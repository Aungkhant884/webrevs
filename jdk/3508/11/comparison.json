{"files":[{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Base info class which provides some useful utility methods and information about a test.\n+ * <p>\n+ * <b>Base tests<\/b> and <b>checked tests<\/b> use {@link TestInfo} while <b>custom run tests<\/b> use {@link RunInfo}.\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ *\/\n+abstract public class AbstractInfo {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    protected final Class<?> testClass;\n+    private boolean onWarmUp = true;\n+\n+    AbstractInfo(Class<?> testClass) {\n+        this.testClass = testClass;\n+    }\n+\n+    \/**\n+     * Get the initialized {@link Random} object.\n+     *\n+     * @return the random object.\n+     *\/\n+    public Random getRandom() {\n+        return RANDOM;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the framework is currently warming up the associated test.\n+     *\n+     * @return the warm-up status of the associated test.\n+     *\n+     * @see Warmup\n+     *\/\n+    public boolean isWarmUp() {\n+        return onWarmUp;\n+    }\n+\n+    \/**\n+     * Get the method object of the method {@code name} of class {@code c} with arguments {@code args}.\n+     *\n+     * @param c    the class containing the method.\n+     * @param name the name of the method.\n+     * @param args the arguments of the method, leave empty if no arguments.\n+     *\n+     * @return the method object of the requested method.\n+     *\/\n+    public Method getMethod(Class<?> c, String name, Class<?>... args) {\n+        try {\n+            return c.getMethod(name, args);\n+        } catch (NoSuchMethodException e) {\n+            String parameters = args == null || args.length == 0 ? \"\" :\n+                    \" with arguments [\" + Arrays.stream(args).map(Class::getName).collect(Collectors.joining(\",\")) + \"]\";\n+            throw new TestRunException(\"Could not find method \" + name + \" in \" + c + parameters, e);\n+        }\n+    }\n+\n+    \/**\n+     * Get the method object of the method {@code name} of the test class with arguments {@code args}.\n+     *\n+     * @param name the name of the method in the test class.\n+     * @param args the arguments of the method, leave empty if no arguments.\n+     *\n+     * @return the method object of the requested method in the test class.\n+     *\/\n+    public Method getTestClassMethod(String name, Class<?>... args) {\n+        return getMethod(testClass, name, args);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the test VM runs with flags that allow C2 compilations.\n+     *\n+     * @return {@code true} if C2 compilations are allowed;\n+     *         {@code false} otherwise (run with {@code -XX:TieredStopAtLevel={1,2,3}, -XX:-UseCompiler}).\n+     *\/\n+    public boolean isC2CompilationEnabled() {\n+        return TestVM.USE_COMPILER && !TestVM.TEST_C1;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} when the warm-up is finished. Should not be called by user code.\n+     *\/\n+    public void setWarmUpFinished() {\n+        onWarmUp = false;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/AbstractInfo.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Well-defined argument values that can be used in the {@link Arguments} annotation at a {@link Test} method for a\n+ * <b>base test<\/b> or a <b>checked test<\/b>.\n+ *\n+ * @see Arguments\n+ * @see Test\n+ * @see Check\n+ *\/\n+public enum Argument {\n+    \/**\n+     * Provides the default value for any kind of primitive type and object type if the class provides a default constructor.\n+     *\/\n+    DEFAULT,\n+    \/**\n+     * Provides the number 42 for any primitive number type.\n+     *\/\n+    NUMBER_42,\n+    \/**\n+     * Provides the number -42 for any primitive number type.\n+     *\/\n+    NUMBER_MINUS_42,\n+    \/**\n+     * Provides the minimum value of the specified primitive number type.\n+     *\/\n+    MIN,\n+    \/**\n+     * Provides the maximum value of the specified primitive number type.\n+     *\/\n+    MAX,\n+    \/**\n+     * Provides the boolean value false.\n+     *\/\n+    FALSE,\n+    \/**\n+     * Provides the boolean value true.\n+     *\/\n+    TRUE,\n+    \/**\n+     * Provides a different boolean value on each test invocation, starting with false.\n+     *\/\n+    BOOLEAN_TOGGLE_FIRST_FALSE,\n+    \/**\n+     * Provides a different boolean value on each test invocation, starting with true.\n+     *\/\n+    BOOLEAN_TOGGLE_FIRST_TRUE,\n+    \/**\n+     * Provides a random primitive value on the first test invocation and reuses the same value for all invocation of the test.\n+     * Float and double values are restricted to the range [-10000,10000].\n+     *\/\n+    RANDOM_ONCE,\n+    \/**\n+     * Provides a different random primitive value on each test invocation.\n+     * Float and double values are restricted to the range [-10000,10000].\n+     *\/\n+    RANDOM_EACH,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Argument.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation is used to specify well-defined {@link Argument} values for test methods (specifying {@link Test}) when\n+ * used as part of a <b>base test<\/b> or <b>checked test<\/b>.\n+ *\n+ * @see Argument\n+ * @see Test\n+ * @see Check\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Arguments {\n+    \/**\n+     * Get the argument value.\n+     *\/\n+    Argument[] value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Arguments.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation for a check method of a <b>checked test<\/b>.\n+ *\n+ * <p>\n+ * Let {@code t} be a test method specifying the {@link Test @Test} annotation and {@code c} be a check method specifying\n+ * the {@code @Check(test = \"t\")} annotation. These two methods represent a so-called <i>checked test<\/i>. The only\n+ * difference to a <i>base test<\/i> (see {@link Test}) is that the framework will invoke the check method {@code c}\n+ * directly after the invocation of the test method {@code t} which allows to do some additional verification,\n+ * including the return value of {@code t}. The framework does the following, similar as for <i>base tests<\/i>:\n+ * <ol>\n+ *     <li><p>The framework warms {@code t} up by invoking it for a predefined number of iterations (default: 2000)\n+ *            or any number specified by an additional {@link Warmup @Warmup} annotation at {@code t} or by using\n+ *            {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is\n+ *            similar to simulating {@code -Xcomp}). After each invocation of {@code t}, the framework also invokes\n+ *            {@code c} if the {@code @Check} annotation specifies {@link CheckAt#EACH_INVOCATION} at {@link #when()}.\n+ *            More information about the warm-up in general can be found at {@link Warmup}<\/li>\n+ *     <li><p>After the warm-up, the framework compiles {@code t} at the specified compilation level set by\n+ *            {@link Test#compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is\n+ *            usually {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes {@code t} one more time to run the compilation. Afterwards, the framework will\n+ *            always invoke {@code c} again to be able perform additional checks after the compilation of {@code t}.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at the test method {@code t}.\n+ *            More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * The test method {@code t} has the same properties and follows the same constraints as stated in {@link Test}.\n+ * <p>\n+ * The following additional constraints must be met for the test method {@code t} and check method {@code c}:\n+ * <ul>\n+ *     <li><p>{@code c} must specify the method name {@code t} as property in {@code @Check(test = \"t\")}\n+ *     (see {@link #test()}. Specifying a non-{@code @Test} annotated method or a {@code @Test} method that\n+ *     has already been used by another {@code @Check} or {@link Run @Run} method results in a {@link TestFormatException}.\n+ *     <li><p>{@code c} can specify the following method parameter combinations:\n+ *     <ul>\n+ *         <li><p>void<\/li>\n+ *         <li><p>One parameter: {@link TestInfo} which provides some information about {@code t} and utility methods.<\/li>\n+ *         <li><p>One parameter: the <i>exact<\/i> same type as the return value of {@code t}. When {@code c} is\n+ *                invoked by the framework, this parameter contains the return value of {@code t}.<\/li>\n+ *         <li><p>1st parameter: {@link TestInfo}; 2nd parameter: the <i>exact<\/i> same type as the return value of\n+ *                {@code t} (see above)<\/li>\n+ *         <li><p> Any other combination will result in a {@link TestFormatException}.\n+ *     <\/ul>\n+ *     <li><p>{@code c} is not compiled nor inlined.\n+ *     <li><p>{@code c} must be part of the test class. Using {@code @Check} in nested or other classes is not allowed.<\/li>\n+ *     <li><p>{@code c} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * If no verification is required, use a <i>base test<\/i> (see {@link Test}). If {@code t} must be invoked with more\n+ * complex or varying arguments and\/or the {@code t} must be invoked differently in subsequent invocations, use a\n+ * <i>custom run test<\/i> (see {@link Run}).\n+ *\n+ * <p>\n+ * Examples on how to write checked tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.CheckedTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Test\n+ * @see TestInfo\n+ * @see CheckAt\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Check {\n+    \/**\n+     * The unique associated {@link Test} method for this {@code @Check} annotated check method. The framework will directly\n+     * invoke the {@code @Check} method after each invocation or only after the compilation of the associated {@code @Test}\n+     * method (depending on the value set with {@link #when()}).\n+     * <p>\n+     * If a non-{@code @Test} annotated method or a {@code @Test} method that has already been used by another\n+     * {@code @Check} or {@link Run} method is specified, then a {@link TestFormatException} is thrown.\n+     *\n+     * @see Test\n+     *\/\n+    String test();\n+    \/**\n+     * When should the {@code @Check} method be invoked? By default, the check is done after each invocation which is\n+     * encouraged if performance is not critical.\n+     *\n+     * @see CheckAt\n+     *\/\n+    CheckAt when() default CheckAt.EACH_INVOCATION;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Check.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * This enum is used in {@link Check#when()} of a <b>checked test<\/b> to specify when the framework will invoke the\n+ * check method after invoking the associated {@link Test} method.\n+ *\n+ * @see Check\n+ * @see Test\n+ *\/\n+public enum CheckAt {\n+    \/**\n+     * Default: Invoke the {@link Check} method each time after invoking the associated {@link Test} method.\n+     *\/\n+    EACH_INVOCATION,\n+    \/**\n+     * Invoke the {@link Check} method only once after the warm-up of the associated {@link Test} method had been completed\n+     * and the framework has compiled the associated {@link Test} method.\n+     *\/\n+    COMPILED,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CheckAt.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Executable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * Compilation levels used by the framework to initiate a compilation of a method. The compilation levels map to the used\n+ * levels in HotSpot (apart from the framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot\n+ * be found in HotSpot). The HotSpot specific levels must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+ *\n+ * <p>\n+ * The compilation levels can be specified in the {@link Test}, {@link ForceCompile}, and\n+ * {@link ForceCompileClassInitializer} annotation.\n+ *\n+ * @see Test\n+ * @see ForceCompile\n+ * @see ForceCompileClassInitializer\n+ *\/\n+public enum CompLevel {\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. After the warm-up, the framework keeps invoking the test over a span\n+     * of 10s (configurable by setting the property flag {@code -DWaitForCompilationTimeout}) until HotSpot compiles the\n+     * {@link Test} method. If the method was not compiled after 10s, an exception is thrown. The framework does not wait\n+     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n+     * {@code -DExcludeRandom=true}.\n+     *\/\n+    WAIT_FOR_COMPILATION(-4),\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. Skip a compilation of the {@link Test @Test} method completely.\n+     *\/\n+    SKIP(-3),\n+    \/**\n+     *  Use any compilation level depending on the usage:\n+     *  <ul>\n+     *      <li><p>{@link Test @Test}, {@link ForceCompile @ForceCompile}: Use the highest available compilation level\n+     *      which is usually C2.<\/li>\n+     *      <li><p>{@link DontCompile @DontCompile}: Prevents any compilation of the associated helper method.<\/li>\n+     *  <\/ul>\n+     *\/\n+    ANY(-1),\n+    \/**\n+     *  Compilation level 1: C1 compilation without any profile information.\n+     *\/\n+    C1_SIMPLE(1),\n+    \/**\n+     *  Compilation level 2: C1 compilation with limited profile information: Includes Invocation and backedge counters.\n+     *\/\n+    C1_LIMITED_PROFILE(2),\n+    \/**\n+     *  Compilation level 3: C1 compilation with full profile information: Includes Invocation and backedge counters with MDO.\n+     *\/\n+    C1_FULL_PROFILE(3),\n+    \/**\n+     * Compilation level 4: C2 compilation with full optimizations.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private static final Map<Integer, CompLevel> TYPES_BY_VALUE = new HashMap<>();\n+    private final int value;\n+\n+    static {\n+        for (CompLevel level : CompLevel.values()) {\n+            TYPES_BY_VALUE.put(level.value, level);\n+        }\n+    }\n+\n+    CompLevel(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+\n+    \/**\n+     * Get the compilation level enum from the specified integer.\n+     *\n+     * @param value the compilation level as integer.\n+     * @throws TestRunException if {@code value} does not specify a valid compilation level.\n+     * @return the compilation level enum for {@code value}.\n+     *\/\n+    public static CompLevel forValue(int value) {\n+        CompLevel level = TYPES_BY_VALUE.get(value);\n+        TestRun.check(level != null, \"Invalid compilation level \" + value);\n+        return level;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to check if this compilation level is not part of the compiler.\n+     *\/\n+    public boolean isNotCompilationLevelOfCompiler(Compiler c) {\n+        return switch (c) {\n+            case C1 -> !isC1();\n+            case C2 -> this != C2;\n+            default -> throw new TestFrameworkException(\"Should not be called with compiler \" + c);\n+        };\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to flip compilation levels.\n+     *\/\n+    public CompLevel flipCompLevel() {\n+        switch (this) {\n+            case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n+                return CompLevel.C2;\n+            }\n+            case C2 -> {\n+                return CompLevel.C1_SIMPLE;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework}. Return the compilation level when only allowing a compilation with the specified\n+     * compiler.\n+     *\/\n+    public CompLevel excludeCompilationRandomly(Executable ex) {\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            \/\/ No exclusion\n+            return this;\n+        }\n+        Compiler compiler = TestVM.excludeRandomly(ex);\n+        return switch (compiler) {\n+            case ANY -> SKIP;\n+            case C1 -> isC1() ? SKIP : this;\n+            case C2 -> this == C2 ? SKIP : this;\n+        };\n+    }\n+\n+    private boolean isC1() {\n+        return this == C1_SIMPLE || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompLevel.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Compilers to select for {@link DontCompile}. HotSpot does not handle the exclusion of a C1 method at a specific level.\n+ * It can only exclude a method for the entire C1 compilation. Thus, this annotation is provided for {@link DontCompile}\n+ * instead of {@link CompLevel}.\n+ *\n+ * @see DontCompile\n+ *\/\n+public enum Compiler {\n+    \/**\n+     * Selecting both the C1 and C2 compiler. This must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+     *\/\n+    ANY(-1),\n+    \/**\n+     * The C1 compiler.\n+     *\/\n+    C1(1),\n+    \/**\n+     * The C2 compiler.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private final int value;\n+\n+    Compiler(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Compiler.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Prevent a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test},\n+ * {@link Check @Check} or {@link Run @Run}) with the specified compiler.\n+ *\n+ * <ul>\n+ *     <li><p>{@link Compiler#ANY} (default): No C1 or C2 compilation.<\/li>\n+ *     <li><p>{@link Compiler#C1}: No C1 compilation, C2 compilation still possible.<\/li>\n+ *     <li><p>{@link Compiler#C2}: No C2 compilation, C1 compilation still possible.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Using this annotation on <i>non-helper methods<\/i> results in a {@link TestFormatException TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface DontCompile {\n+    \/**\n+     * The compiler with which a compilation of a helper method is excluded.\n+     *\/\n+    Compiler value() default Compiler.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontCompile.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Prevent an inlining of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Run @Run}). <i>Non-helper methods<\/i> are never inlined. Explicitly using this annotation on\n+ * <i>non-helper methods<\/i> results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface DontInline {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontInline.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Test @Run}) immediately at the specified level. {@link CompLevel#SKIP} and\n+ * {@link CompLevel#WAIT_FOR_COMPILATION} do not apply and result in a {@link TestFormatException}.\n+ *\n+ * <p>\n+ * Using this annotation on <i>non-helper<\/i> methods also results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceCompile {\n+    \/**\n+     * The compilation level to compile the helper method at.\n+     *\/\n+    CompLevel value() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompile.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force a compilation of the static class initializer method ({@code <clinit>}) of the annotated test or helper class\n+ * immediately at the specified level. {@link CompLevel#SKIP} and {@link CompLevel#WAIT_FOR_COMPILATION} do not apply\n+ * and result in a {@link TestFormatException}.\n+\n+ * <p>\n+ *  Using this annotation on non-classes also results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceCompileClassInitializer {\n+    \/**\n+     * The compilation level to compile the static class initializer method ({@code <clinit>}) at.\n+     *\/\n+    CompLevel value() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompileClassInitializer.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force an inlining of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Test @Run}). Using this annotation on <i>non-helper methods<\/i> results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceInline {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceInline.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation is used to define a constraint\/rule\/check on the resulting IR of a test method (method with\n+ * {@link Test @Test} annotation). A test method can define multiple {@code @IR} rules.\n+ * <p>\n+ * There are two kinds of checks that can be specified:\n+ * <ul>\n+ *     <li><p>{@link #failOn()}: Specify a list of (node) regexes that should not be matched on the {@code PrintIdeal} or\n+ *            {@code PrintOptoAssembly} output.<\/li>\n+ *     <li><p>{@link #counts()}: Specify a list of ({@code regex,count}) pairs: The (node) {@code regex} should be matched\n+ *            for the specified amount in {@code count} on the {@code PrintIdeal} or {@code PrintOptoAssembly} output.<\/li>\n+ * <\/ul>\n+ * An IR rule must specify either or both of these two checks. If one or both of the checks fails, an\n+ * {@link IRViolationException} is thrown. A user can provide a custom regex string or specify any of the default node\n+ * regexes defined in {@link IRNode}.\n+ * <p>\n+ * Sometimes, the shape of the resulting IR is changed by commonly used VM flags in such a way that an IR rule no longer\n+ * applies. Generally, the framework does <b>not<\/b> apply any IR rules when any of the following flags are used:\n+ * {@code -Xint, -XX:-UseCompiler, -XX:TieredStopAtLevel={1,2,3}, -DExcludeRandom=true, -DFlipC1C2=true}.\n+ * Furthermore, a JTreg test could be run with additional VM and Javaoptions flags. The IR verification is <b>not<\/b>\n+ * performed in this case if any of these JTreg flags is used that is not part of the whitelist specified by\n+ * {@link TestFramework#JTREG_WHITELIST_FLAGS}.\n+ * <p>\n+ * For any other flag specified either by user code (e.g. {@link Scenario#Scenario(int, String...)},\n+ * {@link TestFramework#runWithFlags(String...) etc.} or as part of the JTreg whitelist, IR verification is applied.\n+ * To restrict the application of IR rules when certain flags are present that could change the IR, each {@code @IR}\n+ * annotation can specify additional preconditions on the allowed test VM flags that must hold when an IR rule is applied.\n+ * If the specified preconditions fail, then the framework does not apply the IR rule. These preconditions can be\n+ * set with {@link #applyIf()}, {@link #applyIfNot()}, {@link #applyIfAnd()}, or {@link #applyIfOr()}.\n+ * <p>\n+ * Examples on how to write tests with IR rules can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.IRExample}\n+ * and also as part of the internal testing in {@link jdk.test.lib.hotspot.ir_framework.tests.TestIRMatching}.\n+ *\n+ * @see Test\n+ * @see IRNode\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Repeatable(IRs.class)\n+public @interface IR {\n+    \/**\n+     * Define a list of (node) regexes. If any of these regexes are matched on the PrintIdeal or PrintOptoAssembly, the\n+     * IR rule fails and an {@link IRViolationException} is thrown.\n+     *\/\n+    String[] failOn() default {};\n+\n+    \/**\n+     * Define a list of ((node) regexes,count) string pairs: A regex to be matched on the PrintIdeal or PrintOptoAssembly\n+     * is immediately followed by a number specifying how often the regex should be matched. The number can be proceeded\n+     * by comparators ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is\n+     * specified).\n+     * <p>\n+     * If any constraint on the number of regexes cannot be met, the IR rule fails and an\n+     * {@link IRViolationException} is thrown.\n+     *\/\n+    String[] counts() default {};\n+\n+    \/**\n+     * Define a single VM flag precondition which <i>must hold<\/i> when applying the IR rule. If the VM flag precondition\n+     * fails, then the IR rule is not applied. This is useful if a commonly used flag alters the IR in such a way that an IR rule\n+     * would fail.\n+     * <p>\n+     * The precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * This is the inverse of {@link #applyIfNot()}. For multiple preconditions, use {@link #applyIfAnd()} or\n+     * {@link #applyIfOr()} depending on the use case.\n+     *\/\n+    String[] applyIf() default {};\n+\n+    \/**\n+     * Define a single VM flag precondition which <i>must <b>not<\/b> hold<\/i> when applying the IR rule. If, however,\n+     * the VM flag precondition holds, then the IR rule is not applied. This could also be defined as <i>negative<\/i>\n+     * precondition. This is useful if a commonly used flag alters the IR in such a way that an IR rule would fail.\n+     * <p>\n+     * The precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * This is the inverse of {@link #applyIf()}. For multiple preconditions, use {@link #applyIfAnd()} or\n+     * {@link #applyIfOr()} depending on the use case.\n+     *\/\n+    String[] applyIfNot() default {};\n+\n+    \/**\n+     * Define a list of at least two VM flag precondition which <i><b>all<\/b> must hold<\/i> when applying the IR rule.\n+     * If the one of the VM flag preconditions does not hold, then the IR rule is not applied. This is useful if\n+     * commonly used flags alter the IR in such a way that an IR rule would fail. This can also be defined as conjunction\n+     * of preconditions.\n+     * <p>\n+     * A precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * Use  {@link #applyIfOr()} for disjunction and for single precondition constraints use {@link #applyIf()} or\n+     * {@link #applyIfNot()} depending on the use case.\n+     *\/\n+    String[] applyIfAnd() default {};\n+\n+    \/**\n+     * Define a list of at least two VM flag precondition from which <i><b>at least one<\/b> must hold<\/i> when applying\n+     * the IR rule. If none of the VM flag preconditions holds, then the IR rule is not applied. This is useful if\n+     * commonly used flags alter the IR in such a way that an IR rule would fail. This can also be defined as disjunction\n+     * of preconditions.\n+     * <p>\n+     * A precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * Use  {@link #applyIfAnd()} for conjunction and for single precondition constraints use {@link #applyIf()} or\n+     * {@link #applyIfNot()} depending on the use case.\n+     *\/\n+    String[] applyIfOr() default {};\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRMatcher;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class provides default regex strings that can be used in {@link IR @IR} annotations to specify IR constraints.\n+ * <p>\n+ * There are two types of default regexes:\n+ * <ul>\n+ *     <li><p>Standalone regexes: Use them directly.<\/li>\n+ *     <li><p>Composite regexes: Their names contain \"{@code _OF}\" and expect another string in a list in\n+ *            {@link IR#failOn()} and {@link IR#counts()}. They cannot be use as standalone regex and will result in a\n+ *            {@link TestFormatException} when doing so.<\/li>\n+ * <\/ul>\n+ *\n+ * @see IR\n+ *\/\n+public class IRNode {\n+    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    private static final String MID = \".*)+(\\\\s){2}===.*\";\n+    private static final String END = \")\";\n+\n+    public static final String ALLOC = \"(.*precise klass .*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_OF = \"(.*precise klass .*\";\n+    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n+    public static final String ALLOC_ARRAY_OF = \"(.*precise klass \\\\[L.*\";\n+\n+    public static final String CHECKCAST_ARRAY = \"(cmp.*precise klass \\\\[.*;:\" + END;\n+    public static final String CHECKCAST_ARRAY_OF = \"(cmp.*precise klass \\\\[.*\";\n+    public static final String CHECKCAST_ARRAYCOPY = \"(.*call_leaf_nofp,runtime  checkcast_arraycopy.*\" + END;\n+\n+    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n+\n+    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n+    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n+    public static final String STORE_C = START + \"StoreC\" + MID + END;\n+    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n+    public static final String STORE_L = START + \"StoreL\" + MID + END;\n+    public static final String STORE_F = START + \"StoreF\" + MID + END;\n+    public static final String STORE_D = START + \"StoreD\" + MID + END;\n+    public static final String STORE_P = START + \"StoreP\" + MID + END;\n+    public static final String STORE_N = START + \"StoreN\" + MID + END;\n+    public static final String STORE_OF_CLASS = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n+    public static final String STORE_B_OF_CLASS = START + \"StoreB\" + MID + \"@\\\\S*\";\n+    public static final String STORE_C_OF_CLASS = START + \"StoreC\" + MID + \"@\\\\S*\";\n+    public static final String STORE_I_OF_CLASS = START + \"StoreI\" + MID + \"@\\\\S*\";\n+    public static final String STORE_L_OF_CLASS = START + \"StoreL\" + MID + \"@\\\\S*\";\n+    public static final String STORE_F_OF_CLASS = START + \"StoreF\" + MID + \"@\\\\S*\";\n+    public static final String STORE_D_OF_CLASS = START + \"StoreD\" + MID + \"@\\\\S*\";\n+    public static final String STORE_P_OF_CLASS = START + \"StoreP\" + MID + \"@\\\\S*\";\n+    public static final String STORE_N_OF_CLASS = START + \"StoreN\" + MID + \"@\\\\S*\";\n+    public static final String STORE_OF_FIELD = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+\n+    public static final String LOAD = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + END;\n+    public static final String LOAD_B = START + \"LoadB\" + MID + END;\n+    public static final String LOAD_UB = START + \"LoadUB\" + MID + END; \/\/ Load from boolean\n+    public static final String LOAD_S = START + \"LoadS\" + MID + END;\n+    public static final String LOAD_US = START + \"LoadUS\" + MID + END; \/\/ Load from char\n+    public static final String LOAD_I = START + \"LoadI\" + MID + END;\n+    public static final String LOAD_L = START + \"LoadL\" + MID + END;\n+    public static final String LOAD_F = START + \"LoadF\" + MID + END;\n+    public static final String LOAD_D = START + \"LoadD\" + MID + END;\n+    public static final String LOAD_P = START + \"LoadP\" + MID + END;\n+    public static final String LOAD_N = START + \"LoadN\" + MID + END;\n+    public static final String LOAD_OF_CLASS = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_B_OF_CLASS = START + \"LoadB\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_UB_OF_CLASS = START + \"LoadUB\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_S_OF_CLASS = START + \"LoadS\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_US_OF_CLASS = START + \"LoadUS\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_I_OF_CLASS = START + \"LoadI\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_L_OF_CLASS = START + \"LoadL\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_F_OF_CLASS = START + \"LoadF\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_D_OF_CLASS = START + \"LoadD\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_P_OF_CLASS = START + \"LoadP\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_N_OF_CLASS = START + \"LoadN\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_OF_FIELD = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+    public static final String LOAD_KLASS  = START + \"LoadK\" + MID + END;\n+\n+    public static final String LOOP   = START + \"Loop\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+\n+    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n+    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n+    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n+    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n+    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n+    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n+    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n+    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n+    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n+    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n+\n+    public static final String SCOPE_OBJECT = \"(.*# ScObj.*\" + END;\n+    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n+\n+\n+    private static final String ALLOC_OF_POSTFIX =  \":.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n+    private static final String ALLOC_ARRAY_OF_POSTFIX = \";:.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n+    private static final String CHECKCAST_ARRAY_OF_POSTFIX = \";:\" + END;\n+    private static final String STORE_OF_FIELD_POSTFIX = \",.*\" + END;\n+    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_FIELD_POSTFIX = \",.*\" + END;\n+\n+    \/**\n+     * Called by {@link IRMatcher} to merge special composite nodes together with additional user-defined input.\n+     *\/\n+    public static List<String> mergeNodes(String[] nodes) {\n+        List<String> mergedNodes = new ArrayList<>();\n+        for (int i = 0; i < nodes.length; i += 2) {\n+            String node = nodes[i];\n+            switch (node) {\n+                case ALLOC_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_OF_POSTFIX, \"ALLOC_OF\");\n+                case ALLOC_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_ARRAY_OF_POSTFIX, \"ALLOC_ARRAY_OF\");\n+                case CHECKCAST_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, CHECKCAST_ARRAY_OF_POSTFIX, \"CHECKCAST_ARRAY_OF\");\n+                case STORE_OF_CLASS, STORE_B_OF_CLASS, STORE_C_OF_CLASS, STORE_D_OF_CLASS, STORE_F_OF_CLASS, STORE_I_OF_CLASS,\n+                        STORE_L_OF_CLASS, STORE_N_OF_CLASS, STORE_P_OF_CLASS\n+                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_CLASS_POSTFIX, \"STORE_OF_CLASS\");\n+                case STORE_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_FIELD_POSTFIX, \"STORE_OF_FIELD\");\n+                case LOAD_OF_CLASS, LOAD_B_OF_CLASS, LOAD_UB_OF_CLASS, LOAD_D_OF_CLASS, LOAD_F_OF_CLASS, LOAD_I_OF_CLASS, LOAD_L_OF_CLASS,\n+                        LOAD_N_OF_CLASS, LOAD_P_OF_CLASS, LOAD_S_OF_CLASS, LOAD_US_OF_CLASS\n+                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_CLASS_POSTFIX, \"LOAD_OF_CLASS\");\n+                case LOAD_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_FIELD_POSTFIX, \"LOAD_OF_FIELD\");\n+                default -> {\n+                    i--; \/\/ No composite node, do not increment by 2.\n+                    mergedNodes.add(node);\n+                }\n+            }\n+        }\n+        return mergedNodes;\n+    }\n+\n+    private static void mergeCompositeNodes(String[] nodes, List<String> mergedNodes, int i, String node, String postFix, String varName) {\n+        TestFormat.check(i + 1 < nodes.length, \"Must provide class name at index \" + (i + 1) + \" right after \" + varName);\n+        mergedNodes.add(node + Pattern.quote(nodes[i + 1]) + postFix);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation to allow to specify multiple {@link IR @IR} annotations at a {@link Test @Test} method.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface IRs {\n+    IR[] value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRs.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+# IR Test Framework\n+This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n+\n+## 1. How to Use the Framework\n+The framework is intended to be used in JTreg tests. The JTreg header of the test must contain `@library \/test\/lib \/` (2 paths) and should be run as a driver with `@run driver`. Annotate the test code with the supported framework annotations and call the framework from within the test's `main()` method. A simple example is shown below:\n+\n+    \/*\n+     * @test\n+     * @summary A simple test using the test framework.\n+     * @library \/test\/lib \/\n+     * @run driver my.package.MySimpleTest\n+     *\/\n+    \n+    package my.package;\n+    \n+    import compiler.lib.ir_framework.*;\n+\n+    public class MySimpleTest {\n+        \n+        public static void main(String[] args) {\n+            TestFramework.run(); \/\/ The framework runs all tests of this class.\n+        }\n+    \n+        @Test\n+        @IR(failOn = IRNode.STORE) \/\/ Fail if the IR of myTest() contains any stores.\n+        public void myTest() {\n+            \/* ... *\/\n+        }\n+    }\n+\n+There are various ways how to set up and run a test within the `main()` method of a JTreg test. These are described and can be found in the [TestFramework](.\/TestFramework.java) class.\n+   \n+## 2. Features\n+ The framework offers various annotations and flags to control how your test code should be invoked and being checked. This section gives an overview over all these features.\n+\n+### 2.1 Different Tests\n+There are three kinds of tests depending on how much control is needed over the test invocation.\n+#### Base Tests\n+The simplest form of testing provides a single `@Test` annotated method which the framework will invoke as part of the testing. The test method has no or well-defined arguments that the framework can automatically provide. \n+\n+More information on base tests with a precise definition can be found in the Javadocs of [Test](.\/Test.java). Concrete examples on how to specify a base test can be found in [BaseTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/BaseTestExample.java).\n+\n+#### Checked Tests\n+The base tests do not provide any way of verification by user code. A checked test enables this by allowing the user to define an additional `@Check` annotated method which is invoked directly after the `@Test` annotated method. This allows the user to perform various checks about the test method including return value verification.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Check](.\/Check.java). Concrete examples on how to specify a checked test can be found in [CheckedTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CheckedTestExample.java).\n+\n+#### Custom Run Tests\n+Neither the base nor the checked tests provide any control over how a `@Test` annotated method is invoked in terms of customized argument values and\/or conditions for the invocation itself. A custom run test gives full control over the invocation of the `@Test` annotated method to the user. The framework calls a dedicated `@Run` annotated method from which the user can invoke the `@Test` method according to his\/her needs.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Run](.\/Run.java). Concrete examples on how to specify a custom run test can be found in [CustomRunTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CustomRunTestExample.java).\n+\n+### 2.2 IR Verification\n+The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. For simplicity, we will refer to the \"IR\" or \"IR matching\" when actually meaning the combined output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ for a C2 compilation.\n+\n+The user has the possibility to add an additional `@IR` annotation to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify a constraint\/rule on the compiled IR shape. The `@IR` annotation provides two kinds of regex checks:\n+\n+ - A `failOn` check that verifies that the provided regex is not matched in the C2 IR.\n+ - A `counts` check that verifies that the provided regex is matched a user defined number of times in the C2 IR.\n+ \n+A regex can either be a custom string or any of the default regexes provided by the framework in [IRNode](.\/IRNode.java) for some commonly used IR nodes (also provides the possibility of composite regexes).\n+\n+An IR verification cannot always be performed. For example, a JTreg test could be run with _-Xint_ or not a debug build (_-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ are debug build flags). But also CI tier testing could add additional JTreg VM and Javaoptions flags which could make an IR rule unstable. \n+\n+In general, the framework will only perform IR verification if the used VM flags allow a C2 compilation and if non-critical additional JTreg VM and Javaoptions are provided (see whiteflag list in [TestFramework](.\/TestFramework.java)). The user test code, however, can specify any flags which still allow an IR verification to be performed if a C2 compilation is done (expected flags by user defined `@IR` annotations). \n+\n+An `@IR` annotation allows additional preconditions\/restrictions on the currently present VM flags to enable or disable rules when certain flags are present or have a specific value (see `applyIfXX` properties of an `@IR` annotation).\n+\n+More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/IRExample.java) and [TestIRMatching](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestIRMatching.java) (an internal framework test).\n+\n+### 2.3 Test VM Flags and Scenarios\n+The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n+\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+\n+### 2.4 Compiler Controls\n+The framework allows the use of additional compiler control annotations for helper method and classes in the same fashion as JMH does. The following annotations are supported and described in the referenced Javadocs for the annotation class:\n+\n+- [@DontInline](.\/DontInline.java)\n+- [@ForceInline](.\/ForceInline.java)\n+- [@DontCompile](.\/DontCompile.java)\n+- [@ForceCompile](.\/DontCompile.java)\n+- [@ForceCompileClassInitializer](.\/ForceCompileClassInitializer.java)\n+\n+### 2.5 Framework Debug and Stress Flags\n+The framework provides various stress and debug flags. They should mainly be used as JTreg VM and\/or Javaoptions (apart from `VerifyIR`). The following (property) flags are supported:\n+\n+- `-DVerifyIR=false`: Explicitly disable IR verification. This is useful, for example, if some scenarios use VM flags that let `@IR` annotation rules fail and the user does not want to provide separate IR rules or add flag preconditions to the already existing IR rules.\n+- `-DTest=test1,test2`: Provide a list of `@Test` method names which should be executed.\n+- `-DExclude=test3`: Provide a list of `@Test` method names which should be excluded from execution.\n+- `-DScenarios=1,2`: Provide a list of scenario indexes to specify which scenarios should be executed.\n+- `-DWarmup=200`: Provide a new default value of the number of warm-up iterations (framework default is 2000). This might have an influence on the resulting IR and could lead to matching failures (the user can also set a fixed default warm-up value in a test with `testFrameworkObject.setDefaultWarmup(200)`).\n+- `-DVerbose=true`: Enable more fain-grained logging (slows the execution down).\n+- `-DReproduce=true`: Flag to use when directly running a test VM to bypass dependencies to the driver VM state (for example, when reproducing an issue).\n+- `-DPrintTimes=true`: Print the execution time measurements of each executed test.\n+- `-DVerifyVM=true`: The framework runs the test VM with additional verification flags (slows the execution down).\n+- `-DExcluceRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n+- `-DFlipC1C2=true`: The framework compiles all `@Test` annotated method with C1 if a C2 compilation would have been applied and vice versa. IR verification is disabled completely with this flag.\n+- `-DShuffleTests=false`: Disables the random execution order of all tests (such a shuffling is always done by default).\n+- `-DDumpReplay=true`: Add the `DumpReplay` directive to the test VM.\n+- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution down).\n+- `-TestCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a normal `@Test` annotated method.\n+- `-DWaitForCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a `@Test` annotated method with compilation level [WAIT\\_FOR\\_COMPILATION](.\/CompLevel.java).\n+- `-DIgnoreCompilerControls=false`: Ignore all compiler controls applied in the framework. This includes any compiler control annotations (`@DontCompile`, `@DontInline`, `@ForceCompile`, `@ForceInline`, `@ForceCompileStaticInitializer`), the exclusion of `@Run` and `@Check` methods from compilation, and the directive to not inline `@Test` annotated methods.\n+\n+\n+## 3. Test Framework Execution\n+This section gives an overview of how the framework is executing a JTreg test that calls the framework from within its `main()` method.\n+\n+The framework will spawn a new \"test VM\" to execute the user defined tests. The test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n+1. Warm the test up for a predefined number of times (default 2000). This can also be adapted for all tests by using `testFrameworkobject.setDefaultWarmup(100)` or for individual tests with an additional [@Warmup](.\/Warmup.java) annotation. \n+2. After the warm-up is finished, the framework compiles the associated `@Test` annotated method at the specified compilation level (default: C2).\n+3. After the compilation, the test is invoked one more time.\n+\n+Once the test VM terminates, IR verification (if possible) is performed on the output of the test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n+\n+Some of the steps above can be different due to the kind of the test or due to using non-default annotation properties. These details and differences are described in the Javadocs for the three tests (see section 2.1 Different Tests).\n+\n+More information about the internals and the workflow of the framework can be found in the Javadocs of [TestFramework](.\/TestFramework.java).  \n+ \n+## 4. Internal Framework Tests\n+There are various tests to verify the correctness of the test framework. These tests can be found in [ir_framework](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework) and can directly be run with JTreg. The tests are part of the normal JTreg tests of HotSpot and should be run upon changing the framework code as a minimal form of testing.\n+\n+Additional testing was performed by converting all compiler Inline Types tests that used the currently present IR test framework in Valhalla (see [JDK-8263024](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8263024)). It is strongly advised to make sure a change to the framework still lets these converted tests in Valhalla pass as part of an additional testing step.\n+\n+## 5. Framework Package Structure\n+A user only needs to import classes from the package `compiler.lib.ir_framework` (e.g. `import compiler.lib.ir_framework.*;`) which represents the interface classes to the framework. The remaining framework internal classes are kept in separate subpackages and should not directly be imported:\n+\n+- `compiler.lib.ir_framework.driver`: These classes are used while running the driver VM (same VM as the one running the user code's `main()` method of a JTreg test).\n+- `compiler.lib.ir_framework.flag`: These classes are used while running the flag VM to determine additional flags for the test VM which are required for IR verification.\n+- `compiler.lib.ir_framework.test`: These classes are used while running the test VM (i.e. the actual execution of the user tests as described in section 3).\n+- `compiler.lib.ir_framework.shared`: These classes can be called from either the driver, flag, or test VM.\n+\n+## 6. Summary\n+ The initial design and feature set was kept simple and straight forward and serves well for small to medium sized tests. There are a lot of possibilities to further enhance the framework and make it more powerful. This can be tackled in additional RFEs. A few ideas can be found as subtasks of the [initial RFE](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8254129) for this framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation for a run method of a <b>custom run test<\/b>.\n+ *\n+ * <p>\n+ * Let {@code t} be a test method specifying the {@link Test @Test} annotation and {@code r} be a run method specifying\n+ * the {@code @Run(test = \"t\")} annotation. These two methods represent a so-called <i>custom run test<\/i>. The only\n+ * difference to a <i>base test<\/i> (see {@link Test}) is that the framework will not invoke the test method {@code t}\n+ * but instead the run method {@code r} which is then responsible to invoke {@code t} in any way and optionally do any\n+ * additional verification (e.g. of the return value). If {@code r} does not specify {@link RunMode#STANDALONE} as\n+ * {@link #mode()} property, the framework does the following, similar as for <i>base tests<\/i>:\n+ * <ol>\n+ *     <li><p>The framework warms {@code r} up by invoking it for a predefined number of iterations (default: 2000)\n+ *            or any number specified by an additional {@link Warmup} annotation at the run method {@code r} or by using\n+ *            {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is\n+ *            similar to simulating {@code -Xcomp}). More information about the warm-up in general can be found in\n+ *            {@link Warmup @Warmup}.<\/li>\n+ *     <li><p>After the warm-up, the framework compiles the test method {@code t} at the specified compilation level set by\n+ *            {@link Test#compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is usually\n+ *            {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes the run method {@code r} one more time to check the compilation.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at the test method {@code t}.\n+ *            More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ *  If {@code r} specifies {@link RunMode#STANDALONE} as {@link #mode()} property, the framework gives complete\n+ *  control to the run method {@code r}:\n+ * <ol>\n+ *     <li><p>The framework invokes the run method {@code r} only one time without any warm-up or compilation of\n+ *            {@code t} ({@link Warmup @Warmup} is not allowed at {@code r} in this case).<\/li>\n+ *     <li><p>After this single invocation, the framework directly checks any specified {@link IR} constraints at the test\n+ *            method {@code t}. The run method {@code r} needs to make sure to reliably trigger a C2 compilation. Otherwise,\n+ *            IR matching will fail. More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * The test method {@code t} and run method {@code r} have the following properties:\n+ * <ul>\n+ *     <li><p>{@code t} can specify any parameter or return type except {@link AbstractInfo} or any of its subclasses.<\/li>\n+ *     <li><p>{@code t} is not inlined.\n+ *     <li><p>{@code r} is not compiled nor inlined.\n+ *     <li><p>{@code r} is responsible to invoke {@code t} in any way (once, multiple times or even skipping on some\n+ *                      invocations of {@code r}).\n+ *     <li><p>{@code r} can specify the following method parameter combinations:\n+ *     <ul>\n+ *         <li><p>void<\/li>\n+ *         <li><p>One parameter: {@link RunInfo} which provides some information about {@code t} and utility methods.<\/li>\n+ *         <li><p>Any other combination will result in a {@link TestFormatException}.\n+ *     <\/ul>\n+ *     <li><p>{@code t} and {@code r} must be part of the test class. Using {@code @Run} and {@code @Test} in nested or\n+ *             other helper classes is not allowed.<\/li>\n+ *     <li><p>{@code t} and {@code r} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * Examples on how to write custom run tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.CustomRunTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Test\n+ * @see RunInfo\n+ * @see RunMode\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Run {\n+    \/**\n+     * The associated {@link Test @Test} methods (one or more) for this {@code @Run} annotated run method.\n+     * The framework directly invokes the run method instead of the associated {@code @Test} methods.\n+     *\/\n+    String[] test();\n+\n+    \/**\n+     * The mode of this custom run test.\n+     *\n+     * @see RunMode\n+     *\/\n+    RunMode mode() default RunMode.NORMAL;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Run.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Test info class which provides some useful utility methods and information about a <b>custom run test<\/b>.\n+ *\n+ * @see Run\n+ *\/\n+public class RunInfo extends AbstractInfo {\n+    private final Method testMethod;\n+    private final DeclaredTest test;\n+    private final Map<String, DeclaredTest> tests;\n+    private final boolean hasMultipleTests;\n+\n+    public RunInfo(List<DeclaredTest> tests) {\n+        super(tests.get(0).getTestMethod().getDeclaringClass());\n+        this.test = tests.get(0);\n+        this.testMethod = test.getTestMethod();\n+        this.hasMultipleTests = tests.size() != 1;\n+        if (hasMultipleTests) {\n+            this.tests = new HashMap<>();\n+            for (DeclaredTest test : tests) {\n+                this.tests.put(test.getTestMethod().getName(), test);\n+            }\n+        } else {\n+            this.tests = null;\n+        }\n+    }\n+\n+    \/**\n+     * Get the associated test method object of this custom run test. This method can only be called if <i>one<\/i> test\n+     * method is specified in the custom run test ({@link Run#test()}). Otherwise, use {@link #getTest(String)}.\n+     *\n+     * @return the associated test method object.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public Method getTest() {\n+        checkSingleTest(\"getTest\");\n+        return testMethod;\n+    }\n+\n+    \/**\n+     * Get the associated method object of the test method with the name {@code testName}. This method can only be called\n+     * if the custom run test specifies more than one test method in ({@link Run#test()}). Otherwise, use {@link #getTest()}.\n+     *\n+     * @param testName the test method for which the method object should be returned.\n+     * @return the associated test method object with the name {@code testName}.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public Method getTest(String testName) {\n+        checkMultipleTests(\"getTest\");\n+        return getMethod(testName);\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation of the associated test method after the warm-up\n+     * due to VM flags not allowing a compilation on the requested level in {@link Test#compLevel()}. This method can only\n+     * be called if <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isCompilationSkipped(String)}.\n+     *\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isCompilationSkipped() {\n+        checkSingleTest(\"isCompilationSkipped\");\n+        return test.getCompLevel() == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation of the associated test method with the name\n+     * {@code testName} after the warm-up due to VM flags not allowing a compilation on the requested level in\n+     * {@link Test#compLevel()}. This method can only be called if the custom run test specifies more than one test method\n+     * in ({@link Run#test()}). Otherwise, use {@link #isCompilationSkipped()}.\n+     *\n+     * @param testName the test method for which the method object should be returned.\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isCompilationSkipped(String testName) {\n+        checkMultipleTests(\"isCompilationSkipped\");\n+        return getDeclaredTest(testName).getCompLevel() == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C1 compiled. This method can only be called if\n+     * <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isTestC1Compiled(String)}.\n+     *\n+     * @return {@code true} if the associated test method is C1 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestC1Compiled() {\n+        checkSingleTest(\"isTestC1Compiled\");\n+        return TestVM.isC1Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is C1 compiled.\n+     * This method can only be called if the custom run test specifies more than one test method in ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestC1Compiled()}.\n+     *\n+     * @param testName the name of the test method.\n+     * @return {@code true} if the test method with the name {@code testName} is C1 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestC1Compiled(String testName) {\n+        checkMultipleTests(\"isTestC1Compiled\");\n+        return TestVM.isC1Compiled(getMethod(testName));\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C2 compiled. This method can only be called if\n+     * <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isTestC2Compiled(String)}.\n+     *\n+     * @return {@code true} if the associated test method is C2 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestC2Compiled() {\n+        checkSingleTest(\"isTestC2Compiled\");\n+        return TestVM.isC2Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is C2 compiled.\n+     * This method can only be called if the custom run test specifies more than one test method in ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestC2Compiled()}.\n+     *\n+     * @param testName the name of the test method.\n+     * @return {@code true} if the test method with the name {@code testName} is C2 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestC2Compiled(String testName) {\n+        checkMultipleTests(\"isTestC2Compiled\");\n+        return TestVM.isC2Compiled(getMethod(testName));\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}. This method can only\n+     * be called if <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestCompiledAtLevel(String, CompLevel)}.\n+     *\n+     * @param compLevel the compilation level\n+     * @return {@code true} if the associated test method is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestCompiledAtLevel(CompLevel compLevel) {\n+        checkSingleTest(\"isTestCompiledAtLevel\");\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is compiled at\n+     * {@code compLevel}. This method can only be called if the custom run test specifies more than one test method\n+     * in ({@link Run#test()}). Otherwise, use {@link #isTestCompiledAtLevel(CompLevel)}.\n+     *\n+     * @param testName the name of the test method.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if the test method with the name {@code testName} is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} oor if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestCompiledAtLevel(String testName, CompLevel compLevel) {\n+        checkMultipleTests(\"isTestCompiledAtLevel\");\n+        return TestVM.isCompiledAtLevel(getMethod(testName), compLevel);\n+    }\n+\n+    private void checkSingleTest(String calledMethod) {\n+        if (hasMultipleTests) {\n+            throw new TestRunException(\"Use \" + calledMethod + \"(String) with testName String argument in @Run method \" +\n+                                       \"for custom run test that specifies more than one @Test method.\");\n+        }\n+    }\n+\n+    private void checkMultipleTests(String calledMethod) {\n+        if (!hasMultipleTests) {\n+            throw new TestRunException(\"Use \" + calledMethod + \"() without testName String argument in @Run method \" +\n+                                       \"for custom run test that specifies exactly one @Test method.\");\n+        }\n+    }\n+\n+    private DeclaredTest getDeclaredTest(String testName) {\n+        DeclaredTest test = tests.get(testName);\n+        if (test == null) {\n+            throw new TestRunException(\"Could not find @Test \\\"\" + testName + \"\\\" in \" + testClass + \" being associated with\" +\n+                                       \" corresponding @Run method.\");\n+        }\n+        return test;\n+    }\n+\n+    private Method getMethod(String testName) {\n+        return getDeclaredTest(testName).getTestMethod();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunInfo.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * The run mode for a <b>custom run test<\/b> specified in {@link Run#mode}.\n+ *\n+ * @see Run\n+ *\/\n+public enum RunMode {\n+    \/**\n+     * Default mode: First warm up the run method (if a warm-up is done), then compile the associated {@link Test}\n+     * method and finally invoke the run method once more.\n+     *\/\n+    NORMAL,\n+    \/**\n+     * Standalone mode: There is no warm-up and no compilation done by the framework. The run method is responsible to\n+     * trigger the compilation(s), especially in regard of possible {@link IR} annotations at the associated {@link Test}\n+     * method.\n+     *\/\n+    STANDALONE,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunMode.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents a scenario that can be executed by the {@link TestFramework}.\n+ * <p>\n+ * A JTreg test should use the test framework with {@code @run driver} (without directly specify any additional flags).\n+ * If a test should run with additional flags, use {@link TestFramework#runWithFlags(String...)} or\n+ * {@link TestFramework#addFlags(String...)}. If, however, the test should be run with different settings (equivalent\n+ * to having multiple {@code @run} entries in a normal JTreg test), use scenarios. A scenario will be run with the\n+ * scenario specific VM flags, if any, and optionally specified VM flags with {@link TestFramework#addFlags(String...)}\n+ * whereas scenario VM flags will have precedence.\n+ * <p>\n+ * There is also the possibility to specify additional VM flags for all scenarios by using {@code DScenarioFlags}.\n+ *\n+ * @see TestFramework\n+ *\/\n+public class Scenario {\n+    private static final String ADDITIONAL_SCENARIO_FLAGS_PROPERTY = System.getProperty(\"ScenarioFlags\", \"\");\n+    private static final String SCENARIOS_PROPERTY = System.getProperty(\"Scenarios\", \"\");\n+    private static final List<String> ADDITIONAL_SCENARIO_FLAGS;\n+    private static final Set<Integer> ENABLED_SCENARIOS;\n+\n+    private final List<String> flags;\n+    private final int index;\n+    private final boolean enabled;\n+    private String testVMOutput;\n+\n+    static {\n+        if (!SCENARIOS_PROPERTY.isEmpty()) {\n+            var split = SCENARIOS_PROPERTY.split(\"\\\\s*,\\\\s*\");\n+            try {\n+                ENABLED_SCENARIOS = Arrays.stream(split).map(Integer::parseInt).collect(Collectors.toSet());\n+            } catch (NumberFormatException e) {\n+                throw new TestRunException(\"Provided a scenario index in the -DScenario comma-separated list which is not \"\n+                                           + \"a number: \" + SCENARIOS_PROPERTY);\n+            }\n+        } else {\n+            ENABLED_SCENARIOS = Collections.emptySet();\n+        }\n+\n+        ADDITIONAL_SCENARIO_FLAGS = ADDITIONAL_SCENARIO_FLAGS_PROPERTY.isEmpty() ? Collections.emptyList() :\n+                Arrays.asList(ADDITIONAL_SCENARIO_FLAGS_PROPERTY.split(\"\\\\s*,\\\\s*\"));\n+    }\n+\n+    \/**\n+     * Create a scenario with {@code index} that will be run with the additional VM flags specified in {@code flags}\n+     * (or without any if null or parameter not provided).\n+     * <p>\n+     * The scenario {@code index} must be unique to be distinguishable in the stdout and stderr output and when specifying\n+     * {@code -DScenarios} (see {@link Scenario}).\n+     *\n+     * @param index the unique scenario index.\n+     * @param flags the scenario flags or null (i.e. no parameter specified) if no flags should be used.\n+     *\/\n+    public Scenario(int index, String... flags) {\n+        this.index = index;\n+        if (flags != null) {\n+            this.flags = new ArrayList<>(Arrays.asList(flags));\n+            this.flags.addAll(ADDITIONAL_SCENARIO_FLAGS);\n+        } else {\n+            this.flags = new ArrayList<>();\n+        }\n+        this.enabled = ENABLED_SCENARIOS.isEmpty() || ENABLED_SCENARIOS.contains(index);\n+    }\n+\n+    \/**\n+     * Add additional VM flags to this scenario.\n+     *\n+     * @param flags the additional scenario VM flags.\n+     *\/\n+    public void addFlags(String... flags) {\n+        if (flags != null) {\n+            this.flags.addAll(Arrays.asList(flags));\n+        }\n+    }\n+\n+    \/**\n+     * Get all scenario specific VM flags as defined in {@link #Scenario(int, String...)}.\n+     *\n+     * @return the scenario VM flags.\n+     *\/\n+    public List<String> getFlags() {\n+        return flags;\n+    }\n+\n+    \/**\n+     * Get the unique scenario index as defined in {@link #Scenario(int, String...)}.\n+     *\n+     * @return the scenario index.\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Get the test VM output (stdout + stderr) of this scenario from the last execution of the framework.\n+     *\n+     * @return the test VM output.\n+     *\/\n+    public String getTestVMOutput() {\n+        return testVMOutput;\n+    }\n+\n+    \/**\n+     * Set the test VM output, called by the framework.\n+     *\/\n+    void setTestVMOutput(String testVMOutput) {\n+        this.testVMOutput = testVMOutput;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if this scenario will be executed by the test framework. This only depends on\n+     * the property flag {@code -DScenarios} (see {@link Scenario}). This is only used by the framework internally.\n+     *\n+     * @return {@code true} if {@code -DScenarios} is either not set or if {@code -DScenarios} specifies the scenario\n+     *         index set by {@link #Scenario(int, String...)}.\n+     *         {@code false} otherwise.\n+     *\/\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Scenario.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotate all methods in your test class which the framework should test with {@code @Test}.\n+ * <p>\n+ * Let {@code m} be a test method specifying the {@code @Test} annotation. If {@code m} is neither part of a\n+ * <b>checked test<\/b> (an additional method specifying {@link Check @Check} with {@code @Check(test = \"m\")}) nor part\n+ * of a <b>custom run test<\/b> (an additional method specifying {@link Run @Run} with {@code @Run(test = \"m\")}),\n+ * then {@code m} is a so-called <b>base test<\/b> and the the framework invokes {@code m} in the following way:\n+ * <ol>\n+ *     <li><p>The framework warms {@code m} up by invoking it for a predefined number of iterations (default: 2000)\n+ *     or any number specified by an additional {@link Warmup @Warmup} annotation at {@code m} or by using\n+ *     {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is similar\n+ *     to simulating {@code -Xcomp}). More information about the warm-up in general can be found at {@link Warmup}<\/li>\n+ *     <li><p>After the warm-up, the framework compiles {@code m} at the specified compilation level set by\n+ *     {@link #compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is usually\n+ *     {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes {@code m} one more time to run the compilation.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at {@code m}. More information about IR matching\n+ *     can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * {@code m} has the following properties:\n+ * <ul>\n+ *     <li><p>If {@code m} specifies no parameters, the framework can directly invoke {@code m}.<\/li>\n+ *     <li><p>If {@code m} specifies parameters, the framework needs to know how to invoke {@code m}. Use {@link Arguments}\n+ *     with {@link Argument} properties for each parameter to use well-defined parameters by the framework. If the method\n+ *     requires a more specific argument value, use a custom run test (see {@link Run}).<\/li>\n+ *     <li><p>{@code m} cannot specify {@link AbstractInfo} or any of its subclasses as parameter or return type.<\/li>\n+ *     <li><p>{@code m} is not inlined by the framework.<\/li>\n+ *     <li><p>Verification of the return value of {@code m} can only be done in a checked test (see {@link Check}) or\n+ *     custom run test (see {@link Run}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * The following constraints must be met for the test method {@code m} specifying {@code @Test}:\n+ * <ul>\n+ *     <li><p>{@code m} must be part of the test class. Using {@code @Test} in nested or helper classes is not allowed.<\/li>\n+ *     <li><p>{@code m} cannot have the same name as another {@code @Test} method in the same test class. Method\n+ *     overloading is only allowed (but not encouraged) with other non-{@code @Test} methods.<\/li>\n+ *     <li><p>{@code m} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}). <\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * Examples on how to write base tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.BaseTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Arguments\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Test {\n+    \/**\n+     * Specify at which compilation level the framework should eventually compile the test method after an optional\n+     * warm-up period. The default {@link CompLevel#ANY} will let the framework compile the method at the highest\n+     * available level which is usually {@link CompLevel#C2}.\n+     *\/\n+    CompLevel compLevel() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Test.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,718 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents the main entry point to the test framework whose main purpose is to perform regex-based checks on\n+ * the C2 IR shape emitted by the VM flags {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}. The framework can\n+ * also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used\n+ * testing patterns and compiler control flags.\n+ * <p>\n+ * The framework offers various annotations to control how your test code should be invoked and being checked. There are\n+ * three kinds of tests depending on how much control is needed over the test invocation:\n+ * <b>Base tests<\/b> (see {@link Test}), <b>checked tests<\/b> (see {@link Check}), and <b>custom run tests<\/b>\n+ * (see {@link Run}). Each type of test needs to define a unique <i>test method<\/i> that specifies a {@link Test @Test}\n+ * annotation which represents the test code that is eventually executed by the test framework. More information about\n+ * the usage and how to write different tests can be found in {@link Test}, {@link Check}, and {@link Run}.\n+ * <p>\n+ * Each test method can specify an arbitrary number of IR rules. This is done by using {@link IR @IR} annotations which\n+ * can define regex strings that are matched on the output of {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}.\n+ * The matching is done after the test method was (optionally) warmed up and compiled. More information about the usage\n+ * and how to write different IR rules can be found at {@link IR}.\n+ * <p>\n+ * This framework should be used with the following JTreg setup in your Test.java file in package <i>some.package<\/i>:\n+ * <pre>\n+ * {@literal @}library \/test\/lib\n+ * {@literal @}run driver some.package.Test\n+ * <\/pre>\n+ * Note that even though the framework uses the Whitebox API internally, it is not required to build and enabel it in the\n+ * JTreg test if the test itself is not utilizing any Whitebox features directly.\n+ * <p>\n+ * To specify additional flags, use {@link #runWithFlags(String...)}, {@link #addFlags(String...)}, or\n+ * {@link #addScenarios(Scenario...)} where the scenarios can also be used to run different flag combinations\n+ * (instead of specifying multiple JTreg {@code @run} entries).\n+ * <p>\n+ * After annotating your test code with the framework specific annotations, the framework needs to be invoked from the\n+ * {@code main()} method of your JTreg test. There are two ways to do so. The first way is by calling the various\n+ * {@code runXX()} methods of {@link TestFramework}. The second way, which gives more control, is to create a new\n+ * {@code TestFramework} builder object on which {@link #start()} needs to be eventually called to start the testing.\n+ * <p>\n+ * The framework is called from the <i>driver VM<\/i> in which the JTreg test is initially run by specifying {@code\n+ * @run driver} in the JTreg header. This strips all additionally specified JTreg VM and Javaoptions.\n+ * The framework creates a new <i>flag VM<\/i> with all these flags added again in order to figure out which flags are\n+ * required to run the tests specified in the test class (e.g. {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}\n+ * for IR matching).\n+ * <p>\n+ * After the flag VM terminates, it starts a new <i>test VM<\/i> which performs the execution of the specified\n+ * tests in the test class as described in {@link Test}, {@link Check}, and {@link Run}.\n+ * <p>\n+ * In a last step, once the test VM has terminated without exceptions, IR matching is performed if there are any IR\n+ * rules and if no VM flags disable it (e.g. not running with {@code -Xint}, see {@link IR} for more details).\n+ * The IR regex matching is done on the output of {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly} by parsing\n+ * the hotspot_pid file of the test VM. Failing IR rules are reported by throwing a {@link IRViolationException}.\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ * @see IR\n+ *\/\n+public class TestFramework {\n+    \/**\n+     * JTreg can define additional VM (-Dtest.vm.opts) and Javaoptions (-Dtest.java.opts) flags. IR verification is only\n+     * performed when all these additional JTreg flags (does not include additionally added framework and scenario flags\n+     * by user code) are whitelisted.\n+     *\n+     * A flag is whitelisted if it is a property flag (starting with -D), -ea, -esa, or if the flag name contains any of\n+     * the entries of this list as a substring (partial match).\n+     *\/\n+    public static final Set<String> JTREG_WHITELIST_FLAGS = new HashSet<>(\n+            Arrays.asList(\n+                    \/\/ The following substrings are part of more than one VM flag\n+                    \"RAM\",\n+                    \"Heap\",\n+                    \"Trace\",\n+                    \"Print\",\n+                    \"Verify\",\n+                    \"TLAB\",\n+                    \"UseNewCode\",\n+                    \"Xmn\",\n+                    \"Xms\",\n+                    \"Xmx\",\n+                    \"Xss\",\n+                    \/\/ The following substrings are only part of one VM flag (=exact match)\n+                    \"CreateCoredumpOnCrash\",\n+                    \"IgnoreUnrecognizedVMOptions\",\n+                    \"UnlockDiagnosticVMOptions\",\n+                    \"UnlockExperimentalVMOptions\",\n+                    \"BackgroundCompilation\",\n+                    \"Xbatch\",\n+                    \"TieredCompilation\",\n+                    \"Xmixed\",\n+                    \"server\",\n+                    \"Xlog\",\n+                    \"LogCompilation\"\n+            )\n+    );\n+\n+    public static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    public static final boolean TESTLIST = !System.getProperty(\"Test\", \"\").isEmpty();\n+    public static final boolean EXCLUDELIST = !System.getProperty(\"Exclude\", \"\").isEmpty();\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+    \/\/ Only used for internal testing and should not be used for normal user testing.\n+    private static final boolean SKIP_WHITEBOX_INSTALL = Boolean.getBoolean(\"SkipWhiteBoxInstall\");\n+\n+    private static final String RERUN_HINT = \"\"\"\n+                                               #############################################################\n+                                                - To only run the failed tests use -DTest, -DExclude,\n+                                                  and\/or -DScenarios.\n+                                                - To also get the standard output of the test VM run with\n+                                                  -DReportStdout=true or for even more fine-grained logging\n+                                                  use -DVerbose=true.\n+                                               #############################################################\n+                                             \"\"\" + System.lineSeparator();\n+\n+    private boolean irVerificationPossible = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private boolean shouldVerifyIR; \/\/ Should we perform IR matching?\n+    private static boolean toggleBool;\n+\n+    private final Class<?> testClass;\n+    private Set<Class<?>> helperClasses;\n+    private List<Scenario> scenarios;\n+    private Set<Integer> scenarioIndices;\n+    private List<String> flags;\n+    private int defaultWarmup = -1;\n+\n+    \/*\n+     * Public interface methods\n+     *\/\n+\n+    \/**\n+     * Creates an instance acting as a builder to test the class from which this constructor was invoked from.\n+     * Use this constructor if you want to use multiple run options (flags, helper classes, scenarios).\n+     * Use the associated add methods ({@link #addFlags(String...)}, {@link #addScenarios(Scenario...)},\n+     * {@link #addHelperClasses(Class...)}) to set up everything and then start the testing by invoking {@link #start()}.\n+     *\/\n+    public TestFramework() {\n+        this(StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass());\n+    }\n+\n+    \/**\n+     * Creates an instance acting as a builder to test {@code testClass}.\n+     * Use this constructor if you want to use multiple run options (flags, helper classes, scenarios).\n+     * Use the associated add methods ({@link #addFlags(String...)}, @link #addScenarios(Scenario...)},\n+     * {@link #addHelperClasses(Class...)}) to set up everything and then start the testing by invoking {@link #start()}.\n+     *\n+     * @param testClass the class to be tested by the framework.\n+     * @see #TestFramework()\n+     *\/\n+    public TestFramework(Class<?> testClass) {\n+        TestRun.check(testClass != null, \"Test class cannot be null\");\n+        this.testClass = testClass;\n+        if (VERBOSE) {\n+            System.out.println(\"Test class: \" + testClass);\n+        }\n+    }\n+\n+    \/**\n+     * Tests the class from which this method was invoked from.\n+     *\/\n+    public static void run() {\n+        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+        run(walker.getCallerClass());\n+    }\n+\n+    \/**\n+     * Tests {@code testClass}.\n+     *\n+     * @param testClass the class to be tested by the framework.\n+     * @see #run()\n+     *\/\n+    public static void run(Class<?> testClass) {\n+        TestFramework framework = new TestFramework(testClass);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Tests the class from which this method was invoked from. The test VM is called with the specified {@code flags}.\n+     * <ul>\n+     *     <li><p>The {@code flags} override any set VM or Javaoptions flags by JTreg by default.<p>\n+     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the JTreg VM and  Javaoptions flags over\n+     *            the specified {@code flags} of this method.<\/li>\n+     *     <li><p>If you want to run your entire JTreg test with additional flags, use this method.<\/li>\n+     *     <li><p>If you want to run your entire JTreg test with additional flags but for another test class then the one\n+     *            from which this method was called from, use {@link #addFlags(String...)}, use this method.<\/li>\n+     *     <li><p>If you want to run your JTreg test with multiple flag combinations, use\n+     *            {@link #addScenarios(Scenario...)}<\/li>\n+     * <\/ul>\n+     *\n+     * @param flags VM flags to be used for the test VM.\n+     *\/\n+    public static void runWithFlags(String... flags) {\n+        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+        TestFramework framework = new TestFramework(walker.getCallerClass());\n+        framework.addFlags(flags);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Add VM flags to be used for the test VM. These flags override any VM or Javaoptions set by JTreg by default.<p>\n+     * Use {@code -DPreferCommandLineFlags=true} if you want to prefer the VM or Javaoptions over the scenario flags.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}\n+     *\n+     * @param flags VM options to be applied to the test VM.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addFlags(String... flags) {\n+        TestRun.check(flags != null && Arrays.stream(flags).noneMatch(Objects::isNull), \"A flag cannot be null\");\n+        if (this.flags == null) {\n+            this.flags = new ArrayList<>();\n+        }\n+        this.flags.addAll(Arrays.asList(flags));\n+        return this;\n+    }\n+\n+    \/**\n+     * Add helper classes that can specify additional compile command annotations ({@link ForceCompile @ForceCompile},\n+     * {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline}, {@link DontInline @DontInline}) to be applied\n+     * while testing {@code testClass} (also see description of {@link TestFramework}).\n+     *\n+     * <p>\n+     * Duplicates in {@code helperClasses} are ignored. If a class is used by the test class that does not specify any\n+     * compile command annotations, you do not need to include it with this method. If no helper class specifies any\n+     * compile commands, you do not need to call this method at all.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}.\n+     *\n+     * @param helperClasses helper classes containing compile command annotations ({@link ForceCompile},\n+     *                      {@link DontCompile}, {@link ForceInline}, {@link DontInline}) to be applied\n+     *                      while testing {@code testClass} (also see description of {@link TestFramework}).\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addHelperClasses(Class<?>... helperClasses) {\n+        TestRun.check(helperClasses != null && Arrays.stream(helperClasses).noneMatch(Objects::isNull),\n+                      \"A Helper class cannot be null\");\n+        if (this.helperClasses == null) {\n+            this.helperClasses = new HashSet<>();\n+        }\n+\n+        this.helperClasses.addAll(Arrays.asList(helperClasses));\n+        return this;\n+    }\n+\n+    \/**\n+     * Add scenarios to be used for the test VM. A test VM is called for each scenario in {@code scenarios} by using the\n+     * specified VM flags in the scenario. The scenario flags override any flags set by {@link #addFlags(String...)}\n+     * and thus also override any VM or Javaoptions set by JTreg by default.<p>\n+     * Use {@code -DPreferCommandLineFlags=true} if you want to prefer the VM and Javaoptions over the scenario flags.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}\n+     *\n+     * @param scenarios scenarios which specify specific flags for the test VM.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addScenarios(Scenario... scenarios) {\n+        TestFormat.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n+                         \"A scenario cannot be null\");\n+        if (this.scenarios == null) {\n+            this.scenarios = new ArrayList<>();\n+            this.scenarioIndices = new HashSet<>();\n+        }\n+\n+        for (Scenario scenario : scenarios) {\n+            int scenarioIndex = scenario.getIndex();\n+            TestFormat.check(scenarioIndices.add(scenarioIndex),\n+                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n+            this.scenarios.add(scenario);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Start the testing of the implicitly (by {@link #TestFramework()}) or explicitly (by {@link #TestFramework(Class)})\n+     * set test class.\n+     *\/\n+    public void start() {\n+        if (!SKIP_WHITEBOX_INSTALL) {\n+            installWhiteBox();\n+        }\n+        disableIRVerificationIfNotFeasible();\n+\n+        if (scenarios == null) {\n+            try {\n+                start(null);\n+            } catch (TestVMException e) {\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + RERUN_HINT);\n+                throw e;\n+            } catch (IRViolationException e) {\n+                System.out.println(\"Compilation(s) of failed match(es):\");\n+                System.out.println(e.getCompilations());\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + System.lineSeparator() + RERUN_HINT);\n+                throw e;\n+            }\n+        } else {\n+            startWithScenarios();\n+        }\n+    }\n+\n+    \/**\n+     * Set a new default warm-up (overriding the framework default of 2000 at\n+     * {@link TestVM#WARMUP_ITERATIONS}) to be applied for all tests that do not specify an explicit\n+     * warm-up with {@link Warmup @Warmup}.\n+     *\n+     * @param defaultWarmup a new non-negative default warm-up.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework setDefaultWarmup(int defaultWarmup) {\n+        TestFormat.check(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n+        this.defaultWarmup = defaultWarmup;\n+        return this;\n+    }\n+\n+    \/**\n+     * Get the VM output of the test VM. Use {@code -DVerbose=true} to enable more debug information. If scenarios\n+     * were run, use {@link Scenario#getTestVMOutput()}.\n+     *\n+     * @return the last test VM output.\n+     *\/\n+    public static String getLastTestVMOutput() {\n+        return TestVMProcess.getLastTestVMOutput();\n+    }\n+\n+    \/*\n+     * The following methods are only intended to be called from actual @Test methods and not from the main() method of\n+     * a JTreg test. Calling these methods from main() results in a linking exception (Whitebox not yet loaded and enabled).\n+     *\/\n+\n+    \/**\n+     * Compile {@code m} at compilation level {@code compLevel}. {@code m} is first enqueued and might not be compiled,\n+     * yet, upon returning from this method.\n+     *\n+     * @param m the method to be compiled.\n+     * @param compLevel the (valid) compilation level at which the method should be compiled.\n+     * @throws TestRunException if compilation level is {@link CompLevel#SKIP} or {@link CompLevel#WAIT_FOR_COMPILATION}.\n+     *\/\n+    public static void compile(Method m, CompLevel compLevel) {\n+        TestVM.compile(m, compLevel);\n+    }\n+\n+    \/**\n+     * Deoptimize {@code m}.\n+     *\n+     * @param m the method to be deoptimized.\n+     *\/\n+    public static void deoptimize(Method m) {\n+        TestVM.deoptimize(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled at any level;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isCompiled(Method m) {\n+        return TestVM.isCompiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled with C1.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled with C1;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isC1Compiled(Method m) {\n+        return TestVM.isC1Compiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled with C2.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled with C2;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isC2Compiled(Method m) {\n+        return TestVM.isC2Compiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if {@code m} is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+        return TestVM.isCompiledAtLevel(m, compLevel);\n+    }\n+\n+    \/**\n+     * Checks if {@code m} is compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is not compiled at any level.\n+     *\/\n+    public static void assertCompiled(Method m) {\n+        TestVM.assertCompiled(m);\n+    }\n+\n+    \/**\n+     * Checks if {@code m} is not compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is compiled at any level.\n+     *\/\n+    public static void assertNotCompiled(Method m) {\n+        TestVM.assertNotCompiled(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled with C1.\n+     *\n+     * @param m the method to be verified.\n+     * @throws TestRunException if {@code m} is not compiled with C1.\n+     *\/\n+    public static void assertCompiledByC1(Method m) {\n+        TestVM.assertCompiledByC1(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled with C2.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is not compiled with C2.\n+     *\/\n+    public static void assertCompiledByC2(Method m) {\n+        TestVM.assertCompiledByC2(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @throws TestRunException if {@code m} is not compiled at {@code compLevel}.\n+     *\/\n+    public static void assertCompiledAtLevel(Method m, CompLevel compLevel) {\n+        TestVM.assertCompiledAtLevel(m, compLevel);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} was deoptimized after being C1 compiled.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is was not deoptimized after being C1 compiled.\n+     *\/\n+    public static void assertDeoptimizedByC1(Method m) {\n+        TestVM.assertDeoptimizedByC1(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} was deoptimized after being C2 compiled.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is was not deoptimized after being C2 compiled.\n+     *\/\n+    public static void assertDeoptimizedByC2(Method m) {\n+        TestVM.assertDeoptimizedByC2(m);\n+    }\n+\n+    \/**\n+     * Returns a different boolean each time this method is invoked (switching between {@code false} and {@code true}).\n+     * The very first invocation returns {@code false}. Note that this method could be used by different tests and\n+     * thus the first invocation for a test could be {@code true} or {@code false} depending on how many times\n+     * other tests have already invoked this method.\n+     *\n+     * @return an inverted boolean of the result of the last invocation of this method.\n+     *\/\n+    public static boolean toggleBoolean() {\n+        toggleBool = !toggleBool;\n+        return toggleBool;\n+    }\n+\n+    \/*\n+     * End of public interface methods\n+     *\/\n+\n+    \/**\n+     * Used to move Whitebox class to the right folder in the JTreg test\n+     *\/\n+    private void installWhiteBox() {\n+        try {\n+            ClassFileInstaller.main(WhiteBox.class.getName());\n+        } catch (Exception e) {\n+            throw new Error(\"failed to install whitebox classes\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Disable IR verification completely in certain cases.\n+     *\/\n+    private void disableIRVerificationIfNotFeasible() {\n+        if (irVerificationPossible) {\n+            irVerificationPossible = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to not running a debug build (required for PrintIdeal\" +\n+                                   \"and PrintOptoAssembly), running with -Xint, or -Xcomp (use warm-up of 0 instead)\");\n+                return;\n+            }\n+\n+            irVerificationPossible = hasIRAnnotations();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to test \" + testClass + \" not specifying any @IR annotations\");\n+                return;\n+            }\n+\n+            \/\/ No IR verification is done if additional non-whitelisted JTreg VM or Javaoptions flag is specified.\n+            irVerificationPossible = onlyWhitelistedJTregVMAndJavaOptsFlags();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to using non-whitelisted JTreg VM or Javaoptions flag(s).\"\n+                                   + System.lineSeparator());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * For scenarios: Run the tests with the scenario settings and collect all exceptions to be able to run all\n+     * scenarios without prematurely throwing an exception. Format violations, however, are wrong for all scenarios\n+     * and thus is reported immediately on the first scenario execution.\n+     *\/\n+    private void startWithScenarios() {\n+        Map<Scenario, Exception> exceptionMap = new TreeMap<>(Comparator.comparingInt(Scenario::getIndex));\n+        for (Scenario scenario : scenarios) {\n+            try {\n+                start(scenario);\n+            } catch (TestFormatException e) {\n+                \/\/ Test format violation is wrong for all the scenarios. Only report once.\n+                throw e;\n+            } catch (Exception e) {\n+                exceptionMap.put(scenario, e);\n+            }\n+        }\n+        if (!exceptionMap.isEmpty()) {\n+            reportScenarioFailures(exceptionMap);\n+        }\n+    }\n+\n+    private void reportScenarioFailures(Map<Scenario, Exception> exceptionMap) {\n+        String failedScenarios = \"The following scenarios have failed: #\"\n+                                 + exceptionMap.keySet().stream()\n+                                               .map(s -> String.valueOf(s.getIndex()))\n+                                               .collect(Collectors.joining(\", #\"));\n+        StringBuilder builder = new StringBuilder(failedScenarios);\n+        builder.append(System.lineSeparator()).append(System.lineSeparator());\n+        for (Map.Entry<Scenario, Exception> entry : exceptionMap.entrySet()) {\n+            Exception e = entry.getValue();\n+            Scenario scenario = entry.getKey();\n+            String errorMsg = \"\";\n+            if (scenario != null) {\n+                errorMsg = getScenarioTitleAndFlags(scenario);\n+            }\n+            if (e instanceof IRViolationException irException) {\n+                \/\/ For IR violations, only show the actual violations and not the (uninteresting) stack trace.\n+                System.out.println((scenario != null ? \"Scenario #\" + scenario.getIndex() + \" - \" : \"\")\n+                                   + \"Compilation(s) of failed matche(s):\");\n+                System.out.println(irException.getCompilations());\n+                builder.append(errorMsg).append(System.lineSeparator()).append(irException.getExceptionInfo());\n+            } else if (e instanceof TestVMException testVMException) {\n+                builder.append(errorMsg).append(System.lineSeparator()).append(testVMException.getExceptionInfo());\n+            } else {\n+                \/\/ Print stack trace otherwise\n+                StringWriter errors = new StringWriter();\n+                e.printStackTrace(new PrintWriter(errors));\n+                builder.append(errors.toString());\n+            }\n+            builder.append(System.lineSeparator());\n+        }\n+        System.err.println(builder.toString());\n+        if (!VERBOSE && !REPORT_STDOUT && !TESTLIST && !EXCLUDELIST) {\n+            \/\/ Provide a hint to the user how to get additional output\/debugging information.\n+            System.err.println(RERUN_HINT);\n+        }\n+        throw new TestRunException(failedScenarios + \". Please check stderr for more information.\");\n+    }\n+\n+    private static String getScenarioTitleAndFlags(Scenario scenario) {\n+        StringBuilder builder = new StringBuilder();\n+        String title = \"Scenario #\" + scenario.getIndex();\n+        builder.append(title).append(System.lineSeparator()).append(\"=\".repeat(title.length()))\n+               .append(System.lineSeparator());\n+        builder.append(\"Scenario flags: [\").append(String.join(\", \", scenario.getFlags())).append(\"]\")\n+               .append(System.lineSeparator());\n+        return builder.toString();\n+    }\n+\n+    \/**\n+     * Execute a separate \"flag\" VM with White Box access to determine all test VM flags. The flag VM sends an encoding of\n+     * all required flags for the test VM to the driver VM over a socket. Once the flag VM exits, this driver VM parses the\n+     * test VM flags, which also determine if IR matching should be done, and then starts the test VM to execute all tests.\n+     *\/\n+    private void start(Scenario scenario) {\n+        if (scenario != null && !scenario.isEnabled()) {\n+            System.out.println(\"Disabled scenario #\" + scenario.getIndex() + \"! This scenario is not present in set flag \" +\n+                               \"-DScenarios and is therefore not executed.\");\n+            return;\n+        }\n+        shouldVerifyIR = irVerificationPossible;\n+        try {\n+            \/\/ Use TestFramework flags and scenario flags for new VMs.\n+            List<String> additionalFlags = new ArrayList<>();\n+            if (flags != null) {\n+                additionalFlags.addAll(flags);\n+            }\n+            if (scenario != null) {\n+                List<String> scenarioFlags = scenario.getFlags();\n+                String scenarioFlagsString = scenarioFlags.isEmpty() ? \"\" : \" - [\" + String.join(\", \", scenarioFlags) + \"]\";\n+                System.out.println(\"Scenario #\" + scenario.getIndex() + scenarioFlagsString + \":\");\n+                additionalFlags.addAll(scenarioFlags);\n+            }\n+            String frameworkAndScenarioFlags = additionalFlags.isEmpty() ?\n+                    \"\" : \" - [\" + String.join(\", \", additionalFlags) + \"]\";\n+\n+            if (shouldVerifyIR) {\n+                \/\/ Only need to use flag VM if an IR verification is possibly done.\n+                System.out.println(\"Run Flag VM:\");\n+                FlagVMProcess flagVMProcess = new FlagVMProcess(testClass, additionalFlags);\n+                shouldVerifyIR = flagVMProcess.shouldVerifyIR();\n+                if (shouldVerifyIR) {\n+                    \/\/ Add more flags for the test VM which are required to do IR verification.\n+                    additionalFlags.addAll(flagVMProcess.getTestVMFlags());\n+                } \/\/ else: Flag VM found a reason to not do IR verification.\n+            } else {\n+                System.out.println(\"Skip Flag VM due to not performing IR verification.\");\n+            }\n+\n+            System.out.println(\"Run Test VM\" + frameworkAndScenarioFlags + \":\");\n+            runTestVM(additionalFlags);\n+        } finally {\n+            if (scenario != null) {\n+                scenario.setTestVMOutput(TestVMProcess.getLastTestVMOutput());\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+    private boolean hasIRAnnotations() {\n+        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class) != null);\n+    }\n+\n+    private boolean onlyWhitelistedJTregVMAndJavaOptsFlags() {\n+        List<String> flags = Arrays.stream(Utils.getTestJavaOpts())\n+                                   .map(s -> s.replaceFirst(\"-XX:[+|-]?|-(?=[^D|^e])\", \"\"))\n+                                   .collect(Collectors.toList());\n+        for (String flag : flags) {\n+            \/\/ Property flags (prefix -D), -ea and -esa are whitelisted.\n+            if (!flag.startsWith(\"-D\") && !flag.startsWith(\"-e\") && JTREG_WHITELIST_FLAGS.stream().noneMatch(flag::contains)) {\n+                \/\/ Found VM flag that is not whitelisted\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runTestVM(List<String> additionalFlags) {\n+        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup);\n+        if (shouldVerifyIR) {\n+            try {\n+                new IRMatcher(testVMProcess.getHotspotPidFileName(), testVMProcess.getIrEncoding(), testClass);\n+            } catch (IRViolationException e) {\n+                e.addCommandLine(testVMProcess.getCommandLine());\n+                throw e;\n+            }\n+        } else {\n+            System.out.println(\"IR verification disabled either due to no @IR annotations, through explicitly setting \" +\n+                               \"-DVerify=false, due to not running a debug build, using a non-whitelisted JTreg VM or \" +\n+                               \"Javaopts flag like -Xint, or running the test VM with other VM flags added by user code \" +\n+                               \"that make the IR verification impossible (e.g. -XX:-UseCompile, \" +\n+                               \"-XX:TieredStopAtLevel=[1,2,3], etc.).\");\n+        }\n+    }\n+\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            throw new TestFrameworkException(failureMessage);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":718,"deletions":0,"binary":false,"changes":718,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Test info class which provides some useful utility methods and information about a <b>checked test<\/b>.\n+ *\n+ * @see Test\n+ * @see Check\n+ *\/\n+public class TestInfo extends AbstractInfo {\n+    private final Method testMethod;\n+    private final boolean compilationSkipped;\n+\n+    public TestInfo(Method testMethod, CompLevel testCmpLevel) {\n+        super(testMethod.getDeclaringClass());\n+        this.testMethod = testMethod;\n+        this.compilationSkipped = testCmpLevel == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Get the associated test method object.\n+     *\n+     * @return the associated test method object.\n+     *\/\n+    public Method getTest() {\n+        return testMethod;\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation after the warm-up due to VM flags not\n+     * allowing a compilation on the requested level in {@link Test#compLevel()}.\n+     *\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompilationSkipped() {\n+        return compilationSkipped;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C1 compiled.\n+     *\n+     * @return {@code true} if the test method is C1 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC1Compiled() {\n+        return TestVM.isC1Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C2 compiled.\n+     *\n+     * @return {@code true} if the test method is C2 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC2Compiled() {\n+        return TestVM.isC2Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}.\n+     *\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if the test method is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompiledAtLevel(CompLevel compLevel) {\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestInfo.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation overrides the default number (2000) of times the framework should warm up a test.\n+ * <ul>\n+ *     <li><p>Any positive value or zero is permitted. A warm-up of zero allows a simulation of {@code -Xcomp}.<\/li>\n+ *     <li><p>Custom run tests (see {@link Run}) must specify a {@code @Warmup} annotation at the run method.<\/li>\n+ *     <li><p>Base and checked tests (see {@link Test}, {@link Check}) must specify a {@code @Warmup} annotation at\n+ *            the test method.<\/li>\n+ * <\/ul>\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Warmup {\n+    \/**\n+     * The warm-up iterations for the test.\n+     *\/\n+    int value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Warmup.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.flag.FlagVM;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"flag\" VM with verification of proper termination. The flag VM determines\n+ * the flags required for the \"test\" VM. The flag VM writes these flags to a dedicated file which is then parsed by this\n+ * class after the termination of the flag VM.\n+ *\n+ * @see FlagVM\n+ *\/\n+public class FlagVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+\n+    private final List<String> cmds;\n+    private final List<String> testVMFlags;\n+    private boolean shouldVerifyIR;\n+    private String testVMFlagsFile;\n+    private OutputAnalyzer oa;\n+\n+    public FlagVMProcess(Class<?> testClass, List<String> additionalFlags) {\n+        cmds = new ArrayList<>();\n+        testVMFlags = new ArrayList<>();\n+        prepareVMFlags(testClass, additionalFlags);\n+        start();\n+        parseTestVMFlags();\n+    }\n+\n+    private void parseTestVMFlags() {\n+        String flags = readFlagsFromFile();\n+        if (VERBOSE) {\n+            System.out.println(\"Read data from \" + testVMFlagsFile + \":\");\n+            System.out.println(flags);\n+        }\n+        String patternString = \"(.*DShouldDoIRVerification=(true|false).*)\";\n+        Pattern pattern = Pattern.compile(patternString);\n+        Matcher matcher = pattern.matcher(flags);\n+        TestFramework.check(matcher.find(), \"Invalid flag encoding emitted by flag VM\");\n+        \/\/ Maybe we run with flags that make IR verification impossible\n+        shouldVerifyIR = Boolean.parseBoolean(matcher.group(2));\n+        testVMFlags.addAll(Arrays.asList(matcher.group(1).split(FlagVM.TEST_VM_FLAGS_DELIMITER)));\n+    }\n+\n+    private String readFlagsFromFile() {\n+        try (var br = Files.newBufferedReader(Paths.get(testVMFlagsFile))) {\n+            String flags = br.readLine();\n+            TestFramework.check(br.readLine() == null, testVMFlagsFile + \" should only contain one line.\");\n+            return flags;\n+\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading from file \" + testVMFlagsFile, e);\n+        }\n+    }\n+\n+    \/**\n+     * The flag VM needs White Box access to prepare all test VM flags. The flag VM will write the test VM flags to\n+     * a dedicated file which is afterwards parsed by the driver VM and added as flags to the test VM.\n+     *\/\n+    private void prepareVMFlags(Class<?> testClass, List<String> additionalFlags) {\n+        cmds.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        cmds.add(\"-cp\");\n+        cmds.add(Utils.TEST_CLASS_PATH);\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        \/\/ TestFramework and scenario flags might have an influence on the later used test VM flags. Add them as well.\n+        cmds.addAll(additionalFlags);\n+        cmds.add(FlagVM.class.getCanonicalName());\n+        cmds.add(testClass.getCanonicalName());\n+    }\n+\n+    private void start() {\n+        try {\n+            \/\/ Run \"flag\" VM with White Box access to determine the test VM flags and if IR verification should be done.\n+            oa = ProcessTools.executeTestJvm(cmds);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Failed to execute TestFramework flag VM\", e);\n+        }\n+        testVMFlagsFile = FlagVM.TEST_VM_FLAGS_FILE_PREFIX + oa.pid()\n+                          + FlagVM.TEST_VM_FLAGS_FILE_POSTFIX;\n+        checkFlagVMExitCode();\n+    }\n+\n+    private void checkFlagVMExitCode() {\n+        String flagVMOutput = oa.getOutput();\n+        int exitCode = oa.getExitValue();\n+        if (VERBOSE && exitCode == 0) {\n+            System.out.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.out.println(flagVMOutput);\n+        }\n+\n+        if (exitCode != 0) {\n+            System.err.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.err.println(flagVMOutput);\n+            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n+        }\n+    }\n+\n+    public List<String> getTestVMFlags() {\n+        return testVMFlags;\n+    }\n+\n+    public boolean shouldVerifyIR() {\n+        return shouldVerifyIR;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Parse the hotspot pid file of the test VM to match all @IR rules.\n+ *\/\n+public class IRMatcher {\n+    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n+    private static final Pattern IR_ENCODING_PATTERN =\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n+    private final Map<String, IRMethod> compilations;\n+    private final Class<?> testClass;\n+    private final Map<Method, List<String>> fails;\n+    private final Pattern compileIdPatternForTestClass;\n+    private final String hotspotPidFileName;\n+    private IRMethod irMethod; \/\/ Current IR method to which rules are applied\n+    private Method method; \/\/ Current method to which rules are applied\n+    private IR irAnno; \/\/ Current IR annotation that is processed.\n+    private int irRuleIndex; \/\/ Current IR rule index;\n+\n+    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n+        this.compilations = new HashMap<>();\n+        this.fails = new HashMap<>();\n+        this.testClass = testClass;\n+        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName())\n+                                                            + \" (\\\\S+)\");\n+        this.hotspotPidFileName = hotspotPidFileName;\n+        setupTestMethods(irEncoding);\n+        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n+            System.out.println(\"Read IR encoding from test VM:\");\n+            System.out.println(irEncoding);\n+        }\n+        if (!compilations.isEmpty()) {\n+            parseHotspotPidFile();\n+            applyRules();\n+        }\n+    }\n+\n+    \/**\n+     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n+     *\/\n+    private void setupTestMethods(String irEncoding) {\n+        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            method = m;\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+            if (irAnnos.length > 0) {\n+                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n+                int[] ids = irRulesMap.get(m.getName());\n+                TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n+                TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n+                TestFramework.check(ids[ids.length - 1] < irAnnos.length, \"Invalid IR rule index found in validIrRulesMap for \" + m);\n+                if (ids[0] != IREncodingPrinter.NO_RULE_APPLIED) {\n+                    \/\/ If -1, than there was no matching IR rule for the given conditions.\n+                    compilations.put(m.getName(), new IRMethod(m, ids, irAnnos));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n+     *\/\n+    private Map<String, int[]> parseIREncoding(String irEncoding) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n+        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n+        String[] lines = matcher.group(0).split(\"\\\\R\");\n+\n+        \/\/ Skip first line containing information about the format only\n+        for (int i = 1; i < lines.length; i++) {\n+            String line = lines[i].trim();\n+            String[] splitComma = line.split(\",\");\n+            if (splitComma.length < 2) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitComma[0]);\n+            }\n+            String testName = splitComma[0];\n+            int[] irRulesIdx = new int[splitComma.length - 1];\n+            for (int j = 1; j < splitComma.length; j++) {\n+                try {\n+                    irRulesIdx[j - 1] = Integer.parseInt(splitComma[j]);\n+                } catch (NumberFormatException e) {\n+                    throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitComma[j]);\n+                }\n+            }\n+            irRulesMap.put(testName, irRulesIdx);\n+        }\n+        return irRulesMap;\n+    }\n+\n+    \/**\n+     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly entries for all\n+     * methods of the test class that need to be IR matched (according to IR encoding).\n+     *\/\n+    private void parseHotspotPidFile() {\n+        Map<Integer, String> compileIdMap = new HashMap<>();\n+        try (var br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+            String line;\n+            StringBuilder builder = new StringBuilder();\n+            boolean append = false;\n+            String currentMethod = \"\";\n+            while ((line = br.readLine()) != null) {\n+                if (append && line.startsWith(\"<\/\")) {\n+                    flushOutput(line, builder, currentMethod);\n+                    append = false;\n+                    currentMethod = \"\";\n+                    continue;\n+                } else if (append) {\n+                    appendLine(builder, line);\n+                    continue;\n+                }\n+\n+                if (maybeTestEntry(line)) {\n+                    addTestMethodCompileId(compileIdMap, line);\n+                } else if (isPrintIdealStart(line)) {\n+                    String methodName = getMethodName(compileIdMap, line);\n+                    if (methodName != null) {\n+                        currentMethod = methodName;\n+                        append = true; \/\/ Append all following lines until we hit the closing <\/ideal> tag.\n+                    }\n+                } else if (isPrintOptoAssemblyStart(line)) {\n+                    String methodName = getMethodName(compileIdMap, line);\n+                    if (methodName != null) {\n+                        TestFramework.check(compilations.containsKey(methodName), \"Must be second entry of \" + methodName);\n+                        currentMethod = methodName;\n+                        append = true; \/\/ Append all following lines until we hit the closing <\/opto_assembly> tag.\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n+        }\n+    }\n+\n+    \/**\n+     * Write the input to the IR method and reset the builder.\n+     *\/\n+    private void flushOutput(String line, StringBuilder builder, String currentMethod) {\n+        TestFramework.check(!currentMethod.isEmpty(), \"current method must be set\");\n+        IRMethod irMethod = compilations.get(currentMethod);\n+        if (line.startsWith(\"<\/i\")) {\n+            \/\/ PrintIdeal\n+            irMethod.setIdealOutput(builder.toString());\n+        } else {\n+            \/\/ PrintOptoAssembly\n+            irMethod.setOptoAssemblyOutput(builder.toString());\n+        }\n+        builder.setLength(0);\n+    }\n+\n+    \/**\n+     * Only consider non-osr (no \"compile_kind\") and compilations with C2 (no \"level\")\n+     *\/\n+    private boolean maybeTestEntry(String line) {\n+        return line.startsWith(\"<task_queued\") && !line.contains(\"compile_kind='\") && !line.contains(\"level='\");\n+    }\n+\n+    \/**\n+     * Need to escape XML special characters.\n+     *\/\n+    private static void appendLine(StringBuilder builder, String line) {\n+        if (line.contains(\"&\")) {\n+            line = line.replace(\"&lt;\", \"<\");\n+            line = line.replace(\"&gt;\", \">\");\n+            line = line.replace(\"&quot;\", \"\\\"\");\n+            line = line.replace(\"&apos;\", \"'\");\n+            line = line.replace(\"&amp;\", \"&\");\n+        }\n+        builder.append(line).append(System.lineSeparator());\n+    }\n+\n+    private static int getCompileId(Matcher matcher) {\n+        int compileId;\n+        try {\n+            compileId = Integer.parseInt(matcher.group(1));\n+        } catch (NumberFormatException e) {\n+            throw new TestRunException(\"Could not parse compile id\", e);\n+        }\n+        return compileId;\n+    }\n+\n+    \/**\n+     * Parse the compile id from this line if it belongs to a method that needs to be IR tested (part of test class\n+     * and IR encoding from the test VM specifies that this method has @IR rules to be checked).\n+     *\/\n+    private void addTestMethodCompileId(Map<Integer, String> compileIdMap, String line) {\n+        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+        if (matcher.find()) {\n+            \/\/ Only care about test class entries. Might have non-class entries as well if user specified additional\n+            \/\/ compile commands. Ignore these.\n+            String methodName = matcher.group(2);\n+            if (compilations.containsKey(methodName)) {\n+                \/\/ We only care about methods that we are actually gonna IR match based on IR encoding.\n+                int compileId = getCompileId(matcher);\n+                TestRun.check(!methodName.isEmpty(), \"method name cannot be empty\");\n+                compileIdMap.put(compileId, methodName);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n+     * interested in.\n+     *\/\n+    private static boolean isPrintIdealStart(String line) {\n+        return line.startsWith(\"<ideal\") && !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n+     * interested in.\n+     *\/\n+    private static boolean isPrintOptoAssemblyStart(String line) {\n+        return line.startsWith(\"<opto_assembly\") && !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Get method name for this line by looking up the compile id.\n+     * Returns null if not an interesting method (i.e. from test class).\n+     *\/\n+    private String getMethodName(Map<Integer, String> compileIdMap, String line) {\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n+        TestFramework.check(matcher.find(), \"Is \" + hotspotPidFileName + \" corrupted?\");\n+        int compileId = getCompileId(matcher);\n+        return compileIdMap.get(compileId);\n+    }\n+\n+    \/**\n+     * Do an IR matching of all methods with appliable @IR rules fetched during parsing of the hotspot pid file.\n+     *\/\n+    private void applyRules() {\n+        compilations.values().forEach(this::applyRulesForMethod);\n+        reportFailuresIfAny();\n+    }\n+\n+    private void applyRulesForMethod(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+        method = irMethod.getMethod();\n+        String testOutput = irMethod.getOutput();\n+        if (testOutput.isEmpty()) {\n+            String msg = \"Method was not compiled. Did you specify any compiler directives preventing a compilation or used a \" +\n+                         \"@Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 compilation \" +\n+                         \"by invoking the test enough times.\";\n+            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(msg);\n+            return;\n+        }\n+\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Output of \" + method + \":\");\n+            System.out.println(testOutput);\n+        }\n+        Arrays.stream(irMethod.getRuleIds()).forEach(this::applyIRRule);\n+    }\n+\n+    \/**\n+     * Apply a single @IR rule as part of a method.\n+     *\/\n+    private void applyIRRule(int id) {\n+        irAnno = irMethod.getIrAnno(id);\n+        irRuleIndex = id;\n+        StringBuilder failMsg = new StringBuilder();\n+        applyFailOn(failMsg);\n+        try {\n+            applyCounts(failMsg);\n+        } catch (TestFormatException e) {\n+            \/\/ Logged. Continue to check other rules.\n+        }\n+        if (!failMsg.isEmpty()) {\n+            failMsg.insert(0, \"@IR rule \" + (id + 1) + \": \\\"\" + irAnno + \"\\\"\" + System.lineSeparator());\n+            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(failMsg.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Apply the failOn regexes of the @IR rule.\n+     *\/\n+    private void applyFailOn(StringBuilder failMsg) {\n+        if (irAnno.failOn().length != 0) {\n+            String failOnRegex = String.join(\"|\", IRNode.mergeNodes(irAnno.failOn()));\n+            Pattern pattern = Pattern.compile(failOnRegex);\n+            Matcher matcher = pattern.matcher(irMethod.getOutput());\n+            long matchCount = matcher.results().count();\n+            if (matchCount > 0) {\n+                addFailOnFailsForOutput(failMsg, pattern, matchCount);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A failOn regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n+     * to the user.\n+     *\/\n+    private void addFailOnFailsForOutput(StringBuilder failMsg, Pattern pattern, long matchCount) {\n+        long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n+        long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n+        if (matchCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n+            \/\/ Report with Ideal and Opto Assembly\n+            addFailOnFailsForOutput(failMsg, irMethod.getOutput());\n+            irMethod.needsAllOutput();\n+        } else if (optoAssemblyCount == 0) {\n+            \/\/ Report with Ideal only\n+            addFailOnFailsForOutput(failMsg, irMethod.getIdealOutput());\n+            irMethod.needsIdeal();\n+        } else {\n+            \/\/ Report with Opto Assembly only\n+            addFailOnFailsForOutput(failMsg, irMethod.getOptoAssemblyOutput());\n+            irMethod.needsOptoAssembly();\n+        }\n+    }\n+\n+    \/**\n+     * Apply the regexes to the testOutput and log the failures.\n+     *\/\n+    private void addFailOnFailsForOutput(StringBuilder failMsg, String testOutput) {\n+        List<String> failOnNodes = IRNode.mergeNodes(irAnno.failOn());\n+        Pattern pattern;\n+        Matcher matcher;\n+        failMsg.append(\"- failOn: Graph contains forbidden nodes:\").append(System.lineSeparator());\n+        int nodeId = 1;\n+        for (String nodeRegex : failOnNodes) {\n+            pattern = Pattern.compile(nodeRegex);\n+            matcher = pattern.matcher(testOutput);\n+            long matchCount = matcher.results().count();\n+            if (matchCount > 0) {\n+                matcher.reset();\n+                failMsg.append(\"    Regex \").append(nodeId).append(\": \").append(nodeRegex).append(System.lineSeparator());\n+                failMsg.append(\"    Matched forbidden node\").append(matchCount > 1 ? \"s (\" + matchCount + \")\" : \"\")\n+                       .append(\":\").append(System.lineSeparator());\n+                matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n+            }\n+            nodeId++;\n+        }\n+    }\n+\n+    \/**\n+     * Apply the counts regexes of the @IR rule.\n+     *\/\n+    private void applyCounts(StringBuilder failMsg) {\n+        if (irAnno.counts().length != 0) {\n+            boolean hasFails = false;\n+            String testOutput = irMethod.getOutput();\n+            int countsId = 1;\n+            final List<String> nodesWithCount = IRNode.mergeNodes(irAnno.counts());\n+            for (int i = 0; i < nodesWithCount.size(); i += 2) {\n+                String node = nodesWithCount.get(i);\n+                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\" + getPostfixErrorMsg(node));\n+                String countString = nodesWithCount.get(i + 1);\n+                long expectedCount;\n+                ParsedComparator<Long> parsedComparator;\n+                try {\n+                    parsedComparator = ParsedComparator.parseComparator(countString);\n+                    expectedCount = Long.parseLong(parsedComparator.getStrippedString());\n+                } catch (NumberFormatException e) {\n+                    TestFormat.fail(\"Provided invalid count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n+                    return;\n+                } catch (CheckedTestFrameworkException e) {\n+                    TestFormat.fail(\"Invalid comparator \\\"\" + e.getMessage() + \"\\\" in \\\"\" + countString + \"\\\" for count\" + getPostfixErrorMsg(node));\n+                    return;\n+                } catch (IndexOutOfBoundsException e) {\n+                    TestFormat.fail(\"Provided empty value\" + getPostfixErrorMsg(node));\n+                    return;\n+                }\n+                TestFormat.check(expectedCount >= 0,\"Provided invalid negative count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n+\n+                Pattern pattern = Pattern.compile(node);\n+                Matcher matcher = pattern.matcher(testOutput);\n+                long actualCount = matcher.results().count();\n+                if (!parsedComparator.getPredicate().test(actualCount, expectedCount)) {\n+                    if (!hasFails) {\n+                        failMsg.append(\"- counts: Graph contains wrong number of nodes:\").append(System.lineSeparator());\n+                        hasFails = true;\n+                    }\n+                    addCountsFail(failMsg, node, pattern, expectedCount, actualCount, countsId);\n+                }\n+                countsId++;\n+            }\n+        }\n+    }\n+\n+    private String getPostfixErrorMsg(String node) {\n+        return \" for IR rule \" + irRuleIndex + \", node \\\"\" + node + \"\\\" at \" + method;\n+    }\n+\n+    \/**\n+     * A counts regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n+     * to the user.\n+     *\/\n+    private void addCountsFail(StringBuilder failMsg, String node, Pattern pattern, long expectedCount, long actualCount, int countsId) {\n+        failMsg.append(\"    Regex \").append(countsId).append(\": \").append(node).append(System.lineSeparator());\n+        failMsg.append(\"    Expected \").append(expectedCount).append(\" but found \").append(actualCount);\n+\n+        if (actualCount > 0) {\n+            Matcher matcher = pattern.matcher(irMethod.getOutput());\n+            long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n+            long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n+            if (actualCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n+                irMethod.needsAllOutput();\n+            } else if (optoAssemblyCount == 0) {\n+                irMethod.needsIdeal();\n+            } else {\n+                irMethod.needsOptoAssembly();\n+            }\n+            failMsg.append(\" node\").append(actualCount > 1 ? \"s\" : \"\").append(\":\").append(System.lineSeparator());\n+            matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n+        } else {\n+            irMethod.needsAllOutput();\n+            failMsg.append(\" nodes.\").append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n+     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n+     * in both outputs than the entire output is reported. Throws IRViolationException from which the compilation\n+     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n+     * failures.\n+     *\/\n+    private void reportFailuresIfAny() {\n+        TestFormat.reportIfAnyFailures();\n+        if (!fails.isEmpty()) {\n+            StringBuilder failuresBuilder = new StringBuilder();\n+            StringBuilder compilationsBuilder = new StringBuilder();\n+            int failures = 0;\n+            for (Map.Entry<Method, List<String>> entry : fails.entrySet()) {\n+                Method method = entry.getKey();\n+                compilationsBuilder.append(\">>> Compilation of \").append(method).append(\":\").append(System.lineSeparator());\n+                IRMethod irMethod = compilations.get(method.getName());\n+                String output;\n+                if (irMethod.usesIdeal() && irMethod.usesOptoAssembly()) {\n+                    output = irMethod.getOutput();\n+                } else if (irMethod.usesIdeal()) {\n+                    output = irMethod.getIdealOutput();\n+                } else if (irMethod.usesOptoAssembly()) {\n+                    output = irMethod.getOptoAssemblyOutput();\n+                } else {\n+                    output = \"<empty>\";\n+                }\n+                compilationsBuilder.append(output).append(System.lineSeparator()).append(System.lineSeparator());\n+                List<String> list = entry.getValue();\n+                failuresBuilder.append(\"- Method \\\"\").append(method).append(\"\\\":\").append(System.lineSeparator());\n+                failures += list.size();\n+                list.forEach(s -> failuresBuilder.append(\"  * \")\n+                                                 .append(s.replace(System.lineSeparator(),\n+                                                                   System.lineSeparator() + \"    \").trim())\n+                                                 .append(System.lineSeparator()));\n+                failuresBuilder.append(System.lineSeparator());\n+            }\n+            failuresBuilder.insert(0, (\"One or more @IR rules failed:\" + System.lineSeparator()\n+                                       + System.lineSeparator() + \"Failed IR Rules (\" + failures + \")\"\n+                                       + System.lineSeparator()) + \"-----------------\"\n+                                       + \"-\".repeat(String.valueOf(failures).length()) + System.lineSeparator());\n+            failuresBuilder.append(\">>> Check stdout for compilation output of the failed methods\")\n+                           .append(System.lineSeparator()).append(System.lineSeparator());\n+            throw new IRViolationException(failuresBuilder.toString(), compilationsBuilder.toString());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMatcher.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Helper class to store information about a method that needs to be IR matched.\n+ *\/\n+class IRMethod {\n+    private final Method method;\n+    private final int[] ruleIds;\n+    private final IR[] irAnnos;\n+    private final StringBuilder outputBuilder;\n+    private String output;\n+    private String idealOutput;\n+    private String optoAssemblyOutput;\n+    private boolean needsIdeal;\n+    private boolean needsOptoAssembly;\n+\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+        this.method = method;\n+        this.ruleIds = ruleIds;\n+        this.irAnnos = irAnnos;\n+        this.outputBuilder = new StringBuilder();\n+        this.output = \"\";\n+        this.idealOutput = \"\";\n+        this.optoAssemblyOutput = \"\";\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public int[] getRuleIds() {\n+        return ruleIds;\n+    }\n+\n+    public IR getIrAnno(int idx) {\n+        return irAnnos[idx];\n+    }\n+\n+    \/**\n+     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n+     * Only keep the very last one by overriding 'output'.\n+     *\/\n+    public void setIdealOutput(String idealOutput) {\n+        outputBuilder.setLength(0);\n+        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n+        outputBuilder.append(this.idealOutput);\n+    }\n+\n+    \/**\n+     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     *\/\n+    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n+        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n+        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n+        output = outputBuilder.toString();\n+    }\n+\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public String getIdealOutput() {\n+        return idealOutput;\n+    }\n+\n+    public String getOptoAssemblyOutput() {\n+        return optoAssemblyOutput;\n+    }\n+\n+    public void needsAllOutput() {\n+        needsIdeal();\n+        needsOptoAssembly();\n+    }\n+\n+    public void needsIdeal() {\n+        needsIdeal = true;\n+    }\n+\n+    public boolean usesIdeal() {\n+        return needsIdeal;\n+    }\n+\n+    public void needsOptoAssembly() {\n+        needsOptoAssembly = true;\n+    }\n+\n+    public boolean usesOptoAssembly() {\n+        return needsOptoAssembly;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMethod.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Test;\n+\n+\/**\n+ * Exception that is thrown if an {@link IR} rule\/constraint failed. The exception message contains a detailed list of\n+ * all failures, including failing method(s), {@code @IR} rule(s) (the first {@code @IR} constraint is rule 1) and the\n+ * specific regex(es) that could not be matched.\n+ *\n+ * @see IR\n+ * @see Test\n+ *\/\n+public class IRViolationException extends RuntimeException {\n+    private final String compilations;\n+    private String exceptionInfo;\n+\n+    IRViolationException(String message, String compilations) {\n+        super(\"There were one or multiple IR rule failures. Please check stderr for more information.\");\n+        this.exceptionInfo = message;\n+        this.compilations = compilations;\n+    }\n+\n+    \/**\n+     * Get some more detailed information about the violated IR rule(s) and how to reproduce it.\n+     *\n+     * @return a formatted string containing information about the violated IR rule(s) and how to reproduce it.\n+     *\/\n+    public String getExceptionInfo() {\n+        return exceptionInfo;\n+    }\n+\n+    public String getCompilations() {\n+        return compilations;\n+    }\n+\n+    public void addCommandLine(String commandLine) {\n+        this.exceptionInfo = commandLine + System.lineSeparator() + exceptionInfo;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRViolationException.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+\/**\n+ * Exception that is thrown if the test VM has thrown any kind of exception (except for {@link TestFormatException}).\n+ *\/\n+public class TestVMException extends RuntimeException {\n+    private final String exceptionInfo;\n+\n+    TestVMException(String exceptionInfo) {\n+        super(\"There were one or multiple errors. Please check stderr for more information.\");\n+        this.exceptionInfo = exceptionInfo;\n+    }\n+\n+    \/**\n+     * Get some more detailed information about the exception thrown in the test VM and how to reproduce it.\n+     *\n+     * @return a formatted string containing information about the exception of the test VM and how to reproduce it.\n+     *\/\n+    public String getExceptionInfo() {\n+        return exceptionInfo;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"test\" VM with verification of proper termination. The class also stores\n+ * information about the test VM which is later queried for IR matching. The communication between this driver VM\n+ * and the test VM is done over a dedicated socket.\n+ *\n+ * @see TestVM\n+ * @see TestFrameworkSocket\n+ *\/\n+public class TestVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PREFER_COMMAND_LINE_FLAGS = Boolean.getBoolean(\"PreferCommandLineFlags\");\n+    private static final int WARMUP_ITERATIONS = Integer.getInteger(\"Warmup\", -1);\n+    private static final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+\n+    private static String lastTestVMOutput = \"\";\n+\n+    private final ArrayList<String> cmds;\n+    private String hotspotPidFileName;\n+    private String commandLine;\n+    private OutputAnalyzer oa;\n+    private String irEncoding;\n+\n+    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+        this.cmds = new ArrayList<>();\n+        TestFrameworkSocket socket = new TestFrameworkSocket();\n+        try (socket) {\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup);\n+            start();\n+        }\n+        processSocketOutput(socket.getOutput());\n+        checkTestVMExitCode();\n+    }\n+\n+    public String getCommandLine() {\n+        return commandLine;\n+    }\n+\n+    public String getIrEncoding() {\n+        return irEncoding;\n+    }\n+\n+    public String getHotspotPidFileName() {\n+        return hotspotPidFileName;\n+    }\n+\n+    public static String getLastTestVMOutput() {\n+        return lastTestVMOutput;\n+    }\n+\n+    private void prepareTestVMFlags(List<String> additionalFlags, TestFrameworkSocket socket, Class<?> testClass,\n+                                    Set<Class<?>> helperClasses, int defaultWarmup) {\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        \/\/ Need White Box access in test VM.\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        String[] jtregVMFlags = Utils.getTestJavaOpts();\n+        if (!PREFER_COMMAND_LINE_FLAGS) {\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+        \/\/ Add server property flag that enables test VM to print encoding for IR verification last and debug messages.\n+        cmds.add(socket.getPortPropertyFlag());\n+        cmds.addAll(additionalFlags);\n+        cmds.addAll(Arrays.asList(getDefaultFlags()));\n+        if (VERIFY_VM) {\n+            cmds.addAll(Arrays.asList(getVerifyFlags()));\n+        }\n+\n+        if (PREFER_COMMAND_LINE_FLAGS) {\n+            \/\/ Prefer flags set via the command line over the ones set by scenarios.\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+\n+        if (WARMUP_ITERATIONS < 0 && defaultWarmup != -1) {\n+            \/\/ Only use the set warmup for the framework if not overridden by a valid -DWarmup property set by a test.\n+            cmds.add(\"-DWarmup=\" + defaultWarmup);\n+        }\n+\n+        cmds.add(TestVM.class.getName());\n+        cmds.add(testClass.getName());\n+        if (helperClasses != null) {\n+            helperClasses.forEach(c -> cmds.add(c.getName()));\n+        }\n+    }\n+\n+    \/**\n+     * Default flags that are added used for the test VM.\n+     *\/\n+    private static String[] getDefaultFlags() {\n+        return new String[] {\"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=quiet\"};\n+    }\n+\n+    \/**\n+     * Additional verification flags that are used if -DVerifyVM=true is with a debug build.\n+     *\/\n+    private static String[] getVerifyFlags() {\n+        return new String[] {\n+                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\",\n+                \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\", \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"\n+        };\n+    }\n+\n+    private void start() {\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(cmds);\n+        try {\n+            \/\/ Calls 'main' of TestVM to run all specified tests with commands 'cmds'.\n+            \/\/ Use executeProcess instead of executeTestJvm as we have already added the JTreg VM and\n+            \/\/ Java options in prepareTestVMFlags().\n+            oa = ProcessTools.executeProcess(process);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Error while executing Test VM\", e);\n+        }\n+        commandLine = \"Command Line:\" + System.lineSeparator() + String.join(\" \", process.command())\n+                      + System.lineSeparator();\n+        hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n+        lastTestVMOutput = oa.getOutput();\n+    }\n+\n+    \/**\n+     * Process the socket output: All prefixed lines are dumped to the standard output while the remaining lines\n+     * represent the IR encoding used for IR matching later.\n+     *\/\n+    private void processSocketOutput(String output) {\n+        if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n+            StringBuilder builder = new StringBuilder();\n+            Scanner scanner = new Scanner(output);\n+            System.out.println(System.lineSeparator() + \"Run flag defined test list\");\n+            System.out.println(\"--------------------------\");\n+            while (scanner.hasNextLine()) {\n+                String line = scanner.nextLine();\n+                if (line.startsWith(TestFrameworkSocket.STDOUT_PREFIX)) {\n+                    line = \"> \" + line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n+                    System.out.println(line);\n+                } else {\n+                    builder.append(line).append(System.lineSeparator());\n+                }\n+            }\n+            System.out.println();\n+            irEncoding = builder.toString();\n+        } else {\n+            irEncoding = output;\n+        }\n+    }\n+\n+    private void checkTestVMExitCode() {\n+        final int exitCode = oa.getExitValue();\n+        if (EXCLUDE_RANDOM || REPORT_STDOUT || (VERBOSE && exitCode == 0)) {\n+            System.out.println(\"--- OUTPUT TestFramework test VM ---\");\n+            System.out.println(oa.getOutput());\n+        }\n+\n+        if (exitCode != 0) {\n+            throwTestVMException();\n+        }\n+    }\n+\n+    \/**\n+     * Exit code was non-zero of test VM. Check the stderr to determine what kind of exception that should be thrown to\n+     * react accordingly later.\n+     *\/\n+    private void throwTestVMException() {\n+        String stdErr = oa.getStderr();\n+        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n+            Pattern pattern = Pattern.compile(\"Violations \\\\(\\\\d+\\\\)[\\\\s\\\\S]*(?=\/============\/)\");\n+            Matcher matcher = pattern.matcher(stdErr);\n+            TestFramework.check(matcher.find(), \"Must find violation matches\");\n+            throw new TestFormatException(System.lineSeparator() + System.lineSeparator() + matcher.group());\n+        } else if (stdErr.contains(\"NoTestsRunException\")) {\n+            throw new NoTestsRunException(\">>> No tests run due to empty set specified with -DTest and\/or -DExclude. \" +\n+                                          \"Make sure to define a set of at least one @Test method\");\n+        } else {\n+            throw new TestVMException(getExceptionInfo());\n+        }\n+    }\n+\n+    \/**\n+     * Get more detailed information about the exception in a pretty format.\n+     *\/\n+    private String getExceptionInfo() {\n+        int exitCode = oa.getExitValue();\n+        String stdErr = oa.getStderr();\n+        String stdOut = \"\";\n+        if (exitCode == 134) {\n+            \/\/ Also dump the stdout if we experience a JVM error (e.g. to show hit assertions etc.).\n+            stdOut = System.lineSeparator() + System.lineSeparator() + \"Standard Output\" + System.lineSeparator()\n+                     + \"---------------\" + System.lineSeparator() + oa.getOutput();\n+        }\n+        return \"TestFramework test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n+               + System.lineSeparator() + commandLine + System.lineSeparator() + System.lineSeparator()\n+               + \"Error Output\" + System.lineSeparator() + \"------------\" + System.lineSeparator() + stdErr\n+               + System.lineSeparator() + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"flag VM\". It uses the\n+ * Whitebox API to determine the necessary additional flags to run the test VM (e.g. to do IR matching). It returns\n+ * the flags over the dedicated TestFramework socket.\n+ *\/\n+public class FlagVM {\n+    public static final String TEST_VM_FLAGS_FILE_PREFIX = \"test-vm-flags-pid-\";\n+    public static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n+    public static final String TEST_VM_FLAGS_DELIMITER = \" \";\n+\n+    private static final String TEST_VM_FLAGS_FILE;\n+    private static final WhiteBox WHITE_BOX;\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+            TEST_VM_FLAGS_FILE = TEST_VM_FLAGS_FILE_PREFIX + ProcessTools.getProcessId() + TEST_VM_FLAGS_FILE_POSTFIX;\n+        } catch (UnsatisfiedLinkError e) {\n+            throw new TestFrameworkException(\"Could not load WhiteBox\", e);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Could not get process id\", e);\n+        }\n+    }\n+\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL =\n+            CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    private static final boolean TEST_C1 = TIERED_COMPILATION\n+                                           && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean REQUESTED_VERIFY_IR = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private static final boolean VERIFY_IR = REQUESTED_VERIFY_IR && USE_COMPILER && !EXCLUDE_RANDOM && !FLIP_C1_C2 && !TEST_C1;\n+\n+    private static String[] getPrintFlags() {\n+        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n+    }\n+\n+    \/**\n+     * Main entry point of the flag VM.\n+     *\/\n+    public static void main(String[] args) {\n+        String testClassName = args[0];\n+        if (VERBOSE) {\n+            System.out.println(\"FlagVM main() called. Prepare test VM flags to run class \" + testClassName);\n+        }\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find test class \" + testClassName, e);\n+        }\n+        emitTestVMFlags(prepareTestVmFlags(testClass));\n+    }\n+\n+    \/**\n+     * Emit test VM flags to the dedicated test VM flags file to parse them from the TestFramework \"driver\" VM again\n+     * which adds them to the test VM.\n+     *\/\n+    private static void emitTestVMFlags(ArrayList<String> flags) {\n+        try (var bw = Files.newBufferedWriter(Paths.get(TEST_VM_FLAGS_FILE))) {\n+            bw.write(String.join(TEST_VM_FLAGS_DELIMITER, flags));\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while writing to file \" + TEST_VM_FLAGS_FILE, e);\n+        }\n+    }\n+\n+    private static ArrayList<String> prepareTestVmFlags(Class<?> testClass) {\n+        return setupIrVerificationFlags(testClass);\n+    }\n+\n+    private static ArrayList<String> setupIrVerificationFlags(Class<?> testClass) {\n+        ArrayList<String> cmds = new ArrayList<>();\n+        if (VERIFY_IR) {\n+            \/\/ Add print flags for IR verification\n+            cmds.addAll(Arrays.asList(getPrintFlags()));\n+            cmds.add(\"-XX:+LogCompilation\");\n+            cmds.add(\"-XX:CompileCommand=log,\" + testClass.getCanonicalName() + \"::*\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintIdeal\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintOptoAssembly\");\n+            \/\/ Always trap for exception throwing to not confuse IR verification\n+            cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n+            cmds.add(\"-DShouldDoIRVerification=true\");\n+        } else {\n+            cmds.add(\"-DShouldDoIRVerification=false\");\n+        }\n+        return cmds;\n+    }\n+\n+    private static void addBoolOptionForClass(ArrayList<String> cmds, Class<?> testClass, String option) {\n+        cmds.add(\"-XX:CompileCommand=option,\" + testClass.getCanonicalName() + \"::*,bool,\" + option + \",true\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/FlagVM.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Checked internal exceptions in the framework to propagate error handling.\n+ *\/\n+public class CheckedTestFrameworkException extends Exception {\n+    public CheckedTestFrameworkException(String msg) {\n+        super(msg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/CheckedTestFrameworkException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown by the test VM if no tests are run as a result of specifying {@code -DTest} and\/or\n+ * {@code -DExclude} defining an empty set with the used test VM flags.\n+ *\/\n+public class NoTestsRunException extends RuntimeException {\n+    \/**\n+     * Default constructor used by test VM\n+     *\/\n+    public NoTestsRunException() {}\n+\n+    \/**\n+     * Constructor used to eventually throw the exception in the driver VM.\n+     *\/\n+    public NoTestsRunException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/NoTestsRunException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+\n+\/**\n+ * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n+ *\/\n+public class ParsedComparator<T extends Comparable<T>> {\n+    private final String strippedString;\n+    private final BiPredicate<T, T> predicate;\n+    private final String comparator;\n+\n+    public ParsedComparator(String strippedString, BiPredicate<T, T> predicate, String comparator) {\n+        this.strippedString = strippedString;\n+        this.predicate = predicate;\n+        this.comparator = comparator;\n+    }\n+\n+    public String getStrippedString() {\n+        return strippedString;\n+    }\n+\n+    public BiPredicate<T, T> getPredicate() {\n+        return predicate;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+\n+    \/**\n+     * Return parsed comparator object which provides the predicate to perform the test.\n+     * Allowed comparators: <, <=, >, =>, =, !=\n+     *\/\n+    public static <T extends Comparable<T>> ParsedComparator<T> parseComparator(String value) throws CheckedTestFrameworkException {\n+        BiPredicate<T, T> comparison;\n+        value = value.trim();\n+        String comparator = \"\";\n+        switch (value.charAt(0)) {\n+            case '<':\n+                if (value.charAt(1) == '=') {\n+                    comparator = \"<=\";\n+                    comparison = (x, y) -> x.compareTo(y) <= 0;\n+                    value = value.substring(2).trim();\n+                } else {\n+                    comparator = \"<\";\n+                    comparison = (x, y) -> x.compareTo(y) < 0;\n+                    value = value.substring(1).trim();\n+                }\n+                break;\n+            case '>':\n+                if (value.charAt(1) == '=') {\n+                    comparator = \">=\";\n+                    comparison = (x, y) -> x.compareTo(y) >= 0;\n+                    value = value.substring(2).trim();\n+                } else {\n+                    comparator = \">\";\n+                    comparison = (x, y) -> x.compareTo(y) > 0;\n+                    value = value.substring(1).trim();\n+                }\n+                break;\n+            case '!':\n+                if (value.charAt(1) != '=') {\n+                    throw new CheckedTestFrameworkException(value.substring(0, 1));\n+                }\n+                comparator = \"!=\";\n+                comparison = (x, y) -> x.compareTo(y) != 0;\n+                value = value.substring(2).trim();\n+                break;\n+            case '=': \/\/ Allowed syntax, equivalent to not using any symbol.\n+                comparator = \"=\";\n+                value = value.substring(1).trim();\n+                \/\/ Fall through\n+            default:\n+                comparison = (x, y) -> x.compareTo(y) == 0;\n+                value = value.trim();\n+                break;\n+        }\n+        return new ParsedComparator<>(value, comparison, comparator);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ParsedComparator.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Utility class to report a {@link TestFormatException}.\n+ *\/\n+public class TestFormat {\n+    private static final List<String> FAILURES = new ArrayList<>();\n+\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            fail(failureMessage);\n+        }\n+    }\n+\n+    public static void checkNoThrow(boolean test, String failureMessage) {\n+        if (!test) {\n+            failNoThrow(failureMessage);\n+        }\n+    }\n+\n+    public static void fail(String failureMessage) {\n+        FAILURES.add(failureMessage);\n+        throw new TestFormatException(failureMessage);\n+    }\n+\n+    public static void failNoThrow(String failureMessage) {\n+        FAILURES.add(failureMessage);\n+    }\n+\n+    public static void reportIfAnyFailures() {\n+        if (FAILURES.isEmpty()) {\n+            \/\/ No format violation detected.\n+            return;\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(System.lineSeparator()).append(\"One or more format violations have been detected:\")\n+               .append(System.lineSeparator()).append(System.lineSeparator());\n+        builder.append(\"Violations (\").append(FAILURES.size()).append(\")\").append(System.lineSeparator());\n+        builder.append(\"-------------\").append(\"-\".repeat(String.valueOf(FAILURES.size()).length()))\n+               .append(System.lineSeparator());\n+        for (String failure : FAILURES) {\n+            builder.append(\" - \").append(failure).append(System.lineSeparator());\n+        }\n+        builder.append(\"\/============\/\");\n+        FAILURES.clear();\n+        throw new TestFormatException(builder.toString());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if a JTreg test violates the supported format by the test framework.\n+ *\/\n+public class TestFormatException extends RuntimeException {\n+    public TestFormatException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormatException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if there is an internal error in the framework. This is most likely an indicator of a bug\n+ * in the framework.\n+ *\/\n+public class TestFrameworkException extends RuntimeException {\n+    public TestFrameworkException(String message) {\n+        super(\"Internal Test Framework exception - please file a bug:\" + System.lineSeparator() + message);\n+    }\n+\n+    public TestFrameworkException(String message, Throwable e) {\n+        super(\"Internal Test Framework exception - please file a bug:\" + System.lineSeparator() + message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.FutureTask;\n+\n+\/**\n+ * Dedicated socket to send data from the flag and test VM back to the driver VM.\n+ *\/\n+public class TestFrameworkSocket implements AutoCloseable {\n+    public static final String STDOUT_PREFIX = \"[STDOUT]\";\n+    \/\/ Static fields used for test VM only.\n+    private static final String SERVER_PORT_PROPERTY = \"ir.framework.server.port\";\n+    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n+\n+    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n+    private static final String HOSTNAME = null;\n+    private static Socket clientSocket = null;\n+    private static PrintWriter clientWriter = null;\n+\n+    private final String serverPortPropertyFlag;\n+    private FutureTask<String> socketTask;\n+    private final ServerSocket serverSocket;\n+\n+    public TestFrameworkSocket() {\n+        try {\n+            serverSocket = new ServerSocket(0);\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Failed to create TestFramework server socket\", e);\n+        }\n+        int port = serverSocket.getLocalPort();\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"TestFramework server socket uses port \" + port);\n+        }\n+        serverPortPropertyFlag = \"-D\" + SERVER_PORT_PROPERTY + \"=\" + port;\n+        start();\n+    }\n+\n+    public String getPortPropertyFlag() {\n+        return serverPortPropertyFlag;\n+    }\n+\n+    private void start() {\n+        socketTask = initSocketTask();\n+        Thread socketThread = new Thread(socketTask);\n+        socketThread.start();\n+    }\n+\n+    \/**\n+     * Waits for a client (created by flag or test VM) to connect. Return the messages received from the client.\n+     *\/\n+    private FutureTask<String> initSocketTask() {\n+        return new FutureTask<>(() -> {\n+            try (Socket clientSocket = serverSocket.accept();\n+                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))\n+            ) {\n+                StringBuilder builder = new StringBuilder();\n+                String next;\n+                while ((next = in.readLine()) != null) {\n+                    builder.append(next).append(System.lineSeparator());\n+                }\n+                return builder.toString();\n+            } catch (IOException e) {\n+                throw new TestFrameworkException(\"Server socket error\", e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Could not close socket\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type) {\n+        write(msg, type, false);\n+    }\n+\n+    \/**\n+     * Only called by test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type, boolean stdout) {\n+        if (REPRODUCE) {\n+            System.out.println(\"Debugging Test VM: Skip writing due to -DReproduce\");\n+            return;\n+        }\n+        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n+                                               + \"or method not called from flag or test VM\");\n+        try {\n+            \/\/ Keep the client socket open until the test VM terminates (calls closeClientSocket before exiting main()).\n+            if (clientSocket == null) {\n+                clientSocket = new Socket(HOSTNAME, SERVER_PORT);\n+                clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n+            }\n+            if (stdout) {\n+                msg = STDOUT_PREFIX + msg;\n+            }\n+            clientWriter.println(msg);\n+        } catch (Exception e) {\n+            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n+            \/\/ driver VM.\n+            String failMsg = System.lineSeparator() + System.lineSeparator() + \"\"\"\n+                             ###########################################################\n+                              Did you directly run the test VM (TestVM class)\n+                              to reproduce a bug?\n+                              => Append the flag -DReproduce=true and try again!\n+                             ###########################################################\n+                             \"\"\";\n+            throw new TestRunException(failMsg, e);\n+        }\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Written \" + type + \" to socket:\");\n+            System.out.println(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n+     * the main() method of the flag and the test VM.\n+     *\/\n+    public static void closeClientSocket() {\n+        if (clientSocket != null) {\n+            try {\n+                clientWriter.close();\n+                clientSocket.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close TestVM socket\", e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Get the socket output of the flag VM.\n+     *\/\n+    public String getOutput() {\n+        try {\n+            return socketTask.get();\n+        } catch (ExecutionException e) {\n+            \/\/ Thrown when socket task was not finished, yet (i.e. no client sent data) but socket was already closed.\n+            return \"\";\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Could not read from socket task\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Utility class to report a {@link TestRunException}.\n+ *\/\n+public class TestRun {\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            throw new TestRunException(failureMessage);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRun.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if the JTreg test throws an exception during the execution of individual tests of the\n+ * test class.\n+ *\/\n+public class TestRunException extends RuntimeException {\n+    public TestRunException(String message) {\n+        super(message);\n+    }\n+\n+    public TestRunException(String message, Exception e) {\n+        super(message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRunException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * Abstract super class for base, checked and custom run tests.\n+ *\/\n+abstract class AbstractTest {\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    protected static final int TEST_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"TestCompilationTimeout\", \"10000\"));\n+    protected static final int WAIT_FOR_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"WaitForCompilationTimeout\", \"10000\"));\n+    protected static final boolean VERIFY_OOPS = (Boolean)WHITE_BOX.getVMFlag(\"VerifyOops\");\n+\n+    protected final int warmupIterations;\n+    protected final boolean skip;\n+\n+    AbstractTest(int warmupIterations, boolean skip) {\n+        this.warmupIterations = warmupIterations;\n+        this.skip = skip;\n+    }\n+\n+    protected boolean shouldCompile(DeclaredTest test) {\n+        return test.getCompLevel() != CompLevel.SKIP;\n+    }\n+\n+    abstract String getName();\n+\n+    \/**\n+     * Should test be executed?\n+     *\/\n+    public boolean isSkipped() {\n+        return skip;\n+    }\n+\n+    \/**\n+     * See {@link CompLevel#WAIT_FOR_COMPILATION}.\n+     *\/\n+    protected static boolean isWaitForCompilation(DeclaredTest test) {\n+        return test.getCompLevel() == CompLevel.WAIT_FOR_COMPILATION;\n+    }\n+\n+    protected static Object createInvocationTarget(Method method) {\n+        Class<?> clazz = method.getDeclaringClass();\n+        Object invocationTarget;\n+        if (Modifier.isStatic(method.getModifiers())) {\n+            invocationTarget = null;\n+        } else {\n+            try {\n+                Constructor<?> constructor = clazz.getDeclaredConstructor();\n+                constructor.setAccessible(true);\n+                invocationTarget = constructor.newInstance();\n+            } catch (Exception e) {\n+                throw new TestRunException(\"Could not create instance of \" + clazz\n+                                           + \". Make sure there is a constructor without arguments.\", e);\n+            }\n+        }\n+        return invocationTarget;\n+    }\n+\n+    \/**\n+     * Run the associated test.\n+     *\/\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        onStart();\n+        for (int i = 0; i < warmupIterations; i++) {\n+            invokeTest();\n+        }\n+        onWarmupFinished();\n+        compileTest();\n+        \/\/ Always run the test as a last step of the test execution.\n+        invokeTest();\n+    }\n+\n+    protected void onStart() {\n+        \/\/ Do nothing by default.\n+    }\n+\n+    abstract protected void invokeTest();\n+\n+    abstract protected void onWarmupFinished();\n+\n+    abstract protected void compileTest();\n+\n+    protected void compileMethod(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Compile method \" + testMethod + \" after warm-up...\");\n+        }\n+\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+        int lastCompilationLevel = -10;\n+        enqueueMethodForCompilation(test);\n+\n+        do {\n+            if (!WHITE_BOX.isMethodQueuedForCompilation(testMethod)) {\n+                if (elapsed > 0) {\n+                    if (TestVM.VERBOSE) {\n+                        System.out.println(testMethod + \" is not in queue anymore due to compiling it simultaneously on \" +\n+                                           \"a different level. Enqueue again.\");\n+                    }\n+                    enqueueMethodForCompilation(test);\n+                }\n+            }\n+            if (maybeCodeBufferOverflow && elapsed > 1000 && !WHITE_BOX.isMethodCompiled(testMethod, false)) {\n+                \/\/ Let's disable VerifyOops temporarily and retry.\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+                WHITE_BOX.clearMethodState(testMethod);\n+                enqueueMethodForCompilation(test);\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            }\n+\n+            lastCompilationLevel = WHITE_BOX.getMethodCompilationLevel(testMethod, false);\n+            if (lastCompilationLevel == test.getCompLevel().getValue()) {\n+                break;\n+            }\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < TEST_COMPILATION_TIMEOUT);\n+        TestRun.check(elapsed < TEST_COMPILATION_TIMEOUT,\n+                      \"Could not compile \" + testMethod + \" at level \" + test.getCompLevel() + \" after \"\n+                      + TEST_COMPILATION_TIMEOUT\/1000 + \"s. Last compilation level: \" + lastCompilationLevel);\n+        checkCompilationLevel(test);\n+    }\n+\n+    private void enqueueMethodForCompilation(DeclaredTest test) {\n+        TestVM.enqueueForCompilation(test.getTestMethod(), test.getCompLevel());\n+    }\n+\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WHITE_BOX.getMethodCompilationLevel(test.getTestMethod()));\n+        TestRun.check(level == test.getCompLevel(),  \"Compilation level should be \" + test.getCompLevel().name()\n+                                                     + \" (requested) but was \" + level.name() + \" for \" + test.getTestMethod());\n+    }\n+\n+    final protected void waitForCompilation(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        boolean stateCleared = false;\n+        long elapsed;\n+        do {\n+            elapsed = System.currentTimeMillis() - started;\n+            int level = WHITE_BOX.getMethodCompilationLevel(testMethod);\n+            if (maybeCodeBufferOverflow && elapsed > 5000\n+                && (!WHITE_BOX.isMethodCompiled(testMethod, false) || level != test.getCompLevel().getValue())) {\n+                retryDisabledVerifyOops(testMethod, stateCleared);\n+                stateCleared = true;\n+            } else {\n+                invokeTest();\n+            }\n+\n+            boolean isCompiled = WHITE_BOX.isMethodCompiled(testMethod, false);\n+            if (TestVM.VERBOSE) {\n+                System.out.println(\"Is \" + testMethod + \" compiled? \" + isCompiled);\n+            }\n+            if (isCompiled || TestVM.XCOMP || TestVM.EXCLUDE_RANDOM) {\n+                \/\/ Don't wait for compilation if -Xcomp is enabled or if we are randomly excluding methods from compilation.\n+                return;\n+            }\n+        } while (elapsed < WAIT_FOR_COMPILATION_TIMEOUT);\n+        throw new TestRunException(testMethod + \" not compiled after waiting for \"\n+                                   + WAIT_FOR_COMPILATION_TIMEOUT\/1000 + \" s\");\n+    }\n+\n+    \/**\n+     * If it takes too long, try to disable Verify Oops.\n+     *\/\n+    private void retryDisabledVerifyOops(Method testMethod, boolean stateCleared) {\n+        System.out.println(\"Temporarily disabling VerifyOops\");\n+        try {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+            if (!stateCleared) {\n+                WHITE_BOX.clearMethodState(testMethod);\n+            }\n+            invokeTest();\n+        } finally {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            System.out.println(\"Re-enabled VerifyOops\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/AbstractTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import java.util.Random;\n+\n+\/**\n+ * This class represents an argument value specified by {@link Argument} in {@link Arguments}.\n+ *\/\n+class ArgumentValue {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private final Object argumentValue;\n+    private final boolean isRandomEach;\n+    private final boolean isFixedRandom;\n+    private final Class<?> randomClass;\n+\n+    ArgumentValue() {\n+        this.argumentValue = null;\n+        this.isRandomEach = false;\n+        this.randomClass = null;\n+        this.isFixedRandom = false;\n+    }\n+\n+    private ArgumentValue(Object argumentValue, boolean isFixedRandom) {\n+        this.argumentValue = argumentValue;\n+        this.isRandomEach = false;\n+        this.randomClass = null;\n+        this.isFixedRandom = isFixedRandom;\n+    }\n+\n+    private ArgumentValue(Object argumentValue, Class<?> randomClass) {\n+        this.argumentValue = argumentValue;\n+        this.isRandomEach = true;\n+        this.randomClass = randomClass;\n+        this.isFixedRandom = false;\n+    }\n+\n+    \/**\n+     * Return all arguments for the @Arguments annotation.\n+     *\n+     * @param m The @Test method.\n+     * @return Returns an array with Argument objects for each specified argument in the @Arguments annotation of m.\n+     *         Returns null if method has no @Arguments annotation.\n+     *\/\n+    public static ArgumentValue[] getArguments(Method m) {\n+        Arguments argumentsAnno = m.getAnnotation(Arguments.class);\n+        if (argumentsAnno == null) {\n+            return null;\n+        }\n+        Argument[] values = argumentsAnno.value();\n+        ArgumentValue[] arguments = new ArgumentValue[values.length];\n+        Class<?>[] declaredParameters = m.getParameterTypes();\n+        Parameter[] declaredParameterObjects = m.getParameters();\n+        try {\n+            TestFormat.check(values.length == declaredParameters.length,\n+                             \"Number of argument values provided in @Arguments does not match the number \" +\n+                             \"of actual arguments in \" + m);\n+\n+            for (int i = 0; i < values.length; i++) {\n+                Argument specifiedArg = values[i];\n+                Class<?> parameter = declaredParameters[i];\n+                Parameter parameterObj = declaredParameterObjects[i];\n+                try {\n+                    switch (specifiedArg) {\n+                        case DEFAULT -> {\n+                            try {\n+                                arguments[i] = createDefault(parameter);\n+                            } catch (NoSuchMethodException e) {\n+                                TestFormat.fail(\"Cannot create new default instance of \" + parameter\n+                                                + \" for \" + m + \" due to missing default constructor\");\n+                            } catch (Exception e) {\n+                                TestFormat.fail(\"Cannot create new default instance of \" + parameter\n+                                                + \" for \" + m + \": \" + e.getCause());\n+                            }\n+                        }\n+                        case NUMBER_42 -> {\n+                            TestFormat.check(isNumber(parameter), \"Provided invalid NUMBER_42 argument \" +\n+                                                                  \"for non-number \" + parameterObj + \" for \" + m);\n+                            arguments[i] = create((byte) 42);\n+                        }\n+                        case NUMBER_MINUS_42 -> {\n+                            TestFormat.check(isNumber(parameter), \"Provided invalid NUMBER_MINUS_42 argument \" +\n+                                                                  \"for non-number \" + parameterObj + \" for \" + m);\n+                            arguments[i] = create((byte) -42);\n+                        }\n+                        case MIN -> {\n+                            TestFormat.check(isNumber(parameter) || isChar(parameter),\n+                                             \"Provided invalid MIN argument for non-number \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createMin(parameter);\n+                        }\n+                        case MAX -> {\n+                            TestFormat.check(isNumber(parameter) || isChar(parameter),\n+                                             \"Provided invalid MAX argument for non-number \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createMax(parameter);\n+                        }\n+                        case FALSE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid FALSE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = create(false);\n+                        }\n+                        case TRUE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid TRUE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = create(true);\n+                        }\n+                        case BOOLEAN_TOGGLE_FIRST_FALSE -> {\n+                            TestFormat.check(isBoolean(parameter),\n+                                             \"Provided invalid BOOLEAN_TOGGLE_FIRST_FALSE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = BooleanToggleValue.create(false);\n+                        }\n+                        case BOOLEAN_TOGGLE_FIRST_TRUE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid BOOLEAN_TOGGLE_FIRST_TRUE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = BooleanToggleValue.create(true);\n+                        }\n+                        case RANDOM_ONCE -> {\n+                            TestFormat.check(isPrimitiveType(parameter),\n+                                             \"Provided invalid RANDOM_ONCE argument for non-primitive type \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createRandom(parameter);\n+                        }\n+                        case RANDOM_EACH -> {\n+                            TestFormat.check(isPrimitiveType(parameter),\n+                                             \"Provided invalid RANDOM_EACH argument for non-primitive type \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createRandomEach(parameter);\n+                        }\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Catch and continue to check arguments.\n+                }\n+            }\n+        } catch (TestFormatException e) {\n+            \/\/ Catch and return empty array to check for additional failures.\n+            return new ArgumentValue[0];\n+        }\n+        return arguments;\n+    }\n+\n+    private static ArgumentValue create(Object argumentValue) {\n+        return new ArgumentValue(argumentValue, false);\n+    }\n+\n+    private static ArgumentValue createDefault(Class<?> c) throws Exception {\n+        if (ArgumentValue.isNumber(c)) {\n+            return ArgumentValue.create((byte)0);\n+        } else if (ArgumentValue.isChar(c)) {\n+            return ArgumentValue.create('\\u0000');\n+        } else if (ArgumentValue.isBoolean(c)) {\n+            return ArgumentValue.create(false);\n+        } else {\n+            \/\/ Object\n+            Constructor<?> constructor = c.getDeclaredConstructor();\n+            constructor.setAccessible(true); \/\/ Make sure to have access to private default constructor\n+            return ArgumentValue.create(constructor.newInstance());\n+        }\n+    }\n+\n+    private static ArgumentValue createMin(Class<?> c) {\n+        Object argument;\n+        if (c.equals(byte.class)) {\n+            argument = Byte.MIN_VALUE;\n+        } else if (isChar(c)) {\n+            argument = Character.MIN_VALUE;\n+        }  else if (c.equals(short.class)) {\n+            argument = Short.MIN_VALUE;\n+        } else if (c.equals(int.class)) {\n+            argument = Integer.MIN_VALUE;\n+        } else if (c.equals(long.class)) {\n+            argument = Long.MIN_VALUE;\n+        } else if (c.equals(float.class)) {\n+            argument = Float.MIN_VALUE;\n+        } else if (c.equals(double.class)) {\n+            argument = Double.MIN_VALUE;\n+        } else {\n+            throw new TestFrameworkException(\"Invalid class passed to createMin()\");\n+        }\n+        return new ArgumentValue(argument, false);\n+    }\n+\n+    private static ArgumentValue createMax(Class<?> c) {\n+        Object argument;\n+        if (c.equals(byte.class)) {\n+            argument = Byte.MAX_VALUE;\n+        } else if (isChar(c)) {\n+            argument = Character.MAX_VALUE;\n+        }  else if (c.equals(short.class)) {\n+            argument = Short.MAX_VALUE;\n+        } else if (c.equals(int.class)) {\n+            argument = Integer.MAX_VALUE;\n+        } else if (c.equals(long.class)) {\n+            argument = Long.MAX_VALUE;\n+        } else if (c.equals(float.class)) {\n+            argument = Float.MAX_VALUE;\n+        } else if (c.equals(double.class)) {\n+            argument = Double.MAX_VALUE;\n+        } else {\n+            throw new TestFrameworkException(\"Invalid class passed to createMax()\");\n+        }\n+        return new ArgumentValue(argument, false);\n+    }\n+\n+    private static ArgumentValue createRandom(Class<?> c) {\n+        return new ArgumentValue(getRandom(c), true);\n+    }\n+\n+    private static ArgumentValue createRandomEach(Class<?> c) {\n+        return new ArgumentValue(null, c);\n+    }\n+\n+    public boolean isFixedRandom() {\n+        return isFixedRandom;\n+    }\n+\n+    public Object getArgument() {\n+        if (isRandomEach) {\n+            return getRandom(randomClass);\n+        } else {\n+            return argumentValue;\n+        }\n+    }\n+\n+    private static boolean isPrimitiveType(Class<?> c) {\n+        return isNumber(c) || isBoolean(c) || isChar(c);\n+    }\n+\n+    private static boolean isBoolean(Class<?> c) {\n+        return c.equals(boolean.class);\n+    }\n+\n+    private static boolean isChar(Class<?> c) {\n+        return c.equals(char.class);\n+    }\n+\n+    private static boolean isNumber(Class<?> c) {\n+        return isIntNumber(c) || isFloatNumber(c);\n+    }\n+\n+    private static boolean isIntNumber(Class<?> c) {\n+        return c.equals(byte.class)\n+                || c.equals(short.class)\n+                || c.equals(int.class)\n+                || c.equals(long.class);\n+    }\n+\n+    private static boolean isFloatNumber(Class<?> c) {\n+        return c.equals(float.class) || c.equals(double.class);\n+    }\n+\n+    private static Object getRandom(Class<?> c) {\n+        if (isBoolean(c)) {\n+            return RANDOM.nextBoolean();\n+        } else if (c.equals(byte.class)) {\n+            return (byte) RANDOM.nextInt(256);\n+        } else if (isChar(c)) {\n+            return (char) RANDOM.nextInt(65536);\n+        }  else if (c.equals(short.class)) {\n+            return (short) RANDOM.nextInt(65536);\n+        } else if (c.equals(int.class)) {\n+            return RANDOM.nextInt();\n+        } else if (c.equals(long.class)) {\n+            return RANDOM.nextLong();\n+        } else if (c.equals(float.class)) {\n+            \/\/ Get float between -10000 and 10000.\n+            return RANDOM.nextFloat() * 20000 - 10000;\n+        } else if (c.equals(double.class)) {\n+            \/\/ Get double between -10000 and 10000.\n+            return RANDOM.nextDouble() * 20000 - 10000;\n+        } else {\n+            TestFormat.fail(\"Cannot generate random value for non-primitive type\");\n+            return null;\n+        }\n+    }\n+}\n+\n+\/**\n+ * Special class to handle boolean toggle argument values.\n+ *\/\n+class BooleanToggleValue extends ArgumentValue {\n+    private boolean previousBoolean;\n+\n+    BooleanToggleValue(boolean firstBoolean) {\n+        this.previousBoolean = !firstBoolean;\n+    }\n+\n+    @Override\n+    public Object getArgument() {\n+        previousBoolean = !previousBoolean;\n+        return previousBoolean;\n+    }\n+\n+    static BooleanToggleValue create(boolean firstBoolean) {\n+        return new BooleanToggleValue(firstBoolean);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ArgumentValue.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * A base test only consists of a single @Test method. See {@link Test} for more details and its precise definition.\n+ *\/\n+class BaseTest extends AbstractTest {\n+    private final DeclaredTest test;\n+    protected final Method testMethod;\n+    protected final TestInfo testInfo;\n+    protected final Object invocationTarget;\n+    private final boolean shouldCompile;\n+    private final boolean waitForCompilation;\n+\n+    public BaseTest(DeclaredTest test, boolean skip) {\n+        super(test.getWarmupIterations(), skip);\n+        this.test = test;\n+        this.testMethod = test.getTestMethod();\n+        this.testInfo = new TestInfo(testMethod, test.getCompLevel());\n+        this.invocationTarget = createInvocationTarget(testMethod);\n+        this.shouldCompile = shouldCompile(test);\n+        this.waitForCompilation = isWaitForCompilation(test);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Base Test: @Test \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return testMethod.getName();\n+    }\n+\n+    @Override\n+    protected void onStart() {\n+        test.printFixedRandomArguments();\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        testInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void invokeTest() {\n+        verify(invokeTestMethod());\n+    }\n+\n+    private Object invokeTestMethod() {\n+        try {\n+            if (test.hasArguments()) {\n+                return testMethod.invoke(invocationTarget, test.getArguments());\n+            } else {\n+                return testMethod.invoke(invocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod\n+                                       + \". Used arguments: \" + test.getArgumentsString(), e);\n+        }\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (shouldCompile) {\n+            if (waitForCompilation) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify the result\n+     *\/\n+    public void verify(Object result) { \/* no verification in BaseTests *\/ }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/BaseTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.CheckAt;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * A checked test is an extension of a base test with additional verification done in a @Check method.\n+ * See {@link Check} for more details and its precise definition.\n+ *\/\n+class CheckedTest extends BaseTest {\n+    private final Method checkMethod;\n+    private final CheckAt checkAt;\n+    private final Parameter parameter;\n+    private final Object checkInvocationTarget;\n+\n+    enum Parameter {\n+        NONE, RETURN_ONLY, TEST_INFO_ONLY, BOTH\n+    }\n+\n+    public CheckedTest(DeclaredTest test, Method checkMethod, Check checkSpecification, Parameter parameter, boolean excludedByUser) {\n+        super(test, excludedByUser);\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        checkMethod.setAccessible(true);\n+        this.checkMethod = checkMethod;\n+        this.checkAt = checkSpecification.when();\n+        this.parameter = parameter;\n+        \/\/ Use the same invocation target\n+        if (Modifier.isStatic(checkMethod.getModifiers())) {\n+            this.checkInvocationTarget = null;\n+        } else {\n+            \/\/ Use the same invocation target as the test method if check method is non-static.\n+            this.checkInvocationTarget = this.invocationTarget != null ? this.invocationTarget : createInvocationTarget(checkMethod);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Checked Test: @Check \" + checkMethod.getName() + \" - @Test: \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return checkMethod.getName();\n+    }\n+\n+    @Override\n+    public void verify(Object result) {\n+        boolean shouldVerify = false;\n+        switch (checkAt) {\n+            case EACH_INVOCATION -> shouldVerify = true;\n+            case COMPILED -> shouldVerify = !testInfo.isWarmUp();\n+        }\n+        if (shouldVerify) {\n+            try {\n+                switch (parameter) {\n+                    case NONE -> checkMethod.invoke(checkInvocationTarget);\n+                    case RETURN_ONLY -> checkMethod.invoke(checkInvocationTarget, result);\n+                    case TEST_INFO_ONLY -> checkMethod.invoke(checkInvocationTarget, testInfo);\n+                    case BOTH -> checkMethod.invoke(checkInvocationTarget, result, testInfo);\n+                }\n+            } catch (Exception e) {\n+                throw new TestRunException(\"There was an error while invoking @Check method \" + checkMethod, e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CheckedTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A custom run test allows the user to have full control over how the @Test method is invoked by specifying\n+ * a dedicated @Run method. See {@link Run} for more details and its precise definition.\n+ *\/\n+class CustomRunTest extends AbstractTest {\n+    private final Method runMethod;\n+    private final RunMode mode;\n+    private final Object runInvocationTarget;\n+    private final List<DeclaredTest> tests;\n+    private final RunInfo runInfo;\n+\n+    public CustomRunTest(Method runMethod, Warmup warmUpAnno, Run runSpecification, List<DeclaredTest> tests, boolean skip) {\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        super(warmUpAnno != null ? warmUpAnno.value() : TestVM.WARMUP_ITERATIONS, skip);\n+        TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + runMethod);\n+        runMethod.setAccessible(true);\n+        this.runMethod = runMethod;\n+        this.runInvocationTarget = createInvocationTarget(runMethod);\n+        this.mode = runSpecification.mode();\n+        this.tests = tests;\n+        this.runInfo = new RunInfo(tests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"Custom Run Test: @Run: \" + runMethod.getName() + \" - @Test\";\n+        if (tests.size() == 1) {\n+            s += \": \" + tests.get(0).getTestMethod().getName();\n+        } else {\n+            s += \"s: {\" + tests.stream().map(t -> t.getTestMethod().getName())\n+                               .collect(Collectors.joining(\",\")) + \"}\";\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    String getName() {\n+        return runMethod.getName();\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        switch (mode) {\n+            case STANDALONE -> {\n+                runInfo.setWarmUpFinished();\n+                invokeTest();\n+            }\/\/ Invoke once but do not apply anything else.\n+            case NORMAL -> super.run();\n+        }\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        runInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (tests.size() == 1) {\n+            compileSingleTest();\n+        } else {\n+            compileMultipleTests();\n+        }\n+    }\n+\n+    private void compileSingleTest() {\n+        DeclaredTest test = tests.get(0);\n+        if (shouldCompile(test)) {\n+            if (isWaitForCompilation(test)) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    private void compileMultipleTests() {\n+        boolean anyWaitForCompilation = false;\n+        boolean anyCompileMethod = false;\n+        ExecutorService executor = Executors.newFixedThreadPool(tests.size());\n+        for (DeclaredTest test : tests) {\n+            if (shouldCompile(test)) {\n+                if (isWaitForCompilation(test)) {\n+                    anyWaitForCompilation = true;\n+                    executor.execute(() -> waitForCompilation(test));\n+                } else {\n+                    anyCompileMethod = true;\n+                    executor.execute(() -> compileMethod(test));\n+                }\n+            }\n+        }\n+        executor.shutdown();\n+        int timeout;\n+        if (anyCompileMethod && anyWaitForCompilation) {\n+            timeout = Math.max(WAIT_FOR_COMPILATION_TIMEOUT, TEST_COMPILATION_TIMEOUT) + 5000;\n+        } else if (anyWaitForCompilation) {\n+            timeout = WAIT_FOR_COMPILATION_TIMEOUT + 5000;\n+        } else {\n+            timeout = TEST_COMPILATION_TIMEOUT + 5000;\n+        }\n+        try {\n+            executor.awaitTermination(timeout, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            throw new TestRunException(\"Some compilations did not complete after \" + timeout\n+                                       + \"ms for @Run method \" + runMethod);\n+        }\n+    }\n+\n+    \/**\n+     * Do not directly run the test but rather the run method that is responsible for invoking the actual test.\n+     *\/\n+    @Override\n+    protected void invokeTest() {\n+        try {\n+            if (runMethod.getParameterCount() == 1) {\n+                runMethod.invoke(runInvocationTarget, runInfo);\n+            } else {\n+                runMethod.invoke(runInvocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Run method \" + runMethod, e);\n+        }\n+    }\n+\n+    @Override\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WhiteBox.getWhiteBox().getMethodCompilationLevel(test.getTestMethod()));\n+        if (level != test.getCompLevel()) {\n+            String message = \"Compilation level should be \" + test.getCompLevel().name() + \" (requested) but was \"\n+                             + level.name() + \" for \" + test.getTestMethod() + \".\";\n+            switch (mode) {\n+                case STANDALONE -> throw new TestFrameworkException(\"Should not be called for STANDALONE method \" + runMethod);\n+                case NORMAL -> message = message + System.lineSeparator() + \"Check your @Run method \" + runMethod\n+                                         + \" to ensure that \" + test.getTestMethod()\n+                                         + \" is called at least once in each iteration.\";\n+            }\n+            throw new TestRunException(message);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CustomRunTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+\/**\n+ * This class represents a @Test method.\n+ *\/\n+public class DeclaredTest {\n+    private final Method testMethod;\n+    private final ArgumentValue[] arguments;\n+    private final int warmupIterations;\n+    private final CompLevel compLevel;\n+    private Method attachedMethod;\n+\n+    public DeclaredTest(Method testMethod, ArgumentValue[] arguments, CompLevel compLevel, int warmupIterations) {\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        testMethod.setAccessible(true);\n+        this.testMethod = testMethod;\n+        this.compLevel = compLevel;\n+        this.arguments = arguments;\n+        this.warmupIterations = warmupIterations;\n+        this.attachedMethod = null;\n+    }\n+\n+    public Method getTestMethod() {\n+        return testMethod;\n+    }\n+\n+    public CompLevel getCompLevel() {\n+        return compLevel;\n+    }\n+\n+    public int getWarmupIterations() {\n+        return warmupIterations;\n+    }\n+\n+    public boolean hasArguments() {\n+        return arguments != null;\n+    }\n+\n+    public Object[] getArguments() {\n+        return Arrays.stream(arguments).map(ArgumentValue::getArgument).toArray();\n+    }\n+\n+    public void setAttachedMethod(Method m) {\n+        attachedMethod = m;\n+    }\n+\n+    public Method getAttachedMethod() {\n+        return attachedMethod;\n+    }\n+\n+    public void printFixedRandomArguments() {\n+        if (hasArguments()) {\n+            boolean hasRandomArgs = false;\n+            StringBuilder builder = new StringBuilder(\"Fixed random arguments for method \").append(testMethod).append(\": \");\n+            for (int i = 0; i < arguments.length; i++) {\n+                ArgumentValue argument = arguments[i];\n+                if (argument.isFixedRandom()) {\n+                    hasRandomArgs = true;\n+                    Object argumentVal = argument.getArgument();\n+                    builder.append(\"arg \").append(i).append(\": \").append(argumentVal.toString());\n+                    if (argumentVal instanceof Character) {\n+                        builder.append(\" (\").append((int)(Character)argumentVal).append(\")\");\n+                    }\n+                    builder.append(\", \");\n+                }\n+            }\n+            if (hasRandomArgs) {\n+                \/\/ Drop the last comma and space.\n+                builder.setLength(builder.length() - 2);\n+                System.out.println(builder.toString());\n+            }\n+        }\n+    }\n+\n+    public String getArgumentsString() {\n+        if (hasArguments()) {\n+            StringBuilder builder = new StringBuilder();\n+            for (int i = 0; i < arguments.length; i++) {\n+                builder.append(\"arg \").append(i).append(\": \").append(arguments[i].getArgument()).append(\", \");\n+            }\n+            builder.setLength(builder.length() - 2);\n+            return builder.toString();\n+        } else {\n+            return \"<void>\";\n+        }\n+    }\n+\n+    public Object invoke(Object obj, Object... args) {\n+        try {\n+            return testMethod.invoke(obj, args);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod, e);\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/DeclaredTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+\/**\n+ * Prints an encoding to the dedicated test framework socket whether @IR rules of @Test methods should be applied or not.\n+ * This is done during the execution of the test VM by checking the active VM flags. This encoding is eventually parsed\n+ * and checked by the IRMatcher class in the driver VM after the termination of the test VM.\n+ *\/\n+public class IREncodingPrinter {\n+    public static final String START = \"##### IRMatchRulesEncoding - used by TestFramework #####\";\n+    public static final String END = \"----- END -----\";\n+    public static final int NO_RULE_APPLIED = -1;\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final List<Function<String, Object>> LONG_GETTERS = Arrays.asList(\n+            WHITE_BOX::getIntVMFlag, WHITE_BOX::getUintVMFlag, WHITE_BOX::getIntxVMFlag,\n+            WHITE_BOX::getUintxVMFlag, WHITE_BOX::getUint64VMFlag, WHITE_BOX::getSizeTVMFlag);\n+\n+    private final StringBuilder output = new StringBuilder();\n+    private Method method;\n+    private int ruleIndex;\n+\n+    public IREncodingPrinter() {\n+        output.append(START).append(System.lineSeparator());\n+        output.append(\"<method>,{comma separated applied @IR rule ids}\").append(System.lineSeparator());\n+    }\n+\n+    \/**\n+     * Emits \"<method>,{ids}\" where {ids} is either:\n+     * - indices of all @IR rules that should be applied, separated by a comma\n+     * - \"-1\" if no @IR rule should not be applied\n+     *\/\n+    public void emitRuleEncoding(Method m, boolean skipped) {\n+        method = m;\n+        int i = 0;\n+        ArrayList<Integer> validRules = new ArrayList<>();\n+        IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+        if (!skipped) {\n+            for (IR irAnno : irAnnos) {\n+                ruleIndex = i + 1;\n+                try {\n+                    if (shouldApplyIrRule(irAnno)) {\n+                        validRules.add(i);\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Catch logged failure and continue to check other IR annotations.\n+                }\n+                i++;\n+            }\n+        }\n+        if (irAnnos.length != 0) {\n+            output.append(m.getName());\n+            if (validRules.isEmpty()) {\n+                output.append(\",\" + NO_RULE_APPLIED);\n+            } else {\n+                for (i = 0; i < validRules.size(); i++) {\n+                    output.append(\",\").append(validRules.get(i));\n+                }\n+            }\n+            output.append(System.lineSeparator());\n+        }\n+    }\n+\n+    private boolean shouldApplyIrRule(IR irAnno) {\n+        checkIRAnnotations(irAnno);\n+        if (irAnno.applyIf().length != 0) {\n+            return hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\");\n+        }\n+\n+        if (irAnno.applyIfNot().length != 0) {\n+            return hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\");\n+        }\n+\n+        if (irAnno.applyIfAnd().length != 0) {\n+            return hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\");\n+        }\n+\n+        if (irAnno.applyIfOr().length != 0) {\n+            return !hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\");\n+        }\n+        \/\/ No conditions, always apply.\n+        return true;\n+    }\n+\n+    private void checkIRAnnotations(IR irAnno) {\n+        TestFormat.checkNoThrow(irAnno.counts().length != 0 || irAnno.failOn().length != 0,\n+                                \"Must specify either counts or failOn constraint\" + failAt());\n+        int applyRules = 0;\n+        if (irAnno.applyIfAnd().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfAnd().length > 2,\n+                                    \"Use applyIf or applyIfNot or at least 2 conditions for applyIfAnd\" + failAt());\n+        }\n+        if (irAnno.applyIfOr().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfOr().length > 2,\n+                                    \"Use applyIf or applyIfNot or at least 2 conditions for applyIfOr\" + failAt());\n+        }\n+        if (irAnno.applyIf().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIf().length <= 2,\n+                                    \"Use applyIfAnd or applyIfOr or only 1 condition for applyIf\" + failAt());\n+        }\n+        if (irAnno.applyIfNot().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfNot().length <= 2,\n+                                    \"Use applyIfAnd or applyIfOr or only 1 condition for applyIfNot\" + failAt());\n+        }\n+        TestFormat.checkNoThrow(applyRules <= 1,\n+                                \"Can only specify one apply constraint \" + failAt());\n+\n+    }\n+\n+    private boolean hasAllRequiredFlags(String[] andRules, String ruleType) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String flag = andRules[i].trim();\n+            i++;\n+            TestFormat.check(i < andRules.length, \"Missing value for flag \" + flag + \" in \" + ruleType + failAt());\n+            String value = andRules[i].trim();\n+            if (!check(flag, value) && returnValue) {\n+                \/\/ Rule will not be applied but keep processing the other flags to verify that they are sane.\n+                returnValue = false;\n+            }\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasNoRequiredFlags(String[] orRules, String ruleType) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String flag = orRules[i];\n+            i++;\n+            TestFormat.check(i < orRules.length, \"Missing value for flag \" + flag + \" in \" + ruleType + failAt());\n+            String value = orRules[i];\n+            if (check(flag, value) && returnValue) {\n+                \/\/ Rule will not be applied but keep processing the other flags to verify that they are sane.\n+                returnValue = false;\n+            }\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean check(String flag, String value) {\n+        if (flag.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty flag\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for flag \" + flag + failAt());\n+            return false;\n+        }\n+        Object actualFlagValue = WHITE_BOX.getBooleanVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return checkBooleanFlag(flag, value, (Boolean) actualFlagValue);\n+        }\n+        actualFlagValue = LONG_GETTERS.stream().map(f -> f.apply(flag)).filter(Objects::nonNull).findAny().orElse(null);\n+        if (actualFlagValue != null) {\n+            return checkLongFlag(flag, value, (Long) actualFlagValue);\n+        }\n+        actualFlagValue = WHITE_BOX.getDoubleVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return checkDoubleFlag(flag, value, (Double) actualFlagValue);\n+        }\n+        actualFlagValue = WHITE_BOX.getStringVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return value.equals(actualFlagValue);\n+        }\n+\n+        \/\/ This could be improved if the Whitebox offers a \"isVMFlag\" function. For now, just check if we can actually set\n+        \/\/ a value for a string flag. If we find this value, it's a string flag. If null is returned, the flag is unknown.\n+        WHITE_BOX.setStringVMFlag(flag, \"test\");\n+        String stringFlagValue = WHITE_BOX.getStringVMFlag(flag);\n+        if (stringFlagValue == null) {\n+            TestFormat.failNoThrow(\"Could not find VM flag \\\"\" + flag + \"\\\"\" + failAt());\n+            return false;\n+        }\n+        TestFramework.check(stringFlagValue.equals(\"test\"),\n+                         \"Must find newly set flag value \\\"test\\\" but found \" + failAt());\n+        WHITE_BOX.setStringVMFlag(flag, null); \/\/ reset flag to NULL\n+        return false;\n+    }\n+\n+    private boolean checkBooleanFlag(String flag, String value, boolean actualFlagValue) {\n+        boolean booleanValue = false;\n+        if (\"true\".equalsIgnoreCase(value)) {\n+            booleanValue = true;\n+        } else if (!\"false\".equalsIgnoreCase(value)) {\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + value + \"\\\" for boolean flag \" + flag + failAt());\n+            return false;\n+        }\n+        return booleanValue == actualFlagValue;\n+    }\n+\n+    private boolean checkLongFlag(String flag, String value, long actualFlagValue) {\n+        long longValue;\n+        ParsedComparator<Long> parsedComparator;\n+        try {\n+            parsedComparator = ParsedComparator.parseComparator(value);\n+        } catch (CheckedTestFrameworkException e) {\n+            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for integer based flag \" + flag + failAt());\n+            return false;\n+        }  catch (IndexOutOfBoundsException e) {\n+            TestFormat.failNoThrow(\"Provided empty value for integer based flag \" + flag + failAt());\n+            return false;\n+        }\n+        try {\n+            longValue = Long.parseLong(parsedComparator.getStrippedString());\n+        } catch (NumberFormatException e) {\n+            String comparator = parsedComparator.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n+            }\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n+                            + comparator + \" for integer based flag \" + flag + failAt());\n+            return false;\n+        }\n+        return parsedComparator.getPredicate().test(actualFlagValue, longValue);\n+    }\n+\n+    private boolean checkDoubleFlag(String flag, String value, double actualFlagValue) {\n+        double doubleValue;\n+        ParsedComparator<Double> parsedComparator;\n+        try {\n+            parsedComparator = ParsedComparator.parseComparator(value);\n+        } catch (CheckedTestFrameworkException e) {\n+            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for floating point based flag \" + flag + failAt());\n+            return false;\n+        } catch (IndexOutOfBoundsException e) {\n+            TestFormat.failNoThrow(\"Provided empty value for floating point based flag \" + flag + failAt());\n+            return false;\n+        }\n+        try {\n+            doubleValue = Double.parseDouble(parsedComparator.getStrippedString());\n+        } catch (NumberFormatException e) {\n+            String comparator = parsedComparator.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n+            }\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n+                    + comparator + \" for floating point based flag \" + flag + failAt());\n+            return false;\n+        }\n+        return parsedComparator.getPredicate().test(actualFlagValue, doubleValue);\n+    }\n+\n+    private String failAt() {\n+        return \" for @IR rule \" + ruleIndex + \" at \" + method;\n+    }\n+\n+    public void emit() {\n+        output.append(END);\n+        TestFrameworkSocket.write(output.toString(), \"IR rule application encoding\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,955 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Compiler;\n+import compiler.lib.ir_framework.shared.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"test VM\". The class is\n+ * the heart of the framework and is responsible for executing all the specified tests in the test class. It uses the\n+ * Whitebox API and reflection to achieve this task.\n+ *\/\n+public class TestVM {\n+    private static final WhiteBox WHITE_BOX;\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+        } catch (UnsatisfiedLinkError e) {\n+            System.err.println(System.lineSeparator() + \"\"\"\n+                               ##########################################################\n+                                - Did you call a test-related interface method from\n+                                  TestFramework in main() of your test? Make sure to\n+                                  only call setup\/run methods and no checks or\n+                                  assertions from main() of your test!\n+                                - Are you rerunning the test VM (TestVM class)\n+                                  directly after a JTreg run? Make sure to start it\n+                                  from within JTwork\/scratch and with the flag\n+                                  -DReproduce=true!\n+                               ##########################################################\n+                               \"\"\");\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * The default number of warm-up iterations used to warm up a {@link Test} annotated test method.\n+     * Use {@code -DWarmup=XY} to specify a different default value. An individual warm-up can also be\n+     * set by specifying a {@link Warmup} iteration for a test.\n+     *\/\n+    public static final int WARMUP_ITERATIONS = Integer.parseInt(System.getProperty(\"Warmup\", \"2000\"));\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL = CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    public static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    static final boolean XCOMP = Platform.isComp();\n+    static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\");\n+    public static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final String TESTLIST = System.getProperty(\"Test\", \"\");\n+    private static final String EXCLUDELIST = System.getProperty(\"Exclude\", \"\");\n+    private static final boolean DUMP_REPLAY = Boolean.getBoolean(\"DumpReplay\");\n+    private static final boolean GC_AFTER = Boolean.getBoolean(\"GCAfter\");\n+    private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(\"ShuffleTests\", \"true\"));\n+    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by flag VM.\n+    private static final boolean PRINT_VALID_IR_RULES = Boolean.getBoolean(\"ShouldDoIRVerification\");\n+    protected static final long PER_METHOD_TRAP_LIMIT = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n+    protected static final boolean PROFILE_INTERPRETER = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean IGNORE_COMPILER_CONTROLS = Boolean.getBoolean(\"IgnoreCompilerControls\");\n+\n+    private final HashMap<Method, DeclaredTest> declaredTests = new HashMap<>();\n+    private final List<AbstractTest> allTests = new ArrayList<>();\n+    private final HashMap<String, Method> testMethodMap = new HashMap<>();\n+    private final List<String> excludeList;\n+    private final List<String> testList;\n+    private Set<Class<?>> helperClasses = null; \/\/ Helper classes that contain framework annotations to be processed.\n+    private final IREncodingPrinter irMatchRulePrinter;\n+    private final Class<?> testClass;\n+    private final Map<Executable, CompLevel> forceCompileMap = new HashMap<>();\n+\n+    private TestVM(Class<?> testClass) {\n+        TestRun.check(testClass != null, \"Test class cannot be null\");\n+        this.testClass = testClass;\n+        this.testList = createTestFilterList(TESTLIST, testClass);\n+        this.excludeList = createTestFilterList(EXCLUDELIST, testClass);\n+\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter = new IREncodingPrinter();\n+        } else {\n+            irMatchRulePrinter = null;\n+        }\n+    }\n+\n+    \/**\n+     * Parse \"test1,test2,test3\" into a list.\n+     *\/\n+    private static List<String> createTestFilterList(String list, Class<?> testClass) {\n+        List<String> filterList = null;\n+        if (!list.isEmpty()) {\n+            String classPrefix = testClass.getSimpleName() + \".\";\n+            filterList = new ArrayList<>(Arrays.asList(list.split(\",\")));\n+            for (int i = filterList.size() - 1; i >= 0; i--) {\n+                String test = filterList.get(i);\n+                if (test.indexOf(\".\") > 0) {\n+                    if (test.startsWith(classPrefix)) {\n+                        test = test.substring(classPrefix.length());\n+                        filterList.set(i, test);\n+                    } else {\n+                        filterList.remove(i);\n+                    }\n+                }\n+            }\n+        }\n+        return filterList;\n+    }\n+\n+    \/**\n+     * Main entry point of the test VM.\n+     *\/\n+    public static void main(String[] args) {\n+        try {\n+            String testClassName = args[0];\n+            System.out.println(\"TestVM main() called - about to run tests in class \" + testClassName);\n+            Class<?> testClass = getClassObject(testClassName, \"test\");\n+\n+            TestVM framework = new TestVM(testClass);\n+            framework.addHelperClasses(args);\n+            framework.start();\n+        } finally {\n+            TestFrameworkSocket.closeClientSocket();\n+        }\n+    }\n+\n+    protected static Class<?> getClassObject(String className, String classType) {\n+        try {\n+            return Class.forName(className);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find \" + classType + \" class\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Set up all helper classes and verify they are specified correctly.\n+     *\/\n+    private void addHelperClasses(String[] args) {\n+        Class<?>[] helperClassesList = getHelperClasses(args);\n+        if (helperClassesList != null) {\n+            TestRun.check(Arrays.stream(helperClassesList).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n+            this.helperClasses = new HashSet<>();\n+\n+            for (Class<?> helperClass : helperClassesList) {\n+                if (Arrays.stream(testClass.getDeclaredClasses()).anyMatch(c -> c == helperClass)) {\n+                    \/\/ Nested class of test class is automatically treated as helper class\n+                    TestFormat.failNoThrow(\"Nested \" + helperClass + \" inside test \" + testClass + \" is implicitly\"\n+                                           + \" treated as helper class and does not need to be specified as such.\");\n+                    continue;\n+                }\n+                TestRun.check(!this.helperClasses.contains(helperClass), \"Cannot add the same class twice: \" + helperClass);\n+                this.helperClasses.add(helperClass);\n+            }\n+        }\n+    }\n+\n+    private static Class<?>[] getHelperClasses(String[] args) {\n+        if (args.length == 1) {\n+            return null;\n+        }\n+        Class<?>[] helperClasses = new Class<?>[args.length - 1]; \/\/ First argument is test class\n+        for (int i = 1; i < args.length; i++) {\n+            String helperClassName = args[i];\n+            helperClasses[i - 1] = getClassObject(helperClassName, \"helper\");\n+        }\n+        return helperClasses;\n+    }\n+\n+    private void checkHelperClass(Class<?> clazz) {\n+        checkAnnotationsInClass(clazz, \"helper\");\n+        for (Class<?> c : clazz.getDeclaredClasses()) {\n+            checkAnnotationsInClass(c, \"nested (and helper)\");\n+        }\n+    }\n+\n+    private void checkAnnotationsInClass(Class<?> c, String clazzType) {\n+        Method[] methods = c.getDeclaredMethods();\n+        for (Method m : methods) {\n+            TestFormat.checkNoThrow(getAnnotation(m, Test.class) == null,\n+                                    \"Cannot use @Test annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Run.class) == null,\n+                                    \"Cannot use @Run annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Check.class) == null,\n+                                    \"Cannot use @Check annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by internal tests testing the framework itself. Accessed by reflection. Not exposed to normal users.\n+     *\/\n+    private static void runTestsOnSameVM(Class<?> testClass) {\n+        if (testClass == null) {\n+            StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            testClass = walker.getCallerClass();\n+        }\n+        TestVM framework = new TestVM(testClass);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Once everything is initialized and set up, start collecting tests and executing them afterwards.\n+     *\/\n+    private void start() {\n+        setupTests();\n+        checkForcedCompilationsCompleted();\n+        runTests();\n+    }\n+\n+    private void setupTests() {\n+        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+            checkAnnotationsInClass(clazz, \"inner\");\n+        }\n+        if (DUMP_REPLAY) {\n+            addReplay();\n+        }\n+        \/\/ Make sure to first setup test methods and make them non-inlineable and only then process compile commands.\n+        setupDeclaredTests();\n+        processControlAnnotations(testClass);\n+        processHelperClasses();\n+        setupCheckedAndCustomRunTests();\n+\n+        \/\/ All remaining tests are simple base tests without check or specific way to run them.\n+        addBaseTests();\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter.emit();\n+        }\n+        TestFormat.reportIfAnyFailures();\n+        declaredTests.clear();\n+        testMethodMap.clear();\n+    }\n+\n+    private void addBaseTests() {\n+        declaredTests.forEach((m, test) -> {\n+            if (test.getAttachedMethod() == null) {\n+                try {\n+                    Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+                    TestFormat.check(argumentsAnno != null || m.getParameterCount() == 0, \"Missing @Arguments annotation to define arguments of \" + m);\n+                    BaseTest baseTest = new BaseTest(test, shouldExcludeTest(m.getName()));\n+                    allTests.add(baseTest);\n+                    if (PRINT_VALID_IR_RULES) {\n+                       irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Check if user wants to exclude this test by checking the -DTest and -DExclude lists.\n+     *\/\n+    private boolean shouldExcludeTest(String testName) {\n+        boolean hasTestList = testList != null;\n+        boolean hasExcludeList = excludeList != null;\n+        if (hasTestList) {\n+            return !testList.contains(testName) || (hasExcludeList && excludeList.contains(testName));\n+        } else if (hasExcludeList) {\n+            return excludeList.contains(testName);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Generate replay compilation files.\n+     *\/\n+    private void addReplay() {\n+        String directive = \"[{ match: \\\"*.*\\\", DumpReplay: true }]\";\n+        TestFramework.check(WHITE_BOX.addCompilerDirective(directive) == 1, \"Failed to add DUMP_REPLAY directive\");\n+    }\n+\n+    private void processControlAnnotations(Class<?> clazz) {\n+        if (IGNORE_COMPILER_CONTROLS) {\n+            return;\n+        }\n+        \/\/ Also apply compile commands to all inner classes of 'clazz'.\n+        ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n+        classes.add(clazz);\n+        for (Class<?> c : classes) {\n+            applyClassAnnotations(c);\n+            List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n+            Collections.addAll(executables, c.getDeclaredConstructors());\n+            for (Executable ex : executables) {\n+                checkClassAnnotations(ex);\n+                try {\n+                    applyIndependentCompilationCommands(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+\n+            \/\/ Only force compilation now because above annotations affect inlining\n+            for (Executable ex : executables) {\n+                try {\n+                    applyForceCompileCommand(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        }\n+    }\n+\n+    private void applyClassAnnotations(Class<?> c) {\n+        ForceCompileClassInitializer anno = getAnnotation(c, ForceCompileClassInitializer.class);\n+        if (anno == null) {\n+            return;\n+        }\n+\n+        \/\/ Compile class initializer\n+        CompLevel level = anno.value();\n+        if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n+            TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n+                                   \"@ForceCompileClassInitializer at \" + c);\n+            return;\n+        }\n+        level = restrictCompLevel(anno.value());\n+        if (level != CompLevel.SKIP) {\n+            \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n+            getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n+            TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n+                                    \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n+                                    + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n+        }\n+    }\n+\n+    private void checkClassAnnotations(Executable ex) {\n+        TestFormat.checkNoThrow(getAnnotation(ex, ForceCompileClassInitializer.class) == null,\n+                                \"@ForceCompileClassInitializer only allowed at classes but not at method \" + ex);\n+    }\n+\n+    \/**\n+     * Exclude a method from compilation with a compiler randomly. Return the compiler for which the method was made\n+     * not compilable.\n+     *\/\n+    public static Compiler excludeRandomly(Executable ex) {\n+        Compiler compiler = switch (Utils.getRandomInstance().nextInt() % 3) {\n+            case 1 -> Compiler.C1;\n+            case 2 -> Compiler.C2;\n+            default -> Compiler.ANY;\n+        };\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        System.out.println(\"Excluding from \" + compiler.name() + \" compilation: \" + ex);\n+        return compiler;\n+    }\n+\n+    private void applyIndependentCompilationCommands(Executable ex) {\n+        ForceInline forceInlineAnno = getAnnotation(ex, ForceInline.class);\n+        DontInline dontInlineAnno = getAnnotation(ex, DontInline.class);\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        DontCompile dontCompileAnno = getAnnotation(ex, DontCompile.class);\n+        checkCompilationCommandAnnotations(ex, forceInlineAnno, dontInlineAnno, forceCompileAnno, dontCompileAnno);\n+        \/\/ First handle inline annotations\n+        if (dontInlineAnno != null) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        } else if (forceInlineAnno != null) {\n+            WHITE_BOX.testSetForceInlineMethod(ex, true);\n+        }\n+        if (dontCompileAnno != null) {\n+            dontCompileWithCompiler(ex, dontCompileAnno.value());\n+        }\n+        if (EXCLUDE_RANDOM && getAnnotation(ex, Test.class) == null && forceCompileAnno == null && dontCompileAnno == null) {\n+            \/\/ Randomly exclude helper methods from compilation\n+            if (Utils.getRandomInstance().nextBoolean()) {\n+                excludeRandomly(ex);\n+            }\n+        }\n+    }\n+\n+    private void checkCompilationCommandAnnotations(Executable ex, ForceInline forceInlineAnno, DontInline dontInlineAnno, ForceCompile forceCompileAnno, DontCompile dontCompileAnno) {\n+        Test testAnno = getAnnotation(ex, Test.class);\n+        Run runAnno = getAnnotation(ex, Run.class);\n+        Check checkAnno = getAnnotation(ex, Check.class);\n+        TestFormat.check((testAnno == null && runAnno == null && checkAnno == null) || Stream.of(forceCompileAnno, dontCompileAnno, forceInlineAnno, dontInlineAnno).noneMatch(Objects::nonNull),\n+                         \"Cannot use explicit compile command annotations (@ForceInline, @DontInline, \" +\n+                         \"@ForceCompile or @DontCompile) together with @Test, @Check or @Run: \" + ex + \". Use compLevel in @Test for fine tuning.\");\n+        if (Stream.of(forceInlineAnno, dontCompileAnno, dontInlineAnno).filter(Objects::nonNull).count() > 1) {\n+            \/\/ Failure\n+            TestFormat.check(dontCompileAnno == null || dontInlineAnno == null,\n+                             \"@DontInline is implicitely done with @DontCompile annotation at \" + ex);\n+            TestFormat.fail(\"Cannot mix @ForceInline, @DontInline and @DontCompile at the same time at \" + ex);\n+        }\n+        TestFormat.check(forceInlineAnno == null || dontInlineAnno == null, \"Cannot have @ForceInline and @DontInline at the same time at \" + ex);\n+        if (forceCompileAnno != null && dontCompileAnno != null) {\n+            CompLevel forceCompileLevel = forceCompileAnno.value();\n+            Compiler dontCompileCompiler = dontCompileAnno.value();\n+            TestFormat.check(dontCompileCompiler != Compiler.ANY,\n+                             \"Cannot have @DontCompile(Compiler.ANY) and @ForceCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel != CompLevel.ANY,\n+                             \"Cannot have @ForceCompile(CompLevel.ANY) and @DontCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel.isNotCompilationLevelOfCompiler(dontCompileCompiler),\n+                             \"Overlapping compilation level and compiler with @ForceCompile and @DontCompile at \" + ex);\n+        }\n+    }\n+\n+    \/**\n+     * Exlude the method from compilation and make sure it is not inlined.\n+     *\/\n+    private void dontCompileAndDontInlineMethod(Method m) {\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+    }\n+\n+    private void dontCompileWithCompiler(Executable ex, Compiler compiler) {\n+        if (VERBOSE) {\n+            System.out.println(\"dontCompileWithCompiler \" + ex + \" , compiler = \" + compiler.name());\n+        }\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        if (compiler == Compiler.ANY) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        }\n+    }\n+\n+    private void applyForceCompileCommand(Executable ex) {\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        if (forceCompileAnno != null) {\n+            CompLevel complevel = forceCompileAnno.value();\n+            TestFormat.check(complevel != CompLevel.SKIP && complevel != CompLevel.WAIT_FOR_COMPILATION,\n+                             \"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in @ForceCompile at \" + ex);\n+            complevel = restrictCompLevel(forceCompileAnno.value());\n+            if (FLIP_C1_C2) {\n+                complevel = complevel.flipCompLevel();\n+            }\n+            if (EXCLUDE_RANDOM) {\n+                complevel = complevel.excludeCompilationRandomly(ex);\n+            }\n+            if (complevel != CompLevel.SKIP) {\n+                enqueueForCompilation(ex, complevel);\n+                forceCompileMap.put(ex, complevel);\n+            }\n+        }\n+    }\n+\n+    static void enqueueForCompilation(Executable ex, CompLevel requestedCompLevel) {\n+        if (TestVM.VERBOSE) {\n+            System.out.println(\"enqueueForCompilation \" + ex + \", level = \" + requestedCompLevel);\n+        }\n+        CompLevel compLevel = restrictCompLevel(requestedCompLevel);\n+        if (compLevel != CompLevel.SKIP) {\n+            WHITE_BOX.enqueueMethodForCompilation(ex, compLevel.getValue());\n+        } else {\n+            System.out.println(\"Skipped compilation on level \" + requestedCompLevel + \" due to VM flags not allowing it.\");\n+        }\n+    }\n+\n+    \/**\n+     * Setup @Test annotated method an add them to the declaredTests map to have a convenient way of accessing them\n+     * once setting up a framework test (base  checked, or custom run test).\n+     *\/\n+    private void setupDeclaredTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Test testAnno = getAnnotation(m, Test.class);\n+            try {\n+                if (testAnno != null) {\n+                    addDeclaredTest(m);\n+                } else {\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(Warmup.class) || getAnnotation(m, Run.class) != null,\n+                                     \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+        TestFormat.checkNoThrow(!declaredTests.isEmpty(), \"Did not specify any @Test methods in \" + testClass);\n+    }\n+\n+    private void addDeclaredTest(Method m) {\n+        Test testAnno = getAnnotation(m, Test.class);\n+        checkTestAnnotations(m, testAnno);\n+        Warmup warmup = getAnnotation(m, Warmup.class);\n+        int warmupIterations = WARMUP_ITERATIONS;\n+        if (warmup != null) {\n+            warmupIterations = warmup.value();\n+            TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + m);\n+        }\n+\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            \/\/ Don't inline test methods by default. Do not apply this when -DIgnoreCompilerControls=true is set.\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+        CompLevel compLevel = restrictCompLevel(testAnno.compLevel());\n+        if (FLIP_C1_C2) {\n+            compLevel = compLevel.flipCompLevel();\n+        }\n+        if (EXCLUDE_RANDOM) {\n+            compLevel = compLevel.excludeCompilationRandomly(m);\n+        }\n+        DeclaredTest test = new DeclaredTest(m, ArgumentValue.getArguments(m), compLevel, warmupIterations);\n+        declaredTests.put(m, test);\n+        testMethodMap.put(m.getName(), m);\n+    }\n+\n+    private void checkTestAnnotations(Method m, Test testAnno) {\n+        TestFormat.check(!testMethodMap.containsKey(m.getName()),\n+                         \"Cannot overload two @Test methods: \" + m + \", \" + testMethodMap.get(m.getName()));\n+        TestFormat.check(testAnno != null, m + \" must be a method with a @Test annotation\");\n+\n+        Check checkAnno = getAnnotation(m, Check.class);\n+        Run runAnno = getAnnotation(m, Run.class);\n+        TestFormat.check(checkAnno == null && runAnno == null,\n+                         m + \" has invalid @Check or @Run annotation while @Test annotation is present.\");\n+\n+        TestFormat.checkNoThrow(Arrays.stream(m.getParameterTypes()).noneMatch(AbstractInfo.class::isAssignableFrom),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as parameter type at \" +\n+                                \"@Test method \" + m);\n+\n+        TestFormat.checkNoThrow(!AbstractInfo.class.isAssignableFrom(m.getReturnType()),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as return type at \" +\n+                                \"@Test method \" + m);\n+    }\n+\n+\n+    \/**\n+     * Get the appropriate level as permitted by the test scenario and VM flags.\n+     *\/\n+    private static CompLevel restrictCompLevel(CompLevel compLevel) {\n+        if (!USE_COMPILER) {\n+            return CompLevel.SKIP;\n+        }\n+        if (compLevel == CompLevel.ANY) {\n+            \/\/ Use highest available compilation level by default (usually C2).\n+            compLevel = TIERED_COMPILATION_STOP_AT_LEVEL;\n+        }\n+        if (!TIERED_COMPILATION && compLevel.getValue() < CompLevel.C2.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        if (TIERED_COMPILATION && compLevel.getValue() > TIERED_COMPILATION_STOP_AT_LEVEL.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        return compLevel;\n+    }\n+\n+    \/**\n+     * Verify that the helper classes do not contain illegal framework annotations and then apply the actions as\n+     * specified by the different helper class annotations.\n+     *\/\n+    private void processHelperClasses() {\n+        if (helperClasses != null) {\n+            for (Class<?> helperClass : helperClasses) {\n+                \/\/ Process the helper classes and apply the explicit compile commands\n+                TestFormat.checkNoThrow(helperClass != testClass,\n+                                        \"Cannot specify test \" + testClass + \" as helper class, too.\");\n+                checkHelperClass(helperClass);\n+                processControlAnnotations(helperClass);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * First set up checked (with @Check) and custom run tests (with @Run). All remaining unmatched\/unused @Test methods\n+     * are treated as base tests and set up as such later.\n+     *\/\n+    private void setupCheckedAndCustomRunTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Check checkAnno = getAnnotation(m, Check.class);\n+            Run runAnno = getAnnotation(m, Run.class);\n+            Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+            try {\n+                TestFormat.check(argumentsAnno == null || (checkAnno == null && runAnno == null),\n+                                 \"Cannot have @Argument annotation in combination with @Run or @Check at \" + m);\n+                if (checkAnno != null) {\n+                    addCheckedTest(m, checkAnno, runAnno);\n+                } else if (runAnno != null) {\n+                    addCustomRunTest(m, runAnno);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Set up a checked test by first verifying the correct format of the @Test and @Check method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCheckedTest(Method m, Check checkAnno, Run runAnno) {\n+        Method testMethod = testMethodMap.get(checkAnno.test());\n+        DeclaredTest test = declaredTests.get(testMethod);\n+        checkCheckedTest(m, checkAnno, runAnno, testMethod, test);\n+        test.setAttachedMethod(m);\n+        CheckedTest.Parameter parameter = getCheckedTestParameter(m, testMethod);\n+        dontCompileAndDontInlineMethod(m);\n+        CheckedTest checkedTest = new CheckedTest(test, m, checkAnno, parameter, shouldExcludeTest(testMethod.getName()));\n+        allTests.add(checkedTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            \/\/ Only need to emit IR verification information if IR verification is actually performed.\n+            irMatchRulePrinter.emitRuleEncoding(m, checkedTest.isSkipped());\n+        }\n+    }\n+\n+    private void checkCheckedTest(Method m, Check checkAnno, Run runAnno, Method testMethod, DeclaredTest test) {\n+        TestFormat.check(runAnno == null, m + \" has invalid @Run annotation while @Check annotation is present.\");\n+        TestFormat.check(testMethod != null, \"Did not find associated test method \\\"\" + m.getDeclaringClass().getName()\n+                                             + \".\" + checkAnno.test() + \"\\\" for @Check at \" + m);\n+        TestFormat.check(test != null, \"Missing @Test annotation for associated test method \" + testMethod + \" for @Check at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run or one @Check method. Found: \" + m + \", \" + attachedMethod);\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Check}.\n+     *\/\n+    private CheckedTest.Parameter getCheckedTestParameter(Method m, Method testMethod) {\n+        boolean firstParameterTestInfo = m.getParameterCount() > 0 && m.getParameterTypes()[0].equals(TestInfo.class);\n+        boolean secondParameterTestInfo = m.getParameterCount() > 1 && m.getParameterTypes()[1].equals(TestInfo.class);\n+        CheckedTest.Parameter parameter = null;\n+        Class<?> testReturnType = testMethod.getReturnType();\n+        switch (m.getParameterCount()) {\n+            case 0 -> parameter = CheckedTest.Parameter.NONE;\n+            case 1 -> {\n+                TestFormat.checkNoThrow(firstParameterTestInfo || m.getParameterTypes()[0] == testReturnType,\n+                                        \"Single-parameter version of @Check method \" + m + \" must match return type of @Test \" + testMethod);\n+                parameter = firstParameterTestInfo ? CheckedTest.Parameter.TEST_INFO_ONLY : CheckedTest.Parameter.RETURN_ONLY;\n+            }\n+            case 2 -> {\n+                TestFormat.checkNoThrow(m.getParameterTypes()[0] == testReturnType && secondParameterTestInfo,\n+                                        \"Two-parameter version of @Check method \" + m + \" must provide as first parameter the same\"\n+                                        + \" return type as @Test method \" + testMethod + \" and as second parameter an object of \" + TestInfo.class);\n+                parameter = CheckedTest.Parameter.BOTH;\n+            }\n+            default -> TestFormat.failNoThrow(\"@Check method \" + m + \" must provide either a none, single or two-parameter variant.\");\n+        }\n+        return parameter;\n+    }\n+\n+    \/**\n+     * Set up a custom run test by first verifying the correct format of the @Test and @Run method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCustomRunTest(Method m, Run runAnno) {\n+        checkRunMethod(m, runAnno);\n+        List<DeclaredTest> tests = new ArrayList<>();\n+        boolean shouldExcludeTest = true;\n+        for (String testName : runAnno.test()) {\n+            try {\n+                Method testMethod = testMethodMap.get(testName);\n+                DeclaredTest test = declaredTests.get(testMethod);\n+                checkCustomRunTest(m, testName, testMethod, test, runAnno.mode());\n+                test.setAttachedMethod(m);\n+                tests.add(test);\n+                \/\/ Only exclude custom run test if all test methods excluded\n+                shouldExcludeTest &= shouldExcludeTest(testMethod.getName());\n+            } catch (TestFormatException e) {\n+                \/\/ Logged, continue.\n+            }\n+        }\n+        if (tests.isEmpty()) {\n+            return; \/\/ There was a format violation. Return.\n+        }\n+        dontCompileAndDontInlineMethod(m);\n+        CustomRunTest customRunTest = new CustomRunTest(m, getAnnotation(m, Warmup.class), runAnno, tests, shouldExcludeTest);\n+        allTests.add(customRunTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            tests.forEach(test -> irMatchRulePrinter.emitRuleEncoding(test.getTestMethod(), customRunTest.isSkipped()));\n+        }\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Run}.\n+     *\/\n+    private void checkCustomRunTest(Method m, String testName, Method testMethod, DeclaredTest test, RunMode runMode) {\n+        TestFormat.check(testMethod != null, \"Did not find associated @Test method \\\"\"  + m.getDeclaringClass().getName()\n+                                             + \".\" + testName + \"\\\" specified in @Run at \" + m);\n+        TestFormat.check(test != null,\n+                         \"Missing @Test annotation for associated test method \" + testName + \" for @Run at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run\/@Check method. Found: \"\n+                         + m + \", \" + attachedMethod);\n+        TestFormat.check(!test.hasArguments(),\n+                         \"Cannot use @Arguments at test method \" + testMethod + \" in combination with @Run method \" + m);\n+        Warmup warmupAnno = getAnnotation(testMethod, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null,\n+                         \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n+                         + m + \". Use @Warmup at @Run method instead.\");\n+        Test testAnno = getAnnotation(testMethod, Test.class);\n+        TestFormat.checkNoThrow(runMode != RunMode.STANDALONE || testAnno.compLevel() == CompLevel.ANY,\n+                                \"Setting explicit compilation level for @Test method \" + testMethod + \" has no effect \"\n+                                + \"when used with STANDALONE @Run method \" + m);\n+    }\n+\n+    private void checkRunMethod(Method m, Run runAnno) {\n+        TestFormat.check(runAnno.test().length > 0, \"@Run method \" + m + \" must specify at least one test method\");\n+        TestFormat.checkNoThrow(m.getParameterCount() == 0 || (m.getParameterCount() == 1 && m.getParameterTypes()[0].equals(RunInfo.class)),\n+                                \"@Run method \" + m + \" must specify either no parameter or exactly one \" + RunInfo.class + \" parameter.\");\n+        Warmup warmupAnno = getAnnotation(m, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null || runAnno.mode() != RunMode.STANDALONE,\n+                                \"Cannot set @Warmup at @Run method \" + m + \" when used with RunMode.STANDALONE. The @Run method is only invoked once.\");\n+    }\n+\n+    private static <T extends Annotation> T getAnnotation(AnnotatedElement element, Class<T> c) {\n+        T[] annos =  element.getAnnotationsByType(c);\n+        TestFormat.check(annos.length < 2, element + \" has duplicated annotations\");\n+        return Arrays.stream(annos).findFirst().orElse(null);\n+    }\n+\n+    \/**\n+     * Ensure that all compilations that were enforced (added to compilation queue) by framework annotations are\n+     * completed. Wait if necessary for a short amount of time for their completion.\n+     *\/\n+    private void checkForcedCompilationsCompleted() {\n+        if (forceCompileMap.isEmpty()) {\n+            return;\n+        }\n+        final long started = System.currentTimeMillis();\n+        long elapsed;\n+        do {\n+            forceCompileMap.entrySet().removeIf(entry -> WHITE_BOX.getMethodCompilationLevel(entry.getKey()) == entry.getValue().getValue());\n+            if (forceCompileMap.isEmpty()) {\n+                \/\/ All @ForceCompile methods are compiled at the requested level.\n+                return;\n+            }\n+            \/\/ Retry again if not yet compiled.\n+            forceCompileMap.forEach(TestVM::enqueueForCompilation);\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < 5000);\n+        StringBuilder builder = new StringBuilder();\n+        forceCompileMap.forEach((key, value) -> builder.append(\"- \").append(key).append(\" at CompLevel.\").append(value)\n+                                                       .append(System.lineSeparator()));\n+        throw new TestRunException(\"Could not force compile the following @ForceCompile methods:\"\n+                                   + System.lineSeparator() + builder.toString());\n+    }\n+\n+    \/**\n+     * Once all framework tests are collected, they are run in this method.\n+     *\/\n+    private void runTests() {\n+        TreeMap<Long, String> durations = (PRINT_TIMES || VERBOSE) ? new TreeMap<>() : null;\n+        long startTime = System.nanoTime();\n+        List<AbstractTest> testList;\n+        boolean testFilterPresent = testFilterPresent();\n+        if (testFilterPresent) {\n+            \/\/ Only run the specified tests by the user filters -DTest and\/or -DExclude.\n+            testList = allTests.stream().filter(test -> !test.isSkipped()).collect(Collectors.toList());\n+            if (testList.isEmpty()) {\n+                \/\/ Throw an exception to inform the user about an empty specified test set with -DTest and\/or -DExclude\n+                throw new NoTestsRunException();\n+            }\n+        } else {\n+            testList = allTests;\n+        }\n+\n+        if (SHUFFLE_TESTS) {\n+            \/\/ Execute tests in random order (execution sequence affects profiling). This is done by default.\n+            Collections.shuffle(testList, Utils.getRandomInstance());\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        int failures = 0;\n+\n+        \/\/ Execute all tests and keep track of each exception that is thrown. These are then reported once all tests\n+        \/\/ are executing. This prevents a premature exit without running all tests.\n+        for (AbstractTest test : testList) {\n+            if (VERBOSE) {\n+                System.out.println(\"Run \" + test.toString());\n+            }\n+            if (testFilterPresent) {\n+                TestFrameworkSocket.write(\"Run \" + test.toString(), \"testfilter\", true);\n+            }\n+            try {\n+                test.run();\n+            } catch (TestRunException e) {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                e.printStackTrace(pw);\n+                builder.append(test.toString()).append(\":\").append(System.lineSeparator()).append(sw.toString())\n+                       .append(System.lineSeparator()).append(System.lineSeparator());\n+                failures++;\n+            }\n+            if (PRINT_TIMES || VERBOSE) {\n+                long endTime = System.nanoTime();\n+                long duration = (endTime - startTime);\n+                durations.put(duration, test.getName());\n+                if (VERBOSE) {\n+                    System.out.println(\"Done \" + test.getName() + \": \" + duration + \" ns = \" + (duration \/ 1000000) + \" ms\");\n+                }\n+            }\n+            if (GC_AFTER) {\n+                System.out.println(\"doing GC\");\n+                WHITE_BOX.fullGC();\n+            }\n+        }\n+\n+        \/\/ Print execution times\n+        if (VERBOSE || PRINT_TIMES) {\n+            System.out.println(System.lineSeparator() + System.lineSeparator() + \"Test execution times:\");\n+            for (Map.Entry<Long, String> entry : durations.entrySet()) {\n+                System.out.format(\"%-10s%15d ns%n\", entry.getValue() + \":\", entry.getKey());\n+            }\n+        }\n+\n+        if (failures > 0) {\n+            \/\/ Finally, report all occurred exceptions in a nice format.\n+            String msg = System.lineSeparator() + System.lineSeparator() + \"Test Failures (\" + failures + \")\"\n+                         + System.lineSeparator() + \"----------------\" + \"-\".repeat(String.valueOf(failures).length());\n+            throw new TestRunException(msg + System.lineSeparator() + builder.toString());\n+        }\n+    }\n+\n+    private boolean testFilterPresent() {\n+        return testList != null || excludeList != null;\n+    }\n+\n+    enum TriState {\n+        Maybe,\n+        Yes,\n+        No\n+    }\n+\n+    public static void compile(Method m, CompLevel compLevel) {\n+        TestRun.check(compLevel != CompLevel.SKIP && compLevel != CompLevel.WAIT_FOR_COMPILATION,\n+                         \"Invalid compilation request with level \" + compLevel);\n+        enqueueForCompilation(m, compLevel);\n+    }\n+\n+    public static void deoptimize(Method m) {\n+        WHITE_BOX.deoptimizeMethod(m);\n+    }\n+\n+    public static boolean isCompiled(Method m) {\n+        return compiledAtLevel(m, CompLevel.ANY) == TriState.Yes;\n+    }\n+\n+    public static boolean isC1Compiled(Method m) {\n+        return compiledByC1(m) == TriState.Yes;\n+    }\n+\n+    public static boolean isC2Compiled(Method m) {\n+        return compiledByC2(m) == TriState.Yes;\n+    }\n+\n+    public static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+        return compiledAtLevel(m, compLevel) == TriState.Yes;\n+    }\n+\n+    public static void assertDeoptimizedByC1(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C1\");\n+        }\n+    }\n+\n+    public static void assertDeoptimizedByC2(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n+            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C2\");\n+        }\n+    }\n+\n+    \/**\n+     * Some VM flags could make the deopt assertions unstable.\n+     *\/\n+    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+        return (USE_COMPILER && !XCOMP && !IGNORE_COMPILER_CONTROLS && !TEST_C1 &&\n+               (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n+    }\n+\n+    public static void assertCompiledByC1(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No, m + \" should have been C1 compiled\");\n+    }\n+\n+    public static void assertCompiledByC2(Method m) {\n+        TestRun.check(compiledByC2(m) != TriState.No, m + \" should have been C2 compiled\");\n+    }\n+\n+    public static void assertCompiledAtLevel(Method m, CompLevel level) {\n+        TestRun.check(compiledAtLevel(m, level) != TriState.No, m + \" should have been compiled at level \" + level.name());\n+    }\n+\n+    public static void assertNotCompiled(Method m) {\n+        TestRun.check(!isC1Compiled(m), m + \" should not have been compiled by C1\");\n+        TestRun.check(!isC2Compiled(m), m + \" should not have been compiled by C2\");\n+    }\n+\n+    public static void assertCompiled(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No || compiledByC2(m) != TriState.No, m + \" should have been compiled\");\n+    }\n+\n+    private static TriState compiledByC1(Method m) {\n+        TriState triState = compiledAtLevel(m, CompLevel.C1_SIMPLE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_LIMITED_PROFILE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_FULL_PROFILE);\n+        return triState;\n+    }\n+\n+    private static TriState compiledByC2(Method m) {\n+        return compiledAtLevel(m, CompLevel.C2);\n+    }\n+\n+    private static TriState compiledAtLevel(Method m, CompLevel level) {\n+        if (WHITE_BOX.isMethodCompiled(m, false)) {\n+            switch (level) {\n+                case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n+                    if (WHITE_BOX.getMethodCompilationLevel(m, false) == level.getValue()) {\n+                        return TriState.Yes;\n+                    }\n+                }\n+                case ANY -> {\n+                    return TriState.Yes;\n+                }\n+                default -> throw new TestRunException(\"compiledAtLevel() should not be called with \" + level);\n+            }\n+        }\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n+            (EXCLUDE_RANDOM && !WHITE_BOX.isMethodCompilable(m, level.getValue(), false))) {\n+            return TriState.Maybe;\n+        }\n+        return TriState.No;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":955,"deletions":0,"binary":false,"changes":955,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Framework internal tests\n+This folder contains tests which test the functionality of the framework. These should be run with JTreg and without additional VM and Javaopts flags whenever the framework is modified. \n+\n+These tests are not part of the normal tier testing as they only should be run when the framework is changed in any way.\n+\n+Additional testing should be performed with the converted Valhalla tests to make sure a changeset is correct (these are part of the Valhalla CI).\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/README.md","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,425 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test different access modifiers an make sure, the framework can access all methods.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestAccessModifiers\n+ *\/\n+\n+public class TestAccessModifiers {\n+    public static void main(String[] args) {\n+        TestFramework.run(PackagePrivate.class);\n+    }\n+}\n+\n+class PackagePrivate {\n+    @Test\n+    public void test() {\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void test2(int x) {\n+    }\n+\n+    @Test\n+    public static int staticPublicPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicPrivate\")\n+    private void staticPublicPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedPrivate\")\n+    private void staticProtectedPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultPrivate\")\n+    private void staticDefaultPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivatePrivate\")\n+    private void staticPrivatePrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicDefault\")\n+    void staticPublicDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedDefault\")\n+    void staticProtectedDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultDefault\")\n+    void staticDefaultDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivateDefault\")\n+    void staticPrivateDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicProtected\")\n+    protected void staticPublicProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedProtected\")\n+    protected void staticProtectedProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultProtected\")\n+    protected void staticDefaultProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivateProtected\")\n+    protected void staticPrivateProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicPublic\")\n+    public void staticPublicPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedPublic\")\n+    public void staticProtectedPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultPublic\")\n+    public void staticDefaultPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivatePublic\")\n+    public void staticPrivatePublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPrivate2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultPrivate2\")\n+    private void staticDefaultPrivateRun() {\n+        int retValue = staticDefaultPrivate2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePrivate2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivatePrivate2\")\n+    private void staticPrivatePrivateRun() {\n+        int retValue = staticPrivatePrivate2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicDefault2\")\n+    void staticPublicDefaultRun() {\n+        int retValue = staticPublicDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedDefault2\")\n+    void staticProtectedDefaultRun() {\n+        int retValue = staticProtectedDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultDefault2\")\n+    void staticDefaultDefaultRun() {\n+        int retValue = staticDefaultDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivateDefault2\")\n+    void staticPrivateDefaultRun() {\n+        int retValue = staticPrivateDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicProtected2\")\n+    protected void staticPublicProtectedRun() {\n+        int retValue = staticPublicProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedProtected2\")\n+    protected void staticProtectedProtectedRun() {\n+        int retValue = staticProtectedProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultProtected2\")\n+    protected void staticDefaultProtectedRun() {\n+        int retValue = staticDefaultProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivateProtected2\")\n+    protected void staticPrivateProtectedRun() {\n+        int retValue = staticPrivateProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicPublic2\")\n+    public void staticPublicPublicRun() {\n+        int retValue = staticPublicPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedPublic2\")\n+    public void staticProtectedPublicRun() {\n+        int retValue = staticProtectedPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultPublic2\")\n+    public void staticDefaultPublicRun() {\n+        int retValue = staticDefaultPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivatePublic2\")\n+    public void staticPrivatePublicRun() {\n+        int retValue = staticPrivatePublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestAccessModifiers.java","additions":425,"deletions":0,"binary":false,"changes":425,"status":"added"},{"patch":"@@ -0,0 +1,1001 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ * @summary Test test format violations.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestBadFormat\n+ *\/\n+\n+public class TestBadFormat {\n+\n+    public static void main(String[] args) {\n+        expectTestFormatException(BadNoTests.class);\n+        expectTestFormatException(BadArgumentsAnnotation.class);\n+        expectTestFormatException(BadOverloadedMethod.class);\n+        expectTestFormatException(BadCompilerControl.class);\n+        expectTestFormatException(BadWarmup.class);\n+        expectTestFormatException(BadBaseTests.class);\n+        expectTestFormatException(BadRunTests.class);\n+        expectTestFormatException(BadCheckTest.class);\n+        expectTestFormatException(BadIRAnnotations.class);\n+        expectTestFormatException(BadInnerClassTest.class);\n+        expectTestFormatException(BadCompileClassInitializer.class, BadCompileClassInitializerHelper1.class,\n+                                  BadCompileClassInitializerHelper2.class, BadCompileClassInitializerHelper3.class);\n+    }\n+\n+    private static void expectTestFormatException(Class<?> clazz, Class<?>... helpers) {\n+        try {\n+            if (helpers == null) {\n+                TestFramework.run(clazz);\n+            } else {\n+                new TestFramework(clazz).addHelperClasses(helpers).start();\n+            }\n+        } catch (Exception e) {\n+            if (!(e instanceof TestFormatException)) {\n+                e.printStackTrace();\n+                Asserts.fail(\"Unexpected exception\", e);\n+            }\n+            String msg = e.getMessage();\n+            Violations violations = getViolations(clazz, helpers);\n+            violations.getFailedMethods().forEach(\n+                    f -> Asserts.assertTrue(msg.contains(f),\n+                                            \"Could not find \" + f + \" in violations\" + System.lineSeparator() + msg));\n+            Pattern pattern = Pattern.compile(\"Violations \\\\((\\\\d+)\\\\)\");\n+            Matcher matcher = pattern.matcher(msg);\n+            Asserts.assertTrue(matcher.find(), \"Could not find violations in\" + System.lineSeparator() + msg);\n+            int violationCount = Integer.parseInt(matcher.group(1));\n+            Asserts.assertEQ(violationCount, violations.getViolationCount(), msg);\n+            return;\n+        }\n+        throw new RuntimeException(\"Should catch an exception\");\n+    }\n+\n+    private static Violations getViolations(Class<?> clazz, Class<?>... helpers) {\n+        Violations violations = new Violations();\n+        collectViolations(clazz, violations);\n+        if (helpers != null) {\n+            Arrays.stream(helpers).forEach(c -> collectViolations(c, violations));\n+        }\n+        return violations;\n+    }\n+\n+    private static void collectViolations(Class<?> clazz, Violations violations) {\n+        getViolationsOfClass(clazz, violations);\n+        for (Class<?> c : clazz.getDeclaredClasses()) {\n+            getViolationsOfClass(c, violations);\n+        }\n+    }\n+\n+    private static void getViolationsOfClass(Class<?> clazz, Violations violations) {\n+        ClassFail classFail = clazz.getDeclaredAnnotation(ClassFail.class);\n+        if (classFail != null) {\n+            violations.addFail(clazz);\n+        }\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            NoFail noFail = m.getDeclaredAnnotation(NoFail.class);\n+            if (noFail == null) {\n+                FailCount failCount = m.getDeclaredAnnotation(FailCount.class);\n+                if (failCount != null) {\n+                    violations.addFail(m, failCount.value());\n+                } else {\n+                    violations.addFail(m, 1);\n+                }\n+            } else {\n+                \/\/ Cannot define both annotation at the same method.\n+                Asserts.assertEQ(m.getDeclaredAnnotation(FailCount.class), null);\n+            }\n+        }\n+    }\n+\n+}\n+\n+\/\/ Specify at least one @Test\n+@ClassFail\n+class BadNoTests {\n+\n+}\n+\n+class BadArgumentsAnnotation {\n+\n+    @Test\n+    public void noArgAnnotation(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argNumberMismatch(int a, int b) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argNumberMismatch2() {}\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void notBoolean(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void notBoolean2(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void notNumber(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.FALSE)\n+    public void notNumber2(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_TRUE)\n+    public void notNumber3(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_FALSE)\n+    public void notNumber4(int a) {}\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.TRUE})\n+    public void notNumber5(boolean a, int b) {}\n+\n+    @FailCount(2)\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.NUMBER_42})\n+    public void notNumber6(int a, boolean b) {}\n+\n+    @FailCount(2)\n+    @Test\n+    @Arguments({Argument.MIN, Argument.MAX})\n+    public void notNumber7(boolean a, boolean b) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void missingDefaultConstructor(ClassNoDefaultConstructor a) {}\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void wrongArgumentNumberWithRun(Object o1, Object o2) {\n+    }\n+\n+    \/\/ Also fails: Cannot use @Arguments together with @Run\n+    @Run(test=\"wrongArgumentNumberWithRun\")\n+    public void forRun() {\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void wrongArgumentNumberWithCheck(Object o1, Object o2) {\n+    }\n+\n+    @NoFail\n+    @Check(test=\"wrongArgumentNumberWithCheck\")\n+    public void forCheck() {\n+    }\n+}\n+\n+class BadOverloadedMethod {\n+\n+    @FailCount(0) \/\/ Combined with both sameName() below\n+    @Test\n+    public void sameName() {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void sameName(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void sameName(double a) {}\n+}\n+\n+class BadCompilerControl {\n+\n+    @Test\n+    @DontCompile\n+    public void test1() {}\n+\n+    @Test\n+    @ForceCompile\n+    public void test2() {}\n+\n+    @Test\n+    @DontInline\n+    public void test3() {}\n+\n+    @Test\n+    @ForceInline\n+    public void test4() {}\n+\n+    @Test\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void test5() {}\n+\n+    @DontInline\n+    @ForceInline\n+    public void mix1() {}\n+\n+    @DontCompile\n+    @ForceCompile\n+    public void mix2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test6() {}\n+\n+    @Run(test = \"test6\")\n+    @DontCompile\n+    public void notAtRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test7() {}\n+\n+    @Run(test = \"test7\")\n+    @ForceCompile\n+    public void notAtRun2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test8() {}\n+\n+    @Run(test = \"test8\")\n+    @DontInline\n+    public void notAtRun3() {}\n+\n+    @NoFail\n+    @Test\n+    public void test9() {}\n+\n+    @Run(test = \"test9\")\n+    @ForceInline\n+    public void notAtRun4() {}\n+\n+    @NoFail\n+    @Test\n+    public void test10() {}\n+\n+    @Run(test = \"test10\")\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void notAtRun5() {}\n+\n+    @NoFail\n+    @Test\n+    public void test11() {}\n+\n+    @Check(test = \"test11\")\n+    @DontCompile\n+    public void notAtCheck() {}\n+\n+    @NoFail\n+    @Test\n+    public void test12() {}\n+\n+    @Check(test = \"test12\")\n+    @ForceCompile\n+    public void notAtCheck2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test13() {}\n+\n+    @Check(test = \"test13\")\n+    @DontInline\n+    public void notAtCheck3() {}\n+\n+    @NoFail\n+    @Test\n+    public void test14() {}\n+\n+    @Check(test = \"test14\")\n+    @ForceInline\n+    public void notAtCheck4() {}\n+\n+    @NoFail\n+    @Test\n+    public void test15() {}\n+\n+    @Check(test = \"test15\")\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void notAtCheck5() {}\n+\n+    @ForceCompile(CompLevel.SKIP)\n+    public void invalidSkip1() {}\n+\n+    @ForceCompile(CompLevel.WAIT_FOR_COMPILATION)\n+    public void invalidWaitForCompilation() {}\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C1)\n+    public void overlappingCompile1() {}\n+\n+    @ForceCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C2)\n+    public void overlappingCompile2() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.C1)\n+    public void invalidMix1() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.C2)\n+    public void invalidMix2() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile\n+    public void invalidMix3() {}\n+}\n+\n+class BadWarmup {\n+\n+    @Warmup(10000)\n+    public void warmUpNonTest() {}\n+\n+    @Test\n+    @Warmup(1)\n+    public void someTest() {}\n+\n+    @FailCount(0) \/\/ Combined with someTest()\n+    @Run(test = \"someTest\")\n+    @Warmup(1)\n+    public void twoWarmups() {}\n+\n+    @Test\n+    @Warmup(-1)\n+    public void negativeWarmup() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest2() {}\n+\n+    @Run(test = \"someTest2\")\n+    @Warmup(-1)\n+    public void negativeWarmup2() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest3() {}\n+\n+    @FailCount(2) \/\/ Negative warmup and invoke once\n+    @Run(test = \"someTest3\", mode = RunMode.STANDALONE)\n+    @Warmup(-1)\n+    public void noWarmupAtStandalone() {}\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void testNoCompLevelStandalone() {}\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void testNoCompLevelStandalone2() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest4() {}\n+\n+    @FailCount(0) \/\/ Negative warmup and invoke once\n+    @Run(test = {\"someTest4\", \"testNoCompLevelStandalone\", \"testNoCompLevelStandalone2\"}, mode = RunMode.STANDALONE)\n+    public void runNoCompLevelStandalone() {}\n+}\n+\n+class BadBaseTests {\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public TestInfo cannotUseTestInfoAsParameterOrReturn(TestInfo info) {\n+        return null;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public RunInfo cannotUseRunInfoAsParameterOrReturn(RunInfo info) {\n+        return null;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public AbstractInfo cannotUseAbstractInfoAsParameterOrReturn(AbstractInfo info) {\n+        return null;\n+    }\n+}\n+\n+class BadRunTests {\n+    @Run(test = \"runForRun2\")\n+    public void runForRun() {}\n+\n+    @Run(test = \"runForRun\")\n+    public void runForRun2() {}\n+\n+    @Test\n+    public void sharedByTwo() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Run(test = \"sharedByTwo\")\n+    public void share1() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Run(test = \"sharedByTwo\")\n+    public void share2() {}\n+\n+    @Run(test = \"doesNotExist\")\n+    public void noTestExists() {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argTest(int x) {}\n+\n+    @FailCount(0) \/\/ Combined with argTest()\n+    @Run(test = \"argTest\")\n+    public void noArgumentAnnotationForRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test1() {}\n+\n+    @Run(test = \"test1\")\n+    public void wrongParameters1(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public void test2() {}\n+\n+    @Run(test = \"test2\")\n+    public void wrongParameters(RunInfo info, int x) {}\n+\n+    @Test\n+    public void invalidShare() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShare\")\n+    public void shareSameTestTwice1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShare\")\n+    public void shareSameTestTwice2() {}\n+\n+    @Test\n+    public void invalidShareCheckRun() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShareCheckRun\")\n+    public void invalidShareCheckRun1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShareCheckRun\")\n+    public void invalidShareCheckRun2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidRunWithArgAnnotation() {}\n+\n+    @Arguments(Argument.DEFAULT)\n+    @Run(test = \"testInvalidRunWithArgAnnotation\")\n+    public void invalidRunWithArgAnnotation(RunInfo info) {}\n+\n+    @NoFail\n+    @Test\n+    public void testRunWithTestInfo() {}\n+\n+    @Run(test = \"testRunWithTestInfo\")\n+    public void invalidRunWithTestInfo(TestInfo info) {}\n+\n+    @Run(test = {})\n+    public void invalidRunWithNoTest() {}\n+\n+    @Run(test = \"\")\n+    public void invalidRunWithEmptyTestName() {}\n+\n+    @NoFail\n+    @Test\n+    public void someExistingTest() {}\n+\n+    @FailCount(2)\n+    @Run(test = {\"unknown1\", \"someExistingTest\", \"unknown2\"})\n+    public void invalidRunWithInvalidTests() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidReuse() {}\n+\n+    @Test\n+    public void testInvalidReuse2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidReuse3() {}\n+\n+    @FailCount(0)\n+    @Run(test = {\"testInvalidReuse\", \"testInvalidReuse2\"})\n+    public void runInvalidReuse1() {}\n+\n+    @FailCount(0)\n+    @Run(test = {\"testInvalidReuse2\", \"testInvalidReuse3\"})\n+    public void runInvalidReuse2() {}\n+}\n+\n+class BadCheckTest {\n+    @Check(test = \"checkForCheck2\")\n+    public void checkForCheck() {}\n+\n+    @Check(test = \"checkForCheck\")\n+    public void checkForCheck2() {}\n+\n+    @Test\n+    public void sharedByTwo() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Check(test = \"sharedByTwo\")\n+    public void share1() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Check(test = \"sharedByTwo\")\n+    public void share2() {}\n+\n+    @Check(test = \"doesNotExist\")\n+    public void noTestExists() {}\n+\n+    @NoFail\n+    @Test\n+    public void test1() {}\n+\n+    @Check(test = \"test1\")\n+    public void wrongReturnParameter1(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test2() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test2\")\n+    public void wrongReturnParameter2(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test3() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test3\")\n+    public void wrongReturnParameter3(String x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test4() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test4\")\n+    public void wrongReturnParameter4(TestInfo info, int x) {} \/\/ Must flip parameters\n+\n+    @NoFail\n+    @Test\n+    public int test5() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test5\")\n+    public void wrongReturnParameter5(short x, TestInfo info) {}\n+\n+    @Test\n+    public void invalidShare() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShare\")\n+    public void shareSameTestTwice1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShare\")\n+    public void shareSameTestTwice2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidRunWithArgAnnotation() {}\n+\n+    @Arguments(Argument.DEFAULT)\n+    @Check(test = \"testInvalidRunWithArgAnnotation\")\n+    public void invalidRunWithArgAnnotation(TestInfo info) {}\n+}\n+\n+class BadIRAnnotations {\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtNonTest() {}\n+\n+    @NoFail\n+    @Test\n+    public void test() {}\n+\n+    @Run(test = \"test\")\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test2() {}\n+\n+    @Check(test = \"test2\")\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtCheck() {}\n+\n+    @Test\n+    @IR\n+    public void mustSpecifyAtLeastOneConstraint() {\n+    }\n+\n+    @FailCount(2)\n+    @Test\n+    @IR\n+    @IR\n+    public void mustSpecifyAtLeastOneConstraint2() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"50\"})\n+    public void mustSpecifyAtLeastOneConstraint3() {\n+    }\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}, applyIfNot = {\"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"},\n+        applyIfOr = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}, applyIfNot = {\"TLABRefillWasteFraction\", \"50\"},\n+        applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"},\n+        applyIfOr = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    public void onlyOneApply() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfTooManyFlags() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"Bla\"})\n+    public void applyIfMissingValue() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"PrintIdealGraphFilee\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"Bla\", \"foo\"})\n+    public void applyIfUnknownFlag() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\" \", \" \"})\n+    public void applyIfEmptyValue() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<\"})\n+    public void applyIfFaultyComparator() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\"})\n+    public void applyIfNotTooManyFlags() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"Bla\"})\n+    public void applyIfNotMissingValue() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"PrintIdealGraphFilee\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"Bla\", \"foo\"})\n+    public void applyIfNotUnknownFlag() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\" \", \" \"})\n+    public void applyIfNotEmptyValue() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"<\"})\n+    public void applyIfNotFaultyComparator() {}\n+\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"50\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfAndNotEnoughFlags() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"Bla\"})\n+    public void applyIfAndMissingValue() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFilee\", \"true\", \"TLABRefillWasteFraction\", \"< 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!= 50\", \"Bla\", \"bla\", \"Bla2\", \"bla2\"})\n+    public void applyIfAndUnknownFlag() {}\n+\n+    @FailCount(18)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFile\", \"\", \"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"UseTLAB\", \"\", \"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"true\", \"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"\", \"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\" \", \" \", \" \", \" \"})\n+    public void applyIfAndEmptyValue() {}\n+\n+    @FailCount(20)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"! 34\", \"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!== 34\", \"TLABRefillWasteFraction\", \"=== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<<= 34\", \"TLABRefillWasteFraction\", \">>= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"=<34\", \"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<\", \"TLABRefillWasteFraction\", \"!=\"})\n+    public void applyIfAndFaultyComparator() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"50\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfOrNotEnoughFlags() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"Bla\"})\n+    public void applyIfOrMissingValue() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFilee\", \"true\", \"TLABRefillWasteFraction\", \"< 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!= 50\", \"Bla\", \"bla\", \"Bla2\", \"bla2\"})\n+    public void applyIfOrUnknownFlag() {}\n+\n+    @FailCount(18)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFile\", \"\", \"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"UseTLAB\", \"\", \"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"true\", \"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"\", \"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\" \", \" \", \" \", \" \"})\n+    public void applyIfOrEmptyValue() {}\n+\n+    @FailCount(20)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"! 34\", \"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!== 34\", \"TLABRefillWasteFraction\", \"=== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<<= 34\", \"TLABRefillWasteFraction\", \">>= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"=<34\", \"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<\", \"TLABRefillWasteFraction\", \"!=\"})\n+    public void applyIfOrFaultyComparator() {}\n+\n+\n+    @Test\n+    @FailCount(3)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"48.5\"})\n+    public void wrongFlagValueLongFlag() {}\n+\n+    @Test\n+    @FailCount(3)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"true\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"48\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"48.5\"})\n+    public void wrongFlagValueBooleanFlag() {}\n+\n+    @Test\n+    @FailCount(2)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"48.5\"}) \/\/ valid\n+    public void wrongFlagValueDoubleFlag() {}\n+\n+    @Test\n+    @NoFail\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"true\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"SomeString\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"48.5\"}) \/\/ valid\n+    public void anyValueForStringFlags() {}\n+}\n+\n+@ClassFail\n+class BadInnerClassTest {\n+\n+    class InnerClass {\n+        @Test\n+        public void noTestInInnerClass1() {}\n+\n+        @Test\n+        public void noTestInInnerClass2() {}\n+\n+        @Check(test = \"noTestInInnerClass2\")\n+        public void checkNoTestInInnerClass2() {}\n+\n+        @Test\n+        public void noTestInInnerClass3() {}\n+\n+        @Run(test = \"noTestInInnerClass3\")\n+        public void checkNoTestInInnerClass3() {}\n+    }\n+\n+\n+    static class StaticInnerClass {\n+        @Test\n+        public void noTestInInnerStaticClass1() {}\n+\n+        @Test\n+        public void noTestInStaticInnerClass2() {}\n+\n+        @Check(test = \"noTestInStaticInnerClass2\")\n+        public void checkNoTestInStaticInnerClass2() {}\n+\n+        @Test\n+        public void noTestInStaticInnerClass3() {}\n+\n+        @Run(test = \"noTestInStaticInnerClass3\")\n+        public void checkNoTestInStaticInnerClass3() {}\n+    }\n+}\n+\n+@ForceCompileClassInitializer\n+class BadCompileClassInitializer {\n+    static int iFld = 3;\n+\n+    @Test\n+    @ForceCompileClassInitializer\n+    public void test() {}\n+\n+    @ForceCompileClassInitializer\n+    public void helper() {}\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer(CompLevel.SKIP)\n+class BadCompileClassInitializerHelper1 {\n+\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer(CompLevel.WAIT_FOR_COMPILATION)\n+class BadCompileClassInitializerHelper2 {\n+\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer\n+class BadCompileClassInitializerHelper3 {\n+    \/\/ no <clinit>\n+}\n+\n+class ClassNoDefaultConstructor {\n+    private ClassNoDefaultConstructor(int i) {\n+    }\n+}\n+\n+\/\/ Test specific annotation:\n+\/\/ All methods without such an annotation must occur in the violation messages.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface NoFail {}\n+\n+\/\/ Test specific annotation:\n+\/\/ Specify a fail count for a method without @NoFail. Use the value 0 if multiple methods are part of the same violation.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface FailCount {\n+    int value();\n+}\n+\n+\/\/ Class specific annotation:\n+\/\/ All classes with such an annotation have exactly one violation with the clas name in it.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface ClassFail {}\n+\n+class Violations {\n+    private final List<String> failedMethods = new ArrayList<>();\n+    private int violations;\n+\n+    public int getViolationCount() {\n+        return violations;\n+    }\n+\n+    public List<String> getFailedMethods() {\n+        return failedMethods;\n+    }\n+\n+    public void addFail(Method m, int count) {\n+        failedMethods.add(m.getName());\n+        violations += count;\n+    }\n+\n+    public void addFail(Class<?> c) {\n+        failedMethods.add(c.getName());\n+        violations += 1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestBadFormat.java","additions":1001,"deletions":0,"binary":false,"changes":1001,"status":"added"},{"patch":"@@ -0,0 +1,1085 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ * @summary Test basics of the framework. This test runs directly the test VM which normally does not happen.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.lib.ir_framework.TestBasics\n+ *\/\n+\n+public class TestBasics {\n+    private static boolean wasExecuted = false;\n+    private boolean lastToggleBoolean = true;\n+    private final static int[] executed = new int[100];\n+    private final static int[] executedOnce = new int[5];\n+    private long[] nonFloatingRandomNumbers = new long[10];\n+    private double[] floatingRandomNumbers = new double[10];\n+    private Boolean[] randomBooleans = new Boolean[64];\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Run on same VM to make this test easier as we are not interested in any output processing.\n+        Class<?> c = TestFramework.class; \/\/ Enable JTreg test to compile TestFramework\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{ null });\n+\n+        if (wasExecuted) {\n+            throw new RuntimeException(\"Executed non @Test method or a method that was not intended to be run\");\n+        }\n+        for (int i = 0; i < executed.length; i++) {\n+            int value = executed[i];\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n+                \/\/ Warmups + 1 C2 compiled invocation\n+                throw new RuntimeException(\"Test \" + i + \"  was executed \" + value + \" times instead stead of \"\n+                                           + (TestVM.WARMUP_ITERATIONS + 1) + \" times.\" );\n+            }\n+        }\n+\n+        for (int value : executedOnce) {\n+            if (value != 1) {\n+                throw new RuntimeException(\"Check function should have been executed exactly once\");\n+            }\n+        }\n+    }\n+\n+    private void clearNonFloatingRandomNumbers() {\n+        nonFloatingRandomNumbers = new long[10];\n+    }\n+\n+    private void clearFloatingRandomNumbers() {\n+        floatingRandomNumbers = new double[10];\n+    }\n+\n+    private void clearRandomBooleans() {\n+        randomBooleans = new Boolean[64];\n+    }\n+\n+    \/\/ Base test, no arguments, directly invoked.\n+    @Test\n+    public void test() {\n+        executed[0]++;\n+    }\n+\n+    \/\/ Not a test\n+    public void noTest() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Not a test\n+    public void test2() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Can overload non- @Test\n+    public static void test2(int i) {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Can overload a @Test if it is not a @Test itself.\n+    public static void test(double i) {\n+        wasExecuted = true;\n+    }\n+\n+    @Test\n+    public static void staticTest() {\n+        executed[1]++;\n+    }\n+\n+    @Test\n+    public final void finalTest() {\n+        executed[2]++;\n+    }\n+\n+    @Test\n+    public int returnValueTest() {\n+        executed[3]++;\n+        return 4;\n+    }\n+\n+    \/\/ Base test, with arguments, directly invoked.\n+    \/\/ Specify the argument values with @Arguments\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void byteDefaultArgument(byte x) {\n+        executed[4]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void shortDefaultArgument(short x) {\n+        executed[5]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void intDefaultArgument(int x) {\n+        executed[6]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void longDefaultArgument(long x) {\n+        executed[7]++;\n+        if (x != 0L) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void floatDefaultArgument(float x) {\n+        executed[8]++;\n+        if (x != 0.0f) {\n+            throw new RuntimeException(\"Must be 0.0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void doubleDefaultArgument(double x) {\n+        executed[9]++;\n+        if (x != 0.0f) {\n+            throw new RuntimeException(\"Must be 0.0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void charDefaultArgument(char x) {\n+        executed[10]++;\n+        if (x != '\\u0000') {\n+            throw new RuntimeException(\"Must be \\u0000\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void booleanDefaultArgument(boolean x) {\n+        executed[11]++;\n+        if (x) {\n+            throw new RuntimeException(\"Must be false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void stringObjectDefaultArgument(String x) {\n+        executed[12]++;\n+        if (x == null || x.length() != 0) {\n+            throw new RuntimeException(\"Default string object must be non-null and having a length of zero\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void defaultObjectDefaultArgument(DefaultObject x) {\n+        executed[13]++;\n+        if (x == null || x.i != 4) {\n+            throw new RuntimeException(\"Default object must not be null and its i field must be 4\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void byte42(byte x) {\n+        executed[14]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void short42(short x) {\n+        executed[15]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void int42(int x) {\n+        executed[16]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void long42(long x) {\n+        executed[17]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void float42(float x) {\n+        executed[18]++;\n+        if (x != 42.0) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void double42(double x) {\n+        executed[19]++;\n+        if (x != 42.0) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.FALSE)\n+    public void booleanFalse(boolean x) {\n+        executed[20]++;\n+        if (x) {\n+            throw new RuntimeException(\"Must be false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void booleanTrue(boolean x) {\n+        executed[21]++;\n+        if (!x) {\n+            throw new RuntimeException(\"Must be true\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomByte(byte x) {\n+        executed[22]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomShort(short x) {\n+        executed[23]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomInt(int x) {\n+        executed[24]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomLong(long x) {\n+        executed[25]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomFloat(float x) {\n+        executed[26]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomDouble(double x) {\n+        executed[27]++;\n+    }\n+\n+    \/\/ Not executed\n+    public void randomNotExecutedTest(double x) {\n+        wasExecuted = true;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomBoolean(boolean x) {\n+        executed[28]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_FALSE)\n+    public void booleanToggleFirstFalse(boolean x) {\n+        if (executed[29] == 0) {\n+            \/\/ First invocation\n+            if (x) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE must be false on first invocation\");\n+            }\n+        } else if (x == lastToggleBoolean) {\n+            throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE did not toggle\");\n+        }\n+        lastToggleBoolean = x;\n+        executed[29]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachByte(byte x) {\n+        checkNonFloatingRandomNumber(x, executed[30]);\n+        executed[30]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachShort(short x) {\n+        checkNonFloatingRandomNumber(x, executed[31]);\n+        executed[31]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachInt(int x) {\n+        checkNonFloatingRandomNumber(x, executed[32]);\n+        executed[32]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachLong(long x) {\n+        checkNonFloatingRandomNumber(x, executed[33]);\n+        executed[33]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachChar(char x) {\n+        checkNonFloatingRandomNumber(x, executed[34]);\n+        executed[34]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachFloat(float x) {\n+        checkFloatingRandomNumber(x, executed[35]);\n+        executed[35]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachDouble(double x) {\n+        checkFloatingRandomNumber(x, executed[36]);\n+        executed[36]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachBoolean(boolean x) {\n+        checkRandomBoolean(x, executed[37]);\n+        executed[37]++;\n+    }\n+\n+    private void checkNonFloatingRandomNumber(long x, int invocationCount) {\n+        int mod10 = invocationCount % 10;\n+        if (invocationCount > 0 && mod10 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 10 numbers and ensure that there are at least 2 different ones.\n+            \/\/ All numbers are equal? Very unlikely nd we should really consider to play the lottery...\n+            long first = nonFloatingRandomNumbers[0];\n+            if (Arrays.stream(nonFloatingRandomNumbers).allMatch(n -> n == first)) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random integer numbers\");\n+            }\n+            clearNonFloatingRandomNumbers();\n+        }\n+        nonFloatingRandomNumbers[mod10] = x;\n+    }\n+\n+    private void checkFloatingRandomNumber(double x, int invocationCount) {\n+        int mod10 = invocationCount % 10;\n+        if (invocationCount > 0 && mod10 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 10 numbers and ensure that there are at least 2 different ones.\n+            \/\/ All numbers are equal? Very unlikely nd we should really consider to play the lottery...\n+            double first = floatingRandomNumbers[0];\n+            if (Arrays.stream(floatingRandomNumbers).allMatch(n -> n == first)) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random floating point numbers\");\n+            }\n+            clearFloatingRandomNumbers();\n+        }\n+        floatingRandomNumbers[mod10] = x;\n+    }\n+\n+    private void checkRandomBoolean(boolean x, int invocationCount) {\n+        int mod64 = invocationCount % 64;\n+        if (invocationCount > 0 && mod64 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 64 booleans and ensure that there are at least one true and one false.\n+            \/\/ All booleans are equal? Very unlikely (chance of 2^64) and we should really consider\n+            \/\/ to play the lottery...\n+            if (Arrays.stream(randomBooleans).allMatch(b -> b == randomBooleans[0])) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random booleans\");\n+            }\n+            clearRandomBooleans();\n+        }\n+        randomBooleans[mod64] = x;\n+    }\n+\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void byteMinus42(byte x) {\n+        executed[38]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void shortMinus42(short x) {\n+        executed[39]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void intMinus42(int x) {\n+        executed[40]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void longMinus42(long x) {\n+        executed[41]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void floatMinus42(float x) {\n+        executed[42]++;\n+        if (x != -42.0) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void doubleMinus42(double x) {\n+        executed[43]++;\n+        if (x != -42.0) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void byteMin(byte x) {\n+        executed[79]++;\n+        if (x != Byte.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void charMin(char x) {\n+        executed[80]++;\n+        if (x != Character.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void shortMin(short x) {\n+        executed[81]++;\n+        if (x != Short.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void intMin(int x) {\n+        executed[82]++;\n+        if (x != Integer.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void longMin(long x) {\n+        executed[83]++;\n+        if (x != Long.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void floatMin(float x) {\n+        executed[84]++;\n+        if (x != Float.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void doubleMin(double x) {\n+        executed[85]++;\n+        if (x != Double.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void byteMax(byte x) {\n+        executed[86]++;\n+        if (x != Byte.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void charMax(char x) {\n+        executed[87]++;\n+        if (x != Character.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void shortMax(short x) {\n+        executed[88]++;\n+        if (x != Short.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void intMax(int x) {\n+        executed[89]++;\n+        if (x != Integer.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void longMax(long x) {\n+        executed[90]++;\n+        if (x != Long.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void floatMax(float x) {\n+        executed[91]++;\n+        if (x != Float.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void doubleMax(double x) {\n+        executed[78]++;\n+        if (x != Double.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault1(byte x, short y) {\n+        executed[44]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault2(int x, short y) {\n+        executed[45]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault3(short x, long y) {\n+        executed[46]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault4(float x, boolean y) {\n+        executed[47]++;\n+        if (x != 0.0 || y) {\n+            throw new RuntimeException(\"Must be 0 and false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault5(boolean x, char y) {\n+        executed[48]++;\n+        if (x || y != '\\u0000') {\n+            throw new RuntimeException(\"Must be false and \\u0000\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault6(char x, byte y) {\n+        executed[49]++;\n+        if (x != '\\u0000' || y != 0) {\n+            throw new RuntimeException(\"Must be\\u0000 and 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void twoArgsRandomOnce(char x, byte y) {\n+        executed[50]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void checkRandomOnceDifferentArgs(int a, int b, int c, int d, int e, int f, int g, int h) {\n+        if (Stream.of(a, b, c, d, e, f, g, h).allMatch(i -> i == a)) {\n+            throw new RuntimeException(\"RANDOM_ONCE does not produce random values for different arguments\");\n+        }\n+        executed[51]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void checkMixedRandoms1(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[52]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public void checkMixedRandoms2(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[53]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_ONCE})\n+    public void checkMixedRandoms3(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[54]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42,\n+                Argument.NUMBER_42, Argument.NUMBER_42,\n+                Argument.NUMBER_42, Argument.NUMBER_42})\n+    public void check42Mix1(byte a, short b, int c, long d, float e, double f) {\n+        if (a != 42 || b != 42 || c != 42 || d != 42 || e != 42.0 || f != 42.0) {\n+            throw new RuntimeException(\"Must all be 42\");\n+        }\n+        executed[55]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42})\n+    public void check42Mix2(byte a, short b, int c, long d, float e, double f) {\n+        if (a != -42 || b != -42 || c != -42 || d != -42 || e != -42.0 || f != -42.0) {\n+            throw new RuntimeException(\"Must all be -42\");\n+        }\n+        executed[56]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_MINUS_42, Argument.NUMBER_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_42, Argument.NUMBER_MINUS_42})\n+    public void check42Mix3(byte a, short b, int c, long d, float e, double f) {\n+        if (a != -42 || b != 42 || c != -42 || d != -42 || e != 42.0 || f != -42.0) {\n+            throw new RuntimeException(\"Do not match the right 42 version\");\n+        }\n+        executed[57]++;\n+    }\n+\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_TRUE)\n+    public void booleanToggleFirstTrue(boolean x) {\n+        if (executed[58] == 0) {\n+            \/\/ First invocation\n+            if (!x) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE must be false on first invocation\");\n+            }\n+        } else if (x == lastToggleBoolean) {\n+            throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE did not toggle\");\n+        }\n+        lastToggleBoolean = x;\n+        executed[58]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    public void checkTwoToggles(boolean b1, boolean b2) {\n+        if (executed[59] == 0) {\n+            \/\/ First invocation\n+            if (b1 || !b2) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLES have wrong initial value\");\n+            }\n+        } else if (b1 == b2) {\n+            throw new RuntimeException(\"Boolean values must be different\");\n+        } else if (b1 == lastToggleBoolean) {\n+            throw new RuntimeException(\"Booleans did not toggle\");\n+        }\n+        lastToggleBoolean = b1;\n+        executed[59]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.FALSE,\n+                Argument.TRUE, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    public void booleanMix(boolean b1, boolean b2, boolean b3, boolean b4) {\n+        if (executed[60] == 0) {\n+            \/\/ First invocation\n+            if (b1 || b2 || !b3 || !b4) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLES have wrong initial value\");\n+            }\n+        } else if (b1 == b4) {\n+            throw new RuntimeException(\"Boolean values must be different\");\n+        } else if (b1 == lastToggleBoolean) {\n+            throw new RuntimeException(\"Booleans did not toggle\");\n+        }\n+        lastToggleBoolean = b1;\n+        executed[60]++;\n+    }\n+\n+    \/*\n+     * Checked tests.\n+     *\/\n+\n+    @Test\n+    public int testCheck() {\n+        executed[63]++;\n+        return 1;\n+    }\n+\n+    \/\/ Checked test. Check invoked after invoking \"testCheck\". Perform some more things after invocation.\n+    @Check(test = \"testCheck\")\n+    public void checkTestCheck() {\n+        executed[64]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckReturn() {\n+        executed[65]++;\n+        return 2;\n+    }\n+\n+    \/\/ Checked test with return value. Perform checks on it.\n+    @Check(test = \"testCheckReturn\")\n+    public void checkTestCheckReturn(int returnValue) {\n+        if (returnValue != 2) {\n+            throw new RuntimeException(\"Must be 2\");\n+        }\n+        executed[66]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public short testCheckWithArgs(short x) {\n+        executed[94]++;\n+        return x;\n+    }\n+\n+    @Check(test = \"testCheckWithArgs\")\n+    public void checkTestCheckWithArgs(short returnValue) {\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+        executed[95]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckTestInfo() {\n+        executed[67]++;\n+        return 3;\n+    }\n+\n+    \/\/ Checked test with info object about test.\n+    @Check(test = \"testCheckTestInfo\")\n+    public void checkTestCheckTestInfo(TestInfo testInfo) {\n+        executed[68]++; \/\/ Executed on each invocation\n+    }\n+\n+\n+    @Test\n+    public int testCheckBoth() {\n+        executed[69]++;\n+        return 4;\n+    }\n+\n+    \/\/ Checked test with return value and info object about test.\n+    @Check(test = \"testCheckBoth\")\n+    public void checkTestCheckTestInfo(int returnValue, TestInfo testInfo) {\n+        if (returnValue != 4) {\n+            throw new RuntimeException(\"Must be 4\");\n+        }\n+        executed[70]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckOnce() {\n+        executed[71]++;\n+        return 1;\n+    }\n+\n+    \/\/ Check method only invoked once after method is compiled after warm up.\n+    @Check(test = \"testCheckOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckOnce() {\n+        executedOnce[0]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckReturnOnce() {\n+        executed[72]++;\n+        return 2;\n+    }\n+\n+    @Check(test = \"testCheckReturnOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckReturnOnce(int returnValue) {\n+        if (returnValue != 2) {\n+            throw new RuntimeException(\"Must be 2\");\n+        }\n+        executedOnce[1]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckTestInfoOnce() {\n+        executed[73]++;\n+        return 3;\n+    }\n+\n+    @Check(test = \"testCheckTestInfoOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckTestInfoOnce(TestInfo testInfo) {\n+        executedOnce[2]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckBothOnce() {\n+        executed[74]++;\n+        return 4;\n+    }\n+\n+    @Check(test = \"testCheckBothOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckBothOnce(int returnValue, TestInfo testInfo) {\n+        if (returnValue != 4) {\n+            throw new RuntimeException(\"Must be 4\");\n+        }\n+        executedOnce[3]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public void sameName() {\n+        executed[76]++;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    public void sameName(boolean a) {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    @Check(test = \"sameName\")\n+    public void sameName(TestInfo info) {\n+        executed[77]++;\n+    }\n+\n+\n+    \/*\n+     * Custom run tests.\n+     *\/\n+\n+    @Test\n+    public void sameName2() {\n+        executed[92]++;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    @Run(test = \"sameName2\")\n+    public void sameName2(RunInfo info) {\n+        executed[93]++;\n+        sameName2();\n+    }\n+\n+    @Test\n+    public void testRun() {\n+        executed[61]++;\n+    }\n+\n+    \/\/ Custom run test. This method is invoked each time instead of @Test method. This method responsible for calling\n+    \/\/ the @Test method. @Test method is compiled after warm up. This is similar to the verifiers in the old Valhalla framework.\n+    @Run(test = \"testRun\")\n+    public void runTestRun(RunInfo info) {\n+        testRun();\n+    }\n+\n+    @Test\n+    public void testRunNoTestInfo(int i) { \/\/ Argument allowed when run by @Run\n+        executed[62]++;\n+    }\n+\n+    @Run(test = \"testRunNoTestInfo\")\n+    public void runTestRunNoTestInfo() {\n+        testRunNoTestInfo(3);\n+    }\n+\n+    @Test\n+    public void testNotRun() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = \"testNotRun\")\n+    public void runTestNotRun() {\n+        \/\/ Do not execute the test. Pointless but need to test that as well.\n+    }\n+\n+    @Test\n+    public void testRunOnce() {\n+        executedOnce[4]++;\n+    }\n+\n+    \/\/ Custom run test that is only invoked once. There is no warm up and no compilation. This method is responsible\n+    \/\/ for triggering compilation.\n+    @Run(test = \"testRunOnce\", mode = RunMode.STANDALONE)\n+    public void runTestRunOnce(RunInfo info) {\n+        testRunOnce();\n+    }\n+\n+    @Test\n+    public void testRunOnce2() {\n+        executed[75]++;\n+    }\n+\n+    @Run(test = \"testRunOnce2\", mode = RunMode.STANDALONE)\n+    public void runTestRunOnce2(RunInfo info) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n+            testRunOnce2();\n+        }\n+    }\n+\n+    @Test\n+    public void testRunMultiple() {\n+        executed[96]++;\n+    }\n+\n+    @Test\n+    public void testRunMultiple2() {\n+        executed[97]++;\n+    }\n+\n+    @Test\n+    public void testRunMultipleNotExecuted() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = {\"testRunMultiple\", \"testRunMultiple2\", \"testRunMultipleNotExecuted\"})\n+    public void runTestRunMultiple() {\n+        testRunMultiple();\n+        testRunMultiple2();\n+    }\n+\n+\n+    @Test\n+    public void testRunMultiple3() {\n+        executed[98]++;\n+    }\n+\n+    @Test\n+    public void testRunMultiple4() {\n+        executed[99]++;\n+    }\n+\n+    @Test\n+    public void testRunMultipleNotExecuted2() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = {\"testRunMultiple3\", \"testRunMultiple4\", \"testRunMultipleNotExecuted2\"}, mode = RunMode.STANDALONE)\n+    public void runTestRunMultipl2(RunInfo info) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n+            testRunMultiple3();\n+            testRunMultiple4();\n+        }\n+    }\n+}\n+\n+class DefaultObject {\n+    int i = 4;\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestBasics.java","additions":1085,"deletions":0,"binary":false,"changes":1085,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test if compilation levels are used correctly in the framework.\n+ *          This test partly runs directly the test VM which normally does and should not happen in user tests.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI compiler.lib.ir_framework.TestCompLevels\n+ *\/\n+\n+public class TestCompLevels {\n+    static int[] testExecuted = new int[5];\n+\n+    public static void main(String[] args) throws Exception {\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{null});\n+\n+        for (int i = 0; i < testExecuted.length; i++) {\n+            int value = testExecuted[i];\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n+                \/\/ Warmups + 1 compiled invocation\n+                throw new RuntimeException(\"Test \" + i + \"  was executed \" + value + \" times stead of \"\n+                                           + TestVM.WARMUP_ITERATIONS + 1 + \" times.\" );\n+            }\n+        }\n+        TestFramework framework = new TestFramework(TestNoTiered.class);\n+        framework.setDefaultWarmup(10).addFlags(\"-XX:-TieredCompilation\").start();\n+        framework = new TestFramework(TestNoTiered.class);\n+        framework.setDefaultWarmup(10).addScenarios(new Scenario(0, \"-XX:-TieredCompilation\")).start();\n+        framework = new TestFramework(TestStopAtLevel1.class);\n+        framework.setDefaultWarmup(10).addFlags(\"-XX:TieredStopAtLevel=1\").start();\n+        framework = new TestFramework(TestStopAtLevel1.class);\n+        framework.setDefaultWarmup(10).addScenarios(new Scenario(0, \"-XX:TieredStopAtLevel=1\")).start();\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void testC1() {\n+        testExecuted[0]++;\n+    }\n+\n+    @Check(test = \"testC1\", when = CheckAt.COMPILED)\n+    public void checkTestC1(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_SIMPLE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void testC1Limited() {\n+        testExecuted[1]++;\n+    }\n+\n+    @Check(test = \"testC1Limited\", when = CheckAt.COMPILED)\n+    public void checkTestLimited(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_LIMITED_PROFILE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void testC1Full() {\n+        testExecuted[2]++;\n+    }\n+\n+    @Check(test = \"testC1Full\", when = CheckAt.COMPILED)\n+    public void checkTestC1Full(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_FULL_PROFILE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void testC2() {\n+        testExecuted[3]++;\n+    }\n+\n+    @Check(test = \"testC2\", when = CheckAt.COMPILED)\n+    public void checkTestC2(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C2);\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void testSkip() {\n+        testExecuted[4]++; \/\/ Executed by eventually not compiled by framework\n+    }\n+}\n+\n+class TestNoTiered {\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void level1() {\n+    }\n+\n+    @Check(test = \"level1\")\n+    public void check1(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void level2() {\n+    }\n+\n+    @Check(test = \"level2\")\n+    public void check2(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void level3() {\n+    }\n+\n+    @Check(test = \"level3\")\n+    public void check3(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void level4() {\n+    }\n+\n+    @Check(test = \"level4\")\n+    public void check4(TestInfo info) {\n+        if (info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+        } else {\n+            if (TestFramework.isC1Compiled(info.getTest())) {\n+                throw new RuntimeException(\"Cannot be compiled with C1\"); \/\/ Never compiled without C1\n+            }\n+            TestFramework.assertCompiledByC2(info.getTest());\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void skip() {\n+    }\n+\n+    @Check(test = \"skip\")\n+    public void checkSkip(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled\n+    }\n+}\n+\n+class TestStopAtLevel1 {\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int level1() {\n+        return 34;\n+    }\n+\n+    @Check(test = \"level1\")\n+    public void check1(int result, TestInfo info) {\n+        if (info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest()); \/\/ Not compiled yet\n+        } else {\n+            TestFramework.assertCompiledByC1(info.getTest());\n+            if (TestFramework.isC2Compiled(info.getTest())) {\n+                throw new RuntimeException(\"Cannot be compiled by C2\");\n+            }\n+            System.out.println(\"TestStopAtLevel1=\" + result);\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void level2() {\n+    }\n+\n+    @Check(test = \"level2\")\n+    public void check2(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 2\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void level3() {\n+    }\n+\n+    @Check(test = \"level3\")\n+    public void check3(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 3\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void level4() {\n+    }\n+\n+    @Check(test = \"level4\")\n+    public void check4(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 4\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void skip() {\n+    }\n+\n+    @Check(test = \"skip\")\n+    public void checkSkip(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestCompLevels.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test if compilation control annotaions are handled correctly in the framework.\n+ *          This test partly runs directly the test VM which normally does and should not happen in user tests.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI compiler.lib.ir_framework.TestControls\n+ *\/\n+\n+public class TestControls {\n+    static int[] executed = new int[15];\n+    static boolean wasExecuted = false;\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public int iFld;\n+\n+    public static void main(String[] args) throws Exception {\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{ null });\n+        final int defaultIterations = TestVM.WARMUP_ITERATIONS + 1;\n+        Asserts.assertEQ(executed[0], 1001);\n+        Asserts.assertEQ(executed[1], 101);\n+        Asserts.assertEQ(executed[2], 10000);\n+        Asserts.assertEQ(executed[3], 10000);\n+        Asserts.assertEQ(executed[4], defaultIterations);\n+        Asserts.assertEQ(executed[5], defaultIterations);\n+        Asserts.assertEQ(executed[6], 5001);\n+        Asserts.assertEQ(executed[7], 5001);\n+        Asserts.assertEQ(executed[8], 1);\n+        Asserts.assertEQ(executed[9], 5000);\n+        Asserts.assertEQ(executed[10], 1);\n+        Asserts.assertEQ(executed[11], 2);\n+        Asserts.assertEQ(executed[12], 1);\n+        Asserts.assertEQ(executed[13], 1);\n+        Asserts.assertFalse(wasExecuted);\n+        final long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+        Method overloadDouble = TestControls.class.getDeclaredMethod(\"overload\", double.class);\n+        Method overloadInt = TestControls.class.getDeclaredMethod(\"overload\", int.class);\n+        while (!(TestFramework.isC2Compiled(overloadInt) && TestFramework.isCompiledAtLevel(overloadDouble, CompLevel.C1_LIMITED_PROFILE)) && elapsed < 5000) {\n+            elapsed = System.currentTimeMillis() - started;\n+        }\n+        TestFramework.assertCompiledAtLevel(TestControls.class.getDeclaredMethod(\"overload\", double.class), CompLevel.C1_LIMITED_PROFILE);\n+        TestFramework.assertCompiledByC2(TestControls.class.getDeclaredMethod(\"overload\", int.class));\n+\n+        TestFramework framework = new TestFramework(ClassInitializerTest.class);\n+        framework.addFlags(\"-XX:+PrintCompilation\").addHelperClasses(ClassInitializerHelper.class).start();\n+        String output = TestFramework.getLastTestVMOutput();\n+        Pattern p = Pattern.compile(\"4.*ClassInitializerTest::<clinit>\");\n+        Matcher m = p.matcher(output);\n+        Asserts.assertTrue(m.find());\n+        p = Pattern.compile(\"2.*ClassInitializerHelper::<clinit>\");\n+        m = p.matcher(output);\n+        Asserts.assertTrue(m.find());\n+\n+        new TestFramework(TestWarmup.class).setDefaultWarmup(500).start();\n+        TestFramework.run(ExplicitSkip.class);\n+    }\n+\n+    @Test\n+    @Warmup(1000)\n+    public void test1() {\n+        executed[0]++;\n+    }\n+\n+    @Check(test = \"test1\")\n+    public void check1(TestInfo info) {\n+        if (executed[0] <= 1000) {\n+            Asserts.assertTrue(info.isWarmUp());\n+        } else {\n+            Asserts.assertTrue(!info.isWarmUp() && executed[0] == 1001);\n+            TestFramework.assertCompiledByC2(info.getTest());\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(100)\n+    public void test2() {\n+        executed[1]++;\n+    }\n+\n+    @Check(test = \"test2\", when = CheckAt.COMPILED)\n+    public void check2(TestInfo info) {\n+        Asserts.assertTrue(!info.isWarmUp() && executed[1] == 101);\n+        TestFramework.assertCompiledByC2(info.getTest());\n+    }\n+\n+    @Test\n+    public void overload() {\n+        executed[4]++;\n+    }\n+\n+    @ForceCompile\n+    @DontInline\n+    public static void overload(int i) {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_LIMITED_PROFILE)\n+    @ForceInline\n+    public static void overload(double i) {\n+        wasExecuted = true;\n+    }\n+\n+    @Check(test = \"overload\")\n+    public void checkOverload()  {\n+        executed[5]++;\n+    }\n+\n+    @Test\n+    public void testDontCompile() {\n+        executed[2]++;\n+    }\n+\n+    @DontCompile\n+    public static void dontCompile() {\n+        executed[3]++;\n+    }\n+\n+    @Run(test = \"testDontCompile\", mode = RunMode.STANDALONE)\n+    public void runTestDontCompile() throws NoSuchMethodException {\n+        for (int i = 0; i < 10000; i++) {\n+            dontCompile(); \/\/ Should not compile this method\n+            testDontCompile();\n+        }\n+        TestFramework.assertNotCompiled(TestControls.class.getDeclaredMethod(\"dontCompile\"));\n+    }\n+\n+    @Test\n+    public void testCompileAtLevel1() {\n+        executed[6]++;\n+    }\n+\n+    @DontCompile(Compiler.ANY)\n+    public static void dontCompile2() {\n+        executed[7]++;\n+    }\n+\n+    @Run(test = \"testCompileAtLevel1\")\n+    @Warmup(5000)\n+    public void runTestDontCompile2(RunInfo info) throws NoSuchMethodException {\n+        dontCompile2();\n+        testCompileAtLevel1();\n+        if (!info.isWarmUp()) {\n+            executed[8]++;\n+            int compLevel = WHITE_BOX.getMethodCompilationLevel(TestControls.class.getDeclaredMethod(\"dontCompile2\"), false);\n+            Asserts.assertLessThan(compLevel, CompLevel.C1_LIMITED_PROFILE.getValue());\n+        } else {\n+            executed[9]++;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    public void noWarmup() {\n+        executed[10]++;\n+    }\n+\n+    @Test\n+    public void noWarmup2() {\n+        executed[11]++;\n+    }\n+\n+    @Run(test = \"noWarmup2\")\n+    @Warmup(0)\n+    public void runNoWarmup2(RunInfo info) {\n+        noWarmup2();\n+        noWarmup2();\n+        Asserts.assertTrue(!info.isWarmUp());\n+        executed[12]++;\n+    }\n+\n+    @Test\n+    public void testCompilation() {\n+        wasExecuted = true;\n+    }\n+\n+    @DontCompile(Compiler.ANY)\n+    public void dontCompileAny() {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = i;\n+        }\n+    }\n+\n+    @DontCompile(Compiler.C1)\n+    public void dontCompileC1() {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = 3;\n+        }\n+    }\n+\n+    @DontCompile(Compiler.C2)\n+    public void dontCompileC2(int x, boolean b) {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = x;\n+        }\n+    }\n+\n+    \/\/ Default is C2.\n+    @ForceCompile\n+    public void forceCompileDefault() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ ANY maps to C2.\n+    @ForceCompile\n+    public void forceCompileAny() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public void forceCompileC1() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_LIMITED_PROFILE)\n+    public void forceCompileC1Limited() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_FULL_PROFILE)\n+    public void forceCompileC1Full() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C2)\n+    public void forceCompileC2() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C2)\n+    public void forceC1DontC2() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C1)\n+    public void forceC2DontC1() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = \"testCompilation\")\n+    @Warmup(0)\n+    public void runTestCompilation(RunInfo info) {\n+        for (int i = 0; i < 100000; i++) {\n+            dontCompileAny();\n+            dontCompileC1();\n+            dontCompileC2(i, i % 2 == 0);\n+        }\n+        TestFramework.assertCompiledByC2(info.getTest());\n+        TestFramework.assertNotCompiled(info.getTestClassMethod(\"dontCompileAny\"));\n+        TestFramework.assertCompiledByC2(info.getTestClassMethod(\"dontCompileC1\"));\n+        TestFramework.assertCompiledByC1(info.getTestClassMethod(\"dontCompileC2\", int.class, boolean.class));\n+\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileDefault\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileAny\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC2\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1\"), CompLevel.C1_SIMPLE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1Limited\"), CompLevel.C1_LIMITED_PROFILE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1Full\"), CompLevel.C1_FULL_PROFILE);\n+\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC1DontC2\"), CompLevel.C1_SIMPLE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC2DontC1\"), CompLevel.C2);\n+        executed[13]++;\n+    }\n+}\n+\n+@ForceCompileClassInitializer\n+class ClassInitializerTest {\n+\n+    static int i;\n+    static Object o;\n+    static {\n+        i = 3;\n+        o = new Object();\n+    }\n+    @Test\n+    public void test() {}\n+}\n+\n+@ForceCompileClassInitializer(CompLevel.C1_LIMITED_PROFILE)\n+class ClassInitializerHelper {\n+    static int i;\n+    static {\n+        i = 3;\n+    }\n+}\n+\n+class TestWarmup {\n+    int iFld;\n+    int iFld2;\n+    int iFldCheck;\n+    int iFldCheck2;\n+\n+    @Test\n+    @Warmup(200)\n+    public void test() {\n+        iFld++;\n+    }\n+\n+    @Test\n+    public void test2() {\n+        iFld2++;\n+    }\n+\n+    @Check(test = \"test\")\n+    public void checkTest(TestInfo info) {\n+        iFldCheck++;\n+        if (iFldCheck != iFld) {\n+            throw new RuntimeException(iFld + \" must be equal \" + iFldCheck);\n+        }\n+        if (!info.isWarmUp()) {\n+            if (iFld != 201) {\n+                throw new RuntimeException(\"Must be 201 but was \" + iFld);\n+            }\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    public void checkTest2(TestInfo info) {\n+        iFldCheck2++;\n+        if (iFldCheck2 != iFld2) {\n+            throw new RuntimeException(iFld2 + \" must be equal \" + iFldCheck2);\n+        }\n+        if (!info.isWarmUp()) {\n+            if (iFld2 != 501) {\n+                throw new RuntimeException(\"Must be 501 but was \" + iFld2);\n+            }\n+        }\n+    }\n+}\n+\n+\n+class ExplicitSkip {\n+    int iFld;\n+\n+    \/\/ Test skipped and thus also no IR verification should be done.\n+    @Test(compLevel = CompLevel.SKIP)\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test\")\n+    public void run(RunInfo info) {\n+        test(34);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestControls.java","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Sanity test remaining framework property flags.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DFlipC1C2=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DExcludeRandom=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerifyVM=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DDumpReplay=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerbose=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DShuffleTests=false compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DReproduce=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DReportStdout=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DGCAfter=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DPrintTimes=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerifyIR=false compiler.lib.ir_framework.TestDFlags\n+ *\/\n+\n+public class TestDFlags {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    public int c1() {\n+        return 34;\n+    }\n+\n+\n+    @Test\n+    public void c2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_3() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDFlags.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test -DIgnoreCompilerControls property flag.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestDIgnoreCompilerControls\n+ *\/\n+\n+public class TestDIgnoreCompilerControls {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            TestFramework.run();\n+        } else {\n+            OutputAnalyzer oa = run(\"true\");\n+            oa.shouldHaveExitValue(0);\n+            oa = run(\"false\");\n+            oa.shouldNotHaveExitValue(0);\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail run\"), \"did not find run: \" + oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail check\"), \"did not find check\" + oa.getOutput());\n+        }\n+    }\n+\n+    private static OutputAnalyzer run(String flagValue) throws Exception {\n+        OutputAnalyzer oa;\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                \"-Dtest.class.path=\" + Utils.TEST_CLASS_PATH, \"-Dtest.jdk=\" + Utils.TEST_JDK,\n+                \"-Dtest.vm.opts=-DIgnoreCompilerControls=\" + flagValue,\n+                \"compiler.lib.ir_framework.TestDIgnoreCompilerControls\", flagValue);\n+        oa = ProcessTools.executeProcess(process);\n+        return oa;\n+    }\n+\n+    @Test\n+    public void test() { }\n+\n+    @Run(test = \"test\")\n+    @Warmup(10000)\n+    public void run(RunInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"run\", RunInfo.class)), \"fail run\");\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    public void test2() {}\n+\n+\n+    @Check(test = \"test2\")\n+    public void check(TestInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"check\", TestInfo.class)), \"fail check\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDIgnoreCompilerControls.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test -DScenarios property flag. Run with othervm which should not be done when writing tests using the framework.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DScenarios=1,5,10 compiler.lib.ir_framework.TestDScenarios test\n+ * @run main\/othervm -DScenarios=1,4 compiler.lib.ir_framework.TestDScenarios test\n+ * @run main\/othervm -DScenarios=3,4,9 compiler.lib.ir_framework.TestDScenarios test\n+ * @run driver compiler.lib.ir_framework.TestDScenarios test2\n+ * @run driver compiler.lib.ir_framework.TestDScenarios\n+ *\/\n+\n+public class TestDScenarios {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            switch (args[0]) {\n+                case \"test\" -> {\n+                    Scenario s1 = new Scenario(1);\n+                    Scenario s2 = new Scenario(5);\n+                    Scenario s3 = new Scenario(10);\n+                    Scenario bad = new Scenario(0, \"-Flagdoesnotexist\"); \/\/ not executed\n+                    new TestFramework().addScenarios(bad, s1, s2, s3).start();\n+                }\n+                case \"test2\" -> {\n+                    try {\n+                        TestFramework.run(DScenariosBad.class);\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (TestVMException e) {\n+                        System.out.println(e.getExceptionInfo());\n+                        Asserts.assertTrue(e.getExceptionInfo().contains(\"Expected DScenariosBad exception\"));\n+                    }\n+                }\n+                default -> {\n+                    \/\/ Invalid -DScenarios set and thus exception thrown when Scenario class is statically initialized.\n+                    Scenario s = new Scenario(3);\n+                    throw new RuntimeException(\"should not reach\");\n+                }\n+            }\n+        } else {\n+            \/\/ Test invalid -DScenario flag.\n+            OutputAnalyzer oa;\n+            ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                    \"-Dtest.jdk=\" + Utils.TEST_JDK, \"-DScenarios=a,1,b,10\",\n+                    \"compiler.lib.ir_framework.TestDScenarios\", \" test3\");\n+            oa = ProcessTools.executeProcess(process);\n+            oa.shouldNotHaveExitValue(0);\n+            System.out.println(oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"TestRunException: Provided a scenario index\"));\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+    }\n+}\n+\n+class DScenariosBad {\n+    @Test\n+    public void test() {\n+        throw new RuntimeException(\"Expected DScenariosBad exception\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDScenarios.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test -DTest and -DExclude property flag.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestDTestAndExclude\n+ *\/\n+\n+public class TestDTestAndExclude {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            run(\"good1,good2\", \"\", \"good\");\n+            run(\"good1,good2\", \"bad1\", \"good\");\n+            run(\"good1,bad1\", \"bad1\", \"good\");\n+            run(\"good1,bad1\", \"bad1,good\", \"good\");\n+            run(\"good3,bad2\", \"bad1,bad2\", \"good\");\n+            run(\"goodMulti1,goodMulti2\", \"\", \"good\");\n+            run(\"bad1,good1\", \"\", \"bad1\");\n+            run(\"bad1,good1\", \"good1\", \"bad1\");\n+            run(\"bad1,good1\", \"asdf\", \"bad1\");\n+            run(\"bad2,good1\", \"\", \"runBadSingle\");\n+            run(\"bad2\", \"runBadSingle\", \"runBadSingle\");\n+            run(\"badMulti1,badMulti2\", \"\", \"runBadMulti\");\n+            run(\"badMulti1\", \"\", \"runBadMulti\");\n+            run(\"badMulti1\", \"badMulti2\", \"runBadMulti\");\n+            run(\"badMulti2\", \"badMulti1\", \"runBadMulti\");\n+            run(\"runBadSingle\", \"\", \"empty\");\n+            run(\"runBadMulti\", \"\", \"empty\");\n+            run(\"asdf\", \"\", \"empty\");\n+            run(\"\", \"good1,good2,good3,bad1,bad2,goodMulti1,goodMulti2,badMulti1,badMulti2\", \"empty\");\n+            run(\"asdf\", \"good1,good2,good3,bad1,bad2,goodMulti1,goodMulti2,badMulti1,badMulti2\", \"empty\");\n+            run(\"bad1\", \"bad1\", \"empty\");\n+            run(\"good1\", \"asdf,good,good1\", \"empty\");\n+        } else {\n+            switch (args[0]) {\n+                case \"good\" -> TestFramework.run();\n+                case \"bad1\", \"runBadMulti\", \"runBadSingle\" -> {\n+                    try {\n+                        TestFramework.run();\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (TestVMException e) {\n+                        Asserts.assertTrue(e.getExceptionInfo().contains(\"expected \" + args[0] + \" exception\"));\n+                    }\n+                }\n+                case \"empty\" -> {\n+                    try {\n+                        TestFramework.run();\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (NoTestsRunException e) {\n+                        \/\/ Expected\n+                    }\n+                }\n+                default -> throw new RuntimeException(\"should not reach\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create a VM and simulate as if it was a driver VM spawned by JTreg that has -DTest\/DExclude set as VM or Javaopts\n+     *\/\n+    protected static void run(String dTest, String dExclude, String arg) throws Exception {\n+        System.out.println(\"Run -DTest=\" + dTest + \" -DExclude=\" + dExclude + \" arg=\" + arg);\n+        OutputAnalyzer oa;\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                \"-Dtest.class.path=\" + Utils.TEST_CLASS_PATH, \"-Dtest.jdk=\" + Utils.TEST_JDK,\n+                \"-Dtest.vm.opts=-DTest=\" + dTest + \" -DExclude=\" + dExclude,\n+                \"compiler.lib.ir_framework.TestDTestAndExclude\", arg);\n+        oa = ProcessTools.executeProcess(process);\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    @Test\n+    public void good1() { }\n+\n+    @Test\n+    public void good2() { }\n+\n+    @Check(test = \"good2\")\n+    public void check2() {}\n+\n+    @Test\n+    public void bad1() {\n+        throw new RuntimeException(\"expected bad1 exception\");\n+    }\n+\n+    @Test\n+    public void good3() {}\n+\n+    @Test\n+    public void goodMulti1() {}\n+\n+    @Test\n+    public void goodMulti2() {}\n+\n+    @Run(test = \"good3\")\n+    public void runGoodSingle() {\n+        good3();\n+    }\n+\n+    @Run(test = {\"goodMulti1\", \"goodMulti2\"})\n+    public void runGoodMulti() {\n+        goodMulti1();\n+        goodMulti2();\n+    }\n+\n+    @Test\n+    public void bad2() {\n+    }\n+\n+    @Test\n+    public void badMulti1() {\n+    }\n+\n+    @Test\n+    public void badMulti2() {\n+    }\n+\n+    @Run(test = \"bad2\")\n+    public void runBadSingle() {\n+        throw new RuntimeException(\"expected runBadSingle exception\");\n+    }\n+\n+    @Run(test = {\"badMulti1\", \"badMulti2\"})\n+    public void runBadMulti() {\n+        throw new RuntimeException(\"expected runBadMulti exception\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDTestAndExclude.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,1627 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import jdk.test.lib.Asserts;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test IR matcher with different default IR node regexes. Use -DPrintIREncoding.\n+ *          Normally, the framework should be called with driver.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DPrintIREncoding=true compiler.lib.ir_framework.TestIRMatching\n+ *\/\n+\n+public class TestIRMatching {\n+\n+    public static void main(String[] args) {\n+        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test1(int)\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\");\n+        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test2()\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:-UsePerfData\", \"-XX:+UseTLAB\");\n+\n+        runWithArguments(AndOr1.class, \"-XX:TLABRefillWasteFraction=52\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\");\n+        runWithArguments(CountComparisons.class, \"-XX:TLABRefillWasteFraction=50\");\n+        runWithArguments(GoodCount.class, \"-XX:TLABRefillWasteFraction=50\");\n+        runWithArguments(MultipleFailOnGood.class, \"-XX:TLABRefillWasteFraction=50\");\n+\n+        String[] allocMatches = { \"MyClass\", \"call,static  wrapper for: _new_instance_Java\" };\n+        runCheck(BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1, 1, \"Store\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1,  3, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1,  2, 4),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail2()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail2()\", 1,  2, \"CallStaticJava\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail3()\", 1,  2, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail3()\", 1,  1, 3),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail4()\", 1,  1, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail4()\", 1,  2, 3),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail5()\", 1,  1, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail5()\", 1,  2, 3),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  2, allocMatches),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  3, \"CallStaticJava\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail7()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail7()\", 1,  2, allocMatches),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail8()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail8()\", 1,  2, allocMatches),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail9()\", 1,  1, \"Store\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail9()\", 1,  2, \"CallStaticJava\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail10()\", 1,  1, \"Store\", \"iFld\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail10()\", 1,  2, 3)\n+        );\n+\n+        runCheck(BadCountsConstraint.create(BadCount.class, \"bad1()\", 1, 1, \"Load\"),\n+                 GoodCountsConstraint.create(BadCount.class, \"bad1()\", 2),\n+                 GoodCountsConstraint.create(BadCount.class, \"bad2()\", 1),\n+                 BadCountsConstraint.create(BadCount.class, \"bad2()\", 2,  1, \"Store\"),\n+                 BadCountsConstraint.create(BadCount.class, \"bad3()\", 1,  1, \"Load\"),\n+                 BadCountsConstraint.create(BadCount.class, \"bad3()\", 2,  1, \"Store\")\n+        );\n+\n+        String[] allocArrayMatches = { \"MyClass\", \"call,static  wrapper for: _new_array_Java\"};\n+        runCheck(BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 1, allocArrayMatches),\n+                 BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 2,  allocArrayMatches),\n+                 GoodFailOnConstraint.create(AllocArray.class, \"allocArray()\", 3),\n+                 GoodFailOnConstraint.create(AllocArray.class, \"allocArray()\", 4),\n+                 BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 5,  allocArrayMatches)\n+        );\n+\n+        runCheck(GoodRuleConstraint.create(RunTests.class, \"good1()\", 1),\n+                 GoodRuleConstraint.create(RunTests.class, \"good1()\", 2),\n+                 GoodRuleConstraint.create(RunTests.class, \"good2()\", 1),\n+                 GoodRuleConstraint.create(RunTests.class, \"good2()\", 2),\n+                 GoodRuleConstraint.create(RunTests.class, \"good3(int)\", 1),\n+                 BadCountsConstraint.create(RunTests.class, \"bad1(int)\", 1, 0),\n+                 BadFailOnConstraint.create(RunTests.class, \"bad1(int)\", 2, \"Load\")\n+        );\n+\n+        runCheck(new String[] {\"-XX:-UseCompressedClassPointers\"},\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 3, \"LoadI\"),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 1, 1, 0),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 1, 2, 1,\"Load\"),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 2),\n+                 GoodFailOnConstraint.create(Loads.class, \"load()\", 3),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 3, 2, 2,\"Store\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 4, 2, \"Store\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 5, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 6, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 7, \"Load\"),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 8),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 9),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 10),\n+                 BadFailOnConstraint.create(Loads.class, \"loadKlass()\", 1),\n+                 BadCountsConstraint.create(Loads.class, \"loadKlass()\", 2, 2,\"Field\")\n+                 );\n+\n+        \/\/ Loops\n+        runCheck(BadFailOnConstraint.create(Loops.class, \"loop()\", 1, \"Loop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"loop()\", 2),\n+                 GoodRuleConstraint.create(Loops.class, \"loop()\", 3),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoop()\", 1),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoop()\", 2, \"CountedLoop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoop()\", 3),\n+                 BadFailOnConstraint.create(Loops.class, \"loopAndCountedLoop()\", 1, \"Loop\"),\n+                 BadFailOnConstraint.create(Loops.class, \"loopAndCountedLoop()\", 2, \"CountedLoop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"loopAndCountedLoop()\", 3),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopMain()\", 1),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoopMain()\", 2, \"CountedLoop\"),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoopMain()\", 3, \"CountedLoop\", \"main\"),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 1),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 2),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 3)\n+        );\n+\n+        \/\/ Traps\n+        runCheck(GoodRuleConstraint.create(Traps.class, \"noTraps()\", 1),\n+                 BadFailOnConstraint.create(Traps.class, \"noTraps()\", 2, \"Store\", \"iFld\"),\n+                 GoodRuleConstraint.create(Traps.class, \"noTraps()\", 3),\n+                 BadFailOnConstraint.create(Traps.class, \"predicateTrap()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"predicateTrap()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"predicate\"),\n+                 GoodRuleConstraint.create(Traps.class, \"predicateTrap()\", 3),\n+                 GoodRuleConstraint.create(Traps.class, \"predicateTrap()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 3, \"uncommon_trap\", \"unstable_if\"),\n+                 GoodRuleConstraint.create(Traps.class, \"nullCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"null_assert\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"nullAssert()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"unstableIf(boolean)\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"unstableIf(boolean)\",  2, \"CallStaticJava\", \"uncommon_trap\", \"unstable_if\"),\n+                 GoodRuleConstraint.create(Traps.class, \"unstableIf(boolean)\", 3),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"class_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"classCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"range_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"rangeCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"intrinsic_or_type_checked_inlining\"),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 4)\n+        );\n+\n+\n+        runCheck(new String[] {\"-XX:+BailoutToInterpreterForThrows\"},\n+                 BadFailOnConstraint.create(UnhandledTrap.class, \"unhandled()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(UnhandledTrap.class, \"unhandled()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"unhandled\"),\n+                 GoodRuleConstraint.create(UnhandledTrap.class, \"unhandled()\", 3)\n+        );\n+\n+        runCheck(BadFailOnConstraint.create(ScopeObj.class, \"scopeObject()\", 1, \"ScObj\"));\n+        runCheck(BadFailOnConstraint.create(Membar.class, \"membar()\", 1, \"MemBar\"));\n+        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 1, \"cmp\", \"precise klass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 1,\"cmp\", \"precise klass\", \"MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,\"cmp\", \"precise klass\", \"ir_framework\/MyClass\"),\n+                 GoodFailOnConstraint.create(CheckCastArray.class, \"array()\", 3),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"arrayCopy(java.lang.Object[],java.lang.Class)\", 1, \"checkcast_arraycopy\")\n+        );\n+\n+        \/\/ Redirect stdout to stream and then check if we find required IR encoding read from socket.\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        PrintStream old = System.out;\n+        System.setOut(ps);\n+\n+        try {\n+            runWithArguments(CompilationOutputOfFails.class);\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            System.out.flush();\n+            String output = baos.toString();\n+            baos.reset();\n+            Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n+            Matcher matcher = pattern.matcher(output);\n+            Asserts.assertEQ(matcher.results().count(), (long)7, \"Could not find all both methods: \" + output);\n+            pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+            matcher = pattern.matcher(output);\n+            int count = 0;\n+            while (matcher.find()) {\n+                String match = matcher.group();\n+                Asserts.assertFalse(match.contains(\"PrintOptoAssembly\"), \"Cannot contain opto assembly: \" + output);\n+                count++;\n+            }\n+            Asserts.assertEQ(count, 7, \"Could not find all ideal methods: \" + output);\n+            pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+            matcher = pattern.matcher(output);\n+            count = 0;\n+            while (matcher.find()) {\n+                String match = matcher.group();\n+                Asserts.assertFalse(match.contains(\"PrintIdeal\"), \"Cannot contain opto assembly: \" + output);\n+                count++;\n+            }\n+            Asserts.assertEQ(count, 7, \"Could not find all opto methods\");\n+        }\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=50\");\n+        System.out.flush();\n+        String output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 0, 21);\n+        findIrIds(output, \"testMatchNoneIf50\", -1, -1);\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=49\");\n+        System.out.flush();\n+        output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 4, 6, 13, 18);\n+        findIrIds(output, \"testMatchNoneIf50\", 0, 3, 8, 10, 17, 22);\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=51\");\n+        System.out.flush();\n+        output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 7, 12, 19, 21);\n+        findIrIds(output, \"testMatchNoneIf50\", 4, 7, 11, 16, 20, 22);\n+        System.setOut(old);\n+    }\n+\n+    private static void runWithArguments(Class<?> clazz, String... args) {\n+        new TestFramework(clazz).addFlags(args).start();\n+    }\n+\n+    private static void runCheck(String[] args , Constraint... constraints) {\n+        try {\n+            new TestFramework(constraints[0].getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            checkConstraints(e, constraints);\n+        }\n+    }\n+\n+    private static void runCheck(Constraint... constraints) {\n+        try {\n+            TestFramework.run(constraints[0].getKlass()); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            checkConstraints(e, constraints);\n+        }\n+    }\n+\n+    private static void checkConstraints(IRViolationException e, Constraint[] constraints) {\n+        String message = e.getExceptionInfo();\n+        try {\n+            for (Constraint constraint : constraints) {\n+                constraint.checkConstraint(e);\n+            }\n+        } catch (Exception e1) {\n+            System.out.println(TestFramework.getLastTestVMOutput());\n+            System.out.println(message);\n+            throw e1;\n+        }\n+    }\n+\n+    \/\/ Single constraint\n+    private static void runFailOnTestsArgs(Constraint constraint, String... args) {\n+        try {\n+            new TestFramework(constraint.getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            constraint.checkConstraint(e);\n+        }\n+    }\n+\n+    public static void shouldNotReach() {\n+        throw new ShouldNotReachException(\"Framework did not fail but it should have!\");\n+    }\n+\n+    public static void findIrIds(String output, String method, int... numbers) {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(method);\n+        for (int i = 0; i < numbers.length; i+=2) {\n+            int start = numbers[i];\n+            int endIncluded = numbers[i + 1];\n+            for (int j = start; j <= endIncluded; j++) {\n+                builder.append(\",\");\n+                builder.append(j);\n+            }\n+        }\n+        Asserts.assertTrue(output.contains(builder.toString()), \"Could not find encoding: \\\"\" + builder.toString()\n+                                                                + System.lineSeparator());\n+    }\n+}\n+\n+class AndOr1 {\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @IR(applyIfAnd = {\"UsePerfData\", \"true\", \"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"}, failOn = {IRNode.CALL})\n+    public void test1(int i) {\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UsePerfData\", \"false\", \"TLABRefillWasteFraction\", \"51\", \"UseTLAB\", \"false\"}, failOn = {IRNode.CALL})\n+    public void test2() {\n+        dontInline();\n+    }\n+\n+    @DontInline\n+    private void dontInline() {\n+    }\n+}\n+\n+class MultipleFailOnGood {\n+    private int iFld;\n+    private MyClassSub myClassSub = new MyClassSub();\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"50\"}, failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(applyIfOr = {\"TLABRefillWasteFraction\", \"99\", \"TLABRefillWasteFraction\", \"100\"}, failOn = {IRNode.LOOP, IRNode.CALL}) \/\/ Not applied\n+    public void good1() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"20\"}, failOn = {IRNode.ALLOC})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"< 100\"}, failOn = {IRNode.ALLOC_OF, \"Test\"})\n+    public void good2() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"Test\", IRNode.CALL})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"20\"}, failOn = {IRNode.ALLOC})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"< 100\"}, failOn = {IRNode.ALLOC_OF, \"Test\"})\n+    public void good3() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CALL, IRNode.STORE_OF_CLASS, \"UnknownClass\"})\n+    public void good4() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"xFld\", IRNode.CALL})\n+    public void good5() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClass\"}) \/\/ Needs exact match to fail\n+    public void good6() {\n+        myClassSub.iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClassSub\"}) \/\/ Static write is with Class and not MySubClass\n+    public void good7() {\n+        MyClassSub.iFldStatic = 42;\n+    }\n+\n+    @ForceInline\n+    private void forceInline() {}\n+}\n+\n+class MultipleFailOnBad {\n+    private int iFld;\n+    private int myInt;\n+    private MyClass myClass;\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL, IRNode.STORE_I, IRNode.LOOP})\n+    public void fail1() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    public void fail2() {\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CALL, IRNode.STORE_OF_CLASS, \"MultipleFailOnBad\", IRNode.ALLOC})\n+    public void fail3() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/MultipleFailOnBad\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail4() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail5() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClass\", IRNode.ALLOC, IRNode.CALL})\n+    public void fail6() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"MyClass\"})\n+    public void fail7() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"compiler\/lib\/ir_framework\/MyClassSub\"})\n+    public void fail8() {\n+        myClass = new MyClassSub();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    public void fail9() {\n+        iFld = 42;\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail10() {\n+        myInt = 34;\n+        iFld = 42;\n+    }\n+\n+    @DontInline\n+    private void dontInline() {}\n+}\n+\n+\/\/ Called with -XX:TLABRefillWasteFraction=X.\n+class FlagComparisons {\n+    \/\/ Applies all IR rules if TLABRefillWasteFraction=50\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =   50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <=  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 7\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >=  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"> 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 13\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"< 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 21\n+    public void testMatchAllIf50() {}\n+\n+    \/\/ Applies no IR rules if TLABRefillWasteFraction=50\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 8\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <=  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 11\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >=  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"> 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 17\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"< 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 22\n+    public void testMatchNoneIf50() {}\n+}\n+\n+class CountComparisons {\n+    int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"= 1\",\n+                  IRNode.STORE, \"=1\",\n+                  IRNode.STORE, \" = 1\",\n+                  IRNode.STORE, \"  =  1\",\n+                  IRNode.STORE, \">= 1\",\n+                  IRNode.STORE, \">=1\",\n+                  IRNode.STORE, \" >= 1\",\n+                  IRNode.STORE, \"  >=  1\",\n+                  IRNode.STORE, \"<= 1\",\n+                  IRNode.STORE, \"<=1\",\n+                  IRNode.STORE, \" <= 1\",\n+                  IRNode.STORE, \"  <=  1\",\n+                  IRNode.STORE, \"!= 0\",\n+                  IRNode.STORE, \"!=0\",\n+                  IRNode.STORE, \" != 0\",\n+                  IRNode.STORE, \"  !=  0\",\n+                  IRNode.STORE, \"> 0\",\n+                  IRNode.STORE, \">0\",\n+                  IRNode.STORE, \" > 0\",\n+                  IRNode.STORE, \"  >  0\",\n+                  IRNode.STORE, \"< 2\",\n+                  IRNode.STORE, \"<2\",\n+                  IRNode.STORE, \" < 2\",\n+                  IRNode.STORE, \"  <  2\",\n+    })\n+    public void countComparison() {\n+        iFld = 3;\n+    }\n+}\n+\n+class GoodCount {\n+    boolean flag;\n+    char cFld;\n+    byte bFld;\n+    short sFld;\n+    int iFld;\n+    long lFld;\n+    float fFld;\n+    double dFld;\n+    long x;\n+\n+    long result;\n+    MyClass myClass = new MyClass();\n+    MyClass myClassSubPoly = new MyClassSub();\n+    MyClassSub myClassSub = new MyClassSub();\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\", IRNode.STORE_I, \"1\"},\n+        failOn = {IRNode.STORE_B, IRNode.STORE_C, IRNode.STORE_D,\n+                  IRNode.STORE_F, IRNode.STORE_L})\n+    public void good1() {\n+        iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\",\n+                  IRNode.STORE_B, \"2\", \/\/ bFld + flag\n+                  IRNode.STORE_C, \"2\", \/\/ cFld + sFld\n+                  IRNode.STORE_I, \"1\",\n+                  IRNode.STORE_L, \"1\",\n+                  IRNode.STORE_F, \"1\",\n+                  IRNode.STORE_D, \"1\"})\n+    public void good2() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.STORE_B, \"2\", IRNode.STORE_B_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_C, \"2\", IRNode.STORE_C_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_I, \"1\", IRNode.STORE_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_L, \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_F, \"1\", IRNode.STORE_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_D, \"1\", IRNode.STORE_D_OF_CLASS, \"GoodCount\", \"1\"})\n+    public void good3() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.STORE_B, \"2\", IRNode.STORE_B_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_C, \"2\", IRNode.STORE_C_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_I, \"1\", IRNode.STORE_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_L, \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_F, \"1\", IRNode.STORE_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_D, \"1\", IRNode.STORE_D_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_FIELD, \"lFld\", \"1\"})\n+    public void good4() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"2\", IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\",\n+                  IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/MyClass\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"compiler\/lib\/ir_framework\/MyClass\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/GoodCount\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"compiler\/lib\/ir_framework\/GoodCount\", \"1\",\n+                  IRNode.STORE_OF_FIELD, \"x\", \"2\"})\n+    public void good5() {\n+        x = 3; \/\/ long\n+        myClass.x = 4; \/\/ int\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"myClass\", \"1\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"\/GoodCount\", \"1\", IRNode.STORE_OF_CLASS, \"MyClass\", \"0\"},\n+        failOn = {IRNode.STORE_OF_CLASS, \"MyClass\"})\n+    public void good6() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"3\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"0\",\n+                  IRNode.STORE_OF_CLASS, \"MyClass\", \"2\", IRNode.STORE_OF_CLASS, \"MyClassSub\", \"1\",\n+                  IRNode.STORE, \"3\"},\n+        failOn = {IRNode.STORE_OF_CLASS, \"GoodCount\"})\n+    public void good7() {\n+        myClass.iFld = 1;\n+        myClassSubPoly.iFld = 2;\n+        myClassSub.iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\", IRNode.STORE, \"1\"})\n+    public void good8() {\n+        result = iFld;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"4\", IRNode.STORE, \"1\", IRNode.LOAD_OF_FIELD, \"iFld\", \"2\", IRNode.LOAD_OF_FIELD, \"iFld2\", \"0\",\n+                  IRNode.LOAD_OF_FIELD, \"lFldStatic\", \"1\", IRNode.LOAD_OF_CLASS, \"GoodCount\", \"2\", IRNode.LOAD_OF_CLASS, \"MyClass\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\", IRNode.STORE_OF_FIELD, \"result\", \"1\",\n+                  IRNode.LOAD_OF_FIELD, \"myClass\", \"1\"})\n+    public void good9() {\n+        result = iFld + MyClass.lFldStatic + myClass.iFld; \/\/ 1 + 1 + 2 loads (myClass is LoadN of GoodCount and myClass.iFld a LoadI of MyClass)\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"8\",\n+                  IRNode.LOAD_B, \"1\",\n+                  IRNode.LOAD_UB, \"1\",\n+                  IRNode.LOAD_S, \"1\",\n+                  IRNode.LOAD_US, \"1\",\n+                  IRNode.LOAD_I, \"1\",\n+                  IRNode.LOAD_L, \"1\",\n+                  IRNode.LOAD_F, \"1\",\n+                  IRNode.LOAD_D, \"1\"})\n+    public void good10() {\n+        bFld++;\n+        cFld++;\n+        sFld++;\n+        iFld++;\n+        lFld++;\n+        fFld++;\n+        dFld++;\n+        flag = !flag;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"8\", IRNode.LOAD_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.LOAD_B, \"1\", IRNode.LOAD_B_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_UB, \"1\", IRNode.LOAD_UB_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_S, \"1\", IRNode.LOAD_S_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_US, \"1\", IRNode.LOAD_US_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_I, \"1\", IRNode.LOAD_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_L, \"1\", IRNode.LOAD_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_F, \"1\", IRNode.LOAD_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_D, \"1\", IRNode.LOAD_D_OF_CLASS, \"GoodCount\", \"1\"})\n+    public void good11() {\n+        bFld++;\n+        cFld++;\n+        sFld++;\n+        iFld++;\n+        lFld++;\n+        fFld++;\n+        dFld++;\n+        flag = !flag;\n+    }\n+}\n+\n+class BadCount {\n+    int iFld;\n+    int result;\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"!= 1\"})\n+    @IR(counts = {IRNode.STORE, \"> 0\"})\n+    public void bad1() {\n+        result = iFld;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(counts = {IRNode.STORE, \"< 1\"})\n+    public void bad2() {\n+        result = iFld;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"0\"})\n+    @IR(counts = {IRNode.STORE, \" <= 0\"})\n+    public void bad3() {\n+        result = iFld;\n+    }\n+}\n+\n+\n+class RunTests {\n+    public int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public void good1() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(failOn = IRNode.STORE)\n+    public int good2() {\n+        return iFld;\n+    }\n+\n+    @Run(test = {\"good1\", \"good2\"})\n+    public void runGood1() {\n+        good1();\n+        good2();\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public void good3(int x) {\n+        iFld = x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public int bad1(int x) {\n+        return iFld + x;\n+    }\n+\n+    @Run(test = {\"bad1\", \"good3\"})\n+    public void run() {\n+        bad1(2);\n+        good3(4);\n+    }\n+}\n+\n+\n+class AllocArray {\n+    MyClass[] myClassArray;\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_ARRAY})\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"MyClass\"})\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"MyClasss\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"compiler\/lib\/ir_framework\/MySubClass\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"compiler\/lib\/ir_framework\/MyClass\"})\n+    public void allocArray() {\n+        myClassArray = new MyClass[2];\n+    }\n+}\n+\n+class Loads {\n+    int iFld = 34;\n+    int result = 0;\n+    Object myClass = new MyClass();\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.LOOP, IRNode.LOAD_I}, counts = {IRNode.LOOP, \"2\", IRNode.LOAD, \"2\", IRNode.STORE, \"2\"})\n+    @IR(failOn = {IRNode.LOOP, IRNode.LOOP}, counts = {IRNode.LOOP, \"0\", IRNode.LOAD, \"1\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.LOOP, IRNode.LOOP}, counts = {IRNode.LOOP, \"0\", IRNode.STORE, \"1\"})\n+    @IR(failOn = {IRNode.LOOP, IRNode.STORE}, counts = {IRNode.LOOP, \"0\", IRNode.LOAD, \"1\"})\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"compiler\/lib\/ir_framework\/Loads\"})\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"Loads\"})\n+    @IR(failOn = {IRNode.LOAD_OF_FIELD, \"iFld\"})\n+    @IR(failOn = {IRNode.LOAD_OF_FIELD, \"iFld2\", IRNode.LOAD_OF_CLASS, \"Load\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.LOAD_KLASS}) \/\/ Does not fail\n+    @IR(counts = {IRNode.FIELD_ACCESS, \"3\"}) \/\/ Does not fail\n+    public void load() {\n+        result = iFld;\n+        iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_KLASS})\n+    @IR(counts = {IRNode.FIELD_ACCESS, \"3\"})\n+    public void loadKlass() {\n+        if (myClass instanceof MyClass) {\n+            result = 3;\n+        }\n+    }\n+}\n+\n+class Loops {\n+    int limit = 1024;\n+    int[] iArr = new int[100];\n+\n+    @DontInline\n+    public void dontInline() {}\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void loop() {\n+        for (int i = 0; i < limit; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void countedLoop() {\n+        for (int i = 0; i < 2000; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void loopAndCountedLoop() {\n+        for (int i = 0; i < 2000; i++) {\n+            for (int j = 0; j < limit; j++) {\n+                dontInline();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN) \/\/ fails\n+    public void countedLoopMain() {\n+        \/\/ Cannot unroll completely -> create pre\/main\/post\n+        for (int i = 0; i < 100; i++) {\n+            iArr[i] = i;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void countedLoopUnrolled() {\n+        \/\/ Completely unrolled -> no pre\/main\/post\n+        for (int i = 0; i < 8; i++) {\n+            iArr[i] = i;\n+        }\n+    }\n+}\n+\n+class Traps {\n+    int number42 = 42;\n+    int iFld = 10;\n+    int[] iArr = new int[2];\n+    MyClass myClass = new MyClass();\n+    MyClassSub myClassSub = new MyClassSub();\n+    NotLoaded notLoaded = new NotLoaded();\n+    Object[] oArr = new Object[10];\n+    MyClass[] mArr = new MyClass[10];\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP)\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"}) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void noTraps() {\n+        for (int i = 0; i < 100; i++) {\n+            if (i < 42) {\n+                \/\/ Reached, no uncommon trap\n+                iFld = i;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.PREDICATE_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"})\n+    @IR(failOn = {IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void predicateTrap() {\n+        for (int i = 0; i < 100; i++) {\n+            if (number42 != 42) {\n+                \/\/ Never reached\n+                iFld = i;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNSTABLE_IF_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void nullCheck() {\n+        if (myClass instanceof MyClassSub) {\n+            iFld = 4;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_ASSERT_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public Object nullAssert() {\n+        return notLoaded.notLoadedFld;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNSTABLE_IF_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void unstableIf(boolean flag) {\n+        if (flag) {\n+            iFld++;\n+        } else {\n+            iFld--;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.CLASS_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void classCheck() {\n+        try {\n+            myClassSub = (MyClassSub) myClass;\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.RANGE_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void rangeCheck() {\n+        iArr[1] = 3;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void instrinsicOrTypeCheckedInlining() {\n+        System.arraycopy(oArr, 0, mArr, 0, 8);\n+    }\n+}\n+\n+class UnhandledTrap {\n+    int iFld = 34;\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNHANDLED_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP})\n+    public void unhandled() {\n+        try {\n+            throw new RuntimeException();\n+        } catch (RuntimeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n+\n+class ScopeObj {\n+\n+    @DontInline\n+    public void dontInline(int i) {}\n+\n+    @Test\n+    @IR(failOn = IRNode.SCOPE_OBJECT) \/\/ fails\n+    public int scopeObject() {\n+        MyClass myClass = new MyClass();\n+        for (int i = 0; i < 100; i++) {\n+            dontInline(myClass.iFld);\n+        }\n+        return 3;\n+    }\n+}\n+\n+class Membar {\n+    volatile MyClass myClass;\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR) \/\/ fails\n+    public int membar() {\n+        myClass = new MyClass();\n+        return myClass.x;\n+    }\n+}\n+\n+class CheckCastArray {\n+    Object[] oArr = new Object[10];\n+    MyClass[] mArr = new MyClass[10];\n+\n+    @Test\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY) \/\/ fails\n+    @IR(failOn = {IRNode.CHECKCAST_ARRAY_OF, \"MyClass\", \/\/ fails\n+                  IRNode.CHECKCAST_ARRAY_OF, \"ir_framework\/MyClass\"}) \/\/ fails\n+    @IR(failOn = {IRNode.CHECKCAST_ARRAY_OF, \"MyClasss\", IRNode.CHECKCAST_ARRAY_OF, \"Object\"})\n+    public boolean array() {\n+        return oArr instanceof MyClass[];\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CHECKCAST_ARRAYCOPY) \/\/ fails\n+    public Object[] arrayCopy(Object[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @Run(test = \"arrayCopy\")\n+    public void testArrayCopy() {\n+        arrayCopy(mArr, MyClass[].class);\n+        arrayCopy(mArr, Object[].class);\n+        arrayCopy(mArr, MyClass2[].class);\n+    }\n+}\n+\n+class CompilationOutputOfFails {\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\")\n+    public void both1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP + \"|\" + \"call\")\n+    public void both2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = \"call\")\n+    public void both3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\", \"0\"})\n+    public void both4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP + \"|\" + \"call\", \"1\"})\n+    public void both5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"0\"})\n+    @IR(counts = {\"call\", \"1\"})\n+    public void both6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(counts = {\"call\", \"1\"})\n+    public void both7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    public void ideal1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.ALLOC) \/\/ not fail\n+    public void ideal2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(counts = {IRNode.ALLOC, \"0\"}) \/\/ not fail\n+    public void ideal3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ALLOC) \/\/ not fail\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC, \"0\"}) \/\/ not fail\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"5\"})\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    public void opto1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    public void opto2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"1\"}) \/\/ not fail\n+    public void opto3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"0\"}) \/\/ not fail\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"call\", \"10\"})\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @DontInline\n+    private void dontInline() {}\n+}\n+\n+\n+\/\/ Used only by class Traps\n+class NotLoaded {\n+    NotLoadedHelper notLoadedFld;\n+}\n+\n+\/\/ Used only by class Traps\n+class NotLoadedHelper {}\n+\n+class MyClass {\n+    int iFld = 3;\n+    int x = 5;\n+    static long lFldStatic;\n+}\n+\n+class MyClass2 {}\n+\n+class MyClassSub extends MyClass {\n+    int iFld;\n+    static int iFldStatic;\n+}\n+\n+class ShouldNotReachException extends RuntimeException {\n+    ShouldNotReachException(String s) {\n+        super(s);\n+    }\n+}\n+\n+\n+\/\/ Base class for any kind of constraint that is used to verify if the framework reports the correct IR failures.\n+abstract class Constraint {\n+    private final Class<?> klass;\n+    protected final int ruleIdx;\n+    private final Pattern methodPattern;\n+    private final String classAndMethod;\n+    protected final Pattern irPattern;\n+    private final String methodName;\n+    protected boolean matched;\n+\n+    Constraint(Class<?> klass, String methodName, int ruleIdx, Pattern irPattern) {\n+        this.klass = klass;\n+        classAndMethod = klass.getSimpleName() + \".\" + methodName;\n+        this.ruleIdx = ruleIdx;\n+        this.methodPattern = Pattern.compile(Pattern.quote(classAndMethod));\n+        this.irPattern = irPattern;\n+        this.methodName = methodName;\n+        this.matched = false;\n+    }\n+\n+    \/\/ For good constraints only\n+    Constraint(Class<?> klass, String methodName, int ruleIdx) {\n+        this.klass = klass;\n+        classAndMethod = klass.getSimpleName() + \".\" + methodName;\n+        this.ruleIdx = ruleIdx;\n+        this.methodPattern = Pattern.compile(Pattern.quote(classAndMethod));\n+        this.irPattern = null;\n+        this.methodName = methodName;\n+        this.matched = false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Constraint \" + getClass().getSimpleName() + \", method: \" + methodName + \", rule: \" + ruleIdx;\n+    }\n+\n+    public Class<?> getKlass() {\n+        return klass;\n+    }\n+\n+    protected String errorPrefix() {\n+        return \"Method \" + methodName + \", Rule \" + ruleIdx;\n+    }\n+\n+    public void checkConstraint(IRViolationException e) {\n+        String message = e.getExceptionInfo();\n+        String[] splitMethods = message.split(\"Method\");\n+        for (int i = 1; i < splitMethods.length; i++) {\n+            String method = splitMethods[i];\n+            if (methodPattern.matcher(method).find()) {\n+                String[] splitIrRules = method.split(\"@IR \");\n+                for (int j = 1; j < splitIrRules.length; j++) {\n+                    String irRule = splitIrRules[j];\n+                    if (irRule.startsWith(\"rule \" + ruleIdx)) {\n+                        checkIRRule(irRule);\n+                    }\n+                }\n+            }\n+        }\n+        Asserts.assertTrue(matched, toString() + \" should have been matched\");\n+    }\n+\n+    abstract protected void checkIRRule(String irRule);\n+\n+    protected void checkOnMethod(String method) {}\n+}\n+\n+\/\/ Constraint for rule that does not fail.\n+class GoodRuleConstraint extends Constraint {\n+\n+    GoodRuleConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+        matched = true;\n+    }\n+\n+    public static GoodRuleConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodRuleConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.fail(errorPrefix() + \" should not fail:\" + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail but not with \"failOn\".\n+class GoodFailOnConstraint extends GoodRuleConstraint {\n+\n+    private GoodFailOnConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+    }\n+\n+    public static GoodFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodFailOnConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.assertFalse(irRule.contains(\"- failOn\"), errorPrefix() + \" should not have failed:\" + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail but not with \"counts\".\n+class GoodCountsConstraint extends GoodRuleConstraint {\n+\n+    private GoodCountsConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+    }\n+\n+    public static GoodCountsConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodCountsConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.assertFalse(irRule.contains(\"- counts\"), errorPrefix() + \" should not have failed with counts:\"\n+                                                         + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Base class for all Regex based constraint.\n+abstract class RegexConstraint extends Constraint {\n+    final String category;\n+    final String otherCategory;\n+    final int[] regexIndexes;\n+    final boolean isGood;\n+    final List<String> matches;\n+\n+    RegexConstraint(Class<?> klass, String methodName, String category, boolean isGood, List<String> matches, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, ruleIdx, initIRPattern(category, ruleIdx));\n+        this.category = category;\n+        this.regexIndexes = regexIndexes;\n+        if (category.equals(\"failOn\")) {\n+            this.otherCategory = \"counts\";\n+        } else {\n+            Asserts.assertTrue(category.equals(\"counts\"));\n+            this.otherCategory = \"failOn\";\n+        }\n+        this.isGood = isGood;\n+        this.matches = matches;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String msg = super.toString() + \", \";\n+        if (regexIndexes.length > 1) {\n+            msg += \"regexes: [\" + String.join(\", \", Arrays.stream(regexIndexes).mapToObj(String::valueOf).toArray(String[]::new)) + \"]\";\n+        } else {\n+            msg += \"regex: \" + regexIndexes[0];\n+        }\n+        return msg;\n+    }\n+\n+    @Override\n+    protected String errorPrefix() {\n+        return super.errorPrefix() + \" with \\\"\" + category + \"\\\"\";\n+    }\n+\n+    private static Pattern initIRPattern(String category, int ruleIdx) {\n+        if (category.equals(\"failOn\")) {\n+            return Pattern.compile(\"rule \" + ruleIdx + \":.*\\\\R.*- failOn: Graph contains forbidden nodes.*\\\\R\" +\n+                                   \".*Regex \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n+        } else {\n+            return Pattern.compile(\"rule \" + ruleIdx + \":.*\\\\R.*- counts: Graph contains wrong number of nodes:\\\\R\" +\n+                                   \".*Regex \\\\d+:.*\\\\R.*Expected.*\");\n+        }\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        int categoryIndex = irRule.indexOf(\"- \" + category);\n+        Asserts.assertTrue(categoryIndex != -1, errorPrefix() + \" should have failed\");\n+\n+        int endIndex;\n+        int otherCategoryIndex = irRule.indexOf(\"- \" + otherCategory);\n+        if (otherCategoryIndex == -1 || categoryIndex > otherCategoryIndex) {\n+            endIndex = irRule.length();\n+        } else {\n+            endIndex = otherCategoryIndex;\n+        }\n+        String categoryString = irRule.substring(irRule.indexOf(\"- \" + category), endIndex);\n+        Pattern pattern;\n+        Matcher matcher;\n+        for (int regexIndex : this.regexIndexes) {\n+            pattern = Pattern.compile(\"Regex \" + regexIndex + \":.*\");\n+            matcher = pattern.matcher(categoryString);\n+            if (isGood) {\n+                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Regex \" + regexIndex);\n+                matched = true;\n+            } else {\n+                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Regex \" + regexIndex);\n+                String[] splitRegex = categoryString.split(\"Regex \");\n+                if (matches != null) {\n+                    for (int i = 1; i < splitRegex.length; i++) {\n+                        String regexString = splitRegex[i];\n+                        if (regexString.startsWith(String.valueOf(regexIndex))) {\n+                            Asserts.assertTrue(matches.stream().allMatch(regexString::contains),\n+                                               errorPrefix() + \" could not find all matches at Regex \" + regexIndex);\n+                            matched = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ Base class for all good regex based constraints.\n+abstract class GoodRegexConstraint extends RegexConstraint {\n+\n+    GoodRegexConstraint(Class<?> klass, String methodName, String category, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, category, true, null, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail with \"counts\" or \"failOn\", but the specified regex in \"failOn\" does not fail.\n+class GoodFailOnRegexConstraint extends GoodRegexConstraint {\n+\n+    private GoodFailOnRegexConstraint(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, \"failOn\", ruleIdx, regexIndexes);\n+    }\n+\n+\n+    public static GoodFailOnRegexConstraint create(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        return new GoodFailOnRegexConstraint(klass, methodName, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\n+\/\/ Constraint for rule that might fail with \"counts\" or \"failOn\", but the specified regex in \"counts\" does not fail.\n+class GoodCountsRegexConstraint extends GoodRegexConstraint {\n+\n+    private GoodCountsRegexConstraint(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, \"counts\", ruleIdx, regexIndexes);\n+    }\n+\n+\n+    public static GoodCountsRegexConstraint create(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        return new GoodCountsRegexConstraint(klass, methodName, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\/\/ Constraint for rule that fails with \"failOn\" and the specified regex must also fail.\n+class BadFailOnConstraint extends RegexConstraint {\n+\n+    BadFailOnConstraint(Class<?> klass, String methodName, int ruleIdx, List<String> matches, int... regexIndexes) {\n+        super(klass, methodName, \"failOn\", false, matches, ruleIdx, regexIndexes);\n+    }\n+\n+    public static BadFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx, int regexId, String... matches) {\n+        return new BadFailOnConstraint(klass, methodName, ruleIdx, new ArrayList<>(Arrays.asList(matches)), regexId);\n+    }\n+\n+    public static BadFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx, String... matches) {\n+        return new BadFailOnConstraint(klass, methodName, ruleIdx, new ArrayList<>(Arrays.asList(matches)), 1);\n+    }\n+}\n+\n+\/\/ Constraint for rule that fails with \"counts\" and the specified regex must also fail.\n+class BadCountsConstraint extends RegexConstraint {\n+\n+    BadCountsConstraint(Class<?> klass, String methodName, int ruleIdx, List<String> matches, int... regexIndexes) {\n+        super(klass, methodName, \"counts\", false, matches, ruleIdx, regexIndexes);\n+    }\n+\n+    public static BadCountsConstraint create(Class<?> klass, String methodName, int ruleIdx, int regexId, int foundCount, String... matches) {\n+        List<String> matchesList = getMatchesList(foundCount, matches, Arrays.asList(matches));\n+        return new BadCountsConstraint(klass, methodName, ruleIdx, matchesList, regexId);\n+    }\n+\n+    public static BadCountsConstraint create(Class<?> klass, String methodName, int ruleIdx, int foundCount, String... matches) {\n+        List<String> matchesList = getMatchesList(foundCount, matches, Arrays.asList(matches));\n+        return new BadCountsConstraint(klass, methodName, ruleIdx, matchesList, 1);\n+    }\n+\n+    private static List<String> getMatchesList(int foundCount, String[] matches, List<String> strings) {\n+        List<String> matchesList = new ArrayList<>();\n+        matchesList.add(\"but found \" + foundCount);\n+        if (matches != null) {\n+            matchesList.addAll(strings);\n+        }\n+        return matchesList;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestIRMatching.java","additions":1627,"deletions":0,"binary":false,"changes":1627,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test different custom run tests.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestRunTests\n+ *\/\n+\n+public class TestRunTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        try {\n+            TestFramework.run(BadStandalone.class);\n+            throw new RuntimeException(\"Should not reach\");\n+        } catch (IRViolationException e) {\n+            String[] matches = { \"test(int)\", \"test2(int)\", \"Failed IR Rules (2)\"};\n+            Arrays.stream(matches).forEach(m -> Asserts.assertTrue(e.getExceptionInfo().contains(m)));\n+            Asserts.assertEQ(e.getExceptionInfo().split(\"STANDALONE mode\", -1).length - 1, 2);\n+        }\n+        new TestFramework(SkipCompilation.class).addFlags(\"-XX:-UseCompiler\").start();\n+        new TestFramework(SkipCompilation.class).addFlags(\"-Xint\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=1\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=2\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=3\").start();\n+    }\n+    public int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test1(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test2(int y) {\n+        iFld = y;\n+        return y;\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\"})\n+    public void run(RunInfo info) {\n+        test1(23);\n+        test2(42);\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest(\"test1\"));\n+            TestFramework.assertCompiledByC2(info.getTest(\"test2\"));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test3(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run2(RunInfo info) {\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        test3(42);\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest());\n+            try {\n+                info.getTest(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC1Compiled(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC2Compiled(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestCompiledAtLevel(\"test2\", CompLevel.C2);\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test4(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test4\", mode = RunMode.STANDALONE)\n+    public void run3(RunInfo info) {\n+        for (int i = 0; i < 2000; i++) {\n+            test4(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test5(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test6(int y) {\n+        iFld = y;\n+        return y;\n+    }\n+\n+    @Run(test = {\"test5\", \"test6\"})\n+    public void run4(RunInfo info) {\n+        test5(23);\n+        test6(42);\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest(\"test5\"));\n+            TestFramework.assertCompiledByC2(info.getTest(\"test6\"));\n+            try {\n+                info.getTest();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC1Compiled();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC2Compiled();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestCompiledAtLevel(CompLevel.C2);\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test7(int x) {\n+        for (int i = 0; i < 100; i++) {}\n+        iFld = x;\n+        return x;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test8(int x) {\n+        for (int i = 0; i < 100; i++) {}\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = {\"test7\", \"test8\"}, mode = RunMode.STANDALONE)\n+    public void run5() {\n+        for (int i = 0; i < 10000; i++) {\n+            test7(23);\n+            test8(42);\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @Warmup(0)\n+    public void test9() {\n+        TestClass tmp = new TestClass();\n+        for (int i = 0; i < 100; ++i) {\n+            tmp.test();\n+        }\n+    }\n+\n+    static class TestClass {\n+        public int test() {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+}\n+\n+class BadStandalone {\n+    int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test\", mode = RunMode.STANDALONE)\n+    public void run(RunInfo info) {\n+        test(42);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test2(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test2\", mode = RunMode.STANDALONE)\n+    public void run2(RunInfo info) {\n+    }\n+}\n+\n+\/\/ Run with TieredStopAt=[1,3]. IR verification is skipped.\n+class SkipC2Compilation {\n+\n+    int iFld;\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testC2() {\n+        iFld = 34;\n+    }\n+\n+    @Check(test = \"testC2\")\n+    public void checkC2(TestInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test2C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Run(test = \"test2C2\")\n+    public void run2C2(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        try {\n+            info.isCompilationSkipped(\"test2C2\");\n+            throw new RuntimeException(\"should not reach\");\n+        } catch (TestRunException e) {\n+            \/\/ Excepted, do not call this method for single associated test.\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test3C2() {\n+        iFld = 34;\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test4C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Test \/\/ Level any\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testAny() {\n+        iFld = 34;\n+    }\n+\n+    @Run(test = {\"test3C2\", \"test4C2\", \"testAny\"})\n+    public void runMulti(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC1(info.getTest(\"testAny\"));\n+        }\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertFalse(info.isCompilationSkipped(\"testAny\"));\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertFalse(info.isCompilationSkipped(\"testAny\"));\n+        try {\n+            info.isCompilationSkipped();\n+            throw new RuntimeException(\"should not reach\");\n+        } catch (TestRunException e) {\n+            \/\/ Excepted, do not call this method for multiple associated tests.\n+        }\n+    }\n+}\n+\n+\/\/ Run with -Xint and -XX:-Compiler. IR verification is skipped.\n+class SkipCompilation {\n+    int iFld;\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testC2() {\n+        iFld = 34;\n+    }\n+\n+    @Check(test = \"testC2\")\n+    public void checkC2(TestInfo info) {\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test2C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Run(test = \"test2C2\")\n+    public void run2C2(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test3C2() {\n+        iFld = 34;\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test4C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Test \/\/ Level any\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testAny() {\n+        iFld = 34;\n+    }\n+\n+    @Run(test = {\"test3C2\", \"test4C2\", \"testAny\"})\n+    public void runMulti(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest(\"testAny\"));\n+            TestFramework.assertNotCompiled(info.getTest(\"test3C2\"));\n+            TestFramework.assertNotCompiled(info.getTest(\"test4C2\"));\n+        }\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"testAny\"));\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"testAny\"));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestRunTests.java","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Sanity test the different ways to start the test framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestSanity\n+ *\/\n+\n+public class TestSanity {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        TestFramework.run(TestSanity.class);\n+        TestFramework.runWithFlags(\"-XX:+TieredCompilation\");\n+        new TestFramework().addFlags(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework(TestSanity.class).addFlags(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework().addHelperClasses(HelperA.class).start();\n+        new TestFramework(TestSanity.class).addHelperClasses(HelperA.class, HelperB.class).start();\n+        Scenario sDefault = new Scenario(0);\n+        Scenario s1 = new Scenario(1, \"-XX:TLABRefillWasteFraction=52\", \"-XX:+UseTLAB\");\n+        Scenario s2 = new Scenario(2, \"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseTLAB\");\n+        new TestFramework(TestSanity.class).addScenarios(s1).start();\n+        new TestFramework().addScenarios(s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(s1, s2).start();\n+        new TestFramework().addScenarios(sDefault, s1).start();\n+        new TestFramework().addScenarios(sDefault, s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1, s2).start();\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.start();\n+        testFramework.addFlags(\"-XX:TLABRefillWasteFraction=54\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addFlags(\"-XX:TLABRefillWasteFraction=55\").addFlags(\"-XX:+UseTLAB\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class, HelperB.class).start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class, HelperB.class).addHelperClasses(HelperC.class).start();\n+        testFramework = new TestFramework();\n+        testFramework.addScenarios(sDefault).addScenarios(s1, s2).start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addScenarios(sDefault).addFlags(\"-XX:+UseSuperWord\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addFlags(\"-XX:+UseSuperWord\", \"-XX:+UseCompiler\").addScenarios(sDefault)\n+                     .addHelperClasses(HelperB.class, HelperC.class).addScenarios(s1, s2).addFlags(\"-XX:+TieredCompilation\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addFlags(\"-XX:+UseSuperWord\", \"-XX:+UseCompiler\").addScenarios(sDefault)\n+                     .addHelperClasses(HelperB.class, HelperC.class).addScenarios(s1, s2).setDefaultWarmup(200)\n+                     .addFlags(\"-XX:+TieredCompilation\").start();\n+    }\n+\n+    @Test\n+    public void test() {}\n+}\n+\n+class HelperA { }\n+class HelperB { }\n+class HelperC { }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestSanity.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test scenarios with the framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestScenarios\n+ *\/\n+\n+public class TestScenarios {\n+    public static void main(String[] args) {\n+        Scenario sDefault = new Scenario(0);\n+        Scenario s1 = new Scenario(1, \"-XX:TLABRefillWasteFraction=51\");\n+        Scenario s2 = new Scenario(2, \"-XX:TLABRefillWasteFraction=52\");\n+        Scenario s3 = new Scenario(3, \"-XX:TLABRefillWasteFraction=53\");\n+        Scenario s3dup = new Scenario(3, \"-XX:TLABRefillWasteFraction=53\");\n+        try {\n+            new TestFramework().addScenarios(sDefault, s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework().addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #1, #3\"), e.getMessage());\n+        }\n+        new TestFramework(ScenarioTest.class).addScenarios(s1, s2, s3).start();\n+        try {\n+            new TestFramework().addScenarios(s1, s3dup, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot define two scenarios with the same index 3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework(MyExceptionTest.class).addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(s1.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+            Asserts.assertTrue(s2.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+            Asserts.assertTrue(s3.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+        } catch (Exception e) {\n+            Asserts.fail(\"Should not catch other exceptions\");\n+        }\n+\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failS3() {\n+    }\n+}\n+\n+class ScenarioTest {\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"54\"}, counts = {IRNode.CALL, \"1\"})\n+    public void doesNotFail() {\n+    }\n+}\n+\n+class MyExceptionTest {\n+    int iFld;\n+    @Test\n+    @IR(failOn = IRNode.STORE) \/\/ Not evaluated due to MyScenarioException\n+    public void test() {\n+        iFld = 42;\n+        throw new MyScenarioException();\n+    }\n+}\n+\n+class MyScenarioException extends RuntimeException {}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestScenarios.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test the framework with helper classes.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestWithHelperClasses\n+ *\/\n+\n+public class TestWithHelperClasses {\n+\n+    public static void main(String[] args) {\n+        new TestFramework().addHelperClasses(Helper1.class, Helper2.class).start();\n+        try {\n+            new TestFramework().addHelperClasses(Helper1.class).start();\n+            shouldNotReach();\n+        } catch (TestVMException e) {\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"public static void compiler.lib.ir_framework.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"public static void compiler.lib.ir_framework.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(TestFramework.getLastTestVMOutput().contains(\"public static void compiler.lib.ir_framework.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"public static void compiler.lib.ir_framework.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"Should not be executed\"));\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"Should not be executed\"));\n+        }\n+\n+        try {\n+            new TestFramework(BadHelperClass.class).addHelperClasses(BadHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Test annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Check annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Run annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"noTestInHelper\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"check2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test3\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"run3\"));\n+        }\n+\n+        try {\n+            new TestFramework(TestAsHelper.class).addHelperClasses(TestAsHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot specify test class compiler.lib.ir_framework.\" +\n+                                                       \"TestAsHelper as helper class, too\"));\n+        }\n+\n+        try {\n+            new TestFramework().addHelperClasses(NestedHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Nested class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"TestWithHelperClasses$NestedHelper inside test class\"));\n+        }\n+    }\n+\n+    public static void shouldNotReach() {\n+        throw new RuntimeException(\"should not reach\");\n+    }\n+\n+    @Test\n+    public void test() throws NoSuchMethodException {\n+        TestFramework.assertCompiledByC2(Helper1.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(Helper2.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(NestedHelper.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(StaticNestedHelper.class.getMethod(\"foo\"));\n+    }\n+\n+    class NestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+\n+\n+    static class StaticNestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+}\n+\n+class TestAsHelper {\n+\n+    @Test\n+    public void foo() {}\n+}\n+\n+class Helper1 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class Helper2 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class BadHelperClass {\n+    @Test\n+    public void test1() {}\n+ }\n+\n+\n+class BadHelper {\n+    @Test\n+    public void noTestInHelper() {}\n+\n+    @Test\n+    public void test2() {}\n+\n+    @Check(test = \"test2\")\n+    public void check2() {}\n+\n+    @Test\n+    public void test3() {}\n+\n+    @Run(test = \"test3\")\n+    public void run3() {}\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestWithHelperClasses.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.BaseTestExample\n+ *\/\n+\n+\/**\n+ * If there is no warm up specified the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>Then do compilation of @Test method. <b>(**)<\/b><\/li>\n+ *     <li><p>Invoke @Test method once again<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for simple tests (no @Run or @Check) at @Test method:\n+ * <ul>\n+ *     <li><p>compLevel: Specify at which compilation level the test should be compiled by the framework at step <b>(**)<\/b>.\n+ *                       If {@link CompLevel#WAIT_FOR_COMPILATION} is specified, the framework will continue invoke the\n+ *                       method until HotSpot compiles it. If it is not compiled after 10s, an exception is thrown.<\/li>\n+ *     <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n+ *     <li><p>@Arguments: If a @Test method specifies arguments, you need to provide arguments by using @Arguments such\n+ *                        that the framework knows how to call the method. If you need more complex values, use @Run.<\/li>\n+ *     <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ * <\/ul>\n+ *\n+ * @see Test\n+ * @see Arguments\n+ * @see Warmup\n+ * @see TestFramework\n+ *\/\n+public class BaseTestExample {\n+    int iFld;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(BaseTestExample.class)\n+    }\n+\n+    \/\/ Test without arguments.\n+    @Test\n+    public void mostBasicTest() {\n+        iFld = 42;\n+    }\n+\n+    \/\/ Test with arguments. Use Argument class to choose a value.\n+    \/\/ Object arguments need to have an associated default constructor in its class.\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.MAX})\n+    public void basicTestWithArguments(int x, long y) {\n+        iFld = x;\n+    }\n+\n+    \/\/ @Warmup needs to be positive or zero. In case of zero, the method is directly compiled (simulated -Xcomp).\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.MAX})\n+    @Warmup(100)\n+    public void basicTestWithDifferentWarmup(int x, long y) {\n+        iFld = x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/BaseTestExample.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.CheckedTestExample\n+ *\/\n+\n+\/**\n+ * If there is no non-default warm-up specified, the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>By default, after each invocation, the @Check method of the @Test method is invoked. This can be disabled\n+ *            by using {@link CheckAt#COMPILED}<\/li>\n+ *     <li><p>After the warm-up, the @Test method is compiled.<\/li>\n+ *     <li><p>Invoke @Test method once again and then always invoke the @Check method once again.<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for checked tests:\n+ * <ul>\n+ *     <li><p>At @Test method:<\/li>\n+ *     <ul>\n+ *         <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n+ *         <li><p>@Arguments: If a @Test method specifies arguments, you need to provide arguments by using @Arguments\n+ *                            such that the framework knows how to call the method. If you need more complex values, use a\n+ *                            custom run test with @Run.<\/li>\n+ *         <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ *     <\/ul>\n+ *     <li><p>At @Check method:<\/li>\n+ *     <ul>\n+ *         <li><p>{@link Check#when}: When should the @Check method be invoked.<\/li>\n+ *         <li><p>No @IR annotations.<\/li>\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * @see Check\n+ * @see Test\n+ * @see Arguments\n+ * @see Warmup\n+ * @see TestFramework\n+ *\/\n+public class CheckedTestExample {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(CheckedTestExample.class)\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT) \/\/ As with normal tests, you need to tell the framework what the argument is.\n+    @Warmup(100) \/\/ As with normal tests, you can specify the warmup iterations.\n+    public int test(int x) {\n+        return 42;\n+    }\n+\n+    \/\/ Check method for test(). Invoked directly after test() by the Test Framework.\n+    @Check(test = \"test\") \/\/ Specify the @Test method for which this method is a check.\n+    public void basicCheck() {\n+        \/\/ Do some checks after an invocation.\n+    }\n+\n+    @Test\n+    public int test2() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes the return value from test2() as an argument.\n+    \/\/ The return type and the parameter type must match.\n+    @Check(test = \"test2\")\n+    public void checkWithReturn(int returnValue) {\n+        \/\/ Do some checks after an invocation.\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test3() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes a TestInfo object to the check which contains some additional information about the test.\n+    @Check(test = \"test3\")\n+    public void checkWithTestInfo(TestInfo info) {\n+        \/\/ Do some checks after an invocation. Additional queries with TestInfo.\n+        if (!info.isWarmUp()) {\n+            \/\/ ...\n+        }\n+    }\n+\n+    @Test\n+    public int test4() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes the return value and a TestInfo object to the check which contains some additional\n+    \/\/ information about the test. The order of the arguments is important. The return value must come first and the\n+    \/\/ the TestInfo parameter second. Any other combination or use of different arguments are forbidden for @Check methods.\n+    @Check(test = \"test4\")\n+    public void checkWithReturnAndTestInfo(int returnValue, TestInfo info) {\n+        \/\/ Do some checks after an invocation. Additional queries with TestInfo.\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+        if (!info.isWarmUp()) {\n+            \/\/ ...\n+        }\n+    }\n+\n+    @Test\n+    public int test5() {\n+        return 42;\n+    }\n+\n+    \/\/ Check method for test5() is only invoked once warmup is finished and test() has been compiled by the Test Framework.\n+    @Check(test = \"test5\", when = CheckAt.COMPILED) \/\/ Specify the @Test method for which this method is a check.\n+    public void checkAfterCompiled(TestInfo info) {\n+        \/\/ Do some checks after compilation.\n+        TestFramework.assertCompiled(info.getTest()); \/\/ Test is compiled by framework after warm-up.\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CheckedTestExample.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.CustomRunTestExample\n+ *\/\n+\n+\/**\n+ * If there is no warm-up specified, the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Run method {@link TestVM#WARMUP_ITERATIONS} many times. Note that the @Run method\n+ *            is responsible to invoke the @Test methods to warm it up properly. This is not done by the framework. Not\n+ *            invoking a @Test method will result in an -Xcomp like compilation of the method as there is no profile\n+ *            information for it. The @Run method can do any arbitrary argument setup and return value verification and\n+ *            can invoke the @Test methods multiple times in a single invocation of the @Run method or even skip some\n+ *            test invocations.<\/li>\n+ *     <li><p>After the warm-up, the @Test methods are compiled (there can be multiple @Test methods).<\/li>\n+ *     <li><p>Invoke the @Run method once again.<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for custom run tests:\n+ * <ul>\n+ *     <li><p>At @Test methods:<\/li>\n+ *     <ul>\n+ *         <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ *         <li><p>No @Warmup, this must be set at @Run method.<\/li>\n+ *         <li><p>No @Arguments, the arguments are set by @Run method.<\/li>\n+ *     <\/ul>\n+ *     <li><p>At @Run method:<\/li>\n+ *     <ul>\n+ *         <li><p>@Warmup: Change warm-up iterations of @Run method (defined by default by\n+ *                         TestVM.WARMUP_ITERATIONS)<\/li>\n+ *         <li><p>{@link Run#test}: Specify any number of @Test methods. They cannot be shared with other @Check or @Run\n+ *                                  methods.<\/li>\n+ *         <li><p>{@link Run#mode}: Choose between normal invocation as described above or {@link RunMode#STANDALONE}.\n+ *                                  STANDALONE only invokes the @Run method once without warm-up or a compilation by the\n+ *                                  Test Framework. The only thing done by the framework is the verification of any @IR\n+ *                                  rules afterwards. The STANDALONE @Run method needs to make sure that a C2 compilation\n+ *                                  is reliably triggered if there are any @IR rules.<\/li>\n+ *         <li><p>No @IR annotations<\/li>\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * @see Run\n+ * @see Test\n+ * @see RunMode\n+ * @see TestFramework\n+ *\/\n+public class CustomRunTestExample {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(CustomRunTestExample.class)\n+    }\n+\n+    @Test\n+    public int test(int x) {\n+        return x;\n+    }\n+\n+    \/\/ Run method for test(). Invoked directly by Test Framework instead of test().\n+    \/\/ Can do anything you like. It's also possible to skip or do multiple invocations of test()\n+    @Run(test = \"test\") \/\/ Specify the @Test method for which this method is a runner.\n+    public void basicRun() {\n+        int returnValue = test(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test2(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combiniations are allowed.\n+    @Run(test = \"test2\")\n+    public void runWithRunInfo(RunInfo info) {\n+        \/\/ We could also skip some invocations. This might have an influence on possible @IR rules, need to be careful.\n+        if (info.getRandom().nextBoolean()) {\n+            int returnValue = test(34);\n+            if (returnValue != 34) {\n+                throw new RuntimeException(\"Must match\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public int test3(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run uses a user defined @Warmup.\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runWithWarmUp() {\n+        int returnValue = test3(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test4(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run is only invoked once by the Test Framework. There is no warm-up and no compilation done\n+    \/\/ by the Test Framework. The only thing done by the framework is @IR rule verification.\n+    @Run(test = \"test4\", mode = RunMode.STANDALONE)\n+    public void runOnlyOnce() {\n+        int returnValue = test4(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test5(int x) {\n+        return x;\n+    }\n+\n+    @Test\n+    public int test6(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run can run multiple test methods and get them IR checked as part of this custom run test.\n+    @Run(test = {\"test5\", \"test6\"})\n+    public void runMultipleTests() {\n+        int returnValue = test5(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+        returnValue = test6(42);\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CustomRunTestExample.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.IRExample\n+ *\/\n+\n+\/**\n+ * Multiple @IR rules can be specified at @Test methods. The framework performs a regex based match on the PrintIdeal\n+ * and PrintOptoAssembly of the run test VM. Some default string regexes for IR nodes are defined in the framework\n+ * IRNode class. There are two kinds of checks:\n+ * <ul>\n+ *     <li><p>{@link IR#failOn}: One or more (IR node) regexes that are not allowed to occur in the IR (neither in\n+ *                               PrintIdeal nor in PrintOptoAssembly)<\/li>\n+ *     <li><p>{@link IR#counts}: One or more regexes-count pairs specifies how often an (IR node) regex must be found in\n+ *                               PrintIdeal and PrintOptoAssembly.<\/li>\n+ * <\/ul>\n+ * <p>\n+ *\n+ * One might also want to restrict the application of certain @IR rules depending on the used flags in the test VM.\n+ * These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted (see\n+ * {@link TestFramework}) most of them should not have an impact on the IR except for different GC flags which should\n+ * be considered) to enable a verification by the framework (see below). The @IR rules thus have an option to restrict\n+ * their application:\n+ * <ul>\n+ *     <li><p>{@link IR#applyIf}: Only apply a rule if a flag has a certain value<\/li>\n+ *     <li><p>{@link IR#applyIfNot}: Only apply a rule if a flag has NOT a certain value (inverse of applyIf)<\/li>\n+ *     <li><p>{@link IR#applyIfAnd}: Only apply a rule if all flags have the specified value<\/li>\n+ *     <li><p>{@link IR#applyIfOr}: Only apply a rule if at least one flag has the specified value<\/li>\n+ * <\/ul>\n+ * <p>\n+ *\n+ * The framework, however, does not perform the verification if:\n+ * <ul>\n+ *     <li><p>-DVerifyIR=false is used<\/li>\n+ *     <li><p>The test is run with a non-debug build<\/li>\n+ *     <li><p>-Xcomp, -Xint, -XX:-UseCompile, -XX:CompileThreshold, -DFlipC1C2=true, or -DExcludeRandom=true are used.<\/li>\n+ *     <li><p>JTreg specifies non-whitelisted flags as VM and\/or Javaoptions (could change the IR in an unexpected way)<\/li>\n+ * <\/ul>\n+ *\n+ * @see IR\n+ * @see Test\n+ * @see TestFramework\n+ *\/\n+\/\/ This test is expected to fail when run with JTreg.\n+public class IRExample {\n+    int iFld, iFld2, iFld3;\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ First run tests from IRExample\n+        try {\n+            TestFramework.run(FailingExamples.class); \/\/ Secondly, run tests from FailingExamples\n+        } catch (IRViolationException e) {\n+            \/\/ Expected. Check stderr\/stdout to see how IR failures are reported (always printed, regardless if\n+            \/\/ exception is thrown or not). Uncomment the \"throw\" statement below to get a completely failing test.\n+            \/\/throw e;\n+        }\n+    }\n+\n+    \/\/ Rules with failOn constraint which all pass\n+    @Test\n+    @IR(failOn = IRNode.LOAD) \/\/ 1 default regex\n+    @IR(failOn = {IRNode.LOAD, IRNode.LOOP}) \/\/ 2 default regexes\n+    @IR(failOn = {IRNode.LOAD, \"some regex that does not occur\"}) \/\/ 1 default regex and a user-defined regex\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld2\", IRNode.LOAD, IRNode.STORE_OF_CLASS, \"Foo\"})\n+    \/\/ Only apply this rule if the VM flag UseZGC is true\n+    @IR(applyIf = {\"UseZGC\", \"true\"}, failOn = IRNode.LOAD)\n+    \/\/ We can also use comparators (<, <=, >, >=, !=, =) to restrict the rules.\n+    \/\/ This rule is only applied if the loop unroll limit is 10 or greater.\n+    @IR(applyIf = {\"LoopUnrollLimit\", \">= 10\"}, failOn = IRNode.LOAD)\n+    public void goodFailOn() {\n+        iFld = 42; \/\/ No load, no loop, no store to iFld2, no store to class Foo\n+    }\n+\n+    \/\/ Rules with counts constraint which all pass\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"2\"}) \/\/ 1 default regex\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ equivalent to failOn = IRNode.LOAD\n+    @IR(counts = {IRNode.STORE, \"2\",\n+                  IRNode.LOAD, \"0\"}) \/\/ 2 default regexes\n+    @IR(counts = {IRNode.STORE, \"2\",\n+                  \"some regex that does not occur\", \"0\"}) \/\/ 1 default regex and a user-defined regex\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"1\",\n+                  IRNode.STORE, \"2\",\n+                  IRNode.STORE_OF_CLASS, \"IRExample\", \"2\"})\n+    public void goodCounts() {\n+        iFld = 42; \/\/ No load, store to iFld in class IRExample\n+        iFld2 = 42; \/\/ No load, store to iFld2 in class IRExample\n+    }\n+\n+    \/\/ @IR rules can also specify both type of checks in the same rule\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC,\n+                  IRNode.LOOP},\n+        counts = {IRNode.LOAD, \"2\",\n+                  IRNode.LOAD_OF_FIELD, \"iFld2\", \"1\",\n+                  IRNode.LOAD_OF_CLASS, \"IRExample\", \"2\"})\n+    public void mixFailOnAndCounts() {\n+        iFld = iFld2;\n+        iFld2 = iFld3;\n+    }\n+}\n+\n+class FailingExamples {\n+    int iFld2, iFld3;\n+    IRExample irExample = new IRExample();\n+\n+    \/\/ Rules with failOn constraint which all fail.\n+    @Test\n+    @IR(failOn = IRNode.STORE)\n+    @IR(failOn = {IRNode.STORE, IRNode.LOOP}) \/\/ LOOP regex not found but STORE regex, letting the rule fail\n+    @IR(failOn = {IRNode.LOOP, IRNode.STORE}) \/\/ Order does not matter\n+    @IR(failOn = {IRNode.STORE, IRNode.LOAD}) \/\/ STORE and LOAD regex found, letting the rule fail\n+    @IR(failOn = {\"LoadI\"}) \/\/ LoadI can be found in PrintIdeal letting the rule fail\n+    \/\/ Store to iFld, store, and store to class IRExample, all 3 regexes found letting the rule fail\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.STORE, IRNode.STORE_OF_CLASS, \"IRExample\"})\n+    public void badFailOn() {\n+        irExample.iFld = iFld2; \/\/ Store to iFld in class IRExample, load from iFld2\n+    }\n+\n+\n+    \/\/ Rules with counts constraint which all fail\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"}) \/\/ There are 2 stores\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ equivalent to failOn = IRNode.LOAD, there is 1 load\n+    @IR(counts = {IRNode.STORE, \"1\",\n+                  IRNode.LOAD, \"1\"}) \/\/ first constraint holds (there is 1 load) but 2 stores, letting this rule fail\n+    @IR(counts = {IRNode.LOAD, \"1\",\n+                  IRNode.STORE, \"1\"}) \/\/ order does not matter\n+    @IR(counts = {\"some regex that does not occur\", \"1\"}) \/\/ user-defined regex does not occur once\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"2\", \/\/ Only one store to iFld\n+                  IRNode.LOAD, \"2\", \/\/ Only 1 load\n+                  IRNode.STORE_OF_CLASS, \"Foo\", \"1\"}) \/\/ No store to class Foo\n+    public void badCounts() {\n+        irExample.iFld = iFld3; \/\/ No load, store to iFld in class IRExample\n+        iFld2 = 42; \/\/ No load, store to iFld2 in class IRExample\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/IRExample.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"}]}