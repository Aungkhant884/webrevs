{"files":[{"patch":"@@ -43,1 +43,1 @@\n-    private static final Random random = Utils.getRandomInstance();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -58,1 +58,1 @@\n-        return random;\n+        return RANDOM;\n@@ -87,1 +87,1 @@\n-            throw new TestRunException(\"Could not find method \" + name + \" in \" + c + parameters);\n+            throw new TestRunException(\"Could not find method \" + name + \" in \" + c + parameters, e);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    RANDOM_EACH\n+    RANDOM_EACH,\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Argument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    private static final Random random = Utils.getRandomInstance();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -285,1 +285,1 @@\n-            return random.nextBoolean();\n+            return RANDOM.nextBoolean();\n@@ -287,1 +287,1 @@\n-            return (byte)random.nextInt(256);\n+            return (byte) RANDOM.nextInt(256);\n@@ -289,1 +289,1 @@\n-            return (char)random.nextInt(65536);\n+            return (char) RANDOM.nextInt(65536);\n@@ -291,1 +291,1 @@\n-            return (short)random.nextInt(65536);\n+            return (short) RANDOM.nextInt(65536);\n@@ -293,1 +293,1 @@\n-            return random.nextInt();\n+            return RANDOM.nextInt();\n@@ -295,1 +295,1 @@\n-            return random.nextLong();\n+            return RANDOM.nextLong();\n@@ -298,1 +298,1 @@\n-            return random.nextFloat() * 20000 - 10000;\n+            return RANDOM.nextFloat() * 20000 - 10000;\n@@ -301,1 +301,1 @@\n-            return random.nextDouble() * 20000 - 10000;\n+            return RANDOM.nextDouble() * 20000 - 10000;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ArgumentValue.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    COMPILED\n+    COMPILED,\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CheckAt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Executable;\n@@ -30,2 +33,3 @@\n- * Compilation levels used by the framework. The compilation levels map to the used levels in HotSpot (apart from the\n- * framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot be found in HotSpot).\n+ * Compilation levels used by the framework to initiate a compilation of a method. The compilation levels map to the used\n+ * levels in HotSpot (apart from the framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot\n+ * be found in HotSpot). The HotSpot specific levels must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n@@ -34,2 +38,2 @@\n- * The compilation levels can be specified in the {@link Test}, {@link ForceCompile} and {@link DontCompile} annotation.\n- *\n+ * The compilation levels can be specified in the {@link Test}, {@link ForceCompile}, and\n+ * {@link ForceCompileClassInitializer} annotation.\n@@ -39,1 +43,1 @@\n- * @see DontCompile\n+ * @see ForceCompileClassInitializer\n@@ -46,1 +50,2 @@\n-     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler} or {@code -DStressCC=true}.\n+     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n+     * {@code -DExcludeRandom=true}.\n@@ -65,1 +70,1 @@\n-    C1(1),\n+    C1_SIMPLE(1),\n@@ -77,1 +82,3 @@\n-    C2(4);\n+    C2(4),\n+\n+    ;\n@@ -79,1 +86,1 @@\n-    private static final Map<Integer, CompLevel> typesByValue = new HashMap<>();\n+    private static final Map<Integer, CompLevel> TYPES_BY_VALUE = new HashMap<>();\n@@ -84,1 +91,1 @@\n-            typesByValue.put(level.value, level);\n+            TYPES_BY_VALUE.put(level.value, level);\n@@ -109,1 +116,1 @@\n-        CompLevel level = typesByValue.get(value);\n+        CompLevel level = TYPES_BY_VALUE.get(value);\n@@ -115,1 +122,12 @@\n-     * Checks if two compilation levels are overlapping.\n+     * Checks if this compilation level is not part of the compiler.\n+     *\/\n+    boolean isNotCompilationLevelOfCompiler(Compiler c) {\n+        return switch (c) {\n+            case C1 -> !isC1();\n+            case C2 -> this != C2;\n+            default -> throw new TestFrameworkException(\"Should not be called with compiler \" + c);\n+        };\n+    }\n+\n+    \/**\n+     * Flip the compilation levels.\n@@ -117,2 +135,10 @@\n-    static boolean overlapping(CompLevel l1, CompLevel l2) {\n-        return l1.isC1() == l2.isC1() || (l1 == C2 && l2 == C2);\n+    CompLevel flipCompLevel() {\n+        switch (this) {\n+            case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n+                return CompLevel.C2;\n+            }\n+            case C2 -> {\n+                return CompLevel.C1_SIMPLE;\n+            }\n+        }\n+        return this;\n@@ -121,6 +147,13 @@\n-    static CompLevel join(CompLevel l1, CompLevel l2) {\n-        return switch (l1) {\n-            case ANY -> l2;\n-            case C1, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> l2.isC1() || l2 == ANY ? C1 : SKIP;\n-            case C2 -> l2 == C2 || l2 == ANY ? C2 : SKIP;\n-            default -> SKIP;\n+    \/**\n+     * Return the compilation level when only allowing a compilation with the specified compiler.\n+     *\/\n+    CompLevel excludeCompilationRandomly(Executable ex) {\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            \/\/ No exclusion\n+            return this;\n+        }\n+        Compiler compiler = TestFrameworkExecution.excludeRandomly(ex);\n+        return switch (compiler) {\n+            case ANY -> SKIP;\n+            case C1 -> isC1() ? SKIP : this;\n+            case C2 -> this == C2 ? SKIP : this;\n@@ -131,1 +164,1 @@\n-        return this == C1 || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n+        return this == C1_SIMPLE || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CompLevel.java","additions":54,"deletions":21,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+\/**\n+ * Compilers to select for {@link DontCompile}. HotSpot does not handle the exclusion of a C1 method at a specific level.\n+ * It can only exclude a method for the entire C1 compilation. Thus, this annotation is provided for {@link DontCompile}\n+ * instead of {@link CompLevel}.\n+ *\n+ * @see DontCompile\n+ *\/\n+public enum Compiler {\n+    \/**\n+     * Selecting both the C1 and C2 compiler. This must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+     *\/\n+    ANY(-2),\n+    \/**\n+     * The C1 compiler.\n+     *\/\n+    C1(1),\n+    \/**\n+     * The C2 compiler.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private final int value;\n+\n+    Compiler(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Compiler.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -86,1 +86,1 @@\n-                    String argumentValString = argumentVal.toString();\n+                    builder.append(\"arg \").append(i).append(\": \").append(argumentVal.toString());\n@@ -88,1 +88,1 @@\n-                        argumentValString += \" (\" + (int)(Character)argumentVal + \")\";\n+                        builder.append(\" (\").append((int)(Character)argumentVal).append(\")\");\n@@ -90,1 +90,1 @@\n-                    builder.append(\"arg \").append(i).append(\": \").append(argumentValString).append(\", \");\n+                    builder.append(\", \");\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/DeclaredTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * {@link Check @Check} or {@link Run @Run}):\n+ * {@link Check @Check} or {@link Run @Run}) with the specified compiler.\n@@ -34,5 +34,3 @@\n- *     <li><p>{@link CompLevel#ANY} (default): No C1 or C2 compilation.<\/li>\n- *     <li><p>{@link CompLevel#C1}: No C1 compilation, C2 compilation still possible.<\/li>\n- *     <li><p>{@link CompLevel#C2}: No C2 compilation, C1 compilation still possible.<\/li>\n- *     <li><p>The usage of any other compilation level is forbidden and results in a\n- *            {@link TestFormatException TestFormatException}.<\/li>\n+ *     <li><p>{@link Compiler#ANY} (default): No C1 or C2 compilation.<\/li>\n+ *     <li><p>{@link Compiler#C1}: No C1 compilation, C2 compilation still possible.<\/li>\n+ *     <li><p>{@link Compiler#C2}: No C2 compilation, C1 compilation still possible.<\/li>\n@@ -46,1 +44,1 @@\n-     * The excluded compilation level for the helper method.\n+     * The compiler with which a compilation of a helper method is excluded.\n@@ -48,1 +46,1 @@\n-    CompLevel value() default CompLevel.ANY;\n+    Compiler value() default Compiler.ANY;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/DontCompile.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,16 +30,4 @@\n- * Force a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test},\n- * {@link Check @Check} or {@link Test @Run}) immediately at the specified level:\n- * <ul>\n- *     <li><p>{@link CompLevel#ANY} (default): Highest available compilation level is selected which is usually\n- *            {@link CompLevel#C2}<\/li>\n- *     <li><p>{@link CompLevel#C1}: Level 1: C1 compilation without any profile information.<\/li>\n- *     <li><p>{@link CompLevel#C1_LIMITED_PROFILE}: Level 2: C1 compilation with limited profile information:\n- *            Includes Invocation and backedge counters.<\/li>\n- *     <li><p>{@link CompLevel#C1_FULL_PROFILE}: Level 3: C1 compilation with full profile information:\n- *            Includes Invocation and backedge counters with MDO.<\/li>\n- *     <li><p>{@link CompLevel#C2}: Level 4: C2 compilation with full optimizations.<\/li>\n- *     <li><p>{@link CompLevel#SKIP}: Does not apply to {@code @ForceCompile} and results in a\n- *            {@link TestFormatException}.<\/li>\n- *     <li><p>{@link CompLevel#WAIT_FOR_COMPILATION}: Does not apply to {@code @ForceCompile} and results in a\n- *            {@link TestFormatException}.<\/li>\n- * <\/ul>\n+ * Force a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Test @Run}) immediately at the specified level. {@link CompLevel#SKIP} and\n+ * {@link CompLevel#WAIT_FOR_COMPILATION} do not apply and result in a {@link TestFormatException}.\n+ *\n@@ -47,1 +35,1 @@\n- *  Using this annotation on <i>non-helper<\/i> methods results in a {@link TestFormatException}.\n+ * Using this annotation on <i>non-helper<\/i> methods also results in a {@link TestFormatException}.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ForceCompile.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,15 +31,3 @@\n- * immediately at the specified level:\n- * <ul>\n- *     <li><p>{@link CompLevel#ANY} (default): Highest available compilation level is selected which is usually\n- *            {@link CompLevel#C2}<\/li>\n- *     <li><p>{@link CompLevel#C1}: Level 1: C1 compilation without any profile information.<\/li>\n- *     <li><p>{@link CompLevel#C1_LIMITED_PROFILE}: Level 2: C1 compilation with limited profile information:\n- *     Includes Invocation and backedge counters.<\/li>\n- *     <li><p>{@link CompLevel#C1_FULL_PROFILE}: Level 3: C1 compilation with full profile information:\n- *     Includes Invocation and backedge counters with MDO.<\/li>\n- *     <li><p>{@link CompLevel#C2}: Level 4: C2 compilation with full optimizations.<\/li>\n- *     <li><p>{@link CompLevel#SKIP}: Does not apply to {@code @ForceCompileClassInitializer} and results in a\n- *     {@link TestFormatException}.<\/li>\n- *     <li><p>{@link CompLevel#WAIT_FOR_COMPILATION}: Does not apply to {@code @ForceCompileClassInitializer} and results in a\n- *     {@link TestFormatException}.<\/li>\n- * <\/ul>\n+ * immediately at the specified level. {@link CompLevel#SKIP} and {@link CompLevel#WAIT_FOR_COMPILATION} do not apply\n+ * and result in a {@link TestFormatException}.\n+\n@@ -47,1 +35,1 @@\n- *  Using this annotation on non-classes results in a {@link TestFormatException}.\n+ *  Using this annotation on non-classes also results in a {@link TestFormatException}.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ForceCompileClassInitializer.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private static final List<Function<String, Object>> longGetters = Arrays.asList(\n+    private static final List<Function<String, Object>> LONG_GETTERS = Arrays.asList(\n@@ -188,1 +188,1 @@\n-        actualFlagValue = longGetters.stream().map(f -> f.apply(flag)).filter(Objects::nonNull).findAny().orElse(null);\n+        actualFlagValue = LONG_GETTERS.stream().map(f -> f.apply(flag)).filter(Objects::nonNull).findAny().orElse(null);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IREncodingPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.io.*;\n+import java.io.IOException;\n@@ -39,1 +39,1 @@\n-    private static final Pattern irEncodingPattern =\n+    private static final Pattern IR_ENCODING_PATTERN =\n@@ -41,1 +41,1 @@\n-    private static final Pattern compileIdPattern = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n@@ -54,1 +54,1 @@\n-        this.compilations =  new HashMap<>();\n+        this.compilations = new HashMap<>();\n@@ -96,1 +96,1 @@\n-        Matcher matcher = irEncodingPattern.matcher(irEncoding);\n+        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n@@ -127,1 +127,1 @@\n-        try (BufferedReader br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+        try (var br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n@@ -252,1 +252,1 @@\n-        Matcher matcher = compileIdPattern.matcher(line);\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMatcher.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        final List<String> mergedNodes = new ArrayList<>();\n+        List<String> mergedNodes = new ArrayList<>();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,3 @@\n-- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution don).\n+- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution down).\n+- `-DWaitForCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a `@Test` annotated method with compilation level [WAIT_FOR_COMPILATION](.\/CompLevel.java).\n+- `-DIgnoreCompilerControls=false`: Ignore all compiler controls applied in the framework. This includes any compiler control annotations (`@DontCompile`, `@DontInline`, `@ForceCompile`, `@ForceInline`, `@ForceCompileStaticInitializer`), the exclusion of `@Run` and `@Check` methods from compilation, and the directive to not inline `@Test` annotated methods.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/README.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-     * The associated {@link Test @Test} methods (one or more) for for this {@code @Run} annotated run method.\n+     * The associated {@link Test @Test} methods (one or more) for this {@code @Run} annotated run method.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Run.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    STANDALONE\n+    STANDALONE,\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/RunMode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.stream.Collectors;\n@@ -45,2 +46,2 @@\n-    private static final List<String> ADDITIONAL_SCENARIO_FLAGS = new ArrayList<>();\n-    private static final Set<Integer> ENABLED_SCENARIOS = new HashSet<>();\n+    private static final List<String> ADDITIONAL_SCENARIO_FLAGS;\n+    private static final Set<Integer> ENABLED_SCENARIOS;\n@@ -55,1 +56,1 @@\n-            System.out.println(Arrays.toString(SCENARIOS_PROPERTY.split(\"\\\\s*,\\\\s*\")));\n+            var split = SCENARIOS_PROPERTY.split(\"\\\\s*,\\\\s*\");\n@@ -57,1 +58,1 @@\n-                Arrays.stream(SCENARIOS_PROPERTY.split(\"\\\\s*,\\\\s*\")).map(Integer::parseInt).forEachOrdered(ENABLED_SCENARIOS::add);\n+                ENABLED_SCENARIOS = Arrays.stream(split).map(Integer::parseInt).collect(Collectors.toSet());\n@@ -62,0 +63,2 @@\n+        } else {\n+            ENABLED_SCENARIOS = Collections.emptySet();\n@@ -64,3 +67,2 @@\n-        if (!ADDITIONAL_SCENARIO_FLAGS_PROPERTY.isEmpty()) {\n-            ADDITIONAL_SCENARIO_FLAGS.addAll(Arrays.asList(ADDITIONAL_SCENARIO_FLAGS_PROPERTY.split(\"\\\\s*,\\\\s*\")));\n-        }\n+        ADDITIONAL_SCENARIO_FLAGS = ADDITIONAL_SCENARIO_FLAGS_PROPERTY.isEmpty() ? Collections.emptyList() :\n+                Arrays.asList(ADDITIONAL_SCENARIO_FLAGS_PROPERTY.split(\"\\\\s*,\\\\s*\"));\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Scenario.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -145,2 +145,1 @@\n-    private final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n-    private boolean VERIFY_IR = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private static final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n@@ -148,0 +147,1 @@\n+    private boolean irVerificationPossible = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n@@ -153,4 +153,4 @@\n-    private Set<Class<?>> helperClasses = null;\n-    private List<Scenario> scenarios = null;\n-    private Set<Integer> scenarioIndices = null;\n-    private List<String> flags = null;\n+    private Set<Class<?>> helperClasses;\n+    private List<Scenario> scenarios;\n+    private Set<Integer> scenarioIndices;\n+    private List<String> flags;\n@@ -628,3 +628,3 @@\n-        if (VERIFY_IR) {\n-            VERIFY_IR = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n-            if (!VERIFY_IR) {\n+        if (irVerificationPossible) {\n+            irVerificationPossible = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n+            if (!irVerificationPossible) {\n@@ -636,2 +636,2 @@\n-            VERIFY_IR = hasIRAnnotations();\n-            if (!VERIFY_IR) {\n+            irVerificationPossible = hasIRAnnotations();\n+            if (!irVerificationPossible) {\n@@ -643,2 +643,2 @@\n-            VERIFY_IR = onlyWhitelistedJTregVMAndJavaOptsFlags();\n-            if (!VERIFY_IR) {\n+            irVerificationPossible = onlyWhitelistedJTregVMAndJavaOptsFlags();\n+            if (!irVerificationPossible) {\n@@ -733,1 +733,1 @@\n-        shouldVerifyIR = VERIFY_IR;\n+        shouldVerifyIR = irVerificationPossible;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFramework.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -92,2 +92,2 @@\n-    protected static final long PerMethodTrapLimit = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n-    protected static final boolean ProfileInterpreter = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n+    protected static final long PER_METHOD_TRAP_LIMIT = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n+    protected static final boolean PROFILE_INTERPRETER = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n@@ -95,0 +95,1 @@\n+    private static final boolean IGNORE_COMPILER_CONTROLS = Boolean.getBoolean(\"IgnoreCompilerControls\");\n@@ -149,2 +150,1 @@\n-            Class<?> testClass;\n-            testClass = getClassObject(testClassName, \"test\");\n+            Class<?> testClass = getClassObject(testClassName, \"test\");\n@@ -161,1 +161,0 @@\n-        Class<?> c;\n@@ -163,1 +162,1 @@\n-            c = Class.forName(className);\n+            return Class.forName(className);\n@@ -167,1 +166,0 @@\n-        return c;\n@@ -174,3 +172,3 @@\n-        Class<?>[] helperClasses = getHelperClasses(args);\n-        if (helperClasses != null) {\n-            TestRun.check(Arrays.stream(helperClasses).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n+        Class<?>[] helperClassesList = getHelperClasses(args);\n+        if (helperClassesList != null) {\n+            TestRun.check(Arrays.stream(helperClassesList).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n@@ -179,1 +177,1 @@\n-            for (Class<?> helperClass : helperClasses) {\n+            for (Class<?> helperClass : helperClassesList) {\n@@ -308,16 +306,16 @@\n-        if (!XCOMP) {\n-            \/\/ Don't control compilations if -Xcomp is enabled.\n-            \/\/ Also apply compile commands to all inner classes of 'clazz'.\n-            ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n-            classes.add(clazz);\n-            for (Class<?> c : classes) {\n-                applyClassAnnotations(c);\n-                List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n-                Collections.addAll(executables, c.getDeclaredConstructors());\n-                for (Executable ex : executables) {\n-                    checkClassAnnotations(ex);\n-                    try {\n-                        applyIndependentCompilationCommands(ex);\n-                    } catch (TestFormatException e) {\n-                        \/\/ Failure logged. Continue and report later.\n-                    }\n+        if (IGNORE_COMPILER_CONTROLS) {\n+            return;\n+        }\n+        \/\/ Also apply compile commands to all inner classes of 'clazz'.\n+        ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n+        classes.add(clazz);\n+        for (Class<?> c : classes) {\n+            applyClassAnnotations(c);\n+            List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n+            Collections.addAll(executables, c.getDeclaredConstructors());\n+            for (Executable ex : executables) {\n+                checkClassAnnotations(ex);\n+                try {\n+                    applyIndependentCompilationCommands(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n@@ -325,0 +323,1 @@\n+            }\n@@ -326,7 +325,6 @@\n-                \/\/ Only force compilation now because above annotations affect inlining\n-                for (Executable ex : executables) {\n-                    try {\n-                        applyForceCompileCommand(ex);\n-                    } catch (TestFormatException e) {\n-                        \/\/ Failure logged. Continue and report later.\n-                    }\n+            \/\/ Only force compilation now because above annotations affect inlining\n+            for (Executable ex : executables) {\n+                try {\n+                    applyForceCompileCommand(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n@@ -340,17 +338,19 @@\n-        if (anno != null) {\n-            \/\/ Compile class initializer\n-            CompLevel level = anno.value();\n-            if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n-                TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n-                                       \"@ForceCompileClassInitializer at \" + c);\n-                return;\n-            }\n-            level = restrictCompLevel(anno.value());\n-            if (level != CompLevel.SKIP) {\n-                \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n-                getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n-                TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n-                                        \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n-                                        + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n-                                        + \"Make sure to provide any form of static initialization or remove the annotation.\");\n-            }\n+        if (anno == null) {\n+            return;\n+        }\n+\n+        \/\/ Compile class initializer\n+        CompLevel level = anno.value();\n+        if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n+            TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n+                                   \"@ForceCompileClassInitializer at \" + c);\n+            return;\n+        }\n+        level = restrictCompLevel(anno.value());\n+        if (level != CompLevel.SKIP) {\n+            \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n+            getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n+            TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n+                                    \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n+                                    + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n@@ -366,2 +366,2 @@\n-     * Exclude a method from compilation randomly and returns the compilation level on which a compilation is still\n-     * possible.\n+     * Exclude a method from compilation with a compiler randomly. Return the compiler for which the method was made\n+     * not compilable.\n@@ -369,27 +369,6 @@\n-    static CompLevel excludeRandomly(Executable ex) {\n-        Random random = Utils.getRandomInstance();\n-        boolean exclude = random.nextBoolean();\n-        CompLevel level = CompLevel.ANY;\n-        if (exclude) {\n-            String levelName;\n-            switch (random.nextInt() % 3) {\n-                case 1 -> {\n-                    level = CompLevel.C1;\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.C2.getValue(), false);\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.C2.getValue(), true);\n-                    levelName = \"C2\";\n-                }\n-                case 2 -> {\n-                    level = CompLevel.C2;\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.C1.getValue(), false);\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.C1.getValue(), true);\n-                    levelName = \"C1\";\n-                }\n-                default -> {\n-                    level = CompLevel.SKIP;\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.ANY.getValue(), false);\n-                    WHITE_BOX.makeMethodNotCompilable(ex, CompLevel.ANY.getValue(), true);\n-                    levelName = \"C1 and C2\";\n-                }\n-            }\n-            System.out.println(\"Excluding from \" + levelName + \" compilation: \" + ex);\n+    static Compiler excludeRandomly(Executable ex) {\n+        Compiler compiler;\n+        switch (Utils.getRandomInstance().nextInt() % 3) {\n+            case 1 -> compiler = Compiler.C1;\n+            case 2 -> compiler = Compiler.C2;\n+            default -> compiler = Compiler.ANY;\n@@ -397,1 +376,4 @@\n-        return level;\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        System.out.println(\"Excluding from \" + compiler.name() + \" compilation: \" + ex);\n+        return compiler;\n@@ -413,5 +395,1 @@\n-            CompLevel compLevel = dontCompileAnno.value();\n-            TestFormat.check(compLevel == CompLevel.C1 || compLevel == CompLevel.C2 || compLevel == CompLevel.ANY,\n-                             \"Can only specify compilation level C1 (no individual C1 levels), \" +\n-                             \"C2 or ANY (no compilation, same as specifying anything) in @DontCompile at \" + ex);\n-            dontCompileAtLevel(ex, compLevel);\n+            dontCompileWithCompiler(ex, dontCompileAnno.value());\n@@ -421,1 +399,3 @@\n-            excludeRandomly(ex);\n+            if (Utils.getRandomInstance().nextBoolean()) {\n+                excludeRandomly(ex);\n+            }\n@@ -440,5 +420,5 @@\n-            CompLevel forceCompile = forceCompileAnno.value();\n-            CompLevel dontCompile = dontCompileAnno.value();\n-            TestFormat.check(dontCompile != CompLevel.ANY,\n-                             \"Cannot have @DontCompile(CompLevel.ANY) and @ForceCompile at the same time at \" + ex);\n-            TestFormat.check(forceCompile != CompLevel.ANY,\n+            CompLevel forceCompileLevel = forceCompileAnno.value();\n+            Compiler dontCompileCompiler = dontCompileAnno.value();\n+            TestFormat.check(dontCompileCompiler != Compiler.ANY,\n+                             \"Cannot have @DontCompile(Compiler.ANY) and @ForceCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel != CompLevel.ANY,\n@@ -446,2 +426,2 @@\n-            TestFormat.check(!CompLevel.overlapping(dontCompile, forceCompile),\n-                             \"Overlapping compilation levels with @ForceCompile and @DontCompile at \" + ex);\n+            TestFormat.check(forceCompileLevel.isNotCompilationLevelOfCompiler(dontCompileCompiler),\n+                             \"Overlapping compilation level and compiler with @ForceCompile and @DontCompile at \" + ex);\n@@ -455,3 +435,5 @@\n-        WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n-        WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n-        WHITE_BOX.testSetDontInlineMethod(m, true);\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n@@ -460,1 +442,1 @@\n-    private void dontCompileAtLevel(Executable ex, CompLevel compLevel) {\n+    private void dontCompileWithCompiler(Executable ex, Compiler compiler) {\n@@ -462,1 +444,1 @@\n-            System.out.println(\"dontCompileAtLevel \" + ex + \" , level = \" + compLevel.name());\n+            System.out.println(\"dontCompileWithCompiler \" + ex + \" , compiler = \" + compiler.name());\n@@ -464,3 +446,3 @@\n-        WHITE_BOX.makeMethodNotCompilable(ex, compLevel.getValue(), true);\n-        WHITE_BOX.makeMethodNotCompilable(ex, compLevel.getValue(), false);\n-        if (compLevel == CompLevel.ANY) {\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        if (compiler == Compiler.ANY) {\n@@ -478,3 +460,0 @@\n-            if (EXCLUDE_RANDOM) {\n-                complevel = CompLevel.join(complevel, excludeRandomly(ex));\n-            }\n@@ -482,1 +461,4 @@\n-                complevel = flipCompLevel(complevel);\n+                complevel = complevel.flipCompLevel();\n+            }\n+            if (EXCLUDE_RANDOM) {\n+                complevel = complevel.excludeCompilationRandomly(ex);\n@@ -535,2 +517,2 @@\n-        if (!XCOMP) {\n-            \/\/ Don't inline test methods. Don't care when -Xcomp set.\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            \/\/ Don't inline test methods by default. Do not apply this when -DIgnoreCompilerControls=true is set.\n@@ -541,1 +523,1 @@\n-            compLevel = flipCompLevel(compLevel);\n+            compLevel = compLevel.flipCompLevel();\n@@ -544,1 +526,1 @@\n-            compLevel = CompLevel.join(compLevel, excludeRandomly(m));\n+            compLevel = compLevel.excludeCompilationRandomly(m);\n@@ -591,12 +573,0 @@\n-    private static CompLevel flipCompLevel(CompLevel compLevel) {\n-        switch (compLevel) {\n-            case C1, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n-                return CompLevel.C2;\n-            }\n-            case C2 -> {\n-                return CompLevel.C1;\n-            }\n-        }\n-        return compLevel;\n-    }\n-\n@@ -906,2 +876,2 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C1)) {\n-            TestRun.check(compiledByC1(m) != TriState.Yes || PerMethodTrapLimit == 0 || !ProfileInterpreter,\n+        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n@@ -914,1 +884,1 @@\n-            TestRun.check(compiledByC2(m) != TriState.Yes || PerMethodTrapLimit == 0 || !ProfileInterpreter,\n+            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n@@ -923,1 +893,1 @@\n-        return (USE_COMPILER && !XCOMP && !TEST_C1 &&\n+        return (USE_COMPILER && !XCOMP && !IGNORE_COMPILER_CONTROLS && !TEST_C1 &&\n@@ -949,1 +919,1 @@\n-        TriState triState = compiledAtLevel(m, CompLevel.C1);\n+        TriState triState = compiledAtLevel(m, CompLevel.C1_SIMPLE);\n@@ -968,1 +938,1 @@\n-                case C1, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n+                case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n@@ -979,1 +949,1 @@\n-        if (!USE_COMPILER || XCOMP || TEST_C1 ||\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n@@ -1145,2 +1115,2 @@\n-            if (isCompiled || TestFrameworkExecution.XCOMP) {\n-                \/\/ Don't wait for compilation if -Xcomp is enabled.\n+            if (isCompiled || TestFrameworkExecution.XCOMP || TestFrameworkExecution.EXCLUDE_RANDOM) {\n+                \/\/ Don't wait for compilation if -Xcomp is enabled or if we are randomly excluding methods from compilation.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkExecution.java","additions":101,"deletions":131,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.test.lib.hotspot.ir_framework.Compiler;\n@@ -348,3 +349,0 @@\n-    @DontCompile(CompLevel.SKIP)\n-    public void invalidSkip2() {}\n-\n@@ -354,5 +352,2 @@\n-    @DontCompile(CompLevel.WAIT_FOR_COMPILATION)\n-    public void invalidWaitForCompilation2() {}\n-\n-    @ForceCompile(CompLevel.C1)\n-    @DontCompile(CompLevel.C1)\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C1)\n@@ -362,1 +357,1 @@\n-    @DontCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C2)\n@@ -366,1 +361,1 @@\n-    @DontCompile(CompLevel.C1)\n+    @DontCompile(Compiler.C1)\n@@ -370,1 +365,1 @@\n-    @DontCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C2)\n@@ -376,6 +371,0 @@\n-\n-    @DontCompile(CompLevel.C1_LIMITED_PROFILE)\n-    public void invalidDontCompile1() {}\n-\n-    @DontCompile(CompLevel.C1_FULL_PROFILE)\n-    public void invalidDontCompile2() {}\n@@ -419,1 +408,1 @@\n-    @Test(compLevel = CompLevel.C1)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestBadFormat.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.test.lib.Asserts;\n@@ -67,1 +66,1 @@\n-    @Test(compLevel = CompLevel.C1)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n@@ -74,1 +73,1 @@\n-        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1);\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_SIMPLE);\n@@ -114,1 +113,1 @@\n-    @Test(compLevel = CompLevel.C1)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n@@ -168,1 +167,1 @@\n-    @Test(compLevel = CompLevel.C1)\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestCompLevels.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.test.lib.hotspot.ir_framework.Compiler;\n@@ -171,1 +172,1 @@\n-    @DontCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.ANY)\n@@ -215,1 +216,1 @@\n-    @DontCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.ANY)\n@@ -222,1 +223,1 @@\n-    @DontCompile(CompLevel.C1)\n+    @DontCompile(Compiler.C1)\n@@ -229,1 +230,1 @@\n-    @DontCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C2)\n@@ -248,1 +249,1 @@\n-    @ForceCompile(CompLevel.C1)\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n@@ -268,2 +269,2 @@\n-    @ForceCompile(CompLevel.C1)\n-    @DontCompile(CompLevel.C2)\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C2)\n@@ -275,1 +276,1 @@\n-    @DontCompile(CompLevel.C1)\n+    @DontCompile(Compiler.C1)\n@@ -296,1 +297,1 @@\n-        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1\"), CompLevel.C1);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1\"), CompLevel.C1_SIMPLE);\n@@ -300,1 +301,1 @@\n-        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC1DontC2\"), CompLevel.C1);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC1DontC2\"), CompLevel.C1_SIMPLE);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestControls.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework.tests;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.hotspot.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @summary Test -DIgnoreCompilerControls property flag.\n+ * @library \/test\/lib\n+ * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestDIgnoreCompilerControls\n+ *\/\n+\n+public class TestDIgnoreCompilerControls {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            TestFramework.run();\n+        } else {\n+            OutputAnalyzer oa = run(\"true\");\n+            oa.shouldHaveExitValue(0);\n+            oa = run(\"false\");\n+            oa.shouldNotHaveExitValue(0);\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail run\"), \"did not find run: \" + oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail check\"), \"did not find check\" + oa.getOutput());\n+        }\n+    }\n+\n+    private static OutputAnalyzer run(String flagValue) throws Exception {\n+        OutputAnalyzer oa;\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                \"-Dtest.class.path=\" + Utils.TEST_CLASS_PATH, \"-Dtest.jdk=\" + Utils.TEST_JDK,\n+                \"-Dtest.vm.opts=-DIgnoreCompilerControls=\" + flagValue,\n+                \"jdk.test.lib.hotspot.ir_framework.tests.TestDIgnoreCompilerControls\", flagValue);\n+        oa = ProcessTools.executeProcess(process);\n+        return oa;\n+    }\n+\n+    @Test\n+    public void test() { }\n+\n+    @Run(test = \"test\")\n+    @Warmup(10000)\n+    public void run(RunInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"run\", RunInfo.class)), \"fail run\");\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    public void test2() {}\n+\n+\n+    @Check(test = \"test2\")\n+    public void check(TestInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"check\", TestInfo.class)), \"fail check\");\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDIgnoreCompilerControls.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}