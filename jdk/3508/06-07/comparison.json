{"files":[{"patch":"@@ -110,1 +110,1 @@\n-        return TestFrameworkExecution.USE_COMPILER && !TestFrameworkExecution.TEST_C1;\n+        return TestVM.USE_COMPILER && !TestVM.TEST_C1;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * Abstract super class for base, checked and custom run tests.\n+ *\/\n+abstract class AbstractTest {\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    protected static final int TEST_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"TestCompilationTimeout\", \"10000\"));\n+    protected static final int WAIT_FOR_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"WaitForCompilationTimeout\", \"10000\"));\n+    protected static final boolean VERIFY_OOPS = (Boolean)WHITE_BOX.getVMFlag(\"VerifyOops\");\n+\n+    protected final int warmupIterations;\n+    protected final boolean skip;\n+\n+    AbstractTest(int warmupIterations, boolean skip) {\n+        this.warmupIterations = warmupIterations;\n+        this.skip = skip;\n+    }\n+\n+    protected boolean shouldCompile(DeclaredTest test) {\n+        return test.getCompLevel() != CompLevel.SKIP;\n+    }\n+\n+    abstract String getName();\n+\n+    \/**\n+     * Should test be executed?\n+     *\/\n+    public boolean isSkipped() {\n+        return skip;\n+    }\n+\n+    \/**\n+     * See {@link CompLevel#WAIT_FOR_COMPILATION}.\n+     *\/\n+    protected static boolean isWaitForCompilation(DeclaredTest test) {\n+        return test.getCompLevel() == CompLevel.WAIT_FOR_COMPILATION;\n+    }\n+\n+    protected static Object createInvocationTarget(Method method) {\n+        Class<?> clazz = method.getDeclaringClass();\n+        Object invocationTarget;\n+        if (Modifier.isStatic(method.getModifiers())) {\n+            invocationTarget = null;\n+        } else {\n+            try {\n+                Constructor<?> constructor = clazz.getDeclaredConstructor();\n+                constructor.setAccessible(true);\n+                invocationTarget = constructor.newInstance();\n+            } catch (Exception e) {\n+                throw new TestRunException(\"Could not create instance of \" + clazz\n+                                           + \". Make sure there is a constructor without arguments.\", e);\n+            }\n+        }\n+        return invocationTarget;\n+    }\n+\n+    \/**\n+     * Run the associated test.\n+     *\/\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        onStart();\n+        for (int i = 0; i < warmupIterations; i++) {\n+            invokeTest();\n+        }\n+        onWarmupFinished();\n+        compileTest();\n+        \/\/ Always run the test as a last step of the test execution.\n+        invokeTest();\n+    }\n+\n+    protected void onStart() {\n+        \/\/ Do nothing by default.\n+    }\n+\n+    abstract protected void invokeTest();\n+\n+    abstract protected void onWarmupFinished();\n+\n+    abstract protected void compileTest();\n+\n+    protected void compileMethod(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Compile method \" + testMethod + \" after warm-up...\");\n+        }\n+\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+        enqueueMethodForCompilation(test);\n+\n+        do {\n+            if (!WHITE_BOX.isMethodQueuedForCompilation(testMethod)) {\n+                if (elapsed > 0) {\n+                    if (TestVM.VERBOSE) {\n+                        System.out.println(testMethod + \" is not in queue anymore due to compiling it simultaneously on \" +\n+                                           \"a different level. Enqueue again.\");\n+                    }\n+                    enqueueMethodForCompilation(test);\n+                }\n+            }\n+            if (maybeCodeBufferOverflow && elapsed > 1000 && !WHITE_BOX.isMethodCompiled(testMethod, false)) {\n+                \/\/ Let's disable VerifyOops temporarily and retry.\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+                WHITE_BOX.clearMethodState(testMethod);\n+                enqueueMethodForCompilation(test);\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            }\n+\n+            if (WHITE_BOX.getMethodCompilationLevel(testMethod, false) == test.getCompLevel().getValue()) {\n+                break;\n+            }\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < TEST_COMPILATION_TIMEOUT);\n+        TestRun.check(elapsed < TEST_COMPILATION_TIMEOUT,\n+                      \"Could not compile \" + testMethod + \" after \" + TEST_COMPILATION_TIMEOUT\/1000 + \"s\");\n+        checkCompilationLevel(test);\n+    }\n+\n+    private void enqueueMethodForCompilation(DeclaredTest test) {\n+        TestVM.enqueueForCompilation(test.getTestMethod(), test.getCompLevel());\n+    }\n+\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WHITE_BOX.getMethodCompilationLevel(test.getTestMethod()));\n+        TestRun.check(level == test.getCompLevel(),  \"Compilation level should be \" + test.getCompLevel().name()\n+                                                     + \" (requested) but was \" + level.name() + \" for \" + test.getTestMethod());\n+    }\n+\n+    final protected void waitForCompilation(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        boolean stateCleared = false;\n+        long elapsed;\n+        do {\n+            elapsed = System.currentTimeMillis() - started;\n+            int level = WHITE_BOX.getMethodCompilationLevel(testMethod);\n+            if (maybeCodeBufferOverflow && elapsed > 5000\n+                && (!WHITE_BOX.isMethodCompiled(testMethod, false) || level != test.getCompLevel().getValue())) {\n+                retryDisabledVerifyOops(testMethod, stateCleared);\n+                stateCleared = true;\n+            } else {\n+                invokeTest();\n+            }\n+\n+            boolean isCompiled = WHITE_BOX.isMethodCompiled(testMethod, false);\n+            if (TestVM.VERBOSE) {\n+                System.out.println(\"Is \" + testMethod + \" compiled? \" + isCompiled);\n+            }\n+            if (isCompiled || TestVM.XCOMP || TestVM.EXCLUDE_RANDOM) {\n+                \/\/ Don't wait for compilation if -Xcomp is enabled or if we are randomly excluding methods from compilation.\n+                return;\n+            }\n+        } while (elapsed < WAIT_FOR_COMPILATION_TIMEOUT);\n+        throw new TestRunException(testMethod + \" not compiled after waiting for \"\n+                                   + WAIT_FOR_COMPILATION_TIMEOUT\/1000 + \" s\");\n+    }\n+\n+    \/**\n+     * If it takes too long, try to disable Verify Oops.\n+     *\/\n+    private void retryDisabledVerifyOops(Method testMethod, boolean stateCleared) {\n+        System.out.println(\"Temporarily disabling VerifyOops\");\n+        try {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+            if (!stateCleared) {\n+                WHITE_BOX.clearMethodState(testMethod);\n+            }\n+            invokeTest();\n+        } finally {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            System.out.println(\"Re-enabled VerifyOops\");\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * A base test only consists of a single @Test method. See {@link Test} for more details and its precise definition.\n+ *\/\n+class BaseTest extends AbstractTest {\n+    private final DeclaredTest test;\n+    protected final Method testMethod;\n+    protected final TestInfo testInfo;\n+    protected final Object invocationTarget;\n+    private final boolean shouldCompile;\n+    private final boolean waitForCompilation;\n+\n+    public BaseTest(DeclaredTest test, boolean skip) {\n+        super(test.getWarmupIterations(), skip);\n+        this.test = test;\n+        this.testMethod = test.getTestMethod();\n+        this.testInfo = new TestInfo(test);\n+        this.invocationTarget = createInvocationTarget(testMethod);\n+        this.shouldCompile = shouldCompile(test);\n+        this.waitForCompilation = isWaitForCompilation(test);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Base Test: @Test \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return testMethod.getName();\n+    }\n+\n+    @Override\n+    protected void onStart() {\n+        test.printFixedRandomArguments();\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        testInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void invokeTest() {\n+        verify(invokeTestMethod());\n+    }\n+\n+    private Object invokeTestMethod() {\n+        try {\n+            if (test.hasArguments()) {\n+                return testMethod.invoke(invocationTarget, test.getArguments());\n+            } else {\n+                return testMethod.invoke(invocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod\n+                                       + \". Used arguments: \" + test.getArgumentsString(), e);\n+        }\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (shouldCompile) {\n+            if (waitForCompilation) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify the result\n+     *\/\n+    public void verify(Object result) { \/* no verification in BaseTests *\/ }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/BaseTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * A checked test is an extension of a base test with additional verification done in a @Check method.\n+ * See {@link Check} for more details and its precise definition.\n+ *\/\n+class CheckedTest extends BaseTest {\n+    private final Method checkMethod;\n+    private final CheckAt checkAt;\n+    private final Parameter parameter;\n+    private final Object checkInvocationTarget;\n+\n+    enum Parameter {\n+        NONE, RETURN_ONLY, TEST_INFO_ONLY, BOTH\n+    }\n+\n+    public CheckedTest(DeclaredTest test, Method checkMethod, Check checkSpecification, Parameter parameter, boolean excludedByUser) {\n+        super(test, excludedByUser);\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        checkMethod.setAccessible(true);\n+        this.checkMethod = checkMethod;\n+        this.checkAt = checkSpecification.when();\n+        this.parameter = parameter;\n+        \/\/ Use the same invocation target\n+        if (Modifier.isStatic(checkMethod.getModifiers())) {\n+            this.checkInvocationTarget = null;\n+        } else {\n+            \/\/ Use the same invocation target as the test method if check method is non-static.\n+            this.checkInvocationTarget = this.invocationTarget != null ? this.invocationTarget : createInvocationTarget(checkMethod);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Checked Test: @Check \" + checkMethod.getName() + \" - @Test: \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return checkMethod.getName();\n+    }\n+\n+    @Override\n+    public void verify(Object result) {\n+        boolean shouldVerify = false;\n+        switch (checkAt) {\n+            case EACH_INVOCATION -> shouldVerify = true;\n+            case COMPILED -> shouldVerify = !testInfo.isWarmUp();\n+        }\n+        if (shouldVerify) {\n+            try {\n+                switch (parameter) {\n+                    case NONE -> checkMethod.invoke(checkInvocationTarget);\n+                    case RETURN_ONLY -> checkMethod.invoke(checkInvocationTarget, result);\n+                    case TEST_INFO_ONLY -> checkMethod.invoke(checkInvocationTarget, testInfo);\n+                    case BOTH -> checkMethod.invoke(checkInvocationTarget, result, testInfo);\n+                }\n+            } catch (Exception e) {\n+                throw new TestRunException(\"There was an error while invoking @Check method \" + checkMethod, e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CheckedTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -155,1 +155,1 @@\n-        Compiler compiler = TestFrameworkExecution.excludeRandomly(ex);\n+        Compiler compiler = TestVM.excludeRandomly(ex);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CompLevel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A custom run test allows the user to have full control over how the @Test method is invoked by specifying\n+ * a dedicated @Run method. See {@link Run} for more details and its precise definition.\n+ *\/\n+class CustomRunTest extends AbstractTest {\n+    private final Method runMethod;\n+    private final RunMode mode;\n+    private final Object runInvocationTarget;\n+    private final List<DeclaredTest> tests;\n+    private final RunInfo runInfo;\n+\n+    public CustomRunTest(Method runMethod, Warmup warmUpAnno, Run runSpecification, List<DeclaredTest> tests, boolean skip) {\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        super(warmUpAnno != null ? warmUpAnno.value() : TestVM.WARMUP_ITERATIONS, skip);\n+        TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + runMethod);\n+        runMethod.setAccessible(true);\n+        this.runMethod = runMethod;\n+        this.runInvocationTarget = createInvocationTarget(runMethod);\n+        this.mode = runSpecification.mode();\n+        this.tests = tests;\n+        this.runInfo = new RunInfo(tests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"Custom Run Test: @Run: \" + runMethod.getName() + \" - @Test\";\n+        if (tests.size() == 1) {\n+            s += \": \" + tests.get(0).getTestMethod().getName();\n+        } else {\n+            s += \"s: {\" + tests.stream().map(t -> t.getTestMethod().getName())\n+                               .collect(Collectors.joining(\",\")) + \"}\";\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    String getName() {\n+        return runMethod.getName();\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        switch (mode) {\n+            case STANDALONE -> {\n+                runInfo.setWarmUpFinished();\n+                invokeTest();\n+            }\/\/ Invoke once but do not apply anything else.\n+            case NORMAL -> super.run();\n+        }\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        runInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (tests.size() == 1) {\n+            compileSingleTest();\n+        } else {\n+            compileMultipleTests();\n+        }\n+    }\n+\n+    private void compileSingleTest() {\n+        DeclaredTest test = tests.get(0);\n+        if (shouldCompile(test)) {\n+            if (isWaitForCompilation(test)) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    private void compileMultipleTests() {\n+        boolean anyWaitForCompilation = false;\n+        boolean anyCompileMethod = false;\n+        ExecutorService executor = Executors.newFixedThreadPool(tests.size());\n+        for (DeclaredTest test : tests) {\n+            if (shouldCompile(test)) {\n+                if (isWaitForCompilation(test)) {\n+                    anyWaitForCompilation = true;\n+                    executor.execute(() -> waitForCompilation(test));\n+                } else {\n+                    anyCompileMethod = true;\n+                    executor.execute(() -> compileMethod(test));\n+                }\n+            }\n+        }\n+        executor.shutdown();\n+        int timeout;\n+        if (anyCompileMethod && anyWaitForCompilation) {\n+            timeout = Math.max(WAIT_FOR_COMPILATION_TIMEOUT, TEST_COMPILATION_TIMEOUT) + 5000;\n+        } else if (anyWaitForCompilation) {\n+            timeout = WAIT_FOR_COMPILATION_TIMEOUT + 5000;\n+        } else {\n+            timeout = TEST_COMPILATION_TIMEOUT + 5000;\n+        }\n+        try {\n+            executor.awaitTermination(timeout, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            throw new TestRunException(\"Some compilations did not complete after \" + timeout\n+                                       + \"ms for @Run method \" + runMethod);\n+        }\n+    }\n+\n+    \/**\n+     * Do not directly run the test but rather the run method that is responsible for invoking the actual test.\n+     *\/\n+    @Override\n+    protected void invokeTest() {\n+        try {\n+            if (runMethod.getParameterCount() == 1) {\n+                runMethod.invoke(runInvocationTarget, runInfo);\n+            } else {\n+                runMethod.invoke(runInvocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Run method \" + runMethod, e);\n+        }\n+    }\n+\n+    @Override\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WhiteBox.getWhiteBox().getMethodCompilationLevel(test.getTestMethod()));\n+        if (level != test.getCompLevel()) {\n+            String message = \"Compilation level should be \" + test.getCompLevel().name() + \" (requested) but was \"\n+                             + level.name() + \" for \" + test.getTestMethod() + \".\";\n+            switch (mode) {\n+                case STANDALONE -> throw new TestFrameworkException(\"Should not be called for STANDALONE method \" + runMethod);\n+                case NORMAL -> message = message + System.lineSeparator() + \"Check your @Run method \" + runMethod\n+                                         + \" to ensure that \" + test.getTestMethod()\n+                                         + \" is called at least once in each iteration.\";\n+            }\n+            throw new TestRunException(message);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CustomRunTest.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"flag VM\". It uses the\n+ * Whitebox API to determine the necessary additional flags to run the test VM (e.g. to do IR matching). It returns\n+ * the flags over the dedicated TestFramework socket.\n+ *\/\n+class FlagVM {\n+    private static final WhiteBox WHITE_BOX;\n+    static final String TEST_VM_FLAGS_FILE_PREFIX = \"test-vm-flags-pid-\";\n+    static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+            TEST_VM_FLAGS_FILE = TEST_VM_FLAGS_FILE_PREFIX + ProcessTools.getProcessId() + TEST_VM_FLAGS_FILE_POSTFIX;\n+        } catch (UnsatisfiedLinkError e) {\n+            throw new TestFrameworkException(\"Could not load WhiteBox\", e);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Could not get process id\", e);\n+        }\n+    }\n+\n+    private static final String TEST_VM_FLAGS_FILE;\n+\n+    static final String TEST_VM_FLAGS_DELIMITER = \" \";\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL =\n+            CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    private static final boolean TEST_C1 = TIERED_COMPILATION\n+                                           && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean REQUESTED_VERIFY_IR = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private static final boolean VERIFY_IR = REQUESTED_VERIFY_IR && USE_COMPILER && !EXCLUDE_RANDOM && !FLIP_C1_C2 && !TEST_C1;\n+\n+    private static String[] getPrintFlags() {\n+        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n+    }\n+\n+    \/**\n+     * Main entry point of the flag VM.\n+     *\/\n+    public static void main(String[] args) {\n+        String testClassName = args[0];\n+        if (VERBOSE) {\n+            System.out.println(\"FlagVM main() called. Prepare test VM flags to run class \" + testClassName);\n+        }\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find test class \" + testClassName, e);\n+        }\n+        emitTestVMFlags(prepareTestVmFlags(testClass));\n+    }\n+\n+    \/**\n+     * Emit test VM flags to the dedicated test VM flags file to parse them from the TestFramework \"driver\" VM again\n+     * which adds them to the test VM.\n+     *\/\n+    private static void emitTestVMFlags(ArrayList<String> flags) {\n+        try (var bw = Files.newBufferedWriter(Paths.get(TEST_VM_FLAGS_FILE))) {\n+            bw.write(String.join(TEST_VM_FLAGS_DELIMITER, flags));\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while writing to file \" + TEST_VM_FLAGS_FILE, e);\n+        }\n+    }\n+\n+    private static ArrayList<String> prepareTestVmFlags(Class<?> testClass) {\n+        return setupIrVerificationFlags(testClass);\n+    }\n+\n+    private static ArrayList<String> setupIrVerificationFlags(Class<?> testClass) {\n+        ArrayList<String> cmds = new ArrayList<>();\n+        if (VERIFY_IR) {\n+            \/\/ Add print flags for IR verification\n+            cmds.addAll(Arrays.asList(getPrintFlags()));\n+            cmds.add(\"-XX:+LogCompilation\");\n+            cmds.add(\"-XX:CompileCommand=log,\" + testClass.getCanonicalName() + \"::*\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintIdeal\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintOptoAssembly\");\n+            \/\/ Always trap for exception throwing to not confuse IR verification\n+            cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n+            cmds.add(\"-DShouldDoIRVerification=true\");\n+        } else {\n+            cmds.add(\"-DShouldDoIRVerification=false\");\n+        }\n+        return cmds;\n+    }\n+\n+    private static void addBoolOptionForClass(ArrayList<String> cmds, Class<?> testClass, String option) {\n+        cmds.add(\"-XX:CompileCommand=option,\" + testClass.getCanonicalName() + \"::*,bool,\" + option + \",true\");\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/FlagVM.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"flag\" VM with verification of proper termination. The flag VM determines\n+ * the flags required for the \"test\" VM. The flag VM writes these flags to a dedicated file which is then parsed by this\n+ * class after the termination of the flag VM.\n+ *\n+ * @see FlagVM\n+ *\/\n+class FlagVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+\n+    private final List<String> cmds;\n+    private final List<String> testVMFlags;\n+    private boolean shouldVerifyIR;\n+    private String testVMFlagsFile;\n+    private OutputAnalyzer oa;\n+\n+    FlagVMProcess(Class<?> testClass, List<String> additionalFlags) {\n+        cmds = new ArrayList<>();\n+        testVMFlags = new ArrayList<>();\n+        prepareVMFlags(testClass, additionalFlags);\n+        start();\n+        parseTestVMFlags();\n+    }\n+\n+    private void parseTestVMFlags() {\n+        String flags = readFlagsFromFile();\n+        if (VERBOSE) {\n+            System.out.println(\"Read data from \" + testVMFlagsFile + \":\");\n+            System.out.println(flags);\n+        }\n+        String patternString = \"(.*DShouldDoIRVerification=(true|false).*)\";\n+        Pattern pattern = Pattern.compile(patternString);\n+        Matcher matcher = pattern.matcher(flags);\n+        TestFramework.check(matcher.find(), \"Invalid flag encoding emitted by flag VM\");\n+        \/\/ Maybe we run with flags that make IR verification impossible\n+        shouldVerifyIR = Boolean.parseBoolean(matcher.group(2));\n+        testVMFlags.addAll(Arrays.asList(matcher.group(1).split(FlagVM.TEST_VM_FLAGS_DELIMITER)));\n+    }\n+\n+    private String readFlagsFromFile() {\n+        try (var br = Files.newBufferedReader(Paths.get(testVMFlagsFile))) {\n+            String flags = br.readLine();\n+            TestFramework.check(br.readLine() == null, testVMFlagsFile + \" should only contain one line.\");\n+            return flags;\n+\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading from file \" + testVMFlagsFile, e);\n+        }\n+    }\n+\n+    \/**\n+     * The flag VM needs White Box access to prepare all test VM flags. The flag VM will write the test VM flags to\n+     * a dedicated file which is afterwards parsed by the driver VM and added as flags to the test VM.\n+     *\/\n+    private void prepareVMFlags(Class<?> testClass, List<String> additionalFlags) {\n+        cmds.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        cmds.add(\"-cp\");\n+        cmds.add(Utils.TEST_CLASS_PATH);\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        \/\/ TestFramework and scenario flags might have an influence on the later used test VM flags. Add them as well.\n+        cmds.addAll(additionalFlags);\n+        cmds.add(FlagVM.class.getCanonicalName());\n+        cmds.add(testClass.getCanonicalName());\n+    }\n+\n+    private void start() {\n+        try {\n+            \/\/ Run \"flag\" VM with White Box access to determine the test VM flags and if IR verification should be done.\n+            oa = ProcessTools.executeTestJvm(cmds);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Failed to execute TestFramework flag VM\", e);\n+        }\n+        testVMFlagsFile = FlagVM.TEST_VM_FLAGS_FILE_PREFIX + oa.pid()\n+                          + FlagVM.TEST_VM_FLAGS_FILE_POSTFIX;\n+        checkFlagVMExitCode();\n+    }\n+\n+    private void checkFlagVMExitCode() {\n+        String flagVMOutput = oa.getOutput();\n+        int exitCode = oa.getExitValue();\n+        if (VERBOSE && exitCode == 0) {\n+            System.out.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.out.println(flagVMOutput);\n+        }\n+\n+        if (exitCode != 0) {\n+            System.err.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.err.println(flagVMOutput);\n+            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n+        }\n+    }\n+\n+    public List<String> getTestVMFlags() {\n+        return testVMFlags;\n+    }\n+\n+    public boolean shouldVerifyIR() {\n+        return shouldVerifyIR;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/FlagVMProcess.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -65,2 +65,4 @@\n-        parseHotspotPidFile();\n-        applyRules();\n+        if (!compilations.isEmpty()) {\n+            parseHotspotPidFile();\n+            applyRules();\n+        }\n@@ -478,2 +480,1 @@\n-            failuresBuilder.insert(0, (System.lineSeparator() + System.lineSeparator()\n-                                       + \"One or more @IR rules failed:\" + System.lineSeparator()\n+            failuresBuilder.insert(0, (\"One or more @IR rules failed:\" + System.lineSeparator()\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMatcher.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-        super(message);\n+        super(\"There were one or multiple IR rule failures. Please check stderr for more information.\");\n+        this.exceptionInfo = message;\n@@ -56,2 +57,2 @@\n-    void setExceptionInfo(String exceptionInfo) {\n-        this.exceptionInfo = exceptionInfo;\n+    void addCommandLine(String commandLine) {\n+        this.exceptionInfo = commandLine + System.lineSeparator() + exceptionInfo;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRViolationException.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-     * @return {@code true} if the framework compiled the test;\n+     * @return {@code true} if the framework skipped compilation of the test;\n@@ -105,1 +105,1 @@\n-     * @return {@code true} if the framework compiled the test;\n+     * @return {@code true} if the framework skipped compilation of the test;\n@@ -126,1 +126,1 @@\n-        return TestFrameworkExecution.isC1Compiled(testMethod);\n+        return TestVM.isC1Compiled(testMethod);\n@@ -142,1 +142,1 @@\n-        return TestFrameworkExecution.isC1Compiled(getMethod(testName));\n+        return TestVM.isC1Compiled(getMethod(testName));\n@@ -156,1 +156,1 @@\n-        return TestFrameworkExecution.isC2Compiled(testMethod);\n+        return TestVM.isC2Compiled(testMethod);\n@@ -172,1 +172,1 @@\n-        return TestFrameworkExecution.isC2Compiled(getMethod(testName));\n+        return TestVM.isC2Compiled(getMethod(testName));\n@@ -187,1 +187,1 @@\n-        return TestFrameworkExecution.isCompiledAtLevel(testMethod, compLevel);\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n@@ -204,1 +204,1 @@\n-        return TestFrameworkExecution.isCompiledAtLevel(getMethod(testName), compLevel);\n+        return TestVM.isCompiledAtLevel(getMethod(testName), compLevel);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/RunInfo.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n@@ -37,2 +35,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -67,3 +63,3 @@\n- * To specify additional flags, use {@link #runWithFlags(String...)}, {@link #addFlags(String...)},\n- * {@link #addScenarios(Scenario...)}, or {@link #runWithScenarios(Scenario...)} where the scenarios can also be used\n- * to run different flag combinations (instead of specifying multiple JTreg {@code @run} entries).\n+ * To specify additional flags, use {@link #runWithFlags(String...)}, {@link #addFlags(String...)}, or\n+ * {@link #addScenarios(Scenario...)} where the scenarios can also be used to run different flag combinations\n+ * (instead of specifying multiple JTreg {@code @run} entries).\n@@ -128,3 +124,2 @@\n-    static final String TEST_VM_FLAGS_START = \"##### TestFrameworkPrepareFlags - used by TestFramework #####\";\n-    static final String TEST_VM_FLAGS_DELIMITER = \" \";\n-    static final String TEST_VM_FLAGS_END = \"----- END -----\";\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+\n@@ -135,1 +130,1 @@\n-                                        - To also get the standard output of the test VM run with\\s\n+                                        - To also get the standard output of the test VM run with\n@@ -141,6 +136,0 @@\n-    private static final int WARMUP_ITERATIONS = Integer.getInteger(\"Warmup\", -1);\n-    private static final boolean PREFER_COMMAND_LINE_FLAGS = Boolean.getBoolean(\"PreferCommandLineFlags\");\n-    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n-    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n-    private static final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n-\n@@ -149,1 +138,0 @@\n-    private static String lastTestVMOutput;\n@@ -158,2 +146,0 @@\n-    private TestFrameworkSocket socket;\n-    private Scenario scenario;\n@@ -192,17 +178,0 @@\n-    \/**\n-     * Default flags that are added used for the test VM.\n-     *\/\n-    private static String[] getDefaultFlags() {\n-        return new String[] {\"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=quiet\"};\n-    }\n-\n-    \/**\n-     * Additional verification flags that are used if -DVerifyVM=true is with a debug build.\n-     *\/\n-    private static String[] getVerifyFlags() {\n-        return new String[] {\n-                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\",\n-                \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\", \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"\n-        };\n-    }\n-\n@@ -235,0 +204,2 @@\n+     *     <li><p>If you want to run your entire JTreg test with additional flags but for another test class then the one\n+     *            from which this method was called from, use {@link #addFlags(String...)}, use this method.<\/li>\n@@ -236,1 +207,1 @@\n-     *            {@link #runWithScenarios(Scenario...)}<\/li>\n+     *            {@link #addScenarios(Scenario...)}<\/li>\n@@ -243,21 +214,1 @@\n-        runWithFlags(walker.getCallerClass(), flags);\n-    }\n-\n-    \/**\n-     * Tests {@code testClass}. The test VM is called with the specified {@code flags}.\n-     * <ul>\n-     *     <li><p>The {@code flags} override any set VM or Javaoptions flags by JTreg by default.<p>\n-     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the JTreg VM and  Javaoptions flags over\n-     *            the specified {@code flags} of this method.<\/li>\n-     *     <li><p>If you want to run your entire JTreg test with additional flags, use this method.<\/li>\n-     *     <li><p>If you want to run your JTreg test with multiple flag combinations, use\n-     *            {@link #runWithScenarios(Scenario...)}<\/li>\n-     * <\/ul>\n-     *\n-     * @param testClass the class to be tested by the framework.\n-     * @param flags VM flags to be used for the test VM.\n-     *\n-     * @see #runWithFlags(String...)\n-     *\/\n-    public static void runWithFlags(Class<?> testClass, String... flags) {\n-        TestFramework framework = new TestFramework(testClass);\n+        TestFramework framework = new TestFramework(walker.getCallerClass());\n@@ -268,60 +219,0 @@\n-    \/**\n-     * Tests {@code testClass} which uses {@code helperClasses} that can specify additional compile command annotations\n-     * ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n-     * {@link DontInline @DontInline}) to be applied while testing {@code testClass} (also see description of\n-     * {@link TestFramework}).\n-     *\n-     * <p>\n-     * If a class is used by the test class that does not specify any compile command annotations, you do not\n-     * need to include it in {@code helperClasses}. If no helper class specifies any compile commands, consider\n-     * using {@link #run()} or {@link #run(Class)}.\n-     *\n-     * @param testClass the class to be tested by the framework.\n-     * @param helperClasses helper classes containing compile command annotations ({@link ForceCompile},\n-     *                      {@link DontCompile}, {@link ForceInline}, {@link DontInline}) to be applied\n-     *                      while testing {@code testClass} (also see description of {@link TestFramework}).\n-     *\/\n-    public static void runWithHelperClasses(Class<?> testClass, Class<?>... helperClasses) {\n-        TestFramework framework = new TestFramework(testClass);\n-        framework.addHelperClasses(helperClasses);\n-        framework.start();\n-    }\n-\n-    \/**\n-     * Tests the class from which this method was invoked from. A test VM is called for each scenario in {@code scenarios}\n-     * by using the specified flags in the scenario.\n-     * <ul>\n-     *     <li><p>If there is only one scenario, consider using {@link #runWithFlags(String...)}.<\/li>\n-     *     <li><p>The scenario flags override any VM or Javaoptions set by JTreg by default.<p>\n-     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the Java and VM options over the\n-     *            scenario flags.<\/li>\n-     * <\/ul>\n-     *\n-     * @param scenarios scenarios which specify specific flags for the test VM.\n-     *\/\n-    public static void runWithScenarios(Scenario... scenarios) {\n-        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-        runWithScenarios(walker.getCallerClass(), scenarios);\n-    }\n-\n-    \/**\n-     * Tests {@code testClass} A test VM is called for each scenario in {@code scenarios} by using the specified flags\n-     * in the scenario.\n-     * <ul>\n-     *     <li><p>If there is only one scenario, consider using {@link #runWithFlags(String...)}.<\/li>\n-     *     <li><p>The scenario flags override any VM or Javaoptions set by JTreg by default.<p>\n-     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the Java and VM options over the\n-     *            scenario flags.<\/li>\n-     * <\/ul>\n-     *\n-     * @param testClass the class to be tested by the framework.\n-     * @param scenarios scenarios which specify specific flags for the test VM.\n-     *\n-     * @see #runWithScenarios(Scenario...)\n-     *\/\n-    public static void runWithScenarios(Class<?> testClass, Scenario... scenarios) {\n-        TestFramework framework = new TestFramework(testClass);\n-        framework.addScenarios(scenarios);\n-        framework.start();\n-    }\n-\n@@ -417,1 +308,1 @@\n-                System.err.println(System.lineSeparator() + e.getExceptionInfo());\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + RERUN_HINT);\n@@ -422,1 +313,1 @@\n-                System.err.println(System.lineSeparator() + e.getExceptionInfo());\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + System.lineSeparator() + RERUN_HINT);\n@@ -432,1 +323,1 @@\n-     * {@link TestFrameworkExecution#WARMUP_ITERATIONS}) to be applied for all tests that do not specify an explicit\n+     * {@link TestVM#WARMUP_ITERATIONS}) to be applied for all tests that do not specify an explicit\n@@ -451,1 +342,1 @@\n-        return lastTestVMOutput;\n+        return TestVMProcess.getLastTestVMOutput();\n@@ -468,1 +359,1 @@\n-        TestFrameworkExecution.compile(m, compLevel);\n+        TestVM.compile(m, compLevel);\n@@ -477,1 +368,1 @@\n-        TestFrameworkExecution.deoptimize(m);\n+        TestVM.deoptimize(m);\n@@ -488,1 +379,1 @@\n-        return TestFrameworkExecution.isCompiled(m);\n+        return TestVM.isCompiled(m);\n@@ -499,1 +390,1 @@\n-        return TestFrameworkExecution.isC1Compiled(m);\n+        return TestVM.isC1Compiled(m);\n@@ -510,1 +401,1 @@\n-        return TestFrameworkExecution.isC2Compiled(m);\n+        return TestVM.isC2Compiled(m);\n@@ -522,1 +413,1 @@\n-        return TestFrameworkExecution.isCompiledAtLevel(m, compLevel);\n+        return TestVM.isCompiledAtLevel(m, compLevel);\n@@ -532,1 +423,1 @@\n-        TestFrameworkExecution.assertCompiled(m);\n+        TestVM.assertCompiled(m);\n@@ -542,1 +433,1 @@\n-        TestFrameworkExecution.assertNotCompiled(m);\n+        TestVM.assertNotCompiled(m);\n@@ -552,1 +443,1 @@\n-        TestFrameworkExecution.assertCompiledByC1(m);\n+        TestVM.assertCompiledByC1(m);\n@@ -562,1 +453,1 @@\n-        TestFrameworkExecution.assertCompiledByC2(m);\n+        TestVM.assertCompiledByC2(m);\n@@ -573,1 +464,1 @@\n-        TestFrameworkExecution.assertCompiledAtLevel(m, compLevel);\n+        TestVM.assertCompiledAtLevel(m, compLevel);\n@@ -583,1 +474,1 @@\n-        TestFrameworkExecution.assertDeoptimizedByC1(m);\n+        TestVM.assertDeoptimizedByC1(m);\n@@ -593,1 +484,1 @@\n-        TestFrameworkExecution.assertDeoptimizedByC2(m);\n+        TestVM.assertDeoptimizedByC2(m);\n@@ -692,4 +583,3 @@\n-                builder.append(errorMsg).append(System.lineSeparator()).append(irException.getExceptionInfo())\n-                       .append(e.getMessage());\n-            } else if (e instanceof TestVMException) {\n-                builder.append(errorMsg).append(System.lineSeparator()).append(((TestVMException) e).getExceptionInfo());\n+                builder.append(errorMsg).append(System.lineSeparator()).append(irException.getExceptionInfo());\n+            } else if (e instanceof TestVMException testVMException) {\n+                builder.append(errorMsg).append(System.lineSeparator()).append(testVMException.getExceptionInfo());\n@@ -734,2 +624,0 @@\n-        socket = TestFrameworkSocket.getSocket();\n-        this.scenario = scenario;\n@@ -748,1 +636,3 @@\n-            socket.start();\n+            String frameworkAndScenarioFlags = additionalFlags.isEmpty() ?\n+                    \"\" : \" - [\" + String.join(\", \", additionalFlags) + \"]\";\n+\n@@ -750,0 +640,1 @@\n+                \/\/ Only need to use flag VM if an IR verification is possibly done.\n@@ -751,1 +642,6 @@\n-                runFlagVM(additionalFlags);\n+                FlagVMProcess flagVMProcess = new FlagVMProcess(testClass, additionalFlags);\n+                shouldVerifyIR = flagVMProcess.shouldVerifyIR();\n+                if (shouldVerifyIR) {\n+                    \/\/ Add more flags for the test VM which are required to do IR verification.\n+                    additionalFlags.addAll(flagVMProcess.getTestVMFlags());\n+                } \/\/ else: Flag VM found a reason to not do IR verification.\n@@ -756,2 +652,1 @@\n-            String flagsString = additionalFlags.isEmpty() ? \"\" : \" - [\" + String.join(\", \", additionalFlags) + \"]\";\n-            System.out.println(\"Run Test VM\" + flagsString + \":\");\n+            System.out.println(\"Run Test VM\" + frameworkAndScenarioFlags + \":\");\n@@ -760,0 +655,3 @@\n+            if (scenario != null) {\n+                scenario.setTestVMOutput(TestVMProcess.getLastTestVMOutput());\n+            }\n@@ -761,1 +659,0 @@\n-            socket.close();\n@@ -783,49 +680,0 @@\n-    private void runFlagVM(List<String> additionalFlags) {\n-        ArrayList<String> cmds = prepareFlagVMFlags(additionalFlags);\n-        OutputAnalyzer oa;\n-        try {\n-            \/\/ Run \"flag\" VM with White Box access to determine the test VM flags and if IR verification should be done.\n-            oa = ProcessTools.executeTestJvm(cmds);\n-        } catch (Exception e) {\n-            throw new TestRunException(\"Failed to execute TestFramework flag VM\", e);\n-        }\n-        checkFlagVMExitCode(oa);\n-    }\n-\n-    \/**\n-     * The \"flag\" VM needs White Box access to prepare all test VM flags. It sends these as encoding over a socket to the\n-     * driver VM which afterwards parses the flags and adds them to the test VM.\n-     *\/\n-    private ArrayList<String> prepareFlagVMFlags(List<String> additionalFlags) {\n-        ArrayList<String> cmds = new ArrayList<>();\n-        cmds.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n-        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n-        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n-        cmds.add(\"-cp\");\n-        cmds.add(Utils.TEST_CLASS_PATH);\n-        cmds.add(\"-Xbootclasspath\/a:.\");\n-        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n-        cmds.add(\"-XX:+WhiteBoxAPI\");\n-        cmds.add(socket.getPortPropertyFlag());\n-        \/\/ TestFramework and scenario flags might have an influence on the later used test VM flags. Add them as well.\n-        cmds.addAll(additionalFlags);\n-        cmds.add(TestFrameworkPrepareFlags.class.getCanonicalName());\n-        cmds.add(testClass.getCanonicalName());\n-        return cmds;\n-    }\n-\n-    private void checkFlagVMExitCode(OutputAnalyzer oa) {\n-        String flagVMOutput = oa.getOutput();\n-        int exitCode = oa.getExitValue();\n-        if (VERBOSE && exitCode == 0) {\n-            System.out.println(\"--- OUTPUT TestFramework flag VM ---\");\n-            System.out.println(flagVMOutput);\n-        }\n-\n-        if (exitCode != 0) {\n-            System.err.println(\"--- OUTPUT TestFramework flag VM ---\");\n-            System.err.println(flagVMOutput);\n-            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n-        }\n-    }\n-\n@@ -833,24 +681,1 @@\n-        List<String> cmds = prepareTestVMFlags(additionalFlags);\n-        socket.start();\n-\n-        OutputAnalyzer oa;\n-        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(cmds);\n-        try {\n-            \/\/ Calls 'main' of TestFrameworkExecution to run all specified tests with commands 'cmds'.\n-            \/\/ Use executeProcess instead of executeTestJvm as we have already added the JTreg VM and\n-            \/\/ Java options in prepareTestVMFlags().\n-            oa = ProcessTools.executeProcess(process);\n-        } catch (Exception e) {\n-            throw new TestFrameworkException(\"Error while executing Test VM\", e);\n-        }\n-        JVMOutput output = new JVMOutput(oa, scenario, process);\n-        lastTestVMOutput = oa.getOutput();\n-        if (scenario != null) {\n-            scenario.setTestVMOutput(lastTestVMOutput);\n-        }\n-        String socketOutput = \"\";\n-        if (shouldVerifyIR || TESTLIST || EXCLUDELIST) {\n-            \/\/ Socket has only output to read if IR verification is done and\/or if a test list was provided by user\n-            socketOutput = socket.getOutputPrintStdout();\n-        }\n-        checkTestVMExitCode(output);\n+        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup);\n@@ -859,1 +684,1 @@\n-                new IRMatcher(output.getHotspotPidFileName(), socketOutput, testClass);\n+                new IRMatcher(testVMProcess.getHotspotPidFileName(), testVMProcess.getIrEncoding(), testClass);\n@@ -861,1 +686,1 @@\n-                e.setExceptionInfo(output.getExceptionInfo(scenario != null));\n+                e.addCommandLine(testVMProcess.getCommandLine());\n@@ -873,95 +698,0 @@\n-    private List<String> prepareTestVMFlags(List<String> additionalFlags) {\n-        ArrayList<String> cmds = new ArrayList<>();\n-        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n-        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n-        \/\/ Need White Box access in test VM.\n-        cmds.add(\"-Xbootclasspath\/a:.\");\n-        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n-        cmds.add(\"-XX:+WhiteBoxAPI\");\n-        String[] jtregVMFlags = Utils.getTestJavaOpts();\n-        if (!PREFER_COMMAND_LINE_FLAGS) {\n-            cmds.addAll(Arrays.asList(jtregVMFlags));\n-        }\n-        cmds.addAll(additionalFlags);\n-        cmds.addAll(getTestVMFlags());\n-\n-        if (PREFER_COMMAND_LINE_FLAGS) {\n-            \/\/ Prefer flags set via the command line over the ones set by scenarios.\n-            cmds.addAll(Arrays.asList(jtregVMFlags));\n-        }\n-\n-        if (WARMUP_ITERATIONS < 0 && defaultWarmup != -1) {\n-            \/\/ Only use the set warmup for the framework if not overridden by a valid -DWarmup property set by a test.\n-            cmds.add(\"-DWarmup=\" + defaultWarmup);\n-        }\n-\n-        \/\/ Add server property flag that enables test VM to print encoding for IR verification last and debug messages.\n-        cmds.add(socket.getPortPropertyFlag());\n-\n-        cmds.add(TestFrameworkExecution.class.getName());\n-        cmds.add(testClass.getName());\n-        if (helperClasses != null) {\n-            helperClasses.forEach(c -> cmds.add(c.getName()));\n-        }\n-        return cmds;\n-    }\n-\n-    \/**\n-     * Parse the test VM flags as prepared by the flag VM. Additionally check the property flag DShouldDoIRVerification\n-     * to determine if IR matching should be done or not.\n-     *\/\n-    private List<String> getTestVMFlags() {\n-        List<String> flagList = new ArrayList<>();\n-\n-        if (VERIFY_VM) {\n-            flagList.addAll(Arrays.asList(getVerifyFlags()));\n-        }\n-\n-        flagList.addAll(Arrays.asList(getDefaultFlags()));\n-\n-        if (shouldVerifyIR) {\n-            String flags = socket.getOutput();\n-            if (VERBOSE) {\n-                System.out.println(\"Read sent data from flag VM from socket:\");\n-                System.out.println(flags);\n-            }\n-            String patternString = \"(?<=\" + TestFramework.TEST_VM_FLAGS_START + \"\\\\R)\" + \"(.*DShouldDoIRVerification=(true|false).*)\\\\R\"\n-                                   + \"(?=\" + IREncodingPrinter.END + \")\";\n-            Pattern pattern = Pattern.compile(patternString);\n-            Matcher matcher = pattern.matcher(flags);\n-            check(matcher.find(), \"Invalid flag encoding emitted by flag VM\");\n-            \/\/ Maybe we run with flags that make IR verification impossible\n-            shouldVerifyIR = Boolean.parseBoolean(matcher.group(2));\n-            flagList.addAll(Arrays.asList(matcher.group(1).split(TEST_VM_FLAGS_DELIMITER)));\n-        }\n-        return flagList;\n-    }\n-\n-    private void checkTestVMExitCode(JVMOutput vmOutput) {\n-        final int exitCode = vmOutput.getExitCode();\n-        if (EXCLUDE_RANDOM || REPORT_STDOUT || (VERBOSE && exitCode == 0)) {\n-            System.out.println(\"--- OUTPUT TestFramework test VM ---\");\n-            System.out.println(vmOutput.getOutput());\n-        }\n-\n-        if (exitCode != 0) {\n-            throwTestVMException(vmOutput);\n-        }\n-    }\n-\n-    private void throwTestVMException(JVMOutput vmOutput) {\n-        String stdErr = vmOutput.getStderr();\n-        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n-            Pattern pattern = Pattern.compile(\"Violations \\\\(\\\\d+\\\\)[\\\\s\\\\S]*(?=\/============\/)\");\n-            Matcher matcher = pattern.matcher(stdErr);\n-            TestFramework.check(matcher.find(), \"Must find violation matches\");\n-            throw new TestFormatException(System.lineSeparator() + System.lineSeparator() + matcher.group());\n-        } else if (stdErr.contains(\"NoTestsRunException\")) {\n-            shouldVerifyIR = false;\n-            throw new NoTestsRunException(\">>> No tests run due to empty set specified with -DTest and\/or -DExclude. \" +\n-                                          \"Make sure to define a set of at least one @Test method\");\n-        } else {\n-            throw new TestVMException(vmOutput.getExceptionInfo(scenario != null));\n-        }\n-    }\n-\n@@ -974,71 +704,0 @@\n-\n-\/**\n- * Class to encapsulate information about the test VM output, the run process and the scenario.\n- *\/\n-class JVMOutput {\n-    private final Scenario scenario;\n-    private final OutputAnalyzer oa;\n-    private final ProcessBuilder process;\n-    private final String hotspotPidFileName;\n-\n-    JVMOutput(OutputAnalyzer oa, Scenario scenario, ProcessBuilder process) {\n-        this.oa = oa;\n-        this.scenario = scenario;\n-        this.process = process;\n-        this.hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n-    }\n-\n-    public Scenario getScenario() {\n-        return scenario;\n-    }\n-\n-    public String getCommandLine() {\n-        return \"Command Line:\" + System.lineSeparator() + String.join(\" \", process.command())\n-               + System.lineSeparator();\n-    }\n-\n-    public int getExitCode() {\n-        return oa.getExitValue();\n-    }\n-\n-    public String getOutput() {\n-        return oa.getOutput();\n-    }\n-\n-    public String getStdout() {\n-        return oa.getStdout();\n-    }\n-\n-    public String getStderr() {\n-        return oa.getStderr();\n-    }\n-\n-    public String getHotspotPidFileName() {\n-        return hotspotPidFileName;\n-    }\n-\n-    \/**\n-     * Get more detailed information about the exception in a pretty format.\n-     *\/\n-    public String getExceptionInfo(boolean stripRerunHint) {\n-        int exitCode = getExitCode();\n-        String stdErr = getStderr();\n-        String rerunHint = \"\";\n-        String stdOut = \"\";\n-        if (exitCode == 134) {\n-            stdOut = System.lineSeparator() + System.lineSeparator() + \"Standard Output\" + System.lineSeparator()\n-                     + \"---------------\" + System.lineSeparator() + getOutput();\n-        } else if (!stripRerunHint) {\n-            rerunHint = TestFramework.RERUN_HINT;\n-        }\n-        if (exitCode == 0) {\n-            \/\/ IR exception\n-            return getCommandLine() + rerunHint;\n-        } else {\n-            return \"TestFramework test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n-                   + System.lineSeparator() + getCommandLine() + System.lineSeparator() + System.lineSeparator()\n-                   + \"Error Output\" + System.lineSeparator() + \"------------\" + System.lineSeparator() + stdErr\n-                   + System.lineSeparator() + System.lineSeparator() + rerunHint;\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFramework.java","additions":47,"deletions":388,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -1,1422 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.Utils;\n-import sun.hotspot.WhiteBox;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-\/**\n- * This class' main method is called from {@link TestFramework} and represents the so-called \"test VM\". The class is\n- * the heart of the framework and is responsible for executing all the specified tests in the test class. It uses the\n- * Whitebox API and reflection to achieve this task.\n- *\/\n-public class TestFrameworkExecution {\n-    private static final WhiteBox WHITE_BOX;\n-\n-    static {\n-        try {\n-            WHITE_BOX = WhiteBox.getWhiteBox();\n-        } catch (UnsatisfiedLinkError e) {\n-            System.err.println(System.lineSeparator() + \"\"\"\n-                               ##########################################################\n-                                - Did you call a test-related interface method from\n-                                  TestFramework in main() of your test? Make sure to\n-                                  only call setup\/run methods and no checks or\n-                                  assertions from main() of your test!\n-                                - Are you rerunning the test VM (TestFrameworkExecution)\n-                                  directly after a JTreg run? Make sure to start it\n-                                  from within JTwork\/scratch and with the flag\n-                                  -DReproduce=true!\n-                               ##########################################################\n-                               \"\"\");\n-            throw e;\n-        }\n-    }\n-\n-    \/**\n-     * The default number of warm-up iterations used to warm up a {@link Test} annotated test method.\n-     * Use {@code -DWarmup=XY} to specify a different default value. An individual warm-up can also be\n-     * set by specifying a {@link Warmup} iteration for a test.\n-     *\/\n-    public static final int WARMUP_ITERATIONS = Integer.parseInt(System.getProperty(\"Warmup\", \"2000\"));\n-\n-    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n-    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL = CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n-    static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n-\n-    static final boolean XCOMP = Platform.isComp();\n-    static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n-    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\");\n-    static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n-    static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n-    private static final String TESTLIST = System.getProperty(\"Test\", \"\");\n-    private static final String EXCLUDELIST = System.getProperty(\"Exclude\", \"\");\n-    private static final boolean DUMP_REPLAY = Boolean.getBoolean(\"DumpReplay\");\n-    private static final boolean GC_AFTER = Boolean.getBoolean(\"GCAfter\");\n-    private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(\"ShuffleTests\", \"true\"));\n-    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by flag VM.\n-    private static final boolean PRINT_VALID_IR_RULES = Boolean.getBoolean(\"ShouldDoIRVerification\");\n-    protected static final long PER_METHOD_TRAP_LIMIT = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n-    protected static final boolean PROFILE_INTERPRETER = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n-    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n-    private static final boolean IGNORE_COMPILER_CONTROLS = Boolean.getBoolean(\"IgnoreCompilerControls\");\n-\n-    private final HashMap<Method, DeclaredTest> declaredTests = new HashMap<>();\n-    private final List<AbstractTest> allTests = new ArrayList<>();\n-    private final HashMap<String, Method> testMethodMap = new HashMap<>();\n-    private final List<String> excludeList;\n-    private final List<String> testList;\n-    private Set<Class<?>> helperClasses = null; \/\/ Helper classes that contain framework annotations to be processed.\n-    private final IREncodingPrinter irMatchRulePrinter;\n-    private final Class<?> testClass;\n-    private final Map<Executable, CompLevel> forceCompileMap = new HashMap<>();\n-\n-    private TestFrameworkExecution(Class<?> testClass) {\n-        TestRun.check(testClass != null, \"Test class cannot be null\");\n-        this.testClass = testClass;\n-        this.testList = createTestFilterList(TESTLIST, testClass);\n-        this.excludeList = createTestFilterList(EXCLUDELIST, testClass);\n-\n-        if (PRINT_VALID_IR_RULES) {\n-            irMatchRulePrinter = new IREncodingPrinter();\n-        } else {\n-            irMatchRulePrinter = null;\n-        }\n-    }\n-\n-    \/**\n-     * Parse \"test1,test2,test3\" into a list.\n-     *\/\n-    private static List<String> createTestFilterList(String list, Class<?> testClass) {\n-        List<String> filterList = null;\n-        if (!list.isEmpty()) {\n-            String classPrefix = testClass.getSimpleName() + \".\";\n-            filterList = new ArrayList<>(Arrays.asList(list.split(\",\")));\n-            for (int i = filterList.size() - 1; i >= 0; i--) {\n-                String test = filterList.get(i);\n-                if (test.indexOf(\".\") > 0) {\n-                    if (test.startsWith(classPrefix)) {\n-                        test = test.substring(classPrefix.length());\n-                        filterList.set(i, test);\n-                    } else {\n-                        filterList.remove(i);\n-                    }\n-                }\n-            }\n-        }\n-        return filterList;\n-    }\n-\n-    \/**\n-     * Main entry point of the test VM.\n-     *\/\n-    public static void main(String[] args) {\n-        try {\n-            String testClassName = args[0];\n-            System.out.println(\"Framework main(), about to run tests in class \" + testClassName);\n-            Class<?> testClass = getClassObject(testClassName, \"test\");\n-\n-            TestFrameworkExecution framework = new TestFrameworkExecution(testClass);\n-            framework.addHelperClasses(args);\n-            framework.start();\n-        } finally {\n-            TestFrameworkSocket.closeClientSocket();\n-        }\n-    }\n-\n-    protected static Class<?> getClassObject(String className, String classType) {\n-        try {\n-            return Class.forName(className);\n-        } catch (Exception e) {\n-            throw new TestRunException(\"Could not find \" + classType + \" class\", e);\n-        }\n-    }\n-\n-    \/**\n-     * Set up all helper classes and verify they are specified correctly.\n-     *\/\n-    private void addHelperClasses(String[] args) {\n-        Class<?>[] helperClassesList = getHelperClasses(args);\n-        if (helperClassesList != null) {\n-            TestRun.check(Arrays.stream(helperClassesList).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n-            this.helperClasses = new HashSet<>();\n-\n-            for (Class<?> helperClass : helperClassesList) {\n-                if (Arrays.stream(testClass.getDeclaredClasses()).anyMatch(c -> c == helperClass)) {\n-                    \/\/ Nested class of test class is automatically treated as helper class\n-                    TestFormat.failNoThrow(\"Nested \" + helperClass + \" inside test \" + testClass + \" is implicitly\"\n-                                           + \" treated as helper class and does not need to be specified as such.\");\n-                    continue;\n-                }\n-                TestRun.check(!this.helperClasses.contains(helperClass), \"Cannot add the same class twice: \" + helperClass);\n-                this.helperClasses.add(helperClass);\n-            }\n-        }\n-    }\n-\n-    private static Class<?>[] getHelperClasses(String[] args) {\n-        if (args.length == 1) {\n-            return null;\n-        }\n-        Class<?>[] helperClasses = new Class<?>[args.length - 1]; \/\/ First argument is test class\n-        for (int i = 1; i < args.length; i++) {\n-            String helperClassName = args[i];\n-            helperClasses[i - 1] = getClassObject(helperClassName, \"helper\");\n-        }\n-        return helperClasses;\n-    }\n-\n-    private void checkHelperClass(Class<?> clazz) {\n-        checkAnnotationsInClass(clazz, \"helper\");\n-        for (Class<?> c : clazz.getDeclaredClasses()) {\n-            checkAnnotationsInClass(c, \"nested (and helper)\");\n-        }\n-    }\n-\n-    private void checkAnnotationsInClass(Class<?> c, String clazzType) {\n-        Method[] methods = c.getDeclaredMethods();\n-        for (Method m : methods) {\n-            TestFormat.checkNoThrow(getAnnotation(m, Test.class) == null,\n-                                    \"Cannot use @Test annotation in \" + clazzType + \" \" + c + \" at \" + m);\n-            TestFormat.checkNoThrow(getAnnotation(m, Run.class) == null,\n-                                    \"Cannot use @Run annotation in \" + clazzType + \" \" + c + \" at \" + m);\n-            TestFormat.checkNoThrow(getAnnotation(m, Check.class) == null,\n-                                    \"Cannot use @Check annotation in \" + clazzType + \" \" + c + \" at \" + m);\n-        }\n-    }\n-\n-    \/**\n-     * Only called by internal tests testing the framework itself. Accessed by reflection. Not exposed to normal users.\n-     *\/\n-    private static void runTestsOnSameVM(Class<?> testClass) {\n-        if (testClass == null) {\n-            StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-            testClass = walker.getCallerClass();\n-        }\n-        TestFrameworkExecution framework = new TestFrameworkExecution(testClass);\n-        framework.start();\n-    }\n-\n-    \/**\n-     * Once everything is initialized and set up, start collecting tests and executing them afterwards.\n-     *\/\n-    private void start() {\n-        setupTests();\n-        checkForcedCompilationsCompleted();\n-        runTests();\n-    }\n-\n-    private void setupTests() {\n-        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n-            checkAnnotationsInClass(clazz, \"inner\");\n-        }\n-        if (DUMP_REPLAY) {\n-            addReplay();\n-        }\n-        \/\/ Make sure to first setup test methods and make them non-inlineable and only then process compile commands.\n-        setupDeclaredTests();\n-        processControlAnnotations(testClass);\n-        processHelperClasses();\n-        setupCheckedAndCustomRunTests();\n-\n-        \/\/ All remaining tests are simple base tests without check or specific way to run them.\n-        addBaseTests();\n-        if (PRINT_VALID_IR_RULES) {\n-            irMatchRulePrinter.emit();\n-        }\n-        TestFormat.reportIfAnyFailures();\n-        declaredTests.clear();\n-        testMethodMap.clear();\n-    }\n-\n-    private void addBaseTests() {\n-        declaredTests.forEach((m, test) -> {\n-            if (test.getAttachedMethod() == null) {\n-                try {\n-                    Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n-                    TestFormat.check(argumentsAnno != null || m.getParameterCount() == 0, \"Missing @Arguments annotation to define arguments of \" + m);\n-                    BaseTest baseTest = new BaseTest(test, shouldExcludeTest(m.getName()));\n-                    allTests.add(baseTest);\n-                    if (PRINT_VALID_IR_RULES) {\n-                       irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n-                    }\n-                } catch (TestFormatException e) {\n-                    \/\/ Failure logged. Continue and report later.\n-                }\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Check if user wants to exclude this test by checking the -DTest and -DExclude lists.\n-     *\/\n-    private boolean shouldExcludeTest(String testName) {\n-        boolean hasTestList = testList != null;\n-        boolean hasExcludeList = excludeList != null;\n-        if (hasTestList) {\n-            return !testList.contains(testName) || (hasExcludeList && excludeList.contains(testName));\n-        } else if (hasExcludeList) {\n-            return excludeList.contains(testName);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Generate replay compilation files.\n-     *\/\n-    private void addReplay() {\n-        String directive = \"[{ match: \\\"*.*\\\", DumpReplay: true }]\";\n-        TestFramework.check(WHITE_BOX.addCompilerDirective(directive) == 1, \"Failed to add DUMP_REPLAY directive\");\n-    }\n-\n-    private void processControlAnnotations(Class<?> clazz) {\n-        if (IGNORE_COMPILER_CONTROLS) {\n-            return;\n-        }\n-        \/\/ Also apply compile commands to all inner classes of 'clazz'.\n-        ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n-        classes.add(clazz);\n-        for (Class<?> c : classes) {\n-            applyClassAnnotations(c);\n-            List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n-            Collections.addAll(executables, c.getDeclaredConstructors());\n-            for (Executable ex : executables) {\n-                checkClassAnnotations(ex);\n-                try {\n-                    applyIndependentCompilationCommands(ex);\n-                } catch (TestFormatException e) {\n-                    \/\/ Failure logged. Continue and report later.\n-                }\n-            }\n-\n-            \/\/ Only force compilation now because above annotations affect inlining\n-            for (Executable ex : executables) {\n-                try {\n-                    applyForceCompileCommand(ex);\n-                } catch (TestFormatException e) {\n-                    \/\/ Failure logged. Continue and report later.\n-                }\n-            }\n-        }\n-    }\n-\n-    private void applyClassAnnotations(Class<?> c) {\n-        ForceCompileClassInitializer anno = getAnnotation(c, ForceCompileClassInitializer.class);\n-        if (anno == null) {\n-            return;\n-        }\n-\n-        \/\/ Compile class initializer\n-        CompLevel level = anno.value();\n-        if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n-            TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n-                                   \"@ForceCompileClassInitializer at \" + c);\n-            return;\n-        }\n-        level = restrictCompLevel(anno.value());\n-        if (level != CompLevel.SKIP) {\n-            \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n-            getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n-            TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n-                                    \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n-                                    + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n-                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n-        }\n-    }\n-\n-    private void checkClassAnnotations(Executable ex) {\n-        TestFormat.checkNoThrow(getAnnotation(ex, ForceCompileClassInitializer.class) == null,\n-                                \"@ForceCompileClassInitializer only allowed at classes but not at method \" + ex);\n-    }\n-\n-    \/**\n-     * Exclude a method from compilation with a compiler randomly. Return the compiler for which the method was made\n-     * not compilable.\n-     *\/\n-    static Compiler excludeRandomly(Executable ex) {\n-        Compiler compiler;\n-        switch (Utils.getRandomInstance().nextInt() % 3) {\n-            case 1 -> compiler = Compiler.C1;\n-            case 2 -> compiler = Compiler.C2;\n-            default -> compiler = Compiler.ANY;\n-        }\n-        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n-        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n-        System.out.println(\"Excluding from \" + compiler.name() + \" compilation: \" + ex);\n-        return compiler;\n-    }\n-\n-    private void applyIndependentCompilationCommands(Executable ex) {\n-        ForceInline forceInlineAnno = getAnnotation(ex, ForceInline.class);\n-        DontInline dontInlineAnno = getAnnotation(ex, DontInline.class);\n-        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n-        DontCompile dontCompileAnno = getAnnotation(ex, DontCompile.class);\n-        checkCompilationCommandAnnotations(ex, forceInlineAnno, dontInlineAnno, forceCompileAnno, dontCompileAnno);\n-        \/\/ First handle inline annotations\n-        if (dontInlineAnno != null) {\n-            WHITE_BOX.testSetDontInlineMethod(ex, true);\n-        } else if (forceInlineAnno != null) {\n-            WHITE_BOX.testSetForceInlineMethod(ex, true);\n-        }\n-        if (dontCompileAnno != null) {\n-            dontCompileWithCompiler(ex, dontCompileAnno.value());\n-        }\n-        if (EXCLUDE_RANDOM && getAnnotation(ex, Test.class) == null && forceCompileAnno == null && dontCompileAnno == null) {\n-            \/\/ Randomly exclude helper methods from compilation\n-            if (Utils.getRandomInstance().nextBoolean()) {\n-                excludeRandomly(ex);\n-            }\n-        }\n-    }\n-\n-    private void checkCompilationCommandAnnotations(Executable ex, ForceInline forceInlineAnno, DontInline dontInlineAnno, ForceCompile forceCompileAnno, DontCompile dontCompileAnno) {\n-        Test testAnno = getAnnotation(ex, Test.class);\n-        Run runAnno = getAnnotation(ex, Run.class);\n-        Check checkAnno = getAnnotation(ex, Check.class);\n-        TestFormat.check((testAnno == null && runAnno == null && checkAnno == null) || Stream.of(forceCompileAnno, dontCompileAnno, forceInlineAnno, dontInlineAnno).noneMatch(Objects::nonNull),\n-                         \"Cannot use explicit compile command annotations (@ForceInline, @DontInline, \" +\n-                         \"@ForceCompile or @DontCompile) together with @Test, @Check or @Run: \" + ex + \". Use compLevel in @Test for fine tuning.\");\n-        if (Stream.of(forceInlineAnno, dontCompileAnno, dontInlineAnno).filter(Objects::nonNull).count() > 1) {\n-            \/\/ Failure\n-            TestFormat.check(dontCompileAnno == null || dontInlineAnno == null,\n-                             \"@DontInline is implicitely done with @DontCompile annotation at \" + ex);\n-            TestFormat.fail(\"Cannot mix @ForceInline, @DontInline and @DontCompile at the same time at \" + ex);\n-        }\n-        TestFormat.check(forceInlineAnno == null || dontInlineAnno == null, \"Cannot have @ForceInline and @DontInline at the same time at \" + ex);\n-        if (forceCompileAnno != null && dontCompileAnno != null) {\n-            CompLevel forceCompileLevel = forceCompileAnno.value();\n-            Compiler dontCompileCompiler = dontCompileAnno.value();\n-            TestFormat.check(dontCompileCompiler != Compiler.ANY,\n-                             \"Cannot have @DontCompile(Compiler.ANY) and @ForceCompile at the same time at \" + ex);\n-            TestFormat.check(forceCompileLevel != CompLevel.ANY,\n-                             \"Cannot have @ForceCompile(CompLevel.ANY) and @DontCompile at the same time at \" + ex);\n-            TestFormat.check(forceCompileLevel.isNotCompilationLevelOfCompiler(dontCompileCompiler),\n-                             \"Overlapping compilation level and compiler with @ForceCompile and @DontCompile at \" + ex);\n-        }\n-    }\n-\n-    \/**\n-     * Exlude the method from compilation and make sure it is not inlined.\n-     *\/\n-    private void dontCompileAndDontInlineMethod(Method m) {\n-        if (!IGNORE_COMPILER_CONTROLS) {\n-            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n-            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n-            WHITE_BOX.testSetDontInlineMethod(m, true);\n-        }\n-    }\n-\n-    private void dontCompileWithCompiler(Executable ex, Compiler compiler) {\n-        if (VERBOSE) {\n-            System.out.println(\"dontCompileWithCompiler \" + ex + \" , compiler = \" + compiler.name());\n-        }\n-        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n-        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n-        if (compiler == Compiler.ANY) {\n-            WHITE_BOX.testSetDontInlineMethod(ex, true);\n-        }\n-    }\n-\n-    private void applyForceCompileCommand(Executable ex) {\n-        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n-        if (forceCompileAnno != null) {\n-            CompLevel complevel = forceCompileAnno.value();\n-            TestFormat.check(complevel != CompLevel.SKIP && complevel != CompLevel.WAIT_FOR_COMPILATION,\n-                             \"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in @ForceCompile at \" + ex);\n-            complevel = restrictCompLevel(forceCompileAnno.value());\n-            if (FLIP_C1_C2) {\n-                complevel = complevel.flipCompLevel();\n-            }\n-            if (EXCLUDE_RANDOM) {\n-                complevel = complevel.excludeCompilationRandomly(ex);\n-            }\n-            if (complevel != CompLevel.SKIP) {\n-                enqueueForCompilation(ex, complevel);\n-                forceCompileMap.put(ex, complevel);\n-            }\n-        }\n-    }\n-\n-    static void enqueueForCompilation(Executable ex, CompLevel requestedCompLevel) {\n-        if (TestFrameworkExecution.VERBOSE) {\n-            System.out.println(\"enqueueForCompilation \" + ex + \", level = \" + requestedCompLevel);\n-        }\n-        CompLevel compLevel = restrictCompLevel(requestedCompLevel);\n-        if (compLevel != CompLevel.SKIP) {\n-            WHITE_BOX.enqueueMethodForCompilation(ex, compLevel.getValue());\n-        } else {\n-            System.out.println(\"Skipped compilation on level \" + requestedCompLevel + \" due to VM flags not allowing it.\");\n-        }\n-    }\n-\n-    \/**\n-     * Setup @Test annotated method an add them to the declaredTests map to have a convenient way of accessing them\n-     * once setting up a framework test (base  checked, or custom run test).\n-     *\/\n-    private void setupDeclaredTests() {\n-        for (Method m : testClass.getDeclaredMethods()) {\n-            Test testAnno = getAnnotation(m, Test.class);\n-            try {\n-                if (testAnno != null) {\n-                    addDeclaredTest(m);\n-                } else {\n-                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n-                    TestFormat.checkNoThrow(!m.isAnnotationPresent(Warmup.class) || getAnnotation(m, Run.class) != null,\n-                                     \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n-                }\n-            } catch (TestFormatException e) {\n-                \/\/ Failure logged. Continue and report later.\n-            }\n-        }\n-        TestFormat.checkNoThrow(!declaredTests.isEmpty(), \"Did not specify any @Test methods in \" + testClass);\n-    }\n-\n-    private void addDeclaredTest(Method m) {\n-        Test testAnno = getAnnotation(m, Test.class);\n-        checkTestAnnotations(m, testAnno);\n-        Warmup warmup = getAnnotation(m, Warmup.class);\n-        int warmupIterations = WARMUP_ITERATIONS;\n-        if (warmup != null) {\n-            warmupIterations = warmup.value();\n-            TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + m);\n-        }\n-\n-        if (!IGNORE_COMPILER_CONTROLS) {\n-            \/\/ Don't inline test methods by default. Do not apply this when -DIgnoreCompilerControls=true is set.\n-            WHITE_BOX.testSetDontInlineMethod(m, true);\n-        }\n-        CompLevel compLevel = restrictCompLevel(testAnno.compLevel());\n-        if (FLIP_C1_C2) {\n-            compLevel = compLevel.flipCompLevel();\n-        }\n-        if (EXCLUDE_RANDOM) {\n-            compLevel = compLevel.excludeCompilationRandomly(m);\n-        }\n-        DeclaredTest test = new DeclaredTest(m, ArgumentValue.getArguments(m), compLevel, warmupIterations);\n-        declaredTests.put(m, test);\n-        testMethodMap.put(m.getName(), m);\n-    }\n-\n-    private void checkTestAnnotations(Method m, Test testAnno) {\n-        TestFormat.check(!testMethodMap.containsKey(m.getName()),\n-                         \"Cannot overload two @Test methods: \" + m + \", \" + testMethodMap.get(m.getName()));\n-        TestFormat.check(testAnno != null, m + \" must be a method with a @Test annotation\");\n-\n-        Check checkAnno = getAnnotation(m, Check.class);\n-        Run runAnno = getAnnotation(m, Run.class);\n-        TestFormat.check(checkAnno == null && runAnno == null,\n-                         m + \" has invalid @Check or @Run annotation while @Test annotation is present.\");\n-\n-        TestFormat.checkNoThrow(Arrays.stream(m.getParameterTypes()).noneMatch(AbstractInfo.class::isAssignableFrom),\n-                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as parameter type at \" +\n-                                \"@Test method \" + m);\n-\n-        TestFormat.checkNoThrow(!AbstractInfo.class.isAssignableFrom(m.getReturnType()),\n-                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as return type at \" +\n-                                \"@Test method \" + m);\n-    }\n-\n-\n-    \/**\n-     * Get the appropriate level as permitted by the test scenario and VM flags.\n-     *\/\n-    private static CompLevel restrictCompLevel(CompLevel compLevel) {\n-        if (!USE_COMPILER) {\n-            return CompLevel.SKIP;\n-        }\n-        if (compLevel == CompLevel.ANY) {\n-            \/\/ Use highest available compilation level by default (usually C2).\n-            compLevel = TIERED_COMPILATION_STOP_AT_LEVEL;\n-        }\n-        if (!TIERED_COMPILATION && compLevel.getValue() < CompLevel.C2.getValue()) {\n-            return CompLevel.SKIP;\n-        }\n-        if (TIERED_COMPILATION && compLevel.getValue() > TIERED_COMPILATION_STOP_AT_LEVEL.getValue()) {\n-            return CompLevel.SKIP;\n-        }\n-        return compLevel;\n-    }\n-\n-    \/**\n-     * Verify that the helper classes do not contain illegal framework annotations and then apply the actions as\n-     * specified by the different helper class annotations.\n-     *\/\n-    private void processHelperClasses() {\n-        if (helperClasses != null) {\n-            for (Class<?> helperClass : helperClasses) {\n-                \/\/ Process the helper classes and apply the explicit compile commands\n-                TestFormat.checkNoThrow(helperClass != testClass,\n-                                        \"Cannot specify test \" + testClass + \" as helper class, too.\");\n-                checkHelperClass(helperClass);\n-                processControlAnnotations(helperClass);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * First set up checked (with @Check) and custom run tests (with @Run). All remaining unmatched\/unused @Test methods\n-     * are treated as base tests and set up as such later.\n-     *\/\n-    private void setupCheckedAndCustomRunTests() {\n-        for (Method m : testClass.getDeclaredMethods()) {\n-            Check checkAnno = getAnnotation(m, Check.class);\n-            Run runAnno = getAnnotation(m, Run.class);\n-            Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n-            try {\n-                TestFormat.check(argumentsAnno == null || (checkAnno == null && runAnno == null),\n-                                 \"Cannot have @Argument annotation in combination with @Run or @Check at \" + m);\n-                if (checkAnno != null) {\n-                    addCheckedTest(m, checkAnno, runAnno);\n-                } else if (runAnno != null) {\n-                    addCustomRunTest(m, runAnno);\n-                }\n-            } catch (TestFormatException e) {\n-                \/\/ Failure logged. Continue and report later.\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Set up a checked test by first verifying the correct format of the @Test and @Check method and then adding it\n-     * to the allTests list which keeps track of all framework tests that are eventually executed.\n-     *\/\n-    private void addCheckedTest(Method m, Check checkAnno, Run runAnno) {\n-        Method testMethod = testMethodMap.get(checkAnno.test());\n-        DeclaredTest test = declaredTests.get(testMethod);\n-        checkCheckedTest(m, checkAnno, runAnno, testMethod, test);\n-        test.setAttachedMethod(m);\n-        CheckedTest.Parameter parameter = getCheckedTestParameter(m, testMethod);\n-        dontCompileAndDontInlineMethod(m);\n-        CheckedTest checkedTest = new CheckedTest(test, m, checkAnno, parameter, shouldExcludeTest(testMethod.getName()));\n-        allTests.add(checkedTest);\n-        if (PRINT_VALID_IR_RULES) {\n-            \/\/ Only need to emit IR verification information if IR verification is actually performed.\n-            irMatchRulePrinter.emitRuleEncoding(m, checkedTest.isSkipped());\n-        }\n-    }\n-\n-    private void checkCheckedTest(Method m, Check checkAnno, Run runAnno, Method testMethod, DeclaredTest test) {\n-        TestFormat.check(runAnno == null, m + \" has invalid @Run annotation while @Check annotation is present.\");\n-        TestFormat.check(testMethod != null, \"Did not find associated test method \\\"\" + m.getDeclaringClass().getName()\n-                                             + \".\" + checkAnno.test() + \"\\\" for @Check at \" + m);\n-        TestFormat.check(test != null, \"Missing @Test annotation for associated test method \" + testMethod + \" for @Check at \" + m);\n-        Method attachedMethod = test.getAttachedMethod();\n-        TestFormat.check(attachedMethod == null,\n-                         \"Cannot use @Test \" + testMethod + \" for more than one @Run or one @Check method. Found: \" + m + \", \" + attachedMethod);\n-    }\n-\n-    \/**\n-     * Only allow parameters as specified in {@link Check}.\n-     *\/\n-    private CheckedTest.Parameter getCheckedTestParameter(Method m, Method testMethod) {\n-        boolean firstParameterTestInfo = m.getParameterCount() > 0 && m.getParameterTypes()[0].equals(TestInfo.class);\n-        boolean secondParameterTestInfo = m.getParameterCount() > 1 && m.getParameterTypes()[1].equals(TestInfo.class);\n-        CheckedTest.Parameter parameter = null;\n-        Class<?> testReturnType = testMethod.getReturnType();\n-        switch (m.getParameterCount()) {\n-            case 0 -> parameter = CheckedTest.Parameter.NONE;\n-            case 1 -> {\n-                TestFormat.checkNoThrow(firstParameterTestInfo || m.getParameterTypes()[0] == testReturnType,\n-                                        \"Single-parameter version of @Check method \" + m + \" must match return type of @Test \" + testMethod);\n-                parameter = firstParameterTestInfo ? CheckedTest.Parameter.TEST_INFO_ONLY : CheckedTest.Parameter.RETURN_ONLY;\n-            }\n-            case 2 -> {\n-                TestFormat.checkNoThrow(m.getParameterTypes()[0] == testReturnType && secondParameterTestInfo,\n-                                        \"Two-parameter version of @Check method \" + m + \" must provide as first parameter the same\"\n-                                        + \" return type as @Test method \" + testMethod + \" and as second parameter an object of \" + TestInfo.class);\n-                parameter = CheckedTest.Parameter.BOTH;\n-            }\n-            default -> TestFormat.failNoThrow(\"@Check method \" + m + \" must provide either a none, single or two-parameter variant.\");\n-        }\n-        return parameter;\n-    }\n-\n-    \/**\n-     * Set up a custom run test by first verifying the correct format of the @Test and @Run method and then adding it\n-     * to the allTests list which keeps track of all framework tests that are eventually executed.\n-     *\/\n-    private void addCustomRunTest(Method m, Run runAnno) {\n-        checkRunMethod(m, runAnno);\n-        List<DeclaredTest> tests = new ArrayList<>();\n-        boolean shouldExcludeTest = true;\n-        for (String testName : runAnno.test()) {\n-            try {\n-                Method testMethod = testMethodMap.get(testName);\n-                DeclaredTest test = declaredTests.get(testMethod);\n-                checkCustomRunTest(m, testName, testMethod, test, runAnno.mode());\n-                test.setAttachedMethod(m);\n-                tests.add(test);\n-                \/\/ Only exclude custom run test if all test methods excluded\n-                shouldExcludeTest &= shouldExcludeTest(testMethod.getName());\n-            } catch (TestFormatException e) {\n-                \/\/ Logged, continue.\n-            }\n-        }\n-        if (tests.isEmpty()) {\n-            return; \/\/ There was a format violation. Return.\n-        }\n-        dontCompileAndDontInlineMethod(m);\n-        CustomRunTest customRunTest = new CustomRunTest(m, getAnnotation(m, Warmup.class), runAnno, tests, shouldExcludeTest);\n-        allTests.add(customRunTest);\n-        if (PRINT_VALID_IR_RULES) {\n-            tests.forEach(test -> irMatchRulePrinter.emitRuleEncoding(test.getTestMethod(), customRunTest.isSkipped()));\n-        }\n-    }\n-\n-    \/**\n-     * Only allow parameters as specified in {@link Run}.\n-     *\/\n-    private void checkCustomRunTest(Method m, String testName, Method testMethod, DeclaredTest test, RunMode runMode) {\n-        TestFormat.check(testMethod != null, \"Did not find associated @Test method \\\"\"  + m.getDeclaringClass().getName()\n-                                             + \".\" + testName + \"\\\" specified in @Run at \" + m);\n-        TestFormat.check(test != null,\n-                         \"Missing @Test annotation for associated test method \" + testName + \" for @Run at \" + m);\n-        Method attachedMethod = test.getAttachedMethod();\n-        TestFormat.check(attachedMethod == null,\n-                         \"Cannot use @Test \" + testMethod + \" for more than one @Run\/@Check method. Found: \"\n-                         + m + \", \" + attachedMethod);\n-        TestFormat.check(!test.hasArguments(),\n-                         \"Cannot use @Arguments at test method \" + testMethod + \" in combination with @Run method \" + m);\n-        Warmup warmupAnno = getAnnotation(testMethod, Warmup.class);\n-        TestFormat.checkNoThrow(warmupAnno == null,\n-                         \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n-                         + m + \". Use @Warmup at @Run method instead.\");\n-        Test testAnno = getAnnotation(testMethod, Test.class);\n-        TestFormat.checkNoThrow(runMode != RunMode.STANDALONE || testAnno.compLevel() == CompLevel.ANY,\n-                                \"Setting explicit compilation level for @Test method \" + testMethod + \" has no effect \"\n-                                + \"when used with STANDALONE @Run method \" + m);\n-    }\n-\n-    private void checkRunMethod(Method m, Run runAnno) {\n-        TestFormat.check(runAnno.test().length > 0, \"@Run method \" + m + \" must specify at least one test method\");\n-        TestFormat.checkNoThrow(m.getParameterCount() == 0 || (m.getParameterCount() == 1 && m.getParameterTypes()[0].equals(RunInfo.class)),\n-                                \"@Run method \" + m + \" must specify either no parameter or exactly one \" + RunInfo.class + \" parameter.\");\n-        Warmup warmupAnno = getAnnotation(m, Warmup.class);\n-        TestFormat.checkNoThrow(warmupAnno == null || runAnno.mode() != RunMode.STANDALONE,\n-                                \"Cannot set @Warmup at @Run method \" + m + \" when used with RunMode.STANDALONE. The @Run method is only invoked once.\");\n-    }\n-\n-    private static <T extends Annotation> T getAnnotation(AnnotatedElement element, Class<T> c) {\n-        T[] annos =  element.getAnnotationsByType(c);\n-        TestFormat.check(annos.length < 2, element + \" has duplicated annotations\");\n-        return Arrays.stream(annos).findFirst().orElse(null);\n-    }\n-\n-    \/**\n-     * Ensure that all compilations that were enforced (added to compilation queue) by framework annotations are\n-     * completed. Wait if necessary for a short amount of time for their completion.\n-     *\/\n-    private void checkForcedCompilationsCompleted() {\n-        if (forceCompileMap.isEmpty()) {\n-            return;\n-        }\n-        final long started = System.currentTimeMillis();\n-        long elapsed;\n-        do {\n-            forceCompileMap.entrySet().removeIf(entry -> WHITE_BOX.getMethodCompilationLevel(entry.getKey()) == entry.getValue().getValue());\n-            if (forceCompileMap.isEmpty()) {\n-                \/\/ All @ForceCompile methods are compiled at the requested level.\n-                return;\n-            }\n-            \/\/ Retry again if not yet compiled.\n-            forceCompileMap.forEach(TestFrameworkExecution::enqueueForCompilation);\n-            elapsed = System.currentTimeMillis() - started;\n-        } while (elapsed < 5000);\n-        StringBuilder builder = new StringBuilder();\n-        forceCompileMap.forEach((key, value) -> builder.append(\"- \").append(key).append(\" at CompLevel.\").append(value)\n-                                                       .append(System.lineSeparator()));\n-        throw new TestRunException(\"Could not force compile the following @ForceCompile methods:\"\n-                                   + System.lineSeparator() + builder.toString());\n-    }\n-\n-    \/**\n-     * Once all framework tests are collected, they are run in this method.\n-     *\/\n-    private void runTests() {\n-        TreeMap<Long, String> durations = (PRINT_TIMES || VERBOSE) ? new TreeMap<>() : null;\n-        long startTime = System.nanoTime();\n-        List<AbstractTest> testList;\n-        boolean testFilterPresent = testFilterPresent();\n-        if (testFilterPresent) {\n-            \/\/ Only run the specified tests by the user filters -DTest and\/or -DExclude.\n-            testList = allTests.stream().filter(test -> !test.isSkipped()).collect(Collectors.toList());\n-            if (testList.isEmpty()) {\n-                \/\/ Throw an exception to inform the user about an empty specified test set with -DTest and\/or -DExclude\n-                throw new NoTestsRunException();\n-            }\n-        } else {\n-            testList = allTests;\n-        }\n-\n-        if (SHUFFLE_TESTS) {\n-            \/\/ Execute tests in random order (execution sequence affects profiling). This is done by default.\n-            Collections.shuffle(testList, Utils.getRandomInstance());\n-        }\n-        StringBuilder builder = new StringBuilder();\n-        int failures = 0;\n-\n-        \/\/ Execute all tests and keep track of each exception that is thrown. These are then reported once all tests\n-        \/\/ are executing. This prevents a premature exit without running all tests.\n-        for (AbstractTest test : testList) {\n-            if (VERBOSE) {\n-                System.out.println(\"Run \" + test.toString());\n-            } else if (testFilterPresent) {\n-                TestFrameworkSocket.write(\"Run \" + test.toString(), \"testfilter\", true);\n-            }\n-            try {\n-                test.run();\n-            } catch (TestRunException e) {\n-                StringWriter sw = new StringWriter();\n-                PrintWriter pw = new PrintWriter(sw);\n-                e.printStackTrace(pw);\n-                builder.append(test.toString()).append(\":\").append(System.lineSeparator()).append(sw.toString())\n-                       .append(System.lineSeparator()).append(System.lineSeparator());\n-                failures++;\n-            }\n-            if (PRINT_TIMES || VERBOSE) {\n-                long endTime = System.nanoTime();\n-                long duration = (endTime - startTime);\n-                durations.put(duration, test.getName());\n-                if (VERBOSE) {\n-                    System.out.println(\"Done \" + test.getName() + \": \" + duration + \" ns = \" + (duration \/ 1000000) + \" ms\");\n-                }\n-            }\n-            if (GC_AFTER) {\n-                System.out.println(\"doing GC\");\n-                System.gc();\n-            }\n-        }\n-\n-        \/\/ Print execution times\n-        if (VERBOSE || PRINT_TIMES) {\n-            System.out.println(System.lineSeparator() + System.lineSeparator() + \"Test execution times:\");\n-            for (Map.Entry<Long, String> entry : durations.entrySet()) {\n-                System.out.format(\"%-10s%15d ns\" + System.lineSeparator(), entry.getValue() + \":\", entry.getKey());\n-            }\n-        }\n-\n-        if (failures > 0) {\n-            \/\/ Finally, report all occurred exceptions in a nice format.\n-            String msg = System.lineSeparator() + System.lineSeparator() + \"Test Failures (\" + failures + \")\"\n-                         + System.lineSeparator() + \"----------------\" + \"-\".repeat(String.valueOf(failures).length());\n-            throw new TestRunException(msg + System.lineSeparator() + builder.toString());\n-        }\n-    }\n-\n-    private boolean testFilterPresent() {\n-        return testList != null || excludeList != null;\n-    }\n-\n-    enum TriState {\n-        Maybe,\n-        Yes,\n-        No\n-    }\n-\n-    static void compile(Method m, CompLevel compLevel) {\n-        TestRun.check(compLevel != CompLevel.SKIP && compLevel != CompLevel.WAIT_FOR_COMPILATION,\n-                         \"Invalid compilation request with level \" + compLevel);\n-        enqueueForCompilation(m, compLevel);\n-    }\n-\n-    static void deoptimize(Method m) {\n-        WHITE_BOX.deoptimizeMethod(m);\n-    }\n-\n-    static boolean isCompiled(Method m) {\n-        return compiledAtLevel(m, CompLevel.ANY) == TriState.Yes;\n-    }\n-\n-    static boolean isC1Compiled(Method m) {\n-        return compiledByC1(m) == TriState.Yes;\n-    }\n-\n-    static boolean isC2Compiled(Method m) {\n-        return compiledByC2(m) == TriState.Yes;\n-    }\n-\n-    static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n-        return compiledAtLevel(m, compLevel) == TriState.Yes;\n-    }\n-\n-    static void assertDeoptimizedByC1(Method m) {\n-        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n-            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n-                          m + \" should have been deoptimized by C1\");\n-        }\n-    }\n-\n-    static void assertDeoptimizedByC2(Method m) {\n-        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n-            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n-                          m + \" should have been deoptimized by C2\");\n-        }\n-    }\n-\n-    \/**\n-     * Some VM flags could make the deopt assertions unstable.\n-     *\/\n-    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n-        return (USE_COMPILER && !XCOMP && !IGNORE_COMPILER_CONTROLS && !TEST_C1 &&\n-               (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n-    }\n-\n-    static void assertCompiledByC1(Method m) {\n-        TestRun.check(compiledByC1(m) != TriState.No, m + \" should have been C1 compiled\");\n-    }\n-\n-    static void assertCompiledByC2(Method m) {\n-        TestRun.check(compiledByC2(m) != TriState.No, m + \" should have been C2 compiled\");\n-    }\n-\n-    static void assertCompiledAtLevel(Method m, CompLevel level) {\n-        TestRun.check(compiledAtLevel(m, level) != TriState.No, m + \" should have been compiled at level \" + level.name());\n-    }\n-\n-    static void assertNotCompiled(Method m) {\n-        TestRun.check(!isC1Compiled(m), m + \" should not have been compiled by C1\");\n-        TestRun.check(!isC2Compiled(m), m + \" should not have been compiled by C2\");\n-    }\n-\n-    static void assertCompiled(Method m) {\n-        TestRun.check(compiledByC1(m) != TriState.No || compiledByC2(m) != TriState.No, m + \" should have been compiled\");\n-    }\n-\n-    private static TriState compiledByC1(Method m) {\n-        TriState triState = compiledAtLevel(m, CompLevel.C1_SIMPLE);\n-        if (triState != TriState.No) {\n-            return triState;\n-        }\n-        triState = compiledAtLevel(m, CompLevel.C1_LIMITED_PROFILE);\n-        if (triState != TriState.No) {\n-            return triState;\n-        }\n-        triState = compiledAtLevel(m, CompLevel.C1_FULL_PROFILE);\n-        return triState;\n-    }\n-\n-    private static TriState compiledByC2(Method m) {\n-        return compiledAtLevel(m, CompLevel.C2);\n-    }\n-\n-    private static TriState compiledAtLevel(Method m, CompLevel level) {\n-        if (WHITE_BOX.isMethodCompiled(m, false)) {\n-            switch (level) {\n-                case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n-                    if (WHITE_BOX.getMethodCompilationLevel(m, false) == level.getValue()) {\n-                        return TriState.Yes;\n-                    }\n-                }\n-                case ANY -> {\n-                    return TriState.Yes;\n-                }\n-                default -> throw new TestRunException(\"compiledAtLevel() should not be called with \" + level);\n-            }\n-        }\n-        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n-            (EXCLUDE_RANDOM && !WHITE_BOX.isMethodCompilable(m, level.getValue(), false))) {\n-            return TriState.Maybe;\n-        }\n-        return TriState.No;\n-    }\n-}\n-\n-\/**\n- * Abstract super class for base, checked and custom run tests.\n- *\/\n-abstract class AbstractTest {\n-    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-    protected static final int TEST_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"TestCompilationTimeout\", \"10000\"));\n-    protected static final int WAIT_FOR_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"WaitForCompilationTimeout\", \"10000\"));\n-    protected static final boolean VERIFY_OOPS = (Boolean)WHITE_BOX.getVMFlag(\"VerifyOops\");\n-\n-    protected final int warmupIterations;\n-    protected final boolean skip;\n-\n-    AbstractTest(int warmupIterations, boolean skip) {\n-        this.warmupIterations = warmupIterations;\n-        this.skip = skip;\n-    }\n-\n-    protected boolean shouldCompile(DeclaredTest test) {\n-        return test.getCompLevel() != CompLevel.SKIP;\n-    }\n-\n-    abstract String getName();\n-\n-    \/**\n-     * Should test be executed?\n-     *\/\n-    public boolean isSkipped() {\n-        return skip;\n-    }\n-\n-    \/**\n-     * See {@link CompLevel#WAIT_FOR_COMPILATION}.\n-     *\/\n-    protected static boolean isWaitForCompilation(DeclaredTest test) {\n-        return test.getCompLevel() == CompLevel.WAIT_FOR_COMPILATION;\n-    }\n-\n-    protected static Object createInvocationTarget(Method method) {\n-        Class<?> clazz = method.getDeclaringClass();\n-        Object invocationTarget;\n-        if (Modifier.isStatic(method.getModifiers())) {\n-            invocationTarget = null;\n-        } else {\n-            try {\n-                Constructor<?> constructor = clazz.getDeclaredConstructor();\n-                constructor.setAccessible(true);\n-                invocationTarget = constructor.newInstance();\n-            } catch (Exception e) {\n-                throw new TestRunException(\"Could not create instance of \" + clazz\n-                                           + \". Make sure there is a constructor without arguments.\", e);\n-            }\n-        }\n-        return invocationTarget;\n-    }\n-\n-    \/**\n-     * Run the associated test.\n-     *\/\n-    public void run() {\n-        if (skip) {\n-            return;\n-        }\n-        onStart();\n-        for (int i = 0; i < warmupIterations; i++) {\n-            invokeTest();\n-        }\n-        onWarmupFinished();\n-        compileTest();\n-        \/\/ Always run the test as a last step of the test execution.\n-        invokeTest();\n-    }\n-\n-    protected void onStart() {\n-        \/\/ Do nothing by default.\n-    }\n-\n-    abstract protected void invokeTest();\n-\n-    abstract protected void onWarmupFinished();\n-\n-    abstract protected void compileTest();\n-\n-    protected void compileMethod(DeclaredTest test) {\n-        final Method testMethod = test.getTestMethod();\n-        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),\n-                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n-                      + \". Did you use compileonly without including all @Test methods?\");\n-        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod),\n-                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n-                      + \". Did you use compileonly without including all @Test methods?\");\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"Compile method \" + testMethod + \" after warm-up...\");\n-        }\n-\n-        final boolean maybeCodeBufferOverflow = (TestFrameworkExecution.TEST_C1 && VERIFY_OOPS);\n-        final long started = System.currentTimeMillis();\n-        long elapsed = 0;\n-        enqueueMethodForCompilation(test);\n-\n-        do {\n-            if (!WHITE_BOX.isMethodQueuedForCompilation(testMethod)) {\n-                if (elapsed > 0) {\n-                    if (TestFrameworkExecution.VERBOSE) {\n-                        System.out.println(testMethod + \" is not in queue anymore due to compiling it simultaneously on \" +\n-                                           \"a different level. Enqueue again.\");\n-                    }\n-                    enqueueMethodForCompilation(test);\n-                }\n-            }\n-            if (maybeCodeBufferOverflow && elapsed > 1000 && !WHITE_BOX.isMethodCompiled(testMethod, false)) {\n-                \/\/ Let's disable VerifyOops temporarily and retry.\n-                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n-                WHITE_BOX.clearMethodState(testMethod);\n-                enqueueMethodForCompilation(test);\n-                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n-            }\n-\n-            if (WHITE_BOX.getMethodCompilationLevel(testMethod, false) == test.getCompLevel().getValue()) {\n-                break;\n-            }\n-            elapsed = System.currentTimeMillis() - started;\n-        } while (elapsed < TEST_COMPILATION_TIMEOUT);\n-        TestRun.check(elapsed < TEST_COMPILATION_TIMEOUT,\n-                      \"Could not compile \" + testMethod + \" after \" + TEST_COMPILATION_TIMEOUT\/1000 + \"s\");\n-        checkCompilationLevel(test);\n-    }\n-\n-    private void enqueueMethodForCompilation(DeclaredTest test) {\n-        TestFrameworkExecution.enqueueForCompilation(test.getTestMethod(), test.getCompLevel());\n-    }\n-\n-    protected void checkCompilationLevel(DeclaredTest test) {\n-        CompLevel level = CompLevel.forValue(WHITE_BOX.getMethodCompilationLevel(test.getTestMethod()));\n-        TestRun.check(level == test.getCompLevel(),  \"Compilation level should be \" + test.getCompLevel().name()\n-                                                     + \" (requested) but was \" + level.name() + \" for \" + test.getTestMethod());\n-    }\n-\n-    final protected void waitForCompilation(DeclaredTest test) {\n-        final Method testMethod = test.getTestMethod();\n-        final boolean maybeCodeBufferOverflow = (TestFrameworkExecution.TEST_C1 && VERIFY_OOPS);\n-        final long started = System.currentTimeMillis();\n-        boolean stateCleared = false;\n-        long elapsed;\n-        do {\n-            elapsed = System.currentTimeMillis() - started;\n-            int level = WHITE_BOX.getMethodCompilationLevel(testMethod);\n-            if (maybeCodeBufferOverflow && elapsed > 5000\n-                && (!WHITE_BOX.isMethodCompiled(testMethod, false) || level != test.getCompLevel().getValue())) {\n-                retryDisabledVerifyOops(testMethod, stateCleared);\n-                stateCleared = true;\n-            } else {\n-                invokeTest();\n-            }\n-\n-            boolean isCompiled = WHITE_BOX.isMethodCompiled(testMethod, false);\n-            if (TestFrameworkExecution.VERBOSE) {\n-                System.out.println(\"Is \" + testMethod + \" compiled? \" + isCompiled);\n-            }\n-            if (isCompiled || TestFrameworkExecution.XCOMP || TestFrameworkExecution.EXCLUDE_RANDOM) {\n-                \/\/ Don't wait for compilation if -Xcomp is enabled or if we are randomly excluding methods from compilation.\n-                return;\n-            }\n-        } while (elapsed < WAIT_FOR_COMPILATION_TIMEOUT);\n-        throw new TestRunException(testMethod + \" not compiled after waiting for \"\n-                                   + WAIT_FOR_COMPILATION_TIMEOUT\/1000 + \" s\");\n-    }\n-\n-    \/**\n-     * If it takes too long, try to disable Verify Oops.\n-     *\/\n-    private void retryDisabledVerifyOops(Method testMethod, boolean stateCleared) {\n-        System.out.println(\"Temporarily disabling VerifyOops\");\n-        try {\n-            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n-            if (!stateCleared) {\n-                WHITE_BOX.clearMethodState(testMethod);\n-            }\n-            invokeTest();\n-        } finally {\n-            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n-            System.out.println(\"Re-enabled VerifyOops\");\n-        }\n-    }\n-}\n-\n-\/**\n- * A base test only consists of a single @Test method. See {@link Test} for more details and its precise definition.\n- *\/\n-class BaseTest extends AbstractTest {\n-    private final DeclaredTest test;\n-    protected final Method testMethod;\n-    protected final TestInfo testInfo;\n-    protected final Object invocationTarget;\n-    private final boolean shouldCompile;\n-    private final boolean waitForCompilation;\n-\n-    public BaseTest(DeclaredTest test, boolean skip) {\n-        super(test.getWarmupIterations(), skip);\n-        this.test = test;\n-        this.testMethod = test.getTestMethod();\n-        this.testInfo = new TestInfo(test);\n-        this.invocationTarget = createInvocationTarget(testMethod);\n-        this.shouldCompile = shouldCompile(test);\n-        this.waitForCompilation = isWaitForCompilation(test);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Base Test: @Test \" + testMethod.getName();\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return testMethod.getName();\n-    }\n-\n-    @Override\n-    protected void onStart() {\n-        test.printFixedRandomArguments();\n-    }\n-\n-    @Override\n-    public void onWarmupFinished() {\n-        testInfo.setWarmUpFinished();\n-    }\n-\n-    @Override\n-    protected void invokeTest() {\n-        verify(invokeTestMethod());\n-    }\n-\n-    private Object invokeTestMethod() {\n-        try {\n-            if (test.hasArguments()) {\n-                return testMethod.invoke(invocationTarget, test.getArguments());\n-            } else {\n-                return testMethod.invoke(invocationTarget);\n-            }\n-        } catch (Exception e) {\n-            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod\n-                                       + \". Used arguments: \" + test.getArgumentsString(), e);\n-        }\n-    }\n-\n-    @Override\n-    protected void compileTest() {\n-        if (shouldCompile) {\n-            if (waitForCompilation) {\n-                waitForCompilation(test);\n-            } else {\n-                compileMethod(test);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Verify the result\n-     *\/\n-    public void verify(Object result) { \/* no verification in BaseTests *\/ }\n-}\n-\n-\/**\n- * A checked test is an extension of a base test with additional verification done in a @Check method.\n- * See {@link Check} for more details and its precise definition.\n- *\/\n-class CheckedTest extends BaseTest {\n-    private final Method checkMethod;\n-    private final CheckAt checkAt;\n-    private final Parameter parameter;\n-    private final Object checkInvocationTarget;\n-\n-    enum Parameter {\n-        NONE, RETURN_ONLY, TEST_INFO_ONLY, BOTH\n-    }\n-\n-    public CheckedTest(DeclaredTest test, Method checkMethod, Check checkSpecification, Parameter parameter, boolean excludedByUser) {\n-        super(test, excludedByUser);\n-        \/\/ Make sure we can also call non-public or public methods in package private classes\n-        checkMethod.setAccessible(true);\n-        this.checkMethod = checkMethod;\n-        this.checkAt = checkSpecification.when();\n-        this.parameter = parameter;\n-        \/\/ Use the same invocation target\n-        if (Modifier.isStatic(checkMethod.getModifiers())) {\n-            this.checkInvocationTarget = null;\n-        } else {\n-            \/\/ Use the same invocation target as the test method if check method is non-static.\n-            this.checkInvocationTarget = this.invocationTarget != null ? this.invocationTarget : createInvocationTarget(checkMethod);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Checked Test: @Check \" + checkMethod.getName() + \" - @Test: \" + testMethod.getName();\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return checkMethod.getName();\n-    }\n-\n-    @Override\n-    public void verify(Object result) {\n-        boolean shouldVerify = false;\n-        switch (checkAt) {\n-            case EACH_INVOCATION -> shouldVerify = true;\n-            case COMPILED -> shouldVerify = !testInfo.isWarmUp();\n-        }\n-        if (shouldVerify) {\n-            try {\n-                switch (parameter) {\n-                    case NONE -> checkMethod.invoke(checkInvocationTarget);\n-                    case RETURN_ONLY -> checkMethod.invoke(checkInvocationTarget, result);\n-                    case TEST_INFO_ONLY -> checkMethod.invoke(checkInvocationTarget, testInfo);\n-                    case BOTH -> checkMethod.invoke(checkInvocationTarget, result, testInfo);\n-                }\n-            } catch (Exception e) {\n-                throw new TestRunException(\"There was an error while invoking @Check method \" + checkMethod, e);\n-            }\n-        }\n-    }\n-}\n-\n-\/**\n- * A custom run test allows the user to have full control over how the @Test method is invoked by specifying\n- * a dedicated @Run method. See {@link Run} for more details and its precise definition.\n- *\/\n-class CustomRunTest extends AbstractTest {\n-    private final Method runMethod;\n-    private final RunMode mode;\n-    private final Object runInvocationTarget;\n-    private final List<DeclaredTest> tests;\n-    private final RunInfo runInfo;\n-\n-    public CustomRunTest(Method runMethod, Warmup warmUpAnno, Run runSpecification, List<DeclaredTest> tests, boolean skip) {\n-        \/\/ Make sure we can also call non-public or public methods in package private classes\n-        super(warmUpAnno != null ? warmUpAnno.value() : TestFrameworkExecution.WARMUP_ITERATIONS, skip);\n-        TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + runMethod);\n-        runMethod.setAccessible(true);\n-        this.runMethod = runMethod;\n-        this.runInvocationTarget = createInvocationTarget(runMethod);\n-        this.mode = runSpecification.mode();\n-        this.tests = tests;\n-        this.runInfo = new RunInfo(tests);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String s = \"Custom Run Test: @Run: \" + runMethod.getName() + \" - @Test\";\n-        if (tests.size() == 1) {\n-            s += \": \" + tests.get(0).getTestMethod().getName();\n-        } else {\n-            s += \"s: {\" + tests.stream().map(t -> t.getTestMethod().getName())\n-                                             .collect(Collectors.joining(\",\")) + \"}\";\n-        }\n-        return s;\n-    }\n-\n-    @Override\n-    String getName() {\n-        return runMethod.getName();\n-    }\n-\n-    @Override\n-    public void run() {\n-        if (skip) {\n-            return;\n-        }\n-        switch (mode) {\n-            case STANDALONE -> {\n-                runInfo.setWarmUpFinished();\n-                invokeTest();\n-            }\/\/ Invoke once but do not apply anything else.\n-            case NORMAL -> super.run();\n-        }\n-    }\n-\n-    @Override\n-    public void onWarmupFinished() {\n-        runInfo.setWarmUpFinished();\n-    }\n-\n-    @Override\n-    protected void compileTest() {\n-        if (tests.size() == 1) {\n-            compileSingleTest();\n-        } else {\n-            compileMultipleTests();\n-        }\n-    }\n-\n-    private void compileSingleTest() {\n-        DeclaredTest test = tests.get(0);\n-        if (shouldCompile(test)) {\n-            if (isWaitForCompilation(test)) {\n-                waitForCompilation(test);\n-            } else {\n-                compileMethod(test);\n-            }\n-        }\n-    }\n-\n-    private void compileMultipleTests() {\n-        boolean anyWaitForCompilation = false;\n-        boolean anyCompileMethod = false;\n-        ExecutorService executor = Executors.newFixedThreadPool(tests.size());\n-        for (DeclaredTest test : tests) {\n-            if (shouldCompile(test)) {\n-                if (isWaitForCompilation(test)) {\n-                    anyWaitForCompilation = true;\n-                    executor.execute(() -> waitForCompilation(test));\n-                } else {\n-                    anyCompileMethod = true;\n-                    executor.execute(() -> compileMethod(test));\n-                }\n-            }\n-        }\n-        executor.shutdown();\n-        int timeout;\n-        if (anyCompileMethod && anyWaitForCompilation) {\n-            timeout = Math.max(WAIT_FOR_COMPILATION_TIMEOUT, TEST_COMPILATION_TIMEOUT) + 5000;\n-        } else if (anyWaitForCompilation) {\n-            timeout = WAIT_FOR_COMPILATION_TIMEOUT + 5000;\n-        } else {\n-            timeout = TEST_COMPILATION_TIMEOUT + 5000;\n-        }\n-        try {\n-            executor.awaitTermination(timeout, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {\n-            throw new TestRunException(\"Some compilations did not complete after \" + timeout\n-                                       + \"ms for @Run method \" + runMethod);\n-        }\n-    }\n-\n-    \/**\n-     * Do not directly run the test but rather the run method that is responsible for invoking the actual test.\n-     *\/\n-    @Override\n-    protected void invokeTest() {\n-        try {\n-            if (runMethod.getParameterCount() == 1) {\n-                runMethod.invoke(runInvocationTarget, runInfo);\n-            } else {\n-                runMethod.invoke(runInvocationTarget);\n-            }\n-        } catch (Exception e) {\n-            throw new TestRunException(\"There was an error while invoking @Run method \" + runMethod, e);\n-        }\n-    }\n-\n-    @Override\n-    protected void checkCompilationLevel(DeclaredTest test) {\n-        CompLevel level = CompLevel.forValue(WhiteBox.getWhiteBox().getMethodCompilationLevel(test.getTestMethod()));\n-        if (level != test.getCompLevel()) {\n-            String message = \"Compilation level should be \" + test.getCompLevel().name() + \" (requested) but was \"\n-                             + level.name() + \" for \" + test.getTestMethod() + \".\";\n-            switch (mode) {\n-                case STANDALONE -> throw new TestFrameworkException(\"Should not be called for STANDALONE method \" + runMethod);\n-                case NORMAL -> message = message + System.lineSeparator() + \"Check your @Run method \" + runMethod\n-                                         + \" to ensure that \" + test.getTestMethod()\n-                                         + \" is called at least once in each iteration.\";\n-            }\n-            throw new TestRunException(message);\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkExecution.java","additions":0,"deletions":1422,"binary":false,"changes":1422,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-import sun.hotspot.WhiteBox;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-\n-\/**\n- * This class' main method is called from {@link TestFramework} and represents the so-called \"flag VM\". It uses the\n- * Whitebox API to determine the necessary additional flags to run the test VM (e.g. to do IR matching). It returns\n- * the flags over the dedicated TestFramework socket.\n- *\/\n-class TestFrameworkPrepareFlags {\n-    private static final WhiteBox WHITE_BOX;\n-\n-    static {\n-        try {\n-            WHITE_BOX = WhiteBox.getWhiteBox();\n-        } catch (UnsatisfiedLinkError e) {\n-            throw new TestFrameworkException(\"Could not load WhiteBox\", e);\n-        }\n-    }\n-\n-    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n-    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL =\n-            CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n-    private static final boolean TEST_C1 = TIERED_COMPILATION\n-                                           && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n-\n-    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n-    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n-    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n-    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n-    private static final boolean REQUESTED_VERIFY_IR = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n-    private static final boolean VERIFY_IR = REQUESTED_VERIFY_IR && USE_COMPILER && !EXCLUDE_RANDOM && !FLIP_C1_C2 && !TEST_C1;\n-\n-    private static String[] getPrintFlags() {\n-        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n-    }\n-\n-    \/**\n-     * Main entry point of the flag VM.\n-     *\/\n-    public static void main(String[] args) {\n-        try {\n-            String testClassName = args[0];\n-            if (VERBOSE) {\n-                System.out.println(\"TestFrameworkPrepareFlags main() called. Prepare test VM flags to run class \" + testClassName);\n-            }\n-            Class<?> testClass;\n-            try {\n-                testClass = Class.forName(testClassName);\n-            } catch (Exception e) {\n-                throw new TestRunException(\"Could not find test class \" + testClassName, e);\n-            }\n-            emitTestVMFlags(prepareTestVmFlags(testClass));\n-        } finally {\n-            TestFrameworkSocket.closeClientSocket();\n-        }\n-    }\n-\n-    \/**\n-     * Emit test VM flags to standard output to parse them from the TestFramework \"driver\" VM again which adds them to the test VM.\n-     *\/\n-    private static void emitTestVMFlags(ArrayList<String> flags) {\n-        String encoding = TestFramework.TEST_VM_FLAGS_START + System.lineSeparator()\n-                          + String.join(TestFramework.TEST_VM_FLAGS_DELIMITER, flags)\n-                          + System.lineSeparator() + TestFramework.TEST_VM_FLAGS_END;\n-        TestFrameworkSocket.write(encoding, \"flag encoding\");\n-    }\n-\n-    private static ArrayList<String> prepareTestVmFlags(Class<?> testClass) {\n-        return setupIrVerificationFlags(testClass);\n-    }\n-\n-    private static ArrayList<String> setupIrVerificationFlags(Class<?> testClass) {\n-        ArrayList<String> cmds = new ArrayList<>();\n-        if (VERIFY_IR) {\n-            \/\/ Add print flags for IR verification\n-            cmds.addAll(Arrays.asList(getPrintFlags()));\n-            cmds.add(\"-XX:+LogCompilation\");\n-            cmds.add(\"-XX:CompileCommand=log,\" + testClass.getCanonicalName() + \"::*\");\n-            addBoolOptionForClass(cmds, testClass, \"PrintIdeal\");\n-            addBoolOptionForClass(cmds, testClass, \"PrintOptoAssembly\");\n-            \/\/ Always trap for exception throwing to not confuse IR verification\n-            cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n-            cmds.add(\"-DShouldDoIRVerification=true\");\n-        } else {\n-            cmds.add(\"-DShouldDoIRVerification=false\");\n-        }\n-        return cmds;\n-    }\n-\n-    private static void addBoolOptionForClass(ArrayList<String> cmds, Class<?> testClass, String option) {\n-        cmds.add(\"-XX:CompileCommand=option,\" + testClass.getCanonicalName() + \"::*,bool,\" + option + \",true\");\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkPrepareFlags.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n@@ -43,0 +43,1 @@\n+    static final String STDOUT_PREFIX = \"[STDOUT]\";\n@@ -45,1 +46,0 @@\n-    private static final String STDOUT_PREFIX = \"[STDOUT]\";\n@@ -53,3 +53,1 @@\n-    private static TestFrameworkSocket singleton = null;\n-\n-    private TestFrameworkSocket() {\n+    TestFrameworkSocket() {\n@@ -66,8 +64,1 @@\n-    }\n-\n-    public static TestFrameworkSocket getSocket() {\n-        if (singleton == null || singleton.serverSocket.isClosed()) {\n-            singleton = new TestFrameworkSocket();\n-            return singleton;\n-        }\n-        return singleton;\n+        start();\n@@ -80,1 +71,1 @@\n-    public void start() {\n+    private void start() {\n@@ -87,1 +78,1 @@\n-     * Waits for client sockets (created by flag or test VM) to connect. Return the messages received by the clients.\n+     * Waits for a client (created by flag or test VM) to connect. Return the messages received from the client.\n@@ -116,1 +107,1 @@\n-     * Only called by flag and test VM to write to server socket.\n+     * Only called by test VM to write to server socket.\n@@ -123,1 +114,1 @@\n-     * Only called by flag and test VM to write to server socket.\n+     * Only called by test VM to write to server socket.\n@@ -133,2 +124,1 @@\n-            \/\/ Keep the client socket open until the flag or test VM terminates (calls closeClientSocket before exiting\n-            \/\/ main()).\n+            \/\/ Keep the client socket open until the test VM terminates (calls closeClientSocket before exiting main()).\n@@ -148,1 +138,1 @@\n-                              Did you directly run the test VM (TestFrameworkExecution)\n+                              Did you directly run the test VM (TestVM class)\n@@ -171,1 +161,1 @@\n-                throw new RuntimeException(\"Could not close TestFrameworkExecution socket\", e);\n+                throw new RuntimeException(\"Could not close TestVM socket\", e);\n@@ -182,32 +172,3 @@\n-\n-        } catch (Exception e) {\n-            throw new TestFrameworkException(\"Could not read from socket task\", e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the socket output from the test VM by stripping all lines starting with a [STDOUT] output and printing them\n-     * to the standard output.\n-     *\/\n-    public String getOutputPrintStdout() {\n-        try {\n-            String output = socketTask.get();\n-            if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n-                StringBuilder builder = new StringBuilder();\n-                Scanner scanner = new Scanner(output);\n-                System.out.println(System.lineSeparator() + \"Run flag defined test list\");\n-                System.out.println(\"--------------------------\");\n-                while (scanner.hasNextLine()) {\n-                    String line = scanner.nextLine();\n-                    if (line.startsWith(STDOUT_PREFIX)) {\n-                        line = \"> \" + line.substring(STDOUT_PREFIX.length());\n-                        System.out.println(line);\n-                    } else {\n-                        builder.append(line).append(System.lineSeparator());\n-                    }\n-                }\n-                System.out.println();\n-                return builder.toString();\n-            }\n-            return output;\n-\n+        } catch (ExecutionException e) {\n+            \/\/ Thrown when socket task was not finished, yet (i.e. no client sent data) but socket was already closed.\n+            return \"\";\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkSocket.java","additions":14,"deletions":53,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * @return {@code true} if the framework compiled the test;\n+     * @return {@code true} if the framework skipped compilation of the test;\n@@ -71,1 +71,1 @@\n-        return TestFrameworkExecution.isC1Compiled(testMethod);\n+        return TestVM.isC1Compiled(testMethod);\n@@ -81,1 +81,1 @@\n-        return TestFrameworkExecution.isC2Compiled(testMethod);\n+        return TestVM.isC2Compiled(testMethod);\n@@ -92,1 +92,1 @@\n-        return TestFrameworkExecution.isCompiledAtLevel(testMethod, compLevel);\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestInfo.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,952 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"test VM\". The class is\n+ * the heart of the framework and is responsible for executing all the specified tests in the test class. It uses the\n+ * Whitebox API and reflection to achieve this task.\n+ *\/\n+public class TestVM {\n+    private static final WhiteBox WHITE_BOX;\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+        } catch (UnsatisfiedLinkError e) {\n+            System.err.println(System.lineSeparator() + \"\"\"\n+                               ##########################################################\n+                                - Did you call a test-related interface method from\n+                                  TestFramework in main() of your test? Make sure to\n+                                  only call setup\/run methods and no checks or\n+                                  assertions from main() of your test!\n+                                - Are you rerunning the test VM (TestVM class)\n+                                  directly after a JTreg run? Make sure to start it\n+                                  from within JTwork\/scratch and with the flag\n+                                  -DReproduce=true!\n+                               ##########################################################\n+                               \"\"\");\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * The default number of warm-up iterations used to warm up a {@link Test} annotated test method.\n+     * Use {@code -DWarmup=XY} to specify a different default value. An individual warm-up can also be\n+     * set by specifying a {@link Warmup} iteration for a test.\n+     *\/\n+    public static final int WARMUP_ITERATIONS = Integer.parseInt(System.getProperty(\"Warmup\", \"2000\"));\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL = CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    static final boolean XCOMP = Platform.isComp();\n+    static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\");\n+    static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final String TESTLIST = System.getProperty(\"Test\", \"\");\n+    private static final String EXCLUDELIST = System.getProperty(\"Exclude\", \"\");\n+    private static final boolean DUMP_REPLAY = Boolean.getBoolean(\"DumpReplay\");\n+    private static final boolean GC_AFTER = Boolean.getBoolean(\"GCAfter\");\n+    private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(\"ShuffleTests\", \"true\"));\n+    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by flag VM.\n+    private static final boolean PRINT_VALID_IR_RULES = Boolean.getBoolean(\"ShouldDoIRVerification\");\n+    protected static final long PER_METHOD_TRAP_LIMIT = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n+    protected static final boolean PROFILE_INTERPRETER = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean IGNORE_COMPILER_CONTROLS = Boolean.getBoolean(\"IgnoreCompilerControls\");\n+\n+    private final HashMap<Method, DeclaredTest> declaredTests = new HashMap<>();\n+    private final List<AbstractTest> allTests = new ArrayList<>();\n+    private final HashMap<String, Method> testMethodMap = new HashMap<>();\n+    private final List<String> excludeList;\n+    private final List<String> testList;\n+    private Set<Class<?>> helperClasses = null; \/\/ Helper classes that contain framework annotations to be processed.\n+    private final IREncodingPrinter irMatchRulePrinter;\n+    private final Class<?> testClass;\n+    private final Map<Executable, CompLevel> forceCompileMap = new HashMap<>();\n+\n+    private TestVM(Class<?> testClass) {\n+        TestRun.check(testClass != null, \"Test class cannot be null\");\n+        this.testClass = testClass;\n+        this.testList = createTestFilterList(TESTLIST, testClass);\n+        this.excludeList = createTestFilterList(EXCLUDELIST, testClass);\n+\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter = new IREncodingPrinter();\n+        } else {\n+            irMatchRulePrinter = null;\n+        }\n+    }\n+\n+    \/**\n+     * Parse \"test1,test2,test3\" into a list.\n+     *\/\n+    private static List<String> createTestFilterList(String list, Class<?> testClass) {\n+        List<String> filterList = null;\n+        if (!list.isEmpty()) {\n+            String classPrefix = testClass.getSimpleName() + \".\";\n+            filterList = new ArrayList<>(Arrays.asList(list.split(\",\")));\n+            for (int i = filterList.size() - 1; i >= 0; i--) {\n+                String test = filterList.get(i);\n+                if (test.indexOf(\".\") > 0) {\n+                    if (test.startsWith(classPrefix)) {\n+                        test = test.substring(classPrefix.length());\n+                        filterList.set(i, test);\n+                    } else {\n+                        filterList.remove(i);\n+                    }\n+                }\n+            }\n+        }\n+        return filterList;\n+    }\n+\n+    \/**\n+     * Main entry point of the test VM.\n+     *\/\n+    public static void main(String[] args) {\n+        try {\n+            String testClassName = args[0];\n+            System.out.println(\"TestVM main() called - about to run tests in class \" + testClassName);\n+            Class<?> testClass = getClassObject(testClassName, \"test\");\n+\n+            TestVM framework = new TestVM(testClass);\n+            framework.addHelperClasses(args);\n+            framework.start();\n+        } finally {\n+            TestFrameworkSocket.closeClientSocket();\n+        }\n+    }\n+\n+    protected static Class<?> getClassObject(String className, String classType) {\n+        try {\n+            return Class.forName(className);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find \" + classType + \" class\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Set up all helper classes and verify they are specified correctly.\n+     *\/\n+    private void addHelperClasses(String[] args) {\n+        Class<?>[] helperClassesList = getHelperClasses(args);\n+        if (helperClassesList != null) {\n+            TestRun.check(Arrays.stream(helperClassesList).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n+            this.helperClasses = new HashSet<>();\n+\n+            for (Class<?> helperClass : helperClassesList) {\n+                if (Arrays.stream(testClass.getDeclaredClasses()).anyMatch(c -> c == helperClass)) {\n+                    \/\/ Nested class of test class is automatically treated as helper class\n+                    TestFormat.failNoThrow(\"Nested \" + helperClass + \" inside test \" + testClass + \" is implicitly\"\n+                                           + \" treated as helper class and does not need to be specified as such.\");\n+                    continue;\n+                }\n+                TestRun.check(!this.helperClasses.contains(helperClass), \"Cannot add the same class twice: \" + helperClass);\n+                this.helperClasses.add(helperClass);\n+            }\n+        }\n+    }\n+\n+    private static Class<?>[] getHelperClasses(String[] args) {\n+        if (args.length == 1) {\n+            return null;\n+        }\n+        Class<?>[] helperClasses = new Class<?>[args.length - 1]; \/\/ First argument is test class\n+        for (int i = 1; i < args.length; i++) {\n+            String helperClassName = args[i];\n+            helperClasses[i - 1] = getClassObject(helperClassName, \"helper\");\n+        }\n+        return helperClasses;\n+    }\n+\n+    private void checkHelperClass(Class<?> clazz) {\n+        checkAnnotationsInClass(clazz, \"helper\");\n+        for (Class<?> c : clazz.getDeclaredClasses()) {\n+            checkAnnotationsInClass(c, \"nested (and helper)\");\n+        }\n+    }\n+\n+    private void checkAnnotationsInClass(Class<?> c, String clazzType) {\n+        Method[] methods = c.getDeclaredMethods();\n+        for (Method m : methods) {\n+            TestFormat.checkNoThrow(getAnnotation(m, Test.class) == null,\n+                                    \"Cannot use @Test annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Run.class) == null,\n+                                    \"Cannot use @Run annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Check.class) == null,\n+                                    \"Cannot use @Check annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by internal tests testing the framework itself. Accessed by reflection. Not exposed to normal users.\n+     *\/\n+    private static void runTestsOnSameVM(Class<?> testClass) {\n+        if (testClass == null) {\n+            StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            testClass = walker.getCallerClass();\n+        }\n+        TestVM framework = new TestVM(testClass);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Once everything is initialized and set up, start collecting tests and executing them afterwards.\n+     *\/\n+    private void start() {\n+        setupTests();\n+        checkForcedCompilationsCompleted();\n+        runTests();\n+    }\n+\n+    private void setupTests() {\n+        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+            checkAnnotationsInClass(clazz, \"inner\");\n+        }\n+        if (DUMP_REPLAY) {\n+            addReplay();\n+        }\n+        \/\/ Make sure to first setup test methods and make them non-inlineable and only then process compile commands.\n+        setupDeclaredTests();\n+        processControlAnnotations(testClass);\n+        processHelperClasses();\n+        setupCheckedAndCustomRunTests();\n+\n+        \/\/ All remaining tests are simple base tests without check or specific way to run them.\n+        addBaseTests();\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter.emit();\n+        }\n+        TestFormat.reportIfAnyFailures();\n+        declaredTests.clear();\n+        testMethodMap.clear();\n+    }\n+\n+    private void addBaseTests() {\n+        declaredTests.forEach((m, test) -> {\n+            if (test.getAttachedMethod() == null) {\n+                try {\n+                    Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+                    TestFormat.check(argumentsAnno != null || m.getParameterCount() == 0, \"Missing @Arguments annotation to define arguments of \" + m);\n+                    BaseTest baseTest = new BaseTest(test, shouldExcludeTest(m.getName()));\n+                    allTests.add(baseTest);\n+                    if (PRINT_VALID_IR_RULES) {\n+                       irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Check if user wants to exclude this test by checking the -DTest and -DExclude lists.\n+     *\/\n+    private boolean shouldExcludeTest(String testName) {\n+        boolean hasTestList = testList != null;\n+        boolean hasExcludeList = excludeList != null;\n+        if (hasTestList) {\n+            return !testList.contains(testName) || (hasExcludeList && excludeList.contains(testName));\n+        } else if (hasExcludeList) {\n+            return excludeList.contains(testName);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Generate replay compilation files.\n+     *\/\n+    private void addReplay() {\n+        String directive = \"[{ match: \\\"*.*\\\", DumpReplay: true }]\";\n+        TestFramework.check(WHITE_BOX.addCompilerDirective(directive) == 1, \"Failed to add DUMP_REPLAY directive\");\n+    }\n+\n+    private void processControlAnnotations(Class<?> clazz) {\n+        if (IGNORE_COMPILER_CONTROLS) {\n+            return;\n+        }\n+        \/\/ Also apply compile commands to all inner classes of 'clazz'.\n+        ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n+        classes.add(clazz);\n+        for (Class<?> c : classes) {\n+            applyClassAnnotations(c);\n+            List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n+            Collections.addAll(executables, c.getDeclaredConstructors());\n+            for (Executable ex : executables) {\n+                checkClassAnnotations(ex);\n+                try {\n+                    applyIndependentCompilationCommands(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+\n+            \/\/ Only force compilation now because above annotations affect inlining\n+            for (Executable ex : executables) {\n+                try {\n+                    applyForceCompileCommand(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        }\n+    }\n+\n+    private void applyClassAnnotations(Class<?> c) {\n+        ForceCompileClassInitializer anno = getAnnotation(c, ForceCompileClassInitializer.class);\n+        if (anno == null) {\n+            return;\n+        }\n+\n+        \/\/ Compile class initializer\n+        CompLevel level = anno.value();\n+        if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n+            TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n+                                   \"@ForceCompileClassInitializer at \" + c);\n+            return;\n+        }\n+        level = restrictCompLevel(anno.value());\n+        if (level != CompLevel.SKIP) {\n+            \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n+            getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n+            TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n+                                    \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n+                                    + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n+        }\n+    }\n+\n+    private void checkClassAnnotations(Executable ex) {\n+        TestFormat.checkNoThrow(getAnnotation(ex, ForceCompileClassInitializer.class) == null,\n+                                \"@ForceCompileClassInitializer only allowed at classes but not at method \" + ex);\n+    }\n+\n+    \/**\n+     * Exclude a method from compilation with a compiler randomly. Return the compiler for which the method was made\n+     * not compilable.\n+     *\/\n+    static Compiler excludeRandomly(Executable ex) {\n+        Compiler compiler = switch (Utils.getRandomInstance().nextInt() % 3) {\n+            case 1 -> Compiler.C1;\n+            case 2 -> Compiler.C2;\n+            default -> Compiler.ANY;\n+        };\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        System.out.println(\"Excluding from \" + compiler.name() + \" compilation: \" + ex);\n+        return compiler;\n+    }\n+\n+    private void applyIndependentCompilationCommands(Executable ex) {\n+        ForceInline forceInlineAnno = getAnnotation(ex, ForceInline.class);\n+        DontInline dontInlineAnno = getAnnotation(ex, DontInline.class);\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        DontCompile dontCompileAnno = getAnnotation(ex, DontCompile.class);\n+        checkCompilationCommandAnnotations(ex, forceInlineAnno, dontInlineAnno, forceCompileAnno, dontCompileAnno);\n+        \/\/ First handle inline annotations\n+        if (dontInlineAnno != null) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        } else if (forceInlineAnno != null) {\n+            WHITE_BOX.testSetForceInlineMethod(ex, true);\n+        }\n+        if (dontCompileAnno != null) {\n+            dontCompileWithCompiler(ex, dontCompileAnno.value());\n+        }\n+        if (EXCLUDE_RANDOM && getAnnotation(ex, Test.class) == null && forceCompileAnno == null && dontCompileAnno == null) {\n+            \/\/ Randomly exclude helper methods from compilation\n+            if (Utils.getRandomInstance().nextBoolean()) {\n+                excludeRandomly(ex);\n+            }\n+        }\n+    }\n+\n+    private void checkCompilationCommandAnnotations(Executable ex, ForceInline forceInlineAnno, DontInline dontInlineAnno, ForceCompile forceCompileAnno, DontCompile dontCompileAnno) {\n+        Test testAnno = getAnnotation(ex, Test.class);\n+        Run runAnno = getAnnotation(ex, Run.class);\n+        Check checkAnno = getAnnotation(ex, Check.class);\n+        TestFormat.check((testAnno == null && runAnno == null && checkAnno == null) || Stream.of(forceCompileAnno, dontCompileAnno, forceInlineAnno, dontInlineAnno).noneMatch(Objects::nonNull),\n+                         \"Cannot use explicit compile command annotations (@ForceInline, @DontInline, \" +\n+                         \"@ForceCompile or @DontCompile) together with @Test, @Check or @Run: \" + ex + \". Use compLevel in @Test for fine tuning.\");\n+        if (Stream.of(forceInlineAnno, dontCompileAnno, dontInlineAnno).filter(Objects::nonNull).count() > 1) {\n+            \/\/ Failure\n+            TestFormat.check(dontCompileAnno == null || dontInlineAnno == null,\n+                             \"@DontInline is implicitely done with @DontCompile annotation at \" + ex);\n+            TestFormat.fail(\"Cannot mix @ForceInline, @DontInline and @DontCompile at the same time at \" + ex);\n+        }\n+        TestFormat.check(forceInlineAnno == null || dontInlineAnno == null, \"Cannot have @ForceInline and @DontInline at the same time at \" + ex);\n+        if (forceCompileAnno != null && dontCompileAnno != null) {\n+            CompLevel forceCompileLevel = forceCompileAnno.value();\n+            Compiler dontCompileCompiler = dontCompileAnno.value();\n+            TestFormat.check(dontCompileCompiler != Compiler.ANY,\n+                             \"Cannot have @DontCompile(Compiler.ANY) and @ForceCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel != CompLevel.ANY,\n+                             \"Cannot have @ForceCompile(CompLevel.ANY) and @DontCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel.isNotCompilationLevelOfCompiler(dontCompileCompiler),\n+                             \"Overlapping compilation level and compiler with @ForceCompile and @DontCompile at \" + ex);\n+        }\n+    }\n+\n+    \/**\n+     * Exlude the method from compilation and make sure it is not inlined.\n+     *\/\n+    private void dontCompileAndDontInlineMethod(Method m) {\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+    }\n+\n+    private void dontCompileWithCompiler(Executable ex, Compiler compiler) {\n+        if (VERBOSE) {\n+            System.out.println(\"dontCompileWithCompiler \" + ex + \" , compiler = \" + compiler.name());\n+        }\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        if (compiler == Compiler.ANY) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        }\n+    }\n+\n+    private void applyForceCompileCommand(Executable ex) {\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        if (forceCompileAnno != null) {\n+            CompLevel complevel = forceCompileAnno.value();\n+            TestFormat.check(complevel != CompLevel.SKIP && complevel != CompLevel.WAIT_FOR_COMPILATION,\n+                             \"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in @ForceCompile at \" + ex);\n+            complevel = restrictCompLevel(forceCompileAnno.value());\n+            if (FLIP_C1_C2) {\n+                complevel = complevel.flipCompLevel();\n+            }\n+            if (EXCLUDE_RANDOM) {\n+                complevel = complevel.excludeCompilationRandomly(ex);\n+            }\n+            if (complevel != CompLevel.SKIP) {\n+                enqueueForCompilation(ex, complevel);\n+                forceCompileMap.put(ex, complevel);\n+            }\n+        }\n+    }\n+\n+    static void enqueueForCompilation(Executable ex, CompLevel requestedCompLevel) {\n+        if (TestVM.VERBOSE) {\n+            System.out.println(\"enqueueForCompilation \" + ex + \", level = \" + requestedCompLevel);\n+        }\n+        CompLevel compLevel = restrictCompLevel(requestedCompLevel);\n+        if (compLevel != CompLevel.SKIP) {\n+            WHITE_BOX.enqueueMethodForCompilation(ex, compLevel.getValue());\n+        } else {\n+            System.out.println(\"Skipped compilation on level \" + requestedCompLevel + \" due to VM flags not allowing it.\");\n+        }\n+    }\n+\n+    \/**\n+     * Setup @Test annotated method an add them to the declaredTests map to have a convenient way of accessing them\n+     * once setting up a framework test (base  checked, or custom run test).\n+     *\/\n+    private void setupDeclaredTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Test testAnno = getAnnotation(m, Test.class);\n+            try {\n+                if (testAnno != null) {\n+                    addDeclaredTest(m);\n+                } else {\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(Warmup.class) || getAnnotation(m, Run.class) != null,\n+                                     \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+        TestFormat.checkNoThrow(!declaredTests.isEmpty(), \"Did not specify any @Test methods in \" + testClass);\n+    }\n+\n+    private void addDeclaredTest(Method m) {\n+        Test testAnno = getAnnotation(m, Test.class);\n+        checkTestAnnotations(m, testAnno);\n+        Warmup warmup = getAnnotation(m, Warmup.class);\n+        int warmupIterations = WARMUP_ITERATIONS;\n+        if (warmup != null) {\n+            warmupIterations = warmup.value();\n+            TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + m);\n+        }\n+\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            \/\/ Don't inline test methods by default. Do not apply this when -DIgnoreCompilerControls=true is set.\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+        CompLevel compLevel = restrictCompLevel(testAnno.compLevel());\n+        if (FLIP_C1_C2) {\n+            compLevel = compLevel.flipCompLevel();\n+        }\n+        if (EXCLUDE_RANDOM) {\n+            compLevel = compLevel.excludeCompilationRandomly(m);\n+        }\n+        DeclaredTest test = new DeclaredTest(m, ArgumentValue.getArguments(m), compLevel, warmupIterations);\n+        declaredTests.put(m, test);\n+        testMethodMap.put(m.getName(), m);\n+    }\n+\n+    private void checkTestAnnotations(Method m, Test testAnno) {\n+        TestFormat.check(!testMethodMap.containsKey(m.getName()),\n+                         \"Cannot overload two @Test methods: \" + m + \", \" + testMethodMap.get(m.getName()));\n+        TestFormat.check(testAnno != null, m + \" must be a method with a @Test annotation\");\n+\n+        Check checkAnno = getAnnotation(m, Check.class);\n+        Run runAnno = getAnnotation(m, Run.class);\n+        TestFormat.check(checkAnno == null && runAnno == null,\n+                         m + \" has invalid @Check or @Run annotation while @Test annotation is present.\");\n+\n+        TestFormat.checkNoThrow(Arrays.stream(m.getParameterTypes()).noneMatch(AbstractInfo.class::isAssignableFrom),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as parameter type at \" +\n+                                \"@Test method \" + m);\n+\n+        TestFormat.checkNoThrow(!AbstractInfo.class.isAssignableFrom(m.getReturnType()),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as return type at \" +\n+                                \"@Test method \" + m);\n+    }\n+\n+\n+    \/**\n+     * Get the appropriate level as permitted by the test scenario and VM flags.\n+     *\/\n+    private static CompLevel restrictCompLevel(CompLevel compLevel) {\n+        if (!USE_COMPILER) {\n+            return CompLevel.SKIP;\n+        }\n+        if (compLevel == CompLevel.ANY) {\n+            \/\/ Use highest available compilation level by default (usually C2).\n+            compLevel = TIERED_COMPILATION_STOP_AT_LEVEL;\n+        }\n+        if (!TIERED_COMPILATION && compLevel.getValue() < CompLevel.C2.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        if (TIERED_COMPILATION && compLevel.getValue() > TIERED_COMPILATION_STOP_AT_LEVEL.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        return compLevel;\n+    }\n+\n+    \/**\n+     * Verify that the helper classes do not contain illegal framework annotations and then apply the actions as\n+     * specified by the different helper class annotations.\n+     *\/\n+    private void processHelperClasses() {\n+        if (helperClasses != null) {\n+            for (Class<?> helperClass : helperClasses) {\n+                \/\/ Process the helper classes and apply the explicit compile commands\n+                TestFormat.checkNoThrow(helperClass != testClass,\n+                                        \"Cannot specify test \" + testClass + \" as helper class, too.\");\n+                checkHelperClass(helperClass);\n+                processControlAnnotations(helperClass);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * First set up checked (with @Check) and custom run tests (with @Run). All remaining unmatched\/unused @Test methods\n+     * are treated as base tests and set up as such later.\n+     *\/\n+    private void setupCheckedAndCustomRunTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Check checkAnno = getAnnotation(m, Check.class);\n+            Run runAnno = getAnnotation(m, Run.class);\n+            Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+            try {\n+                TestFormat.check(argumentsAnno == null || (checkAnno == null && runAnno == null),\n+                                 \"Cannot have @Argument annotation in combination with @Run or @Check at \" + m);\n+                if (checkAnno != null) {\n+                    addCheckedTest(m, checkAnno, runAnno);\n+                } else if (runAnno != null) {\n+                    addCustomRunTest(m, runAnno);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Set up a checked test by first verifying the correct format of the @Test and @Check method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCheckedTest(Method m, Check checkAnno, Run runAnno) {\n+        Method testMethod = testMethodMap.get(checkAnno.test());\n+        DeclaredTest test = declaredTests.get(testMethod);\n+        checkCheckedTest(m, checkAnno, runAnno, testMethod, test);\n+        test.setAttachedMethod(m);\n+        CheckedTest.Parameter parameter = getCheckedTestParameter(m, testMethod);\n+        dontCompileAndDontInlineMethod(m);\n+        CheckedTest checkedTest = new CheckedTest(test, m, checkAnno, parameter, shouldExcludeTest(testMethod.getName()));\n+        allTests.add(checkedTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            \/\/ Only need to emit IR verification information if IR verification is actually performed.\n+            irMatchRulePrinter.emitRuleEncoding(m, checkedTest.isSkipped());\n+        }\n+    }\n+\n+    private void checkCheckedTest(Method m, Check checkAnno, Run runAnno, Method testMethod, DeclaredTest test) {\n+        TestFormat.check(runAnno == null, m + \" has invalid @Run annotation while @Check annotation is present.\");\n+        TestFormat.check(testMethod != null, \"Did not find associated test method \\\"\" + m.getDeclaringClass().getName()\n+                                             + \".\" + checkAnno.test() + \"\\\" for @Check at \" + m);\n+        TestFormat.check(test != null, \"Missing @Test annotation for associated test method \" + testMethod + \" for @Check at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run or one @Check method. Found: \" + m + \", \" + attachedMethod);\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Check}.\n+     *\/\n+    private CheckedTest.Parameter getCheckedTestParameter(Method m, Method testMethod) {\n+        boolean firstParameterTestInfo = m.getParameterCount() > 0 && m.getParameterTypes()[0].equals(TestInfo.class);\n+        boolean secondParameterTestInfo = m.getParameterCount() > 1 && m.getParameterTypes()[1].equals(TestInfo.class);\n+        CheckedTest.Parameter parameter = null;\n+        Class<?> testReturnType = testMethod.getReturnType();\n+        switch (m.getParameterCount()) {\n+            case 0 -> parameter = CheckedTest.Parameter.NONE;\n+            case 1 -> {\n+                TestFormat.checkNoThrow(firstParameterTestInfo || m.getParameterTypes()[0] == testReturnType,\n+                                        \"Single-parameter version of @Check method \" + m + \" must match return type of @Test \" + testMethod);\n+                parameter = firstParameterTestInfo ? CheckedTest.Parameter.TEST_INFO_ONLY : CheckedTest.Parameter.RETURN_ONLY;\n+            }\n+            case 2 -> {\n+                TestFormat.checkNoThrow(m.getParameterTypes()[0] == testReturnType && secondParameterTestInfo,\n+                                        \"Two-parameter version of @Check method \" + m + \" must provide as first parameter the same\"\n+                                        + \" return type as @Test method \" + testMethod + \" and as second parameter an object of \" + TestInfo.class);\n+                parameter = CheckedTest.Parameter.BOTH;\n+            }\n+            default -> TestFormat.failNoThrow(\"@Check method \" + m + \" must provide either a none, single or two-parameter variant.\");\n+        }\n+        return parameter;\n+    }\n+\n+    \/**\n+     * Set up a custom run test by first verifying the correct format of the @Test and @Run method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCustomRunTest(Method m, Run runAnno) {\n+        checkRunMethod(m, runAnno);\n+        List<DeclaredTest> tests = new ArrayList<>();\n+        boolean shouldExcludeTest = true;\n+        for (String testName : runAnno.test()) {\n+            try {\n+                Method testMethod = testMethodMap.get(testName);\n+                DeclaredTest test = declaredTests.get(testMethod);\n+                checkCustomRunTest(m, testName, testMethod, test, runAnno.mode());\n+                test.setAttachedMethod(m);\n+                tests.add(test);\n+                \/\/ Only exclude custom run test if all test methods excluded\n+                shouldExcludeTest &= shouldExcludeTest(testMethod.getName());\n+            } catch (TestFormatException e) {\n+                \/\/ Logged, continue.\n+            }\n+        }\n+        if (tests.isEmpty()) {\n+            return; \/\/ There was a format violation. Return.\n+        }\n+        dontCompileAndDontInlineMethod(m);\n+        CustomRunTest customRunTest = new CustomRunTest(m, getAnnotation(m, Warmup.class), runAnno, tests, shouldExcludeTest);\n+        allTests.add(customRunTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            tests.forEach(test -> irMatchRulePrinter.emitRuleEncoding(test.getTestMethod(), customRunTest.isSkipped()));\n+        }\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Run}.\n+     *\/\n+    private void checkCustomRunTest(Method m, String testName, Method testMethod, DeclaredTest test, RunMode runMode) {\n+        TestFormat.check(testMethod != null, \"Did not find associated @Test method \\\"\"  + m.getDeclaringClass().getName()\n+                                             + \".\" + testName + \"\\\" specified in @Run at \" + m);\n+        TestFormat.check(test != null,\n+                         \"Missing @Test annotation for associated test method \" + testName + \" for @Run at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run\/@Check method. Found: \"\n+                         + m + \", \" + attachedMethod);\n+        TestFormat.check(!test.hasArguments(),\n+                         \"Cannot use @Arguments at test method \" + testMethod + \" in combination with @Run method \" + m);\n+        Warmup warmupAnno = getAnnotation(testMethod, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null,\n+                         \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n+                         + m + \". Use @Warmup at @Run method instead.\");\n+        Test testAnno = getAnnotation(testMethod, Test.class);\n+        TestFormat.checkNoThrow(runMode != RunMode.STANDALONE || testAnno.compLevel() == CompLevel.ANY,\n+                                \"Setting explicit compilation level for @Test method \" + testMethod + \" has no effect \"\n+                                + \"when used with STANDALONE @Run method \" + m);\n+    }\n+\n+    private void checkRunMethod(Method m, Run runAnno) {\n+        TestFormat.check(runAnno.test().length > 0, \"@Run method \" + m + \" must specify at least one test method\");\n+        TestFormat.checkNoThrow(m.getParameterCount() == 0 || (m.getParameterCount() == 1 && m.getParameterTypes()[0].equals(RunInfo.class)),\n+                                \"@Run method \" + m + \" must specify either no parameter or exactly one \" + RunInfo.class + \" parameter.\");\n+        Warmup warmupAnno = getAnnotation(m, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null || runAnno.mode() != RunMode.STANDALONE,\n+                                \"Cannot set @Warmup at @Run method \" + m + \" when used with RunMode.STANDALONE. The @Run method is only invoked once.\");\n+    }\n+\n+    private static <T extends Annotation> T getAnnotation(AnnotatedElement element, Class<T> c) {\n+        T[] annos =  element.getAnnotationsByType(c);\n+        TestFormat.check(annos.length < 2, element + \" has duplicated annotations\");\n+        return Arrays.stream(annos).findFirst().orElse(null);\n+    }\n+\n+    \/**\n+     * Ensure that all compilations that were enforced (added to compilation queue) by framework annotations are\n+     * completed. Wait if necessary for a short amount of time for their completion.\n+     *\/\n+    private void checkForcedCompilationsCompleted() {\n+        if (forceCompileMap.isEmpty()) {\n+            return;\n+        }\n+        final long started = System.currentTimeMillis();\n+        long elapsed;\n+        do {\n+            forceCompileMap.entrySet().removeIf(entry -> WHITE_BOX.getMethodCompilationLevel(entry.getKey()) == entry.getValue().getValue());\n+            if (forceCompileMap.isEmpty()) {\n+                \/\/ All @ForceCompile methods are compiled at the requested level.\n+                return;\n+            }\n+            \/\/ Retry again if not yet compiled.\n+            forceCompileMap.forEach(TestVM::enqueueForCompilation);\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < 5000);\n+        StringBuilder builder = new StringBuilder();\n+        forceCompileMap.forEach((key, value) -> builder.append(\"- \").append(key).append(\" at CompLevel.\").append(value)\n+                                                       .append(System.lineSeparator()));\n+        throw new TestRunException(\"Could not force compile the following @ForceCompile methods:\"\n+                                   + System.lineSeparator() + builder.toString());\n+    }\n+\n+    \/**\n+     * Once all framework tests are collected, they are run in this method.\n+     *\/\n+    private void runTests() {\n+        TreeMap<Long, String> durations = (PRINT_TIMES || VERBOSE) ? new TreeMap<>() : null;\n+        long startTime = System.nanoTime();\n+        List<AbstractTest> testList;\n+        boolean testFilterPresent = testFilterPresent();\n+        if (testFilterPresent) {\n+            \/\/ Only run the specified tests by the user filters -DTest and\/or -DExclude.\n+            testList = allTests.stream().filter(test -> !test.isSkipped()).collect(Collectors.toList());\n+            if (testList.isEmpty()) {\n+                \/\/ Throw an exception to inform the user about an empty specified test set with -DTest and\/or -DExclude\n+                throw new NoTestsRunException();\n+            }\n+        } else {\n+            testList = allTests;\n+        }\n+\n+        if (SHUFFLE_TESTS) {\n+            \/\/ Execute tests in random order (execution sequence affects profiling). This is done by default.\n+            Collections.shuffle(testList, Utils.getRandomInstance());\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        int failures = 0;\n+\n+        \/\/ Execute all tests and keep track of each exception that is thrown. These are then reported once all tests\n+        \/\/ are executing. This prevents a premature exit without running all tests.\n+        for (AbstractTest test : testList) {\n+            if (VERBOSE) {\n+                System.out.println(\"Run \" + test.toString());\n+            }\n+            if (testFilterPresent) {\n+                TestFrameworkSocket.write(\"Run \" + test.toString(), \"testfilter\", true);\n+            }\n+            try {\n+                test.run();\n+            } catch (TestRunException e) {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                e.printStackTrace(pw);\n+                builder.append(test.toString()).append(\":\").append(System.lineSeparator()).append(sw.toString())\n+                       .append(System.lineSeparator()).append(System.lineSeparator());\n+                failures++;\n+            }\n+            if (PRINT_TIMES || VERBOSE) {\n+                long endTime = System.nanoTime();\n+                long duration = (endTime - startTime);\n+                durations.put(duration, test.getName());\n+                if (VERBOSE) {\n+                    System.out.println(\"Done \" + test.getName() + \": \" + duration + \" ns = \" + (duration \/ 1000000) + \" ms\");\n+                }\n+            }\n+            if (GC_AFTER) {\n+                System.out.println(\"doing GC\");\n+                WHITE_BOX.fullGC();\n+            }\n+        }\n+\n+        \/\/ Print execution times\n+        if (VERBOSE || PRINT_TIMES) {\n+            System.out.println(System.lineSeparator() + System.lineSeparator() + \"Test execution times:\");\n+            for (Map.Entry<Long, String> entry : durations.entrySet()) {\n+                System.out.format(\"%-10s%15d ns%n\", entry.getValue() + \":\", entry.getKey());\n+            }\n+        }\n+\n+        if (failures > 0) {\n+            \/\/ Finally, report all occurred exceptions in a nice format.\n+            String msg = System.lineSeparator() + System.lineSeparator() + \"Test Failures (\" + failures + \")\"\n+                         + System.lineSeparator() + \"----------------\" + \"-\".repeat(String.valueOf(failures).length());\n+            throw new TestRunException(msg + System.lineSeparator() + builder.toString());\n+        }\n+    }\n+\n+    private boolean testFilterPresent() {\n+        return testList != null || excludeList != null;\n+    }\n+\n+    enum TriState {\n+        Maybe,\n+        Yes,\n+        No\n+    }\n+\n+    static void compile(Method m, CompLevel compLevel) {\n+        TestRun.check(compLevel != CompLevel.SKIP && compLevel != CompLevel.WAIT_FOR_COMPILATION,\n+                         \"Invalid compilation request with level \" + compLevel);\n+        enqueueForCompilation(m, compLevel);\n+    }\n+\n+    static void deoptimize(Method m) {\n+        WHITE_BOX.deoptimizeMethod(m);\n+    }\n+\n+    static boolean isCompiled(Method m) {\n+        return compiledAtLevel(m, CompLevel.ANY) == TriState.Yes;\n+    }\n+\n+    static boolean isC1Compiled(Method m) {\n+        return compiledByC1(m) == TriState.Yes;\n+    }\n+\n+    static boolean isC2Compiled(Method m) {\n+        return compiledByC2(m) == TriState.Yes;\n+    }\n+\n+    static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+        return compiledAtLevel(m, compLevel) == TriState.Yes;\n+    }\n+\n+    static void assertDeoptimizedByC1(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C1\");\n+        }\n+    }\n+\n+    static void assertDeoptimizedByC2(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n+            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C2\");\n+        }\n+    }\n+\n+    \/**\n+     * Some VM flags could make the deopt assertions unstable.\n+     *\/\n+    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+        return (USE_COMPILER && !XCOMP && !IGNORE_COMPILER_CONTROLS && !TEST_C1 &&\n+               (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n+    }\n+\n+    static void assertCompiledByC1(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No, m + \" should have been C1 compiled\");\n+    }\n+\n+    static void assertCompiledByC2(Method m) {\n+        TestRun.check(compiledByC2(m) != TriState.No, m + \" should have been C2 compiled\");\n+    }\n+\n+    static void assertCompiledAtLevel(Method m, CompLevel level) {\n+        TestRun.check(compiledAtLevel(m, level) != TriState.No, m + \" should have been compiled at level \" + level.name());\n+    }\n+\n+    static void assertNotCompiled(Method m) {\n+        TestRun.check(!isC1Compiled(m), m + \" should not have been compiled by C1\");\n+        TestRun.check(!isC2Compiled(m), m + \" should not have been compiled by C2\");\n+    }\n+\n+    static void assertCompiled(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No || compiledByC2(m) != TriState.No, m + \" should have been compiled\");\n+    }\n+\n+    private static TriState compiledByC1(Method m) {\n+        TriState triState = compiledAtLevel(m, CompLevel.C1_SIMPLE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_LIMITED_PROFILE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_FULL_PROFILE);\n+        return triState;\n+    }\n+\n+    private static TriState compiledByC2(Method m) {\n+        return compiledAtLevel(m, CompLevel.C2);\n+    }\n+\n+    private static TriState compiledAtLevel(Method m, CompLevel level) {\n+        if (WHITE_BOX.isMethodCompiled(m, false)) {\n+            switch (level) {\n+                case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n+                    if (WHITE_BOX.getMethodCompilationLevel(m, false) == level.getValue()) {\n+                        return TriState.Yes;\n+                    }\n+                }\n+                case ANY -> {\n+                    return TriState.Yes;\n+                }\n+                default -> throw new TestRunException(\"compiledAtLevel() should not be called with \" + level);\n+            }\n+        }\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n+            (EXCLUDE_RANDOM && !WHITE_BOX.isMethodCompilable(m, level.getValue(), false))) {\n+            return TriState.Maybe;\n+        }\n+        return TriState.No;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestVM.java","additions":952,"deletions":0,"binary":false,"changes":952,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"test\" VM with verification of proper termination. The class also stores\n+ * information about the test VM which is later queried for IR matching. The communication between this driver VM\n+ * and the test VM is done over a dedicated socket.\n+ *\n+ * @see TestVM\n+ * @see TestFrameworkSocket\n+ *\/\n+class TestVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PREFER_COMMAND_LINE_FLAGS = Boolean.getBoolean(\"PreferCommandLineFlags\");\n+    private static final int WARMUP_ITERATIONS = Integer.getInteger(\"Warmup\", -1);\n+    private static final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+\n+    private static String lastTestVMOutput = \"\";\n+\n+    private final ArrayList<String> cmds;\n+    private String hotspotPidFileName;\n+    private String commandLine;\n+    private OutputAnalyzer oa;\n+    private String irEncoding;\n+\n+    TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+        this.cmds = new ArrayList<>();\n+        TestFrameworkSocket socket = new TestFrameworkSocket();\n+        try (socket) {\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup);\n+            start();\n+        }\n+        processSocketOutput(socket.getOutput());\n+        checkTestVMExitCode();\n+    }\n+\n+    public String getCommandLine() {\n+        return commandLine;\n+    }\n+\n+    public String getIrEncoding() {\n+        return irEncoding;\n+    }\n+\n+    public String getHotspotPidFileName() {\n+        return hotspotPidFileName;\n+    }\n+\n+    public static String getLastTestVMOutput() {\n+        return lastTestVMOutput;\n+    }\n+\n+    private void prepareTestVMFlags(List<String> additionalFlags, TestFrameworkSocket socket, Class<?> testClass,\n+                                    Set<Class<?>> helperClasses, int defaultWarmup) {\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        \/\/ Need White Box access in test VM.\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        String[] jtregVMFlags = Utils.getTestJavaOpts();\n+        if (!PREFER_COMMAND_LINE_FLAGS) {\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+        \/\/ Add server property flag that enables test VM to print encoding for IR verification last and debug messages.\n+        cmds.add(socket.getPortPropertyFlag());\n+        cmds.addAll(additionalFlags);\n+        cmds.addAll(Arrays.asList(getDefaultFlags()));\n+        if (VERIFY_VM) {\n+            cmds.addAll(Arrays.asList(getVerifyFlags()));\n+        }\n+\n+        if (PREFER_COMMAND_LINE_FLAGS) {\n+            \/\/ Prefer flags set via the command line over the ones set by scenarios.\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+\n+        if (WARMUP_ITERATIONS < 0 && defaultWarmup != -1) {\n+            \/\/ Only use the set warmup for the framework if not overridden by a valid -DWarmup property set by a test.\n+            cmds.add(\"-DWarmup=\" + defaultWarmup);\n+        }\n+\n+        cmds.add(TestVM.class.getName());\n+        cmds.add(testClass.getName());\n+        if (helperClasses != null) {\n+            helperClasses.forEach(c -> cmds.add(c.getName()));\n+        }\n+    }\n+\n+    \/**\n+     * Default flags that are added used for the test VM.\n+     *\/\n+    private static String[] getDefaultFlags() {\n+        return new String[] {\"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=quiet\"};\n+    }\n+\n+    \/**\n+     * Additional verification flags that are used if -DVerifyVM=true is with a debug build.\n+     *\/\n+    private static String[] getVerifyFlags() {\n+        return new String[] {\n+                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\",\n+                \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\", \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"\n+        };\n+    }\n+\n+    private void start() {\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(cmds);\n+        try {\n+            \/\/ Calls 'main' of TestVM to run all specified tests with commands 'cmds'.\n+            \/\/ Use executeProcess instead of executeTestJvm as we have already added the JTreg VM and\n+            \/\/ Java options in prepareTestVMFlags().\n+            oa = ProcessTools.executeProcess(process);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Error while executing Test VM\", e);\n+        }\n+        commandLine = \"Command Line:\" + System.lineSeparator() + String.join(\" \", process.command())\n+                      + System.lineSeparator();\n+        hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n+        lastTestVMOutput = oa.getOutput();\n+    }\n+\n+    \/**\n+     * Process the socket output: All prefixed lines are dumped to the standard output while the remaining lines\n+     * represent the IR encoding used for IR matching later.\n+     *\/\n+    private void processSocketOutput(String output) {\n+        if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n+            StringBuilder builder = new StringBuilder();\n+            Scanner scanner = new Scanner(output);\n+            System.out.println(System.lineSeparator() + \"Run flag defined test list\");\n+            System.out.println(\"--------------------------\");\n+            while (scanner.hasNextLine()) {\n+                String line = scanner.nextLine();\n+                if (line.startsWith(TestFrameworkSocket.STDOUT_PREFIX)) {\n+                    line = \"> \" + line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n+                    System.out.println(line);\n+                } else {\n+                    builder.append(line).append(System.lineSeparator());\n+                }\n+            }\n+            System.out.println();\n+            irEncoding = builder.toString();\n+        } else {\n+            irEncoding = output;\n+        }\n+    }\n+\n+    private void checkTestVMExitCode() {\n+        final int exitCode = oa.getExitValue();\n+        if (EXCLUDE_RANDOM || REPORT_STDOUT || (VERBOSE && exitCode == 0)) {\n+            System.out.println(\"--- OUTPUT TestFramework test VM ---\");\n+            System.out.println(oa.getOutput());\n+        }\n+\n+        if (exitCode != 0) {\n+            throwTestVMException();\n+        }\n+    }\n+\n+    \/**\n+     * Exit code was non-zero of test VM. Check the stderr to determine what kind of exception that should be thrown to\n+     * react accordingly later.\n+     *\/\n+    private void throwTestVMException() {\n+        String stdErr = oa.getStderr();\n+        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n+            Pattern pattern = Pattern.compile(\"Violations \\\\(\\\\d+\\\\)[\\\\s\\\\S]*(?=\/============\/)\");\n+            Matcher matcher = pattern.matcher(stdErr);\n+            TestFramework.check(matcher.find(), \"Must find violation matches\");\n+            throw new TestFormatException(System.lineSeparator() + System.lineSeparator() + matcher.group());\n+        } else if (stdErr.contains(\"NoTestsRunException\")) {\n+            throw new NoTestsRunException(\">>> No tests run due to empty set specified with -DTest and\/or -DExclude. \" +\n+                                          \"Make sure to define a set of at least one @Test method\");\n+        } else {\n+            throw new TestVMException(getExceptionInfo());\n+        }\n+    }\n+\n+    \/**\n+     * Get more detailed information about the exception in a pretty format.\n+     *\/\n+    private String getExceptionInfo() {\n+        int exitCode = oa.getExitValue();\n+        String stdErr = oa.getStderr();\n+        String stdOut = \"\";\n+        if (exitCode == 134) {\n+            \/\/ Also dump the stdout if we experience a JVM error (e.g. to show hit assertions etc.).\n+            stdOut = System.lineSeparator() + System.lineSeparator() + \"Standard Output\" + System.lineSeparator()\n+                     + \"---------------\" + System.lineSeparator() + oa.getOutput();\n+        }\n+        return \"TestFramework test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n+               + System.lineSeparator() + commandLine + System.lineSeparator() + System.lineSeparator()\n+               + \"Error Output\" + System.lineSeparator() + \"------------\" + System.lineSeparator() + stdErr\n+               + System.lineSeparator() + System.lineSeparator();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestVMProcess.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n- *     <li><p>Invoke @Test method {@link TestFrameworkExecution#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n@@ -49,1 +49,1 @@\n- *     <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestFrameworkExecution.WARMUP_ITERATIONS)<\/li>\n+ *     <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/BaseTestExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *     <li><p>Invoke @Test method {@link TestFrameworkExecution#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n@@ -50,1 +50,1 @@\n- *         <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestFrameworkExecution.WARMUP_ITERATIONS)<\/li>\n+ *         <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/CheckedTestExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *     <li><p>Invoke @Run method {#link TestFrameworkExecution#WARMUP_ITERATIONS} many times. Note that the @Run method\n+ *     <li><p>Invoke @Run method {@link TestVM#WARMUP_ITERATIONS} many times. Note that the @Run method\n@@ -60,1 +60,1 @@\n- *                         TestFrameworkExecution.WARMUP_ITERATIONS)<\/li>\n+ *                         TestVM.WARMUP_ITERATIONS)<\/li>\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/CustomRunTestExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                TestFramework.runWithHelperClasses(clazz, helpers);\n+                new TestFramework(clazz).addHelperClasses(helpers).start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestBadFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Method runTestsOnSameVM = TestFrameworkExecution.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n@@ -64,1 +64,1 @@\n-            if (value != TestFrameworkExecution.WARMUP_ITERATIONS + 1) {\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n@@ -67,1 +67,1 @@\n-                        + (TestFrameworkExecution.WARMUP_ITERATIONS + 1) + \" times.\" );\n+                                           + (TestVM.WARMUP_ITERATIONS + 1) + \" times.\" );\n@@ -1032,1 +1032,1 @@\n-        for (int i = 0; i < TestFrameworkExecution.WARMUP_ITERATIONS + 1; i++) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n@@ -1076,1 +1076,1 @@\n-        for (int i = 0; i < TestFrameworkExecution.WARMUP_ITERATIONS + 1; i++) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestBasics.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        Method runTestsOnSameVM = TestFrameworkExecution.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n@@ -50,1 +50,1 @@\n-            if (value != TestFrameworkExecution.WARMUP_ITERATIONS + 1) {\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n@@ -53,1 +53,1 @@\n-                                                   + TestFrameworkExecution.WARMUP_ITERATIONS + 1 + \" times.\" );\n+                                           + TestVM.WARMUP_ITERATIONS + 1 + \" times.\" );\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestCompLevels.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Method runTestsOnSameVM = TestFrameworkExecution.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n@@ -58,1 +58,1 @@\n-        final int defaultIterations = TestFrameworkExecution.WARMUP_ITERATIONS + 1;\n+        final int defaultIterations = TestVM.WARMUP_ITERATIONS + 1;\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestControls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                    TestFramework.runWithScenarios(bad, s1, s2, s3);\n+                    new TestFramework().addScenarios(bad, s1, s2, s3).start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDScenarios.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-        TestFramework.runWithFlags(clazz, args);\n+        new TestFramework(clazz).addFlags(args).start();\n@@ -258,1 +258,1 @@\n-            TestFramework.runWithFlags(constraints[0].getKlass(), args); \/\/ All constraints have the same class.\n+            new TestFramework(constraints[0].getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n@@ -274,2 +274,2 @@\n-    private static void checkConstraints(RuntimeException e, Constraint[] constraints) {\n-        String message = e.getMessage();\n+    private static void checkConstraints(IRViolationException e, Constraint[] constraints) {\n+        String message = e.getExceptionInfo();\n@@ -290,1 +290,1 @@\n-            TestFramework.runWithFlags(constraint.getKlass(), args); \/\/ All constraints have the same class.\n+            new TestFramework(constraint.getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n@@ -1388,2 +1388,2 @@\n-    public void checkConstraint(RuntimeException e) {\n-        String message = e.getMessage();\n+    public void checkConstraint(IRViolationException e) {\n+        String message = e.getExceptionInfo();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestIRMatching.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-            Arrays.stream(matches).forEach(m -> Asserts.assertTrue(e.getMessage().contains(m)));\n-            Asserts.assertEQ(e.getMessage().split(\"STANDALONE mode\", -1).length - 1, 2);\n+            Arrays.stream(matches).forEach(m -> Asserts.assertTrue(e.getExceptionInfo().contains(m)));\n+            Asserts.assertEQ(e.getExceptionInfo().split(\"STANDALONE mode\", -1).length - 1, 2);\n@@ -51,5 +51,5 @@\n-        TestFramework.runWithFlags(SkipCompilation.class, \"-XX:-UseCompiler\");\n-        TestFramework.runWithFlags(SkipCompilation.class, \"-Xint\");\n-        TestFramework.runWithFlags(SkipC2Compilation.class, \"-XX:TieredStopAtLevel=1\");\n-        TestFramework.runWithFlags(SkipC2Compilation.class, \"-XX:TieredStopAtLevel=2\");\n-        TestFramework.runWithFlags(SkipC2Compilation.class, \"-XX:TieredStopAtLevel=3\");\n+        new TestFramework(SkipCompilation.class).addFlags(\"-XX:-UseCompiler\").start();\n+        new TestFramework(SkipCompilation.class).addFlags(\"-Xint\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=1\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=2\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=3\").start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestRunTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,3 +43,4 @@\n-        TestFramework.runWithFlags(TestSanity.class, \"-XX:SuspendRetryCount=51\", \"-XX:+UseTLAB\");\n-        TestFramework.runWithHelperClasses(TestSanity.class, HelperA.class);\n-        TestFramework.runWithHelperClasses(TestSanity.class, HelperA.class, HelperB.class);\n+        new TestFramework().addFlags(\"-XX:SuspendRetryCount=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework(TestSanity.class).addFlags(\"-XX:SuspendRetryCount=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework().addHelperClasses(HelperA.class).start();\n+        new TestFramework(TestSanity.class).addHelperClasses(HelperA.class, HelperB.class).start();\n@@ -49,7 +50,7 @@\n-        TestFramework.runWithScenarios(s1);\n-        TestFramework.runWithScenarios(s1, s2);\n-        TestFramework.runWithScenarios(TestSanity.class, s1, s2);\n-        TestFramework.runWithScenarios(sDefault, s1);\n-        TestFramework.runWithScenarios(sDefault, s1, s2);\n-        TestFramework.runWithScenarios(TestSanity.class, sDefault, s1);\n-        TestFramework.runWithScenarios(TestSanity.class, sDefault, s1, s2);\n+        new TestFramework(TestSanity.class).addScenarios(s1).start();\n+        new TestFramework().addScenarios(s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(s1, s2).start();\n+        new TestFramework().addScenarios(sDefault, s1).start();\n+        new TestFramework().addScenarios(sDefault, s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1, s2).start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestSanity.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            TestFramework.runWithScenarios(sDefault, s1, s2, s3);\n+            new TestFramework().addScenarios(sDefault, s1, s2, s3).start();\n@@ -51,1 +51,1 @@\n-            TestFramework.runWithScenarios(s1, s2, s3);\n+            new TestFramework().addScenarios(s1, s2, s3).start();\n@@ -56,2 +56,1 @@\n-\n-        TestFramework.runWithScenarios(ScenarioTest.class, s1, s2, s3);\n+        new TestFramework(ScenarioTest.class).addScenarios(s1, s2, s3).start();\n@@ -59,1 +58,1 @@\n-            TestFramework.runWithScenarios(s1, s3dup, s2, s3);\n+            new TestFramework().addScenarios(s1, s3dup, s2, s3).start();\n@@ -65,1 +64,1 @@\n-            TestFramework.runWithScenarios(MyExceptionTest.class, s1, s2, s3);\n+            new TestFramework(MyExceptionTest.class).addScenarios(s1, s2, s3).start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestScenarios.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        TestFramework.runWithHelperClasses(TestWithHelperClasses.class, Helper1.class, Helper2.class);\n+        new TestFramework().addHelperClasses(Helper1.class, Helper2.class).start();\n@@ -41,1 +41,1 @@\n-            TestFramework.runWithHelperClasses(TestWithHelperClasses.class, Helper1.class);\n+            new TestFramework().addHelperClasses(Helper1.class).start();\n@@ -53,1 +53,1 @@\n-            TestFramework.runWithHelperClasses(BadHelperClass.class, BadHelper.class);\n+            new TestFramework(BadHelperClass.class).addHelperClasses(BadHelper.class).start();\n@@ -67,1 +67,1 @@\n-            TestFramework.runWithHelperClasses(TestAsHelper.class, TestAsHelper.class);\n+            new TestFramework(TestAsHelper.class).addHelperClasses(TestAsHelper.class).start();\n@@ -75,1 +75,1 @@\n-            TestFramework.runWithHelperClasses(TestWithHelperClasses.class, NestedHelper.class);\n+            new TestFramework().addHelperClasses(NestedHelper.class).start();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestWithHelperClasses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}