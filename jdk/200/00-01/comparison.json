{"files":[{"patch":"@@ -59,2 +59,9 @@\n-     * -find non-empty packages with the given name returned by {@link #getPackageElement(ModuleElement, CharSequence)}, where the provided ModuleSymbol is any root module,\n-     * -if the above yields an empty list, search all modules for observable packages with the given name\n+     * <ul>\n+     *     <li>find non-empty packages with the given name returned by\n+     *         {@link #getPackageElement(ModuleElement, CharSequence)},\n+     *         where the provided ModuleSymbol is any root module,\n+     *     <\/li>\n+     *     <li>if the above yields an empty list, search all modules for\n+     *         observable packages with the given name\n+     *     <\/li>\n+     * <\/ul>\n@@ -62,1 +69,2 @@\n-     * If this process leads to a list with a single element, the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element,\n+     * the single element is returned, otherwise null is returned.\n@@ -64,2 +72,4 @@\n-     * @param name  fully qualified package name, or an empty string for an unnamed package\n-     * @return the specified package, or {@code null} if no package can be uniquely determined.\n+     * @param name fully qualified package name,\n+     *             or an empty string for an unnamed package\n+     * @return the specified package,\n+     *         or {@code null} if no package can be uniquely determined.\n@@ -132,4 +142,11 @@\n-     * If running with modules, type elements of the given name are searched in a\n-     * two-stage process:\n-     * -find type elements with the given name returned by {@link #getTypeElement(ModuleElement, CharSequence)}, where the provided ModuleSymbol is any root module,\n-     * -if the above yields an empty list, search all modules for observable type elements with the given name\n+     * If running with modules, type elements of the given name are\n+     * searched in a two-stage process:\n+     * <ul>\n+     *     <li>find type elements with the given name returned by\n+     *         {@link #getTypeElement(ModuleElement, CharSequence)},\n+     *         where the provided ModuleSymbol is any root module,\n+     *     <\/li>\n+     *     <li>if the above yields an empty list, search all modules\n+     *         for observable type elements with the given name\n+     *     <\/li>\n+     * <\/ul>\n@@ -137,1 +154,2 @@\n-     * If this process leads to a list with a single element, the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element,\n+     * the single element is returned, otherwise null is returned.\n@@ -139,2 +157,3 @@\n-     * @param name  the canonical name\n-     * @return the named type element, or {@code null} if no type element can be uniquely determined.\n+     * @param name the canonical name\n+     * @return the named type element,\n+     *         or {@code null} if no type element can be uniquely determined.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+            Set<ModuleSymbol> allModules = new HashSet<>(modules.allModules());\n@@ -203,2 +204,4 @@\n-            for (Set<ModuleSymbol> allModules : Arrays.asList(modules.getRootModules(), modules.allModules())) {\n-                for (ModuleSymbol msym : allModules) {\n+            allModules.removeAll(modules.getRootModules());\n+\n+            for (Set<ModuleSymbol> modules : Arrays.asList(modules.getRootModules(), allModules)) {\n+                for (ModuleSymbol msym : modules) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}