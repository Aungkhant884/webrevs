{"files":[{"patch":"@@ -0,0 +1,518 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 4925447 4887054 8285604\n+ * @key headful\n+ * @summary verifies that most basic rendering operations going are successfully\n+ * clipped against a complex clip shape\n+ * @run main ClipShapeRendering\n+*\/\n+\n+\/**\n+ * This test creates a complex clip shape (basically, a rectangular hole\n+ * cut out of the center of the rendering area) and then cycles through\n+ * various rendering primitives (image copies, lines, text, and shapes)\n+ * under various situations (default, scaled transform, and wide lines).\n+ * After all of that, Robot is used to check whether the clip shape has\n+ * been disturbed by any of the rendering (no pixels from the rendering\n+ * operations should have done anything inside the clipped-out area); the\n+ * test passes or fails based on whether the clip shape is undisturbed.\n+ *\n+ * There is a performance-test version of this app which runs all of the\n+ * tests in loops and times the results.  This can be useful to see, for\n+ * example, the difference in performance between old and new internal\n+ * implementations of this clip-shape situation.  To run the performance\n+ * test, run ClipShapeRendering -perf.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.Stroke;\n+import java.awt.Toolkit;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Area;\n+import java.awt.geom.GeneralPath;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.WritableRaster;\n+\n+\n+public class ClipShapeRendering extends Frame {\n+    BufferedImage image;\n+    BufferedImage imageBM;\n+\n+    static Image offScreenImage;\n+    static boolean timeToRun = false;\n+    static Color imageColor = Color.red;\n+    static Color fillColor = Color.blue;\n+    static boolean perfMode = false;\n+    static boolean showCapture = false;\n+    static Rectangle clipRect = new Rectangle(100, 100, 100, 100);\n+\n+    \/\/ move away from cursor\n+    private final static int OFFSET_X = 20;\n+    private final static int OFFSET_Y = 20;\n+\n+    public ClipShapeRendering() {\n+        super(\"On-screen rendering test frame\");\n+    }\n+\n+    public void initImages(Color imageColor) {\n+        int w = getWidth();\n+        int h = getHeight();\n+\n+        ColorModel cm = new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);\n+        WritableRaster wr =\n+            cm.createCompatibleWritableRaster(w, h);\n+        imageBM = new BufferedImage(cm, wr,\n+                                  cm.isAlphaPremultiplied(), null);\n+        Graphics g2 = imageBM.createGraphics();\n+        g2.setColor(imageColor);\n+        g2.fillRect(0, 0, w, h);\n+\n+        image = new BufferedImage(w, h,\n+                                  BufferedImage.TYPE_INT_RGB);\n+        g2 = image.createGraphics();\n+        g2.setColor(imageColor);\n+        g2.fillRect(0,0, w, h);\n+        g2.dispose();\n+\n+        offScreenImage = createImage(w, h);\n+    }\n+\n+    public void paint(Graphics g) {\n+        synchronized (this) {\n+            timeToRun = true;\n+            notifyAll();\n+        }\n+    }\n+\n+    public void runTests() {\n+        initImages(imageColor);\n+\n+        \/\/ run off-screen test\n+        System.out.println(\"Running OFF-SCREEN tests..\");\n+        runTest(offScreenImage.getGraphics());\n+\n+        \/\/ run on-screen test\n+        System.out.println(\"Running ON-SCREEN tests..\");\n+        runTest(getGraphics());\n+    }\n+\n+    \/**\n+     * Set various parameters on the Graphics object and call the\n+     * rendering loop with each variation\n+     *\/\n+    public void runTest(Graphics g) {\n+        int w = getWidth();\n+        int h = getHeight();\n+        Area area = new Area( new Rectangle(0,0, w, h));\n+        area.subtract(new Area(clipRect));\n+        \/\/ Fill completely with background color\n+        g.setColor(fillColor);\n+        g.fillRect(0, 0, w, h);\n+\n+        \/\/ Set the clip shape\n+        g.setClip(area);\n+\n+        \/\/ Now perform various rendering operations\n+        g.setColor(Color.black);\n+        Graphics2D g2 = (Graphics2D)g;\n+        if (perfMode) {\n+            System.out.println(\"Default Graphics Results:\");\n+            System.out.println(\"-------------------------\");\n+        }\n+        renderingLoop(g2);\n+\n+        if (perfMode) {\n+            System.out.println(\"Scaling Transform Results:\");\n+            System.out.println(\"-------------------------\");\n+        }\n+        AffineTransform oldXform = g2.getTransform();\n+        g2.scale(.9, 1.15);\n+        renderingLoop(g2);\n+        g2.setTransform(oldXform);\n+\n+        if (perfMode) {\n+            System.out.println(\"Wide Lines Results:\");\n+            System.out.println(\"-------------------\");\n+        }\n+        Stroke oldStroke = g2.getStroke();\n+        g2.setStroke(new BasicStroke(5.0f));\n+        renderingLoop(g2);\n+        g2.setStroke(oldStroke);\n+    }\n+\n+    public void renderingLoop(Graphics2D g) {\n+        int numReps = 1;\n+        int numTextReps = 1;\n+        long start, end;\n+        if (perfMode) {\n+            numReps = 1000;\n+            numTextReps = 50;\n+        }\n+        int w = getWidth();\n+        int h = getHeight();\n+\n+        \/\/ Image copies\n+        robot.waitForIdle();\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numReps; ++i) {\n+            g.drawImage(image, 0, 0, null);\n+            g.drawImage(image, -10, -10, null);\n+            g.drawImage(image, 50, 50, null);\n+            g.drawImage(image, 40, 10, null);\n+        }\n+        for (int i = 0; i < numReps; ++i) {\n+            g.drawImage(imageBM, 0, 0, Color.yellow, null);\n+            g.drawImage(imageBM, -10, -10, Color.yellow, null);\n+            g.drawImage(imageBM, 50, 50, Color.yellow, null);\n+            g.drawImage(imageBM, 40, 10, Color.yellow, null);\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"Image Copies   : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ Image scales\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numReps; ++i) {\n+            g.drawImage(image, 0, 0, 500, 500, null);\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"Image scales   : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ Lines\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numReps; ++i) {\n+            g.drawLine(0, 0, w, h);\n+            g.drawLine(0, h, w, 0);\n+            g.drawLine(0, h \/ 2, w, h \/ 2);\n+            g.drawLine(w \/ 2, 0, w \/ 2, h);\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"drawLine       : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ Text\n+\n+        \/\/ Non-AA\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numTextReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawString(\"This is a string, this is only a string\", x,\n+                                 y);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"Text Non-AA    : \" + (end - start) + \" ms\");\n+        }\n+        \/\/ Anti-Aliased\n+        Graphics2D g2 = (Graphics2D)g;\n+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                            RenderingHints.VALUE_ANTIALIAS_ON);\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numTextReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawString(\"This is a string, this is only a string\", x,\n+                                 y);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"Text General AA: \" + (end - start) + \" ms\");\n+        }\n+        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                            RenderingHints.VALUE_ANTIALIAS_OFF);\n+        \/\/ Text AA\n+        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                            RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numTextReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawString(\"This is a string, this is only a string\", x,\n+                                 y);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"Text textAA    : \" + (end - start) + \" ms\");\n+        }\n+        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                            RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+\n+        \/\/ Arcs\n+        start = System.currentTimeMillis();\n+        if (numReps > 1) {\n+            numReps \/= 10;\n+        }\n+        for (int i = 0; i < numReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawArc(x, y, 30, 30, 0, 45);\n+                    g.fillArc(x, y, 25, 25, 0, 45);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"arcs           : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ Ovals\n+        start = System.currentTimeMillis();\n+        if (numReps > 1) {\n+            numReps \/= 10;\n+        }\n+        for (int i = 0; i < numReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawOval(x, y, 20, 20);\n+                    g.fillOval(x, y, 15, 15);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"ovals          : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ Rects\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numReps; ++i) {\n+            for (int x = 0; x < w; x += 20) {\n+                for (int y = 0; y < h; y += 17) {\n+                    g.drawRect(x, y, 20, 20);\n+                    g.fillRect(x, y, 18, 18);\n+                }\n+            }\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"rects          : \" + (end - start) + \" ms\");\n+        }\n+\n+        \/\/ GeneralPath rendering\n+        GeneralPath drawGP = new GeneralPath();\n+        for (int i = 0; i < 30; ++i) {\n+            Rectangle rect = new Rectangle(5 * i, 2 * i, 27, 19);\n+            drawGP.append(rect, false);\n+        }\n+        GeneralPath fillGP = new GeneralPath();\n+        for (int i = 0; i < 30; ++i) {\n+            Rectangle rect = new Rectangle(5 * i, 100 + 2 * i, 27, 19);\n+            fillGP.append(rect, false);\n+        }\n+        Graphics2D g2d = (Graphics2D)g;\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < numReps; ++i) {\n+            g2d.draw(drawGP);\n+            g2d.fill(fillGP);\n+        }\n+        robot.waitForIdle();\n+        end = System.currentTimeMillis();\n+        if (perfMode) {\n+            System.out.println(\"GeneralPath    : \" + (end - start) + \" ms\");\n+        }\n+\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"java ClipShapeRendering [-perf] [-show]\");\n+        System.err.println(\"  -perf : runs performance benchmark (1000 reps)\");\n+        System.err.println(\"  -show : shows a frame with captured clip area\");\n+        System.exit(1);\n+    }\n+\n+    public static boolean checkResult(BufferedImage clientPixels) {\n+        int pixels[] = new int[clipRect.width * clipRect.height];\n+        clientPixels.getRGB(0, 0, clipRect.width,\n+                            clipRect.height, pixels, 0,\n+                            clipRect.width);\n+        int pixelIndex = 0;\n+        for (int row = 0; row < clipRect.height; ++row) {\n+            for (int col = 0; col < clipRect.width; ++col) {\n+                if (!(new Color(pixels[pixelIndex])).equals(fillColor)) {\n+                    System.err.println(\"Incorrect color \" +\n+                                       Integer.toHexString(pixels[pixelIndex]) +\n+                                       \" instead of \" +\n+                                       Integer.toHexString(fillColor.getRGB()) +\n+                                       \" in pixel (\" + (clipRect.x + col) +\n+                                       \", \" + (clipRect.y + row) + \")\");\n+                    return false;\n+                }\n+                pixelIndex++;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    static volatile Robot robot;\n+    public static void main(String args[]) throws Exception {\n+\n+        for (int i = 0; i < args.length; ++i) {\n+            if (args[i].equals(\"-perf\")) {\n+                perfMode = true;\n+            } else if (args[i].equals(\"-show\")) {\n+                showCapture = true;\n+            } else {\n+                usage();\n+            }\n+        }\n+\n+        try {\n+            robot = new Robot();\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Can't create robot: \" + e);\n+        }\n+\n+        ClipShapeRendering clipTest = new ClipShapeRendering();\n+        clipTest.setSize(300, 300);\n+        clipTest.setLocationRelativeTo(null);\n+        clipTest.setAlwaysOnTop(true);\n+        clipTest.setVisible(true);\n+        try {\n+            synchronized (clipTest) {\n+                while (!timeToRun) {\n+                    clipTest.wait(300);\n+                }\n+            }\n+        } catch (InterruptedException e) {}\n+\n+        clipTest.runTests();\n+\n+        \/\/ check off-screen rendering;\n+        BufferedImage offScreenClientPixels =\n+            (BufferedImage)clipTest.createImage(clipRect.width,\n+                                                clipRect.height);\n+        Graphics clientG = offScreenClientPixels.getGraphics();\n+        clientG.drawImage(offScreenImage,\n+                          0, 0, clipRect.width, clipRect.height,\n+                          clipRect.x, clipRect.y,\n+                          clipRect.x + clipRect.width,\n+                          clipRect.y + clipRect.height,\n+                          null);\n+        if (showCapture) {\n+            CaptureFrame f =\n+                new CaptureFrame(\"OffScreen Image\", offScreenImage);\n+            f.setVisible(true);\n+        }\n+\n+        \/\/ check onscreen rendering\n+        Point clientLoc = clipTest.getLocationOnScreen();\n+        Rectangle r = (Rectangle)clipRect.clone();\n+        r.translate(clientLoc.x, clientLoc.y);\n+\n+        \/\/ move mouse cursor away from captured region as in some system\n+        \/\/ cursor remain visible in composite captured image\n+        robot.mouseMove(r.x - OFFSET_X, r.y - OFFSET_Y);\n+        robot.waitForIdle();\n+        BufferedImage onScreenClientPixels = robot.createScreenCapture(r);\n+        try { Thread.sleep(1000); } catch (Exception e) {}\n+        if (showCapture) {\n+            CaptureFrame f =\n+                new CaptureFrame(\"Onscreen clip area\", onScreenClientPixels);\n+            f.setVisible(true);\n+        } else {\n+            clipTest.dispose();\n+        }\n+\n+\n+        System.out.print(\"Checking results for off-screen rendering..\");\n+        boolean offScreenPassed = checkResult(offScreenClientPixels);\n+        System.out.println(\"done.\");\n+\n+        System.out.print(\"Checking results for on-screen rendering..\");\n+        boolean onScreenPassed = checkResult(onScreenClientPixels);\n+        System.out.println(\"done.\");\n+        if (!offScreenPassed || !onScreenPassed) {\n+            javax.imageio.ImageIO.write(offScreenClientPixels, \"png\", new java.io.File(\"offscreen.png\"));\n+            javax.imageio.ImageIO.write(onScreenClientPixels, \"png\", new java.io.File(\"onscreen.png\"));\n+            throw new RuntimeException(\"Test failed. off-screen: \" +\n+                                       (offScreenPassed?\"passed\":\"failed\") +\n+                                       \"   on-screen: \" +\n+                                       (onScreenPassed?\"passed\":\"failed\"));\n+        }\n+        System.out.println(\"Passed\");\n+    }\n+\n+    static {\n+        System.setProperty(\"sun.java2d.pmoffscreen\", \"true\");\n+    }\n+\n+}\n+\n+class CaptureFrame extends Frame {\n+   static int x = 300, y = 0;\n+   Image clientPixels;\n+   public CaptureFrame(String title,  Image clientPixels) {\n+       super(\"Capture Frame: \" + title);\n+       this.clientPixels = clientPixels;\n+       int w = clientPixels.getWidth(null);\n+       int h = clientPixels.getHeight(null);\n+       setSize(w, h + 30);\n+       setLocation(x, y);\n+       x += w;\n+       if (x + w > 1024) {\n+           x = 300;\n+           y += h;\n+       }\n+       add(new Component() {\n+           public void paint(Graphics g) {\n+               g.drawImage(CaptureFrame.this.clientPixels, 0, 0, null);\n+           }\n+       });\n+   }\n+};\n","filename":"test\/jdk\/sun\/java2d\/GdiRendering\/ClipShapeRendering.java","additions":518,"deletions":0,"binary":false,"changes":518,"status":"added"}]}