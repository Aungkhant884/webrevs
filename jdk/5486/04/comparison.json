{"files":[{"patch":"@@ -123,1 +123,1 @@\n-    Map<String,byte[]> moduleInfos = new HashMap<>();\n+    Map<String, ModuleInfoEntry> moduleInfos = new HashMap<>();\n@@ -804,1 +804,3 @@\n-                    moduleInfos.putIfAbsent(name, Files.readAllBytes(f.toPath()));\n+                    Long lastModified = f.lastModified() == 0 ? null : f.lastModified();\n+                    moduleInfos.putIfAbsent(name,\n+                            new StreamedModuleInfoEntry(name, Files.readAllBytes(f.toPath()), lastModified));\n@@ -898,1 +900,1 @@\n-                   Map<String,byte[]> moduleInfos,\n+                   Map<String, ModuleInfoEntry> moduleInfos,\n@@ -947,1 +949,2 @@\n-                moduleInfos.putIfAbsent(name, zis.readAllBytes());\n+                Long lastModified = e.getTime() == -1 ? null : e.getTime();\n+                moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), lastModified));\n@@ -1031,1 +1034,1 @@\n-    private void updateModuleInfo(Map<String,byte[]> moduleInfos, ZipOutputStream zos)\n+    private void updateModuleInfo(Map<String, ModuleInfoEntry> moduleInfos, ZipOutputStream zos)\n@@ -1035,1 +1038,1 @@\n-        for (Map.Entry<String,byte[]> mi : moduleInfos.entrySet()) {\n+        for (Map.Entry<String, ModuleInfoEntry> mi : moduleInfos.entrySet()) {\n@@ -1037,1 +1040,1 @@\n-            byte[] bytes = mi.getValue();\n+            byte[] bytes = mi.getValue().readAllBytes();\n@@ -1039,1 +1042,2 @@\n-            e.setTime(System.currentTimeMillis());\n+            Long lastModified = mi.getValue().getLastModifiedTime();\n+            e.setTime(lastModified == null ? System.currentTimeMillis() : lastModified);\n@@ -1734,1 +1738,1 @@\n-     * bytes and an optional URI. Used when describing modules.\n+     * bytes and an optional URI.\n@@ -1740,0 +1744,11 @@\n+        \/**\n+         * @return Returns the last modified time of the module descriptor.\n+         * Returns null if the last modified time is unknown or cannot be\n+         * determined.\n+         *\/\n+       Long getLastModifiedTime();\n+       default byte[] readAllBytes() throws IOException {\n+            try (InputStream is = bytes()) {\n+                return is.readAllBytes();\n+            }\n+       }\n@@ -1753,0 +1768,6 @@\n+\n+        @Override\n+        public Long getLastModifiedTime() {\n+            return entry.getTime() == -1 ? null : entry.getTime();\n+        }\n+\n@@ -1764,1 +1785,3 @@\n-        StreamedModuleInfoEntry(String name, byte[] bytes) {\n+        private final Long lastModifiedTime;\n+\n+        StreamedModuleInfoEntry(String name, byte[] bytes, Long lastModifiedTime) {\n@@ -1767,0 +1790,1 @@\n+            this.lastModifiedTime = lastModifiedTime;\n@@ -1772,0 +1796,11 @@\n+\n+        @Override\n+        public byte[] readAllBytes() throws IOException {\n+            return bytes;\n+        }\n+\n+        @Override\n+        public Long getLastModifiedTime() {\n+            return lastModifiedTime;\n+        }\n+\n@@ -1823,1 +1858,2 @@\n-                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes()));\n+                    Long lastModified = e.getTime() == -1 ? null : e.getTime();\n+                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes(), lastModified));\n@@ -2036,1 +2072,1 @@\n-    private boolean checkModuleInfo(byte[] moduleInfoBytes, Set<String> entries)\n+    private boolean checkModuleInfo(ModuleInfoEntry moduleInfoEntry, Set<String> entries)\n@@ -2040,1 +2076,1 @@\n-        if (moduleInfoBytes != null) {  \/\/ no root module-info.class if null\n+        if (moduleInfoEntry != null) {  \/\/ no root module-info.class if null\n@@ -2043,1 +2079,1 @@\n-                ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes));\n+                ModuleDescriptor md = ModuleDescriptor.read(moduleInfoEntry.bytes());\n@@ -2061,1 +2097,1 @@\n-     * Map values are updated in-place. Returns false if an error occurs.\n+     * Map values are updated in-place.\n@@ -2063,1 +2099,1 @@\n-    private void addExtendedModuleAttributes(Map<String,byte[]> moduleInfos,\n+    private void addExtendedModuleAttributes(Map<String, ModuleInfoEntry> moduleInfos,\n@@ -2067,3 +2103,6 @@\n-        for (Map.Entry<String,byte[]> e: moduleInfos.entrySet()) {\n-            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(e.getValue()));\n-            e.setValue(extendedInfoBytes(md, e.getValue(), packages));\n+        for (Map.Entry<String, ModuleInfoEntry> e: moduleInfos.entrySet()) {\n+            byte[] bytes = e.getValue().readAllBytes();\n+            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(bytes));\n+            byte[] extended = extendedInfoBytes(md, bytes, packages);\n+            \/\/ replace the entry value with the extended bytes\n+            e.setValue(new StreamedModuleInfoEntry(e.getValue().name(), extended, e.getValue().getLastModifiedTime()));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":58,"deletions":19,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.module.ModuleDescriptor;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import java.util.spi.ToolProvider;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/**\n+ * @test\n+ * @bug 8258117\n+ * @summary Tests that the content generated for module-info.class, using the jar command, is reproducible\n+ * @run testng JarToolModuleDescriptorReproducibilityTest\n+ *\/\n+public class JarToolModuleDescriptorReproducibilityTest {\n+\n+    private static final String MODULE_NAME = \"foo\";\n+    private static final String MODULE_VERSION = \"1.2.3\";\n+    private static final String UPDATED_MODULE_VERSION = \"1.2.4\";\n+    private static final String MAIN_CLASS = \"jdk.test.foo.Foo\";\n+    private static final Path MODULE_CLASSES_DIR = Paths.get(\"8258117-module-classes\", MODULE_NAME).toAbsolutePath();\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"jar tool not found\")\n+            );\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"javac tool not found\")\n+            );\n+\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        compileModuleClasses();\n+    }\n+\n+    \/**\n+     * Launches a \"jar --create\" command multiple times with a module-info.class. The module-info.class\n+     * is internally updated by the jar tool to add additional data. Expects that each such generated\n+     * jar has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarCreate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-create\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ create a modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--main-class=\" + MAIN_CLASS,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/**\n+     * Launches a \"jar --update\" process multiple times to update the module-info.class\n+     * descriptor with the same content and then expects that the modular jar created by\n+     * each of these processes has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarUpdate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-update\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ first create the modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+            \/\/ now update the same modular jar\n+            runJarCommand(\"--update\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + UPDATED_MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \"module-info.class\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, UPDATED_MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/\/ compiles using javac tool the classes used in the test module\n+    private static void compileModuleClasses() throws Exception {\n+        Path sourcePath = Paths.get(System.getProperty(\"test.src\", \".\"),\n+                \"src\", MODULE_NAME);\n+        List<String> sourceFiles = new ArrayList<>();\n+        Files.walkFileTree(sourcePath, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.toString().endsWith(\".java\")) {\n+                    sourceFiles.add(file.toString());\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        Path classesDir = Files.createDirectories(MODULE_CLASSES_DIR);\n+        List<String> javacArgs = new ArrayList<>();\n+        javacArgs.add(\"-d\");\n+        javacArgs.add(classesDir.toString());\n+        sourceFiles.forEach((f) -> javacArgs.add(f));\n+        System.out.println(\"Launching javac command with args: \" + javacArgs);\n+        StringWriter sw = new StringWriter();\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAVAC_TOOL.run(pw, pw, javacArgs.toArray(new String[0]));\n+            assertEquals(exitCode, 0, \"Module compilation failed: \" + sw.toString());\n+        }\n+        System.out.println(\"Module classes successfully compiled to directory \" + classesDir);\n+    }\n+\n+    \/\/ runs the \"jar\" command passing it the \"jarArgs\" and verifying that the command\n+    \/\/ execution didn't fail\n+    private static void runJarCommand(String... jarArgs) {\n+        StringWriter sw = new StringWriter();\n+        System.out.println(\"Launching jar command with args: \" + Arrays.toString(jarArgs));\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAR_TOOL.run(pw, pw, jarArgs);\n+            assertEquals(exitCode, 0, \"jar command execution failed: \" + sw.toString());\n+        }\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(List<Path> files) throws Exception {\n+        Path firstFile = files.get(0);\n+        for (int i = 1; i < files.size(); i++) {\n+            assertEquals(Files.mismatch(firstFile, files.get(i)), -1,\n+                    \"Content in file \" + files.get(i) + \" isn't the same as in file \" + firstFile);\n+        }\n+    }\n+\n+    \/\/ verifies that a module-info.class is present in the jar and the module name and version are the expected\n+    \/\/ ones\n+    private static void assertExpectedModuleInfo(Path jar, String expectedModuleVersion) throws Exception {\n+        try (JarInputStream jaris = new JarInputStream(Files.newInputStream(jar))) {\n+            JarEntry moduleInfoEntry = null;\n+            JarEntry entry = null;\n+            while ((entry = jaris.getNextJarEntry()) != null) {\n+                if (entry.getName().equals(\"module-info.class\")) {\n+                    moduleInfoEntry = entry;\n+                    break;\n+                }\n+            }\n+            assertNotNull(moduleInfoEntry, \"module-info.class is missing from jar \" + jar);\n+\n+            ModuleDescriptor md = ModuleDescriptor.read(jaris);\n+            assertEquals(md.name(), MODULE_NAME, \"Unexpected module name\");\n+            assertFalse(md.rawVersion().isEmpty(), \"Module version missing from descriptor\");\n+\n+            String actualVersion = md.rawVersion().get();\n+            assertEquals(actualVersion, expectedModuleVersion, \"Unexpected module version\");\n+\n+            System.out.println(moduleInfoEntry.getName() + \" has a timestamp of \"\n+                    + moduleInfoEntry.getTime() + \" for version \" + actualVersion);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jar\/modularJar\/JarToolModuleDescriptorReproducibilityTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}