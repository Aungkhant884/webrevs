{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -123,1 +124,1 @@\n-    Map<String,byte[]> moduleInfos = new HashMap<>();\n+    Map<String, ModuleInfoEntry> moduleInfos = new HashMap<>();\n@@ -809,1 +810,4 @@\n-                    moduleInfos.putIfAbsent(name, Files.readAllBytes(f.toPath()));\n+                    Path path = f.toPath();\n+                    byte[] fileContent = Files.readAllBytes(path);\n+                    ModuleInfoEntry mie = new StreamedModuleInfoEntry(name, fileContent, Files.getLastModifiedTime(path));\n+                    moduleInfos.putIfAbsent(name, mie);\n@@ -910,1 +914,1 @@\n-                   Map<String,byte[]> moduleInfos,\n+                   Map<String, ModuleInfoEntry> moduleInfos,\n@@ -959,1 +963,1 @@\n-                moduleInfos.putIfAbsent(name, zis.readAllBytes());\n+                moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -1043,1 +1047,1 @@\n-    private void updateModuleInfo(Map<String,byte[]> moduleInfos, ZipOutputStream zos)\n+    private void updateModuleInfo(Map<String, ModuleInfoEntry> moduleInfos, ZipOutputStream zos)\n@@ -1047,1 +1051,1 @@\n-        for (Map.Entry<String,byte[]> mi : moduleInfos.entrySet()) {\n+        for (Map.Entry<String, ModuleInfoEntry> mi : moduleInfos.entrySet()) {\n@@ -1049,1 +1053,2 @@\n-            byte[] bytes = mi.getValue();\n+            ModuleInfoEntry mie = mi.getValue();\n+            byte[] bytes = mie.readAllBytes();\n@@ -1051,1 +1056,6 @@\n-            e.setTime(System.currentTimeMillis());\n+            FileTime lastModified = mie.getLastModifiedTime();\n+            if (lastModified != null) {\n+                e.setLastModifiedTime(lastModified);\n+            } else {\n+                e.setLastModifiedTime(FileTime.fromMillis(System.currentTimeMillis()));\n+            }\n@@ -1746,1 +1756,1 @@\n-     * bytes and an optional URI. Used when describing modules.\n+     * bytes and an optional URI.\n@@ -1749,3 +1759,14 @@\n-       String name();\n-       Optional<String> uriString();\n-       InputStream bytes() throws IOException;\n+        String name();\n+        Optional<String> uriString();\n+        InputStream bytes() throws IOException;\n+        \/**\n+         * @return Returns the last modified time of the module-info.class.\n+         * Returns null if the last modified time is unknown or cannot be\n+         * determined.\n+         *\/\n+        FileTime getLastModifiedTime();\n+        default byte[] readAllBytes() throws IOException {\n+            try (InputStream is = bytes()) {\n+                return is.readAllBytes();\n+            }\n+        }\n@@ -1765,0 +1786,6 @@\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return entry.getLastModifiedTime();\n+        }\n+\n@@ -1776,1 +1803,3 @@\n-        StreamedModuleInfoEntry(String name, byte[] bytes) {\n+        private final FileTime lastModifiedTime;\n+\n+        StreamedModuleInfoEntry(String name, byte[] bytes, FileTime lastModifiedTime) {\n@@ -1779,0 +1808,1 @@\n+            this.lastModifiedTime = lastModifiedTime;\n@@ -1784,0 +1814,11 @@\n+\n+        @Override\n+        public byte[] readAllBytes() throws IOException {\n+            return bytes;\n+        }\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return lastModifiedTime;\n+        }\n+\n@@ -1835,1 +1876,1 @@\n-                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes()));\n+                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -2048,1 +2089,1 @@\n-    private boolean checkModuleInfo(byte[] moduleInfoBytes, Set<String> entries)\n+    private boolean checkModuleInfo(ModuleInfoEntry moduleInfoEntry, Set<String> entries)\n@@ -2052,1 +2093,1 @@\n-        if (moduleInfoBytes != null) {  \/\/ no root module-info.class if null\n+        if (moduleInfoEntry != null) {  \/\/ no root module-info.class if null\n@@ -2055,1 +2096,1 @@\n-                ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes));\n+                ModuleDescriptor md = ModuleDescriptor.read(moduleInfoEntry.bytes());\n@@ -2073,1 +2114,1 @@\n-     * Map values are updated in-place. Returns false if an error occurs.\n+     * Map values are updated in-place.\n@@ -2075,1 +2116,1 @@\n-    private void addExtendedModuleAttributes(Map<String,byte[]> moduleInfos,\n+    private void addExtendedModuleAttributes(Map<String, ModuleInfoEntry> moduleInfos,\n@@ -2079,3 +2120,7 @@\n-        for (Map.Entry<String,byte[]> e: moduleInfos.entrySet()) {\n-            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(e.getValue()));\n-            e.setValue(extendedInfoBytes(md, e.getValue(), packages));\n+        for (Map.Entry<String, ModuleInfoEntry> e: moduleInfos.entrySet()) {\n+            ModuleInfoEntry mie = e.getValue();\n+            byte[] bytes = mie.readAllBytes();\n+            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(bytes));\n+            byte[] extended = extendedInfoBytes(md, bytes, packages);\n+            \/\/ replace the entry value with the extended bytes\n+            e.setValue(new StreamedModuleInfoEntry(mie.name(), extended, mie.getLastModifiedTime()));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":67,"deletions":22,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.module.ModuleDescriptor;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import java.util.spi.ToolProvider;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/**\n+ * @test\n+ * @bug 8258117\n+ * @summary Tests that the content generated for module-info.class, using the jar command, is reproducible\n+ * @run testng JarToolModuleDescriptorReproducibilityTest\n+ *\/\n+public class JarToolModuleDescriptorReproducibilityTest {\n+\n+    private static final String MODULE_NAME = \"foo\";\n+    private static final String MODULE_VERSION = \"1.2.3\";\n+    private static final String UPDATED_MODULE_VERSION = \"1.2.4\";\n+    private static final String MAIN_CLASS = \"jdk.test.foo.Foo\";\n+    private static final Path MODULE_CLASSES_DIR = Path.of(\"8258117-module-classes\", MODULE_NAME).toAbsolutePath();\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"jar tool not found\")\n+            );\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"javac tool not found\")\n+            );\n+\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        compileModuleClasses();\n+    }\n+\n+    \/**\n+     * Launches a \"jar --create\" command multiple times with a module-info.class. The module-info.class\n+     * is internally updated by the jar tool to add additional data. Expects that each such generated\n+     * jar has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarCreate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-create\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ create a modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--main-class=\" + MAIN_CLASS,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/**\n+     * Launches a \"jar --update\" process multiple times to update the module-info.class\n+     * descriptor with the same content and then expects that the modular jar created by\n+     * each of these processes has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarUpdate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-update\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ first create the modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+            \/\/ now update the same modular jar\n+            runJarCommand(\"--update\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + UPDATED_MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \"module-info.class\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, UPDATED_MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/\/ compiles using javac tool the classes used in the test module\n+    private static void compileModuleClasses() throws Exception {\n+        Path sourcePath = Path.of(System.getProperty(\"test.src\", \".\"),\n+                \"src\", MODULE_NAME);\n+        List<String> sourceFiles = new ArrayList<>();\n+        Files.walkFileTree(sourcePath, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.toString().endsWith(\".java\")) {\n+                    sourceFiles.add(file.toString());\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        Path classesDir = Files.createDirectories(MODULE_CLASSES_DIR);\n+        List<String> javacArgs = new ArrayList<>();\n+        javacArgs.add(\"-d\");\n+        javacArgs.add(classesDir.toString());\n+        sourceFiles.forEach((f) -> javacArgs.add(f));\n+        System.out.println(\"Launching javac command with args: \" + javacArgs);\n+        StringWriter sw = new StringWriter();\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAVAC_TOOL.run(pw, pw, javacArgs.toArray(new String[0]));\n+            assertEquals(exitCode, 0, \"Module compilation failed: \" + sw.toString());\n+        }\n+        System.out.println(\"Module classes successfully compiled to directory \" + classesDir);\n+    }\n+\n+    \/\/ runs the \"jar\" command passing it the \"jarArgs\" and verifying that the command\n+    \/\/ execution didn't fail\n+    private static void runJarCommand(String... jarArgs) {\n+        StringWriter sw = new StringWriter();\n+        System.out.println(\"Launching jar command with args: \" + Arrays.toString(jarArgs));\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAR_TOOL.run(pw, pw, jarArgs);\n+            assertEquals(exitCode, 0, \"jar command execution failed: \" + sw.toString());\n+        }\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(List<Path> files) throws Exception {\n+        Path firstFile = files.get(0);\n+        for (int i = 1; i < files.size(); i++) {\n+            assertEquals(Files.mismatch(firstFile, files.get(i)), -1,\n+                    \"Content in file \" + files.get(i) + \" isn't the same as in file \" + firstFile);\n+        }\n+    }\n+\n+    \/\/ verifies that a module-info.class is present in the jar and the module name and version are the expected\n+    \/\/ ones\n+    private static void assertExpectedModuleInfo(Path jar, String expectedModuleVersion) throws Exception {\n+        try (JarInputStream jaris = new JarInputStream(Files.newInputStream(jar))) {\n+            JarEntry moduleInfoEntry = null;\n+            JarEntry entry = null;\n+            while ((entry = jaris.getNextJarEntry()) != null) {\n+                if (entry.getName().equals(\"module-info.class\")) {\n+                    moduleInfoEntry = entry;\n+                    break;\n+                }\n+            }\n+            assertNotNull(moduleInfoEntry, \"module-info.class is missing from jar \" + jar);\n+\n+            ModuleDescriptor md = ModuleDescriptor.read(jaris);\n+            assertEquals(md.name(), MODULE_NAME, \"Unexpected module name\");\n+            assertFalse(md.rawVersion().isEmpty(), \"Module version missing from descriptor\");\n+\n+            String actualVersion = md.rawVersion().get();\n+            assertEquals(actualVersion, expectedModuleVersion, \"Unexpected module version\");\n+\n+            System.out.println(moduleInfoEntry.getName() + \" has a timestamp of \"\n+                    + moduleInfoEntry.getTime() + \" for version \" + actualVersion);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jar\/modularJar\/JarToolModuleDescriptorReproducibilityTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"}]}