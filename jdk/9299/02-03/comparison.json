{"files":[{"patch":"@@ -101,1 +101,8 @@\n-                  Location.INNER_CLASS)),\n+                  Location.INNER_CLASS)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                Location.SET_CLASS_FIELD_METHOD:\n+                locations();\n+        }\n+    },\n@@ -108,1 +115,8 @@\n-    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                Location.SET_FIELD_METHOD:\n+                locations();\n+       }\n+    },\n@@ -115,1 +129,8 @@\n-    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                Location.SET_FIELD_METHOD:\n+                locations();\n+        }\n+    },\n@@ -122,1 +143,8 @@\n-    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                Location.SET_FIELD_METHOD:\n+                locations();\n+        }\n+    },\n@@ -131,1 +159,15 @@\n-                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+                 Location.INNER_CLASS,     \/* added in 1.1 *\/\n+                 Location.METHOD_PARAMETER \/* added in 8 *\/ )) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n+                return locations();\n+            } else {\n+                if (cffv == ClassFileFormatVersion.RELEASE_0) {\n+                    return Location.SET_CLASS_FIELD_METHOD;\n+                } else {\n+                    return Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n+                }\n+            }\n+        }\n+    },\n@@ -148,1 +190,8 @@\n-    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+    OPEN(0x0000_0020, false, Set.of(Location.MODULE)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -155,1 +204,8 @@\n-    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -169,1 +225,8 @@\n-    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -171,5 +234,5 @@\n-     \/**\n-      * The access flag {@code ACC_VOLATILE}, corresponding to the\n-      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n-      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n-      *\/\n+   \/**\n+     * The access flag {@code ACC_VOLATILE}, corresponding to the\n+     * source modifier {@link Modifier#VOLATILE volatile} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+     *\/\n@@ -183,1 +246,8 @@\n-    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -197,1 +267,8 @@\n-    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -211,1 +288,8 @@\n-    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                Location.SET_CLASS:\n+                locations();\n+        }\n+    },\n@@ -219,1 +303,8 @@\n-             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                Location.SET_CLASS_METHOD:\n+                locations();\n+        }\n+    },\n@@ -231,1 +322,9 @@\n-    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                    cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -241,0 +340,1 @@\n+              \/\/ Added as an access flag in 7\n@@ -242,1 +342,3 @@\n-                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n+                     Location.INNER_CLASS,\n+                     Location.METHOD_PARAMETER, \/\/ Added in 8\n+                     \/\/ Module-related items added in 9\n@@ -244,1 +346,15 @@\n-                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n+                return locations();\n+            else {\n+                return\n+                    switch(cffv) {\n+                    case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n+                    case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n+                    default        -> Location.EMPTY_SET;\n+                    };\n+            }\n+        }\n+    },\n@@ -251,1 +367,8 @@\n-    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -259,1 +382,8 @@\n-         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    },\n@@ -266,1 +396,2 @@\n-             Set.of(Location.METHOD_PARAMETER,\n+             Set.of(Location.METHOD_PARAMETER, \/\/ From 8\n+                    \/\/ Starting in 9\n@@ -268,1 +399,12 @@\n-                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n+                return locations();\n+            } else if (cffv == ClassFileFormatVersion.RELEASE_8) {\n+                return Location.SET_METHOD_PARAM;\n+            } else { \/\/ Less than or equal to RELEASE_7\n+                return Location.EMPTY_SET;\n+            }\n+        }\n+    },\n@@ -274,1 +416,8 @@\n-    MODULE(0x0000_8000, false, Location.SET_CLASS)\n+    MODULE(0x0000_8000, false, Location.SET_CLASS) {\n+        @Override\n+        public Set<Location> locations(ClassFileFormatVersion cffv) {\n+            return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                locations():\n+                Location.EMPTY_SET;\n+        }\n+    }\n@@ -320,0 +469,1 @@\n+     * @throws NullPointerException if the parameter is {@code null}\n@@ -322,5 +472,1 @@\n-        if (cffv == ClassFileFormatVersion.latest()) {\n-            return locations();\n-        } else {\n-            throw new UnsupportedOperationException(); \/\/ TOOD\n-        }\n+        return locations; \/\/ Default to supported unchanging locations\n@@ -419,0 +565,9 @@\n+        private static final Set<Location> EMPTY_SET = Set.of();\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD =\n+            Set.of(Location.CLASS, Location.FIELD, Location.METHOD);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD_INNER_CLASS =\n+            Set.of(Location.CLASS, Location.FIELD, Location.METHOD, Location.INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_METHOD =\n+            Set.of(Location.CLASS, Location.METHOD);\n+        private static final Set<Location> SET_FIELD_METHOD =\n+            Set.of(Location.FIELD, Location.METHOD);\n@@ -422,0 +577,1 @@\n+        private static final Set<Location> SET_METHOD_PARAM = Set.of(METHOD_PARAMETER);\n@@ -428,0 +584,6 @@\n+        private static final Set<Location> SET_SYNTHETIC_7 =\n+              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                     Location.INNER_CLASS);\n+        private static final Set<Location> SET_SYNTHETIC_8 =\n+              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n+                     Location.INNER_CLASS, Location.METHOD_PARAMETER);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":192,"deletions":30,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @see System#getProperties System property {@code java.class.version}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Additionall, the access flags enum and synthetic cannot be\n+ * Additionally, the access flags enum and synthetic cannot be\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289106\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import static java.lang.reflect.AccessFlag.*;\n+import java.lang.reflect.ClassFileFormatVersion;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/*\n+ * There are several patterns of access flag applicability. First, an\n+ * access flag can be applied to the same set of locations for each\n+ * class file format version. This is \"invariant\" usage. Second, an\n+ * access flag can be defined for version N, therefore inapplicable\n+ * for earlier versions, and then applied to the same locations for\n+ * all subsequent versions. This is \"step\" usage. Finally, an access\n+ * flag to have a more complicated pattern, having multiple steps of\n+ * being allowed at more locations or even having locations removed if\n+ * the access flag is retired.\n+ *\n+ * List of access flags and how they are tested: \n+ *\n+ * PUBLIC       step\n+ * PRIVATE      step\n+ * PROTECTED    step\n+ * STATIC       step\n+ * FINAL        two-step\n+ * SUPER        invariant\n+ * OPEN         step\n+ * TRANSITIVE   step\n+ * SYNCHRONIZED invariant\n+ * STATIC_PHASE step\n+ * VOLATILE     invariant\n+ * BRIDGE       step\n+ * TRANSIENT    invariant\n+ * VARARGS      step\n+ * NATIVE       invariant\n+ * INTERFACE    step\n+ * ABSTRACT     step\n+ * STRICT       other\n+ * SYNTHETIC    other (three-step)\n+ * ANNOTATION   step\n+ * ENUM         step\n+ * MANDATED     two-step\n+ * MODULE       step\n+ *\/\n+\n+public class VersionedLocationsTest {\n+    public static void main(String... args) throws Exception {\n+        testInvariantAccessFlags();\n+        testStepFunctionAccessFlags();\n+        testTwoStepAccessFlags();\n+        testSynthetic();\n+        testStrict();\n+    }\n+\n+    \/**\n+     * Invariant access flags have the same set of locations for each\n+     * class file format version.\n+     *\/\n+    private static void testInvariantAccessFlags() {\n+        Set<AccessFlag> invariantAccessFlags =\n+            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+        for(var accessFlag : invariantAccessFlags) {\n+            Set<AccessFlag.Location> expected = accessFlag.locations();\n+\n+            for(var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(accessFlag.locations(), accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testStepFunctionAccessFlags() {\n+        StepFunctionTC[] testCases = {\n+            new StepFunctionTC(PUBLIC,\n+                               removeInnerClass(PUBLIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PRIVATE,\n+                               removeInnerClass(PRIVATE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PROTECTED,\n+                               removeInnerClass(PROTECTED.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(STATIC,\n+                               removeInnerClass(STATIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(OPEN,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(TRANSITIVE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(STATIC_PHASE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(BRIDGE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(VARARGS,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(INTERFACE,\n+                               removeInnerClass(INTERFACE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ABSTRACT,\n+                               removeInnerClass(ABSTRACT.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ANNOTATION,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(ENUM,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(MODULE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9)\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(cffv.compareTo(testCase.transition()) >= 0 ?\n+                                 testCase.finalLocs() :\n+                                 testCase.initialLocs(),\n+                                 testCase.accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void compareLocations(Set<AccessFlag.Location> expected,\n+                                         AccessFlag accessFlag,\n+                                         ClassFileFormatVersion cffv) {\n+        var actual = accessFlag.locations(cffv);\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected locations for \" +\n+                                       accessFlag  + \" on \" + cffv + \"\\n\" +\n+                                       \"Expected \" + expected + \"; got \\t\" + actual);\n+        }\n+    }\n+\n+    private static Set<AccessFlag.Location> removeInnerClass(Set<AccessFlag.Location> locations) {\n+        var s = new HashSet<>(locations);\n+        s.remove(Location.INNER_CLASS);\n+        return s;\n+    }\n+\n+    private record StepFunctionTC(AccessFlag accessFlag,\n+                                  Set<AccessFlag.Location> initialLocs,\n+                                  ClassFileFormatVersion transition) {\n+\n+        public Set<AccessFlag.Location> finalLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+\n+    private record TwoStepFunctionTC(AccessFlag accessFlag,\n+                                     Set<AccessFlag.Location> initialLocs,\n+                                     ClassFileFormatVersion transition1,\n+                                     Set<AccessFlag.Location> firstLocs,\n+                                     ClassFileFormatVersion transition2) {\n+\n+        public Set<AccessFlag.Location> secondLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+    private static void testTwoStepAccessFlags() {\n+        TwoStepFunctionTC[] testCases = {\n+            new TwoStepFunctionTC(FINAL,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD),\n+                                  ClassFileFormatVersion.RELEASE_1,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD, Location.INNER_CLASS),\n+                                  ClassFileFormatVersion.RELEASE_8),\n+\n+            new TwoStepFunctionTC(MANDATED,\n+                                  Set.of(),\n+                                  ClassFileFormatVersion.RELEASE_8,\n+                                  Set.of(Location.METHOD_PARAMETER),\n+                                  ClassFileFormatVersion.RELEASE_9),\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                var transition1 = testCase.transition1();\n+                var transition2 = testCase.transition2();\n+                Set<AccessFlag.Location> expected;\n+                if (cffv.compareTo(transition1) < 0) {\n+                    expected = testCase.initialLocs();\n+                } else if (cffv.compareTo(transition1) >= 0 &&\n+                           cffv.compareTo(transition2) < 0) {\n+                    expected = testCase.firstLocs();\n+                } else { \/\/ cffv >= transition2\n+                    expected = testCase.secondLocs();\n+                }\n+\n+                compareLocations(expected, testCase.accessFlag(), cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testSynthetic() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected;\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+                expected = Set.of();\n+            } else {\n+                expected =\n+                    switch(cffv) {\n+                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS);\n+                        case RELEASE_8 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS,\n+                                                 Location.METHOD_PARAMETER);\n+                        default        -> SYNTHETIC.locations();\n+                    };\n+            }\n+        compareLocations(expected, SYNTHETIC, cffv);\n+        }\n+    }\n+\n+    private static void testStrict() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected =\n+                (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                 cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                Set.of(Location.METHOD) :\n+                Set.of();\n+            compareLocations(expected, STRICT, cffv);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}