{"files":[{"patch":"@@ -72,1 +72,0 @@\n-  assert(new_entry_free_list() == NULL, \"entry present on Dictionary's free list\");\n@@ -76,1 +75,1 @@\n-  DictionaryEntry* entry = (DictionaryEntry*)Hashtable<InstanceKlass*, mtClass>::allocate_new_entry(hash, klass);\n+  DictionaryEntry* entry = (DictionaryEntry*)Hashtable<InstanceKlass*, mtClass>::new_entry(hash, klass);\n@@ -93,3 +92,1 @@\n-  \/\/ Unlink from the Hashtable prior to freeing\n-  unlink_entry(entry);\n-  FREE_C_HEAP_ARRAY(char, entry);\n+  BasicHashtable<mtClass>::free_entry(entry);\n@@ -482,1 +479,1 @@\n-  Hashtable<Symbol*, mtSymbol>::free_entry(entry);\n+  BasicHashtable<mtSymbol>::free_entry(entry);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -96,8 +96,0 @@\n-  void add_entry(int index, DictionaryEntry* new_entry) {\n-    Hashtable<InstanceKlass*, mtClass>::add_entry(index, (HashtableEntry<InstanceKlass*, mtClass>*)new_entry);\n-  }\n-\n-  void unlink_entry(DictionaryEntry* entry) {\n-    Hashtable<InstanceKlass*, mtClass>::unlink_entry((HashtableEntry<InstanceKlass*, mtClass>*)entry);\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  Hashtable<InstanceKlass*, mtClass>::free_entry(entry);\n+  BasicHashtable<mtClass>::free_entry(entry);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,4 +360,1 @@\n-\n-      \/\/ Unlink from the Hashtable prior to freeing\n-      unlink_entry(to_remove);\n-      FREE_C_HEAP_ARRAY(char, to_remove);\n+      BasicHashtable<mtModule>::free_entry(to_remove);\n@@ -367,1 +364,0 @@\n-  assert(new_entry_free_list() == NULL, \"entry present on ModuleEntryTable's free list\");\n@@ -582,1 +578,1 @@\n-  ModuleEntry* entry = (ModuleEntry*)Hashtable<Symbol*, mtModule>::allocate_new_entry(hash, name);\n+  ModuleEntry* entry = (ModuleEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,3 +190,1 @@\n-      \/\/ Unlink from the Hashtable prior to freeing\n-      unlink_entry(to_remove);\n-      FREE_C_HEAP_ARRAY(char, to_remove);\n+      BasicHashtable<mtModule>::free_entry(to_remove);\n@@ -196,1 +194,0 @@\n-  assert(new_entry_free_list() == NULL, \"entry present on PackageEntryTable's free list\");\n@@ -325,1 +322,1 @@\n-  PackageEntry* entry = (PackageEntry*)Hashtable<Symbol*, mtModule>::allocate_new_entry(hash, name);\n+  PackageEntry* entry = (PackageEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  Hashtable<Symbol*, mtClass>::free_entry(entry);\n+  BasicHashtable<mtClass>::free_entry(entry);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  Hashtable<ConstantPool*, mtClass>::free_entry(entry);\n+  BasicHashtable<mtClass>::free_entry(entry);\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1649,0 +1649,1 @@\n+      InstanceKlass* ik = probe->instance_klass();\n@@ -1655,1 +1656,1 @@\n-      return probe->instance_klass();\n+      return ik;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,8 +48,1 @@\n-  Entry* entry = (Entry*) new_entry_free_list();\n-  if (entry == NULL) {\n-    entry = (Entry*) NEW_C_HEAP_ARRAY2(char, entry_size(), mtGC, CURRENT_PC);\n-  }\n-  entry->set_next(NULL);\n-  entry->set_hash(hash);\n-  entry->set_literal(nm);\n-  return entry;\n+  return (Entry*)Hashtable<nmethod*, mtGC>::new_entry(hash, nm);\n@@ -76,2 +69,1 @@\n-      unlink_entry(to_remove);\n-      FREE_C_HEAP_ARRAY(char, to_remove);\n+      BasicHashtable<mtGC>::free_entry(to_remove);\n@@ -81,6 +73,0 @@\n-  \/\/ Each of the entries in new_entry_free_list() have been allocated in\n-  \/\/ G1CodeRootSetTable::new_entry(). We never call the block allocator\n-  \/\/ in BasicHashtable::new_entry().\n-  for (BasicHashtableEntry<mtGC>* e = new_entry_free_list(); e != NULL; e = new_entry_free_list()) {\n-    FREE_C_HEAP_ARRAY(char, e);\n-  }\n@@ -127,1 +113,0 @@\n-  new_table->copy_freelist(this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+#include \"utilities\/dtrace.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  assert(new_entry_free_list() == NULL, \"entry present on JvmtiTagMapTable's free list\");\n@@ -77,1 +76,1 @@\n-  JvmtiTagMapEntry* entry = (JvmtiTagMapEntry*)Hashtable<WeakHandle, mtServiceability>::allocate_new_entry(hash, w);\n+  JvmtiTagMapEntry* entry = (JvmtiTagMapEntry*)Hashtable<WeakHandle, mtServiceability>::new_entry(hash, w);\n@@ -83,1 +82,0 @@\n-  unlink_entry(entry);\n@@ -85,1 +83,1 @@\n-  FREE_C_HEAP_ARRAY(char, entry);\n+  BasicHashtable<mtServiceability>::free_entry(entry);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -494,4 +494,0 @@\n-  volatile_nonstatic_field(BasicHashtable<mtInternal>,  _free_list,                           BasicHashtableEntry<mtInternal>*)      \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _first_free_entry,                             char*)                                 \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _end_block,                                    char*)                                 \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _entry_size,                                   int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/altHashing.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"classfile\/stringTable.hpp\"\n@@ -40,0 +38,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -48,1 +47,0 @@\n-\n@@ -51,8 +49,1 @@\n-template <MEMFLAGS F> BasicHashtableEntry<F>* BasicHashtable<F>::new_entry_free_list() {\n-  BasicHashtableEntry<F>* entry = NULL;\n-  if (_free_list != NULL) {\n-    entry = _free_list;\n-    _free_list = _free_list->next();\n-  }\n-  return entry;\n-}\n+\/\/ Hashtable entry allocates in the C heap directly.\n@@ -60,1 +51,0 @@\n-\/\/ HashtableEntrys are allocated in blocks to reduce the space overhead.\n@@ -62,16 +52,2 @@\n-  BasicHashtableEntry<F>* entry = new_entry_free_list();\n-\n-  if (entry == NULL) {\n-    if (_first_free_entry + _entry_size >= _end_block) {\n-      int block_size = MAX2((int)_table_size \/ 2, (int)_number_of_entries); \/\/ pick a reasonable value\n-      block_size = clamp(block_size, 2, 512); \/\/ but never go out of this range\n-      int len = round_down_power_of_2(_entry_size * block_size);\n-      assert(len >= _entry_size, \"\");\n-      _first_free_entry = NEW_C_HEAP_ARRAY2(char, len, F, CURRENT_PC);\n-      _entry_blocks.append(_first_free_entry);\n-      _end_block = _first_free_entry + len;\n-    }\n-    entry = (BasicHashtableEntry<F>*)_first_free_entry;\n-    _first_free_entry += _entry_size;\n-  }\n-\n+  BasicHashtableEntry<F>* entry = ::new (NEW_C_HEAP_ARRAY(char, this->entry_size(), F))\n+                                        BasicHashtableEntry<F>(hashValue);\n@@ -79,1 +55,0 @@\n-  entry->set_hash(hashValue);\n@@ -85,13 +60,2 @@\n-  HashtableEntry<T, F>* entry;\n-\n-  entry = (HashtableEntry<T, F>*)BasicHashtable<F>::new_entry(hashValue);\n-  entry->set_literal(obj);\n-  return entry;\n-}\n-\n-\/\/ Version of hashtable entry allocation that allocates in the C heap directly.\n-\/\/ The block allocator in BasicHashtable has less fragmentation, but the memory is not freed until\n-\/\/ the whole table is freed. Use allocate_new_entry() if you want to individually free the memory\n-\/\/ used by each entry\n-template <class T, MEMFLAGS F> HashtableEntry<T, F>* Hashtable<T, F>::allocate_new_entry(unsigned int hashValue, T obj) {\n-  HashtableEntry<T, F>* entry = (HashtableEntry<T, F>*) NEW_C_HEAP_ARRAY(char, this->entry_size(), F);\n+  HashtableEntry<T, F>* entry = ::new (NEW_C_HEAP_ARRAY(char, this->entry_size(), F))\n+                                      HashtableEntry<T, F>(hashValue);\n@@ -109,0 +73,8 @@\n+template <MEMFLAGS F> inline void BasicHashtable<F>::free_entry(BasicHashtableEntry<F>* entry) {\n+  \/\/ Unlink from the Hashtable prior to freeing\n+  unlink_entry(entry);\n+  FREE_C_HEAP_ARRAY(char, entry);\n+  JFR_ONLY(_stats_rate.remove();)\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"oops\/oop.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -53,9 +51,0 @@\n-  \/\/ Windows IA64 compiler requires subclasses to be able to access these\n-protected:\n-  \/\/ Entry objects should not be created, they should be taken from the\n-  \/\/ free list with BasicHashtable.new_entry().\n-  BasicHashtableEntry() { ShouldNotReachHere(); }\n-  \/\/ Entry objects should not be destroyed.  They should be placed on\n-  \/\/ the free list instead with BasicHashtable.free_entry().\n-  ~BasicHashtableEntry() { ShouldNotReachHere(); }\n-\n@@ -63,0 +52,4 @@\n+  BasicHashtableEntry(unsigned int hashValue) : _hash(hashValue), _next(nullptr) {}\n+  \/\/ Still should not call this. Entries are placement new allocated, so are\n+  \/\/ deleted with free_entry.\n+  ~BasicHashtableEntry() { ShouldNotReachHere(); }\n@@ -89,0 +82,2 @@\n+  HashtableEntry(unsigned int hashValue) : BasicHashtableEntry<F>(hashValue) {}\n+\n@@ -145,3 +140,0 @@\n-  BasicHashtableEntry<F>* volatile _free_list;\n-  char*                            _first_free_entry;\n-  char*                            _end_block;\n@@ -150,1 +142,0 @@\n-  GrowableArrayCHeap<char*, F>     _entry_blocks;\n@@ -167,3 +158,0 @@\n-  \/\/ Attempt to get an entry from the free list\n-  BasicHashtableEntry<F>* new_entry_free_list();\n-\n@@ -173,2 +161,2 @@\n-  \/\/ Used when moving the entry to another table\n-  \/\/ Clean up links, but do not add to free_list\n+  \/\/ Used when moving the entry to another table or deleting entry.\n+  \/\/ Clean up links.\n@@ -180,10 +168,0 @@\n-  \/\/ Move over freelist and free block for allocation\n-  void copy_freelist(BasicHashtable* src) {\n-    _free_list = src->_free_list;\n-    src->_free_list = NULL;\n-    _first_free_entry = src->_first_free_entry;\n-    src->_first_free_entry = NULL;\n-    _end_block = src->_end_block;\n-    src->_end_block = NULL;\n-  }\n-\n@@ -239,1 +217,0 @@\n-  \/\/ Table entry management\n@@ -241,2 +218,0 @@\n-  \/\/ Don't create and use freelist of HashtableEntry.\n-  HashtableEntry<T, F>* allocate_new_entry(unsigned int hashValue, T obj);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"utilities\/dtrace.hpp\"\n@@ -40,2 +39,1 @@\n-template <MEMFLAGS F> inline BasicHashtable<F>::BasicHashtable(int table_size, int entry_size) :\n-    _entry_blocks(4) {\n+template <MEMFLAGS F> inline BasicHashtable<F>::BasicHashtable(int table_size, int entry_size) {\n@@ -54,2 +52,2 @@\n-                                      int number_of_entries) :\n-    _entry_blocks(4) {\n+                                      int number_of_entries) {\n+\n@@ -63,3 +61,0 @@\n-  for (int i = 0; i < _entry_blocks.length(); i++) {\n-    FREE_C_HEAP_ARRAY(char, _entry_blocks.at(i));\n-  }\n@@ -74,3 +69,0 @@\n-  _free_list = NULL;\n-  _first_free_entry = NULL;\n-  _end_block = NULL;\n@@ -122,7 +114,0 @@\n-template <MEMFLAGS F> inline void BasicHashtable<F>::free_entry(BasicHashtableEntry<F>* entry) {\n-  entry->set_next(_free_list);\n-  _free_list = entry;\n-  --_number_of_entries;\n-  JFR_ONLY(_stats_rate.remove();)\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/hashtable.inline.hpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        \".*Hashtable.*allocate_new_entry.*\\n\" +\n+        \".*Hashtable.*new_entry.*\\n\" +\n@@ -74,1 +74,1 @@\n-        \".*Hashtable.*allocate_new_entry.*\\n\" +\n+        \".*Hashtable.*new_entry.*\\n\" +\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}