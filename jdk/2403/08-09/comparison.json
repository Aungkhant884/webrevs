{"files":[{"patch":"@@ -45,1 +45,1 @@\n-    private static native void validate(long layerPtr, MTLSurfaceData cglsd);\n+    private static native void validate(long layerPtr, MTLSurfaceData mtlsd);\n@@ -110,1 +110,1 @@\n-    public void validate(final MTLSurfaceData cglsd) {\n+    public void validate(final MTLSurfaceData mtlsd) {\n@@ -114,1 +114,1 @@\n-            execute(ptr -> validate(ptr, cglsd));\n+            execute(ptr -> validate(ptr, mtlsd));\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLLayer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -616,9 +616,0 @@\n-    \/\/ additional cleanup\n-    private static native void destroyCGLContext(long ctx);\n-\n-    public static void destroyOGLContext(long ctx) {\n-        if (ctx != 0L) {\n-            destroyCGLContext(ctx);\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceData.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    MTLGraphicsConfig oglgc;\n+    MTLGraphicsConfig mtlgc;\n@@ -56,2 +56,2 @@\n-    public MTLSurfaceDataProxy(MTLGraphicsConfig oglgc, int transparency) {\n-        this.oglgc = oglgc;\n+    public MTLSurfaceDataProxy(MTLGraphicsConfig mtlgc, int transparency) {\n+        this.mtlgc = mtlgc;\n@@ -68,1 +68,1 @@\n-                cachedData = oglgc.createManagedSurface(w, h, transparency);\n+                cachedData = mtlgc.createManagedSurface(w, h, transparency);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceDataProxy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull)getAAShaderRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps;\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+@property (assign) jboolean aaShader;\n@@ -71,0 +72,1 @@\n+    jboolean _isAAShader;\n@@ -96,0 +98,1 @@\n+@synthesize aaShader = _isAAShader;\n@@ -181,0 +184,1 @@\n+        && _isAAShader == renderOptions->isAAShader\n@@ -191,0 +195,1 @@\n+    _isAAShader = renderOptions->isAAShader;\n@@ -286,1 +291,1 @@\n-  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_FALSE};\n@@ -290,0 +295,6 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull)getAAShaderRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+{\n+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_TRUE};\n+    return [self getEncoder:dstOps->pTexture renderOptions:&roptions];\n+}\n+\n@@ -293,1 +304,1 @@\n-    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_FALSE};\n@@ -321,1 +332,1 @@\n-    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, {isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_TRUE};\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, {isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_TRUE, JNI_FALSE};\n@@ -331,1 +342,1 @@\n-    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_FALSE};\n@@ -346,1 +357,1 @@\n-    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE, JNI_FALSE};\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE, JNI_FALSE, JNI_FALSE};\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -364,0 +364,6 @@\n+    \/\/ Verify if we use a valid MTLContext\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    RETURN_IF_TRUE(dstMTLOps->configInfo != NULL && mtlc != dstMTLOps->configInfo->context);\n+\n+    MTLSDOps *srcMTLOps = (MTLSDOps *)srcOps->privOps;\n+    RETURN_IF_TRUE(srcMTLOps->configInfo != NULL && mtlc != srcMTLOps->configInfo->context);\n@@ -487,0 +493,3 @@\n+    \/\/ Verify if we use a valid MTLContext\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    RETURN_IF_TRUE(dstMTLOps->configInfo != NULL && mtlc != dstMTLOps->configInfo->context);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+- (void)resetStencilState;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"MTLStencilManager.h\"\n@@ -52,22 +53,0 @@\n-static id<MTLDepthStencilState> getStencilState(id<MTLDevice> device) {\n-    static id<MTLDepthStencilState> stencilState = nil;\n-    if (stencilState == nil) {\n-        MTLDepthStencilDescriptor* stencilDescriptor;\n-        stencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n-        stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n-        stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n-\n-        \/\/ TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives\n-        \/\/ currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.\n-        \/\/ Once that part is changed, set backFaceStencil to nil\n-        \/\/stencilDescriptor.backFaceStencil = nil;\n-\n-        stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n-        stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n-\n-        stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];\n-    }\n-\n-    return stencilState;\n-}\n-\n@@ -131,0 +110,1 @@\n+    _mtlc = other->_mtlc;\n@@ -141,0 +121,1 @@\n+\n@@ -304,1 +285,1 @@\n-        [encoder setDepthStencilState:getStencilState(device)];\n+        [encoder setDepthStencilState:_mtlc.stencilManager.stencilState];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.m","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+#include \"MTLSamplerManager.h\"\n+\n+@class MTLStencilManager;\n@@ -77,0 +80,2 @@\n+@property (readonly) MTLSamplerManager * samplerManager;\n+@property (readonly) MTLStencilManager * stencilManager;\n@@ -175,1 +180,1 @@\n-\n+- (void)reset;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#import \"MTLSamplerManager.h\"\n+#import \"MTLStencilManager.h\"\n@@ -111,0 +113,2 @@\n+    MTLSamplerManager * _samplerManager;\n+    MTLStencilManager * _stencilManager;\n@@ -116,1 +120,2 @@\n-            texturePool, paint=_paint;\n+            texturePool, paint=_paint, encoderManager=_encoderManager,\n+            samplerManager=_samplerManager, stencilManager=_stencilManager;\n@@ -140,0 +145,2 @@\n+        _samplerManager = [[MTLSamplerManager alloc] initWithDevice:device];\n+        _stencilManager = [[MTLStencilManager alloc] initWithDevice:device];\n@@ -153,2 +160,0 @@\n-\n-        initSamplers(device);\n@@ -168,0 +173,2 @@\n+    [_samplerManager release];\n+    [_stencilManager release];\n@@ -176,0 +183,6 @@\n+- (void) reset {\n+    J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLContext : reset\");\n+\n+    \/\/ Add code for context state reset here\n+}\n+\n@@ -213,1 +226,1 @@\n-                          \"MTLContext_SetSurfaces: could not init OGL window\");\n+                          \"MTLContext_SetSurfaces: could not init MTL window\");\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-static void setTxtUniforms(\n-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n-);\n+static MTLRenderPipelineDescriptor * templateAAPipelineDesc = nil;\n+static void\n+setTxtUniforms(MTLContext *mtlc, int color, id <MTLRenderCommandEncoder> encoder, int interpolation, bool repeat,\n+               jfloat extraAlpha, const SurfaceRasterFlags *srcFlags, const SurfaceRasterFlags *dstFlags, int mode);\n@@ -108,0 +108,27 @@\n+\n+    vertDesc = [[MTLVertexDescriptor new] autorelease];\n+    vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n+    vertDesc.attributes[VertexAttributePosition].offset = 0;\n+    vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n+    vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct AAVertex);\n+    vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n+    vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+\n+    templateAAPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateAAPipelineDesc.sampleCount = 1;\n+    templateAAPipelineDesc.vertexDescriptor = vertDesc;\n+    templateAAPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    templateAAPipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n+    templateAAPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+    templateAAPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n+    templateAAPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n+    templateAAPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+    templateAAPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+    templateAAPipelineDesc.colorAttachments[0].blendingEnabled = YES;\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].format = MTLVertexFormatFloat2;\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].offset = 4*sizeof(float);\n+    templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].bufferIndex = MeshVertexBuffer;\n+    templateAAPipelineDesc.label = @\"template_aa\";\n@@ -180,1 +207,1 @@\n-        setTxtUniforms(encoder, _color, 1,\n+        setTxtUniforms(mtlc, _color, encoder,\n@@ -182,1 +209,5 @@\n-                       &renderOptions->dstFlags);\n+                       &renderOptions->dstFlags, 1);\n+    } else if (renderOptions->isAAShader) {\n+        vertShader = @\"vert_col_aa\";\n+        fragShader = @\"frag_col_aa\";\n+        rpDesc = [[templateAAPipelineDesc copy] autorelease];\n@@ -219,1 +250,1 @@\n-        setTxtUniforms(encoder, col, 1,\n+        setTxtUniforms(mtlc, col, encoder,\n@@ -221,1 +252,1 @@\n-                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags, 1);\n@@ -757,1 +788,1 @@\n-    setTxtUniforms(encoder, 0, 0,\n+    setTxtUniforms(mtlc, 0, encoder,\n@@ -759,1 +790,1 @@\n-                   &srcFlags, &renderOptions->dstFlags);\n+                   &srcFlags, &renderOptions->dstFlags, 0);\n@@ -838,52 +869,3 @@\n-static id<MTLSamplerState> samplerNearestClamp = nil;\n-static id<MTLSamplerState> samplerLinearClamp = nil;\n-static id<MTLSamplerState> samplerNearestRepeat = nil;\n-static id<MTLSamplerState> samplerLinearRepeat = nil;\n-\n-void initSamplers(id<MTLDevice> device) {\n-    \/\/ TODO: move this code into SamplerManager (need implement)\n-\n-    if (samplerNearestClamp != nil)\n-        return;\n-\n-    MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n-\n-    samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;\n-    samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;\n-    samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n-    samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n-    samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;\n-    samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;\n-    samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n-    samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n-    samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-}\n-\n-static void setSampler(id<MTLRenderCommandEncoder> encoder, int interpolation, bool repeat) {\n-    id<MTLSamplerState> sampler;\n-    if (repeat) {\n-        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;\n-    } else {\n-        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;\n-    }\n-    [encoder setFragmentSamplerState:sampler atIndex:0];\n-}\n-\n-static void setTxtUniforms(\n-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n-) {\n+static void\n+setTxtUniforms(MTLContext *mtlc, int color, id <MTLRenderCommandEncoder> encoder, int interpolation, bool repeat,\n+               jfloat extraAlpha, const SurfaceRasterFlags *srcFlags, const SurfaceRasterFlags *dstFlags, int mode) {\n@@ -892,2 +874,1 @@\n-\n-    setSampler(encoder, interpolation, repeat);\n+    [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:interpolation repeat:repeat];\n@@ -924,1 +905,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -935,1 +916,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -947,1 +928,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -951,1 +932,1 @@\n-            setTxtUniforms(encoder, 0, 0,\n+            setTxtUniforms(mtlc, 0, encoder,\n@@ -954,1 +935,1 @@\n-                           &renderOptions->dstFlags);\n+                           &renderOptions->dstFlags, 0);\n@@ -983,1 +964,1 @@\n-        setTxtUniforms(encoder, col, 0,\n+        setTxtUniforms(mtlc, col, encoder,\n@@ -985,1 +966,1 @@\n-                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags, 0);\n@@ -991,1 +972,1 @@\n-        setTxtUniforms(encoder, 0, 0,\n+        setTxtUniforms(mtlc, 0, encoder,\n@@ -994,1 +975,1 @@\n-                       &renderOptions->dstFlags);\n+                       &renderOptions->dstFlags, 0);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":54,"deletions":73,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_FALSE};\n@@ -101,1 +101,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE, JNI_FALSE};\n@@ -199,0 +199,5 @@\n+            } else {\n+                \/\/ We continue to use same encoder when we move from shape clip\n+                \/\/ to other opcodes. So we need to maintain apprppriate state\n+                \/\/ for stencilAttachmentPixelFormat until we end the encoder\n+                pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatInvalid;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.m","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,0 +91,9 @@\n+#define ACT_IF_TRUE(ACTION, value)         \\\n+    if ((value)) {                         \\\n+        J2dTraceLn1(J2D_TRACE_ERROR,       \\\n+                    \"%s is false\", #value);\\\n+        ACTION;                            \\\n+    } else do { } while (0)\n+\n+#define RETURN_IF_TRUE(value)   ACT_IF_TRUE(return, value)\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -666,1 +666,3 @@\n-                        [mtlc.encoderManager endEncoder];\n+                        commitEncodedCommands();\n+                        RESET_PREVIOUS_OP();\n+                        [mtlc reset];\n@@ -668,0 +670,6 @@\n+\n+                    MTLTR_FreeGlyphCaches();\n+                    if (dstOps != NULL) {\n+                        MTLSD_Delete(env, dstOps);\n+                    }\n+\n@@ -669,1 +677,1 @@\n-                \/\/    dstOps = NULL;\n+                    dstOps = NULL;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -734,49 +734,0 @@\n-static MTLRenderPipelineDescriptor * templateAAPipelineDesc = nil;\n-\n-static jboolean\n-setupAAShaderState(id<MTLRenderCommandEncoder> encoder,\n-                    MTLContext *mtlc,\n-                    MTLSDOps *dstOps)\n-{\n-    if (templateAAPipelineDesc == nil) {\n-\n-        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n-        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n-        vertDesc.attributes[VertexAttributePosition].offset = 0;\n-        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n-        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct AAVertex);\n-        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n-        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-\n-        templateAAPipelineDesc = [MTLRenderPipelineDescriptor new];\n-        templateAAPipelineDesc.sampleCount = 1;\n-        templateAAPipelineDesc.vertexDescriptor = vertDesc;\n-        templateAAPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n-        templateAAPipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n-        templateAAPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n-        templateAAPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n-        templateAAPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n-        templateAAPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-        templateAAPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-        templateAAPipelineDesc.colorAttachments[0].blendingEnabled = YES;\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].format = MTLVertexFormatFloat2;\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].offset = 4*sizeof(float);\n-        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].bufferIndex = MeshVertexBuffer;\n-        templateAAPipelineDesc.label = @\"template_aa\";\n-    }\n-\n-    id<MTLRenderPipelineState> pipelineState =\n-                [mtlc.pipelineStateStorage\n-                    getPipelineState:templateAAPipelineDesc\n-                      vertexShaderId:@\"vert_col_aa\"\n-                    fragmentShaderId:@\"frag_col_aa\"\n-                       stencilNeeded:mtlc.clip.isShape\n-                   ];\n-\n-    [encoder setRenderPipelineState:pipelineState];\n-    return JNI_TRUE;\n-}\n-\n@@ -874,2 +825,1 @@\n-        [mtlc.encoderManager getRenderEncoder:dstOps];\n-    setupAAShaderState(encoder, mtlc, dstOps);\n+        [mtlc.encoderManager getAAShaderRenderEncoder:dstOps];\n@@ -938,2 +888,1 @@\n-        [mtlc.encoderManager getRenderEncoder:dstOps];\n-    setupAAShaderState(encoder, mtlc, dstOps);\n+        [mtlc.encoderManager getAAShaderRenderEncoder:dstOps];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":2,"deletions":53,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLSamplerManager_h_Included\n+#define MTLSamplerManager_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"RenderOptions.h\"\n+\n+@class MTLContex;\n+\n+\n+@interface MTLSamplerManager : NSObject\n+- (id _Nonnull)initWithDevice:(_Nonnull id<MTLDevice>) device;\n+- (void)dealloc;\n+\n+- (void) setSamplerWithEncoder:(_Nonnull id<MTLRenderCommandEncoder>) encoder\n+                 interpolation:(int) interpolation\n+                        repeat:(bool) repeat;\n+@end\n+\n+#endif \/\/ MTLSamplerManager_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSamplerManager.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLSamplerManager.h\"\n+#include \"MTLContext.h\"\n+#include \"sun_java2d_SunGraphics2D.h\"\n+#import \"common.h\"\n+\n+@implementation MTLSamplerManager {\n+    id<MTLSamplerState> _samplerNearestClamp;\n+    id<MTLSamplerState> _samplerLinearClamp;\n+    id<MTLSamplerState> _samplerNearestRepeat;\n+    id<MTLSamplerState> _samplerLinearRepeat;\n+}\n+\n+- (id _Nonnull)initWithDevice:(id<MTLDevice>) device {\n+    self = [super init];\n+    if (self) {\n+        MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n+\n+        samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;\n+        samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;\n+        samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+        _samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+        _samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;\n+        samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;\n+        samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+        _samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+        _samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+    }\n+    return self;\n+}\n+\n+- (void) setSamplerWithEncoder:(id<MTLRenderCommandEncoder>) encoder\n+                 interpolation:(int) interpolation\n+                        repeat:(bool) repeat {\n+    id<MTLSamplerState> sampler;\n+    if (repeat) {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? _samplerLinearRepeat : _samplerNearestRepeat;\n+    } else {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? _samplerLinearClamp : _samplerNearestClamp;\n+    }\n+    [encoder setFragmentSamplerState:sampler atIndex:0];\n+}\n+\n+- (void)dealloc {\n+    [_samplerNearestClamp release];\n+    [_samplerLinearClamp release];\n+    [_samplerNearestRepeat release];\n+    [_samplerLinearRepeat release];\n+    [super dealloc];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSamplerManager.m","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLStencilManager_h_Included\n+#define MTLStencilManager_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"RenderOptions.h\"\n+\n+@class MTLContex;\n+\n+\n+@interface MTLStencilManager : NSObject\n+- (id _Nonnull)initWithDevice:(_Nonnull id<MTLDevice>) device;\n+- (void)dealloc;\n+@property (readonly) _Nonnull id<MTLDepthStencilState> stencilState;\n+@end\n+\n+#endif \/\/ MTLSamplerManager_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLStencilManager.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLStencilManager.h\"\n+\/\/#include \"MTLContext.h\"\n+\/\/#include \"sun_java2d_SunGraphics2D.h\"\n+\/\/#import \"common.h\"\n+\n+@implementation MTLStencilManager {\n+    id<MTLDepthStencilState> _stencilState;\n+}\n+\n+@synthesize stencilState = _stencilState;\n+\n+- (id _Nonnull)initWithDevice:(id<MTLDevice>) device {\n+    self = [super init];\n+    if (self) {\n+        MTLDepthStencilDescriptor* stencilDescriptor;\n+        stencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n+        stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+\n+        \/\/ TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives\n+        \/\/ currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.\n+        \/\/ Once that part is changed, set backFaceStencil to nil\n+        \/\/stencilDescriptor.backFaceStencil = nil;\n+\n+        stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+        _stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc {\n+    [_stencilState release];\n+    [super dealloc];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLStencilManager.m","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -381,1 +381,1 @@\n-(JNIEnv *env, jobject cglsd)\n+(JNIEnv *env, jobject mtlsd)\n@@ -385,1 +385,1 @@\n-    BMTLSDOps *bmtlsdo = (MTLSDOps*) SurfaceData_GetOps(env, cglsd);\n+    BMTLSDOps *bmtlsdo = (MTLSDOps*) SurfaceData_GetOps(env, mtlsd);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    jboolean isAAShader;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/RenderOptions.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}