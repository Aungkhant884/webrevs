{"files":[{"patch":"@@ -577,0 +577,2 @@\n+METAL := @METAL@\n+METALLIB := @METALLIB@\n","filename":"make\/autoconf\/spec.gmk.in","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -726,0 +726,26 @@\n+\n+    UTIL_LOOKUP_TOOLCHAIN_PROGS(METAL, metal)\n+    if test \"x$METAL\" = x; then\n+      AC_MSG_CHECKING([if metal can be run using xcrun])\n+      METAL=\"xcrun -sdk macosx metal\"\n+      test_metal=`$METAL --version 2>&1`\n+      if test $? -ne 0; then\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([XCode tool 'metal' neither found in path nor with xcrun])\n+      else\n+        AC_MSG_RESULT([yes, will be using '$METAL'])\n+      fi\n+    fi\n+\n+    UTIL_LOOKUP_TOOLCHAIN_PROGS(METALLIB, metallib)\n+    if test \"x$METALLIB\" = x; then\n+      AC_MSG_CHECKING([if metallib can be run using xcrun])\n+      METALLIB=\"xcrun -sdk macosx metallib\"\n+      test_metallib=`$METALLIB --version 2>&1`\n+      if test $? -ne 0; then\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([XCode tool 'metallib' neither found in path nor with xcrun])\n+      else\n+        AC_MSG_RESULT([yes, will be using '$METALLIB'])\n+      fi\n+    fi\n","filename":"make\/autoconf\/toolchain.m4","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+include Execute.gmk\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+        -framework Metal \\\n@@ -769,1 +770,2 @@\n-        -framework Cocoa\n+        -framework Cocoa \\\n+        -framework Metal\n@@ -830,0 +832,1 @@\n+      libawt_lwawt\/java2d\/metal \\\n@@ -865,0 +868,1 @@\n+          -framework Metal \\\n@@ -887,0 +891,22 @@\n+  SHADERS_SRC := $(TOPDIR)\/src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal\n+  SHADERS_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/java.desktop\/libosxui\n+  SHADERS_AIR := $(SHADERS_SUPPORT_DIR)\/shaders.air\n+  SHADERS_LIB := $(INSTALL_LIBRARIES_HERE)\/shaders.metallib\n+\n+  $(eval $(call SetupExecute, metal_shaders, \\\n+      INFO := Running metal on $(notdir $(SHADERS_SRC)) (for libosxui.dylib), \\\n+      DEPS := $(SHADERS_SRC), \\\n+      OUTPUT_FILE := $(SHADERS_AIR), \\\n+      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n+      COMMAND := $(METAL) -c -std=osx-metal2.0 -o $(SHADERS_AIR) $(SHADERS_SRC), \\\n+  ))\n+\n+  $(eval $(call SetupExecute, metallib_shaders, \\\n+      INFO := Running metallib on $(notdir $(SHADERS_AIR)) (for libosxui.dylib), \\\n+      DEPS := $(SHADERS_AIR), \\\n+      OUTPUT_FILE := $(SHADERS_LIB), \\\n+      SUPPORT_DIR := $(SHADERS_SUPPORT_DIR), \\\n+      COMMAND := $(METALLIB) -o $(SHADERS_LIB) $(SHADERS_AIR), \\\n+  ))\n+\n+  TARGETS += $(SHADERS_LIB)\n@@ -902,0 +928,1 @@\n+          -framework Metal \\\n@@ -909,0 +936,1 @@\n+  $(BUILD_LIBOSXUI): $(SHADERS_LIB)\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import sun.java2d.opengl.CGLLayer;\n@@ -37,0 +36,1 @@\n+import sun.lwawt.macosx.CFRetainedResource;\n@@ -83,1 +83,1 @@\n-    public abstract SurfaceData createSurfaceData(CGLLayer layer);\n+    public abstract SurfaceData createSurfaceData(CFRetainedResource layer);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsConfig.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import sun.java2d.MacOSFlags;\n+import sun.java2d.metal.MTLGraphicsConfig;\n@@ -57,1 +59,4 @@\n-    private final GraphicsConfiguration config;\n+    private GraphicsConfiguration config;\n+    private static boolean metalPipelineEnabled = false;\n+    private static boolean oglPipelineEnabled = false;\n+\n@@ -66,1 +71,51 @@\n-        config = CGLGraphicsConfig.getConfig(this);\n+\n+        if (MacOSFlags.isMetalEnabled()) {\n+            \/\/ Try to create MTLGraphicsConfig, if it fails, try to create CGLGraphicsConfig as a fallback\n+            this.config = MTLGraphicsConfig.getConfig(this, displayID);\n+\n+            if (this.config != null) {\n+                metalPipelineEnabled = true;\n+            } else {\n+                \/\/ Try falling back to OpenGL pipeline\n+                if (MacOSFlags.isMetalVerbose()) {\n+                    System.out.println(\"Metal rendering pipeline initialization failed. Using OpenGL rendering pipeline.\");\n+                }\n+\n+                this.config = CGLGraphicsConfig.getConfig(this);\n+\n+                if (this.config != null) {\n+                    oglPipelineEnabled = true;\n+                }\n+            }\n+        } else {\n+            \/\/ Try to create CGLGraphicsConfig, if it fails, try to create MTLGraphicsConfig as a fallback\n+            this.config = CGLGraphicsConfig.getConfig(this);\n+\n+            if (this.config != null) {\n+                oglPipelineEnabled = true;\n+            } else {\n+                \/\/ Try falling back to Metal pipeline\n+                if (MacOSFlags.isOGLVerbose()) {\n+                    System.out.println(\"OpenGL rendering pipeline initialization failed. Using Metal rendering pipeline.\");\n+                }\n+\n+                this.config = MTLGraphicsConfig.getConfig(this, displayID);\n+\n+                if (this.config != null) {\n+                    metalPipelineEnabled = true;\n+                }\n+            }\n+        }\n+\n+        if (!metalPipelineEnabled && !oglPipelineEnabled) {\n+            \/\/ This indicates fallback to other rendering pipeline also failed.\n+            \/\/ Should never reach here\n+            throw new InternalError(\"Error - unable to initialize any rendering pipeline.\");\n+        }\n+\n+        if (metalPipelineEnabled && MacOSFlags.isMetalVerbose()) {\n+            System.out.println(\"Metal pipeline enabled on screen \" + displayID);\n+        } else if (oglPipelineEnabled && MacOSFlags.isOGLVerbose()) {\n+            System.out.println(\"OpenGL pipeline enabled on screen \" + displayID);\n+        }\n+\n@@ -268,0 +323,4 @@\n+    public static boolean usingMetalPipeline() {\n+        return metalPipelineEnabled;\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsDevice.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d;\n+\n+import java.security.PrivilegedAction;\n+import sun.java2d.metal.MTLGraphicsConfig;\n+import sun.java2d.opengl.CGLGraphicsConfig;\n+\n+\n+public class MacOSFlags {\n+\n+    \/**\n+     * Description of command-line flags.  All flags with [true|false]\n+     * values\n+     *      metalEnabled: usage: \"-Dsun.java2d.metal=[true|false]\"\n+     *\/\n+\n+    private static boolean oglEnabled;\n+    private static boolean oglVerbose;\n+    private static boolean metalEnabled;\n+    private static boolean metalVerbose;\n+\n+    private enum PropertyState {ENABLED, DISABLED, UNSPECIFIED};\n+\n+    static {\n+        initJavaFlags();\n+    }\n+\n+    private static PropertyState getBooleanProp(String p, PropertyState defaultVal) {\n+        String propString = System.getProperty(p);\n+        PropertyState returnVal = defaultVal;\n+        if (propString != null) {\n+            if (propString.equals(\"true\") ||\n+                propString.equals(\"t\") ||\n+                propString.equals(\"True\") ||\n+                propString.equals(\"T\") ||\n+                propString.equals(\"\")) \/\/ having the prop name alone\n+            {                          \/\/ is equivalent to true\n+                returnVal = PropertyState.ENABLED;\n+            } else if (propString.equals(\"false\") ||\n+                       propString.equals(\"f\") ||\n+                       propString.equals(\"False\") ||\n+                       propString.equals(\"F\"))\n+            {\n+                returnVal = PropertyState.DISABLED;\n+            }\n+        }\n+        return returnVal;\n+    }\n+\n+    private static boolean isBooleanPropTrueVerbose(String p) {\n+        String propString = System.getProperty(p);\n+        if (propString != null) {\n+            if (propString.equals(\"True\") ||\n+                propString.equals(\"T\"))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void initJavaFlags() {\n+        java.security.AccessController.doPrivileged(\n+                (PrivilegedAction<Object>) () -> {\n+                    PropertyState oglState = getBooleanProp(\"sun.java2d.opengl\", PropertyState.UNSPECIFIED);\n+                    PropertyState metalState = getBooleanProp(\"sun.java2d.metal\", PropertyState.UNSPECIFIED);\n+\n+                    \/\/ Handle invalid combinations to use the default rendering pipeline\n+                    \/\/ Current default rendering pipeline is OpenGL\n+                    \/\/ (The default can be changed to Metal in future just by toggling two states in this if condition block)\n+                    if ((oglState == PropertyState.UNSPECIFIED && metalState == PropertyState.UNSPECIFIED) ||\n+                        (oglState == PropertyState.DISABLED && metalState == PropertyState.DISABLED) ||\n+                        (oglState == PropertyState.ENABLED && metalState == PropertyState.ENABLED)) {\n+                        oglState = PropertyState.ENABLED; \/\/ Enable default pipeline\n+                        metalState = PropertyState.DISABLED; \/\/ Disable non-default pipeline\n+                    }\n+\n+                    if (metalState == PropertyState.UNSPECIFIED) {\n+                        if (oglState == PropertyState.DISABLED) {\n+                            oglEnabled = false;\n+                            metalEnabled = true;\n+                        } else {\n+                            oglEnabled = true;\n+                            metalEnabled = false;\n+                        }\n+                    } else if (metalState == PropertyState.ENABLED) {\n+                        oglEnabled = false;\n+                        metalEnabled = true;\n+                    } else if (metalState == PropertyState.DISABLED) {\n+                        oglEnabled = true;\n+                        metalEnabled = false;\n+                    }\n+\n+                    oglVerbose = isBooleanPropTrueVerbose(\"sun.java2d.opengl\");\n+                    metalVerbose = isBooleanPropTrueVerbose(\"sun.java2d.metal\");\n+\n+                    if (oglEnabled && !metalEnabled) {\n+                        \/\/ Check whether OGL is available\n+                        if (!CGLGraphicsConfig.isCGLAvailable()) {\n+                            if (oglVerbose) {\n+                                System.out.println(\"Could not enable OpenGL pipeline (CGL not available)\");\n+                            }\n+                            oglEnabled = false;\n+                            metalEnabled = MTLGraphicsConfig.isMetalAvailable();\n+                        }\n+                    } else if (metalEnabled && !oglEnabled) {\n+                        \/\/ Check whether Metal framework is available\n+                        if (!MTLGraphicsConfig.isMetalAvailable()) {\n+                            if (metalVerbose) {\n+                                System.out.println(\"Could not enable Metal pipeline (Metal framework not available)\");\n+                            }\n+                            metalEnabled = false;\n+                            oglEnabled = CGLGraphicsConfig.isCGLAvailable();\n+                        }\n+                    }\n+\n+                    \/\/ At this point one of the rendering pipeline must be enabled.\n+                    if (!metalEnabled && !oglEnabled) {\n+                        throw new InternalError(\"Error - unable to initialize any rendering pipeline.\");\n+                    }\n+\n+                    return null;\n+                });\n+    }\n+\n+    public static boolean isMetalEnabled() {\n+        return metalEnabled;\n+    }\n+\n+    public static boolean isMetalVerbose() {\n+        return metalVerbose;\n+    }\n+\n+    public static boolean isOGLEnabled() {\n+        return oglEnabled;\n+    }\n+\n+    public static boolean isOGLVerbose() {\n+        return oglVerbose;\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/MacOSFlags.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import sun.awt.CGraphicsDevice;\n+import sun.java2d.metal.MTLVolatileSurfaceManager;\n@@ -45,1 +47,1 @@\n-     * For Mac OS X, this method returns either an CGL-specific\n+     * For Mac OS X, this method returns either an CGL\/MTL-specific\n@@ -52,1 +54,2 @@\n-        return new CGLVolatileSurfaceManager(vImg, context);\n+        return CGraphicsDevice.usingMetalPipeline() ? new MTLVolatileSurfaceManager(vImg, context) :\n+                new CGLVolatileSurfaceManager(vImg, context);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/MacosxSurfaceManagerFactory.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,905 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.Blit;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.loops.GraphicsPrimitiveMgr;\n+import sun.java2d.loops.ScaledBlit;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.loops.TransformBlit;\n+import sun.java2d.pipe.Region;\n+import sun.java2d.pipe.RenderBuffer;\n+import sun.java2d.pipe.RenderQueue;\n+import sun.java2d.pipe.hw.AccelSurface;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Composite;\n+import java.awt.Transparency;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.lang.annotation.Native;\n+import java.lang.ref.WeakReference;\n+\n+import static sun.java2d.pipe.BufferedOpCodes.BLIT;\n+import static sun.java2d.pipe.BufferedOpCodes.SURFACE_TO_SW_BLIT;\n+\n+final class MTLBlitLoops {\n+\n+    static void register() {\n+        Blit blitIntArgbPreToSurface =\n+                new MTLSwToSurfaceBlit(SurfaceType.IntArgbPre,\n+                        MTLSurfaceData.PF_INT_ARGB_PRE);\n+        Blit blitIntArgbPreToTexture =\n+                new MTLSwToTextureBlit(SurfaceType.IntArgbPre,\n+                        MTLSurfaceData.PF_INT_ARGB_PRE);\n+        TransformBlit transformBlitIntArgbPreToSurface =\n+                new MTLSwToSurfaceTransform(SurfaceType.IntArgbPre,\n+                        MTLSurfaceData.PF_INT_ARGB_PRE);\n+        MTLSurfaceToSwBlit blitSurfaceToIntArgbPre =\n+                new MTLSurfaceToSwBlit(SurfaceType.IntArgbPre,\n+                        MTLSurfaceData.PF_INT_ARGB_PRE);\n+\n+        GraphicsPrimitive[] primitives = {\n+                \/\/ surface->surface ops\n+                new MTLSurfaceToSurfaceBlit(),\n+                new MTLSurfaceToSurfaceScale(),\n+                new MTLSurfaceToSurfaceTransform(),\n+\n+                \/\/ render-to-texture surface->surface ops\n+                new MTLRTTSurfaceToSurfaceBlit(),\n+                new MTLRTTSurfaceToSurfaceScale(),\n+                new MTLRTTSurfaceToSurfaceTransform(),\n+\n+                \/\/ surface->sw ops\n+                new MTLSurfaceToSwBlit(SurfaceType.IntArgb,\n+                        MTLSurfaceData.PF_INT_ARGB),\n+                blitSurfaceToIntArgbPre,\n+\n+                \/\/ sw->surface ops\n+                blitIntArgbPreToSurface,\n+                new MTLSwToSurfaceBlit(SurfaceType.IntRgb,\n+                        MTLSurfaceData.PF_INT_RGB),\n+                new MTLSwToSurfaceBlit(SurfaceType.IntRgbx,\n+                        MTLSurfaceData.PF_INT_RGBX),\n+                new MTLSwToSurfaceBlit(SurfaceType.IntBgr,\n+                        MTLSurfaceData.PF_INT_BGR),\n+                new MTLSwToSurfaceBlit(SurfaceType.IntBgrx,\n+                        MTLSurfaceData.PF_INT_BGRX),\n+                new MTLGeneralBlit(MTLSurfaceData.MTLSurface,\n+                        CompositeType.AnyAlpha,\n+                        blitIntArgbPreToSurface),\n+\n+                new MTLAnyCompositeBlit(MTLSurfaceData.MTLSurface,\n+                        blitSurfaceToIntArgbPre,\n+                        blitSurfaceToIntArgbPre,\n+                        blitIntArgbPreToSurface),\n+                new MTLAnyCompositeBlit(SurfaceType.Any,\n+                        null,\n+                        blitSurfaceToIntArgbPre,\n+                        blitIntArgbPreToSurface),\n+\n+                new MTLSwToSurfaceScale(SurfaceType.IntRgb,\n+                        MTLSurfaceData.PF_INT_RGB),\n+                new MTLSwToSurfaceScale(SurfaceType.IntRgbx,\n+                        MTLSurfaceData.PF_INT_RGBX),\n+                new MTLSwToSurfaceScale(SurfaceType.IntBgr,\n+                        MTLSurfaceData.PF_INT_BGR),\n+                new MTLSwToSurfaceScale(SurfaceType.IntBgrx,\n+                        MTLSurfaceData.PF_INT_BGRX),\n+                new MTLSwToSurfaceScale(SurfaceType.IntArgbPre,\n+                        MTLSurfaceData.PF_INT_ARGB_PRE),\n+\n+                new MTLSwToSurfaceTransform(SurfaceType.IntRgb,\n+                        MTLSurfaceData.PF_INT_RGB),\n+                new MTLSwToSurfaceTransform(SurfaceType.IntRgbx,\n+                        MTLSurfaceData.PF_INT_RGBX),\n+                new MTLSwToSurfaceTransform(SurfaceType.IntBgr,\n+                        MTLSurfaceData.PF_INT_BGR),\n+                new MTLSwToSurfaceTransform(SurfaceType.IntBgrx,\n+                        MTLSurfaceData.PF_INT_BGRX),\n+                transformBlitIntArgbPreToSurface,\n+\n+                new MTLGeneralTransformedBlit(transformBlitIntArgbPreToSurface),\n+\n+                \/\/ texture->surface ops\n+                new MTLTextureToSurfaceBlit(),\n+                new MTLTextureToSurfaceScale(),\n+                new MTLTextureToSurfaceTransform(),\n+\n+                \/\/ sw->texture ops\n+                blitIntArgbPreToTexture,\n+                new MTLSwToTextureBlit(SurfaceType.IntRgb,\n+                        MTLSurfaceData.PF_INT_RGB),\n+                new MTLSwToTextureBlit(SurfaceType.IntRgbx,\n+                        MTLSurfaceData.PF_INT_RGBX),\n+                new MTLSwToTextureBlit(SurfaceType.IntBgr,\n+                        MTLSurfaceData.PF_INT_BGR),\n+                new MTLSwToTextureBlit(SurfaceType.IntBgrx,\n+                        MTLSurfaceData.PF_INT_BGRX),\n+                new MTLGeneralBlit(MTLSurfaceData.MTLTexture,\n+                        CompositeType.SrcNoEa,\n+                        blitIntArgbPreToTexture),\n+        };\n+        GraphicsPrimitiveMgr.register(primitives);\n+    }\n+\n+    \/**\n+     * The following offsets are used to pack the parameters in\n+     * createPackedParams().  (They are also used at the native level when\n+     * unpacking the params.)\n+     *\/\n+    @Native private static final int OFFSET_SRCTYPE = 16;\n+    @Native private static final int OFFSET_HINT    =  8;\n+    @Native private static final int OFFSET_TEXTURE =  3;\n+    @Native private static final int OFFSET_RTT     =  2;\n+    @Native private static final int OFFSET_XFORM   =  1;\n+    @Native private static final int OFFSET_ISOBLIT =  0;\n+\n+    \/**\n+     * Packs the given parameters into a single int value in order to save\n+     * space on the rendering queue.\n+     *\/\n+    private static int createPackedParams(boolean isoblit, boolean texture,\n+                                          boolean rtt, boolean xform,\n+                                          int hint, int srctype)\n+    {\n+        return\n+                ((srctype           << OFFSET_SRCTYPE) |\n+                        (hint              << OFFSET_HINT   ) |\n+                        ((texture ? 1 : 0) << OFFSET_TEXTURE) |\n+                        ((rtt     ? 1 : 0) << OFFSET_RTT    ) |\n+                        ((xform   ? 1 : 0) << OFFSET_XFORM  ) |\n+                        ((isoblit ? 1 : 0) << OFFSET_ISOBLIT));\n+    }\n+\n+    \/**\n+     * Enqueues a BLIT operation with the given parameters.  Note that the\n+     * RenderQueue lock must be held before calling this method.\n+     *\/\n+    private static void enqueueBlit(RenderQueue rq,\n+                                    SurfaceData src, SurfaceData dst,\n+                                    int packedParams,\n+                                    int sx1, int sy1,\n+                                    int sx2, int sy2,\n+                                    double dx1, double dy1,\n+                                    double dx2, double dy2)\n+    {\n+        \/\/ assert rq.lock.isHeldByCurrentThread();\n+        RenderBuffer buf = rq.getBuffer();\n+        rq.ensureCapacityAndAlignment(72, 24);\n+        buf.putInt(BLIT);\n+        buf.putInt(packedParams);\n+        buf.putInt(sx1).putInt(sy1);\n+        buf.putInt(sx2).putInt(sy2);\n+        buf.putDouble(dx1).putDouble(dy1);\n+        buf.putDouble(dx2).putDouble(dy2);\n+        buf.putLong(src.getNativeOps());\n+        buf.putLong(dst.getNativeOps());\n+    }\n+\n+    static void Blit(SurfaceData srcData, SurfaceData dstData,\n+                     Composite comp, Region clip,\n+                     AffineTransform xform, int hint,\n+                     int sx1, int sy1,\n+                     int sx2, int sy2,\n+                     double dx1, double dy1,\n+                     double dx2, double dy2,\n+                     int srctype, boolean texture)\n+    {\n+        int ctxflags = 0;\n+        if (srcData.getTransparency() == Transparency.OPAQUE) {\n+            ctxflags |= MTLContext.SRC_IS_OPAQUE;\n+        }\n+\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ make sure the RenderQueue keeps a hard reference to the\n+            \/\/ source (sysmem) SurfaceData to prevent it from being\n+            \/\/ disposed while the operation is processed on the QFT\n+            rq.addReference(srcData);\n+\n+            MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n+            if (texture) {\n+                \/\/ make sure we have a current context before uploading\n+                \/\/ the sysmem data to the texture object\n+                MTLGraphicsConfig gc = mtlDst.getMTLGraphicsConfig();\n+                MTLContext.setScratchSurface(gc);\n+            } else {\n+                MTLContext.validateContext(mtlDst, mtlDst,\n+                        clip, comp, xform, null, null,\n+                        ctxflags);\n+            }\n+\n+            int packedParams = createPackedParams(false, texture,\n+                    false \/*unused*\/, xform != null,\n+                    hint, srctype);\n+            enqueueBlit(rq, srcData, dstData,\n+                    packedParams,\n+                    sx1, sy1, sx2, sy2,\n+                    dx1, dy1, dx2, dy2);\n+\n+            \/\/ always flush immediately, since we (currently) have no means\n+            \/\/ of tracking changes to the system memory surface\n+            rq.flushNow();\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Note: The srcImg and biop parameters are only used when invoked\n+     * from the MTLBufImgOps.renderImageWithOp() method; in all other cases,\n+     * this method can be called with null values for those two parameters,\n+     * and they will be effectively ignored.\n+     *\/\n+    static void IsoBlit(SurfaceData srcData, SurfaceData dstData,\n+                        BufferedImage srcImg, BufferedImageOp biop,\n+                        Composite comp, Region clip,\n+                        AffineTransform xform, int hint,\n+                        int sx1, int sy1,\n+                        int sx2, int sy2,\n+                        double dx1, double dy1,\n+                        double dx2, double dy2,\n+                        boolean texture)\n+    {\n+        int ctxflags = 0;\n+        if (srcData.getTransparency() == Transparency.OPAQUE) {\n+            ctxflags |= MTLContext.SRC_IS_OPAQUE;\n+        }\n+\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            MTLSurfaceData mtlSrc = (MTLSurfaceData)srcData;\n+            MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n+            int srctype = mtlSrc.getType();\n+            boolean rtt;\n+            MTLSurfaceData srcCtxData;\n+            if (srctype == MTLSurfaceData.TEXTURE) {\n+                \/\/ the source is a regular texture object; we substitute\n+                \/\/ the destination surface for the purposes of making a\n+                \/\/ context current\n+                rtt = false;\n+                srcCtxData = mtlDst;\n+            } else {\n+                \/\/ the source is a pbuffer, backbuffer, or render-to-texture\n+                \/\/ surface; we set rtt to true to differentiate this kind\n+                \/\/ of surface from a regular texture object\n+                rtt = true;\n+                if (srctype == AccelSurface.RT_TEXTURE) {\n+                    srcCtxData = mtlDst;\n+                } else {\n+                    srcCtxData = mtlSrc;\n+                }\n+            }\n+\n+            MTLContext.validateContext(srcCtxData, mtlDst,\n+                    clip, comp, xform, null, null,\n+                    ctxflags);\n+\n+            if (biop != null) {\n+                MTLBufImgOps.enableBufImgOp(rq, mtlSrc, srcImg, biop);\n+            }\n+\n+            int packedParams = createPackedParams(true, texture,\n+                    false \/*unused*\/, xform != null,\n+                    hint, 0 \/*unused*\/);\n+            enqueueBlit(rq, srcData, dstData,\n+                    packedParams,\n+                    sx1, sy1, sx2, sy2,\n+                    dx1, dy1, dx2, dy2);\n+\n+            if (biop != null) {\n+                MTLBufImgOps.disableBufImgOp(rq, biop);\n+            }\n+\n+            if (rtt && mtlDst.isOnScreen()) {\n+                \/\/ we only have to flush immediately when copying from a\n+                \/\/ (non-texture) surface to the screen; otherwise Swing apps\n+                \/\/ might appear unresponsive until the auto-flush completes\n+                rq.flushNow();\n+            }\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+}\n+\n+class MTLSurfaceToSurfaceBlit extends Blit {\n+\n+    MTLSurfaceToSurfaceBlit() {\n+        super(MTLSurfaceData.MTLSurface,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                false);\n+    }\n+}\n+\n+class MTLSurfaceToSurfaceScale extends ScaledBlit {\n+\n+    MTLSurfaceToSurfaceScale() {\n+        super(MTLSurfaceData.MTLSurface,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Scale(SurfaceData src, SurfaceData dst,\n+                      Composite comp, Region clip,\n+                      int sx1, int sy1,\n+                      int sx2, int sy2,\n+                      double dx1, double dy1,\n+                      double dx2, double dy2)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx1, sy1, sx2, sy2,\n+                dx1, dy1, dx2, dy2,\n+                false);\n+    }\n+}\n+\n+class MTLSurfaceToSurfaceTransform extends TransformBlit {\n+\n+    MTLSurfaceToSurfaceTransform() {\n+        super(MTLSurfaceData.MTLSurface,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Transform(SurfaceData src, SurfaceData dst,\n+                          Composite comp, Region clip,\n+                          AffineTransform at, int hint,\n+                          int sx, int sy, int dx, int dy,\n+                          int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, at, hint,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                false);\n+    }\n+}\n+\n+class MTLRTTSurfaceToSurfaceBlit extends Blit {\n+\n+    MTLRTTSurfaceToSurfaceBlit() {\n+        super(MTLSurfaceData.MTLSurfaceRTT,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                true);\n+    }\n+}\n+\n+class MTLRTTSurfaceToSurfaceScale extends ScaledBlit {\n+\n+    MTLRTTSurfaceToSurfaceScale() {\n+        super(MTLSurfaceData.MTLSurfaceRTT,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Scale(SurfaceData src, SurfaceData dst,\n+                      Composite comp, Region clip,\n+                      int sx1, int sy1,\n+                      int sx2, int sy2,\n+                      double dx1, double dy1,\n+                      double dx2, double dy2)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx1, sy1, sx2, sy2,\n+                dx1, dy1, dx2, dy2,\n+                true);\n+    }\n+}\n+\n+class MTLRTTSurfaceToSurfaceTransform extends TransformBlit {\n+\n+    MTLRTTSurfaceToSurfaceTransform() {\n+        super(MTLSurfaceData.MTLSurfaceRTT,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Transform(SurfaceData src, SurfaceData dst,\n+                          Composite comp, Region clip,\n+                          AffineTransform at, int hint,\n+                          int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, at, hint,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                true);\n+    }\n+}\n+\n+final class MTLSurfaceToSwBlit extends Blit {\n+\n+    private final int typeval;\n+    private WeakReference<SurfaceData> srcTmp;\n+\n+    \/\/ destination will actually be ArgbPre or Argb\n+    MTLSurfaceToSwBlit(final SurfaceType dstType, final int typeval) {\n+        super(MTLSurfaceData.MTLSurface,\n+                CompositeType.SrcNoEa,\n+                dstType);\n+        this.typeval = typeval;\n+    }\n+\n+    private synchronized void complexClipBlit(SurfaceData src, SurfaceData dst,\n+                                              Composite comp, Region clip,\n+                                              int sx, int sy, int dx, int dy,\n+                                              int w, int h) {\n+        SurfaceData cachedSrc = null;\n+        if (srcTmp != null) {\n+            \/\/ use cached intermediate surface, if available\n+            cachedSrc = srcTmp.get();\n+        }\n+\n+        \/\/ We can convert argb_pre data from MTL surface in two places:\n+        \/\/ - During MTL surface -> SW blit\n+        \/\/ - During SW -> SW blit\n+        \/\/ The first one is faster when we use opaque MTL surface, because in\n+        \/\/ this case we simply skip conversion and use color components as is.\n+        \/\/ Because of this we align intermediate buffer type with type of\n+        \/\/ destination not source.\n+        final int type = typeval == MTLSurfaceData.PF_INT_ARGB_PRE ?\n+                BufferedImage.TYPE_INT_ARGB_PRE :\n+                BufferedImage.TYPE_INT_ARGB;\n+\n+        src = convertFrom(this, src, sx, sy, w, h, cachedSrc, type);\n+\n+        \/\/ copy intermediate SW to destination SW using complex clip\n+        final Blit performop = Blit.getFromCache(src.getSurfaceType(),\n+                CompositeType.SrcNoEa,\n+                dst.getSurfaceType());\n+        performop.Blit(src, dst, comp, clip, 0, 0, dx, dy, w, h);\n+\n+        if (src != cachedSrc) {\n+            \/\/ cache the intermediate surface\n+            srcTmp = new WeakReference<>(src);\n+        }\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy,\n+                     int w, int h)\n+    {\n+        if (clip != null) {\n+            clip = clip.getIntersectionXYWH(dx, dy, w, h);\n+            \/\/ At the end this method will flush the RenderQueue, we should exit\n+            \/\/ from it as soon as possible.\n+            if (clip.isEmpty()) {\n+                return;\n+            }\n+            sx += clip.getLoX() - dx;\n+            sy += clip.getLoY() - dy;\n+            dx = clip.getLoX();\n+            dy = clip.getLoY();\n+            w = clip.getWidth();\n+            h = clip.getHeight();\n+\n+            if (!clip.isRectangular()) {\n+                complexClipBlit(src, dst, comp, clip, sx, sy, dx, dy, w, h);\n+                return;\n+            }\n+        }\n+\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ make sure the RenderQueue keeps a hard reference to the\n+            \/\/ destination (sysmem) SurfaceData to prevent it from being\n+            \/\/ disposed while the operation is processed on the QFT\n+            rq.addReference(dst);\n+\n+            RenderBuffer buf = rq.getBuffer();\n+            MTLContext.validateContext((MTLSurfaceData)src);\n+\n+            rq.ensureCapacityAndAlignment(48, 32);\n+            buf.putInt(SURFACE_TO_SW_BLIT);\n+            buf.putInt(sx).putInt(sy);\n+            buf.putInt(dx).putInt(dy);\n+            buf.putInt(w).putInt(h);\n+            buf.putInt(typeval);\n+            buf.putLong(src.getNativeOps());\n+            buf.putLong(dst.getNativeOps());\n+\n+            \/\/ always flush immediately\n+            rq.flushNow();\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+}\n+\n+class MTLSwToSurfaceBlit extends Blit {\n+\n+    private int typeval;\n+\n+    MTLSwToSurfaceBlit(SurfaceType srcType, int typeval) {\n+        super(srcType,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+        this.typeval = typeval;\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.Blit(src, dst,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                typeval, false);\n+    }\n+}\n+\n+class MTLSwToSurfaceScale extends ScaledBlit {\n+\n+    private int typeval;\n+\n+    MTLSwToSurfaceScale(SurfaceType srcType, int typeval) {\n+        super(srcType,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+        this.typeval = typeval;\n+    }\n+\n+    public void Scale(SurfaceData src, SurfaceData dst,\n+                      Composite comp, Region clip,\n+                      int sx1, int sy1,\n+                      int sx2, int sy2,\n+                      double dx1, double dy1,\n+                      double dx2, double dy2)\n+    {\n+        MTLBlitLoops.Blit(src, dst,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx1, sy1, sx2, sy2,\n+                dx1, dy1, dx2, dy2,\n+                typeval, false);\n+    }\n+}\n+\n+class MTLSwToSurfaceTransform extends TransformBlit {\n+\n+    private int typeval;\n+\n+    MTLSwToSurfaceTransform(SurfaceType srcType, int typeval) {\n+        super(srcType,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+        this.typeval = typeval;\n+    }\n+\n+    public void Transform(SurfaceData src, SurfaceData dst,\n+                          Composite comp, Region clip,\n+                          AffineTransform at, int hint,\n+                          int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.Blit(src, dst,\n+                comp, clip, at, hint,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                typeval, false);\n+    }\n+}\n+\n+class MTLSwToTextureBlit extends Blit {\n+\n+    private int typeval;\n+\n+    MTLSwToTextureBlit(SurfaceType srcType, int typeval) {\n+        super(srcType,\n+                CompositeType.SrcNoEa,\n+                MTLSurfaceData.MTLTexture);\n+        this.typeval = typeval;\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.Blit(src, dst,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                typeval, true);\n+    }\n+}\n+\n+class MTLTextureToSurfaceBlit extends Blit {\n+\n+    MTLTextureToSurfaceBlit() {\n+        super(MTLSurfaceData.MTLTexture,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Blit(SurfaceData src, SurfaceData dst,\n+                     Composite comp, Region clip,\n+                     int sx, int sy, int dx, int dy, int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                true);\n+    }\n+}\n+\n+class MTLTextureToSurfaceScale extends ScaledBlit {\n+\n+    MTLTextureToSurfaceScale() {\n+        super(MTLSurfaceData.MTLTexture,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Scale(SurfaceData src, SurfaceData dst,\n+                      Composite comp, Region clip,\n+                      int sx1, int sy1,\n+                      int sx2, int sy2,\n+                      double dx1, double dy1,\n+                      double dx2, double dy2)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, null,\n+                AffineTransformOp.TYPE_NEAREST_NEIGHBOR,\n+                sx1, sy1, sx2, sy2,\n+                dx1, dy1, dx2, dy2,\n+                true);\n+    }\n+}\n+\n+class MTLTextureToSurfaceTransform extends TransformBlit {\n+\n+    MTLTextureToSurfaceTransform() {\n+        super(MTLSurfaceData.MTLTexture,\n+                CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+    }\n+\n+    public void Transform(SurfaceData src, SurfaceData dst,\n+                          Composite comp, Region clip,\n+                          AffineTransform at, int hint,\n+                          int sx, int sy, int dx, int dy,\n+                          int w, int h)\n+    {\n+        MTLBlitLoops.IsoBlit(src, dst,\n+                null, null,\n+                comp, clip, at, hint,\n+                sx, sy, sx+w, sy+h,\n+                dx, dy, dx+w, dy+h,\n+                true);\n+    }\n+}\n+\n+\/**\n+ * This general Blit implementation converts any source surface to an\n+ * intermediate IntArgbPre surface, and then uses the more specific\n+ * IntArgbPre->MTLSurface\/Texture loop to get the intermediate\n+ * (premultiplied) surface down to Metal using simple blit.\n+ *\/\n+class MTLGeneralBlit extends Blit {\n+\n+    private final Blit performop;\n+    private WeakReference<SurfaceData> srcTmp;\n+\n+    MTLGeneralBlit(SurfaceType dstType,\n+                   CompositeType compType,\n+                   Blit performop)\n+    {\n+        super(SurfaceType.Any, compType, dstType);\n+        this.performop = performop;\n+    }\n+\n+    public synchronized void Blit(SurfaceData src, SurfaceData dst,\n+                                  Composite comp, Region clip,\n+                                  int sx, int sy, int dx, int dy,\n+                                  int w, int h)\n+    {\n+        Blit convertsrc = Blit.getFromCache(src.getSurfaceType(),\n+                CompositeType.SrcNoEa,\n+                SurfaceType.IntArgbPre);\n+\n+        SurfaceData cachedSrc = null;\n+        if (srcTmp != null) {\n+            \/\/ use cached intermediate surface, if available\n+            cachedSrc = srcTmp.get();\n+        }\n+\n+        \/\/ convert source to IntArgbPre\n+        src = convertFrom(convertsrc, src, sx, sy, w, h,\n+                cachedSrc, BufferedImage.TYPE_INT_ARGB_PRE);\n+\n+        \/\/ copy IntArgbPre intermediate surface to Metal surface\n+        performop.Blit(src, dst, comp, clip,\n+                0, 0, dx, dy, w, h);\n+\n+        if (src != cachedSrc) {\n+            \/\/ cache the intermediate surface\n+            srcTmp = new WeakReference<>(src);\n+        }\n+    }\n+}\n+\n+\/**\n+ * This general TransformedBlit implementation converts any source surface to an\n+ * intermediate IntArgbPre surface, and then uses the more specific\n+ * IntArgbPre->MTLSurface\/Texture loop to get the intermediate\n+ * (premultiplied) surface down to Metal using simple transformBlit.\n+ *\/\n+final class MTLGeneralTransformedBlit extends TransformBlit {\n+\n+    private final TransformBlit performop;\n+    private WeakReference<SurfaceData> srcTmp;\n+\n+    MTLGeneralTransformedBlit(final TransformBlit performop) {\n+        super(SurfaceType.Any, CompositeType.AnyAlpha,\n+                MTLSurfaceData.MTLSurface);\n+        this.performop = performop;\n+    }\n+\n+    @Override\n+    public synchronized void Transform(SurfaceData src, SurfaceData dst,\n+                                       Composite comp, Region clip,\n+                                       AffineTransform at, int hint, int srcx,\n+                                       int srcy, int dstx, int dsty, int width,\n+                                       int height){\n+        Blit convertsrc = Blit.getFromCache(src.getSurfaceType(),\n+                CompositeType.SrcNoEa,\n+                SurfaceType.IntArgbPre);\n+        \/\/ use cached intermediate surface, if available\n+        final SurfaceData cachedSrc = srcTmp != null ? srcTmp.get() : null;\n+        \/\/ convert source to IntArgbPre\n+        src = convertFrom(convertsrc, src, srcx, srcy, width, height, cachedSrc,\n+                BufferedImage.TYPE_INT_ARGB_PRE);\n+\n+        \/\/ transform IntArgbPre intermediate surface to Metal surface\n+        performop.Transform(src, dst, comp, clip, at, hint, 0, 0, dstx, dsty,\n+                width, height);\n+\n+        if (src != cachedSrc) {\n+            \/\/ cache the intermediate surface\n+            srcTmp = new WeakReference<>(src);\n+        }\n+    }\n+}\n+\n+\/**\n+ * This general MTLAnyCompositeBlit implementation can convert any source\/target\n+ * surface to an intermediate surface using convertsrc\/convertdst loops, applies\n+ * necessary composite operation, and then uses convertresult loop to get the\n+ * intermediate surface down to Metal.\n+ *\/\n+final class MTLAnyCompositeBlit extends Blit {\n+\n+    private WeakReference<SurfaceData> dstTmp;\n+    private WeakReference<SurfaceData> srcTmp;\n+    private final Blit convertsrc;\n+    private final Blit convertdst;\n+    private final Blit convertresult;\n+\n+    MTLAnyCompositeBlit(SurfaceType srctype, Blit convertsrc, Blit convertdst,\n+                        Blit convertresult) {\n+        super(srctype, CompositeType.Any, MTLSurfaceData.MTLSurface);\n+        this.convertsrc = convertsrc;\n+        this.convertdst = convertdst;\n+        this.convertresult = convertresult;\n+    }\n+\n+    public synchronized void Blit(SurfaceData src, SurfaceData dst,\n+                                  Composite comp, Region clip,\n+                                  int sx, int sy, int dx, int dy,\n+                                  int w, int h)\n+    {\n+        if (convertsrc != null) {\n+            SurfaceData cachedSrc = null;\n+            if (srcTmp != null) {\n+                \/\/ use cached intermediate surface, if available\n+                cachedSrc = srcTmp.get();\n+            }\n+            \/\/ convert source to IntArgbPre\n+            src = convertFrom(convertsrc, src, sx, sy, w, h, cachedSrc,\n+                    BufferedImage.TYPE_INT_ARGB_PRE);\n+            if (src != cachedSrc) {\n+                \/\/ cache the intermediate surface\n+                srcTmp = new WeakReference<>(src);\n+            }\n+        }\n+\n+        SurfaceData cachedDst = null;\n+\n+        if (dstTmp != null) {\n+            \/\/ use cached intermediate surface, if available\n+            cachedDst = dstTmp.get();\n+        }\n+\n+        \/\/ convert destination to IntArgbPre\n+        SurfaceData dstBuffer = convertFrom(convertdst, dst, dx, dy, w, h,\n+                cachedDst, BufferedImage.TYPE_INT_ARGB_PRE);\n+        Region bufferClip =\n+                clip == null ? null : clip.getTranslatedRegion(-dx, -dy);\n+\n+        Blit performop = Blit.getFromCache(src.getSurfaceType(),\n+                CompositeType.Any, dstBuffer.getSurfaceType());\n+        performop.Blit(src, dstBuffer, comp, bufferClip, sx, sy, 0, 0, w, h);\n+\n+        if (dstBuffer != cachedDst) {\n+            \/\/ cache the intermediate surface\n+            dstTmp = new WeakReference<>(dstBuffer);\n+        }\n+        \/\/ now blit the buffer back to the destination\n+        convertresult.Blit(dstBuffer, dst, AlphaComposite.Src, clip, 0, 0, dx,\n+                dy, w, h);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLBlitLoops.java","additions":905,"deletions":0,"binary":false,"changes":905,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.pipe.BufferedBufImgOps;\n+\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ConvolveOp;\n+import java.awt.image.LookupOp;\n+import java.awt.image.RescaleOp;\n+\n+import static sun.java2d.metal.MTLContext.MTLContextCaps.CAPS_EXT_BIOP_SHADER;\n+\n+class MTLBufImgOps extends BufferedBufImgOps {\n+\n+    \/**\n+     * This method is called from MTLDrawImage.transformImage() only.  It\n+     * validates the provided BufferedImageOp to determine whether the op\n+     * is one that can be accelerated by the MTL pipeline.  If the operation\n+     * cannot be completed for any reason, this method returns false;\n+     * otherwise, the given BufferedImage is rendered to the destination\n+     * using the provided BufferedImageOp and this method returns true.\n+     *\/\n+    static boolean renderImageWithOp(SunGraphics2D sg, BufferedImage img,\n+                                     BufferedImageOp biop, int x, int y)\n+    {\n+        \/\/ Validate the provided BufferedImage (make sure it is one that\n+        \/\/ is supported, and that its properties are acceleratable)\n+        if (biop instanceof ConvolveOp) {\n+            if (!isConvolveOpValid((ConvolveOp)biop)) {\n+                return false;\n+            }\n+        } else if (biop instanceof RescaleOp) {\n+            if (!isRescaleOpValid((RescaleOp)biop, img)) {\n+                return false;\n+            }\n+        } else if (biop instanceof LookupOp) {\n+            if (!isLookupOpValid((LookupOp)biop, img)) {\n+                return false;\n+            }\n+        } else {\n+            \/\/ No acceleration for other BufferedImageOps (yet)\n+            return false;\n+        }\n+\n+        SurfaceData dstData = sg.surfaceData;\n+        if (!(dstData instanceof MTLSurfaceData) ||\n+                (sg.interpolationType == AffineTransformOp.TYPE_BICUBIC) ||\n+                (sg.compositeState > SunGraphics2D.COMP_ALPHA))\n+        {\n+            return false;\n+        }\n+\n+        SurfaceData srcData =\n+                dstData.getSourceSurfaceData(img, SunGraphics2D.TRANSFORM_ISIDENT,\n+                        CompositeType.SrcOver, null);\n+        if (!(srcData instanceof MTLSurfaceData)) {\n+            \/\/ REMIND: this hack tries to ensure that we have a cached texture\n+            srcData =\n+                    dstData.getSourceSurfaceData(img, SunGraphics2D.TRANSFORM_ISIDENT,\n+                            CompositeType.SrcOver, null);\n+            if (!(srcData instanceof MTLSurfaceData)) {\n+                return false;\n+            }\n+        }\n+\n+        \/\/ Verify that the source surface is actually a texture and\n+        \/\/ that the operation is supported\n+        MTLSurfaceData mtlSrc = (MTLSurfaceData)srcData;\n+        MTLGraphicsConfig gc = mtlSrc.getMTLGraphicsConfig();\n+        if (mtlSrc.getType() != MTLSurfaceData.TEXTURE ||\n+                !gc.isCapPresent(CAPS_EXT_BIOP_SHADER))\n+        {\n+            return false;\n+        }\n+\n+        int sw = img.getWidth();\n+        int sh = img.getHeight();\n+        MTLBlitLoops.IsoBlit(srcData, dstData,\n+                img, biop,\n+                sg.composite, sg.getCompClip(),\n+                sg.transform, sg.interpolationType,\n+                0, 0, sw, sh,\n+                x, y, x+sw, y+sh,\n+                true);\n+\n+        return true;\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLBufImgOps.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.pipe.BufferedContext;\n+import sun.java2d.pipe.RenderBuffer;\n+import sun.java2d.pipe.RenderQueue;\n+import sun.java2d.pipe.hw.ContextCapabilities;\n+\n+import java.lang.annotation.Native;\n+\n+import static sun.java2d.pipe.BufferedOpCodes.INVALIDATE_CONTEXT;\n+import static sun.java2d.pipe.BufferedOpCodes.SET_SCRATCH_SURFACE;\n+\n+\/**\n+ * Note that the RenderQueue lock must be acquired before calling any of\n+ * the methods in this class.\n+ *\/\n+final class MTLContext extends BufferedContext {\n+\n+    public MTLContext(RenderQueue rq) {\n+        super(rq);\n+    }\n+\n+    \/**\n+     * Convenience method that delegates to setScratchSurface() below.\n+     *\/\n+    static void setScratchSurface(MTLGraphicsConfig gc) {\n+        setScratchSurface(gc.getNativeConfigInfo());\n+    }\n+\n+    \/**\n+     * Makes the given GraphicsConfig's context current to its associated\n+     * \"scratch surface\".  Each GraphicsConfig maintains a native context\n+     * (MTLDevice) as well as a native pbuffer\n+     * known as the \"scratch surface\".  By making the context current to the\n+     * scratch surface, we are assured that we have a current context for\n+     * the relevant GraphicsConfig, and can therefore perform operations\n+     * depending on the capabilities of that GraphicsConfig.\n+     * This method should be used for operations with an MTL texture\n+     * as the destination surface (e.g. a sw->texture blit loop), or in those\n+     * situations where we may not otherwise have a current context (e.g.\n+     * when disposing a texture-based surface).\n+     *\/\n+    public static void setScratchSurface(long pConfigInfo) {\n+        \/\/ assert MTLRenderQueue.getInstance().lock.isHeldByCurrentThread();\n+\n+        \/\/ invalidate the current context\n+        currentContext = null;\n+\n+        \/\/ set the scratch context\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        RenderBuffer buf = rq.getBuffer();\n+        rq.ensureCapacityAndAlignment(12, 4);\n+        buf.putInt(SET_SCRATCH_SURFACE);\n+        buf.putLong(pConfigInfo);\n+    }\n+\n+    \/**\n+     * Invalidates the currentContext field to ensure that we properly\n+     * revalidate the MTLContext (make it current, etc.) next time through\n+     * the validate() method.  This is typically invoked from methods\n+     * that affect the current context state (e.g. disposing a context or\n+     * surface).\n+     *\/\n+    public static void invalidateCurrentContext() {\n+        \/\/ assert MTLRenderQueue.getInstance().lock.isHeldByCurrentThread();\n+\n+        \/\/ invalidate the current Java-level context so that we\n+        \/\/ revalidate everything the next time around\n+        if (currentContext != null) {\n+            currentContext.invalidateContext();\n+            currentContext = null;\n+        }\n+\n+        \/\/ invalidate the context reference at the native level, and\n+        \/\/ then flush the queue so that we have no pending operations\n+        \/\/ dependent on the current context\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.ensureCapacity(4);\n+        rq.getBuffer().putInt(INVALIDATE_CONTEXT);\n+        rq.flushNow();\n+    }\n+\n+    public static class MTLContextCaps extends ContextCapabilities {\n+\n+        \/** Indicates that the context is doublebuffered. *\/\n+        @Native\n+        public static final int CAPS_DOUBLEBUFFERED   = (FIRST_PRIVATE_CAP << 0);\n+        \/**\n+         * This cap will only be set if the lcdshader system property has been\n+         * enabled and the hardware supports the minimum number of texture units\n+         *\/\n+        @Native\n+        static final int CAPS_EXT_LCD_SHADER   = (FIRST_PRIVATE_CAP << 1);\n+        \/**\n+         * This cap will only be set if the biopshader system property has been\n+         * enabled and the hardware meets our minimum requirements.\n+         *\/\n+        @Native\n+        public static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP << 2);\n+        \/**\n+         * This cap will only be set if the gradshader system property has been\n+         * enabled and the hardware meets our minimum requirements.\n+         *\/\n+        @Native\n+        static final int CAPS_EXT_GRAD_SHADER  = (FIRST_PRIVATE_CAP << 3);\n+\n+        public MTLContextCaps(int caps, String adapterId) {\n+            super(caps, adapterId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder(super.toString());\n+            if ((caps & CAPS_DOUBLEBUFFERED) != 0) {\n+                sb.append(\"CAPS_DOUBLEBUFFERED|\");\n+            }\n+            if ((caps & CAPS_EXT_LCD_SHADER) != 0) {\n+                sb.append(\"CAPS_EXT_LCD_SHADER|\");\n+            }\n+            if ((caps & CAPS_EXT_BIOP_SHADER) != 0) {\n+                sb.append(\"CAPS_BIOP_SHADER|\");\n+            }\n+            if ((caps & CAPS_EXT_GRAD_SHADER) != 0) {\n+                sb.append(\"CAPS_EXT_GRAD_SHADER|\");\n+            }\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLContext.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.loops.TransformBlit;\n+import sun.java2d.pipe.DrawImage;\n+\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+\n+public class MTLDrawImage extends DrawImage {\n+\n+    @Override\n+    protected void renderImageXform(SunGraphics2D sg, Image img,\n+                                    AffineTransform tx, int interpType,\n+                                    int sx1, int sy1, int sx2, int sy2,\n+                                    Color bgColor)\n+    {\n+        \/\/ punt to the MediaLib-based transformImage() in the superclass if:\n+        \/\/     - bicubic interpolation is specified\n+        \/\/     - a background color is specified and will be used\n+        \/\/     - the source surface is neither a texture nor render-to-texture\n+        \/\/       surface, and a non-default interpolation hint is specified\n+        \/\/       (we can only control the filtering for texture->surface\n+        \/\/       copies)\n+        \/\/         REMIND: we should tweak the sw->texture->surface\n+        \/\/         transform case to handle filtering appropriately\n+        \/\/         (see 4841762)...\n+        \/\/     - an appropriate TransformBlit primitive could not be found\n+        if (interpType != AffineTransformOp.TYPE_BICUBIC) {\n+            SurfaceData dstData = sg.surfaceData;\n+            SurfaceData srcData =\n+                    dstData.getSourceSurfaceData(img,\n+                            SunGraphics2D.TRANSFORM_GENERIC,\n+                            sg.imageComp,\n+                            bgColor);\n+\n+            if (srcData != null &&\n+                    !isBgOperation(srcData, bgColor) &&\n+                    (srcData.getSurfaceType() == MTLSurfaceData.MTLTexture ||\n+                            srcData.getSurfaceType() == MTLSurfaceData.MTLSurfaceRTT ||\n+                            interpType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR))\n+            {\n+                SurfaceType srcType = srcData.getSurfaceType();\n+                SurfaceType dstType = dstData.getSurfaceType();\n+                TransformBlit blit = TransformBlit.getFromCache(srcType,\n+                        sg.imageComp,\n+                        dstType);\n+\n+                if (blit != null) {\n+                    blit.Transform(srcData, dstData,\n+                            sg.composite, sg.getCompClip(),\n+                            tx, interpType,\n+                            sx1, sy1, 0, 0, sx2-sx1, sy2-sy1);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        super.renderImageXform(sg, img, tx, interpType,\n+                sx1, sy1, sx2, sy2, bgColor);\n+    }\n+\n+    @Override\n+    public void transformImage(SunGraphics2D sg, BufferedImage img,\n+                               BufferedImageOp op, int x, int y)\n+    {\n+        if (op != null) {\n+            if (op instanceof AffineTransformOp) {\n+                AffineTransformOp atop = (AffineTransformOp) op;\n+                transformImage(sg, img, x, y,\n+                        atop.getTransform(),\n+                        atop.getInterpolationType());\n+                return;\n+            } else {\n+                if (MTLBufImgOps.renderImageWithOp(sg, img, op, x, y)) {\n+                    return;\n+                }\n+            }\n+            img = op.filter(img, null);\n+        }\n+        copyImage(sg, img, x, y, null);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLDrawImage.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.awt.CGraphicsConfig;\n+import sun.awt.CGraphicsDevice;\n+import sun.awt.image.OffScreenImage;\n+import sun.awt.image.SunVolatileImage;\n+import sun.awt.image.SurfaceManager;\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n+import sun.java2d.Surface;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.pipe.hw.AccelGraphicsConfig;\n+import sun.java2d.pipe.hw.AccelSurface;\n+import sun.java2d.pipe.hw.AccelTypedVolatileImage;\n+import sun.java2d.pipe.hw.ContextCapabilities;\n+import sun.lwawt.LWComponentPeer;\n+import sun.lwawt.macosx.CFRetainedResource;\n+\n+import java.awt.AWTException;\n+import java.awt.BufferCapabilities;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.ImageCapabilities;\n+import java.awt.Rectangle;\n+import java.awt.Transparency;\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.VolatileImage;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+import static sun.java2d.metal.MTLContext.MTLContextCaps.CAPS_EXT_GRAD_SHADER;\n+import static sun.java2d.pipe.hw.AccelSurface.TEXTURE;\n+import static sun.java2d.pipe.hw.AccelSurface.RT_TEXTURE;\n+import static sun.java2d.pipe.hw.ContextCapabilities.*;\n+\n+import static sun.java2d.metal.MTLContext.MTLContextCaps.CAPS_EXT_BIOP_SHADER;\n+\n+public final class MTLGraphicsConfig extends CGraphicsConfig\n+        implements AccelGraphicsConfig, SurfaceManager.ProxiedGraphicsConfig\n+{\n+    private static boolean mtlAvailable;\n+    private static ImageCapabilities imageCaps = new MTLImageCaps();\n+\n+    private static final String mtlShadersLib = AccessController.doPrivileged(\n+            (PrivilegedAction<String>) () ->\n+                    System.getProperty(\"java.home\", \"\") + File.separator +\n+                            \"lib\" + File.separator + \"shaders.metallib\");\n+\n+\n+    private BufferCapabilities bufferCaps;\n+    private long pConfigInfo;\n+    private ContextCapabilities mtlCaps;\n+    private final MTLContext context;\n+    private final Object disposerReferent = new Object();\n+    private final int maxTextureSize;\n+\n+    private static native boolean isMetalFrameworkAvailable();\n+    private static native boolean tryLoadMetalLibrary(int displayID, String shaderLib);\n+    private static native long getMTLConfigInfo(int displayID, String mtlShadersLib);\n+\n+    \/**\n+     * Returns maximum texture size supported by Metal. Must be\n+     * called under MTLRQ lock.\n+     *\/\n+    private static native int nativeGetMaxTextureSize();\n+\n+    static {\n+        mtlAvailable = isMetalFrameworkAvailable();\n+    }\n+\n+    private MTLGraphicsConfig(CGraphicsDevice device,\n+                              long configInfo, int maxTextureSize,\n+                              ContextCapabilities mtlCaps) {\n+        super(device);\n+\n+        this.pConfigInfo = configInfo;\n+        this.mtlCaps = mtlCaps;\n+        this.maxTextureSize = maxTextureSize;\n+        context = new MTLContext(MTLRenderQueue.getInstance());\n+        \/\/ add a record to the Disposer so that we destroy the native\n+        \/\/ MTLGraphicsConfigInfo data when this object goes away\n+        Disposer.addRecord(disposerReferent,\n+                new MTLGCDisposerRecord(pConfigInfo));\n+    }\n+\n+    @Override\n+    public Object getProxyKey() {\n+        return this;\n+    }\n+\n+    public SurfaceData createManagedSurface(int w, int h, int transparency) {\n+        return MTLSurfaceData.createData(this, w, h,\n+                getColorModel(transparency),\n+                null,\n+                MTLSurfaceData.TEXTURE);\n+    }\n+\n+    public static MTLGraphicsConfig getConfig(CGraphicsDevice device,\n+                                              int displayID)\n+    {\n+        if (!mtlAvailable) {\n+            return null;\n+        }\n+\n+        if (!tryLoadMetalLibrary(displayID, mtlShadersLib)) {\n+            return null;\n+        }\n+\n+        long cfginfo = 0;\n+        int textureSize = 0;\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ getMTLConfigInfo() creates and destroys temporary\n+            \/\/ surfaces\/contexts, so we should first invalidate the current\n+            \/\/ Java-level context and flush the queue...\n+            MTLContext.invalidateCurrentContext();\n+            cfginfo = getMTLConfigInfo(displayID, mtlShadersLib);\n+            if (cfginfo != 0L) {\n+                textureSize = nativeGetMaxTextureSize();\n+                \/\/ TODO : This clamping code is same as in OpenGL.\n+                \/\/ Whether we need such clamping or not in case of Metal\n+                \/\/ will be pursued under 8260644\n+                textureSize = textureSize <= 16384 ? textureSize \/ 2 : 8192;\n+                MTLContext.setScratchSurface(cfginfo);\n+            }\n+        } finally {\n+            rq.unlock();\n+        }\n+        if (cfginfo == 0) {\n+            return null;\n+        }\n+\n+        ContextCapabilities caps = new MTLContext.MTLContextCaps(\n+                CAPS_PS30 | CAPS_PS20 |\n+                        CAPS_RT_TEXTURE_ALPHA | CAPS_RT_TEXTURE_OPAQUE |\n+                        CAPS_MULTITEXTURE | CAPS_TEXNONPOW2 | CAPS_TEXNONSQUARE |\n+                        CAPS_EXT_BIOP_SHADER | CAPS_EXT_GRAD_SHADER,\n+                null);\n+        return new MTLGraphicsConfig(device, cfginfo, textureSize, caps);\n+    }\n+\n+    public static boolean isMetalAvailable() {\n+        return mtlAvailable;\n+    }\n+\n+    \/**\n+     * Returns true if the provided capability bit is present for this config.\n+     * See MTLContext.java for a list of supported capabilities.\n+     *\/\n+    public boolean isCapPresent(int cap) {\n+        return ((mtlCaps.getCaps() & cap) != 0);\n+    }\n+\n+    public long getNativeConfigInfo() {\n+        return pConfigInfo;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see sun.java2d.pipe.hw.BufferedContextProvider#getContext\n+     *\/\n+    @Override\n+    public MTLContext getContext() {\n+        return context;\n+    }\n+\n+    @Override\n+    public BufferedImage createCompatibleImage(int width, int height) {\n+        ColorModel model = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);\n+        WritableRaster\n+                raster = model.createCompatibleWritableRaster(width, height);\n+        return new BufferedImage(model, raster, model.isAlphaPremultiplied(),\n+                null);\n+    }\n+\n+    @Override\n+    public ColorModel getColorModel(int transparency) {\n+        switch (transparency) {\n+            case Transparency.OPAQUE:\n+                \/\/ REMIND: once the ColorModel spec is changed, this should be\n+                \/\/         an opaque premultiplied DCM...\n+                return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);\n+            case Transparency.BITMASK:\n+                return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);\n+            case Transparency.TRANSLUCENT:\n+                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+                return new DirectColorModel(cs, 32,\n+                        0xff0000, 0xff00, 0xff, 0xff000000,\n+                        true, DataBuffer.TYPE_INT);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    public boolean isDoubleBuffered() {\n+        return true;\n+    }\n+\n+    private static class MTLGCDisposerRecord implements DisposerRecord {\n+        private long pCfgInfo;\n+        public MTLGCDisposerRecord(long pCfgInfo) {\n+            this.pCfgInfo = pCfgInfo;\n+        }\n+        public void dispose() {\n+            if (pCfgInfo != 0) {\n+                MTLRenderQueue.disposeGraphicsConfig(pCfgInfo);\n+                pCfgInfo = 0;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return (\"MTLGraphicsConfig[\" + getDevice().getIDstring() + \"]\");\n+    }\n+\n+    @Override\n+    public SurfaceData createSurfaceData(CFRetainedResource layer) {\n+        return MTLSurfaceData.createData((MTLLayer) layer);\n+    }\n+\n+    @Override\n+    public Image createAcceleratedImage(Component target,\n+                                        int width, int height)\n+    {\n+        ColorModel model = getColorModel(Transparency.OPAQUE);\n+        WritableRaster wr = model.createCompatibleWritableRaster(width, height);\n+        return new OffScreenImage(target, model, wr,\n+                model.isAlphaPremultiplied());\n+    }\n+\n+    @Override\n+    public void assertOperationSupported(final int numBuffers,\n+                                         final BufferCapabilities caps)\n+            throws AWTException {\n+        \/\/ Assume this method is never called with numBuffers != 2, as 0 is\n+        \/\/ unsupported, and 1 corresponds to a SingleBufferStrategy which\n+        \/\/ doesn't depend on the peer. Screen is considered as a separate\n+        \/\/ \"buffer\".\n+        if (numBuffers != 2) {\n+            throw new AWTException(\"Only double buffering is supported\");\n+        }\n+        final BufferCapabilities configCaps = getBufferCapabilities();\n+        if (!configCaps.isPageFlipping()) {\n+            throw new AWTException(\"Page flipping is not supported\");\n+        }\n+        if (caps.getFlipContents() == BufferCapabilities.FlipContents.PRIOR) {\n+            throw new AWTException(\"FlipContents.PRIOR is not supported\");\n+        }\n+    }\n+\n+    @Override\n+    public Image createBackBuffer(final LWComponentPeer<?, ?> peer) {\n+        final Rectangle r = peer.getBounds();\n+        \/\/ It is possible for the component to have size 0x0, adjust it to\n+        \/\/ be at least 1x1 to avoid IAE\n+        final int w = Math.max(1, r.width);\n+        final int h = Math.max(1, r.height);\n+        final int transparency = peer.isTranslucent() ? Transparency.TRANSLUCENT\n+                : Transparency.OPAQUE;\n+        return new SunVolatileImage(this, w, h, transparency, null);\n+    }\n+\n+    @Override\n+    public void destroyBackBuffer(final Image backBuffer) {\n+        if (backBuffer != null) {\n+            backBuffer.flush();\n+        }\n+    }\n+\n+    @Override\n+    public void flip(final LWComponentPeer<?, ?> peer, final Image backBuffer,\n+                     final int x1, final int y1, final int x2, final int y2,\n+                     final BufferCapabilities.FlipContents flipAction) {\n+        final Graphics g = peer.getGraphics();\n+        try {\n+            g.drawImage(backBuffer, x1, y1, x2, y2, x1, y1, x2, y2, null);\n+        } finally {\n+            g.dispose();\n+        }\n+        if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {\n+            final Graphics2D bg = (Graphics2D) backBuffer.getGraphics();\n+            try {\n+                bg.setBackground(peer.getBackground());\n+                bg.clearRect(0, 0, backBuffer.getWidth(null),\n+                        backBuffer.getHeight(null));\n+            } finally {\n+                bg.dispose();\n+            }\n+        }\n+    }\n+\n+    private static class MTLBufferCaps extends BufferCapabilities {\n+        public MTLBufferCaps(boolean dblBuf) {\n+            super(imageCaps, imageCaps,\n+                    dblBuf ? FlipContents.UNDEFINED : null);\n+        }\n+    }\n+\n+    @Override\n+    public BufferCapabilities getBufferCapabilities() {\n+        if (bufferCaps == null) {\n+            bufferCaps = new MTLBufferCaps(isDoubleBuffered());\n+        }\n+        return bufferCaps;\n+    }\n+\n+    private static class MTLImageCaps extends ImageCapabilities {\n+        private MTLImageCaps() {\n+            super(true);\n+        }\n+        public boolean isTrueVolatile() {\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public ImageCapabilities getImageCapabilities() {\n+        return imageCaps;\n+    }\n+\n+    @Override\n+    public VolatileImage createCompatibleVolatileImage(int width, int height,\n+                                                       int transparency,\n+                                                       int type) {\n+        if ((type != RT_TEXTURE && type != TEXTURE) ||\n+            transparency == Transparency.BITMASK) {\n+            return null;\n+        }\n+\n+        SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,\n+                transparency, type);\n+        Surface sd = vi.getDestSurface();\n+        if (!(sd instanceof AccelSurface) ||\n+                ((AccelSurface)sd).getType() != type)\n+        {\n+            vi.flush();\n+            vi = null;\n+        }\n+\n+        return vi;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#getContextCapabilities\n+     *\/\n+    @Override\n+    public ContextCapabilities getContextCapabilities() {\n+        return mtlCaps;\n+    }\n+\n+    @Override\n+    public int getMaxTextureWidth() {\n+        return Math.max(maxTextureSize \/ getDevice().getScaleFactor(),\n+                getBounds().width);\n+    }\n+\n+    @Override\n+    public int getMaxTextureHeight() {\n+        return Math.max(maxTextureSize \/ getDevice().getScaleFactor(),\n+                getBounds().height);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.NullSurfaceData;\n+import sun.java2d.SurfaceData;\n+import sun.lwawt.LWWindowPeer;\n+import sun.lwawt.macosx.CFRetainedResource;\n+\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.Transparency;\n+\n+public class MTLLayer extends CFRetainedResource {\n+\n+    private native long nativeCreateLayer();\n+    private static native void nativeSetScale(long layerPtr, double scale);\n+\n+    \/\/ Pass the insets to native code to make adjustments in blitTexture\n+    private static native void nativeSetInsets(long layerPtr, int top, int left);\n+    private static native void validate(long layerPtr, MTLSurfaceData cglsd);\n+    private static native void blitTexture(long layerPtr);\n+\n+    private LWWindowPeer peer;\n+    private int scale = 1;\n+\n+    private SurfaceData surfaceData; \/\/ represents intermediate buffer (texture)\n+\n+    public MTLLayer(LWWindowPeer peer) {\n+        super(0, true);\n+\n+        setPtr(nativeCreateLayer());\n+        this.peer = peer;\n+    }\n+\n+    public long getPointer() {\n+        return ptr;\n+    }\n+\n+    public Rectangle getBounds() {\n+        return peer.getBounds();\n+    }\n+\n+    public GraphicsConfiguration getGraphicsConfiguration() {\n+        return peer.getGraphicsConfiguration();\n+    }\n+\n+    public boolean isOpaque() {\n+        return !peer.isTranslucent();\n+    }\n+\n+    public int getTransparency() {\n+        return isOpaque() ? Transparency.OPAQUE : Transparency.TRANSLUCENT;\n+    }\n+\n+    public Object getDestination() {\n+        return peer.getTarget();\n+    }\n+\n+    public SurfaceData replaceSurfaceData() {\n+        if (getBounds().isEmpty()) {\n+            surfaceData = NullSurfaceData.theInstance;\n+            return surfaceData;\n+        }\n+\n+        \/\/ the layer redirects all painting to the buffer's graphics\n+        \/\/ and blits the buffer to the layer surface (in display callback)\n+        MTLGraphicsConfig gc = (MTLGraphicsConfig)getGraphicsConfiguration();\n+        surfaceData = gc.createSurfaceData(this);\n+        setScale(gc.getDevice().getScaleFactor());\n+        Insets insets = peer.getInsets();\n+        execute(ptr -> nativeSetInsets(ptr, insets.top, insets.left));\n+        \/\/ the layer holds a reference to the buffer, which in\n+        \/\/ turn has a reference back to this layer\n+        if (surfaceData instanceof MTLSurfaceData) {\n+            validate((MTLSurfaceData)surfaceData);\n+        }\n+\n+        return surfaceData;\n+    }\n+\n+    public SurfaceData getSurfaceData() {\n+        return surfaceData;\n+    }\n+\n+    public void validate(final MTLSurfaceData cglsd) {\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            execute(ptr -> validate(ptr, cglsd));\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        \/\/ break the connection between the layer and the buffer\n+        validate(null);\n+        SurfaceData oldData = surfaceData;\n+        surfaceData = NullSurfaceData.theInstance;;\n+        if (oldData != null) {\n+            oldData.flush();\n+        }\n+        super.dispose();\n+    }\n+\n+    private void setScale(final int _scale) {\n+        if (scale != _scale) {\n+            scale = _scale;\n+            execute(ptr -> nativeSetScale(ptr, scale));\n+        }\n+    }\n+\n+    \/\/ ----------------------------------------------------------------------\n+    \/\/ NATIVE CALLBACKS\n+    \/\/ ----------------------------------------------------------------------\n+\n+    private void drawInMTLContext() {\n+        \/\/ tell the flusher thread not to update the intermediate buffer\n+        \/\/ until we are done blitting from it\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            execute(ptr -> blitTexture(ptr));\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLLayer.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.loops.GraphicsPrimitiveMgr;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.pipe.BufferedMaskBlit;\n+import sun.java2d.pipe.Region;\n+\n+import java.awt.Composite;\n+\n+import static sun.java2d.loops.CompositeType.SrcNoEa;\n+import static sun.java2d.loops.CompositeType.SrcOver;\n+import static sun.java2d.loops.SurfaceType.*;\n+\n+class MTLMaskBlit extends BufferedMaskBlit {\n+\n+    static void register() {\n+        GraphicsPrimitive[] primitives = {\n+                new MTLMaskBlit(IntArgb,    SrcOver),\n+                new MTLMaskBlit(IntArgbPre, SrcOver),\n+                new MTLMaskBlit(IntRgb,     SrcOver),\n+                new MTLMaskBlit(IntRgb,     SrcNoEa),\n+                new MTLMaskBlit(IntBgr,     SrcOver),\n+                new MTLMaskBlit(IntBgr,     SrcNoEa),\n+        };\n+        GraphicsPrimitiveMgr.register(primitives);\n+    }\n+\n+    private MTLMaskBlit(SurfaceType srcType,\n+                        CompositeType compType)\n+    {\n+        super(MTLRenderQueue.getInstance(),\n+                srcType, compType, MTLSurfaceData.MTLSurface);\n+    }\n+\n+    @Override\n+    protected void validateContext(SurfaceData dstData,\n+                                   Composite comp, Region clip)\n+    {\n+        MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n+        MTLContext.validateContext(mtlDst, mtlDst,\n+                clip, comp, null, null, null,\n+                MTLContext.NO_CONTEXT_FLAGS);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLMaskBlit.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.java2d.metal;\n+\n+import sun.java2d.InvalidPipeException;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.loops.GraphicsPrimitiveMgr;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.pipe.BufferedMaskFill;\n+\n+import java.awt.Composite;\n+\n+import static sun.java2d.loops.CompositeType.SrcNoEa;\n+import static sun.java2d.loops.CompositeType.SrcOver;\n+import static sun.java2d.loops.SurfaceType.*;\n+\n+class MTLMaskFill extends BufferedMaskFill {\n+\n+    static void register() {\n+        GraphicsPrimitive[] primitives = {\n+                new MTLMaskFill(AnyColor,                  SrcOver),\n+                new MTLMaskFill(OpaqueColor,               SrcNoEa),\n+                new MTLMaskFill(GradientPaint,             SrcOver),\n+                new MTLMaskFill(OpaqueGradientPaint,       SrcNoEa),\n+                new MTLMaskFill(LinearGradientPaint,       SrcOver),\n+                new MTLMaskFill(OpaqueLinearGradientPaint, SrcNoEa),\n+                new MTLMaskFill(RadialGradientPaint,       SrcOver),\n+                new MTLMaskFill(OpaqueRadialGradientPaint, SrcNoEa),\n+                new MTLMaskFill(TexturePaint,              SrcOver),\n+                new MTLMaskFill(OpaqueTexturePaint,        SrcNoEa),\n+        };\n+        GraphicsPrimitiveMgr.register(primitives);\n+    }\n+\n+    protected MTLMaskFill(SurfaceType srcType, CompositeType compType) {\n+        super(MTLRenderQueue.getInstance(),\n+                srcType, compType, MTLSurfaceData.MTLSurface);\n+    }\n+\n+    @Override\n+    protected native void maskFill(int x, int y, int w, int h,\n+                                   int maskoff, int maskscan, int masklen,\n+                                   byte[] mask);\n+\n+    @Override\n+    protected void validateContext(SunGraphics2D sg2d,\n+                                   Composite comp, int ctxflags)\n+    {\n+        MTLSurfaceData dstData;\n+        try {\n+            dstData = (MTLSurfaceData) sg2d.surfaceData;\n+        } catch (ClassCastException e) {\n+            throw new InvalidPipeException(\"wrong surface data type: \" +\n+                    sg2d.surfaceData);\n+        }\n+\n+        MTLContext.validateContext(dstData, dstData,\n+                sg2d.getCompClip(), comp,\n+                null, sg2d.paint, sg2d, ctxflags);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLMaskFill.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.java2d.metal;\n+\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.CompositeType;\n+\n+import java.awt.LinearGradientPaint;\n+import java.awt.MultipleGradientPaint;\n+import java.awt.TexturePaint;\n+\n+import java.awt.MultipleGradientPaint.ColorSpaceType;\n+import java.awt.MultipleGradientPaint.CycleMethod;\n+import java.awt.image.BufferedImage;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static sun.java2d.metal.MTLContext.MTLContextCaps.CAPS_EXT_GRAD_SHADER;\n+import static sun.java2d.pipe.BufferedPaints.MULTI_MAX_FRACTIONS;\n+\n+abstract class MTLPaints {\n+\n+    \/**\n+     * Holds all registered implementations, using the corresponding\n+     * SunGraphics2D.PAINT_* constant as the hash key.\n+     *\/\n+    private static Map<Integer, MTLPaints> impls =\n+            new HashMap<Integer, MTLPaints>(4, 1.0f);\n+\n+    static {\n+        impls.put(SunGraphics2D.PAINT_GRADIENT, new Gradient());\n+        impls.put(SunGraphics2D.PAINT_LIN_GRADIENT, new LinearGradient());\n+        impls.put(SunGraphics2D.PAINT_RAD_GRADIENT, new RadialGradient());\n+        impls.put(SunGraphics2D.PAINT_TEXTURE, new Texture());\n+    }\n+\n+    \/**\n+     * Attempts to locate an implementation corresponding to the paint state\n+     * of the provided SunGraphics2D object.  If no implementation can be\n+     * found, or if the paint cannot be accelerated under the conditions\n+     * of the SunGraphics2D, this method returns false; otherwise, returns\n+     * true.\n+     *\/\n+    static boolean isValid(SunGraphics2D sg2d) {\n+        MTLPaints impl = impls.get(sg2d.paintState);\n+        return (impl != null && impl.isPaintValid(sg2d));\n+    }\n+\n+    \/**\n+     * Returns true if this implementation is able to accelerate the\n+     * Paint object associated with, and under the conditions of, the\n+     * provided SunGraphics2D instance; otherwise returns false.\n+     *\/\n+    abstract boolean isPaintValid(SunGraphics2D sg2d);\n+\n+    \/************************* GradientPaint support ****************************\/\n+\n+    private static class Gradient extends MTLPaints {\n+        private Gradient() {}\n+\n+        \/**\n+         * There are no restrictions for accelerating GradientPaint, so\n+         * this method always returns true.\n+         *\/\n+        @Override\n+        boolean isPaintValid(SunGraphics2D sg2d) {\n+            return true;\n+        }\n+    }\n+\n+    \/************************** TexturePaint support ****************************\/\n+\n+    private static class Texture extends MTLPaints {\n+        private Texture() {}\n+\n+        \/**\n+         * Returns true if the given TexturePaint instance can be used by the\n+         * accelerated MTLPaints.Texture implementation.  A TexturePaint is\n+         * considered valid if the following conditions are met:\n+         *   - the texture image dimensions are power-of-two\n+         *   - the texture image can be (or is already) cached in an Metal\n+         *     texture object\n+         *\/\n+        @Override\n+        boolean isPaintValid(SunGraphics2D sg2d) {\n+            TexturePaint paint = (TexturePaint)sg2d.paint;\n+            MTLSurfaceData dstData = (MTLSurfaceData)sg2d.surfaceData;\n+            BufferedImage bi = paint.getImage();\n+\n+            SurfaceData srcData =\n+                    dstData.getSourceSurfaceData(bi,\n+                            SunGraphics2D.TRANSFORM_ISIDENT,\n+                            CompositeType.SrcOver, null);\n+            if (!(srcData instanceof MTLSurfaceData)) {\n+                \/\/ REMIND: this is a hack that attempts to cache the system\n+                \/\/         memory image from the TexturePaint instance into an\n+                \/\/         Metal texture...\n+                srcData =\n+                        dstData.getSourceSurfaceData(bi,\n+                                SunGraphics2D.TRANSFORM_ISIDENT,\n+                                CompositeType.SrcOver, null);\n+                if (!(srcData instanceof MTLSurfaceData)) {\n+                    return false;\n+                }\n+            }\n+\n+            \/\/ verify that the source surface is actually a texture\n+            MTLSurfaceData mtlData = (MTLSurfaceData)srcData;\n+            if (mtlData.getType() != MTLSurfaceData.TEXTURE) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    \/****************** Shared MultipleGradientPaint support ********************\/\n+\n+    private abstract static class MultiGradient extends MTLPaints {\n+        protected MultiGradient() {}\n+\n+        \/**\n+         * Returns true if the given MultipleGradientPaint instance can be\n+         * used by the accelerated MTLPaints.MultiGradient implementation.\n+         * A MultipleGradientPaint is considered valid if the following\n+         * conditions are met:\n+         *   - the number of gradient \"stops\" is <= MAX_FRACTIONS\n+         *   - the destination has support for fragment shaders\n+         *\/\n+        @Override\n+        boolean isPaintValid(SunGraphics2D sg2d) {\n+            MultipleGradientPaint paint = (MultipleGradientPaint)sg2d.paint;\n+            \/\/ REMIND: ugh, this creates garbage; would be nicer if\n+            \/\/ we had a MultipleGradientPaint.getNumStops() method...\n+            if (paint.getFractions().length > MULTI_MAX_FRACTIONS) {\n+                return false;\n+            }\n+\n+            MTLSurfaceData dstData = (MTLSurfaceData)sg2d.surfaceData;\n+            MTLGraphicsConfig gc = dstData.getMTLGraphicsConfig();\n+            if (!gc.isCapPresent(CAPS_EXT_GRAD_SHADER)) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    \/********************** LinearGradientPaint support *************************\/\n+\n+    private static class LinearGradient extends MultiGradient {\n+        private LinearGradient() {}\n+\n+        @Override\n+        boolean isPaintValid(SunGraphics2D sg2d) {\n+            LinearGradientPaint paint = (LinearGradientPaint)sg2d.paint;\n+\n+            if (paint.getFractions().length == 2 &&\n+                    paint.getCycleMethod() != CycleMethod.REPEAT &&\n+                    paint.getColorSpace() != ColorSpaceType.LINEAR_RGB)\n+            {\n+                \/\/ we can delegate to the optimized two-color gradient\n+                \/\/ codepath, which does not require fragment shader support\n+                return true;\n+            }\n+\n+            return super.isPaintValid(sg2d);\n+        }\n+    }\n+\n+    \/********************** RadialGradientPaint support *************************\/\n+\n+    private static class RadialGradient extends MultiGradient {\n+        private RadialGradient() {}\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLPaints.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.awt.util.ThreadGroupUtils;\n+import sun.java2d.pipe.RenderBuffer;\n+import sun.java2d.pipe.RenderQueue;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+import static sun.java2d.pipe.BufferedOpCodes.DISPOSE_CONFIG;\n+import static sun.java2d.pipe.BufferedOpCodes.SYNC;\n+\n+\/**\n+ * MTL-specific implementation of RenderQueue.  This class provides a\n+ * single (daemon) thread that is responsible for periodically flushing\n+ * the queue, thus ensuring that only one thread communicates with the native\n+ * OpenGL libraries for the entire process.\n+ *\/\n+public class MTLRenderQueue extends RenderQueue {\n+\n+    private static MTLRenderQueue theInstance;\n+    private final QueueFlusher flusher;\n+\n+    private MTLRenderQueue() {\n+        \/*\n+         * The thread must be a member of a thread group\n+         * which will not get GCed before VM exit.\n+         *\/\n+        flusher = AccessController.doPrivileged((PrivilegedAction<QueueFlusher>) QueueFlusher::new);\n+    }\n+\n+    \/**\n+     * Returns the single MTLRenderQueue instance.  If it has not yet been\n+     * initialized, this method will first construct the single instance\n+     * before returning it.\n+     *\/\n+    public static synchronized MTLRenderQueue getInstance() {\n+        if (theInstance == null) {\n+            theInstance = new MTLRenderQueue();\n+        }\n+        return theInstance;\n+    }\n+\n+    \/**\n+     * Flushes the single MTLRenderQueue instance synchronously.  If an\n+     * MTLRenderQueue has not yet been instantiated, this method is a no-op.\n+     * This method is useful in the case of Toolkit.sync(), in which we want\n+     * to flush the MTL pipeline, but only if the MTL pipeline is currently\n+     * enabled.  Since this class has few external dependencies, callers need\n+     * not be concerned that calling this method will trigger initialization\n+     * of the MTL pipeline and related classes.\n+     *\/\n+    public static void sync() {\n+        if (theInstance != null) {\n+            theInstance.lock();\n+            try {\n+                theInstance.ensureCapacity(4);\n+                theInstance.getBuffer().putInt(SYNC);\n+                theInstance.flushNow();\n+            } finally {\n+                theInstance.unlock();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Disposes the native memory associated with the given native\n+     * graphics config info pointer on the single queue flushing thread.\n+     *\/\n+    public static void disposeGraphicsConfig(long pConfigInfo) {\n+        MTLRenderQueue rq = getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ make sure we make the context associated with the given\n+            \/\/ GraphicsConfig current before disposing the native resources\n+            MTLContext.setScratchSurface(pConfigInfo);\n+\n+            RenderBuffer buf = rq.getBuffer();\n+            rq.ensureCapacityAndAlignment(12, 4);\n+            buf.putInt(DISPOSE_CONFIG);\n+            buf.putLong(pConfigInfo);\n+\n+            \/\/ this call is expected to complete synchronously, so flush now\n+            rq.flushNow();\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the current thread is the MTL QueueFlusher thread.\n+     *\/\n+    public static boolean isQueueFlusherThread() {\n+        return (Thread.currentThread() == getInstance().flusher.thread);\n+    }\n+\n+\n+    @Override\n+    public void flushNow() {\n+        \/\/ assert lock.isHeldByCurrentThread();\n+        try {\n+            flusher.flushNow();\n+        } catch (Exception e) {\n+            System.err.println(\"exception in flushNow:\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void flushAndInvokeNow(Runnable r) {\n+        \/\/ assert lock.isHeldByCurrentThread();\n+        try {\n+            flusher.flushAndInvokeNow(r);\n+        } catch (Exception e) {\n+            System.err.println(\"exception in flushAndInvokeNow:\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private native void flushBuffer(long buf, int limit);\n+\n+    private void flushBuffer() {\n+        \/\/ assert lock.isHeldByCurrentThread();\n+        int limit = buf.position();\n+        if (limit > 0) {\n+            \/\/ process the queue\n+            flushBuffer(buf.getAddress(), limit);\n+        }\n+        \/\/ reset the buffer position\n+        buf.clear();\n+        \/\/ clear the set of references, since we no longer need them\n+        refSet.clear();\n+    }\n+\n+    private class QueueFlusher implements Runnable {\n+        private boolean needsFlush;\n+        private Runnable task;\n+        private Error error;\n+        private final Thread thread;\n+\n+        public QueueFlusher() {\n+            String name = \"Java2D Queue Flusher\";\n+            thread = new Thread(ThreadGroupUtils.getRootThreadGroup(),\n+                    this, name, 0, false);\n+            thread.setDaemon(true);\n+            thread.setPriority(Thread.MAX_PRIORITY);\n+            thread.start();\n+        }\n+\n+        public synchronized void flushNow() {\n+            \/\/ wake up the flusher\n+            needsFlush = true;\n+            notify();\n+\n+            \/\/ wait for flush to complete\n+            while (needsFlush) {\n+                try {\n+                    wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            \/\/ re-throw any error that may have occurred during the flush\n+            if (error != null) {\n+                throw error;\n+            }\n+        }\n+\n+        public synchronized void flushAndInvokeNow(Runnable task) {\n+            this.task = task;\n+            flushNow();\n+        }\n+\n+        public synchronized void run() {\n+            boolean timedOut = false;\n+            while (true) {\n+                while (!needsFlush) {\n+                    try {\n+                        timedOut = false;\n+                        \/*\n+                         * Wait until we're woken up with a flushNow() call,\n+                         * or the timeout period elapses (so that we can\n+                         * flush the queue periodically).\n+                         *\/\n+                        wait(100);\n+                        \/*\n+                         * We will automatically flush the queue if the\n+                         * following conditions apply:\n+                         *   - the wait() timed out\n+                         *   - we can lock the queue (without blocking)\n+                         *   - there is something in the queue to flush\n+                         * Otherwise, just continue (we'll flush eventually).\n+                         *\/\n+                        if (!needsFlush && (timedOut = tryLock())) {\n+                            if (buf.position() > 0) {\n+                                needsFlush = true;\n+                            } else {\n+                                unlock();\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                    }\n+                }\n+                try {\n+                    \/\/ reset the throwable state\n+                    error = null;\n+                    \/\/ flush the buffer now\n+                    flushBuffer();\n+                    \/\/ if there's a task, invoke that now as well\n+                    if (task != null) {\n+                        task.run();\n+                    }\n+                } catch (Error e) {\n+                    error = e;\n+                } catch (Exception x) {\n+                    System.err.println(\"exception in QueueFlusher:\");\n+                    x.printStackTrace();\n+                } finally {\n+                    if (timedOut) {\n+                        unlock();\n+                    }\n+                    task = null;\n+                    \/\/ allow the waiting thread to continue\n+                    needsFlush = false;\n+                    notify();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLRenderQueue.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.java2d.metal;\n+\n+import sun.java2d.InvalidPipeException;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.pipe.BufferedRenderPipe;\n+import sun.java2d.pipe.ParallelogramPipe;\n+import sun.java2d.pipe.RenderQueue;\n+import sun.java2d.pipe.SpanIterator;\n+\n+import java.awt.Transparency;\n+import java.awt.geom.Path2D;\n+\n+import static sun.java2d.pipe.BufferedOpCodes.COPY_AREA;\n+\n+class MTLRenderer extends BufferedRenderPipe {\n+\n+    MTLRenderer(RenderQueue rq) {\n+        super(rq);\n+    }\n+\n+    @Override\n+    protected void validateContext(SunGraphics2D sg2d) {\n+        int ctxflags =\n+                sg2d.paint.getTransparency() == Transparency.OPAQUE ?\n+                        MTLContext.SRC_IS_OPAQUE : MTLContext.NO_CONTEXT_FLAGS;\n+        MTLSurfaceData dstData;\n+        try {\n+            dstData = (MTLSurfaceData)sg2d.surfaceData;\n+        } catch (ClassCastException e) {\n+            throw new InvalidPipeException(\"wrong surface data type: \" + sg2d.surfaceData);\n+        }\n+        MTLContext.validateContext(dstData, dstData,\n+                sg2d.getCompClip(), sg2d.composite,\n+                null, sg2d.paint, sg2d, ctxflags);\n+    }\n+\n+    @Override\n+    protected void validateContextAA(SunGraphics2D sg2d) {\n+        int ctxflags = MTLContext.NO_CONTEXT_FLAGS;\n+        MTLSurfaceData dstData;\n+        try {\n+            dstData = (MTLSurfaceData)sg2d.surfaceData;\n+        } catch (ClassCastException e) {\n+            throw new InvalidPipeException(\"wrong surface data type: \" + sg2d.surfaceData);\n+        }\n+        MTLContext.validateContext(dstData, dstData,\n+                sg2d.getCompClip(), sg2d.composite,\n+                null, sg2d.paint, sg2d, ctxflags);\n+    }\n+\n+    void copyArea(SunGraphics2D sg2d,\n+                  int x, int y, int w, int h, int dx, int dy)\n+    {\n+        rq.lock();\n+        try {\n+            int ctxflags =\n+                    sg2d.surfaceData.getTransparency() == Transparency.OPAQUE ?\n+                            MTLContext.SRC_IS_OPAQUE : MTLContext.NO_CONTEXT_FLAGS;\n+            MTLSurfaceData dstData;\n+            try {\n+                dstData = (MTLSurfaceData)sg2d.surfaceData;\n+            } catch (ClassCastException e) {\n+                throw new InvalidPipeException(\"wrong surface data type: \" + sg2d.surfaceData);\n+            }\n+            MTLContext.validateContext(dstData, dstData,\n+                    sg2d.getCompClip(), sg2d.composite,\n+                    null, null, null, ctxflags);\n+\n+            rq.ensureCapacity(28);\n+            buf.putInt(COPY_AREA);\n+            buf.putInt(x).putInt(y).putInt(w).putInt(h);\n+            buf.putInt(dx).putInt(dy);\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    @Override\n+    protected native void drawPoly(int[] xPoints, int[] yPoints,\n+                                   int nPoints, boolean isClosed,\n+                                   int transX, int transY);\n+\n+    MTLRenderer traceWrap() {\n+        return new Tracer(this);\n+    }\n+\n+    private class Tracer extends MTLRenderer {\n+        private MTLRenderer mtlr;\n+        Tracer(MTLRenderer mtlr) {\n+            super(mtlr.rq);\n+            this.mtlr = mtlr;\n+        }\n+        public ParallelogramPipe getAAParallelogramPipe() {\n+            final ParallelogramPipe realpipe = mtlr.getAAParallelogramPipe();\n+            return new ParallelogramPipe() {\n+                public void fillParallelogram(SunGraphics2D sg2d,\n+                                              double ux1, double uy1,\n+                                              double ux2, double uy2,\n+                                              double x, double y,\n+                                              double dx1, double dy1,\n+                                              double dx2, double dy2)\n+                {\n+                    GraphicsPrimitive.tracePrimitive(\"MTLFillAAParallelogram\");\n+                    realpipe.fillParallelogram(sg2d,\n+                            ux1, uy1, ux2, uy2,\n+                            x, y, dx1, dy1, dx2, dy2);\n+                }\n+                public void drawParallelogram(SunGraphics2D sg2d,\n+                                              double ux1, double uy1,\n+                                              double ux2, double uy2,\n+                                              double x, double y,\n+                                              double dx1, double dy1,\n+                                              double dx2, double dy2,\n+                                              double lw1, double lw2)\n+                {\n+                    GraphicsPrimitive.tracePrimitive(\"MTLDrawAAParallelogram\");\n+                    realpipe.drawParallelogram(sg2d,\n+                            ux1, uy1, ux2, uy2,\n+                            x, y, dx1, dy1, dx2, dy2,\n+                            lw1, lw2);\n+                }\n+            };\n+        }\n+        protected void validateContext(SunGraphics2D sg2d) {\n+            mtlr.validateContext(sg2d);\n+        }\n+        public void drawLine(SunGraphics2D sg2d,\n+                             int x1, int y1, int x2, int y2)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawLine\");\n+            mtlr.drawLine(sg2d, x1, y1, x2, y2);\n+        }\n+        public void drawRect(SunGraphics2D sg2d, int x, int y, int w, int h) {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawRect\");\n+            mtlr.drawRect(sg2d, x, y, w, h);\n+        }\n+        protected void drawPoly(SunGraphics2D sg2d,\n+                                int[] xPoints, int[] yPoints,\n+                                int nPoints, boolean isClosed)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawPoly\");\n+            mtlr.drawPoly(sg2d, xPoints, yPoints, nPoints, isClosed);\n+        }\n+        public void fillRect(SunGraphics2D sg2d, int x, int y, int w, int h) {\n+            GraphicsPrimitive.tracePrimitive(\"MTLFillRect\");\n+            mtlr.fillRect(sg2d, x, y, w, h);\n+        }\n+        protected void drawPath(SunGraphics2D sg2d,\n+                                Path2D.Float p2df, int transx, int transy)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawPath\");\n+            mtlr.drawPath(sg2d, p2df, transx, transy);\n+        }\n+        protected void fillPath(SunGraphics2D sg2d,\n+                                Path2D.Float p2df, int transx, int transy)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLFillPath\");\n+            mtlr.fillPath(sg2d, p2df, transx, transy);\n+        }\n+        protected void fillSpans(SunGraphics2D sg2d, SpanIterator si,\n+                                 int transx, int transy)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLFillSpans\");\n+            mtlr.fillSpans(sg2d, si, transx, transy);\n+        }\n+        public void fillParallelogram(SunGraphics2D sg2d,\n+                                      double ux1, double uy1,\n+                                      double ux2, double uy2,\n+                                      double x, double y,\n+                                      double dx1, double dy1,\n+                                      double dx2, double dy2)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLFillParallelogram\");\n+            mtlr.fillParallelogram(sg2d,\n+                    ux1, uy1, ux2, uy2,\n+                    x, y, dx1, dy1, dx2, dy2);\n+        }\n+        public void drawParallelogram(SunGraphics2D sg2d,\n+                                      double ux1, double uy1,\n+                                      double ux2, double uy2,\n+                                      double x, double y,\n+                                      double dx1, double dy1,\n+                                      double dx2, double dy2,\n+                                      double lw1, double lw2)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawParallelogram\");\n+            mtlr.drawParallelogram(sg2d,\n+                    ux1, uy1, ux2, uy2,\n+                    x, y, dx1, dy1, dx2, dy2, lw1, lw2);\n+        }\n+        public void copyArea(SunGraphics2D sg2d,\n+                             int x, int y, int w, int h, int dx, int dy)\n+        {\n+            GraphicsPrimitive.tracePrimitive(\"MTLCopyArea\");\n+            mtlr.copyArea(sg2d, x, y, w, h, dx, dy);\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLRenderer.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,649 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.awt.SunHints;\n+import sun.awt.image.PixelConverter;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.SurfaceDataProxy;\n+import sun.java2d.loops.CompositeType;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.loops.MaskFill;\n+import sun.java2d.loops.SurfaceType;\n+import sun.java2d.pipe.ParallelogramPipe;\n+import sun.java2d.pipe.PixelToParallelogramConverter;\n+import sun.java2d.pipe.RenderBuffer;\n+import sun.java2d.pipe.TextPipe;\n+import sun.java2d.pipe.hw.AccelSurface;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Composite;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Transparency;\n+\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+\n+import static sun.java2d.pipe.BufferedOpCodes.DISPOSE_SURFACE;\n+import static sun.java2d.pipe.BufferedOpCodes.FLUSH_SURFACE;\n+import static sun.java2d.pipe.hw.ContextCapabilities.CAPS_MULTITEXTURE;\n+import static sun.java2d.pipe.hw.ContextCapabilities.CAPS_PS30;\n+\n+\n+public abstract class MTLSurfaceData extends SurfaceData\n+        implements AccelSurface {\n+\n+    \/**\n+     * Pixel formats\n+     *\/\n+    public static final int PF_INT_ARGB        = 0;\n+    public static final int PF_INT_ARGB_PRE    = 1;\n+    public static final int PF_INT_RGB         = 2;\n+    public static final int PF_INT_RGBX        = 3;\n+    public static final int PF_INT_BGR         = 4;\n+    public static final int PF_INT_BGRX        = 5;\n+    public static final int PF_USHORT_565_RGB  = 6;\n+    public static final int PF_USHORT_555_RGB  = 7;\n+    public static final int PF_USHORT_555_RGBX = 8;\n+    public static final int PF_BYTE_GRAY       = 9;\n+    public static final int PF_USHORT_GRAY     = 10;\n+    public static final int PF_3BYTE_BGR       = 11;\n+    \/**\n+     * SurfaceTypes\n+     *\/\n+\n+    private static final String DESC_MTL_SURFACE = \"MTL Surface\";\n+    private static final String DESC_MTL_SURFACE_RTT =\n+            \"MTL Surface (render-to-texture)\";\n+    private static final String DESC_MTL_TEXTURE = \"MTL Texture\";\n+\n+\n+    static final SurfaceType MTLSurface =\n+            SurfaceType.Any.deriveSubType(DESC_MTL_SURFACE,\n+                    PixelConverter.ArgbPre.instance);\n+    static final SurfaceType MTLSurfaceRTT =\n+            MTLSurface.deriveSubType(DESC_MTL_SURFACE_RTT);\n+    static final SurfaceType MTLTexture =\n+            SurfaceType.Any.deriveSubType(DESC_MTL_TEXTURE);\n+\n+    protected static MTLRenderer mtlRenderPipe;\n+    protected static PixelToParallelogramConverter mtlTxRenderPipe;\n+    protected static ParallelogramPipe mtlAAPgramPipe;\n+    protected static MTLTextRenderer mtlTextPipe;\n+    protected static MTLDrawImage mtlImagePipe;\n+\n+    static {\n+        if (!GraphicsEnvironment.isHeadless()) {\n+            MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+            mtlImagePipe = new MTLDrawImage();\n+            mtlTextPipe = new MTLTextRenderer(rq);\n+            mtlRenderPipe = new MTLRenderer(rq);\n+            if (GraphicsPrimitive.tracingEnabled()) {\n+                mtlTextPipe = mtlTextPipe.traceWrap();\n+                \/\/The wrapped mtlRenderPipe will wrap the AA pipe as well...\n+                \/\/mtlAAPgramPipe = mtlRenderPipe.traceWrap();\n+            }\n+            mtlAAPgramPipe = mtlRenderPipe.getAAParallelogramPipe();\n+            mtlTxRenderPipe =\n+                    new PixelToParallelogramConverter(mtlRenderPipe,\n+                            mtlRenderPipe,\n+                            1.0, 0.25, true);\n+\n+            MTLBlitLoops.register();\n+            MTLMaskFill.register();\n+            MTLMaskBlit.register();\n+        }\n+    }\n+\n+    protected final int scale;\n+    protected final int width;\n+    protected final int height;\n+    protected int type;\n+    private MTLGraphicsConfig graphicsConfig;\n+    \/\/ these fields are set from the native code when the surface is\n+    \/\/ initialized\n+    private int nativeWidth;\n+    private int nativeHeight;\n+\n+    \/**\n+     * Returns the appropriate SurfaceType corresponding to the given Metal\n+     * surface type constant (e.g. TEXTURE -> MTLTexture).\n+     *\/\n+    private static SurfaceType getCustomSurfaceType(int mtlType) {\n+        switch (mtlType) {\n+            case TEXTURE:\n+                return MTLTexture;\n+            case RT_TEXTURE:\n+                return MTLSurfaceRTT;\n+            default:\n+                return MTLSurface;\n+        }\n+    }\n+\n+    private native void initOps(MTLGraphicsConfig gc, long pConfigInfo, long pPeerData, long layerPtr,\n+                                int xoff, int yoff, boolean isOpaque);\n+\n+    private MTLSurfaceData(MTLLayer layer, MTLGraphicsConfig gc,\n+                           ColorModel cm, int type, int width, int height)\n+    {\n+        super(getCustomSurfaceType(type), cm);\n+        this.graphicsConfig = gc;\n+        this.type = type;\n+        setBlitProxyKey(gc.getProxyKey());\n+\n+        \/\/ TEXTURE shouldn't be scaled, it is used for managed BufferedImages.\n+        scale = type == TEXTURE ? 1 : gc.getDevice().getScaleFactor();\n+        this.width = width * scale;\n+        this.height = height * scale;\n+\n+        long pConfigInfo = gc.getNativeConfigInfo();\n+        long layerPtr = 0L;\n+        boolean isOpaque = true;\n+        if (layer != null) {\n+            layerPtr = layer.getPointer();\n+            isOpaque = layer.isOpaque();\n+        }\n+        initOps(gc, pConfigInfo, 0, layerPtr, 0, 0, isOpaque);\n+    }\n+\n+    @Override\n+    public GraphicsConfiguration getDeviceConfiguration() {\n+        return graphicsConfig;\n+    }\n+\n+    \/**\n+     * Creates a SurfaceData object representing the intermediate buffer\n+     * between the Java2D flusher thread and the AppKit thread.\n+     *\/\n+    public static MTLLayerSurfaceData createData(MTLLayer layer) {\n+        MTLGraphicsConfig gc = (MTLGraphicsConfig)layer.getGraphicsConfiguration();\n+        Rectangle r = layer.getBounds();\n+        return new MTLLayerSurfaceData(layer, gc, r.width, r.height);\n+    }\n+\n+    \/**\n+     * Creates a SurfaceData object representing an off-screen buffer\n+     *\/\n+    public static MTLOffScreenSurfaceData createData(MTLGraphicsConfig gc,\n+                                                     int width, int height, ColorModel cm, Image image, int type) {\n+        return new MTLOffScreenSurfaceData(gc, width, height, image, cm,\n+                type);\n+    }\n+\n+    @Override\n+    public double getDefaultScaleX() {\n+        return scale;\n+    }\n+\n+    @Override\n+    public double getDefaultScaleY() {\n+        return scale;\n+    }\n+\n+    @Override\n+    public Rectangle getBounds() {\n+        return new Rectangle(width, height);\n+    }\n+\n+    protected native void clearWindow();\n+\n+    protected native boolean initTexture(long pData, boolean isOpaque, int width, int height);\n+\n+    protected native boolean initRTexture(long pData, boolean isOpaque, int width, int height);\n+\n+    protected native boolean initFlipBackbuffer(long pData);\n+\n+    @Override\n+    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {\n+        return MTLSurfaceDataProxy.createProxy(srcData, graphicsConfig);\n+    }\n+\n+    \/**\n+     * Note: This should only be called from the QFT under the AWT lock.\n+     * This method is kept separate from the initSurface() method below just\n+     * to keep the code a bit cleaner.\n+     *\/\n+    private void initSurfaceNow(int width, int height) {\n+        boolean isOpaque = (getTransparency() == Transparency.OPAQUE);\n+        boolean success = false;\n+\n+        switch (type) {\n+            case TEXTURE:\n+                success = initTexture(getNativeOps(), isOpaque, width, height);\n+                break;\n+\n+            case RT_TEXTURE:\n+                success = initRTexture(getNativeOps(), isOpaque, width, height);\n+                break;\n+\n+            case FLIP_BACKBUFFER:\n+                success = initFlipBackbuffer(getNativeOps());\n+                break;\n+\n+            default:\n+                break;\n+        }\n+\n+        if (!success) {\n+            throw new OutOfMemoryError(\"can't create offscreen surface\");\n+        }\n+    }\n+\n+    \/**\n+     * Initializes the appropriate Metal offscreen surface based on the value\n+     * of the type parameter.  If the surface creation fails for any reason,\n+     * an OutOfMemoryError will be thrown.\n+     *\/\n+    protected void initSurface(final int width, final int height) {\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            switch (type) {\n+                case TEXTURE:\n+                case RT_TEXTURE:\n+                    \/\/ need to make sure the context is current before\n+                    \/\/ creating the texture\n+                    MTLContext.setScratchSurface(graphicsConfig);\n+                    break;\n+                default:\n+                    break;\n+            }\n+            rq.flushAndInvokeNow(new Runnable() {\n+                public void run() {\n+                    initSurfaceNow(width, height);\n+                }\n+            });\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the MTLContext for the GraphicsConfig associated with this\n+     * surface.\n+     *\/\n+    public final MTLContext getContext() {\n+        return graphicsConfig.getContext();\n+    }\n+\n+    \/**\n+     * Returns the MTLGraphicsConfig associated with this surface.\n+     *\/\n+    final MTLGraphicsConfig getMTLGraphicsConfig() {\n+        return graphicsConfig;\n+    }\n+\n+    \/**\n+     * Returns one of the surface type constants defined above.\n+     *\/\n+    public final int getType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * For now, we can only render LCD text if:\n+     *   - the fragment shader extension is available, and\n+     *   - the source color is opaque, and\n+     *   - blending is SrcOverNoEa or disabled\n+     *   - and the destination is opaque\n+     *\n+     * Eventually, we could enhance the native MTL text rendering code\n+     * and remove the above restrictions, but that would require significantly\n+     * more code just to support a few uncommon cases.\n+     *\/\n+    public boolean canRenderLCDText(SunGraphics2D sg2d) {\n+        return\n+              sg2d.surfaceData.getTransparency() == Transparency.OPAQUE &&\n+              sg2d.paintState <= SunGraphics2D.PAINT_OPAQUECOLOR &&\n+             (sg2d.compositeState <= SunGraphics2D.COMP_ISCOPY ||\n+             (sg2d.compositeState <= SunGraphics2D.COMP_ALPHA && canHandleComposite(sg2d.composite)));\n+    }\n+\n+    private boolean canHandleComposite(Composite c) {\n+        if (c instanceof AlphaComposite) {\n+            AlphaComposite ac = (AlphaComposite)c;\n+\n+            return ac.getRule() == AlphaComposite.SRC_OVER && ac.getAlpha() >= 1f;\n+        }\n+        return false;\n+    }\n+\n+    public void validatePipe(SunGraphics2D sg2d) {\n+        TextPipe textpipe;\n+        boolean validated = false;\n+\n+        \/\/ MTLTextRenderer handles both AA and non-AA text, but\n+        \/\/ only works with the following modes:\n+        \/\/ (Note: For LCD text we only enter this code path if\n+        \/\/ canRenderLCDText() has already validated that the mode is\n+        \/\/ CompositeType.SrcNoEa (opaque color), which will be subsumed\n+        \/\/ by the CompositeType.SrcNoEa (any color) test below.)\n+\n+        if (\/* CompositeType.SrcNoEa (any color) *\/\n+                (sg2d.compositeState <= SunGraphics2D.COMP_ISCOPY &&\n+                        sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR)         ||\n+\n+                        \/* CompositeType.SrcOver (any color) *\/\n+                        (sg2d.compositeState == SunGraphics2D.COMP_ALPHA   &&\n+                                sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR &&\n+                                (((AlphaComposite)sg2d.composite).getRule() ==\n+                                        AlphaComposite.SRC_OVER))                                 ||\n+\n+                        \/* CompositeType.Xor (any color) *\/\n+                        (sg2d.compositeState == SunGraphics2D.COMP_XOR &&\n+                                sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR))\n+        {\n+            textpipe = mtlTextPipe;\n+        } else {\n+            \/\/ do this to initialize textpipe correctly; we will attempt\n+            \/\/ to override the non-text pipes below\n+            super.validatePipe(sg2d);\n+            textpipe = sg2d.textpipe;\n+            validated = true;\n+        }\n+\n+        PixelToParallelogramConverter txPipe = null;\n+        MTLRenderer nonTxPipe = null;\n+\n+        if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {\n+            if (sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR) {\n+                if (sg2d.compositeState <= SunGraphics2D.COMP_XOR) {\n+                    txPipe = mtlTxRenderPipe;\n+                    nonTxPipe = mtlRenderPipe;\n+                }\n+            } else if (sg2d.compositeState <= SunGraphics2D.COMP_ALPHA) {\n+                if (MTLPaints.isValid(sg2d)) {\n+                    txPipe = mtlTxRenderPipe;\n+                    nonTxPipe = mtlRenderPipe;\n+                }\n+                \/\/ custom paints handled by super.validatePipe() below\n+            }\n+        } else {\n+            if (sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR) {\n+                if (graphicsConfig.isCapPresent(CAPS_PS30) &&\n+                        (sg2d.imageComp == CompositeType.SrcOverNoEa ||\n+                                sg2d.imageComp == CompositeType.SrcOver))\n+                {\n+                    if (!validated) {\n+                        super.validatePipe(sg2d);\n+                        validated = true;\n+                    }\n+                    PixelToParallelogramConverter aaConverter =\n+                            new PixelToParallelogramConverter(sg2d.shapepipe,\n+                                    mtlAAPgramPipe,\n+                                    1.0\/8.0, 0.499,\n+                                    false);\n+                    sg2d.drawpipe = aaConverter;\n+                    sg2d.fillpipe = aaConverter;\n+                    sg2d.shapepipe = aaConverter;\n+                } else if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {\n+                    \/\/ install the solid pipes when AA and XOR are both enabled\n+                    txPipe = mtlTxRenderPipe;\n+                    nonTxPipe = mtlRenderPipe;\n+                }\n+            }\n+            \/\/ other cases handled by super.validatePipe() below\n+        }\n+\n+        if (txPipe != null) {\n+            if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n+                sg2d.drawpipe = txPipe;\n+                sg2d.fillpipe = txPipe;\n+            } else if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {\n+                sg2d.drawpipe = txPipe;\n+                sg2d.fillpipe = nonTxPipe;\n+            } else {\n+                sg2d.drawpipe = nonTxPipe;\n+                sg2d.fillpipe = nonTxPipe;\n+            }\n+            \/\/ Note that we use the transforming pipe here because it\n+            \/\/ will examine the shape and possibly perform an optimized\n+            \/\/ operation if it can be simplified.  The simplifications\n+            \/\/ will be valid for all STROKE and TRANSFORM types.\n+            sg2d.shapepipe = txPipe;\n+        } else {\n+            if (!validated) {\n+                super.validatePipe(sg2d);\n+            }\n+        }\n+\n+        \/\/ install the text pipe based on our earlier decision\n+        sg2d.textpipe = textpipe;\n+\n+        \/\/ always override the image pipe with the specialized MTL pipe\n+        sg2d.imagepipe = mtlImagePipe;\n+    }\n+\n+    @Override\n+    protected MaskFill getMaskFill(SunGraphics2D sg2d) {\n+        if (sg2d.paintState > SunGraphics2D.PAINT_ALPHACOLOR) {\n+            \/*\n+             * We can only accelerate non-Color MaskFill operations if\n+             * all of the following conditions hold true:\n+             *   - there is an implementation for the given paintState\n+             *   - the current Paint can be accelerated for this destination\n+             *   - multitexturing is available (since we need to modulate\n+             *     the alpha mask texture with the paint texture)\n+             *\n+             * In all other cases, we return null, in which case the\n+             * validation code will choose a more general software-based loop.\n+             *\/\n+            if (!MTLPaints.isValid(sg2d) ||\n+                    !graphicsConfig.isCapPresent(CAPS_MULTITEXTURE))\n+            {\n+                return null;\n+            }\n+        }\n+        return super.getMaskFill(sg2d);\n+    }\n+\n+    public void flush() {\n+        invalidate();\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ make sure we have a current context before\n+            \/\/ disposing the native resources (e.g. texture object)\n+            MTLContext.setScratchSurface(graphicsConfig);\n+\n+            RenderBuffer buf = rq.getBuffer();\n+            rq.ensureCapacityAndAlignment(12, 4);\n+            buf.putInt(FLUSH_SURFACE);\n+            buf.putLong(getNativeOps());\n+\n+            \/\/ this call is expected to complete synchronously, so flush now\n+            rq.flushNow();\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    public boolean isOnScreen() {\n+        return false;\n+    }\n+\n+    private native long getMTLTexturePointer(long pData);\n+\n+    \/**\n+     * Returns native resource of specified {@code resType} associated with\n+     * this surface.\n+     *\n+     * Specifically, for {@code MTLSurfaceData} this method returns the\n+     * the following:\n+     * <pre>\n+     * TEXTURE              - texture id\n+     * <\/pre>\n+     *\n+     * Note: the resource returned by this method is only valid on the rendering\n+     * thread.\n+     *\n+     * @return native resource of specified type or 0L if\n+     * such resource doesn't exist or can not be retrieved.\n+     * @see AccelSurface#getNativeResource\n+     *\/\n+    public long getNativeResource(int resType) {\n+        if (resType == TEXTURE) {\n+            return getMTLTexturePointer(getNativeOps());\n+        }\n+        return 0L;\n+    }\n+\n+    public Raster getRaster(int x, int y, int w, int h) {\n+        throw new InternalError(\"not implemented yet\");\n+    }\n+\n+    @Override\n+    public boolean copyArea(SunGraphics2D sg2d, int x, int y, int w, int h,\n+                            int dx, int dy) {\n+        if (sg2d.compositeState >= SunGraphics2D.COMP_XOR) {\n+            return false;\n+        }\n+        mtlRenderPipe.copyArea(sg2d, x, y, w, h, dx, dy);\n+        return true;\n+    }\n+\n+    public Rectangle getNativeBounds() {\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            return new Rectangle(nativeWidth, nativeHeight);\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * A surface which implements an intermediate buffer between\n+     * the Java2D flusher thread and the AppKit thread.\n+     *\n+     * This surface serves as a buffer attached to a MTLLayer and\n+     * the layer redirects all painting to the buffer's graphics.\n+     *\/\n+    public static class MTLLayerSurfaceData extends MTLSurfaceData {\n+\n+        private final MTLLayer layer;\n+\n+        private MTLLayerSurfaceData(MTLLayer layer, MTLGraphicsConfig gc,\n+                                   int width, int height) {\n+            super(layer, gc, gc.getColorModel(), RT_TEXTURE, width, height);\n+            this.layer = layer;\n+            initSurface(this.width, this.height);\n+        }\n+\n+        @Override\n+        public SurfaceData getReplacement() {\n+            return layer.getSurfaceData();\n+        }\n+\n+        @Override\n+        public boolean isOnScreen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Object getDestination() {\n+            return layer.getDestination();\n+        }\n+\n+        @Override\n+        public int getTransparency() {\n+            return layer.getTransparency();\n+        }\n+\n+        @Override\n+        public void invalidate() {\n+            super.invalidate();\n+            clearWindow();\n+        }\n+    }\n+\n+    \/**\n+     * SurfaceData object representing an off-screen buffer\n+     *\/\n+    public static class MTLOffScreenSurfaceData extends MTLSurfaceData {\n+        private final Image offscreenImage;\n+\n+        public MTLOffScreenSurfaceData(MTLGraphicsConfig gc, int width,\n+                                       int height, Image image,\n+                                       ColorModel cm, int type) {\n+            super(null, gc, cm, type, width, height);\n+            offscreenImage = image;\n+            initSurface(this.width, this.height);\n+        }\n+\n+        @Override\n+        public SurfaceData getReplacement() {\n+            return restoreContents(offscreenImage);\n+        }\n+\n+        \/**\n+         * Returns destination Image associated with this SurfaceData.\n+         *\/\n+        @Override\n+        public Object getDestination() {\n+            return offscreenImage;\n+        }\n+    }\n+\n+\n+    \/\/ additional cleanup\n+    private static native void destroyCGLContext(long ctx);\n+\n+    public static void destroyOGLContext(long ctx) {\n+        if (ctx != 0L) {\n+            destroyCGLContext(ctx);\n+        }\n+    }\n+\n+    \/**\n+     * Disposes the native resources associated with the given MTLSurfaceData\n+     * (referenced by the pData parameter).  This method is invoked from\n+     * the native Dispose() method from the Disposer thread when the\n+     * Java-level MTLSurfaceData object is about to go away.\n+     *\/\n+     public static void dispose(long pData, MTLGraphicsConfig gc) {\n+        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n+        rq.lock();\n+        try {\n+            \/\/ make sure we have a current context before\n+            \/\/ disposing the native resources (e.g. texture object)\n+            MTLContext.setScratchSurface(gc);\n+            RenderBuffer buf = rq.getBuffer();\n+            rq.ensureCapacityAndAlignment(12, 4);\n+            buf.putInt(DISPOSE_SURFACE);\n+            buf.putLong(pData);\n+\n+            \/\/ this call is expected to complete synchronously, so flush now\n+            rq.flushNow();\n+        } finally {\n+            rq.unlock();\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceData.java","additions":649,"deletions":0,"binary":false,"changes":649,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.java2d.SurfaceData;\n+import sun.java2d.SurfaceDataProxy;\n+import sun.java2d.loops.CompositeType;\n+\n+import java.awt.Color;\n+import java.awt.Transparency;\n+\n+\/**\n+ * The proxy class contains the logic for when to replace a\n+ * SurfaceData with a cached MTL Texture and the code to create\n+ * the accelerated surfaces.\n+ *\/\n+public class MTLSurfaceDataProxy extends SurfaceDataProxy {\n+    public static SurfaceDataProxy createProxy(SurfaceData srcData,\n+                                               MTLGraphicsConfig dstConfig)\n+    {\n+        if (srcData instanceof MTLSurfaceData) {\n+            \/\/ srcData must be a VolatileImage which either matches\n+            \/\/ our pixel format or not - either way we do not cache it...\n+            return UNCACHED;\n+        }\n+\n+        return new MTLSurfaceDataProxy(dstConfig, srcData.getTransparency());\n+    }\n+\n+    MTLGraphicsConfig oglgc;\n+    int transparency;\n+\n+    public MTLSurfaceDataProxy(MTLGraphicsConfig oglgc, int transparency) {\n+        this.oglgc = oglgc;\n+        this.transparency = transparency;\n+    }\n+\n+    @Override\n+    public SurfaceData validateSurfaceData(SurfaceData srcData,\n+                                           SurfaceData cachedData,\n+                                           int w, int h)\n+    {\n+        if (cachedData == null) {\n+            try {\n+                cachedData = oglgc.createManagedSurface(w, h, transparency);\n+            } catch (OutOfMemoryError er) {\n+                return null;\n+            }\n+        }\n+        return cachedData;\n+    }\n+\n+    @Override\n+    public boolean isSupportedOperation(SurfaceData srcData,\n+                                        int txtype,\n+                                        CompositeType comp,\n+                                        Color bgColor)\n+    {\n+        return comp.isDerivedFrom(CompositeType.AnyAlpha) &&\n+                (bgColor == null || transparency == Transparency.OPAQUE);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceDataProxy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.font.GlyphList;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.loops.GraphicsPrimitive;\n+import sun.java2d.pipe.BufferedTextPipe;\n+import sun.java2d.pipe.RenderQueue;\n+\n+import java.awt.Composite;\n+\n+class MTLTextRenderer extends BufferedTextPipe {\n+\n+    MTLTextRenderer(RenderQueue rq) {\n+        super(rq);\n+    }\n+\n+    @Override\n+    protected native void drawGlyphList(int numGlyphs, boolean usePositions,\n+                                        boolean subPixPos, boolean rgbOrder,\n+                                        int lcdContrast,\n+                                        float glOrigX, float glOrigY,\n+                                        long[] images, float[] positions);\n+\n+    @Override\n+    protected void validateContext(SunGraphics2D sg2d, Composite comp) {\n+        \/\/ assert rq.lock.isHeldByCurrentThread();\n+        MTLSurfaceData mtlDst = (MTLSurfaceData)sg2d.surfaceData;\n+        MTLContext.validateContext(mtlDst, mtlDst,\n+                sg2d.getCompClip(), comp,\n+                null, sg2d.paint, sg2d,\n+                MTLContext.NO_CONTEXT_FLAGS);\n+    }\n+\n+    MTLTextRenderer traceWrap() {\n+        return new Tracer(this);\n+    }\n+\n+    private static class Tracer extends MTLTextRenderer {\n+        Tracer(MTLTextRenderer mtltr) {\n+            super(mtltr.rq);\n+        }\n+        protected void drawGlyphList(SunGraphics2D sg2d, GlyphList gl) {\n+            GraphicsPrimitive.tracePrimitive(\"MTLDrawGlyphs\");\n+            super.drawGlyphList(sg2d, gl);\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLTextRenderer.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.metal;\n+\n+import sun.awt.image.SunVolatileImage;\n+import sun.awt.image.VolatileSurfaceManager;\n+import sun.java2d.SurfaceData;\n+\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Transparency;\n+import java.awt.image.ColorModel;\n+import sun.java2d.pipe.hw.AccelSurface;\n+\n+public class MTLVolatileSurfaceManager extends VolatileSurfaceManager {\n+\n+    private final boolean accelerationEnabled;\n+\n+    public MTLVolatileSurfaceManager(SunVolatileImage vImg, Object context) {\n+        super(vImg, context);\n+\n+        \/*\n+         * We will attempt to accelerate this image only\n+         * if the image is not bitmask\n+         *\/\n+        int transparency = vImg.getTransparency();\n+        accelerationEnabled = transparency != Transparency.BITMASK;\n+    }\n+\n+    protected boolean isAccelerationEnabled() {\n+        return accelerationEnabled;\n+    }\n+\n+    \/**\n+     * Create a SurfaceData object (or init the backbuffer\n+     * of an existing window if this is a double buffered GraphicsConfig)\n+     *\/\n+    protected SurfaceData initAcceleratedSurface() {\n+        try {\n+            MTLGraphicsConfig gc =\n+                (MTLGraphicsConfig)vImg.getGraphicsConfig();\n+            ColorModel cm = gc.getColorModel(vImg.getTransparency());\n+            int type = vImg.getForcedAccelSurfaceType();\n+            \/\/ if acceleration type is forced (type != UNDEFINED) then\n+            \/\/ use the forced type, otherwise choose RT_TEXTURE\n+            if (type == AccelSurface.UNDEFINED) {\n+                type = AccelSurface.RT_TEXTURE;\n+            }\n+            return MTLSurfaceData.createData(gc,\n+                                             vImg.getWidth(),\n+                                             vImg.getHeight(),\n+                                             cm, vImg, type);\n+        } catch (NullPointerException | OutOfMemoryError ignored) {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    protected boolean isConfigValid(GraphicsConfiguration gc) {\n+        return ((gc == null) || (gc == vImg.getGraphicsConfig()));\n+    }\n+\n+    @Override\n+    public void initContents() {\n+        if (vImg.getForcedAccelSurfaceType() != AccelSurface.TEXTURE) {\n+            super.initContents();\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLVolatileSurfaceManager.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import sun.lwawt.macosx.CFRetainedResource;\n@@ -251,2 +252,2 @@\n-    public SurfaceData createSurfaceData(CGLLayer layer) {\n-        return CGLSurfaceData.createData(layer);\n+    public SurfaceData createSurfaceData(CFRetainedResource layer) {\n+        return CGLSurfaceData.createData((CGLLayer) layer);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/opengl\/CGLGraphicsConfig.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,1 @@\n+import sun.awt.CGraphicsDevice;\n@@ -77,0 +78,1 @@\n+import sun.java2d.metal.MTLRenderQueue;\n@@ -79,0 +81,1 @@\n+import sun.java2d.pipe.RenderQueue;\n@@ -1417,1 +1420,2 @@\n-        final OGLRenderQueue rq = OGLRenderQueue.getInstance();\n+        RenderQueue rq =  CGraphicsDevice.usingMetalPipeline() ?\n+                MTLRenderQueue.getInstance() : OGLRenderQueue.getInstance();\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWComponentPeer.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.awt.CGraphicsDevice;\n@@ -32,0 +33,1 @@\n+import sun.java2d.metal.MTLLayer;\n@@ -35,0 +37,1 @@\n+import sun.lwawt.macosx.CFRetainedResource;\n@@ -37,0 +40,1 @@\n+\n@@ -45,1 +49,1 @@\n-    private CGLLayer windowLayer;\n+    private CFRetainedResource windowLayer;\n@@ -55,1 +59,5 @@\n-        this.windowLayer = new CGLLayer(peer);\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n+            this.windowLayer = new MTLLayer(peer);\n+        } else {\n+            this.windowLayer = new CGLLayer(peer);\n+        }\n@@ -66,1 +74,5 @@\n-        return windowLayer.getPointer();\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n+            return ((MTLLayer)windowLayer).getPointer();\n+        } else {\n+            return ((CGLLayer)windowLayer).getPointer();\n+        }\n@@ -71,1 +83,5 @@\n-        windowLayer.dispose();\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n+            ((MTLLayer)windowLayer).dispose();\n+        } else {\n+            ((CGLLayer)windowLayer).dispose();\n+        }\n@@ -102,1 +118,5 @@\n-        return windowLayer.getSurfaceData();\n+        if ( CGraphicsDevice.usingMetalPipeline()) {\n+            return ((MTLLayer)windowLayer).getSurfaceData();\n+        } else {\n+            return ((CGLLayer)windowLayer).getSurfaceData();\n+        }\n@@ -107,1 +127,5 @@\n-        return windowLayer.replaceSurfaceData();\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n+            return ((MTLLayer)windowLayer).replaceSurfaceData();\n+        } else {\n+            return ((CGLLayer)windowLayer).replaceSurfaceData();\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformEmbeddedFrame.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+import sun.awt.CGraphicsDevice;\n+import sun.java2d.metal.MTLLayer;\n+import sun.lwawt.LWWindowPeer;\n+\n@@ -40,1 +44,0 @@\n-import sun.lwawt.LWWindowPeer;\n@@ -51,1 +54,1 @@\n-    private CGLLayer windowLayer;\n+    private CFRetainedResource windowLayer;\n@@ -61,1 +64,1 @@\n-        this.windowLayer = createCGLayer();\n+        this.windowLayer = CGraphicsDevice.usingMetalPipeline()? createMTLLayer() : createCGLayer();\n@@ -69,0 +72,5 @@\n+    public MTLLayer createMTLLayer() {\n+        return new MTLLayer(peer);\n+    }\n+\n+\n@@ -99,1 +107,4 @@\n-        surfaceData = windowLayer.replaceSurfaceData();\n+        surfaceData = (CGraphicsDevice.usingMetalPipeline()) ?\n+                    ((MTLLayer)windowLayer).replaceSurfaceData() :\n+                    ((CGLLayer)windowLayer).replaceSurfaceData()\n+        ;\n@@ -114,1 +125,3 @@\n-        return windowLayer.getPointer();\n+        return CGraphicsDevice.usingMetalPipeline() ?\n+                ((MTLLayer)windowLayer).getPointer() :\n+                ((CGLLayer)windowLayer).getPointer();\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformView.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.java2d.metal.MTLLayer;\n@@ -303,0 +304,17 @@\n+            public MTLLayer createMTLLayer() {\n+                return new MTLLayer(null) {\n+                    public Rectangle getBounds() {\n+                        return CWarningWindow.this.getBounds();\n+                    }\n+\n+                    public GraphicsConfiguration getGraphicsConfiguration() {\n+                        LWWindowPeer peer = ownerPeer.get();\n+                        return peer.getGraphicsConfiguration();\n+                    }\n+\n+                    public boolean isOpaque() {\n+                        return false;\n+                    }\n+                };\n+            }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CWarningWindow.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,1 @@\n+import sun.java2d.metal.MTLRenderQueue;\n@@ -503,2 +504,6 @@\n-        \/\/ flush the OGL pipeline (this is a no-op if OGL is not enabled)\n-        OGLRenderQueue.sync();\n+        \/\/ flush the rendering pipeline\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n+            MTLRenderQueue.sync();\n+        } else {\n+            OGLRenderQueue.sync();\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#import <QuartzCore\/CAMetalLayer.h>\n@@ -70,2 +71,2 @@\n-\/\/ Updates back buffer size of the layer if it's an OpenGL layer\n-\/\/ including all OpenGL sublayers\n+\/\/ Updates back buffer size of the layer if it's an OpenGL\/Metal layer\n+\/\/ including all OpenGL\/Metal sublayers\n@@ -73,1 +74,2 @@\n-    if ([aLayer isKindOfClass:[CAOpenGLLayer class]]) {\n+    if ([aLayer isKindOfClass:[CAOpenGLLayer class]] ||\n+        [aLayer isKindOfClass:[CAMetalLayer class]]) {\n@@ -95,1 +97,1 @@\n- * Method:    nativeCreateLayer\n+ * Method:    nativeCreateComponent\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTSurfaceLayers.m","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef EncoderManager_h_Included\n+#define EncoderManager_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"RenderOptions.h\"\n+\n+@class MTLContex;\n+\n+\/**\n+ * The EncoderManager class used to obtain MTLRenderCommandEncoder (or MTLBlitCommandEncoder) corresponding\n+ * to the current state of MTLContext.\n+ *\n+ * Due to performance issues (creation of MTLRenderCommandEncoder isn't cheap), each getXXXEncoder invocation\n+ * updates properties of common (cached) encoder and returns this encoder.\n+ *\n+ * Base method getEncoder does the following:\n+ *  1. Checks whether common encoder must be closed and recreated (some of encoder properties is 'persistent',\n+ *  for example destination, stencil, or any other property of MTLRenderPassDescriptor)\n+ *  2. Updates 'mutable' properties encoder: pipelineState (with corresponding buffers), clip, transform, e.t.c. To avoid\n+ *  unnecessary calls of [encoder setXXX] this manager compares requested state with cached one.\n+ *\/\n+@interface EncoderManager : NSObject\n+- (id _Nonnull)init;\n+- (void)dealloc;\n+\n+- (void)setContext:(MTLContex * _Nonnull)mtlc;\n+\n+\/\/ returns encoder that renders\/fills geometry with current paint and composite\n+- (id<MTLRenderCommandEncoder> _Nonnull)getRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getAARenderEncoder:(const BMTLSDOps * _Nonnull)dstOps;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getRenderEncoder:(id<MTLTexture> _Nonnull)dest\n+                                             isDstOpaque:(bool)isOpaque;\n+\n+\/\/ returns encoder that renders\/fills geometry with current composite and with given texture\n+\/\/ (user must call [encoder setFragmentTexture] before any rendering)\n+- (id<MTLRenderCommandEncoder> _Nonnull)getTextureEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+                                      isSrcOpaque:(bool)isSrcOpaque;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                      isSrcOpaque:(bool)isSrcOpaque\n+                                      isDstOpaque:(bool)isDstOpaque\n+                                    interpolation:(int)interpolation;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                              isSrcOpaque:(bool)isSrcOpaque\n+                                              isDstOpaque:(bool)isDstOpaque\n+                                            interpolation:(int)interpolation\n+                                                     isAA:(jboolean)isAA;\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getTextEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+                                      isSrcOpaque:(bool)isSrcOpaque;\n+\n+\/\/ Base method to obtain any MTLRenderCommandEncoder\n+- (id<MTLRenderCommandEncoder> _Nonnull) getEncoder:(id<MTLTexture> _Nonnull)dest\n+                                       isDestOpaque:(jboolean)isDestOpaque\n+                                      renderOptions:(const RenderOptions * _Nonnull)renderOptions;\n+\n+- (id<MTLBlitCommandEncoder> _Nonnull)createBlitEncoder;\n+\n+- (void)endEncoder;\n+@end\n+\n+#endif \/\/ EncoderManager_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.h","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,454 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"EncoderManager.h\"\n+#include \"MTLContext.h\"\n+#include \"sun_java2d_SunGraphics2D.h\"\n+#import \"common.h\"\n+\n+\/\/ NOTE: uncomment to disable comparing cached encoder states with requested (for debugging)\n+\/\/ #define ALWAYS_UPDATE_ENCODER_STATES\n+\n+const SurfaceRasterFlags defaultRasterFlags = { JNI_FALSE, JNI_TRUE };\n+\n+\/\/ Internal utility class that represents the set of 'mutable' encoder properties\n+@interface EncoderStates : NSObject\n+@property (readonly) MTLClip * clip;\n+\n+- (id)init;\n+- (void)dealloc;\n+\n+- (void)reset:(id<MTLTexture>)destination\n+           isDstOpaque:(jboolean)isDstOpaque\n+    isDstPremultiplied:(jboolean)isDstPremultiplied\n+                  isAA:(jboolean)isAA\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD;\n+\n+- (void)updateEncoder:(id<MTLRenderCommandEncoder>)encoder\n+              context:(MTLContext *)mtlc\n+        renderOptions:(const RenderOptions *)renderOptions\n+          forceUpdate:(jboolean)forceUpdate;\n+@property (assign) jboolean aa;\n+@property (assign) jboolean text;\n+@property (assign) jboolean lcd;\n+@property (retain) MTLPaint* paint;\n+@end\n+\n+@implementation EncoderStates {\n+    MTLPipelineStatesStorage * _pipelineStateStorage;\n+    id<MTLDevice> _device;\n+\n+    \/\/ Persistent encoder properties\n+    id<MTLTexture> _destination;\n+    SurfaceRasterFlags _dstFlags;\n+\n+    jboolean _isAA;\n+    jboolean _isText;\n+    jboolean _isLCD;\n+\n+    \/\/\n+    \/\/ Cached 'mutable' states of encoder\n+    \/\/\n+\n+    \/\/ Composite rule and source raster flags (it affects the CAD-multipliers (of pipelineState))\n+    MTLComposite * _composite;\n+    SurfaceRasterFlags _srcFlags;\n+\n+    \/\/ Paint mode (it affects shaders (of pipelineState) and corresponding buffers)\n+    MTLPaint * _paint;\n+\n+    \/\/ If true, indicates that encoder is used for texture drawing (user must do [encoder setFragmentTexture:] before drawing)\n+    jboolean _isTexture;\n+    int _interpolationMode;\n+\n+    \/\/ Clip rect or stencil\n+    MTLClip * _clip;\n+\n+    \/\/ Transform (affects transformation inside vertex shader)\n+    MTLTransform * _transform;\n+}\n+@synthesize aa = _isAA;\n+@synthesize text = _isText;\n+@synthesize lcd = _isLCD;\n+@synthesize paint = _paint;\n+\n+- (id)init {\n+    self = [super init];\n+    if (self) {\n+        _destination = nil;\n+        _composite = [[MTLComposite alloc] init];\n+        _paint = [[MTLPaint alloc] init];\n+        _transform = [[MTLTransform alloc] init];\n+        _clip = [[MTLClip alloc] init];\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc {\n+    [_composite release];\n+    [_paint release];\n+    [_transform release];\n+    [super dealloc];\n+}\n+\n+- (void)setContext:(MTLContext * _Nonnull)mtlc {\n+    self->_pipelineStateStorage = mtlc.pipelineStateStorage;\n+    self->_device = mtlc.device;\n+}\n+\n+- (void)reset:(id<MTLTexture>)destination\n+           isDstOpaque:(jboolean)isDstOpaque\n+    isDstPremultiplied:(jboolean)isDstPremultiplied\n+                  isAA:(jboolean)isAA\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD {\n+    _destination = destination;\n+    _dstFlags.isOpaque = isDstOpaque;\n+    _dstFlags.isPremultiplied = isDstPremultiplied;\n+    _isAA = isAA;\n+    _isText = isText;\n+    _isLCD = isLCD;\n+    \/\/ NOTE: probably it's better to invalidate\/reset all cached states now\n+}\n+\n+- (void)updateEncoder:(id<MTLRenderCommandEncoder>)encoder\n+              context:(MTLContext *)mtlc\n+        renderOptions:(const RenderOptions *)renderOptions\n+          forceUpdate:(jboolean)forceUpdate\n+{\n+    \/\/ 1. Process special case for stencil mask generation\n+    if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {\n+        \/\/ use separate pipeline state for stencil generation\n+        if (forceUpdate || (_clip.stencilMaskGenerationInProgress != JNI_TRUE)) {\n+            [_clip copyFrom:mtlc.clip];\n+            [_clip setMaskGenerationPipelineState:encoder\n+                                        destWidth:_destination.width\n+                                       destHeight:_destination.height\n+                             pipelineStateStorage:_pipelineStateStorage];\n+        }\n+\n+        [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];\n+        return;\n+    }\n+\n+    \/\/ 2. Otherwise update all 'mutable' properties of encoder\n+    [self updatePipelineState:encoder\n+                      context:mtlc\n+                renderOptions:renderOptions\n+                  forceUpdate:forceUpdate];\n+    [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];\n+    [self updateClip:encoder clip:mtlc.clip forceUpdate:forceUpdate];\n+}\n+\n+\/\/\n+\/\/ Internal methods that update states when necessary (compare with cached states)\n+\/\/\n+\n+\/\/ Updates pipelineState (and corresponding buffers) with use of paint+composite+flags\n+- (void)updatePipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                    context:(MTLContext *)mtlc\n+              renderOptions:(const RenderOptions *)renderOptions\n+                forceUpdate:(jboolean)forceUpdate\n+{\n+    if (!forceUpdate\n+        && [_paint isEqual:mtlc.paint]\n+        && [_composite isEqual:mtlc.composite]\n+        && (_isTexture == renderOptions->isTexture && (!renderOptions->isTexture || _interpolationMode == renderOptions->interpolation)) \/\/ interpolation is used only in texture mode\n+        && _isAA == renderOptions->isAA\n+        && _isText == renderOptions->isText\n+        && _isLCD == renderOptions->isLCD\n+        && _srcFlags.isOpaque == renderOptions->srcFlags.isOpaque && _srcFlags.isPremultiplied == renderOptions->srcFlags.isPremultiplied)\n+        return;\n+\n+    self.paint = mtlc.paint;\n+    [_composite copyFrom:mtlc.composite];\n+    _isTexture = renderOptions->isTexture;\n+    _interpolationMode = renderOptions->interpolation;\n+    _isAA = renderOptions->isAA;\n+    _isText = renderOptions->isText;\n+    _isLCD = renderOptions->isLCD;\n+    _srcFlags = renderOptions->srcFlags;\n+\n+    if ((jint)[mtlc.composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR) {\n+\n+        [mtlc.paint setXorModePipelineState:encoder\n+                               context:mtlc\n+                         renderOptions:renderOptions\n+                  pipelineStateStorage:_pipelineStateStorage];\n+    } else {\n+        [mtlc.paint  setPipelineState:encoder\n+                              context:mtlc\n+                        renderOptions:renderOptions\n+                 pipelineStateStorage:_pipelineStateStorage];\n+    }\n+}\n+\n+- (void) updateClip:(id<MTLRenderCommandEncoder>)encoder clip:(MTLClip *)clip forceUpdate:(jboolean)forceUpdate\n+{\n+    if (clip.stencilMaskGenerationInProgress == JNI_TRUE) {\n+        \/\/ don't set setScissorOrStencil when generation in progress\n+        return;\n+    }\n+\n+    if (!forceUpdate && [_clip isEqual:clip])\n+        return;\n+\n+    [_clip copyFrom:clip];\n+    [_clip setScissorOrStencil:encoder\n+                     destWidth:_destination.width\n+                    destHeight:_destination.height\n+                        device:_device];\n+}\n+\n+- (void)updateTransform:(id <MTLRenderCommandEncoder>)encoder\n+              transform:(MTLTransform *)transform\n+            forceUpdate:(jboolean)forceUpdate\n+{\n+    if (!forceUpdate\n+        && [_transform isEqual:transform])\n+        return;\n+\n+    [_transform copyFrom:transform];\n+    [_transform setVertexMatrix:encoder\n+                        destWidth:_destination.width\n+                       destHeight:_destination.height];\n+}\n+\n+@end\n+\n+@implementation EncoderManager {\n+    MTLContext * _mtlc; \/\/ used to obtain CommandBufferWrapper and Composite\/Paint\/Transform\n+\n+    id<MTLRenderCommandEncoder> _encoder;\n+\n+    \/\/ 'Persistent' properties of encoder\n+    id<MTLTexture> _destination;\n+    id<MTLTexture> _aaDestination;\n+    BOOL _useStencil;\n+\n+    \/\/ 'Mutable' states of encoder\n+    EncoderStates * _encoderStates;\n+}\n+\n+- (id _Nonnull)init {\n+    self = [super init];\n+    if (self) {\n+        _encoder = nil;\n+        _destination = nil;\n+        _aaDestination = nil;\n+        _useStencil = NO;\n+        _encoderStates = [[EncoderStates alloc] init];\n+\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc {\n+    [_encoderStates release];\n+    [super dealloc];\n+}\n+\n+- (void)setContext:(MTLContex * _Nonnull)mtlc {\n+    self->_mtlc = mtlc;\n+    [self->_encoderStates setContext:mtlc];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+{\n+    return [self getRenderEncoder:dstOps->pTexture isDstOpaque:dstOps->isOpaque];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getAARenderEncoder:(const BMTLSDOps * _Nonnull)dstOps {\n+  id<MTLTexture> dstTxt = dstOps->pTexture;\n+  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+  return [self getEncoder:dstTxt renderOptions:&roptions];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull)getRenderEncoder:(id<MTLTexture> _Nonnull)dest\n+                                             isDstOpaque:(bool)isOpaque\n+{\n+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    return [self getEncoder:dest renderOptions:&roptions];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+                                      isSrcOpaque:(bool)isSrcOpaque\n+{\n+    return [self getTextureEncoder:dstOps->pTexture\n+                       isSrcOpaque:isSrcOpaque\n+                       isDstOpaque:dstOps->isOpaque\n+                     interpolation:INTERPOLATION_NEAREST_NEIGHBOR];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque\n+{\n+    return [self getTextureEncoder:dest\n+                       isSrcOpaque:isSrcOpaque\n+                       isDstOpaque:isDstOpaque\n+                     interpolation:INTERPOLATION_NEAREST_NEIGHBOR\n+                              isAA:JNI_FALSE];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque\n+{\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, {isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_TRUE};\n+    return [self getEncoder:dest renderOptions:&roptions];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                      isSrcOpaque:(bool)isSrcOpaque\n+                                      isDstOpaque:(bool)isDstOpaque\n+                                    interpolation:(int)interpolation\n+                                             isAA:(jboolean)isAA\n+{\n+    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    return [self getEncoder:dest renderOptions:&roptions];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque\n+                                             interpolation:(int)interpolation\n+{\n+    return [self getTextureEncoder:dest isSrcOpaque:isSrcOpaque isDstOpaque:isDstOpaque interpolation:interpolation isAA:JNI_FALSE];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getTextEncoder:(const BMTLSDOps * _Nonnull)dstOps\n+                                      isSrcOpaque:(bool)isSrcOpaque\n+{\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE, JNI_FALSE};\n+    return [self getEncoder:dstOps->pTexture renderOptions:&roptions];\n+}\n+\n+- (id<MTLRenderCommandEncoder> _Nonnull) getEncoder:(id <MTLTexture> _Nonnull)dest\n+                                      renderOptions:(const RenderOptions * _Nonnull)renderOptions\n+{\n+  \/\/\n+  \/\/ 1. check whether it's necessary to call endEncoder\n+  \/\/\n+  jboolean needEnd = JNI_FALSE;\n+  if (_encoder != nil) {\n+    if (_destination != dest || renderOptions->isAA != _encoderStates.aa) {\n+      J2dTraceLn2(J2D_TRACE_VERBOSE,\n+                  \"end common encoder because of dest change: %p -> %p\",\n+                  _destination, dest);\n+      needEnd = JNI_TRUE;\n+    } else if ((_useStencil == NO) != ([_mtlc.clip isShape] == NO)) {\n+      \/\/ 1. When mode changes RECT -> SHAPE we must recreate encoder with\n+      \/\/ stencilAttachment (todo: consider the case when current encoder already\n+      \/\/ has stencil)\n+      \/\/\n+      \/\/ 2. When mode changes SHAPE -> RECT it seems that we can use the same\n+      \/\/ encoder with disabled stencil test, but [encoder\n+      \/\/ setDepthStencilState:nil] causes crash, so we have to recreate encoder\n+      \/\/ in such case\n+      J2dTraceLn2(J2D_TRACE_VERBOSE,\n+                  \"end common encoder because toggle stencil: %d -> %d\",\n+                  (int)_useStencil, (int)[_mtlc.clip isShape]);\n+      needEnd = JNI_TRUE;\n+    }\n+  }\n+  if (needEnd)\n+    [self endEncoder];\n+\n+  \/\/\n+  \/\/ 2. recreate encoder if necessary\n+  \/\/\n+  jboolean forceUpdate = JNI_FALSE;\n+#ifdef ALWAYS_UPDATE_ENCODER_STATES\n+  forceUpdate = JNI_TRUE;\n+#endif \/\/ ALWAYS_UPDATE_ENCODER_STATES\n+\n+  if (_encoder == nil) {\n+    _destination = dest;\n+    _useStencil = [_mtlc.clip isShape] && !_mtlc.clip.stencilMaskGenerationInProgress;\n+    forceUpdate = JNI_TRUE;\n+\n+    MTLCommandBufferWrapper *cbw = [_mtlc getCommandBufferWrapper];\n+    MTLRenderPassDescriptor *rpd =\n+        [MTLRenderPassDescriptor renderPassDescriptor];\n+    MTLRenderPassColorAttachmentDescriptor *ca = rpd.colorAttachments[0];\n+    ca.texture = dest;\n+\n+    \/\/ TODO: Find out why we cannot use\n+    \/\/ if (_mtlc.clip.stencilMaskGenerationInProgress == YES) {\n+    \/\/     ca.loadAction = MTLLoadActionClear;\n+    \/\/     ca.clearColor = MTLClearColorMake(0.0f, 0.0f,0.0f, 0.0f);\n+    \/\/ }\n+    \/\/ here to avoid creation of clearEncoder in beginShapeClip\n+\n+    ca.loadAction = MTLLoadActionLoad;\n+    ca.storeAction = MTLStoreActionStore;\n+\n+    if (_useStencil && !renderOptions->isAA) {\n+        \/\/ If you enable stencil testing or stencil writing, the\n+        \/\/ MTLRenderPassDescriptor must include a stencil attachment.\n+        rpd.stencilAttachment.loadAction = MTLLoadActionLoad;\n+        rpd.stencilAttachment.storeAction = MTLStoreActionStore;\n+        rpd.stencilAttachment.texture = _mtlc.clip.stencilTextureRef;\n+    }\n+\n+    \/\/ J2dTraceLn1(J2D_TRACE_VERBOSE, \"created render encoder to draw on\n+    \/\/ tex=%p\", dest);\n+    _encoder = [[cbw getCommandBuffer] renderCommandEncoderWithDescriptor:rpd];\n+\n+    [_encoderStates reset:dest\n+               isDstOpaque:renderOptions->dstFlags.isOpaque\n+        isDstPremultiplied:YES\n+                      isAA:renderOptions->isAA\n+                      isText:renderOptions->isText\n+                      isLCD:renderOptions->isLCD];\n+  }\n+\n+  \/\/\n+  \/\/ 3. update encoder states\n+  \/\/\n+  [_encoderStates updateEncoder:_encoder\n+                        context:_mtlc\n+                  renderOptions:renderOptions\n+                    forceUpdate:forceUpdate];\n+\n+  return _encoder;\n+}\n+\n+- (id<MTLBlitCommandEncoder> _Nonnull) createBlitEncoder {\n+    [self endEncoder];\n+    return [[[_mtlc getCommandBufferWrapper] getCommandBuffer] blitCommandEncoder];\n+}\n+\n+- (void) endEncoder {\n+    if (_encoder != nil) {\n+      [_encoder endEncoding];\n+      _encoder = nil;\n+      _destination = nil;\n+    }\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":454,"deletions":0,"binary":false,"changes":454,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLBlitLoops_h_Included\n+#define MTLBlitLoops_h_Included\n+\n+#include \"sun_java2d_metal_MTLBlitLoops.h\"\n+#include \"MTLSurfaceDataBase.h\"\n+#include \"MTLContext.h\"\n+\n+#define OFFSET_SRCTYPE sun_java2d_metal_MTLBlitLoops_OFFSET_SRCTYPE\n+#define OFFSET_HINT    sun_java2d_metal_MTLBlitLoops_OFFSET_HINT\n+#define OFFSET_TEXTURE sun_java2d_metal_MTLBlitLoops_OFFSET_TEXTURE\n+#define OFFSET_RTT     sun_java2d_metal_MTLBlitLoops_OFFSET_RTT\n+#define OFFSET_XFORM   sun_java2d_metal_MTLBlitLoops_OFFSET_XFORM\n+#define OFFSET_ISOBLIT sun_java2d_metal_MTLBlitLoops_OFFSET_ISOBLIT\n+\n+void MTLBlitLoops_IsoBlit(JNIEnv *env,\n+                          MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,\n+                          jboolean xform, jint hint,\n+                          jboolean texture,\n+                          jint sx1, jint sy1,\n+                          jint sx2, jint sy2,\n+                          jdouble dx1, jdouble dy1,\n+                          jdouble dx2, jdouble dy2);\n+\n+void MTLBlitLoops_Blit(JNIEnv *env,\n+                       MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,\n+                       jboolean xform, jint hint,\n+                       jint srctype, jboolean texture,\n+                       jint sx1, jint sy1,\n+                       jint sx2, jint sy2,\n+                       jdouble dx1, jdouble dy1,\n+                       jdouble dx2, jdouble dy2);\n+\n+void MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,\n+                                  jlong pSrcOps, jlong pDstOps, jint dsttype,\n+                                  jint srcx, jint srcy,\n+                                  jint dstx, jint dsty,\n+                                  jint width, jint height);\n+\n+void MTLBlitLoops_CopyArea(JNIEnv *env,\n+                           MTLContext *mtlc, BMTLSDOps *dstOps,\n+                           jint x, jint y,\n+                           jint width, jint height,\n+                           jint dx, jint dy);\n+\n+void MTLBlitTex2Tex(MTLContext *mtlc, id<MTLTexture> src, id<MTLTexture> dest);\n+\n+void drawTex2Tex(MTLContext *mtlc,\n+                        id<MTLTexture> src, id<MTLTexture> dst,\n+                        jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,\n+                        jint sx1, jint sy1, jint sx2, jint sy2,\n+                        jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2);\n+\n+#endif \/* MTLBlitLoops_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.h","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,807 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jlong.h>\n+\n+#include \"SurfaceData.h\"\n+#include \"MTLBlitLoops.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLSurfaceData.h\"\n+#include \"MTLUtils.h\"\n+#include \"GraphicsPrimitiveMgr.h\"\n+\n+#include <stdlib.h> \/\/ malloc\n+#include <string.h> \/\/ memcpy\n+#include \"IntArgbPre.h\"\n+\n+#import <Accelerate\/Accelerate.h>\n+\n+#ifdef DEBUG\n+#define TRACE_ISOBLIT\n+#define TRACE_BLIT\n+#endif \/\/DEBUG\n+\/\/#define DEBUG_ISOBLIT\n+\/\/#define DEBUG_BLIT\n+\n+typedef struct {\n+    \/\/ Consider deleting this field, since it's always MTLPixelFormatBGRA8Unorm\n+    jboolean hasAlpha;\n+    jboolean isPremult;\n+    NSString* swizzleKernel;\n+} MTLRasterFormatInfo;\n+\n+\/**\n+ * This table contains the \"pixel formats\" for all system memory surfaces\n+ * that Metal is capable of handling, indexed by the \"PF_\" constants defined\n+ * in MTLLSurfaceData.java.  These pixel formats contain information that is\n+ * passed to Metal when copying from a system memory (\"Sw\") surface to\n+ * an Metal surface\n+ *\/\n+MTLRasterFormatInfo RasterFormatInfos[] = {\n+        { 1, 0, nil }, \/* 0 - IntArgb      *\/ \/\/ Argb (in java notation)\n+        { 1, 1, nil }, \/* 1 - IntArgbPre   *\/\n+        { 0, 1, @\"rgb_to_rgba\" }, \/* 2 - IntRgb       *\/\n+        { 0, 1, @\"xrgb_to_rgba\" }, \/* 3 - IntRgbx      *\/\n+        { 0, 1, @\"bgr_to_rgba\"  }, \/* 4 - IntBgr       *\/\n+        { 0, 1, @\"xbgr_to_rgba\" }, \/* 5 - IntBgrx      *\/\n+\n+\/\/        TODO: support 2-byte formats\n+\/\/        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,\n+\/\/                2, 0, 1,                                     }, \/* 7 - Ushort555Rgb *\/\n+\/\/        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,\n+\/\/                2, 0, 1,                                     }, \/* 8 - Ushort555Rgbx*\/\n+\/\/        { GL_LUMINANCE, GL_UNSIGNED_BYTE,\n+\/\/                1, 0, 1,                                     }, \/* 9 - ByteGray     *\/\n+\/\/        { GL_LUMINANCE, GL_UNSIGNED_SHORT,\n+\/\/                2, 0, 1,                                     }, \/*10 - UshortGray   *\/\n+\/\/        { GL_BGR,  GL_UNSIGNED_BYTE,\n+\/\/                1, 0, 1,                                     }, \/*11 - ThreeByteBgr *\/\n+};\n+\n+extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);\n+\n+void fillTxQuad(\n+        struct TxtVertex * txQuadVerts,\n+        jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,\n+        jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh\n+) {\n+    const float nsx1 = sx1\/(float)sw;\n+    const float nsy1 = sy1\/(float)sh;\n+    const float nsx2 = sx2\/(float)sw;\n+    const float nsy2 = sy2\/(float)sh;\n+\n+    txQuadVerts[0].position[0] = dx1;\n+    txQuadVerts[0].position[1] = dy1;\n+    txQuadVerts[0].txtpos[0]   = nsx1;\n+    txQuadVerts[0].txtpos[1]   = nsy1;\n+\n+    txQuadVerts[1].position[0] = dx2;\n+    txQuadVerts[1].position[1] = dy1;\n+    txQuadVerts[1].txtpos[0]   = nsx2;\n+    txQuadVerts[1].txtpos[1]   = nsy1;\n+\n+    txQuadVerts[2].position[0] = dx2;\n+    txQuadVerts[2].position[1] = dy2;\n+    txQuadVerts[2].txtpos[0]   = nsx2;\n+    txQuadVerts[2].txtpos[1]   = nsy2;\n+\n+    txQuadVerts[3].position[0] = dx2;\n+    txQuadVerts[3].position[1] = dy2;\n+    txQuadVerts[3].txtpos[0]   = nsx2;\n+    txQuadVerts[3].txtpos[1]   = nsy2;\n+\n+    txQuadVerts[4].position[0] = dx1;\n+    txQuadVerts[4].position[1] = dy2;\n+    txQuadVerts[4].txtpos[0]   = nsx1;\n+    txQuadVerts[4].txtpos[1]   = nsy2;\n+\n+    txQuadVerts[5].position[0] = dx1;\n+    txQuadVerts[5].position[1] = dy1;\n+    txQuadVerts[5].txtpos[0]   = nsx1;\n+    txQuadVerts[5].txtpos[1]   = nsy1;\n+}\n+\n+\/\/#define TRACE_drawTex2Tex\n+\n+void drawTex2Tex(MTLContext *mtlc,\n+                        id<MTLTexture> src, id<MTLTexture> dst,\n+                        jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,\n+                        jint sx1, jint sy1, jint sx2, jint sy2,\n+                        jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)\n+{\n+#ifdef TRACE_drawTex2Tex\n+    J2dRlsTraceLn2(J2D_TRACE_VERBOSE, \"drawTex2Tex: src tex=%p, dst tex=%p\", src, dst);\n+    J2dRlsTraceLn4(J2D_TRACE_VERBOSE, \"  sw=%d sh=%d dw=%d dh=%d\", src.width, src.height, dst.width, dst.height);\n+    J2dRlsTraceLn4(J2D_TRACE_VERBOSE, \"  sx1=%d sy1=%d sx2=%d sy2=%d\", sx1, sy1, sx2, sy2);\n+    J2dRlsTraceLn4(J2D_TRACE_VERBOSE, \"  dx1=%f dy1=%f dx2=%f dy2=%f\", dx1, dy1, dx2, dy2);\n+#endif \/\/TRACE_drawTex2Tex\n+\n+    id<MTLRenderCommandEncoder> encoder = [mtlc.encoderManager getTextureEncoder:dst\n+                                                                     isSrcOpaque:isSrcOpaque\n+                                                                     isDstOpaque:isDstOpaque\n+                                                                   interpolation:hint\n+    ];\n+\n+    struct TxtVertex quadTxVerticesBuffer[6];\n+    fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);\n+\n+    [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];\n+    [encoder setFragmentTexture:src atIndex: 0];\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+}\n+\n+static void\n+replaceTextureRegion(MTLContext *mtlc, id<MTLTexture> dest, const SurfaceDataRasInfo *srcInfo,\n+                     const MTLRasterFormatInfo *rfi,\n+                     int dx1, int dy1, int dx2, int dy2) {\n+    const int sw = srcInfo->bounds.x2 - srcInfo->bounds.x1;\n+    const int sh = srcInfo->bounds.y2 - srcInfo->bounds.y1;\n+    const int dw = dx2 - dx1;\n+    const int dh = dy2 - dy1;\n+    if (dw < sw || dh < sh) {\n+        J2dTraceLn4(J2D_TRACE_ERROR, \"replaceTextureRegion: dest size: (%d, %d) less than source size: (%d, %d)\", dw, dh, sw, sh);\n+        return;\n+    }\n+\n+    const void *raster = srcInfo->rasBase;\n+    raster += (NSUInteger)srcInfo->bounds.y1 * (NSUInteger)srcInfo->scanStride + (NSUInteger)srcInfo->bounds.x1 * (NSUInteger)srcInfo->pixelStride;\n+\n+    @autoreleasepool {\n+        J2dTraceLn4(J2D_TRACE_VERBOSE, \"replaceTextureRegion src (dw, dh) : [%d, %d] dest (dx1, dy1) =[%d, %d]\",\n+                    dw, dh, dx1, dy1);\n+        id<MTLBuffer> buff = [[mtlc.device newBufferWithLength:(sw * sh * srcInfo->pixelStride) options:MTLResourceStorageModeManaged] autorelease];\n+\n+        \/\/ copy src pixels inside src bounds to buff\n+        for (int row = 0; row < sh; row++) {\n+            memcpy(buff.contents + (row * sw * srcInfo->pixelStride), raster, sw * srcInfo->pixelStride);\n+            raster += (NSUInteger)srcInfo->scanStride;\n+        }\n+        [buff didModifyRange:NSMakeRange(0, buff.length)];\n+\n+        if (rfi->swizzleKernel != nil) {\n+            id <MTLBuffer> swizzled = [[mtlc.device newBufferWithLength:(sw * sh * srcInfo->pixelStride) options:MTLResourceStorageModeManaged] autorelease];\n+\n+            \/\/ this should be cheap, since data is already on GPU\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLComputeCommandEncoder> computeEncoder = [cb computeCommandEncoder];\n+            id<MTLComputePipelineState> computePipelineState = [mtlc.pipelineStateStorage\n+                                                                getComputePipelineState:rfi->swizzleKernel];\n+            [computeEncoder setComputePipelineState:computePipelineState];\n+\n+            [computeEncoder setBuffer:buff offset:0 atIndex:0];\n+            [computeEncoder setBuffer:swizzled offset:0 atIndex:1];\n+\n+            NSUInteger threadGroupSize = computePipelineState.maxTotalThreadsPerThreadgroup;\n+            NSUInteger pixelCount = buff.length \/ srcInfo->pixelStride;\n+            MTLSize threadsPerGroup = MTLSizeMake(threadGroupSize, 1, 1);\n+            MTLSize threadGroups = MTLSizeMake((pixelCount + threadGroupSize - 1) \/ threadGroupSize,\n+                                               1, 1);\n+            [computeEncoder dispatchThreadgroups:threadGroups\n+                           threadsPerThreadgroup:threadsPerGroup];\n+            [computeEncoder endEncoding];\n+            [cb commit];\n+\n+            buff = swizzled;\n+        }\n+\n+        id<MTLBlitCommandEncoder> blitEncoder = [mtlc.encoderManager createBlitEncoder];\n+        [blitEncoder copyFromBuffer:buff\n+                       sourceOffset:0 sourceBytesPerRow:(sw * srcInfo->pixelStride)\n+                sourceBytesPerImage:(sw * sh * srcInfo->pixelStride) sourceSize:MTLSizeMake(sw, sh, 1)\n+                          toTexture:dest\n+                   destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];\n+        [blitEncoder endEncoding];\n+        [mtlc.encoderManager endEncoder];\n+\n+        MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+        id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+        [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+            [cbwrapper release];\n+        }];\n+        [commandbuf commit];\n+    }\n+}\n+\n+\/**\n+ * Inner loop used for copying a source system memory (\"Sw\") surface to a\n+ * destination MTL \"Surface\".  This method is invoked from\n+ * MTLBlitLoops_Blit().\n+ *\/\n+\n+static void\n+MTLBlitSwToTextureViaPooledTexture(\n+        MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,\n+        MTLRasterFormatInfo *rfi, jint hint,\n+        jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)\n+{\n+    int sw = srcInfo->bounds.x2 - srcInfo->bounds.x1;\n+    int sh = srcInfo->bounds.y2 - srcInfo->bounds.y1;\n+\n+    sw = MIN(sw, MTL_GPU_FAMILY_MAC_TXT_SIZE);\n+    sh = MIN(sh, MTL_GPU_FAMILY_MAC_TXT_SIZE);\n+\n+    id<MTLTexture> dest = bmtlsdOps->pTexture;\n+\n+    MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:MTLPixelFormatBGRA8Unorm];\n+    if (texHandle == nil) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLBlitSwToTextureViaPooledTexture: can't obtain temporary texture object from pool\");\n+        return;\n+    }\n+    [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];\n+\n+    id<MTLTexture> texBuff = texHandle.texture;\n+    replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);\n+\n+    drawTex2Tex(mtlc, texBuff, dest, !rfi->hasAlpha, bmtlsdOps->isOpaque, hint,\n+                0, 0, sw, sh, dx1, dy1, dx2, dy2);\n+}\n+\n+static\n+jboolean isIntegerAndUnscaled(\n+        jint sx1, jint sy1, jint sx2, jint sy2,\n+        jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2\n+) {\n+    const jdouble epsilon = 0.0001f;\n+\n+    \/\/ check that dx1,dy1 is integer\n+    if (fabs(dx1 - (int)dx1) > epsilon || fabs(dy1 - (int)dy1) > epsilon) {\n+        return JNI_FALSE;\n+    }\n+    \/\/ check that destSize equals srcSize\n+    if (fabs(dx2 - dx1 - sx2 + sx1) > epsilon || fabs(dy2 - dy1 - sy2 + sy1) > epsilon) {\n+        return JNI_FALSE;\n+    }\n+    return JNI_TRUE;\n+}\n+\n+static\n+jboolean clipDestCoords(\n+        jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,\n+        jint *sx1, jint *sy1, jint *sx2, jint *sy2,\n+        jint destW, jint destH, const MTLScissorRect * clipRect\n+) {\n+    \/\/ Trim destination rect by clip-rect (or dest.bounds)\n+    const jint sw    = *sx2 - *sx1;\n+    const jint sh    = *sy2 - *sy1;\n+    const jdouble dw = *dx2 - *dx1;\n+    const jdouble dh = *dy2 - *dy1;\n+\n+    jdouble dcx1 = 0;\n+    jdouble dcx2 = destW;\n+    jdouble dcy1 = 0;\n+    jdouble dcy2 = destH;\n+    if (clipRect != NULL) {\n+        if (clipRect->x > dcx1)\n+            dcx1 = clipRect->x;\n+        const int maxX = clipRect->x + clipRect->width;\n+        if (dcx2 > maxX)\n+            dcx2 = maxX;\n+        if (clipRect->y > dcy1)\n+            dcy1 = clipRect->y;\n+        const int maxY = clipRect->y + clipRect->height;\n+        if (dcy2 > maxY)\n+            dcy2 = maxY;\n+\n+        if (dcx1 >= dcx2) {\n+            J2dTraceLn2(J2D_TRACE_ERROR, \"\\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f\", dcx1, dcx2);\n+            dcx1 = dcx2;\n+        }\n+        if (dcy1 >= dcy2) {\n+            J2dTraceLn2(J2D_TRACE_ERROR, \"\\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f\", dcy1, dcy2);\n+            dcy1 = dcy2;\n+        }\n+    }\n+    if (*dx2 <= dcx1 || *dx1 >= dcx2 || *dy2 <= dcy1 || *dy1 >= dcy2) {\n+        J2dTraceLn(J2D_TRACE_INFO, \"\\tclipDestCoords: dest rect doesn't intersect clip area\");\n+        J2dTraceLn4(J2D_TRACE_INFO, \"\\tdx2=%1.4f <= dcx1=%1.4f || *dx1=%1.4f >= dcx2=%1.4f\", *dx2, dcx1, *dx1, dcx2);\n+        J2dTraceLn4(J2D_TRACE_INFO, \"\\t*dy2=%1.4f <= dcy1=%1.4f || *dy1=%1.4f >= dcy2=%1.4f\", *dy2, dcy1, *dy1, dcy2);\n+        return JNI_FALSE;\n+    }\n+    if (*dx1 < dcx1) {\n+        J2dTraceLn3(J2D_TRACE_VERBOSE, \"\\t\\tdx1=%1.2f, will be clipped to %1.2f | sx1+=%d\", *dx1, dcx1, (jint)((dcx1 - *dx1) * (sw\/dw)));\n+        *sx1 += (jint)((dcx1 - *dx1) * (sw\/dw));\n+        *dx1 = dcx1;\n+    }\n+    if (*dx2 > dcx2) {\n+        J2dTraceLn3(J2D_TRACE_VERBOSE, \"\\t\\tdx2=%1.2f, will be clipped to %1.2f | sx2-=%d\", *dx2, dcx2, (jint)((*dx2 - dcx2) * (sw\/dw)));\n+        *sx2 -= (jint)((*dx2 - dcx2) * (sw\/dw));\n+        *dx2 = dcx2;\n+    }\n+    if (*dy1 < dcy1) {\n+        J2dTraceLn3(J2D_TRACE_VERBOSE, \"\\t\\tdy1=%1.2f, will be clipped to %1.2f | sy1+=%d\", *dy1, dcy1, (jint)((dcy1 - *dy1) * (sh\/dh)));\n+        *sy1 += (jint)((dcy1 - *dy1) * (sh\/dh));\n+        *dy1 = dcy1;\n+    }\n+    if (*dy2 > dcy2) {\n+        J2dTraceLn3(J2D_TRACE_VERBOSE, \"\\t\\tdy2=%1.2f, will be clipped to %1.2f | sy2-=%d\", *dy2, dcy2, (jint)((*dy2 - dcy2) * (sh\/dh)));\n+        *sy2 -= (jint)((*dy2 - dcy2) * (sh\/dh));\n+        *dy2 = dcy2;\n+    }\n+    return JNI_TRUE;\n+}\n+\n+\/**\n+ * General blit method for copying a native MTL surface to another MTL \"Surface\".\n+ * Parameter texture == true forces to use 'texture' codepath (dest coordinates will always be integers).\n+ * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).\n+ *\/\n+void\n+MTLBlitLoops_IsoBlit(JNIEnv *env,\n+                     MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,\n+                     jboolean xform, jint hint, jboolean texture,\n+                     jint sx1, jint sy1, jint sx2, jint sy2,\n+                     jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)\n+{\n+    BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);\n+    BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(srcOps);\n+    RETURN_IF_NULL(dstOps);\n+\n+    id<MTLTexture> srcTex = srcOps->pTexture;\n+    id<MTLTexture> dstTex = dstOps->pTexture;\n+    if (srcTex == nil || srcTex == nil) {\n+        J2dTraceLn2(J2D_TRACE_ERROR, \"MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)\", srcTex, dstTex);\n+        return;\n+    }\n+\n+    const jint sw    = sx2 - sx1;\n+    const jint sh    = sy2 - sy1;\n+    const jdouble dw = dx2 - dx1;\n+    const jdouble dh = dy2 - dy1;\n+\n+    if (sw <= 0 || sh <= 0 || dw <= 0 || dh <= 0) {\n+        J2dTraceLn4(J2D_TRACE_WARNING, \"MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d\", sw, sh, dw, dh);\n+        return;\n+    }\n+\n+#ifdef DEBUG_ISOBLIT\n+    if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {\n+        J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,\n+                \"MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d\",\n+                xform, mtlc.useTransform, texture);\n+    }\n+#endif \/\/ DEBUG_ISOBLIT\n+\n+    if (!xform) {\n+        clipDestCoords(\n+                &dx1, &dy1, &dx2, &dy2,\n+                &sx1, &sy1, &sx2, &sy2,\n+                dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]\n+        );\n+    }\n+\n+    SurfaceDataBounds bounds;\n+    bounds.x1 = sx1;\n+    bounds.y1 = sy1;\n+    bounds.x2 = sx2;\n+    bounds.y2 = sy2;\n+    SurfaceData_IntersectBoundsXYXY(&bounds, 0, 0, srcOps->width, srcOps->height);\n+\n+    if (bounds.x2 <= bounds.x1 || bounds.y2 <= bounds.y1) {\n+        J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLBlitLoops_IsoBlit: source rectangle doesn't intersect with source surface bounds\");\n+        J2dTraceLn6(J2D_TRACE_VERBOSE, \"  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d\", sx1, sy1, sx2, sy2, srcOps->width, srcOps->height);\n+        J2dTraceLn4(J2D_TRACE_VERBOSE, \"  dx1=%f dy1=%f dx2=%f dy2=%f\", dx1, dy1, dx2, dy2);\n+        return;\n+    }\n+\n+    if (bounds.x1 != sx1) {\n+        dx1 += (bounds.x1 - sx1) * (dw \/ sw);\n+        sx1 = bounds.x1;\n+    }\n+    if (bounds.y1 != sy1) {\n+        dy1 += (bounds.y1 - sy1) * (dh \/ sh);\n+        sy1 = bounds.y1;\n+    }\n+    if (bounds.x2 != sx2) {\n+        dx2 += (bounds.x2 - sx2) * (dw \/ sw);\n+        sx2 = bounds.x2;\n+    }\n+    if (bounds.y2 != sy2) {\n+        dy2 += (bounds.y2 - sy2) * (dh \/ sh);\n+        sy2 = bounds.y2;\n+    }\n+\n+#ifdef TRACE_ISOBLIT\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,\n+         \"MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)->(%1.2f, %1.2f, %1.2f, %1.2f)\",\n+         texture, xform, [mtlc getCompositeDescription].cString,\n+         getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,\n+         sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);\n+#endif \/\/TRACE_ISOBLIT\n+\n+    if (!texture && !xform\n+        && srcOps->isOpaque\n+        && isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)\n+        && (dstOps->isOpaque || !srcOps->isOpaque)\n+    ) {\n+#ifdef TRACE_ISOBLIT\n+        J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,\" [via blitEncoder]\");\n+#endif \/\/TRACE_ISOBLIT\n+\n+        id <MTLBlitCommandEncoder> blitEncoder = [mtlc.encoderManager createBlitEncoder];\n+        [blitEncoder copyFromTexture:srcTex\n+                         sourceSlice:0\n+                         sourceLevel:0\n+                        sourceOrigin:MTLOriginMake(sx1, sy1, 0)\n+                          sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)\n+                           toTexture:dstTex\n+                    destinationSlice:0\n+                    destinationLevel:0\n+                   destinationOrigin:MTLOriginMake(dx1, dy1, 0)];\n+        [blitEncoder endEncoding];\n+        return;\n+    }\n+\n+#ifdef TRACE_ISOBLIT\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,\" [via sampling]\");\n+#endif \/\/TRACE_ISOBLIT\n+    drawTex2Tex(mtlc, srcTex, dstTex,\n+            srcOps->isOpaque, dstOps->isOpaque,\n+            hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);\n+}\n+\n+\/**\n+ * General blit method for copying a system memory (\"Sw\") surface to a native MTL surface.\n+ * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.\n+ * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).\n+ *\/\n+void\n+MTLBlitLoops_Blit(JNIEnv *env,\n+                  MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,\n+                  jboolean xform, jint hint,\n+                  jint srctype, jboolean texture,\n+                  jint sx1, jint sy1, jint sx2, jint sy2,\n+                  jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)\n+{\n+    SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);\n+    BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(srcOps);\n+    RETURN_IF_NULL(dstOps);\n+\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    if (dest == NULL) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLBlitLoops_Blit: dest is null\");\n+        return;\n+    }\n+    if (srctype < 0 || srctype >= sizeof(RasterFormatInfos)\/ sizeof(MTLRasterFormatInfo)) {\n+        J2dTraceLn1(J2D_TRACE_ERROR, \"MTLBlitLoops_Blit: source pixel format %d isn't supported\", srctype);\n+        return;\n+    }\n+    const jint sw    = sx2 - sx1;\n+    const jint sh    = sy2 - sy1;\n+    const jdouble dw = dx2 - dx1;\n+    const jdouble dh = dy2 - dy1;\n+\n+    if (sw <= 0 || sh <= 0 || dw <= 0 || dh <= 0) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLBlitLoops_Blit: invalid dimensions\");\n+        return;\n+    }\n+\n+#ifdef DEBUG_BLIT\n+    if (\n+        (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)\n+        || (xform && texture)\n+    ) {\n+        J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,\n+                \"MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d\",\n+                xform, mtlc.useTransform, texture);\n+    }\n+    if (texture) {\n+        if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {\n+            J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,\n+                    \"MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren't equal or dest coords aren't integers\");\n+        }\n+        if (!dstOps->isOpaque && !RasterFormatInfos[srctype].hasAlpha) {\n+            J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,\n+                    \"MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn't alpha, can't use texture-codepath\");\n+        }\n+    }\n+#endif \/\/ DEBUG_BLIT\n+    if (!xform) {\n+        clipDestCoords(\n+                &dx1, &dy1, &dx2, &dy2,\n+                &sx1, &sy1, &sx2, &sy2,\n+                dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]\n+        );\n+    }\n+\n+    SurfaceDataRasInfo srcInfo;\n+    srcInfo.bounds.x1 = sx1;\n+    srcInfo.bounds.y1 = sy1;\n+    srcInfo.bounds.x2 = sx2;\n+    srcInfo.bounds.y2 = sy2;\n+\n+    \/\/ NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.\n+    if (srcOps->Lock(env, srcOps, &srcInfo, SD_LOCK_READ) != SD_SUCCESS) {\n+        J2dTraceLn(J2D_TRACE_WARNING, \"MTLBlitLoops_Blit: could not acquire lock\");\n+        return;\n+    }\n+\n+    if (srcInfo.bounds.x2 > srcInfo.bounds.x1 && srcInfo.bounds.y2 > srcInfo.bounds.y1) {\n+        srcOps->GetRasInfo(env, srcOps, &srcInfo);\n+        if (srcInfo.rasBase) {\n+            if (srcInfo.bounds.x1 != sx1) {\n+                const int dx = srcInfo.bounds.x1 - sx1;\n+                dx1 += dx * (dw \/ sw);\n+            }\n+            if (srcInfo.bounds.y1 != sy1) {\n+                const int dy = srcInfo.bounds.y1 - sy1;\n+                dy1 += dy * (dh \/ sh);\n+            }\n+            if (srcInfo.bounds.x2 != sx2) {\n+                const int dx = srcInfo.bounds.x2 - sx2;\n+                dx2 += dx * (dw \/ sw);\n+            }\n+            if (srcInfo.bounds.y2 != sy2) {\n+                const int dy = srcInfo.bounds.y2 - sy2;\n+                dy2 += dy * (dh \/ sh);\n+            }\n+\n+#ifdef TRACE_BLIT\n+            J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,\n+                    \"MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)->(%1.2f, %1.2f, %1.2f, %1.2f)\",\n+                    texture, xform, [mtlc getCompositeDescription].cString,\n+                    getSurfaceDescription(dstOps).cString, srcOps,\n+                    sx2 - sx1, sy2 - sy1,\n+                    RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,\n+                    sx1, sy1, sx2, sy2,\n+                    dx1, dy1, dx2, dy2);\n+#endif \/\/TRACE_BLIT\n+\n+            MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];\n+\n+            if (texture) {\n+                replaceTextureRegion(mtlc, dest, &srcInfo, &rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);\n+            } else {\n+                MTLBlitSwToTextureViaPooledTexture(mtlc, &srcInfo, dstOps, &rfi, hint, dx1, dy1, dx2, dy2);\n+            }\n+        }\n+        SurfaceData_InvokeRelease(env, srcOps, &srcInfo);\n+    }\n+    SurfaceData_InvokeUnlock(env, srcOps, &srcInfo);\n+}\n+\n+void copyFromMTLBuffer(void *pDst, id<MTLBuffer> srcBuf, jint offset, jint len, BOOL convertFromArgbPre) {\n+    char *pSrc = (char*)srcBuf.contents + offset;\n+    if (convertFromArgbPre) {\n+        jint pixelLen = len>>2;\n+        for (int i = 0; i < pixelLen; i++) {\n+            LoadIntArgbPreTo1IntArgb((jint*)pSrc, 0, i, ((jint*)pDst)[i]);\n+        }\n+    } else {\n+        memcpy(pDst, pSrc, len);\n+    }\n+}\n+\n+\/**\n+ * Specialized blit method for copying a native MTL \"Surface\" (pbuffer,\n+ * window, etc.) to a system memory (\"Sw\") surface.\n+ *\/\n+void\n+MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,\n+                             jlong pSrcOps, jlong pDstOps, jint dsttype,\n+                             jint srcx, jint srcy, jint dstx, jint dsty,\n+                             jint width, jint height)\n+{\n+    J2dTraceLn6(J2D_TRACE_VERBOSE, \"MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d\", srcx, srcy, width, height, dstx, dsty);\n+\n+    BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);\n+    SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);\n+    SurfaceDataRasInfo srcInfo, dstInfo;\n+\n+    if (dsttype < 0 || dsttype >= sizeof(RasterFormatInfos)\/ sizeof(MTLRasterFormatInfo)) {\n+        J2dTraceLn1(J2D_TRACE_ERROR, \"MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn't supported\", dsttype);\n+        return;\n+    }\n+\n+    if (width <= 0 || height <= 0) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive\");\n+        return;\n+    }\n+\n+    RETURN_IF_NULL(srcOps);\n+    RETURN_IF_NULL(dstOps);\n+    RETURN_IF_NULL(mtlc);\n+\n+    srcInfo.bounds.x1 = srcx;\n+    srcInfo.bounds.y1 = srcy;\n+    srcInfo.bounds.x2 = srcx + width;\n+    srcInfo.bounds.y2 = srcy + height;\n+    dstInfo.bounds.x1 = dstx;\n+    dstInfo.bounds.y1 = dsty;\n+    dstInfo.bounds.x2 = dstx + width;\n+    dstInfo.bounds.y2 = dsty + height;\n+\n+    if (dstOps->Lock(env, dstOps, &dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {\n+        J2dTraceLn(J2D_TRACE_WARNING,\"MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock\");\n+        return;\n+    }\n+\n+    SurfaceData_IntersectBoundsXYXY(&srcInfo.bounds,\n+                                    0, 0, srcOps->width, srcOps->height);\n+\n+    SurfaceData_IntersectBlitBounds(&dstInfo.bounds, &srcInfo.bounds,\n+                                    srcx - dstx, srcy - dsty);\n+\n+    if (srcInfo.bounds.x2 > srcInfo.bounds.x1 &&\n+        srcInfo.bounds.y2 > srcInfo.bounds.y1)\n+    {\n+        dstOps->GetRasInfo(env, dstOps, &dstInfo);\n+        if (dstInfo.rasBase) {\n+            void *pDst = dstInfo.rasBase;\n+\n+            srcx = srcInfo.bounds.x1;\n+            srcy = srcInfo.bounds.y1;\n+            dstx = dstInfo.bounds.x1;\n+            dsty = dstInfo.bounds.y1;\n+            width = srcInfo.bounds.x2 - srcInfo.bounds.x1;\n+            height = srcInfo.bounds.y2 - srcInfo.bounds.y1;\n+\n+            pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);\n+            pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);\n+\n+            \/\/ Metal texture is (0,0) at left-top\n+            srcx = srcOps->xOffset + srcx;\n+            srcy = srcOps->yOffset + srcy;\n+            const int byteLength = width * height * 4; \/\/ NOTE: assume that src format is MTLPixelFormatBGRA8Unorm\n+\n+            \/\/ Create MTLBuffer (or use static)\n+            id<MTLBuffer> mtlbuf;\n+#ifdef USE_STATIC_BUFFER\n+            \/\/ NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API\n+            \/\/ mtlbuf = [mtlc.device\n+            \/\/          newBufferWithBytesNoCopy:pDst\n+            \/\/                            length:(NSUInteger) srcLength\n+            \/\/                           options:MTLResourceCPUCacheModeDefaultCache\n+            \/\/                       deallocator:nil];\n+            \/\/\n+            \/\/ see https:\/\/developer.apple.com\/documentation\/metal\/mtldevice\/1433382-newbufferwithbytesnocopy?language=objc\n+            \/\/\n+            \/\/ The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.\n+            \/\/ The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.\n+            \/\/ Memory allocated by malloc is specifically disallowed.\n+\n+            static id<MTLBuffer> mtlIntermediateBuffer = nil; \/\/ need to reimplement with MTLBufferManager\n+            if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length < srcLength) {\n+                if (mtlIntermediateBuffer != nil) {\n+                    [mtlIntermediateBuffer release];\n+                }\n+                mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];\n+            }\n+            mtlbuf = mtlIntermediateBuffer;\n+#else \/\/ USE_STATIC_BUFFER\n+            mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];\n+#endif \/\/ USE_STATIC_BUFFER\n+\n+            \/\/ Read from surface into MTLBuffer\n+            \/\/ NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)\n+            \/\/ can be unfinished when reading raster from blit cmd-buf).\n+            \/\/ Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];\n+            J2dTraceLn1(J2D_TRACE_VERBOSE, \"MTLBlitLoops_SurfaceToSwBlit: source texture %p\", srcOps->pTexture);\n+\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n+            [blitEncoder copyFromTexture:srcOps->pTexture\n+                            sourceSlice:0\n+                            sourceLevel:0\n+                           sourceOrigin:MTLOriginMake(srcx, srcy, 0)\n+                             sourceSize:MTLSizeMake(width, height, 1)\n+                               toBuffer:mtlbuf\n+                      destinationOffset:0 \/*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*\/\n+                 destinationBytesPerRow:width*4\n+               destinationBytesPerImage:byteLength];\n+            [blitEncoder endEncoding];\n+\n+            \/\/ Commit and wait for reading complete\n+            [cb commit];\n+            [cb waitUntilCompleted];\n+\n+            \/\/ Perform conversion if necessary\n+            BOOL convertFromPre = !RasterFormatInfos[dsttype].isPremult && !srcOps->isOpaque;\n+\n+            if ((dstInfo.scanStride == width * dstInfo.pixelStride) &&\n+                (height == (dstInfo.bounds.y2 - dstInfo.bounds.y1))) {\n+                \/\/ mtlbuf.contents have same dimensions as of pDst\n+                copyFromMTLBuffer(pDst, mtlbuf, 0, byteLength, convertFromPre);\n+            } else {\n+                \/\/ mtlbuf.contents have smaller dimensions than pDst\n+                \/\/ copy each row from mtlbuf.contents at appropriate position in pDst\n+                \/\/ Note : pDst is already addjusted for offsets using PtrAddBytes above\n+\n+                int rowSize = width * dstInfo.pixelStride;\n+                for (int y = 0; y < height; y++) {\n+                    copyFromMTLBuffer(pDst, mtlbuf, y * rowSize, rowSize, convertFromPre);\n+                    pDst = PtrAddBytes(pDst, dstInfo.scanStride);\n+                }\n+            }\n+\n+#ifndef USE_STATIC_BUFFER\n+            [mtlbuf release];\n+#endif \/\/ USE_STATIC_BUFFER\n+        }\n+        SurfaceData_InvokeRelease(env, dstOps, &dstInfo);\n+    }\n+    SurfaceData_InvokeUnlock(env, dstOps, &dstInfo);\n+}\n+\n+void\n+MTLBlitLoops_CopyArea(JNIEnv *env,\n+                      MTLContext *mtlc, BMTLSDOps *dstOps,\n+                      jint x, jint y, jint width, jint height,\n+                      jint dx, jint dy)\n+{\n+#ifdef DEBUG\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, \"MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -> dst (%d, %d)\",\n+            dstOps, dstOps->pTexture, ((id<MTLTexture>)dstOps->pTexture).width, ((id<MTLTexture>)dstOps->pTexture).height, x, y, width, height, dx, dy);\n+#endif \/\/DEBUG\n+    jint texWidth = ((id<MTLTexture>)dstOps->pTexture).width;\n+    jint texHeight = ((id<MTLTexture>)dstOps->pTexture).height;\n+\n+    SurfaceDataBounds srcBounds, dstBounds;\n+    srcBounds.x1 = x;\n+    srcBounds.y1 = y;\n+    srcBounds.x2 = srcBounds.x1 + width;\n+    srcBounds.y2 = srcBounds.y1 + height;\n+    dstBounds.x1 = x + dx;\n+    dstBounds.y1 = y + dy;\n+    dstBounds.x2 = dstBounds.x1 + width;\n+    dstBounds.y2 = dstBounds.y1 + height;\n+\n+    SurfaceData_IntersectBoundsXYXY(&srcBounds, 0, 0, texWidth, texHeight);\n+    SurfaceData_IntersectBoundsXYXY(&dstBounds, 0, 0, texWidth, texHeight);\n+    SurfaceData_IntersectBlitBounds(&dstBounds, &srcBounds, -dx, -dy);\n+\n+    int srcWidth = (srcBounds.x2 - srcBounds.x1);\n+    int srcHeight = (srcBounds.y2 - srcBounds.y1);\n+\n+   if ((srcBounds.x1 < srcBounds.x2 && srcBounds.y1 < srcBounds.y2) &&\n+       (dstBounds.x1 < dstBounds.x2 && dstBounds.y1 < dstBounds.y2))\n+   {\n+        @autoreleasepool {\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n+\n+            \/\/ Create an intrermediate buffer\n+            int totalBuffsize = srcWidth * srcHeight * 4;\n+            id <MTLBuffer> buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];\n+\n+            [blitEncoder copyFromTexture:dstOps->pTexture\n+                    sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(srcBounds.x1, srcBounds.y1, 0) sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n+                     toBuffer:buff destinationOffset:0 destinationBytesPerRow:(srcWidth * 4) destinationBytesPerImage:totalBuffsize];\n+\n+            [blitEncoder copyFromBuffer:buff\n+                    sourceOffset:0 sourceBytesPerRow:srcWidth*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n+                    toTexture:dstOps->pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dstBounds.x1, dstBounds.y1, 0)];\n+            [blitEncoder endEncoding];\n+\n+            [cb commit];\n+        }\n+   }\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":807,"deletions":0,"binary":false,"changes":807,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLBufImgOps_h_Included\n+#define MTLBufImgOps_h_Included\n+\n+#include \"MTLContext.h\"\n+\n+@interface MTLRescaleOp : NSObject\n+- (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets;\n+- (jfloat *)getScaleFactors;\n+- (jfloat *)getOffsets;\n+- (NSString *)getDescription; \/\/ creates autorelease string\n+\n+@property (readonly) jboolean isNonPremult;\n+@end\n+\n+@interface MTLConvolveOp : NSObject\n+- (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth\n+                                 kernelHeight:(jint)kernelHeight\n+                                     srcWidth:(jint)srcWidth\n+                                    srcHeight:(jint)srcHeight\n+                                       kernel:(unsigned char *)kernel\n+                                       device:(id<MTLDevice>)device;\n+- (void) dealloc;\n+\n+- (id<MTLBuffer>) getBuffer;\n+- (const float *) getImgEdge;\n+- (NSString *)getDescription; \/\/ creates autorelease string\n+\n+@property (readonly) jboolean isEdgeZeroFill;\n+@property (readonly) int kernelSize;\n+@end\n+\n+@interface MTLLookupOp : NSObject\n+- (id)init:(jboolean)nonPremult shortData:(jboolean)shortData\n+                                 numBands:(jint)numBands\n+                               bandLength:(jint)bandLength\n+                                   offset:(jint)offset\n+                              tableValues:(void *)tableValues\n+                                   device:(id<MTLDevice>)device;\n+- (void) dealloc;\n+\n+- (jfloat *)getOffset;\n+- (id<MTLTexture>) getLookupTexture;\n+- (NSString *)getDescription; \/\/ creates autorelease string\n+\n+@property (readonly) jboolean isUseSrcAlpha;\n+@property (readonly) jboolean isNonPremult;\n+@end\n+\n+#endif \/* MTLBufImgOps_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBufImgOps.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+\n+#include \"MTLBufImgOps.h\"\n+#include \"MTLContext.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLSurfaceDataBase.h\"\n+#include \"GraphicsPrimitiveMgr.h\"\n+\n+@implementation MTLRescaleOp {\n+    jboolean _isNonPremult;\n+    jfloat _normScaleFactors[4];\n+    jfloat _normOffsets[4];\n+}\n+\n+-(jfloat *) getScaleFactors {\n+    return _normScaleFactors;\n+}\n+-(jfloat *) getOffsets {\n+    return _normOffsets;\n+}\n+\n+- (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets {\n+    self = [super init];\n+    if (self) {\n+        J2dTraceLn1(J2D_TRACE_INFO,\"Created MTLRescaleOp: isNonPremult=%d\", isNonPremult);\n+\n+        _isNonPremult = isNonPremult;\n+        _normScaleFactors[0] = NEXT_FLOAT(factors);\n+        _normScaleFactors[1] = NEXT_FLOAT(factors);\n+        _normScaleFactors[2] = NEXT_FLOAT(factors);\n+        _normScaleFactors[3] = NEXT_FLOAT(factors);\n+        _normOffsets[0] = NEXT_FLOAT(offsets);\n+        _normOffsets[1] = NEXT_FLOAT(offsets);\n+        _normOffsets[2] = NEXT_FLOAT(offsets);\n+        _normOffsets[3] = NEXT_FLOAT(offsets);\n+    }\n+    return self;\n+}\n+\n+- (NSString *)getDescription {\n+    return [NSString stringWithFormat:@\"rescale: nonPremult=%d\", _isNonPremult];\n+}\n+@end\n+\n+@implementation MTLConvolveOp {\n+    id<MTLBuffer> _buffer;\n+    float _imgEdge[4];\n+    int _kernelSize;\n+    jboolean _isEdgeZeroFill;\n+}\n+\n+- (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth\n+                                 kernelHeight:(jint)kernelHeight\n+                                     srcWidth:(jint)srcWidth\n+                                    srcHeight:(jint)srcHeight\n+                                       kernel:(unsigned char *)kernel\n+                                       device:(id<MTLDevice>)device {\n+    self = [super init];\n+    if (self) {\n+        J2dTraceLn2(J2D_TRACE_INFO,\"Created MTLConvolveOp: kernelW=%d kernelH=%d\", kernelWidth, kernelHeight);\n+        _isEdgeZeroFill = edgeZeroFill;\n+\n+        _kernelSize = kernelWidth * kernelHeight;\n+        _buffer = [device newBufferWithLength:_kernelSize*sizeof(vector_float3) options:MTLResourceStorageModeShared];\n+\n+        float * kernelVals = [_buffer contents];\n+        int kIndex = 0;\n+        for (int i = -kernelHeight\/2; i < kernelHeight\/2+1; i++) {\n+            for (int j = -kernelWidth\/2; j < kernelWidth\/2+1; j++) {\n+                kernelVals[kIndex+0] = j\/(float)srcWidth;\n+                kernelVals[kIndex+1] = i\/(float)srcHeight;\n+                kernelVals[kIndex+2] = NEXT_FLOAT(kernel);\n+                kIndex += 3;\n+            }\n+        }\n+\n+        _imgEdge[0] = (kernelWidth\/2)\/(float)srcWidth;\n+        _imgEdge[1] = (kernelHeight\/2)\/(float)srcHeight;\n+        _imgEdge[2] = 1 - _imgEdge[0];\n+        _imgEdge[3] = 1 - _imgEdge[1];\n+    }\n+    return self;\n+}\n+\n+- (void) dealloc {\n+    [_buffer release];\n+    [super dealloc];\n+}\n+\n+- (id<MTLBuffer>) getBuffer {\n+    return _buffer;\n+}\n+\n+- (const float *) getImgEdge {\n+    return _imgEdge;\n+}\n+\n+- (NSString *)getDescription {\n+    return [NSString stringWithFormat:@\"convolve: isEdgeZeroFill=%d\", _isEdgeZeroFill];\n+}\n+@end\n+\n+\n+@implementation MTLLookupOp {\n+    float _offset[4];\n+    jboolean _isUseSrcAlpha;\n+    jboolean _isNonPremult;\n+\n+    id<MTLTexture> _lookupTex;\n+}\n+\n+- (id)init:(jboolean)nonPremult shortData:(jboolean)shortData\n+                                 numBands:(jint)numBands\n+                               bandLength:(jint)bandLength\n+                                   offset:(jint)offset\n+                              tableValues:(void *)tableValues\n+                                   device:(id<MTLDevice>)device {\n+    self = [super init];\n+    if (self) {\n+        J2dTraceLn4(J2D_TRACE_INFO,\"Created MTLLookupOp: short=%d num=%d len=%d off=%d\",\n+                    shortData, numBands, bandLength, offset);\n+\n+        _isUseSrcAlpha = numBands != 4;\n+        _isNonPremult = nonPremult;\n+\n+        _offset[0] = offset \/ 255.0f;\n+        _offset[1] = _offset[0];\n+        _offset[2] = _offset[0];\n+        _offset[3] = _offset[0];\n+\n+        MTLTextureDescriptor *textureDescriptor =\n+                [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatA8Unorm\n+                                                                   width:(NSUInteger)256\n+                                                                  height:(NSUInteger)4\n+                                                               mipmapped:NO];\n+\n+        _lookupTex = [device newTextureWithDescriptor:textureDescriptor];\n+\n+        void *bands[4];\n+        for (int i = 0; i < 4; i++) {\n+            bands[i] = NULL;\n+        }\n+        int bytesPerElem = (shortData ? 2 : 1);\n+        if (numBands == 1) {\n+            \/\/ replicate the single band for R\/G\/B; alpha band is unused\n+            for (int i = 0; i < 3; i++) {\n+                bands[i] = tableValues;\n+            }\n+            bands[3] = NULL;\n+        } else if (numBands == 3) {\n+            \/\/ user supplied band for each of R\/G\/B; alpha band is unused\n+            for (int i = 0; i < 3; i++) {\n+                bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);\n+            }\n+            bands[3] = NULL;\n+        } else if (numBands == 4) {\n+            \/\/ user supplied band for each of R\/G\/B\/A\n+            for (int i = 0; i < 4; i++) {\n+                bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);\n+            }\n+        }\n+\n+        for (int i = 0; i < 4; i++) {\n+            if (bands[i] == NULL)\n+                continue;\n+\n+            MTLRegion region = {\n+                    {0, i, 0},\n+                    {bandLength, 1,1}\n+            };\n+\n+            [_lookupTex replaceRegion:region\n+                                    mipmapLevel:0\n+                                      withBytes:bands[i]\n+                                    bytesPerRow:bandLength*bytesPerElem];\n+        }\n+    }\n+    return self;\n+}\n+\n+- (void) dealloc {\n+    [_lookupTex release];\n+    [super dealloc];\n+}\n+\n+- (jfloat *) getOffset {\n+    return _offset;\n+}\n+\n+- (id<MTLTexture>) getLookupTexture {\n+    return _lookupTex;\n+}\n+\n+- (NSString *)getDescription {\n+    return [NSString stringWithFormat:@\"lookup: offset=%f\", _offset[0]];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBufImgOps.m","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <limits.h>\n+#ifndef MTLClip_h_Included\n+#define MTLClip_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include <jni.h>\n+\n+#include \"MTLSurfaceDataBase.h\"\n+\n+enum Clip {\n+    NO_CLIP,\n+    RECT_CLIP,\n+    SHAPE_CLIP\n+};\n+\n+@class MTLContext;\n+@class MTLPipelineStatesStorage;\n+\n+\/**\n+ * The MTLClip class represents clip mode (rect or stencil)\n+ * *\/\n+\n+@interface MTLClip : NSObject\n+@property (readonly) id<MTLTexture> stencilTextureRef;\n+@property (readonly) BOOL stencilMaskGenerationInProgress;\n+@property NSUInteger shapeX;\n+@property NSUInteger shapeY;\n+@property NSUInteger shapeWidth;\n+@property NSUInteger shapeHeight;\n+\n+- (id)init;\n+- (BOOL)isEqual:(MTLClip *)other; \/\/ used to compare requested with cached\n+- (void)copyFrom:(MTLClip *)other; \/\/ used to save cached\n+\n+- (BOOL)isShape;\n+- (BOOL)isRect;\n+\n+\/\/ returns null when clipType != RECT_CLIP\n+- (const MTLScissorRect *) getRect;\n+\n+- (void)reset;\n+- (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2;\n+- (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc;\n+- (void)endShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc;\n+\n+- (void)setScissorOrStencil:(id<MTLRenderCommandEncoder>)encoder\n+                  destWidth:(NSUInteger)dw\n+                 destHeight:(NSUInteger)dh\n+                     device:(id<MTLDevice>)device;\n+\n+- (void)setMaskGenerationPipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                             destWidth:(NSUInteger)dw\n+                            destHeight:(NSUInteger)dh\n+                  pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;\n+\n+- (NSString *)getDescription __unused; \/\/ creates autorelease string\n+@end\n+\n+#endif \/\/ MTLClip_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.h","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLClip.h\"\n+\n+#include \"MTLContext.h\"\n+#include \"common.h\"\n+\n+static MTLRenderPipelineDescriptor * templateStencilPipelineDesc = nil;\n+\n+static void initTemplatePipelineDescriptors() {\n+    if (templateStencilPipelineDesc != nil)\n+        return;\n+\n+    MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n+    vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n+    vertDesc.attributes[VertexAttributePosition].offset = 0;\n+    vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n+    vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n+    vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n+    vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+\n+    templateStencilPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateStencilPipelineDesc.sampleCount = 1;\n+    templateStencilPipelineDesc.vertexDescriptor = vertDesc;\n+    templateStencilPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatR8Uint; \/\/ A byte buffer format\n+    templateStencilPipelineDesc.label = @\"template_stencil\";\n+}\n+\n+static id<MTLDepthStencilState> getStencilState(id<MTLDevice> device) {\n+    static id<MTLDepthStencilState> stencilState = nil;\n+    if (stencilState == nil) {\n+        MTLDepthStencilDescriptor* stencilDescriptor;\n+        stencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n+        stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+\n+        \/\/ TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives\n+        \/\/ currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.\n+        \/\/ Once that part is changed, set backFaceStencil to nil\n+        \/\/stencilDescriptor.backFaceStencil = nil;\n+\n+        stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+\n+        stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];\n+    }\n+\n+    return stencilState;\n+}\n+\n+@implementation MTLClip {\n+    jint _clipType;\n+    MTLScissorRect  _clipRect;\n+    MTLContext* _mtlc;\n+    BMTLSDOps*  _dstOps;\n+    BOOL _stencilMaskGenerationInProgress;\n+    BOOL _clipReady;\n+    MTLOrigin _clipShapeOrigin;\n+    MTLSize _clipShapeSize;\n+}\n+\n+- (id)init {\n+    self = [super init];\n+    if (self) {\n+        _clipType = NO_CLIP;\n+        _mtlc = nil;\n+        _dstOps = NULL;\n+        _stencilMaskGenerationInProgress = NO;\n+        _clipReady = NO;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLClip *)other {\n+    if (self == other)\n+        return YES;\n+    if (_stencilMaskGenerationInProgress == JNI_TRUE)\n+        return other->_stencilMaskGenerationInProgress == JNI_TRUE;\n+    if (_clipType != other->_clipType)\n+        return NO;\n+    if (_clipType == NO_CLIP)\n+        return YES;\n+    if (_clipType == RECT_CLIP) {\n+        return _clipRect.x == other->_clipRect.x && _clipRect.y == other->_clipRect.y\n+               && _clipRect.width == other->_clipRect.width && _clipRect.height == other->_clipRect.height;\n+    }\n+\n+    \/\/ NOTE: can compare stencil-data pointers here\n+    return YES;\n+}\n+\n+- (BOOL)isShape {\n+    return _clipType == SHAPE_CLIP;\n+}\n+\n+- (BOOL)isRect __unused {\n+    return _clipType == RECT_CLIP;\n+}\n+\n+- (const MTLScissorRect * _Nullable) getRect {\n+    return _clipType == RECT_CLIP ? &_clipRect : NULL;\n+}\n+\n+- (void)copyFrom:(MTLClip *)other {\n+    _clipType = other->_clipType;\n+    _stencilMaskGenerationInProgress = other->_stencilMaskGenerationInProgress;\n+    _dstOps = other->_dstOps;\n+    if (other->_clipType == RECT_CLIP) {\n+        _clipRect = other->_clipRect;\n+    }\n+}\n+\n+- (void)reset {\n+    _clipType = NO_CLIP;\n+    _stencilMaskGenerationInProgress = JNI_FALSE;\n+}\n+\n+- (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2 {\n+    if (_clipType == SHAPE_CLIP) {\n+        _dstOps = NULL;\n+    }\n+\n+    if (x1 >= x2 || y1 >= y2) {\n+        J2dTraceLn4(J2D_TRACE_ERROR, \"MTLClip.setClipRect: invalid rect: x1=%d y1=%d x2=%d y2=%d\", x1, y1, x2, y2);\n+        _clipType = NO_CLIP;\n+    }\n+\n+    const jint width = x2 - x1;\n+    const jint height = y2 - y1;\n+\n+    J2dTraceLn4(J2D_TRACE_INFO, \"MTLClip.setClipRect: x=%d y=%d w=%d h=%d\", x1, y1, width, height);\n+\n+    _clipRect.x = (NSUInteger)((x1 >= 0) ? x1 : 0);\n+    _clipRect.y = (NSUInteger)((y1 >= 0) ? y1 : 0);\n+    _clipRect.width = (NSUInteger)((width >= 0) ? width : 0);\n+    _clipRect.height = (NSUInteger)((height >= 0) ? height : 0);\n+    _clipType = RECT_CLIP;\n+}\n+\n+- (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {\n+    _stencilMaskGenerationInProgress = YES;\n+\n+    if ((dstOps == NULL) || (dstOps->pStencilData == NULL) || (dstOps->pStencilTexture == NULL)) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLContext_beginShapeClip: stencil render target or stencil texture is NULL\");\n+        return;\n+    }\n+\n+    \/\/ Clear the stencil render buffer & stencil texture\n+    @autoreleasepool {\n+        if (dstOps->width <= 0 || dstOps->height <= 0) {\n+          return;\n+        }\n+\n+        _clipShapeSize = MTLSizeMake(0, 0, 1);\n+        _clipShapeOrigin = MTLOriginMake(0, 0, 0);\n+\n+        MTLRenderPassDescriptor* clearPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor];\n+        \/\/ set color buffer properties\n+        clearPassDescriptor.colorAttachments[0].texture = dstOps->pStencilData;\n+        clearPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;\n+        clearPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0f, 0.0f,0.0f, 0.0f);\n+\n+        id<MTLCommandBuffer> commandBuf = [mtlc createCommandBuffer];\n+        id <MTLRenderCommandEncoder> clearEncoder = [commandBuf renderCommandEncoderWithDescriptor:clearPassDescriptor];\n+        [clearEncoder endEncoding];\n+        [commandBuf commit];\n+    }\n+}\n+\n+- (void)endShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {\n+\n+    if ((dstOps == NULL) || (dstOps->pStencilData == NULL) || (dstOps->pStencilTexture == NULL)) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLContext_endShapeClip: stencil render target or stencil texture is NULL\");\n+        return;\n+    }\n+\n+    \/\/ Complete the rendering to the stencil buffer ------------\n+    [mtlc.encoderManager endEncoder];\n+\n+    MTLCommandBufferWrapper* cbWrapper = [mtlc pullCommandBufferWrapper];\n+\n+    id<MTLCommandBuffer> commandBuffer = [cbWrapper getCommandBuffer];\n+    [commandBuffer addCompletedHandler:^(id <MTLCommandBuffer> c) {\n+        [cbWrapper release];\n+    }];\n+\n+    [commandBuffer commit];\n+\n+    \/\/ Now the stencil data is ready, this needs to be used while rendering further\n+    @autoreleasepool {\n+        if (_clipShapeSize.width > 0 && _clipShapeSize.height > 0) {\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n+            [blitEncoder copyFromTexture:dstOps->pStencilData\n+                             sourceSlice:0\n+                             sourceLevel:0\n+                            sourceOrigin:_clipShapeOrigin\n+                              sourceSize:_clipShapeSize\n+                                toBuffer:dstOps->pStencilDataBuf\n+                       destinationOffset:0\n+                  destinationBytesPerRow:_clipShapeSize.width\n+                destinationBytesPerImage:_clipShapeSize.width*_clipShapeSize.height];\n+            [blitEncoder endEncoding];\n+            [cb commit];\n+        }\n+    }\n+\n+    _stencilMaskGenerationInProgress = JNI_FALSE;\n+    _mtlc = mtlc;\n+    _dstOps = dstOps;\n+    _clipType = SHAPE_CLIP;\n+    _clipReady = NO;\n+}\n+\n+- (void)setMaskGenerationPipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                  destWidth:(NSUInteger)dw\n+                 destHeight:(NSUInteger)dh\n+       pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+\n+    \/\/ A  PipelineState for rendering to a byte-buffered texture that will be used as a stencil\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:templateStencilPipelineDesc\n+                                                                         vertexShaderId:@\"vert_stencil\"\n+                                                                       fragmentShaderId:@\"frag_stencil\"];\n+    [encoder setRenderPipelineState:pipelineState];\n+\n+    struct FrameUniforms uf; \/\/ color is ignored while writing to stencil buffer\n+    memset(&uf, 0, sizeof(uf));\n+    [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+\n+    _clipRect.x = 0;\n+    _clipRect.y = 0;\n+    _clipRect.width = dw;\n+    _clipRect.height = dh;\n+\n+    [encoder setScissorRect:_clipRect]; \/\/ just for insurance (to reset possible clip from previous drawing)\n+}\n+\n+- (void)setScissorOrStencil:(id<MTLRenderCommandEncoder>)encoder\n+                  destWidth:(NSUInteger)dw\n+                 destHeight:(NSUInteger)dh\n+                     device:(id<MTLDevice>)device\n+{\n+    if (_clipType == NO_CLIP || _clipType == SHAPE_CLIP) {\n+        _clipRect.x = 0;\n+        _clipRect.y = 0;\n+        _clipRect.width = dw;\n+        _clipRect.height = dh;\n+    }\n+\n+    \/\/ Clamping clip rect to the destination area\n+    MTLScissorRect rect = _clipRect;\n+\n+    if (rect.x > dw) {\n+        rect.x = dw;\n+    }\n+\n+    if (rect.y > dh) {\n+        rect.y = dh;\n+    }\n+\n+    if (rect.x + rect.width > dw) {\n+        rect.width = dw - rect.x;\n+    }\n+\n+    if (rect.y + rect.height > dh) {\n+        rect.height = dh - rect.y;\n+    }\n+\n+    [encoder setScissorRect:rect];\n+    if (_clipType == NO_CLIP || _clipType == RECT_CLIP) {\n+        \/\/ NOTE: It seems that we can use the same encoder (with disabled stencil test) when mode changes from SHAPE to RECT.\n+        \/\/ But [encoder setDepthStencilState:nil] causes crash, so we have to recreate encoder in such case.\n+        \/\/ So we can omit [encoder setDepthStencilState:nil] here.\n+        return;\n+    }\n+\n+    if (_clipType == SHAPE_CLIP) {\n+        \/\/ Enable stencil test\n+        [encoder setDepthStencilState:getStencilState(device)];\n+        [encoder setStencilReferenceValue:0xFF];\n+    }\n+}\n+\n+- (NSString *)getDescription __unused {\n+    if (_clipType == NO_CLIP) {\n+        return @\"NO_CLIP\";\n+    }\n+    if (_clipType == RECT_CLIP) {\n+        return [NSString stringWithFormat:@\"RECT_CLIP [%lu,%lu - %lux%lu]\", _clipRect.x, _clipRect.y, _clipRect.width, _clipRect.height];\n+    }\n+    return [NSString stringWithFormat:@\"SHAPE_CLIP\"];\n+}\n+\n+- (id<MTLTexture>) stencilTextureRef {\n+    if (_dstOps == NULL) return nil;\n+\n+    id <MTLTexture> _stencilTextureRef = _dstOps->pStencilTexture;\n+\n+    if (!_clipReady) {\n+        @autoreleasepool {\n+\n+            MTLRenderPassDescriptor* clearPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor];\n+            \/\/ set color buffer properties\n+            clearPassDescriptor.stencilAttachment.texture = _stencilTextureRef;\n+            clearPassDescriptor.stencilAttachment.clearStencil = 0;\n+            clearPassDescriptor.stencilAttachment.loadAction = MTLLoadActionClear;\n+\n+            id<MTLCommandBuffer> commandBuf = [_mtlc createCommandBuffer];\n+            id <MTLRenderCommandEncoder> clearEncoder = [commandBuf renderCommandEncoderWithDescriptor:clearPassDescriptor];\n+            [clearEncoder endEncoding];\n+            [commandBuf commit];\n+\n+            id <MTLCommandBuffer> cb = [_mtlc createCommandBuffer];\n+            id <MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n+            id <MTLBuffer> _stencilDataBufRef = _dstOps->pStencilDataBuf;\n+            [blitEncoder copyFromBuffer:_stencilDataBufRef\n+                           sourceOffset:0\n+                      sourceBytesPerRow:_clipShapeSize.width\n+                    sourceBytesPerImage:_clipShapeSize.width * _clipShapeSize.height\n+                             sourceSize:_clipShapeSize\n+                              toTexture:_stencilTextureRef\n+                       destinationSlice:0\n+                       destinationLevel:0\n+                      destinationOrigin:_clipShapeOrigin];\n+            [blitEncoder endEncoding];\n+            [cb commit];\n+            _clipReady = YES;\n+        }\n+    }\n+    return _stencilTextureRef;\n+}\n+\n+- (NSUInteger)shapeX {\n+    return _clipShapeOrigin.x;\n+}\n+\n+- (void)setShapeX:(NSUInteger)shapeX {\n+    _clipShapeOrigin.x = shapeX;\n+}\n+\n+- (NSUInteger)shapeY {\n+    return _clipShapeOrigin.y;\n+}\n+\n+- (void)setShapeY:(NSUInteger)shapeY {\n+    _clipShapeOrigin.y = shapeY;\n+}\n+\n+- (NSUInteger)shapeWidth {\n+    return _clipShapeSize.width;\n+}\n+\n+- (void)setShapeWidth:(NSUInteger)shapeWidth {\n+    _clipShapeSize.width = shapeWidth;\n+}\n+\n+- (NSUInteger)shapeHeight {\n+    return _clipShapeSize.height;\n+}\n+\n+- (void)setShapeHeight:(NSUInteger)shapeHeight {\n+    _clipShapeSize.height = shapeHeight;\n+}\n+\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.m","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLComposite_h_Included\n+#define MTLComposite_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include <jni.h>\n+\n+#define FLT_EPS (0.001f)\n+#define FLT_LT(x,y) ((x) < (y) - FLT_EPS)\n+#define FLT_GE(x,y) ((x) >= (y) - FLT_EPS)\n+#define FLT_LE(x,y) ((x) <= (y) + FLT_EPS)\n+#define FLT_GT(x,y) ((x) > (y) + FLT_EPS)\n+\n+\/**\n+ * The MTLComposite class represents composite mode\n+ * *\/\n+\n+@interface MTLComposite : NSObject\n+- (id)init;\n+- (BOOL)isEqual:(MTLComposite *)other; \/\/ used to compare requested with cached\n+- (void)copyFrom:(MTLComposite *)other; \/\/ used to save cached\n+\n+- (void)setRule:(jint)rule; \/\/ sets extraAlpha=1\n+- (void)setRule:(jint)rule extraAlpha:(jfloat)extraAlpha;\n+- (void)reset;\n+\n+- (void)setXORComposite:(jint)color;\n+- (void)setAlphaComposite:(jint)rule;\n+\n+\n+- (jint)getCompositeState;\n+- (jint)getRule;\n+- (jint)getXorColor;\n+- (jfloat)getExtraAlpha;\n+\n+- (NSString *)getDescription; \/\/ creates autorelease string\n+@end\n+\n+#endif \/\/ MTLComposite_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLComposite.h","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLComposite.h\"\n+#include \"sun_java2d_SunGraphics2D.h\"\n+#include \"java_awt_AlphaComposite.h\"\n+\n+@implementation MTLComposite {\n+    jint _compState;\n+    jint _compositeRule;\n+    jint _xorPixel;\n+    jfloat _extraAlpha;\n+}\n+\n+- (id)init {\n+    self = [super init];\n+    if (self) {\n+        _compositeRule = -1;\n+        _compState = -1;\n+        _xorPixel = 0;\n+        _extraAlpha = 1;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLComposite *)other {\n+    if (self == other)\n+        return YES;\n+\n+    if (_compState == other->_compState) {\n+        if (_compState == sun_java2d_SunGraphics2D_COMP_XOR) {\n+            return _xorPixel == other->_xorPixel;\n+        }\n+\n+        if (_compState == sun_java2d_SunGraphics2D_COMP_ALPHA) {\n+            return _extraAlpha == other->_extraAlpha\n+                   && _compositeRule == other->_compositeRule;\n+        }\n+    }\n+\n+    return NO;\n+}\n+\n+- (void)copyFrom:(MTLComposite *)other {\n+    _extraAlpha = other->_extraAlpha;\n+    _compositeRule = other->_compositeRule;\n+    _compState = other->_compState;\n+    _xorPixel = other->_xorPixel;\n+}\n+\n+- (void)setRule:(jint)rule {\n+    _extraAlpha = 1.f;\n+    _compositeRule = rule;\n+}\n+\n+- (void)setRule:(jint)rule extraAlpha:(jfloat)extraAlpha {\n+    _compState = sun_java2d_SunGraphics2D_COMP_ALPHA;\n+    _extraAlpha = extraAlpha;\n+    _compositeRule = rule;\n+}\n+\n+- (void)reset {\n+    _compState = sun_java2d_SunGraphics2D_COMP_ISCOPY;\n+    _compositeRule = java_awt_AlphaComposite_SRC;\n+    _extraAlpha = 1.f;\n+}\n+\n+- (jint)getRule {\n+    return _compositeRule;\n+}\n+\n+- (NSString *)getDescription {\n+    const char * result = \"\";\n+    switch (_compositeRule) {\n+        case java_awt_AlphaComposite_CLEAR:\n+        {\n+            result = \"CLEAR\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_SRC:\n+        {\n+            result = \"SRC\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_DST:\n+        {\n+            result = \"DST\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_SRC_OVER:\n+        {\n+            result = \"SRC_OVER\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_DST_OVER:\n+        {\n+            result = \"DST_OVER\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_SRC_IN:\n+        {\n+            result = \"SRC_IN\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_DST_IN:\n+        {\n+            result = \"DST_IN\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_SRC_OUT:\n+        {\n+            result = \"SRC_OUT\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_DST_OUT:\n+        {\n+            result = \"DST_OUT\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_SRC_ATOP:\n+        {\n+            result = \"SRC_ATOP\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_DST_ATOP:\n+        {\n+            result = \"DST_ATOP\";\n+        }\n+            break;\n+        case java_awt_AlphaComposite_XOR:\n+        {\n+            result = \"XOR\";\n+        }\n+            break;\n+        default:\n+            result = \"UNKNOWN\";\n+            break;\n+    }\n+    const double epsilon = 0.001f;\n+    if (fabs(_extraAlpha - 1.f) > epsilon) {\n+        return [NSString stringWithFormat:@\"%s [%1.2f]\", result, _extraAlpha];\n+    }\n+    return [NSString stringWithFormat:@\"%s\", result];\n+}\n+\n+- (void)setAlphaComposite:(jint)rule {\n+    _compState = sun_java2d_SunGraphics2D_COMP_ALPHA;\n+    [self setRule:rule];\n+}\n+\n+\n+- (jint)getCompositeState {\n+    return _compState;\n+}\n+\n+\n+-(void)setXORComposite:(jint)color {\n+    _compState = sun_java2d_SunGraphics2D_COMP_XOR;\n+    _xorPixel = color;\n+}\n+\n+-(jint)getXorColor {\n+    return _xorPixel;\n+}\n+\n+- (jfloat)getExtraAlpha {\n+    return _extraAlpha;\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLComposite.m","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLContext_h_Included\n+#define MTLContext_h_Included\n+\n+#include \"sun_java2d_pipe_BufferedContext.h\"\n+#include \"sun_java2d_metal_MTLContext_MTLContextCaps.h\"\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"MTLTexturePool.h\"\n+#include \"MTLPipelineStatesStorage.h\"\n+#include \"MTLTransform.h\"\n+#include \"MTLComposite.h\"\n+#include \"MTLPaints.h\"\n+#include \"MTLClip.h\"\n+#include \"EncoderManager.h\"\n+\n+\/\/ Constant from\n+\/\/ https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf\n+#define MTL_GPU_FAMILY_MAC_TXT_SIZE 16384\n+\n+\/**\n+ * The MTLCommandBufferWrapper class contains command buffer and\n+ * associated resources that will be released in completion handler\n+ * *\/\n+@interface MTLCommandBufferWrapper : NSObject\n+- (id<MTLCommandBuffer>) getCommandBuffer;\n+- (void) onComplete; \/\/ invoked from completion handler in some pooled thread\n+- (void) registerPooledTexture:(MTLPooledTextureHandle *)handle;\n+@end\n+\n+\/**\n+ * The MTLContext class contains cached state relevant to the native\n+ * MTL context stored within the native ctxInfo field.  Each Java-level\n+ * MTLContext object is associated with a native-level MTLContext class.\n+ * *\/\n+@interface MTLContext : NSObject\n+@property (readonly) MTLComposite * composite;\n+@property (readwrite, retain) MTLPaint * paint;\n+@property (readonly) MTLTransform * transform;\n+@property (readonly) MTLClip * clip;\n+\n+@property jint          textureFunction;\n+@property jboolean      vertexCacheEnabled;\n+@property jboolean      aaEnabled;\n+\n+@property (readonly, strong)   id<MTLDevice>   device;\n+@property (strong) id<MTLCommandQueue>         commandQueue;\n+@property (strong) id<MTLCommandQueue>         blitCommandQueue;\n+@property (strong) id<MTLBuffer>               vertexBuffer;\n+\n+@property (readonly) EncoderManager * encoderManager;\n+\n+@property (strong)MTLPipelineStatesStorage*   pipelineStateStorage;\n+@property (strong)MTLTexturePool*             texturePool;\n+\n+- (MTLCommandBufferWrapper *) getCommandBufferWrapper; \/\/ creates command buffer wrapper (when doesn't exist)\n+- (MTLCommandBufferWrapper *) pullCommandBufferWrapper; \/\/ returns current buffer wrapper with loosing object ownership\n+\n+\/**\n+ * Fetches the MTLContext associated with the given destination surface,\n+ * makes the context current for those surfaces, updates the destination\n+ * viewport, and then returns a pointer to the MTLContext.\n+ *\/\n++ (MTLContext*) setSurfacesEnv:(JNIEnv*)env src:(jlong)pSrc dst:(jlong)pDst;\n+\n+- (id)initWithDevice:(id<MTLDevice>)d shadersLib:(NSString*)shadersLib;\n+- (void)dealloc;\n+\n+\/**\n+ * Resets the current clip state (disables both scissor and depth tests).\n+ *\/\n+- (void)resetClip;\n+\n+\/**\n+ * Sets the Metal scissor bounds to the provided rectangular clip bounds.\n+ *\/\n+- (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2;\n+\n+- (const MTLScissorRect *)clipRect;\n+\n+\/**\n+ * Sets up a complex (shape) clip using the Metal stencil buffer.  This\n+ * method prepares the stencil buffer so that the clip Region spans can\n+ * be \"rendered\" into it.  The stencil buffer is first cleared, then the\n+ * stencil func is setup so that when we render the clip spans,\n+ * nothing is rendered into the color buffer, but for each pixel that would\n+ * be rendered, a 0xFF value is placed into that location in the stencil\n+ * buffer.  With stencil test enabled, pixels will only be rendered into the\n+ * color buffer if the corresponding value at that (x,y) location in the\n+ * stencil buffer is equal to 0xFF.\n+ *\/\n+- (void)beginShapeClip:(BMTLSDOps *)dstOps;\n+\n+\/**\n+ * Finishes setting up the shape clip by resetting the stencil func\n+ * so that future rendering operations will once again be encoded for the\n+ * color buffer (while respecting the clip set up in the stencil buffer).\n+ *\/\n+- (void)endShapeClip:(BMTLSDOps *)dstOps;\n+\n+\/**\n+ * Resets all Metal compositing state (disables blending and logic\n+ * operations).\n+ *\/\n+- (void)resetComposite;\n+\n+\/**\n+ * Initializes the Metal blending state.  XOR mode is disabled and the\n+ * appropriate blend functions are setup based on the AlphaComposite rule\n+ * constant.\n+ *\/\n+- (void)setAlphaCompositeRule:(jint)rule extraAlpha:(jfloat)extraAlpha\n+                        flags:(jint)flags;\n+\n+\/**\n+ * Returns autorelease string with composite description (for debugging only)\n+ *\/\n+- (NSString*)getCompositeDescription;\n+\n+\/**\n+ * Returns autorelease string with paint description (for debugging only)\n+ *\/\n+- (NSString*)getPaintDescription;\n+\n+\/**\n+ * Initializes the Metal logic op state to XOR mode.  Blending is disabled\n+ * before enabling logic op mode.  The XOR pixel value will be applied\n+ * later in the MTLContext_SetColor() method.\n+ *\/\n+- (void)setXorComposite:(jint)xorPixel;\n+- (jboolean)useXORComposite;\n+\n+\/**\n+ * Resets the Metal transform state back to the identity matrix.\n+ *\/\n+- (void)resetTransform;\n+\n+\/**\n+ * Initializes the Metal transform state by setting the modelview transform\n+ * using the given matrix parameters.\n+ *\n+ * REMIND: it may be worthwhile to add serial id to AffineTransform, so we\n+ *         could do a quick check to see if the xform has changed since\n+ *         last time... a simple object compare won't suffice...\n+ *\/\n+- (void)setTransformM00:(jdouble) m00 M10:(jdouble) m10\n+                    M01:(jdouble) m01 M11:(jdouble) m11\n+                    M02:(jdouble) m02 M12:(jdouble) m12;\n+\n+\n+- (void)resetPaint;\n+- (void)setColorPaint:(int)pixel;\n+- (void)setGradientPaintUseMask:(jboolean)useMask\n+                         cyclic:(jboolean)cyclic\n+                             p0:(jdouble)p0\n+                             p1:(jdouble)p1\n+                             p3:(jdouble)p3\n+                         pixel1:(jint)pixel1\n+                         pixel2:(jint) pixel2;\n+- (void)setLinearGradientPaint:(jboolean)useMask\n+                   linear:(jboolean)linear\n+              cycleMethod:(jint)cycleMethod\n+                 numStops:(jint)numStops\n+                       p0:(jfloat)p0\n+                       p1:(jfloat)p1\n+                       p3:(jfloat)p3\n+                fractions:(jfloat *)fractions\n+                   pixels:(jint *)pixels;\n+- (void)setRadialGradientPaint:(jboolean)useMask\n+                   linear:(jboolean)linear\n+              cycleMethod:(jboolean)cycleMethod\n+                 numStops:(jint)numStops\n+                      m00:(jfloat)m00\n+                      m01:(jfloat)m01\n+                      m02:(jfloat)m02\n+                      m10:(jfloat)m10\n+                      m11:(jfloat)m11\n+                      m12:(jfloat)m12\n+                   focusX:(jfloat)focusX\n+                fractions:(void *)fractions\n+                   pixels:(void *)pixels;\n+- (void)setTexturePaint:(jboolean)useMask\n+           pSrcOps:(jlong)pSrcOps\n+            filter:(jboolean)filter\n+               xp0:(jdouble)xp0\n+               xp1:(jdouble)xp1\n+               xp3:(jdouble)xp3\n+               yp0:(jdouble)yp0\n+               yp1:(jdouble)yp1\n+               yp3:(jdouble)yp3;\n+\n+\/\/ Sets current image conversion operation (instance of MTLConvolveOp, MTLRescaleOp, MTLLookupOp).\n+\/\/ Used only in MTLIsoBlit (to blit image with some conversion). Pattern of usage: enableOp -> IsoBlit -> disableOp.\n+\/\/ TODO: Need to remove it from MTLContext and pass it as an argument for IsoBlit (because it's more\n+\/\/ simple and clear)\n+-(void)setBufImgOp:(NSObject*)bufImgOp;\n+\n+-(NSObject*)getBufImgOp;\n+\n+- (id<MTLCommandBuffer>)createCommandBuffer;\n+- (id<MTLCommandBuffer>)createBlitCommandBuffer;\n+@end\n+\n+\/**\n+ * See BufferedContext.java for more on these flags...\n+ *\/\n+#define MTLC_NO_CONTEXT_FLAGS \\\n+    sun_java2d_pipe_BufferedContext_NO_CONTEXT_FLAGS\n+#define MTLC_SRC_IS_OPAQUE    \\\n+    sun_java2d_pipe_BufferedContext_SRC_IS_OPAQUE\n+#define MTLC_USE_MASK         \\\n+    sun_java2d_pipe_BufferedContext_USE_MASK\n+\n+#endif \/* MTLContext_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.h","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,439 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+\n+#include \"sun_java2d_SunGraphics2D.h\"\n+\n+#include \"jlong.h\"\n+#import \"MTLContext.h\"\n+#include \"MTLRenderQueue.h\"\n+\n+\n+extern jboolean MTLSD_InitMTLWindow(JNIEnv *env, MTLSDOps *mtlsdo);\n+\n+static struct TxtVertex verts[PGRAM_VERTEX_COUNT] = {\n+        {{-1.0, 1.0}, {0.0, 0.0}},\n+        {{1.0, 1.0}, {1.0, 0.0}},\n+        {{1.0, -1.0}, {1.0, 1.0}},\n+        {{1.0, -1.0}, {1.0, 1.0}},\n+        {{-1.0, -1.0}, {0.0, 1.0}},\n+        {{-1.0, 1.0}, {0.0, 0.0}}\n+};\n+\n+MTLTransform* tempTransform = nil;\n+\n+@implementation MTLCommandBufferWrapper {\n+    id<MTLCommandBuffer> _commandBuffer;\n+    NSMutableArray * _pooledTextures;\n+    NSLock* _lock;\n+}\n+\n+- (id) initWithCommandBuffer:(id<MTLCommandBuffer>)cmdBuf {\n+    self = [super init];\n+    if (self) {\n+        _commandBuffer = [cmdBuf retain];\n+        _pooledTextures = [[NSMutableArray alloc] init];\n+        _lock = [[NSLock alloc] init];\n+    }\n+    return self;\n+}\n+\n+- (id<MTLCommandBuffer>) getCommandBuffer {\n+    return _commandBuffer;\n+}\n+\n+- (void) onComplete { \/\/ invoked from completion handler in some pooled thread\n+    [_lock lock];\n+    @try {\n+        for (int c = 0; c < [_pooledTextures count]; ++c)\n+            [[_pooledTextures objectAtIndex:c] releaseTexture];\n+        [_pooledTextures removeAllObjects];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+\n+}\n+\n+- (void) registerPooledTexture:(MTLPooledTextureHandle *)handle {\n+    [_lock lock];\n+    @try {\n+        [_pooledTextures addObject:handle];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+}\n+\n+- (void) dealloc {\n+    [self onComplete];\n+\n+    [_pooledTextures release];\n+    [_commandBuffer release];\n+    [_lock release];\n+    [super dealloc];\n+}\n+\n+@end\n+\n+@implementation MTLContext {\n+    MTLCommandBufferWrapper * _commandBufferWrapper;\n+\n+    MTLComposite *     _composite;\n+    MTLPaint *         _paint;\n+    MTLTransform *     _transform;\n+    MTLTransform *     _tempTransform;\n+    MTLClip *          _clip;\n+    NSObject*          _bufImgOp; \/\/ TODO: pass as parameter of IsoBlit\n+\n+    EncoderManager * _encoderManager;\n+}\n+\n+@synthesize textureFunction,\n+            vertexCacheEnabled, aaEnabled, device, pipelineStateStorage,\n+            commandQueue, blitCommandQueue, vertexBuffer,\n+            texturePool, paint=_paint;\n+\n+extern void initSamplers(id<MTLDevice> device);\n+\n+- (id)initWithDevice:(id<MTLDevice>)d shadersLib:(NSString*)shadersLib {\n+    self = [super init];\n+    if (self) {\n+        \/\/ Initialization code here.\n+        device = d;\n+\n+        pipelineStateStorage = [[MTLPipelineStatesStorage alloc] initWithDevice:device shaderLibPath:shadersLib];\n+        if (pipelineStateStorage == nil) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLContext.initWithDevice(): Failed to initialize MTLPipelineStatesStorage.\");\n+            return nil;\n+        }\n+\n+        texturePool = [[MTLTexturePool alloc] initWithDevice:device];\n+\n+        vertexBuffer = [device newBufferWithBytes:verts\n+                                           length:sizeof(verts)\n+                                          options:MTLResourceCPUCacheModeDefaultCache];\n+\n+        _encoderManager = [[EncoderManager alloc] init];\n+        [_encoderManager setContext:self];\n+        _composite = [[MTLComposite alloc] init];\n+        _paint = [[MTLPaint alloc] init];\n+        _transform = [[MTLTransform alloc] init];\n+        _clip = [[MTLClip alloc] init];\n+        _bufImgOp = nil;\n+\n+        _commandBufferWrapper = nil;\n+\n+        \/\/ Create command queue\n+        commandQueue = [device newCommandQueue];\n+        blitCommandQueue = [device newCommandQueue];\n+\n+        _tempTransform = [[MTLTransform alloc] init];\n+\n+        initSamplers(device);\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.dealloc\");\n+\n+    self.texturePool = nil;\n+    self.vertexBuffer = nil;\n+    self.commandQueue = nil;\n+    self.blitCommandQueue = nil;\n+    self.pipelineStateStorage = nil;\n+    [_encoderManager release];\n+    [_composite release];\n+    [_paint release];\n+    [_transform release];\n+    [_tempTransform release];\n+    [_clip release];\n+    [super dealloc];\n+}\n+\n+ - (MTLCommandBufferWrapper *) getCommandBufferWrapper {\n+    if (_commandBufferWrapper == nil) {\n+        J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLContext : commandBuffer is NULL\");\n+        \/\/ NOTE: Command queues are thread-safe and allow multiple outstanding command buffers to be encoded simultaneously.\n+        _commandBufferWrapper = [[MTLCommandBufferWrapper alloc] initWithCommandBuffer:[self.commandQueue commandBuffer]];\/\/ released in [layer blitTexture]\n+    }\n+    return _commandBufferWrapper;\n+}\n+\n+- (MTLCommandBufferWrapper *) pullCommandBufferWrapper {\n+    MTLCommandBufferWrapper * result = _commandBufferWrapper;\n+    _commandBufferWrapper = nil;\n+    return result;\n+}\n+\n++ (MTLContext*) setSurfacesEnv:(JNIEnv*)env src:(jlong)pSrc dst:(jlong)pDst {\n+    BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrc);\n+    BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);\n+    MTLContext *mtlc = NULL;\n+\n+    if (srcOps == NULL || dstOps == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLContext_SetSurfaces: ops are null\");\n+        return NULL;\n+    }\n+\n+    J2dTraceLn6(J2D_TRACE_VERBOSE, \"MTLContext_SetSurfaces: bsrc=%p (tex=%p type=%d), bdst=%p (tex=%p type=%d)\", srcOps, srcOps->pTexture, srcOps->drawableType, dstOps, dstOps->pTexture, dstOps->drawableType);\n+\n+    if (dstOps->drawableType == MTLSD_TEXTURE) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                      \"MTLContext_SetSurfaces: texture cannot be used as destination\");\n+        return NULL;\n+    }\n+\n+    if (dstOps->drawableType == MTLSD_UNDEFINED) {\n+        \/\/ initialize the surface as an MTLSD_WINDOW\n+        if (!MTLSD_InitMTLWindow(env, dstOps)) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                          \"MTLContext_SetSurfaces: could not init OGL window\");\n+            return NULL;\n+        }\n+    }\n+\n+    \/\/ make the context current\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    mtlc = dstMTLOps->configInfo->context;\n+\n+    if (mtlc == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                      \"MTLContext_SetSurfaces: could not make context current\");\n+        return NULL;\n+    }\n+\n+    return mtlc;\n+}\n+\n+- (void)resetClip {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.resetClip\");\n+    [_clip reset];\n+}\n+\n+- (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2 {\n+    J2dTraceLn4(J2D_TRACE_INFO, \"MTLContext.setClipRect: %d,%d - %d,%d\", x1, y1, x2, y2);\n+    [_clip setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];\n+}\n+\n+- (void)beginShapeClip:(BMTLSDOps *)dstOps {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.beginShapeClip\");\n+    [_clip beginShapeClip:dstOps context:self];\n+\n+    \/\/ Store the current transform as we need to use identity transform\n+    \/\/ for clip spans rendering\n+    [_tempTransform copyFrom:_transform];\n+    [self resetTransform];\n+}\n+\n+- (void)endShapeClip:(BMTLSDOps *)dstOps {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.endShapeClip\");\n+    [_clip endShapeClip:dstOps context:self];\n+\n+    \/\/ Reset transform for further rendering\n+    [_transform copyFrom:_tempTransform];\n+}\n+\n+- (void)resetComposite {\n+    J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLContext_ResetComposite\");\n+    [_composite reset];\n+}\n+\n+- (void)setAlphaCompositeRule:(jint)rule extraAlpha:(jfloat)extraAlpha\n+                        flags:(jint)flags {\n+    J2dTraceLn3(J2D_TRACE_INFO, \"MTLContext_SetAlphaComposite: rule=%d, extraAlpha=%1.2f, flags=%d\", rule, extraAlpha, flags);\n+\n+    [_composite setRule:rule extraAlpha:extraAlpha];\n+}\n+\n+- (NSString*)getCompositeDescription {\n+    return [_composite getDescription];\n+}\n+\n+- (NSString*)getPaintDescription {\n+    return [_paint getDescription];\n+}\n+\n+- (void)setXorComposite:(jint)xp {\n+    J2dTraceLn1(J2D_TRACE_INFO, \"MTLContext.setXorComposite: xorPixel=%08x\", xp);\n+\n+    [_composite setXORComposite:xp];\n+}\n+\n+- (jboolean) useXORComposite {\n+    return ([_composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR);\n+}\n+\n+- (void)resetTransform {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext_ResetTransform\");\n+    [_transform resetTransform];\n+}\n+\n+- (void)setTransformM00:(jdouble) m00 M10:(jdouble) m10\n+                    M01:(jdouble) m01 M11:(jdouble) m11\n+                    M02:(jdouble) m02 M12:(jdouble) m12 {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext_SetTransform\");\n+    [_transform setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];\n+}\n+\n+- (void)resetPaint {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.resetPaint\");\n+    self.paint = [[[MTLPaint alloc] init] autorelease];\n+}\n+\n+- (void)setColorPaint:(int)pixel {\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLContext.setColorPaint: pixel=%08x [r=%d g=%d b=%d a=%d]\", pixel, (pixel >> 16) & (0xFF), (pixel >> 8) & 0xFF, (pixel) & 0xFF, (pixel >> 24) & 0xFF);\n+    self.paint = [[[MTLColorPaint alloc] initWithColor:pixel] autorelease];\n+}\n+\n+- (void)setGradientPaintUseMask:(jboolean)useMask\n+                         cyclic:(jboolean)cyclic\n+                             p0:(jdouble)p0\n+                             p1:(jdouble)p1\n+                             p3:(jdouble)p3\n+                         pixel1:(jint)pixel1\n+                         pixel2:(jint) pixel2\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.setGradientPaintUseMask\");\n+    self.paint = [[[MTLGradPaint alloc] initWithUseMask:useMask\n+                                                cyclic:cyclic\n+                                                    p0:p0\n+                                                    p1:p1\n+                                                    p3:p3\n+                                                pixel1:pixel1\n+                                                pixel2:pixel2] autorelease];\n+}\n+\n+- (void)setLinearGradientPaint:(jboolean)useMask\n+                        linear:(jboolean)linear\n+                   cycleMethod:(jint)cycleMethod\n+                                \/\/ 0 - NO_CYCLE\n+                                \/\/ 1 - REFLECT\n+                                \/\/ 2 - REPEAT\n+\n+                      numStops:(jint)numStops\n+                            p0:(jfloat)p0\n+                            p1:(jfloat)p1\n+                            p3:(jfloat)p3\n+                     fractions:(jfloat*)fractions\n+                        pixels:(jint*)pixels\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.setLinearGradientPaint\");\n+    self.paint = [[[MTLLinearGradPaint alloc] initWithUseMask:useMask\n+                       linear:linear\n+                  cycleMethod:cycleMethod\n+                     numStops:numStops\n+                           p0:p0\n+                           p1:p1\n+                           p3:p3\n+                    fractions:fractions\n+                       pixels:pixels] autorelease];\n+}\n+\n+- (void)setRadialGradientPaint:(jboolean)useMask\n+                        linear:(jboolean)linear\n+                   cycleMethod:(jboolean)cycleMethod\n+                      numStops:(jint)numStops\n+                           m00:(jfloat)m00\n+                           m01:(jfloat)m01\n+                           m02:(jfloat)m02\n+                           m10:(jfloat)m10\n+                           m11:(jfloat)m11\n+                           m12:(jfloat)m12\n+                        focusX:(jfloat)focusX\n+                     fractions:(void *)fractions\n+                        pixels:(void *)pixels\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext.setRadialGradientPaint\");\n+    self.paint = [[[MTLRadialGradPaint alloc] initWithUseMask:useMask\n+                                                      linear:linear\n+                                                 cycleMethod:cycleMethod\n+                                                    numStops:numStops\n+                                                         m00:m00\n+                                                         m01:m01\n+                                                         m02:m02\n+                                                         m10:m10\n+                                                         m11:m11\n+                                                         m12:m12\n+                                                      focusX:focusX\n+                                                   fractions:fractions\n+                                                      pixels:pixels] autorelease];\n+}\n+\n+- (void)setTexturePaint:(jboolean)useMask\n+                pSrcOps:(jlong)pSrcOps\n+                 filter:(jboolean)filter\n+                    xp0:(jdouble)xp0\n+                    xp1:(jdouble)xp1\n+                    xp3:(jdouble)xp3\n+                    yp0:(jdouble)yp0\n+                    yp1:(jdouble)yp1\n+                    yp3:(jdouble)yp3\n+{\n+    BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);\n+\n+    if (srcOps == NULL || srcOps->pTexture == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLContext_setTexturePaint: texture paint - texture is null\");\n+        return;\n+    }\n+\n+    J2dTraceLn1(J2D_TRACE_INFO, \"MTLContext.setTexturePaint [tex=%p]\", srcOps->pTexture);\n+\n+    self.paint = [[[MTLTexturePaint alloc] initWithUseMask:useMask\n+                                                textureID:srcOps->pTexture\n+                                                  isOpaque:srcOps->isOpaque\n+                                                   filter:filter\n+                                                      xp0:xp0\n+                                                      xp1:xp1\n+                                                      xp3:xp3\n+                                                      yp0:yp0\n+                                                      yp1:yp1\n+                                                      yp3:yp3] autorelease];\n+}\n+\n+- (id<MTLCommandBuffer>)createCommandBuffer {\n+    return [self.commandQueue commandBuffer];\n+}\n+\n+\/*\n+ * This should be exclusively used only for final blit\n+ * and present of CAMetalDrawable in MTLLayer\n+ *\/\n+- (id<MTLCommandBuffer>)createBlitCommandBuffer {\n+    return [self.blitCommandQueue commandBuffer];\n+}\n+\n+-(void)setBufImgOp:(NSObject*)bufImgOp {\n+    if (_bufImgOp != nil) {\n+        [_bufImgOp release]; \/\/ context owns bufImgOp object\n+    }\n+    _bufImgOp = bufImgOp;\n+}\n+\n+-(NSObject*)getBufImgOp {\n+    return _bufImgOp;\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":439,"deletions":0,"binary":false,"changes":439,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLGlyphCache_h_Included\n+#define MTLGlyphCache_h_Included\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include \"jni.h\"\n+#include \"fontscalerdefs.h\"\n+#import <Metal\/Metal.h>\n+\n+typedef void (MTLFlushFunc)();\n+\n+typedef struct _MTLCacheCellInfo MTLCacheCellInfo;\n+\n+typedef struct {\n+    CacheCellInfo *head;\n+    CacheCellInfo *tail;\n+    id<MTLTexture> texture;\n+    jint          width;\n+    jint          height;\n+    jint          cellWidth;\n+    jint          cellHeight;\n+    MTLFlushFunc     *Flush;\n+} MTLGlyphCacheInfo;\n+\n+struct _MTLCacheCellInfo {\n+    MTLGlyphCacheInfo   *cacheInfo;\n+    struct GlyphInfo *glyphInfo;\n+    \/\/ next cell info in the cache's list\n+    MTLCacheCellInfo    *next;\n+    \/\/ REMIND: find better name?\n+    \/\/ next cell info in the glyph's cell list (next Glyph Cache Info)\n+    MTLCacheCellInfo    *nextGCI;\n+    jint             timesRendered;\n+    jint             x;\n+    jint             y;\n+    \/\/ number of pixels from the left or right edge not considered touched\n+    \/\/ by the glyph\n+    jint             leftOff;\n+    jint             rightOff;\n+    jfloat           tx1;\n+    jfloat           ty1;\n+    jfloat           tx2;\n+    jfloat           ty2;\n+};\n+\n+MTLGlyphCacheInfo *\n+MTLGlyphCache_Init(jint width, jint height,\n+                     jint cellWidth, jint cellHeight,\n+                     MTLFlushFunc *func);\n+MTLCacheCellInfo *\n+MTLGlyphCache_AddGlyph(MTLGlyphCacheInfo *cache, struct GlyphInfo *glyph);\n+bool\n+MTLGlyphCache_IsCacheFull(MTLGlyphCacheInfo *cache, GlyphInfo *glyph);\n+void\n+MTLGlyphCache_Invalidate(MTLGlyphCacheInfo *cache);\n+void\n+MTLGlyphCache_AddCellInfo(struct GlyphInfo *glyph, MTLCacheCellInfo *cellInfo);\n+void\n+MTLGlyphCache_RemoveCellInfo(struct GlyphInfo *glyph, MTLCacheCellInfo *cellInfo);\n+MTLCacheCellInfo *\n+MTLGlyphCache_GetCellInfoForCache(struct GlyphInfo *glyph,\n+                                    MTLGlyphCacheInfo *cache);\n+JNIEXPORT void\n+MTLGlyphCache_RemoveAllCellInfos(struct GlyphInfo *glyph);\n+void\n+MTLGlyphCache_Free(MTLGlyphCacheInfo *cache);\n+\n+#ifdef __cplusplus\n+};\n+#endif\n+\n+#endif \/* MTLGlyphCache_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGlyphCache.h","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include \"jni.h\"\n+#include \"MTLGlyphCache.h\"\n+#include \"Trace.h\"\n+\n+\/**\n+ * When the cache is full, we will try to reuse the cache cells that have\n+ * been used relatively less than the others (and we will save the cells that\n+ * have been rendered more than the threshold defined here).\n+ *\/\n+#define TIMES_RENDERED_THRESHOLD 5\n+\n+\/**\n+ * Creates a new GlyphCacheInfo structure, fills in the initial values, and\n+ * then returns a pointer to the GlyphCacheInfo record.\n+ *\n+ * Note that this method only sets up a data structure describing a\n+ * rectangular region of accelerated memory, containing \"virtual\" cells of\n+ * the requested size.  The cell information is added lazily to the linked\n+ * list describing the cache as new glyphs are added.  Platform specific\n+ * glyph caching code is responsible for actually creating the accelerated\n+ * memory surface that will contain the individual glyph images.\n+ *\n+ * Each glyph contains a reference to a list of cell infos - one per glyph\n+ * cache. There may be multiple glyph caches (for example, one per graphics\n+ * adapter), so if the glyph is cached on two devices its cell list will\n+ * consists of two elements corresponding to different glyph caches.\n+ *\n+ * The platform-specific glyph caching code is supposed to use\n+ * GetCellInfoForCache method for retrieving cache infos from the glyph's list.\n+ *\n+ * Note that if it is guaranteed that there will be only one global glyph\n+ * cache then it one does not have to use AccelGlyphCache_GetCellInfoForCache\n+ * for retrieving cell info for the glyph, but instead just use the struct's\n+ * field directly.\n+ *\/\n+MTLGlyphCacheInfo *\n+MTLGlyphCache_Init(jint width, jint height,\n+                     jint cellWidth, jint cellHeight,\n+                     MTLFlushFunc *func)\n+{\n+    MTLGlyphCacheInfo *gcinfo;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_Init\");\n+\n+    gcinfo = (MTLGlyphCacheInfo *)malloc(sizeof(MTLGlyphCacheInfo));\n+    if (gcinfo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+            \"MTLGlyphCache_Init: could not allocate MTLGlyphCacheInfo\");\n+        return NULL;\n+    }\n+\n+    gcinfo->head = NULL;\n+    gcinfo->tail = NULL;\n+    gcinfo->width = width;\n+    gcinfo->height = height;\n+    gcinfo->cellWidth = cellWidth;\n+    gcinfo->cellHeight = cellHeight;\n+    gcinfo->Flush = func;\n+\n+    return gcinfo;\n+}\n+\n+\/**\n+ * Attempts to add the provided glyph to the specified cache.  If the\n+ * operation is successful, a pointer to the newly occupied cache cell is\n+ * stored in the glyph's cellInfo field; otherwise, its cellInfo field is\n+ * set to NULL, indicating that the glyph's original bits should be rendered\n+ * instead.  If the cache is full, the least-recently-used glyph is\n+ * invalidated and its cache cell is reassigned to the new glyph being added.\n+ *\n+ * Note that this method only ensures that a rectangular region in the\n+ * \"virtual\" glyph cache is available for the glyph image.  Platform specific\n+ * glyph caching code is responsible for actually caching the glyph image\n+ * in the associated accelerated memory surface.\n+ *\n+ * Returns created cell info if it was successfully created and added to the\n+ * cache and glyph's cell lists, NULL otherwise.\n+ *\/\n+MTLCacheCellInfo *\n+MTLGlyphCache_AddGlyph(MTLGlyphCacheInfo *cache, GlyphInfo *glyph)\n+{\n+    MTLCacheCellInfo *cellinfo = NULL;\n+    jint w = glyph->width;\n+    jint h = glyph->height;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_AddGlyph\");\n+\n+    if ((glyph->width > cache->cellWidth) ||\n+        (glyph->height > cache->cellHeight))\n+    {\n+        return NULL;\n+    }\n+\n+    jint x, y;\n+\n+    if (cache->head == NULL) {\n+        x = 0;\n+        y = 0;\n+    } else {\n+        x = cache->tail->x + cache->cellWidth;\n+        y = cache->tail->y;\n+        if ((x + cache->cellWidth) > cache->width) {\n+            x = 0;\n+            y += cache->cellHeight;\n+        }\n+    }\n+\n+    \/\/ create new CacheCellInfo\n+    cellinfo = (MTLCacheCellInfo *)malloc(sizeof(MTLCacheCellInfo));\n+    if (cellinfo == NULL) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"could not allocate CellInfo\");\n+        return NULL;\n+    }\n+\n+    cellinfo->cacheInfo = cache;\n+    cellinfo->glyphInfo = glyph;\n+    cellinfo->timesRendered = 0;\n+    cellinfo->x = x;\n+    cellinfo->y = y;\n+    cellinfo->leftOff = 0;\n+    cellinfo->rightOff = 0;\n+    cellinfo->tx1 = (jfloat)cellinfo->x \/ cache->width;\n+    cellinfo->ty1 = (jfloat)cellinfo->y \/ cache->height;\n+    cellinfo->tx2 = cellinfo->tx1 + ((jfloat)w \/ cache->width);\n+    cellinfo->ty2 = cellinfo->ty1 + ((jfloat)h \/ cache->height);\n+\n+    if (cache->head == NULL) {\n+        \/\/ initialize the head cell\n+        cache->head = cellinfo;\n+    } else {\n+        \/\/ update existing tail cell\n+        cache->tail->next = cellinfo;\n+    }\n+\n+    \/\/ add the new cell to the end of the list\n+    cache->tail = cellinfo;\n+    cellinfo->next = NULL;\n+    cellinfo->nextGCI = NULL;\n+\n+    \/\/ add cache cell to the glyph's cells list\n+    MTLGlyphCache_AddCellInfo(glyph, cellinfo);\n+    return cellinfo;\n+}\n+\n+\n+bool\n+MTLGlyphCache_IsCacheFull(MTLGlyphCacheInfo *cache, GlyphInfo *glyph)\n+{\n+    jint w = glyph->width;\n+    jint h = glyph->height;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_IsCacheFull\");\n+\n+    jint x, y;\n+\n+    if (cache->head == NULL) {\n+        return JNI_FALSE;\n+    } else {\n+        x = cache->tail->x + cache->cellWidth;\n+        y = cache->tail->y;\n+        if ((x + cache->cellWidth) > cache->width) {\n+            x = 0;\n+            y += cache->cellHeight;\n+            if ((y + cache->cellHeight) > cache->height) {\n+                return JNI_TRUE;\n+            }\n+        }\n+    }\n+    return JNI_FALSE;\n+}\n+\/**\n+ * Invalidates all cells in the cache.  Note that this method does not\n+ * attempt to compact the cache in any way; it just invalidates any cells\n+ * that already exist.\n+ *\/\n+void\n+MTLGlyphCache_Invalidate(MTLGlyphCacheInfo *cache)\n+{\n+    MTLCacheCellInfo *cellinfo;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_Invalidate\");\n+\n+    if (cache == NULL) {\n+        return;\n+    }\n+\n+    \/\/ flush any pending vertices that may be depending on the current\n+    \/\/ glyph cache layout\n+    if (cache->Flush != NULL) {\n+        cache->Flush();\n+    }\n+\n+    cellinfo = cache->head;\n+    while (cellinfo != NULL) {\n+        if (cellinfo->glyphInfo != NULL) {\n+            \/\/ if the cell is occupied, notify the base glyph that its\n+            \/\/ cached version for this cache is about to be invalidated\n+            MTLGlyphCache_RemoveCellInfo(cellinfo->glyphInfo, cellinfo);\n+        }\n+        cellinfo = cellinfo->next;\n+    }\n+}\n+\n+\/**\n+ * Invalidates and frees all cells and the cache itself. The \"cache\" pointer\n+ * becomes invalid after this function returns.\n+ *\/\n+void\n+MTLGlyphCache_Free(MTLGlyphCacheInfo *cache)\n+{\n+    MTLCacheCellInfo *cellinfo;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_Free\");\n+\n+    if (cache == NULL) {\n+        return;\n+    }\n+\n+    \/\/ flush any pending vertices that may be depending on the current\n+    \/\/ glyph cache\n+    if (cache->Flush != NULL) {\n+        cache->Flush();\n+    }\n+\n+    while (cache->head != NULL) {\n+        cellinfo = cache->head;\n+        if (cellinfo->glyphInfo != NULL) {\n+            \/\/ if the cell is occupied, notify the base glyph that its\n+            \/\/ cached version for this cache is about to be invalidated\n+            MTLGlyphCache_RemoveCellInfo(cellinfo->glyphInfo, cellinfo);\n+        }\n+        cache->head = cellinfo->next;\n+        free(cellinfo);\n+    }\n+    free(cache);\n+}\n+\n+\/**\n+ * Add cell info to the head of the glyph's list of cached cells.\n+ *\/\n+void\n+MTLGlyphCache_AddCellInfo(GlyphInfo *glyph, MTLCacheCellInfo *cellInfo)\n+{\n+    \/\/ assert (glyph != NULL && cellInfo != NULL)\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_AddCellInfo\");\n+    J2dTraceLn2(J2D_TRACE_VERBOSE, \"  glyph 0x%x: adding cell 0x%x to the list\",\n+                glyph, cellInfo);\n+\n+    cellInfo->glyphInfo = glyph;\n+    cellInfo->nextGCI = glyph->cellInfo;\n+    glyph->cellInfo = cellInfo;\n+    glyph->managed = MANAGED_GLYPH;\n+}\n+\n+\/**\n+ * Removes cell info from the glyph's list of cached cells.\n+ *\/\n+void\n+MTLGlyphCache_RemoveCellInfo(GlyphInfo *glyph, MTLCacheCellInfo *cellInfo)\n+{\n+    MTLCacheCellInfo *currCellInfo = glyph->cellInfo;\n+    MTLCacheCellInfo *prevInfo = NULL;\n+    \/\/ assert (glyph!= NULL && glyph->cellInfo != NULL && cellInfo != NULL)\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_RemoveCellInfo\");\n+    do {\n+        if (currCellInfo == cellInfo) {\n+            J2dTraceLn2(J2D_TRACE_VERBOSE,\n+                        \"  glyph 0x%x: removing cell 0x%x from glyph's list\",\n+                        glyph, currCellInfo);\n+            if (prevInfo == NULL) { \/\/ it's the head, chop-chop\n+                glyph->cellInfo = currCellInfo->nextGCI;\n+            } else {\n+                prevInfo->nextGCI = currCellInfo->nextGCI;\n+            }\n+            currCellInfo->glyphInfo = NULL;\n+            currCellInfo->nextGCI = NULL;\n+            return;\n+        }\n+        prevInfo = currCellInfo;\n+        currCellInfo = currCellInfo->nextGCI;\n+    } while (currCellInfo != NULL);\n+    J2dTraceLn2(J2D_TRACE_WARNING, \"MTLGlyphCache_RemoveCellInfo: \"\\\n+                \"no cell 0x%x in glyph 0x%x's cell list\",\n+                cellInfo, glyph);\n+}\n+\n+\/**\n+ * Removes cell info from the glyph's list of cached cells.\n+ *\/\n+JNIEXPORT void\n+MTLGlyphCache_RemoveAllCellInfos(GlyphInfo *glyph)\n+{\n+    MTLCacheCellInfo *currCell, *prevCell;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGlyphCache_RemoveAllCellInfos\");\n+\n+    if (glyph == NULL || glyph->cellInfo == NULL) {\n+        return;\n+    }\n+\n+    \/\/ invalidate all of this glyph's accelerated cache cells\n+    currCell = glyph->cellInfo;\n+    do {\n+        currCell->glyphInfo = NULL;\n+        prevCell = currCell;\n+        currCell = currCell->nextGCI;\n+        prevCell->nextGCI = NULL;\n+    } while (currCell != NULL);\n+\n+    glyph->cellInfo = NULL;\n+}\n+\n+\/**\n+ * Returns cell info associated with particular cache from the glyph's list of\n+ * cached cells.\n+ *\/\n+MTLCacheCellInfo *\n+MTLGlyphCache_GetCellInfoForCache(GlyphInfo *glyph, MTLGlyphCacheInfo *cache)\n+{\n+    \/\/ assert (glyph != NULL && cache != NULL)\n+    J2dTraceLn(J2D_TRACE_VERBOSE2, \"MTLGlyphCache_GetCellInfoForCache\");\n+\n+    if (glyph->cellInfo != NULL) {\n+        MTLCacheCellInfo *cellInfo = glyph->cellInfo;\n+        do {\n+            if (cellInfo->cacheInfo == cache) {\n+                J2dTraceLn3(J2D_TRACE_VERBOSE2,\n+                            \"  glyph 0x%x: found cell 0x%x for cache 0x%x\",\n+                            glyph, cellInfo, cache);\n+                return cellInfo;\n+            }\n+            cellInfo = cellInfo->nextGCI;\n+        } while (cellInfo != NULL);\n+    }\n+    J2dTraceLn2(J2D_TRACE_VERBOSE2, \"  glyph 0x%x: no cell for cache 0x%x\",\n+                glyph, cache);\n+    return NULL;\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGlyphCache.m","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLGraphicsConfig_h_Included\n+#define MTLGraphicsConfig_h_Included\n+\n+#import \"JNIUtilities.h\"\n+#import \"MTLSurfaceDataBase.h\"\n+#import \"MTLContext.h\"\n+#import <Cocoa\/Cocoa.h>\n+#import <Metal\/Metal.h>\n+\n+\n+@interface MTLGraphicsConfigUtil : NSObject {}\n++ (void) _getMTLConfigInfo: (NSMutableArray *)argValue;\n+@end\n+\n+\/**\n+ * The MTLGraphicsConfigInfo structure contains information specific to a\n+ * given MTLGraphicsConfig (pixel format).\n+ *     MTLContext *context;\n+ * The context associated with this MTLGraphicsConfig.\n+ *\/\n+typedef struct _MTLGraphicsConfigInfo {\n+    MTLContext          *context;\n+} MTLGraphicsConfigInfo;\n+\n+\/\/ From \"Metal Feature Set Tables\"\n+\/\/ There are 2 GPU families for mac - MTLGPUFamilyMac1 and MTLGPUFamilyMac2\n+\/\/ Both of them support \"Maximum 2D texture width and height\" of 16384 pixels\n+\/\/ Note : there is no API to get this value, hence hardcoding by reading from the table\n+#define MaxTextureSize 16384\n+\n+#endif \/* MTLGraphicsConfig_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.h","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"sun_java2d_metal_MTLGraphicsConfig.h\"\n+\n+#import \"MTLGraphicsConfig.h\"\n+#import \"MTLSurfaceData.h\"\n+#import \"ThreadUtilities.h\"\n+#import \"awt.h\"\n+#import \"MTLUtils.h\"\n+\n+\n+#import <stdlib.h>\n+#import <string.h>\n+#import <ApplicationServices\/ApplicationServices.h>\n+\n+#pragma mark -\n+#pragma mark \"--- Mac OS X specific methods for Metal pipeline ---\"\n+\n+\/\/ Uncomment this line to see Metal specific fprintfs\n+\/\/#define METAL_DEBUG\n+\n+\/**\n+ * Disposes all memory and resources associated with the given\n+ * MTLGraphicsConfigInfo (including its native MTLContext data).\n+ *\/\n+void\n+MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGC_DestroyMTLGraphicsConfig\");\n+\n+    MTLGraphicsConfigInfo *mtlinfo =\n+        (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);\n+    if (mtlinfo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                      \"MTLGC_DestroyMTLGraphicsConfig: info is null\");\n+        return;\n+    }\n+\n+    MTLContext *mtlc = (MTLContext*)mtlinfo->context;\n+    if (mtlc != NULL) {\n+        [mtlinfo->context release];\n+        mtlinfo->context = nil;\n+    }\n+    free(mtlinfo);\n+}\n+\n+#pragma mark -\n+#pragma mark \"--- MTLGraphicsConfig methods ---\"\n+\n+\n+\/**\n+ * Probe Metal framework availability using system profiler\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_sun_java2d_metal_MTLGraphicsConfig_isMetalFrameworkAvailable\n+    (JNIEnv *env, jclass mtlgc)\n+{\n+    FILE *f = popen(\"\/usr\/sbin\/system_profiler SPDisplaysDataType\", \"r\");\n+    jboolean metalSupported = JNI_FALSE;\n+    while (getc(f) != EOF)\n+    {\n+        char str[60];\n+\n+        if (fgets(str, 60, f) != NULL) {\n+            \/\/ Check for string\n+            \/\/ \"Metal:  Supported, feature set macOS GPUFamily1 v4\"\n+            if (strstr(str, \"Metal\") != NULL) {\n+                \/\/puts(str);\n+                metalSupported = JNI_TRUE;\n+                break;\n+            }\n+        }\n+    }\n+    pclose(f);\n+\n+#ifdef METAL_DEBUG\n+    if (!metalSupported) {\n+        fprintf(stderr, \"Metal support not present\\n\");\n+    } else {\n+        fprintf(stderr, \"Metal support is present\\n\");\n+    }\n+#endif\n+\n+    J2dRlsTraceLn1(J2D_TRACE_INFO, \"MTLGraphicsConfig_isMetalFrameworkAvailable : %d\", metalSupported);\n+\n+    return metalSupported;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_java2d_metal_MTLGraphicsConfig_tryLoadMetalLibrary\n+    (JNIEnv *env, jclass mtlgc, jint displayID, jstring shadersLibName)\n+{\n+    jboolean ret = JNI_FALSE;\n+    JNI_COCOA_ENTER(env);\n+    NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];\n+    [retArray addObject: [NSNumber numberWithInt: (int)displayID]];\n+    char *str = JNU_GetStringPlatformChars(env, shadersLibName, 0);\n+    [retArray addObject: [NSString stringWithUTF8String: str]];\n+\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n+        [MTLGraphicsConfigUtil _tryLoadMetalLibrary: retArray];\n+    }];\n+\n+    NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];\n+    ret = (jboolean)[num boolValue];\n+    JNU_ReleaseStringPlatformChars(env, shadersLibName, str);\n+    JNI_COCOA_EXIT(env);\n+    return ret;\n+}\n+\n+\n+\/**\n+ * Determines whether the MTL pipeline can be used for a given GraphicsConfig\n+ * provided its screen number and visual ID.  If the minimum requirements are\n+ * met, the native MTLGraphicsConfigInfo structure is initialized for this\n+ * GraphicsConfig with the necessary information (pixel format, etc.)\n+ * and a pointer to this structure is returned as a jlong.  If\n+ * initialization fails at any point, zero is returned, indicating that MTL\n+ * cannot be used for this GraphicsConfig (we should fallback on an existing\n+ * 2D pipeline).\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_java2d_metal_MTLGraphicsConfig_getMTLConfigInfo\n+    (JNIEnv *env, jclass mtlgc, jint displayID, jstring mtlShadersLib)\n+{\n+    jlong ret = 0L;\n+    JNI_COCOA_ENTER(env);\n+    NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];\n+    [retArray addObject: [NSNumber numberWithInt: (int)displayID]];\n+    char *str = JNU_GetStringPlatformChars(env, mtlShadersLib, 0);\n+    [retArray addObject: [NSString stringWithUTF8String: str]];\n+\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n+        [MTLGraphicsConfigUtil _getMTLConfigInfo: retArray];\n+    }];\n+\n+    NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];\n+    ret = (jlong)[num longValue];\n+    JNU_ReleaseStringPlatformChars(env, mtlShadersLib, str);\n+    JNI_COCOA_EXIT(env);\n+    return ret;\n+}\n+\n+\n+\n+\n+@implementation MTLGraphicsConfigUtil\n++ (void) _getMTLConfigInfo: (NSMutableArray *)argValue {\n+    AWT_ASSERT_APPKIT_THREAD;\n+\n+    jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];\n+    NSString *mtlShadersLib = (NSString *)[argValue objectAtIndex: 1];\n+    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n+    [argValue removeAllObjects];\n+\n+    J2dRlsTraceLn(J2D_TRACE_INFO, \"MTLGraphicsConfig_getMTLConfigInfo\");\n+\n+    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n+\n+\n+    NSRect contentRect = NSMakeRect(0, 0, 64, 64);\n+    NSWindow *window =\n+        [[NSWindow alloc]\n+            initWithContentRect: contentRect\n+            styleMask: NSBorderlessWindowMask\n+            backing: NSBackingStoreBuffered\n+            defer: false];\n+    if (window == nil) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: NSWindow is NULL\");\n+        [argValue addObject: [NSNumber numberWithLong: 0L]];\n+        return;\n+    }\n+\n+    MTLContext *mtlc = [[MTLContext alloc] initWithDevice:CGDirectDisplayCopyCurrentMetalDevice(displayID)\n+                        shadersLib:mtlShadersLib];\n+    if (mtlc == 0L) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGC_InitMTLContext: could not initialze MTLContext.\");\n+        [argValue addObject: [NSNumber numberWithLong: 0L]];\n+        return;\n+    }\n+\n+\n+    \/\/ create the MTLGraphicsConfigInfo record for this config\n+    MTLGraphicsConfigInfo *mtlinfo = (MTLGraphicsConfigInfo *)malloc(sizeof(MTLGraphicsConfigInfo));\n+    if (mtlinfo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not allocate memory for mtlinfo\");\n+        free(mtlc);\n+        [argValue addObject: [NSNumber numberWithLong: 0L]];\n+        return;\n+    }\n+    memset(mtlinfo, 0, sizeof(MTLGraphicsConfigInfo));\n+    mtlinfo->context = mtlc;\n+\n+    [argValue addObject: [NSNumber numberWithLong:ptr_to_jlong(mtlinfo)]];\n+    [pool drain];\n+}\n+\n++ (void) _tryLoadMetalLibrary: (NSMutableArray *)argValue {\n+    AWT_ASSERT_APPKIT_THREAD;\n+\n+    jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];\n+    NSString *mtlShadersLib = (NSString *)[argValue objectAtIndex: 1];\n+    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n+    [argValue removeAllObjects];\n+\n+    J2dRlsTraceLn(J2D_TRACE_INFO, \"MTLGraphicsConfigUtil_tryLoadMTLLibrary\");\n+\n+\n+    BOOL ret = FALSE;;\n+    id<MTLDevice> device = CGDirectDisplayCopyCurrentMetalDevice(displayID);\n+    if (device != nil) {\n+        NSError *error = nil;\n+        id<MTLLibrary> lib = [device newLibraryWithFile:mtlShadersLib error:&error];\n+        if (lib != nil) {\n+            ret = TRUE;\n+        } else {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to load Metal shader library.\");\n+        }\n+    } else {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to create MTLDevice.\");\n+    }\n+\n+    [argValue addObject: [NSNumber numberWithBool: ret]];\n+\n+}\n+\n+@end \/\/GraphicsConfigUtil\n+\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_java2d_metal_MTLGraphicsConfig_nativeGetMaxTextureSize\n+    (JNIEnv *env, jclass mtlgc)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLGraphicsConfig_nativeGetMaxTextureSize\");\n+\n+    return (jint)MaxTextureSize;\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLLayer_h_Included\n+#define MTLLayer_h_Included\n+#import <Metal\/Metal.h>\n+#import <QuartzCore\/CAMetalLayer.h>\n+#include <CoreVideo\/CVDisplayLink.h>\n+#import \"common.h\"\n+\n+@interface MTLLayer : CAMetalLayer\n+{\n+@private\n+    jobject javaLayer;\n+\n+    \/\/ intermediate buffer, used the RQ lock to synchronize\n+    MTLContext* ctx;\n+    float bufferWidth;\n+    float bufferHeight;\n+    id<MTLTexture> buffer;\n+    int nextDrawableCount;\n+    int topInset;\n+    int leftInset;\n+    CVDisplayLinkRef displayLink;\n+}\n+\n+@property (nonatomic) jobject javaLayer;\n+@property (readwrite, assign) MTLContext* ctx;\n+@property (readwrite, assign) float bufferWidth;\n+@property (readwrite, assign) float bufferHeight;\n+@property (readwrite, assign) id<MTLTexture> buffer;\n+@property (readwrite, assign) int nextDrawableCount;\n+@property (readwrite, assign) int topInset;\n+@property (readwrite, assign) int leftInset;\n+@property (readwrite, assign) CVDisplayLinkRef displayLink;\n+\n+- (id) initWithJavaLayer:(jobject)layer;\n+\n+- (void) blitTexture;\n+- (void) fillParallelogramCtxX:(jfloat)x\n+                             Y:(jfloat)y\n+                           DX1:(jfloat)dx1\n+                           DY1:(jfloat)dy1\n+                           DX2:(jfloat)dx2\n+                           DY2:(jfloat)dy2;\n+- (void) blitCallback;\n+- (void) display;\n+- (void) redraw;\n+- (void) startDisplayLink;\n+- (void) stopDisplayLink;\n+@end\n+\n+#endif \/* MTLLayer_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.h","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MTLGraphicsConfig.h\"\n+#import \"MTLLayer.h\"\n+#import \"ThreadUtilities.h\"\n+#import \"LWCToolkit.h\"\n+#import \"MTLSurfaceData.h\"\n+#import \"JNIUtilities.h\"\n+\n+@implementation MTLLayer\n+\n+\n+@synthesize javaLayer;\n+@synthesize ctx;\n+@synthesize bufferWidth;\n+@synthesize bufferHeight;\n+@synthesize buffer;\n+@synthesize topInset;\n+@synthesize leftInset;\n+@synthesize nextDrawableCount;\n+@synthesize displayLink;\n+\n+- (id) initWithJavaLayer:(jobject)layer\n+{\n+    AWT_ASSERT_APPKIT_THREAD;\n+    \/\/ Initialize ourselves\n+    self = [super init];\n+    if (self == nil) return self;\n+\n+    self.javaLayer = layer;\n+\n+    self.contentsGravity = kCAGravityTopLeft;\n+\n+    \/\/Disable CALayer's default animation\n+    NSMutableDictionary * actions = [[NSMutableDictionary alloc] initWithObjectsAndKeys:\n+                                    [NSNull null], @\"anchorPoint\",\n+                                    [NSNull null], @\"bounds\",\n+                                    [NSNull null], @\"contents\",\n+                                    [NSNull null], @\"contentsScale\",\n+                                    [NSNull null], @\"onOrderIn\",\n+                                    [NSNull null], @\"onOrderOut\",\n+                                    [NSNull null], @\"position\",\n+                                    [NSNull null], @\"sublayers\",\n+                                    nil];\n+    self.actions = actions;\n+    [actions release];\n+    self.topInset = 0;\n+    self.leftInset = 0;\n+    self.framebufferOnly = NO;\n+    self.nextDrawableCount = 0;\n+    self.opaque = FALSE;\n+    CVDisplayLinkCreateWithActiveCGDisplays(&displayLink);\n+    CVDisplayLinkSetOutputCallback(displayLink, &displayLinkCallback, (__bridge void*)self);\n+    return self;\n+}\n+\n+- (void) blitTexture {\n+    if (self.ctx == NULL || self.javaLayer == NULL || self.buffer == nil || self.ctx.device == nil) {\n+        J2dTraceLn4(J2D_TRACE_VERBOSE, \"MTLLayer.blitTexture: uninitialized (mtlc=%p, javaLayer=%p, buffer=%p, devide=%p)\", self.ctx, self.javaLayer, self.buffer, ctx.device);\n+        return;\n+    }\n+\n+    if (self.nextDrawableCount != 0) {\n+        return;\n+    }\n+    @autoreleasepool {\n+        if ((self.buffer.width == 0) || (self.buffer.height == 0)) {\n+            J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer.blitTexture: cannot create drawable of size 0\");\n+            return;\n+        }\n+\n+        NSUInteger src_x = self.leftInset * self.contentsScale;\n+        NSUInteger src_y = self.topInset * self.contentsScale;\n+        NSUInteger src_w = self.buffer.width - src_x;\n+        NSUInteger src_h = self.buffer.height - src_y;\n+\n+        if (src_h <= 0 || src_w <= 0) {\n+           J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer.blitTexture: Invalid src width or height.\");\n+           return;\n+        }\n+\n+        id<MTLCommandBuffer> commandBuf = [self.ctx createBlitCommandBuffer];\n+        if (commandBuf == nil) {\n+            J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer.blitTexture: commandBuf is null\");\n+            return;\n+        }\n+        id<CAMetalDrawable> mtlDrawable = [self nextDrawable];\n+        if (mtlDrawable == nil) {\n+            J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer.blitTexture: nextDrawable is null)\");\n+            return;\n+        }\n+        self.nextDrawableCount++;\n+\n+        id <MTLBlitCommandEncoder> blitEncoder = [commandBuf blitCommandEncoder];\n+\n+        [blitEncoder\n+                copyFromTexture:self.buffer sourceSlice:0 sourceLevel:0\n+                sourceOrigin:MTLOriginMake(src_x, src_y, 0)\n+                sourceSize:MTLSizeMake(src_w, src_h, 1)\n+                toTexture:mtlDrawable.texture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(0, 0, 0)];\n+        [blitEncoder endEncoding];\n+\n+        [commandBuf presentDrawable:mtlDrawable];\n+        [commandBuf addCompletedHandler:^(id <MTLCommandBuffer> commandBuf) {\n+            self.nextDrawableCount--;\n+        }];\n+\n+        [commandBuf commit];\n+        [self stopDisplayLink];\n+    }\n+}\n+\n+- (void) dealloc {\n+    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n+    (*env)->DeleteWeakGlobalRef(env, self.javaLayer);\n+    self.javaLayer = nil;\n+    [self stopDisplayLink];\n+    CVDisplayLinkRelease(self.displayLink);\n+    self.displayLink = nil;\n+    [super dealloc];\n+}\n+\n+- (void) blitCallback {\n+\n+    JNIEnv *env = [ThreadUtilities getJNIEnv];\n+    DECLARE_CLASS(jc_JavaLayer, \"sun\/java2d\/metal\/MTLLayer\");\n+    DECLARE_METHOD(jm_drawInMTLContext, jc_JavaLayer, \"drawInMTLContext\", \"()V\");\n+\n+    jobject javaLayerLocalRef = (*env)->NewLocalRef(env, self.javaLayer);\n+    if ((*env)->IsSameObject(env, javaLayerLocalRef, NULL)) {\n+        return;\n+    }\n+\n+    (*env)->CallVoidMethod(env, javaLayerLocalRef, jm_drawInMTLContext);\n+    CHECK_EXCEPTION();\n+    (*env)->DeleteLocalRef(env, javaLayerLocalRef);\n+}\n+\n+- (void) display {\n+    AWT_ASSERT_APPKIT_THREAD;\n+    J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer_display() called\");\n+    [self blitCallback];\n+    [super display];\n+}\n+\n+- (void) redraw {\n+    AWT_ASSERT_APPKIT_THREAD;\n+    [self setNeedsDisplay];\n+}\n+\n+- (void) startDisplayLink {\n+    if (!CVDisplayLinkIsRunning(self.displayLink))\n+        CVDisplayLinkStart(self.displayLink);\n+}\n+\n+- (void) stopDisplayLink {\n+    if (CVDisplayLinkIsRunning(self.displayLink))\n+        CVDisplayLinkStop(self.displayLink);\n+}\n+\n+CVReturn displayLinkCallback(CVDisplayLinkRef displayLink, const CVTimeStamp* now, const CVTimeStamp* outputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext)\n+{\n+    J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer_displayLinkCallback() called\");\n+    @autoreleasepool {\n+        MTLLayer *layer = (__bridge MTLLayer *)displayLinkContext;\n+        [layer performSelectorOnMainThread:@selector(redraw) withObject:nil waitUntilDone:NO];\n+    }\n+    return kCVReturnSuccess;\n+}\n+@end\n+\n+\/*\n+ * Class:     sun_java2d_metal_MTLLayer\n+ * Method:    nativeCreateLayer\n+ * Signature: ()J\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_java2d_metal_MTLLayer_nativeCreateLayer\n+(JNIEnv *env, jobject obj)\n+{\n+    __block MTLLayer *layer = nil;\n+\n+JNI_COCOA_ENTER(env);\n+\n+    jobject javaLayer = (*env)->NewWeakGlobalRef(env, obj);\n+\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n+            AWT_ASSERT_APPKIT_THREAD;\n+\n+            layer = [[MTLLayer alloc] initWithJavaLayer: javaLayer];\n+    }];\n+\n+JNI_COCOA_EXIT(env);\n+\n+    return ptr_to_jlong(layer);\n+}\n+\n+\/\/ Must be called under the RQ lock.\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLLayer_validate\n+(JNIEnv *env, jclass cls, jlong layerPtr, jobject surfaceData)\n+{\n+    MTLLayer *layer = OBJC(layerPtr);\n+\n+    if (surfaceData != NULL) {\n+        BMTLSDOps *bmtlsdo = (BMTLSDOps*) SurfaceData_GetOps(env, surfaceData);\n+        layer.bufferWidth = bmtlsdo->width;\n+        layer.bufferHeight = bmtlsdo->width;\n+        layer.buffer = bmtlsdo->pTexture;\n+        layer.ctx = ((MTLSDOps *)bmtlsdo->privOps)->configInfo->context;\n+        layer.device = layer.ctx.device;\n+        layer.pixelFormat = MTLPixelFormatBGRA8Unorm;\n+        layer.drawableSize =\n+            CGSizeMake(layer.buffer.width,\n+                       layer.buffer.height);\n+        [layer startDisplayLink];\n+    } else {\n+        layer.ctx = NULL;\n+        [layer stopDisplayLink];\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLLayer_nativeSetScale\n+(JNIEnv *env, jclass cls, jlong layerPtr, jdouble scale)\n+{\n+    JNI_COCOA_ENTER(env);\n+    MTLLayer *layer = jlong_to_ptr(layerPtr);\n+    \/\/ We always call all setXX methods asynchronously, exception is only in\n+    \/\/ this method where we need to change native texture size and layer's scale\n+    \/\/ in one call on appkit, otherwise we'll get window's contents blinking,\n+    \/\/ during screen-2-screen moving.\n+    [ThreadUtilities performOnMainThreadWaiting:[NSThread isMainThread] block:^(){\n+        layer.contentsScale = scale;\n+    }];\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLLayer_nativeSetInsets\n+(JNIEnv *env, jclass cls, jlong layerPtr, jint top, jint left)\n+{\n+    MTLLayer *layer = jlong_to_ptr(layerPtr);\n+    layer.topInset = top;\n+    layer.leftInset = left;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLLayer_blitTexture\n+(JNIEnv *env, jclass cls, jlong layerPtr)\n+{\n+    J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer_blitTexture\");\n+    MTLLayer *layer = jlong_to_ptr(layerPtr);\n+    MTLContext * ctx = layer.ctx;\n+    if (layer == NULL || ctx == NULL) {\n+        J2dTraceLn(J2D_TRACE_VERBOSE, \"MTLLayer_blit : Layer or Context is null\");\n+        return;\n+    }\n+\n+    [layer blitTexture];\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.m","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLMaskBlit_h_Included\n+#define MTLMaskBlit_h_Included\n+\n+#include \"MTLContext.h\"\n+\n+void MTLMaskBlit_MaskBlit(JNIEnv *env, MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint dstx, jint dsty,\n+                          jint width, jint height,\n+                          void *pPixels);\n+\n+#endif \/* MTLMaskBlit_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLMaskBlit.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <jlong.h>\n+\n+#include \"MTLMaskBlit.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLBlitLoops.h\"\n+\n+\/**\n+ * REMIND: This method assumes that the dimensions of the incoming pixel\n+ *         array are less than or equal to the cached blit texture tile;\n+ *         these are rather fragile assumptions, and should be cleaned up...\n+ *\/\n+void\n+MTLMaskBlit_MaskBlit(JNIEnv *env, MTLContext *mtlc, BMTLSDOps * dstOps,\n+                     jint dstx, jint dsty,\n+                     jint width, jint height,\n+                     void *pPixels)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLMaskBlit_MaskBlit\");\n+\n+    if (width <= 0 || height <= 0) {\n+        J2dTraceLn(J2D_TRACE_WARNING, \"MTLMaskBlit_MaskBlit: invalid dimensions\");\n+        return;\n+    }\n+\n+    RETURN_IF_NULL(pPixels);\n+    RETURN_IF_NULL(mtlc);\n+\n+    MTLPooledTextureHandle * texHandle = [mtlc.texturePool\n+                                                  getTexture:width\n+                                                      height:height\n+                                                      format:MTLPixelFormatBGRA8Unorm];\n+    if (texHandle == nil) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLMaskBlit_MaskBlit: can't obtain temporary texture object from pool\");\n+        return;\n+    }\n+    [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];\n+\n+    id<MTLTexture> texBuff = texHandle.texture;\n+    MTLRegion region = MTLRegionMake2D(0, 0, width, height);\n+    [texBuff replaceRegion:region mipmapLevel:0 withBytes:pPixels bytesPerRow:4*width];\n+\n+    drawTex2Tex(mtlc, texBuff, dstOps->pTexture, JNI_FALSE, dstOps->isOpaque, 0,\n+                0, 0, width, height, dstx, dsty, dstx + width, dsty + height);\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLMaskBlit.m","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLMaskFill_h_Included\n+#define MTLMaskFill_h_Included\n+\n+#include \"MTLContext.h\"\n+\n+void MTLMaskFill_MaskFill(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint x, jint y, jint w, jint h,\n+                          jint maskoff, jint maskscan, jint masklen,\n+                          unsigned char *pMask);\n+\n+#endif \/* MTLMaskFill_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLMaskFill.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"sun_java2d_metal_MTLMaskFill.h\"\n+\n+#include \"MTLMaskFill.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLVertexCache.h\"\n+\n+\/**\n+ * In case of Metal we use shader for texture mapping.\n+ *\n+ * Descriptions of the many variables used in this method:\n+ *   x,y     - upper left corner of the tile destination\n+ *   w,h     - width\/height of the mask tile\n+ *   x0      - placekeeper for the original destination x location\n+ *   tw,th   - width\/height of the actual texture tile in pixels\n+ *   sx1,sy1 - upper left corner of the mask tile source region\n+ *   sx2,sy2 - lower left corner of the mask tile source region\n+ *   sx,sy   - \"current\" upper left corner of the mask tile region of interest\n+ *\/\n+void\n+MTLMaskFill_MaskFill(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                     jint x, jint y, jint w, jint h,\n+                     jint maskoff, jint maskscan, jint masklen,\n+                     unsigned char *pMask)\n+{\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLMaskFill_MaskFill (x=%d y=%d w=%d h=%d pMask=%p)\", x, y, w, h, dstOps->pTexture);\n+    jint tw, th, x0;\n+    jint sx1, sy1, sx2, sy2;\n+    jint sx, sy, sw, sh;\n+\n+    x0 = x;\n+    tw = MTLVC_MASK_CACHE_TILE_WIDTH;\n+    th = MTLVC_MASK_CACHE_TILE_HEIGHT;\n+    sx1 = maskoff % maskscan;\n+    sy1 = maskoff \/ maskscan;\n+    sx2 = sx1 + w;\n+    sy2 = sy1 + h;\n+\n+\n+    for (sy = sy1; sy < sy2; sy += th, y += th) {\n+        x = x0;\n+        sh = ((sy + th) > sy2) ? (sy2 - sy) : th;\n+\n+        for (sx = sx1; sx < sx2; sx += tw, x += tw) {\n+            sw = ((sx + tw) > sx2) ? (sx2 - sx) : tw;\n+            MTLVertexCache_AddMaskQuad(mtlc,\n+                    sx, sy, x, y, sw, sh,\n+                    maskscan, pMask, dstOps);\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLMaskFill_maskFill\n+    (JNIEnv *env, jobject self,\n+     jint x, jint y, jint w, jint h,\n+     jint maskoff, jint maskscan, jint masklen,\n+     jbyteArray maskArray)\n+{\n+    MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+    unsigned char *mask;\n+\n+    J2dTraceLn(J2D_TRACE_ERROR, \"MTLMaskFill_maskFill\");\n+\n+    if (maskArray != NULL) {\n+        mask = (unsigned char *)\n+            (*env)->GetPrimitiveArrayCritical(env, maskArray, NULL);\n+    } else {\n+        mask = NULL;\n+    }\n+\n+    MTLMaskFill_MaskFill(mtlc, dstOps,\n+                         x, y, w, h,\n+                         maskoff, maskscan, masklen, mask);\n+    if (mtlc != NULL) {\n+        RESET_PREVIOUS_OP();\n+        [mtlc.encoderManager endEncoder];\n+        MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+        id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+        [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+            [cbwrapper release];\n+        }];\n+        [commandbuf commit];\n+    }\n+\n+    if (mask != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, maskArray, mask, JNI_ABORT);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLMaskFill.m","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLPaints_h_Included\n+#define MTLPaints_h_Included\n+\n+#import <Metal\/Metal.h>\n+#include \"RenderOptions.h\"\n+\n+#define sun_java2d_SunGraphics2D_PAINT_UNDEFINED -1\n+\n+@class MTLContext;\n+@class MTLComposite;\n+@class MTLClip;\n+@class MTLPipelineStatesStorage;\n+\n+\/**\n+ * The MTLPaint class represents paint mode (color, gradient etc.)\n+ *\/\n+\n+@interface MTLPaint : NSObject\n+\n+- (id)initWithState:(jint)state;\n+- (BOOL)isEqual:(MTLPaint *)other; \/\/ used to compare requested with cached\n+- (NSString *)getDescription;\n+\n+\/\/ For the current paint mode and passed composite (and flags):\n+\/\/ 1. Selects vertex+fragment shader (and corresponding pipelineDesc) and set pipelineState\n+\/\/ 2. Prepares corresponding buffers of vertex and fragment shaders\n+\n+- (void)setPipelineState:(id <MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;\n+\n+\n+- (void)setXorModePipelineState:(id <MTLRenderCommandEncoder>)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;\n+@end\n+\n+@interface MTLColorPaint : MTLPaint\n+- (id)initWithColor:(jint)color;\n+@property (nonatomic, readonly) jint color;\n+@end\n+\n+@interface MTLBaseGradPaint : MTLPaint\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             cyclic:(jboolean)cyclic;\n+@end\n+\n+@interface MTLGradPaint : MTLBaseGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               cyclic:(jboolean)cyclic\n+                   p0:(jdouble)p0\n+                   p1:(jdouble)p1\n+                   p3:(jdouble)p3\n+               pixel1:(jint)pixel1\n+               pixel2:(jint)pixel2;\n+@end\n+\n+@interface MTLBaseMultiGradPaint : MTLBaseGradPaint\n+\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             linear:(jboolean)linear\n+        cycleMethod:(jboolean)cycleMethod\n+           numStops:(jint)numStops\n+          fractions:(jfloat *)fractions\n+             pixels:(jint *)pixels;\n+@end\n+\n+@interface MTLLinearGradPaint : MTLBaseMultiGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jboolean)cycleMethod\n+             numStops:(jint)numStops\n+                   p0:(jfloat)p0\n+                   p1:(jfloat)p1\n+                   p3:(jfloat)p3\n+            fractions:(jfloat *)fractions\n+               pixels:(jint *)pixels;\n+@end\n+\n+@interface MTLRadialGradPaint : MTLBaseMultiGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jint)cycleMethod\n+             numStops:(jint)numStops\n+                  m00:(jfloat)m00\n+                  m01:(jfloat)m01\n+                  m02:(jfloat)m02\n+                  m10:(jfloat)m10\n+                  m11:(jfloat)m11\n+                  m12:(jfloat)m12\n+               focusX:(jfloat)focusX\n+            fractions:(void *)fractions\n+               pixels:(void *)pixels;\n+@end\n+\n+@interface MTLTexturePaint : MTLPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+              textureID:(id <MTLTexture>)textureID\n+               isOpaque:(jboolean)isOpaque\n+                 filter:(jboolean)filter\n+                    xp0:(jdouble)xp0\n+                    xp1:(jdouble)xp1\n+                    xp3:(jdouble)xp3\n+                    yp0:(jdouble)yp0\n+                    yp1:(jdouble)yp1\n+                    yp3:(jdouble)yp3;\n+@end\n+\n+#endif \/* MTLPaints_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.h","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,1006 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLPaints.h\"\n+#include \"MTLClip.h\"\n+#include \"common.h\"\n+\n+#include \"sun_java2d_SunGraphics2D.h\"\n+#include \"sun_java2d_pipe_BufferedPaints.h\"\n+#import \"MTLComposite.h\"\n+#import \"MTLBufImgOps.h\"\n+#include \"MTLRenderQueue.h\"\n+\n+#define RGBA_TO_V4(c)              \\\n+{                                  \\\n+    (((c) >> 16) & (0xFF))\/255.0f, \\\n+    (((c) >> 8) & 0xFF)\/255.0f,    \\\n+    ((c) & 0xFF)\/255.0f,           \\\n+    (((c) >> 24) & 0xFF)\/255.0f    \\\n+}\n+\n+#define FLOAT_ARR_TO_V4(p) \\\n+{                      \\\n+    p[0], \\\n+    p[1], \\\n+    p[2], \\\n+    p[3]  \\\n+}\n+\n+static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;\n+static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;\n+static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;\n+static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;\n+static void setTxtUniforms(\n+        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n+        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n+);\n+\n+static void initTemplatePipelineDescriptors() {\n+    if (templateRenderPipelineDesc != nil && templateTexturePipelineDesc != nil)\n+        return;\n+\n+    MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n+    vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n+    vertDesc.attributes[VertexAttributePosition].offset = 0;\n+    vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n+    vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n+    vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n+    vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+\n+    templateRenderPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateRenderPipelineDesc.sampleCount = 1;\n+    templateRenderPipelineDesc.vertexDescriptor = vertDesc;\n+    templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    templateRenderPipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n+    templateRenderPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+    templateRenderPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n+    templateRenderPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n+    templateRenderPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+    templateRenderPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+    templateRenderPipelineDesc.label = @\"template_render\";\n+\n+    templateTexturePipelineDesc = [templateRenderPipelineDesc copy];\n+    templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+    templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+    templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+    templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n+    templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n+    templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+    templateTexturePipelineDesc.label = @\"template_texture\";\n+\n+    templateAATexturePipelineDesc = [templateTexturePipelineDesc copy];\n+    templateAATexturePipelineDesc.label = @\"template_aa_texture\";\n+\n+    templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateLCDPipelineDesc.sampleCount = 1;\n+    templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n+    templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+    templateLCDPipelineDesc.label = @\"template_lcd\";\n+}\n+\n+\n+@implementation MTLColorPaint {\n+\/\/ color-mode\n+jint _color;\n+}\n+- (id)initWithColor:(jint)color {\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR];\n+\n+    if (self) {\n+        _color = color;\n+    }\n+    return self;\n+}\n+\n+- (jint)color {\n+    return _color;\n+}\n+\n+- (BOOL)isEqual:(MTLColorPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    return _color == other->_color;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _color;\n+    return h;\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:\n+            @\"[r=%d g=%d b=%d a=%d]\",\n+            (_color >> 16) & (0xFF),\n+            (_color >> 8) & 0xFF,\n+            (_color) & 0xFF,\n+            (_color >> 24) & 0xFF];\n+}\n+\n+- (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_col\";\n+    NSString *fragShader = @\"frag_col\";\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt\";\n+        fragShader = @\"frag_txt\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+        if (renderOptions->isAA) {\n+            fragShader = @\"aa_frag_txt\";\n+            rpDesc = [[templateAATexturePipelineDesc copy] autorelease];\n+        }\n+        if (renderOptions->isText) {\n+            fragShader = @\"frag_text\";\n+        }\n+        if (renderOptions->isLCD) {\n+            vertShader = @\"vert_txt_lcd\";\n+            fragShader = @\"lcd_color\";\n+            rpDesc = [[templateLCDPipelineDesc copy] autorelease];\n+        }\n+        setTxtUniforms(encoder, _color, 1,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags,\n+                       &renderOptions->dstFlags);\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    }\n+\n+    struct FrameUniforms uf = {RGBA_TO_V4(_color)};\n+    [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    NSString * vertShader = @\"vert_col_xorMode\";\n+    NSString * fragShader = @\"frag_col_xorMode\";\n+    MTLRenderPipelineDescriptor * rpDesc = nil;\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n+    \/\/ Calculate _color ^ xorColor for RGB components\n+    \/\/ This color gets XORed with destination framebuffer pixel color\n+    const int col = _color ^ xorColor;\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_xorMode\";\n+        fragShader = @\"frag_txt_xorMode\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n+        setTxtUniforms(encoder, col, 1,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+        [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex:0];\n+\n+        [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+    } else {\n+        struct FrameUniforms uf = {RGBA_TO_V4(col)};\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+\n+        [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+        [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n+    }\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+@end\n+\n+@implementation MTLBaseGradPaint {\n+    jboolean      _useMask;\n+@protected\n+    jint          _cyclic;\n+}\n+\n+- (id)initWithState:(jint)state mask:(jboolean)useMask cyclic:(jboolean)cyclic {\n+    self = [super initWithState:state];\n+\n+    if (self) {\n+        _useMask = useMask;\n+        _cyclic = cyclic;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLBaseGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    return [super isEqual:self] && _cyclic == other->_cyclic && _useMask == other->_useMask;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _cyclic;\n+    h = h*31 + _useMask;\n+    return h;\n+}\n+\n+@end\n+\n+@implementation MTLGradPaint {\n+    jdouble _p0;\n+    jdouble _p1;\n+    jdouble _p3;\n+    jint _pixel1;\n+    jint _pixel2;\n+}\n+- (id)initWithUseMask:(jboolean)useMask\n+               cyclic:(jboolean)cyclic\n+                   p0:(jdouble)p0\n+                   p1:(jdouble)p1\n+                   p3:(jdouble)p3\n+               pixel1:(jint)pixel1\n+               pixel2:(jint)pixel2\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_GRADIENT\n+                           mask:useMask\n+                         cyclic:cyclic];\n+\n+    if (self) {\n+        _p0 = p0;\n+        _p1 = p1;\n+        _p3 = p3;\n+        _pixel1 = pixel1;\n+        _pixel2 = pixel2;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    return [super isEqual:self] && _p0 == other->_p0 &&\n+           _p1 == other->_p1 && _p3 == other->_p3 &&\n+           _pixel1 == other->_pixel1 && _pixel2 == other->_pixel2;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_p0) hash];\n+    h = h*31 + [@(_p1) hash];;\n+    h = h*31 + [@(_p3) hash];;\n+    h = h*31 + _pixel1;\n+    h = h*31 + _pixel2;\n+    return h;\n+}\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"gradient\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_grad\";\n+\n+    struct GradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            RGBA_TO_V4(_pixel1),\n+            RGBA_TO_V4(_pixel2),\n+            _cyclic,\n+            [mtlc.composite getExtraAlpha]\n+    };\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    }\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    \/\/ This block is not reached in current implementation.\n+    \/\/ Gradient paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n+    NSString* vertShader = @\"vert_grad_xorMode\";\n+    NSString* fragShader = @\"frag_grad_xorMode\";\n+    MTLRenderPipelineDescriptor *rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n+\n+    struct GradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            RGBA_TO_V4(_pixel1 ^ xorColor),\n+            RGBA_TO_V4(_pixel2 ^ xorColor),\n+            _cyclic,\n+            [mtlc.composite getExtraAlpha]\n+    };\n+\n+    [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+    [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_GRADIENT\");\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+@end\n+\n+@implementation MTLBaseMultiGradPaint {\n+    @protected\n+    jboolean _linear;\n+    jint _numFracts;\n+    jfloat _fract[GRAD_MAX_FRACTIONS];\n+    jint _pixel[GRAD_MAX_FRACTIONS];\n+}\n+\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             linear:(jboolean)linear\n+        cycleMethod:(jboolean)cycleMethod\n+           numStops:(jint)numStops\n+          fractions:(jfloat *)fractions\n+             pixels:(jint *)pixels\n+{\n+    self = [super initWithState:state\n+                           mask:useMask\n+                         cyclic:cycleMethod];\n+\n+    if (self) {\n+        _linear = linear;\n+        memcpy(_fract, fractions,numStops*sizeof(jfloat));\n+        memcpy(_pixel, pixels, numStops*sizeof(jint));\n+        _numFracts = numStops;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLBaseMultiGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    if (_numFracts != other->_numFracts || ![super isEqual:self])\n+        return NO;\n+    for (int i = 0; i < _numFracts; i++) {\n+        if (_fract[i] != other->_fract[i]) return NO;\n+        if (_pixel[i] != other->_pixel[i]) return NO;\n+    }\n+    return YES;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _numFracts;\n+    for (int i = 0; i < _numFracts; i++) {\n+        h = h*31 + [@(_fract[i]) hash];\n+        h = h*31 + _pixel[i];\n+    }\n+    return h;\n+}\n+\n+@end\n+\n+@implementation MTLLinearGradPaint {\n+    jdouble _p0;\n+    jdouble _p1;\n+    jdouble _p3;\n+}\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+\n+{\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_lin_grad\";\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_lin_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    }\n+\n+    struct LinGradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            {},\n+            {},\n+            _numFracts,\n+            _linear,\n+            _cyclic,\n+            [mtlc.composite getExtraAlpha]\n+    };\n+\n+    memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+    for (int i = 0; i < _numFracts; i++) {\n+        vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+        uf.color[i] = v;\n+    }\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jboolean)cycleMethod\n+             numStops:(jint)numStops\n+                   p0:(jfloat)p0\n+                   p1:(jfloat)p1\n+                   p3:(jfloat)p3\n+            fractions:(jfloat *)fractions\n+               pixels:(jint *)pixels\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT\n+                           mask:useMask\n+                         linear:linear\n+                    cycleMethod:cycleMethod\n+                       numStops:numStops\n+                      fractions:fractions\n+                         pixels:pixels];\n+\n+    if (self) {\n+        _p0 = p0;\n+        _p1 = p1;\n+        _p3 = p3;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLLinearGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]] || ![super isEqual:other])\n+        return NO;\n+\n+    return _p0 == other->_p0 && _p1 == other->_p1 && _p3 == other->_p3;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_p0) hash];\n+    h = h*31 + [@(_p1) hash];\n+    h = h*31 + [@(_p3) hash];\n+    return h;\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"linear_gradient\"];\n+}\n+@end\n+\n+@implementation MTLRadialGradPaint {\n+    jfloat _m00;\n+    jfloat _m01;\n+    jfloat _m02;\n+    jfloat _m10;\n+    jfloat _m11;\n+    jfloat _m12;\n+    jfloat _focusX;\n+}\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jint)cycleMethod\n+             numStops:(jint)numStops\n+                  m00:(jfloat)m00\n+                  m01:(jfloat)m01\n+                  m02:(jfloat)m02\n+                  m10:(jfloat)m10\n+                  m11:(jfloat)m11\n+                  m12:(jfloat)m12\n+               focusX:(jfloat)focusX\n+            fractions:(void *)fractions\n+               pixels:(void *)pixels\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT\n+                           mask:useMask\n+                         linear:linear\n+                    cycleMethod:cycleMethod\n+                       numStops:numStops\n+                      fractions:fractions\n+                         pixels:pixels];\n+\n+    if (self) {\n+        _m00 = m00;\n+        _m01 = m01;\n+        _m02 = m02;\n+        _m10 = m10;\n+        _m11 = m11;\n+        _m12 = m12;\n+        _focusX = focusX;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLRadialGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]]\n+            || ![super isEqual:self])\n+        return NO;\n+\n+    return _m00 == other->_m00 && _m01 == other->_m01 && _m02 == other->_m02 &&\n+           _m10 == other->_m10 && _m11 == other->_m11 && _m12 == other->_m12 &&\n+           _focusX == other->_focusX;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_m00) hash];\n+    h = h*31 + [@(_m01) hash];\n+    h = h*31 + [@(_m02) hash];\n+    h = h*31 + [@(_m10) hash];\n+    h = h*31 + [@(_m11) hash];\n+    h = h*31 + [@(_m12) hash];\n+    return h;\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"radial_gradient\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_rad_grad\";\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_rad_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    }\n+\n+    struct RadGradFrameUniforms uf = {\n+            {},\n+            {},\n+            _numFracts,\n+            _linear,\n+            _cyclic,\n+            {_m00, _m01, _m02},\n+            {_m10, _m11, _m12},\n+            {},\n+            [mtlc.composite getExtraAlpha]\n+    };\n+\n+    uf.precalc[0] = _focusX;\n+    uf.precalc[1] = 1.0 - (_focusX * _focusX);\n+    uf.precalc[2] = 1.0 \/ uf.precalc[1];\n+\n+    memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+    for (int i = 0; i < _numFracts; i++) {\n+        vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+        uf.color[i] = v;\n+    }\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+\n+@end\n+\n+@implementation MTLTexturePaint {\n+    struct AnchorData _anchor;\n+    id <MTLTexture> _paintTexture;\n+    jboolean _isOpaque;\n+}\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+              textureID:(id)textureId\n+               isOpaque:(jboolean)isOpaque\n+                 filter:(jboolean)filter\n+                    xp0:(jdouble)xp0\n+                    xp1:(jdouble)xp1\n+                    xp3:(jdouble)xp3\n+                    yp0:(jdouble)yp0\n+                    yp1:(jdouble)yp1\n+                    yp3:(jdouble)yp3\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_TEXTURE];\n+\n+    if (self) {\n+        _paintTexture = textureId;\n+        _anchor.xParams[0] = xp0;\n+        _anchor.xParams[1] = xp1;\n+        _anchor.xParams[2] = xp3;\n+\n+        _anchor.yParams[0] = yp0;\n+        _anchor.yParams[1] = yp1;\n+        _anchor.yParams[2] = yp3;\n+        _isOpaque = isOpaque;\n+    }\n+    return self;\n+\n+}\n+\n+- (BOOL)isEqual:(MTLTexturePaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    return [_paintTexture isEqual:other->_paintTexture]\n+            && _anchor.xParams[0] == other->_anchor.xParams[0]\n+            && _anchor.xParams[1] == other->_anchor.xParams[1]\n+            && _anchor.xParams[2] == other->_anchor.xParams[2]\n+            && _anchor.yParams[0] == other->_anchor.yParams[0]\n+            && _anchor.yParams[1] == other->_anchor.yParams[1]\n+            && _anchor.yParams[2] == other->_anchor.yParams[2];\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"texture_paint\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString* vertShader = @\"vert_tp\";\n+    NSString* fragShader = @\"frag_tp\";\n+\n+    [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_tp\";\n+        fragShader = @\"frag_txt_tp\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+        [encoder setFragmentTexture:_paintTexture atIndex:1];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+        [encoder setFragmentTexture:_paintTexture atIndex:0];\n+    }\n+    const SurfaceRasterFlags srcFlags = {_isOpaque, renderOptions->srcFlags.isPremultiplied};\n+    setTxtUniforms(encoder, 0, 0,\n+                   renderOptions->interpolation, YES, [mtlc.composite getExtraAlpha],\n+                   &srcFlags, &renderOptions->dstFlags);\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    \/\/ This block is not reached in current implementation.\n+    \/\/ Texture paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n+    NSString* vertShader = @\"vert_tp_xorMode\";\n+    NSString* fragShader = @\"frag_tp_xorMode\";\n+    MTLRenderPipelineDescriptor *rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n+\n+    [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n+    [encoder setFragmentTexture:_paintTexture atIndex: 0];\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+    [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+    [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_TEXTURE\");\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+@end\n+\n+@implementation MTLPaint {\n+    jint _paintState;\n+}\n+\n+- (instancetype)init {\n+    self = [super init];\n+    if (self) {\n+        _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;\n+    }\n+\n+    return self;\n+}\n+\n+- (instancetype)initWithState:(jint)state {\n+    self = [super init];\n+    if (self) {\n+        _paintState = state;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![other isKindOfClass:[self class]])\n+        return NO;\n+    return _paintState == other->_paintState;\n+}\n+\n+- (NSUInteger)hash {\n+    return _paintState;\n+}\n+\n+- (NSString *)description {\n+    return @\"unknown-paint\";\n+}\n+\n+static id<MTLSamplerState> samplerNearestClamp = nil;\n+static id<MTLSamplerState> samplerLinearClamp = nil;\n+static id<MTLSamplerState> samplerNearestRepeat = nil;\n+static id<MTLSamplerState> samplerLinearRepeat = nil;\n+\n+void initSamplers(id<MTLDevice> device) {\n+    \/\/ TODO: move this code into SamplerManager (need implement)\n+\n+    if (samplerNearestClamp != nil)\n+        return;\n+\n+    MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n+\n+    samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;\n+    samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;\n+    samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;\n+\n+    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+    samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+    samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+    samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;\n+    samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;\n+    samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;\n+\n+    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+    samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+    samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+}\n+\n+static void setSampler(id<MTLRenderCommandEncoder> encoder, int interpolation, bool repeat) {\n+    id<MTLSamplerState> sampler;\n+    if (repeat) {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;\n+    } else {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;\n+    }\n+    [encoder setFragmentSamplerState:sampler atIndex:0];\n+}\n+\n+static void setTxtUniforms(\n+        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n+        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n+) {\n+    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+\n+    setSampler(encoder, interpolation, repeat);\n+}\n+\n+\/\/ For the current paint mode:\n+\/\/ 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState\n+\/\/ 2. Set vertex and fragment buffers\n+\/\/ Base implementation is used in drawTex2Tex\n+- (void)setPipelineState:(id <MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    \/\/ Called from drawTex2Tex used in flushBuffer and for buffered image ops\n+    if (renderOptions->isTexture) {\n+        NSString * vertShader = @\"vert_txt\";\n+        NSString * fragShader = @\"frag_txt\";\n+        MTLRenderPipelineDescriptor* rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n+        NSObject *bufImgOp = [mtlc getBufImgOp];\n+        if (bufImgOp != nil) {\n+            if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {\n+                MTLRescaleOp *rescaleOp = bufImgOp;\n+                fragShader = @\"frag_txt_op_rescale\";\n+\n+                struct TxtFrameOpRescaleUniforms uf = {\n+                        RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,\n+                        rescaleOp.isNonPremult,\n+                        FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])\n+                };\n+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+                setSampler(encoder, renderOptions->interpolation, NO);\n+            } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {\n+                MTLConvolveOp *convolveOp = bufImgOp;\n+                fragShader = @\"frag_txt_op_convolve\";\n+\n+                struct TxtFrameOpConvolveUniforms uf = {\n+                        [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,\n+                        FLOAT_ARR_TO_V4([convolveOp getImgEdge]),\n+                        convolveOp.kernelSize, convolveOp.isEdgeZeroFill,\n+                };\n+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+                setSampler(encoder, renderOptions->interpolation, NO);\n+\n+                [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];\n+            } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {\n+                MTLLookupOp *lookupOp = bufImgOp;\n+                fragShader = @\"frag_txt_op_lookup\";\n+\n+                struct TxtFrameOpLookupUniforms uf = {\n+                        [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,\n+                        FLOAT_ARR_TO_V4([lookupOp getOffset]), lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,\n+                };\n+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+                setSampler(encoder, renderOptions->interpolation, NO);\n+                [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex:1];\n+            }\n+        } else {\n+            setTxtUniforms(encoder, 0, 0,\n+                           renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                           &renderOptions->srcFlags,\n+                           &renderOptions->dstFlags);\n+\n+        }\n+        id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                            vertexShaderId:vertShader\n+                                                                          fragmentShaderId:fragShader\n+                                                                                 composite:mtlc.composite\n+                                                                             renderOptions:renderOptions\n+                                                                             stencilNeeded:[mtlc.clip isShape]];\n+        [encoder setRenderPipelineState:pipelineState];\n+    }\n+}\n+\n+\/\/ For the current paint mode:\n+\/\/ 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState\n+\/\/ 2. Set vertex and fragment buffers\n+- (void)setXorModePipelineState:(id <MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    if (renderOptions->isTexture) {\n+        initTemplatePipelineDescriptors();\n+        jint xorColor = (jint) [mtlc.composite getXorColor];\n+        NSString * vertShader = @\"vert_txt_xorMode\";\n+        NSString * fragShader = @\"frag_txt_xorMode\";\n+        MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n+        const int col = 0 ^ xorColor;\n+        setTxtUniforms(encoder, col, 0,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+        [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];\n+\n+        BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+        [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+\n+        setTxtUniforms(encoder, 0, 0,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                       &renderOptions->srcFlags,\n+                       &renderOptions->dstFlags);\n+\n+        id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                            vertexShaderId:vertShader\n+                                                                          fragmentShaderId:fragShader\n+                                                                                 composite:mtlc.composite\n+                                                                             renderOptions:renderOptions\n+                                                                             stencilNeeded:[mtlc.clip isShape]];\n+        [encoder setRenderPipelineState:pipelineState];\n+    }\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":1006,"deletions":0,"binary":false,"changes":1006,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLPipelineStatesStorage_h_Included\n+#define MTLPipelineStatesStorage_h_Included\n+\n+#import \"MTLUtils.h\"\n+#include \"RenderOptions.h\"\n+\n+@class MTLComposite;\n+\n+\/**\n+ * The MTLPipelineStatesStorage class used to obtain MTLRenderPipelineState\n+ * *\/\n+\n+\n+@interface MTLPipelineStatesStorage : NSObject {\n+@private\n+\n+id<MTLDevice>       device;\n+id<MTLLibrary>      library;\n+NSMutableDictionary<NSString*, id<MTLFunction>> * shaders;\n+NSMutableDictionary<NSString*, id<MTLComputePipelineState>> * computeStates;\n+}\n+\n+@property (readwrite, assign) id<MTLDevice> device;\n+@property (readwrite, retain) id<MTLLibrary> library;\n+@property (readwrite, retain) NSMutableDictionary<NSString*, id<MTLFunction>> * shaders;\n+@property (readwrite, retain) NSMutableDictionary<NSString*, NSMutableDictionary *> * states;\n+\n+- (id) initWithDevice:(id<MTLDevice>)device shaderLibPath:(NSString *)shadersLib;\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId;\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId\n+                                  stencilNeeded:(bool)stencilNeeded;\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId\n+                                      composite:(MTLComposite*)composite\n+                                  renderOptions:(const RenderOptions *)renderOptions\n+                                  stencilNeeded:(bool)stencilNeeded;\n+\n+- (id<MTLComputePipelineState>) getComputePipelineState:(NSString *)computeShaderId;\n+\n+- (id<MTLFunction>) getShader:(NSString *)name;\n+@end\n+\n+\n+#endif \/\/ MTLPipelineStatesStorage_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.h","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MTLPipelineStatesStorage.h\"\n+\n+#include \"GraphicsPrimitiveMgr.h\"\n+#import \"MTLComposite.h\"\n+\n+#include \"sun_java2d_SunGraphics2D.h\"\n+\n+extern const SurfaceRasterFlags defaultRasterFlags;\n+\n+static void setBlendingFactors(\n+        MTLRenderPipelineColorAttachmentDescriptor * cad,\n+        MTLComposite* composite,\n+        const RenderOptions * renderOptions);\n+\n+@implementation MTLPipelineStatesStorage\n+\n+@synthesize device;\n+@synthesize library;\n+@synthesize shaders;\n+@synthesize states;\n+\n+- (id) initWithDevice:(id<MTLDevice>)dev shaderLibPath:(NSString *)shadersLib {\n+    self = [super init];\n+    if (self == nil) return self;\n+\n+    self.device = dev;\n+\n+    NSError *error = nil;\n+    self.library = [dev newLibraryWithFile:shadersLib error:&error];\n+    if (!self.library) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLPipelineStatesStorage.initWithDevice() - Failed to load Metal shader library.\");\n+        return nil;\n+    }\n+    self.shaders = [NSMutableDictionary dictionaryWithCapacity:10];\n+    self.states = [NSMutableDictionary dictionaryWithCapacity:10];\n+    computeStates = [[NSMutableDictionary dictionaryWithCapacity:10] retain] ;\n+    return self;\n+}\n+\n+- (NSPointerArray * ) getSubStates:(NSString *)vertexShaderId fragmentShader:(NSString *)fragmentShaderId {\n+    NSMutableDictionary * vSubStates = states[vertexShaderId];\n+    if (vSubStates == nil) {\n+        @autoreleasepool {\n+            vSubStates = [NSMutableDictionary dictionary];\n+            [states setObject:vSubStates forKey:vertexShaderId];\n+        }\n+    }\n+    NSPointerArray * sSubStates = vSubStates[fragmentShaderId];\n+    if (sSubStates == nil) {\n+        @autoreleasepool {\n+            sSubStates = [NSPointerArray strongObjectsPointerArray];\n+            [vSubStates setObject:sSubStates forKey:fragmentShaderId];\n+        }\n+    }\n+    return sSubStates;\n+}\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId\n+{\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    return [self getPipelineState:pipelineDescriptor\n+                   vertexShaderId:vertexShaderId\n+                 fragmentShaderId:fragmentShaderId\n+                        composite:nil\n+                    renderOptions:&defaultOptions\n+                    stencilNeeded:NO];\n+}\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId\n+                               stencilNeeded:(bool)stencilNeeded\n+{\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n+    return [self getPipelineState:pipelineDescriptor\n+                   vertexShaderId:vertexShaderId\n+                 fragmentShaderId:fragmentShaderId\n+                        composite:nil\n+                    renderOptions:&defaultOptions\n+                    stencilNeeded:stencilNeeded];\n+}\n+\n+\/\/ Base method to obtain MTLRenderPipelineState.\n+\/\/ NOTE: parameters compositeRule, srcFlags, dstFlags are used to set MTLRenderPipelineColorAttachmentDescriptor multipliers\n+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor\n+                                 vertexShaderId:(NSString *)vertexShaderId\n+                               fragmentShaderId:(NSString *)fragmentShaderId\n+                                      composite:(MTLComposite*) composite\n+                                  renderOptions:(const RenderOptions *)renderOptions\n+                                  stencilNeeded:(bool)stencilNeeded;\n+{\n+    jint compositeRule = composite != nil ? [composite getRule] : RULE_Src;\n+    const jboolean useXorComposite = composite != nil && [composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR;\n+    const jboolean useComposite = composite != nil && compositeRule >= 0\n+        && compositeRule < java_awt_AlphaComposite_MAX_RULE;\n+\n+    \/\/ Calculate index by flags and compositeRule\n+    \/\/ TODO: reimplement, use map with convenient key (calculated by all arguments)\n+    int subIndex = 0;\n+    if (useXorComposite) {\n+        \/\/ compositeRule value is already XOR_COMPOSITE_RULE\n+    }\n+    else {\n+        if (useComposite) {\n+            if (!renderOptions->srcFlags.isPremultiplied)\n+                subIndex |= 1;\n+            if (renderOptions->srcFlags.isOpaque)\n+                subIndex |= 1 << 1;\n+            if (!renderOptions->dstFlags.isPremultiplied)\n+                subIndex |= 1 << 2;\n+            if (renderOptions->dstFlags.isOpaque)\n+                subIndex |= 1 << 3;\n+        } else\n+            compositeRule = RULE_Src;\n+    }\n+\n+    if (stencilNeeded) {\n+        subIndex |= 1 << 4;\n+    }\n+\n+    if (renderOptions->isAA) {\n+        subIndex |= 1 << 5;\n+    }\n+\n+    if ((composite != nil && FLT_LT([composite getExtraAlpha], 1.0f))) {\n+        subIndex |= 1 << 6;\n+    }\n+    int index = compositeRule*64 + subIndex;\n+\n+    NSPointerArray * subStates = [self getSubStates:vertexShaderId fragmentShader:fragmentShaderId];\n+\n+    if (index >= subStates.count) {\n+        subStates.count = (NSUInteger) (index + 1);\n+    }\n+\n+    id<MTLRenderPipelineState> result = [subStates pointerAtIndex:index];\n+    if (result == nil) {\n+        @autoreleasepool {\n+            id <MTLFunction> vertexShader = [self getShader:vertexShaderId];\n+            id <MTLFunction> fragmentShader = [self getShader:fragmentShaderId];\n+            MTLRenderPipelineDescriptor *pipelineDesc = [[pipelineDescriptor copy] autorelease];\n+            pipelineDesc.vertexFunction = vertexShader;\n+            pipelineDesc.fragmentFunction = fragmentShader;\n+\n+            if (useXorComposite) {\n+                \/* The below configuration is the best performant implementation of XOR mode rendering.\n+                   It was found that it works ONLY for basic Colors and not for all RGB combinations.\n+                   Hence, a slow performant XOR mode rendering has been implemented by\n+                   disabling blending & committing after each draw call.\n+                   In XOR mode rendering, subsequent draw calls are rendered\n+                   by shader using already rendered framebuffer pixel value XORed\n+                   with current draw color and XOR color.\n+                pipelineDesc.colorAttachments[0].blendingEnabled = YES;\n+                pipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;\n+                pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationColor;\n+                pipelineDesc.colorAttachments[0].destinationRGBBlendFactor =  MTLBlendFactorOneMinusSourceColor;\n+                *\/\n+\n+                pipelineDesc.colorAttachments[0].blendingEnabled = NO;\n+            } else if (useComposite ||\n+                       (composite != nil  &&\n+                        FLT_LT([composite getExtraAlpha], 1.0f)))\n+            {\n+                setBlendingFactors(\n+                        pipelineDesc.colorAttachments[0],\n+                        composite,\n+                        renderOptions\n+                );\n+            }\n+            if (stencilNeeded) {\n+                pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatStencil8;\n+            }\n+\n+            if (renderOptions->isAA) {\n+                pipelineDesc.sampleCount = MTLAASampleCount;\n+                pipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n+                pipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+                pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n+                pipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n+                pipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+                pipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+                pipelineDesc.colorAttachments[0].blendingEnabled = YES;\n+            }\n+\n+            NSError *error = nil;\n+            result = [[self.device newRenderPipelineStateWithDescriptor:pipelineDesc error:&error] autorelease];\n+            if (result == nil) {\n+                NSLog(@\"Failed to create pipeline state, error %@\", error);\n+                exit(0);\n+            }\n+\n+            [subStates insertPointer:result atIndex:index];\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+- (id<MTLComputePipelineState>) getComputePipelineState:(NSString *)computeShaderId {\n+    id<MTLComputePipelineState> result = computeStates[computeShaderId];\n+    if (result == nil) {\n+        id <MTLFunction> computeShader = [self getShader:computeShaderId];\n+        @autoreleasepool {\n+            NSError *error = nil;\n+            result = (id <MTLComputePipelineState>) [[self.device newComputePipelineStateWithFunction:computeShader error:&error] autorelease];\n+            if (result == nil) {\n+                NSLog(@\"Failed to create pipeline state, error %@\", error);\n+                exit(0);\n+            }\n+            computeStates[computeShaderId] = result;\n+        }\n+    }\n+    return result;\n+}\n+\n+- (id<MTLFunction>) getShader:(NSString *)name {\n+    id<MTLFunction> result = [self.shaders valueForKey:name];\n+    if (result == nil) {\n+        result = [[self.library newFunctionWithName:name] autorelease];\n+        [self.shaders setValue:result forKey:name];\n+    }\n+    return result;\n+}\n+\n+- (void) dealloc {\n+    [super dealloc];\n+    [computeStates release];\n+}\n+@end\n+\n+\/**\n+ * The MTLBlendRule structure encapsulates the two enumerated values that\n+ * comprise a given Porter-Duff blending (compositing) rule.  For example,\n+ * the \"SrcOver\" rule can be represented by:\n+ *     rule.src = GL_ONE;\n+ *     rule.dst = GL_ONE_MINUS_SRC_ALPHA;\n+ *\n+ *     GLenum src;\n+ * The constant representing the source factor in this Porter-Duff rule.\n+ *\n+ *     GLenum dst;\n+ * The constant representing the destination factor in this Porter-Duff rule.\n+ *\/\n+struct MTLBlendRule {\n+    MTLBlendFactor src;\n+    MTLBlendFactor dst;\n+};\n+\n+\/**\n+ * This table contains the standard blending rules (or Porter-Duff compositing\n+ * factors) used in setBlendingFactors(), indexed by the rule constants from the\n+ * AlphaComposite class.\n+ *\/\n+static struct MTLBlendRule StdBlendRules[] = {\n+        { MTLBlendFactorZero,                     MTLBlendFactorZero                }, \/* 0 - Nothing      *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorZero                }, \/* 1 - RULE_Clear   *\/\n+        { MTLBlendFactorOne,                      MTLBlendFactorZero                }, \/* 2 - RULE_Src     *\/\n+        { MTLBlendFactorOne,                      MTLBlendFactorOneMinusSourceAlpha }, \/* 3 - RULE_SrcOver *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorOne                 }, \/* 4 - RULE_DstOver *\/\n+        { MTLBlendFactorDestinationAlpha,         MTLBlendFactorZero                }, \/* 5 - RULE_SrcIn   *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorSourceAlpha         }, \/* 6 - RULE_DstIn   *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorZero                }, \/* 7 - RULE_SrcOut  *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorOneMinusSourceAlpha }, \/* 8 - RULE_DstOut  *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorOne                 }, \/* 9 - RULE_Dst     *\/\n+        { MTLBlendFactorDestinationAlpha,         MTLBlendFactorOneMinusSourceAlpha }, \/*10 - RULE_SrcAtop *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorSourceAlpha         }, \/*11 - RULE_DstAtop *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorOneMinusSourceAlpha }, \/*12 - RULE_AlphaXor*\/\n+};\n+\n+static void setBlendingFactors(\n+        MTLRenderPipelineColorAttachmentDescriptor * cad,\n+        MTLComposite* composite,\n+        const RenderOptions * renderOptions\n+) {\n+    const long compositeRule = composite != nil ? [composite getRule] : RULE_Src;\n+\n+    if ((compositeRule == RULE_Src || compositeRule == RULE_SrcOver) &&\n+        (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f)) &&\n+        (renderOptions->srcFlags.isOpaque))\n+    {\n+        cad.blendingEnabled = NO;\n+        return;\n+    }\n+\n+    cad.blendingEnabled = YES;\n+    cad.rgbBlendOperation = MTLBlendOperationAdd;\n+    cad.alphaBlendOperation = MTLBlendOperationAdd;\n+\n+    cad.sourceAlphaBlendFactor = StdBlendRules[compositeRule].src;\n+    cad.sourceRGBBlendFactor = StdBlendRules[compositeRule].src;\n+    cad.destinationAlphaBlendFactor = StdBlendRules[compositeRule].dst;\n+    cad.destinationRGBBlendFactor = StdBlendRules[compositeRule].dst;\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.m","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLRenderQueue_h_Included\n+#define MTLRenderQueue_h_Included\n+\n+#include \"MTLContext.h\"\n+#include \"MTLSurfaceData.h\"\n+#include \"MTLVertexCache.h\"\n+\n+\/*\n+ * The following macros are used to pick values (of the specified type) off\n+ * the queue.\n+ *\/\n+#define NEXT_VAL(buf, type) (((type *)((buf) += sizeof(type)))[-1])\n+#define NEXT_BYTE(buf)      NEXT_VAL(buf, unsigned char)\n+#define NEXT_INT(buf)       NEXT_VAL(buf, jint)\n+#define NEXT_FLOAT(buf)     NEXT_VAL(buf, jfloat)\n+#define NEXT_BOOLEAN(buf)   (jboolean)NEXT_INT(buf)\n+#define NEXT_LONG(buf)      NEXT_VAL(buf, jlong)\n+#define NEXT_DOUBLE(buf)    NEXT_VAL(buf, jdouble)\n+\n+\/\/ Operations for CheckPreviousOp\n+enum {\n+  MTL_OP_INIT,\n+  MTL_OP_AA,\n+  MTL_OP_SET_COLOR,\n+  MTL_OP_RESET_PAINT,\n+  MTL_OP_SYNC,\n+  MTL_OP_SHAPE_CLIP_SPANS,\n+  MTL_OP_MASK_OP,\n+  MTL_OP_OTHER\n+};\n+\/*\n+ * These macros now simply delegate to the CheckPreviousOp() method.\n+ *\/\n+#define CHECK_PREVIOUS_OP(op) MTLRenderQueue_CheckPreviousOp(op)\n+#define RESET_PREVIOUS_OP() {mtlPreviousOp = MTL_OP_INIT;}\n+\n+\/*\n+ * Increments a pointer (buf) by the given number of bytes.\n+ *\/\n+#define SKIP_BYTES(buf, numbytes) buf += (numbytes)\n+\n+\/*\n+ * Extracts a value at the given offset from the provided packed value.\n+ *\/\n+#define EXTRACT_VAL(packedval, offset, mask) \\\n+    (((packedval) >> (offset)) & (mask))\n+#define EXTRACT_BYTE(packedval, offset) \\\n+    (unsigned char)EXTRACT_VAL(packedval, offset, 0xff)\n+#define EXTRACT_BOOLEAN(packedval, offset) \\\n+    (jboolean)EXTRACT_VAL(packedval, offset, 0x1)\n+\n+\/*\n+ * The following macros allow the caller to return (or continue) if the\n+ * provided value is NULL.  (The strange else clause is included below to\n+ * allow for a trailing ';' after RETURN\/CONTINUE_IF_NULL() invocations.)\n+ *\/\n+#define ACT_IF_NULL(ACTION, value)         \\\n+    if ((value) == NULL) {                 \\\n+        J2dTraceLn1(J2D_TRACE_ERROR,       \\\n+                    \"%s is null\", #value); \\\n+        ACTION;                            \\\n+    } else do { } while (0)\n+#define RETURN_IF_NULL(value)   ACT_IF_NULL(return, value)\n+#define CONTINUE_IF_NULL(value) ACT_IF_NULL(continue, value)\n+\n+MTLContext *MTLRenderQueue_GetCurrentContext();\n+BMTLSDOps *MTLRenderQueue_GetCurrentDestination();\n+void commitEncodedCommands();\n+\n+extern jint mtlPreviousOp;\n+\n+#endif \/* MTLRenderQueue_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.h","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,947 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+\n+#include \"sun_java2d_pipe_BufferedOpCodes.h\"\n+\n+#include \"jlong.h\"\n+#include \"MTLBlitLoops.h\"\n+#include \"MTLBufImgOps.h\"\n+#include \"MTLMaskBlit.h\"\n+#include \"MTLMaskFill.h\"\n+#include \"MTLPaints.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLRenderer.h\"\n+#include \"MTLTextRenderer.h\"\n+#import \"ThreadUtilities.h\"\n+\n+\/**\n+ * References to the \"current\" context and destination surface.\n+ *\/\n+static MTLContext *mtlc = NULL;\n+static BMTLSDOps *dstOps = NULL;\n+jint mtlPreviousOp = MTL_OP_INIT;\n+\n+\n+\/**\n+ * The following methods are implemented in the windowing system (i.e. GLX\n+ * and WGL) source files.\n+ *\/\n+extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);\n+extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);\n+\n+void MTLRenderQueue_CheckPreviousOp(jint op) {\n+\n+    if (mtlPreviousOp == op) {\n+        \/\/ The op is the same as last time, so we can return immediately.\n+        return;\n+    }\n+\n+    if (op == MTL_OP_SET_COLOR) {\n+        if (mtlPreviousOp != MTL_OP_MASK_OP) {\n+            return; \/\/ SET_COLOR should not cause endEncoder\n+        }\n+    } else if (op == MTL_OP_MASK_OP) {\n+        MTLVertexCache_EnableMaskCache(mtlc, dstOps);\n+        mtlPreviousOp = op;\n+        return;\n+    }\n+\n+    J2dTraceLn1(J2D_TRACE_VERBOSE,\n+                \"MTLRenderQueue_CheckPreviousOp: new op=%d\", op);\n+\n+    switch (mtlPreviousOp) {\n+        case MTL_OP_INIT :\n+            mtlPreviousOp = op;\n+            return;\n+        case MTL_OP_MASK_OP :\n+            MTLVertexCache_DisableMaskCache(mtlc);\n+            break;\n+    }\n+\n+    if (mtlc != NULL) {\n+        [mtlc.encoderManager endEncoder];\n+\n+        if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC || op == MTL_OP_SHAPE_CLIP_SPANS) {\n+            MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];\n+            id <MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                [cbwrapper release];\n+            }];\n+            [commandbuf commit];\n+            if (op == MTL_OP_SYNC || op == MTL_OP_SHAPE_CLIP_SPANS) {\n+                [commandbuf waitUntilCompleted];\n+            }\n+        }\n+    }\n+    mtlPreviousOp = op;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLRenderQueue_flushBuffer\n+    (JNIEnv *env, jobject mtlrq,\n+     jlong buf, jint limit)\n+{\n+    unsigned char *b, *end;\n+\n+    J2dTraceLn1(J2D_TRACE_INFO,\n+                \"MTLRenderQueue_flushBuffer: limit=%d\", limit);\n+\n+    b = (unsigned char *)jlong_to_ptr(buf);\n+    if (b == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+            \"MTLRenderQueue_flushBuffer: cannot get direct buffer address\");\n+        return;\n+    }\n+\n+    end = b + limit;\n+    @autoreleasepool {\n+        while (b < end) {\n+            jint opcode = NEXT_INT(b);\n+\n+            J2dTraceLn2(J2D_TRACE_VERBOSE,\n+                    \"MTLRenderQueue_flushBuffer: opcode=%d, rem=%d\",\n+                    opcode, (end-b));\n+\n+            switch (opcode) {\n+\n+                \/\/ draw ops\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_LINE in XOR mode - Force commit earlier draw calls before DRAW_LINE.\");\n+                    }\n+                    jint x1 = NEXT_INT(b);\n+                    jint y1 = NEXT_INT(b);\n+                    jint x2 = NEXT_INT(b);\n+                    jint y2 = NEXT_INT(b);\n+                    MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_RECT in XOR mode - Force commit earlier draw calls before DRAW_RECT.\");\n+                    }\n+                    jint x = NEXT_INT(b);\n+                    jint y = NEXT_INT(b);\n+                    jint w = NEXT_INT(b);\n+                    jint h = NEXT_INT(b);\n+                    MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint nPoints      = NEXT_INT(b);\n+                    jboolean isClosed = NEXT_BOOLEAN(b);\n+                    jint transX       = NEXT_INT(b);\n+                    jint transY       = NEXT_INT(b);\n+                    jint *xPoints = (jint *)b;\n+                    jint *yPoints = ((jint *)b) + nPoints;\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_POLY in XOR mode - Force commit earlier draw calls before DRAW_POLY.\");\n+\n+                        \/\/ draw separate (N-1) lines using N points\n+                        for(int point = 0; point < nPoints-1; point++) {\n+                            jint x1 = xPoints[point] + transX;\n+                            jint y1 = yPoints[point] + transY;\n+                            jint x2 = xPoints[point + 1] + transX;\n+                            jint y2 = yPoints[point + 1] + transY;\n+                            MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);\n+                        }\n+\n+                        if (isClosed) {\n+                            MTLRenderer_DrawLine(mtlc, dstOps, xPoints[0] + transX, yPoints[0] + transY,\n+                                                 xPoints[nPoints-1] + transX, yPoints[nPoints-1] + transY);\n+                        }\n+                    } else {\n+                        MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);\n+                    }\n+\n+                    SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_PIXEL in XOR mode - Force commit earlier draw calls before DRAW_PIXEL.\");\n+                    }\n+\n+                    jint x = NEXT_INT(b);\n+                    jint y = NEXT_INT(b);\n+                    CONTINUE_IF_NULL(mtlc);\n+                    MTLRenderer_DrawPixel(mtlc, dstOps, x, y);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_SCANLINES in XOR mode - Force commit earlier draw calls before \"\n+                                   \"DRAW_SCANLINES.\");\n+                    }\n+\n+                    jint count = NEXT_INT(b);\n+                    MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);\n+\n+                    SKIP_BYTES(b, count * BYTES_PER_SCANLINE);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before \"\n+                                   \"DRAW_PARALLELOGRAM.\");\n+                    }\n+\n+                    jfloat x11 = NEXT_FLOAT(b);\n+                    jfloat y11 = NEXT_FLOAT(b);\n+                    jfloat dx21 = NEXT_FLOAT(b);\n+                    jfloat dy21 = NEXT_FLOAT(b);\n+                    jfloat dx12 = NEXT_FLOAT(b);\n+                    jfloat dy12 = NEXT_FLOAT(b);\n+                    jfloat lwr21 = NEXT_FLOAT(b);\n+                    jfloat lwr12 = NEXT_FLOAT(b);\n+\n+                    MTLRenderer_DrawParallelogram(mtlc, dstOps,\n+                                                  x11, y11,\n+                                                  dx21, dy21,\n+                                                  dx12, dy12,\n+                                                  lwr21, lwr12);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jfloat x11 = NEXT_FLOAT(b);\n+                    jfloat y11 = NEXT_FLOAT(b);\n+                    jfloat dx21 = NEXT_FLOAT(b);\n+                    jfloat dy21 = NEXT_FLOAT(b);\n+                    jfloat dx12 = NEXT_FLOAT(b);\n+                    jfloat dy12 = NEXT_FLOAT(b);\n+                    jfloat lwr21 = NEXT_FLOAT(b);\n+                    jfloat lwr12 = NEXT_FLOAT(b);\n+\n+                    MTLRenderer_DrawAAParallelogram(mtlc, dstOps,\n+                                                    x11, y11,\n+                                                    dx21, dy21,\n+                                                    dx12, dy12,\n+                                                    lwr21, lwr12);\n+                    break;\n+                }\n+\n+                \/\/ fill ops\n+                case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"FILL_RECT in XOR mode - Force commit earlier draw calls before FILL_RECT.\");\n+                    }\n+\n+                    jint x = NEXT_INT(b);\n+                    jint y = NEXT_INT(b);\n+                    jint w = NEXT_INT(b);\n+                    jint h = NEXT_INT(b);\n+                    MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"FILL_SPANS in XOR mode - Force commit earlier draw calls before FILL_SPANS.\");\n+                    }\n+\n+                    jint count = NEXT_INT(b);\n+                    MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);\n+                    SKIP_BYTES(b, count * BYTES_PER_SPAN);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"FILL_PARALLELOGRAM in XOR mode - Force commit earlier draw calls before \"\n+                                   \"FILL_PARALLELOGRAM.\");\n+                    }\n+\n+                    jfloat x11 = NEXT_FLOAT(b);\n+                    jfloat y11 = NEXT_FLOAT(b);\n+                    jfloat dx21 = NEXT_FLOAT(b);\n+                    jfloat dy21 = NEXT_FLOAT(b);\n+                    jfloat dx12 = NEXT_FLOAT(b);\n+                    jfloat dy12 = NEXT_FLOAT(b);\n+                    MTLRenderer_FillParallelogram(mtlc, dstOps,\n+                                                  x11, y11,\n+                                                  dx21, dy21,\n+                                                  dx12, dy12);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jfloat x11 = NEXT_FLOAT(b);\n+                    jfloat y11 = NEXT_FLOAT(b);\n+                    jfloat dx21 = NEXT_FLOAT(b);\n+                    jfloat dy21 = NEXT_FLOAT(b);\n+                    jfloat dx12 = NEXT_FLOAT(b);\n+                    jfloat dy12 = NEXT_FLOAT(b);\n+                    MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n+                                                    x11, y11,\n+                                                    dx21, dy21,\n+                                                    dx12, dy12);\n+                    break;\n+                }\n+\n+                \/\/ text-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+\n+                    if ([mtlc useXORComposite]) {\n+                        commitEncodedCommands();\n+                        J2dTraceLn(J2D_TRACE_VERBOSE,\n+                                   \"DRAW_GLYPH_LIST in XOR mode - Force commit earlier draw calls before \"\n+                                   \"DRAW_GLYPH_LIST.\");\n+                    }\n+\n+                    jint numGlyphs        = NEXT_INT(b);\n+                    jint packedParams     = NEXT_INT(b);\n+                    jfloat glyphListOrigX = NEXT_FLOAT(b);\n+                    jfloat glyphListOrigY = NEXT_FLOAT(b);\n+                    jboolean usePositions = EXTRACT_BOOLEAN(packedParams,\n+                                                            OFFSET_POSITIONS);\n+                    jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,\n+                                                            OFFSET_SUBPIXPOS);\n+                    jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,\n+                                                            OFFSET_RGBORDER);\n+                    jint lcdContrast      = EXTRACT_BYTE(packedParams,\n+                                                         OFFSET_CONTRAST);\n+                    unsigned char *images = b;\n+                    unsigned char *positions;\n+                    jint bytesPerGlyph;\n+                    if (usePositions) {\n+                        positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);\n+                        bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;\n+                    } else {\n+                        positions = NULL;\n+                        bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;\n+                    }\n+                    MTLTR_DrawGlyphList(env, mtlc, dstOps,\n+                                        numGlyphs, usePositions,\n+                                        subPixPos, rgbOrder, lcdContrast,\n+                                        glyphListOrigX, glyphListOrigY,\n+                                        images, positions);\n+                    SKIP_BYTES(b, numGlyphs * bytesPerGlyph);\n+                    break;\n+                }\n+\n+                \/\/ copy-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint x  = NEXT_INT(b);\n+                    jint y  = NEXT_INT(b);\n+                    jint w  = NEXT_INT(b);\n+                    jint h  = NEXT_INT(b);\n+                    jint dx = NEXT_INT(b);\n+                    jint dy = NEXT_INT(b);\n+                    MTLBlitLoops_CopyArea(env, mtlc, dstOps,\n+                                          x, y, w, h, dx, dy);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_BLIT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint packedParams = NEXT_INT(b);\n+                    jint sx1          = NEXT_INT(b);\n+                    jint sy1          = NEXT_INT(b);\n+                    jint sx2          = NEXT_INT(b);\n+                    jint sy2          = NEXT_INT(b);\n+                    jdouble dx1       = NEXT_DOUBLE(b);\n+                    jdouble dy1       = NEXT_DOUBLE(b);\n+                    jdouble dx2       = NEXT_DOUBLE(b);\n+                    jdouble dy2       = NEXT_DOUBLE(b);\n+                    jlong pSrc        = NEXT_LONG(b);\n+                    jlong pDst        = NEXT_LONG(b);\n+                    jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);\n+                    jboolean texture  = EXTRACT_BOOLEAN(packedParams,\n+                                                        OFFSET_TEXTURE);\n+                    jboolean xform    = EXTRACT_BOOLEAN(packedParams,\n+                                                        OFFSET_XFORM);\n+                    jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,\n+                                                        OFFSET_ISOBLIT);\n+                    if (isoblit) {\n+                        MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,\n+                                             xform, hint, texture,\n+                                             sx1, sy1, sx2, sy2,\n+                                             dx1, dy1, dx2, dy2);\n+                    } else {\n+                        jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);\n+                        MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,\n+                                          xform, hint, srctype, texture,\n+                                          sx1, sy1, sx2, sy2,\n+                                          dx1, dy1, dx2, dy2);\n+                    }\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint sx      = NEXT_INT(b);\n+                    jint sy      = NEXT_INT(b);\n+                    jint dx      = NEXT_INT(b);\n+                    jint dy      = NEXT_INT(b);\n+                    jint w       = NEXT_INT(b);\n+                    jint h       = NEXT_INT(b);\n+                    jint dsttype = NEXT_INT(b);\n+                    jlong pSrc   = NEXT_LONG(b);\n+                    jlong pDst   = NEXT_LONG(b);\n+                    MTLBlitLoops_SurfaceToSwBlit(env, mtlc,\n+                                                 pSrc, pDst, dsttype,\n+                                                 sx, sy, dx, dy, w, h);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:\n+                {\n+                    jint x        = NEXT_INT(b);\n+                    jint y        = NEXT_INT(b);\n+                    jint w        = NEXT_INT(b);\n+                    jint h        = NEXT_INT(b);\n+                    jint maskoff  = NEXT_INT(b);\n+                    jint maskscan = NEXT_INT(b);\n+                    jint masklen  = NEXT_INT(b);\n+                    unsigned char *pMask = (masklen > 0) ? b : NULL;\n+                    if (mtlc == nil)\n+                        return;\n+                    CHECK_PREVIOUS_OP(MTL_OP_MASK_OP);\n+                    MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,\n+                                         maskoff, maskscan, masklen, pMask);\n+                    SKIP_BYTES(b, masklen);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint dstx     = NEXT_INT(b);\n+                    jint dsty     = NEXT_INT(b);\n+                    jint width    = NEXT_INT(b);\n+                    jint height   = NEXT_INT(b);\n+                    jint masklen  = width * height * sizeof(jint);\n+                    MTLMaskBlit_MaskBlit(env, mtlc, dstOps,\n+                                         dstx, dsty, width, height, b);\n+                    SKIP_BYTES(b, masklen);\n+                    break;\n+                }\n+\n+                \/\/ state-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint x1 = NEXT_INT(b);\n+                    jint y1 = NEXT_INT(b);\n+                    jint x2 = NEXT_INT(b);\n+                    jint y2 = NEXT_INT(b);\n+                    [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc beginShapeClip:dstOps];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_SHAPE_CLIP_SPANS);\n+                    \/\/ This results in creation of new render encoder with\n+                    \/\/ stencil buffer set as render target\n+                    jint count = NEXT_INT(b);\n+                    MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);\n+                    SKIP_BYTES(b, count * BYTES_PER_SPAN);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc endShapeClip:dstOps];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc resetClip];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint rule         = NEXT_INT(b);\n+                    jfloat extraAlpha = NEXT_FLOAT(b);\n+                    jint flags        = NEXT_INT(b);\n+                    [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jint xorPixel = NEXT_INT(b);\n+                    [mtlc setXorComposite:xorPixel];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:\n+                {\n+                    \/* TODO: check whether something needs to be done here if we are moving out of XOR composite\n+                    commitEncodedCommands();\n+                    MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+                    [cbwrapper onComplete];\n+\n+                    J2dTraceLn(J2D_TRACE_VERBOSE,\n+                     \"RESET_COMPOSITE - Force commit earlier draw calls before RESET_COMPOSITE.\");*\/\n+\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc resetComposite];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jdouble m00 = NEXT_DOUBLE(b);\n+                    jdouble m10 = NEXT_DOUBLE(b);\n+                    jdouble m01 = NEXT_DOUBLE(b);\n+                    jdouble m11 = NEXT_DOUBLE(b);\n+                    jdouble m02 = NEXT_DOUBLE(b);\n+                    jdouble m12 = NEXT_DOUBLE(b);\n+                    [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc resetTransform];\n+                    break;\n+                }\n+\n+                \/\/ context-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pSrc = NEXT_LONG(b);\n+                    jlong pDst = NEXT_LONG(b);\n+\n+                    dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);\n+                    if (mtlc != NULL) {\n+                        [mtlc.encoderManager endEncoder];\n+                    }\n+                    mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pConfigInfo = NEXT_LONG(b);\n+                    MTLGraphicsConfigInfo *mtlInfo =\n+                            (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);\n+\n+                    if (mtlInfo == NULL) {\n+\n+                    } else {\n+                        MTLContext *newMtlc = mtlInfo->context;\n+                        if (newMtlc == NULL) {\n+\n+                        } else {\n+                            if (mtlc != NULL) {\n+                                [mtlc.encoderManager endEncoder];\n+                            }\n+                            mtlc = newMtlc;\n+                            dstOps = NULL;\n+                        }\n+                    }\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pData = NEXT_LONG(b);\n+                    BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);\n+                    if (mtlsdo != NULL) {\n+                        CONTINUE_IF_NULL(mtlc);\n+                        MTLTR_FreeGlyphCaches();\n+                        MTLSD_Delete(env, mtlsdo);\n+                    }\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pData = NEXT_LONG(b);\n+                    BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);\n+                    if (mtlsdo != NULL) {\n+                        CONTINUE_IF_NULL(mtlc);\n+                        MTLSD_Delete(env, mtlsdo);\n+                        if (mtlsdo->privOps != NULL) {\n+                            free(mtlsdo->privOps);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pConfigInfo = NEXT_LONG(b);\n+                    CONTINUE_IF_NULL(mtlc);\n+                    MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);\n+\n+                    \/\/ the previous method will call glX\/wglMakeCurrent(None),\n+                    \/\/ so we should nullify the current mtlc and dstOps to avoid\n+                    \/\/ calling glFlush() (or similar) while no context is current\n+                    if (mtlc != NULL) {\n+                        [mtlc.encoderManager endEncoder];\n+                    }\n+                    mtlc = NULL;\n+                 \/\/   dstOps = NULL;\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    \/\/ invalidate the references to the current context and\n+                    \/\/ destination surface that are maintained at the native level\n+                    if (mtlc != NULL) {\n+                        [mtlc.encoderManager endEncoder];\n+                    }\n+                    mtlc = NULL;\n+                \/\/    dstOps = NULL;\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SYNC:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_SYNC);\n+                    break;\n+                }\n+\n+                \/\/ multibuffering ops\n+                case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong window = NEXT_LONG(b);\n+                    MTLSD_SwapBuffers(env, window);\n+                    break;\n+                }\n+\n+                \/\/ special no-op (mainly used for achieving 8-byte alignment)\n+                case sun_java2d_pipe_BufferedOpCodes_NOOP:\n+                    break;\n+\n+                \/\/ paint-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:\n+                {\n+                  CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);\n+                  [mtlc resetPaint];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);\n+                    jint pixel = NEXT_INT(b);\n+                    [mtlc setColorPaint:pixel];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jboolean useMask= NEXT_BOOLEAN(b);\n+                    jboolean cyclic = NEXT_BOOLEAN(b);\n+                    jdouble p0      = NEXT_DOUBLE(b);\n+                    jdouble p1      = NEXT_DOUBLE(b);\n+                    jdouble p3      = NEXT_DOUBLE(b);\n+                    jint pixel1     = NEXT_INT(b);\n+                    jint pixel2     = NEXT_INT(b);\n+                    [mtlc setGradientPaintUseMask:useMask\n+                                        cyclic:cyclic\n+                                            p0:p0\n+                                            p1:p1\n+                                            p3:p3\n+                                        pixel1:pixel1\n+                                        pixel2:pixel2];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jboolean useMask = NEXT_BOOLEAN(b);\n+                    jboolean linear  = NEXT_BOOLEAN(b);\n+                    jint cycleMethod = NEXT_INT(b);\n+                    jint numStops    = NEXT_INT(b);\n+                    jfloat p0        = NEXT_FLOAT(b);\n+                    jfloat p1        = NEXT_FLOAT(b);\n+                    jfloat p3        = NEXT_FLOAT(b);\n+                    void *fractions, *pixels;\n+                    fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));\n+                    pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));\n+                    [mtlc setLinearGradientPaint:useMask\n+                                          linear:linear\n+                                     cycleMethod:cycleMethod\n+                                        numStops:numStops\n+                                              p0:p0\n+                                              p1:p1\n+                                              p3:p3\n+                                       fractions:fractions\n+                                          pixels:pixels];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jboolean useMask = NEXT_BOOLEAN(b);\n+                    jboolean linear  = NEXT_BOOLEAN(b);\n+                    jint numStops    = NEXT_INT(b);\n+                    jint cycleMethod = NEXT_INT(b);\n+                    jfloat m00       = NEXT_FLOAT(b);\n+                    jfloat m01       = NEXT_FLOAT(b);\n+                    jfloat m02       = NEXT_FLOAT(b);\n+                    jfloat m10       = NEXT_FLOAT(b);\n+                    jfloat m11       = NEXT_FLOAT(b);\n+                    jfloat m12       = NEXT_FLOAT(b);\n+                    jfloat focusX    = NEXT_FLOAT(b);\n+                    void *fractions, *pixels;\n+                    fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));\n+                    pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));\n+                    [mtlc setRadialGradientPaint:useMask\n+                                          linear:linear\n+                                     cycleMethod:cycleMethod\n+                                        numStops:numStops\n+                                             m00:m00\n+                                             m01:m01\n+                                             m02:m02\n+                                             m10:m10\n+                                             m11:m11\n+                                             m12:m12\n+                                          focusX:focusX\n+                                       fractions:fractions\n+                                          pixels:pixels];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jboolean useMask= NEXT_BOOLEAN(b);\n+                    jboolean filter = NEXT_BOOLEAN(b);\n+                    jlong pSrc      = NEXT_LONG(b);\n+                    jdouble xp0     = NEXT_DOUBLE(b);\n+                    jdouble xp1     = NEXT_DOUBLE(b);\n+                    jdouble xp3     = NEXT_DOUBLE(b);\n+                    jdouble yp0     = NEXT_DOUBLE(b);\n+                    jdouble yp1     = NEXT_DOUBLE(b);\n+                    jdouble yp3     = NEXT_DOUBLE(b);\n+                    [mtlc setTexturePaint:useMask\n+                                  pSrcOps:pSrc\n+                                   filter:filter\n+                                      xp0:xp0\n+                                      xp1:xp1\n+                                      xp3:xp3\n+                                      yp0:yp0\n+                                      yp1:yp1\n+                                      yp3:yp3];\n+                    break;\n+                }\n+\n+                \/\/ BufferedImageOp-related ops\n+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pSrc        = NEXT_LONG(b);\n+                    jboolean edgeZero = NEXT_BOOLEAN(b);\n+                    jint kernelWidth  = NEXT_INT(b);\n+                    jint kernelHeight = NEXT_INT(b);\n+\n+                    BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;\n+                    MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero\n+                            kernelWidth:kernelWidth\n+                           kernelHeight:kernelHeight\n+                               srcWidth:bmtlsdOps->width\n+                              srcHeight:bmtlsdOps->height\n+                                 kernel:b\n+                                 device:mtlc.device\n+                                                  ];\n+                    [mtlc setBufImgOp:convolveOp];\n+                    SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc setBufImgOp:NULL];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pSrc          = NEXT_LONG(b);\n+                    jboolean nonPremult = NEXT_BOOLEAN(b);\n+                    jint numFactors     = 4;\n+                    unsigned char *scaleFactors = b;\n+                    unsigned char *offsets = (b + numFactors * sizeof(jfloat));\n+                    MTLRescaleOp * rescaleOp =\n+                            [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];\n+                    [mtlc setBufImgOp:rescaleOp];\n+                    SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc setBufImgOp:NULL];\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    jlong pSrc          = NEXT_LONG(b);\n+                    jboolean nonPremult = NEXT_BOOLEAN(b);\n+                    jboolean shortData  = NEXT_BOOLEAN(b);\n+                    jint numBands       = NEXT_INT(b);\n+                    jint bandLength     = NEXT_INT(b);\n+                    jint offset         = NEXT_INT(b);\n+                    jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);\n+                    void *tableValues = b;\n+\n+                    MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult\n+                                                             shortData:shortData\n+                                                              numBands:numBands\n+                                                            bandLength:bandLength\n+                                                                offset:offset\n+                                                           tableValues:tableValues\n+                                                                device:mtlc.device];\n+                    [mtlc setBufImgOp:lookupOp];\n+                    SKIP_BYTES(b, numBands * bandLength * bytesPerElem);\n+                    break;\n+                }\n+                case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:\n+                {\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n+                    [mtlc setBufImgOp:NULL];\n+                    break;\n+                }\n+\n+                default:\n+                    J2dRlsTraceLn1(J2D_TRACE_ERROR,\n+                        \"MTLRenderQueue_flushBuffer: invalid opcode=%d\", opcode);\n+                    return;\n+            }\n+        }\n+\n+        if (mtlc != NULL) {\n+            if (mtlPreviousOp == MTL_OP_MASK_OP) {\n+                MTLVertexCache_DisableMaskCache(mtlc);\n+            }\n+            [mtlc.encoderManager endEncoder];\n+            MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+            id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                [cbwrapper release];\n+            }];\n+            [commandbuf commit];\n+            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+            if (dstOps != NULL) {\n+                MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+                MTLLayer *layer = (MTLLayer*)dstMTLOps->layer;\n+                if (layer != NULL) {\n+                    [layer startDisplayLink];\n+                }\n+            }\n+        }\n+        RESET_PREVIOUS_OP();\n+    }\n+}\n+\n+\/**\n+ * Returns a pointer to the \"current\" context, as set by the last SET_SURFACES\n+ * or SET_SCRATCH_SURFACE operation.\n+ *\/\n+MTLContext *\n+MTLRenderQueue_GetCurrentContext()\n+{\n+    return mtlc;\n+}\n+\n+\/**\n+ * Returns a pointer to the \"current\" destination surface, as set by the last\n+ * SET_SURFACES operation.\n+ *\/\n+BMTLSDOps *\n+MTLRenderQueue_GetCurrentDestination()\n+{\n+    return dstOps;\n+}\n+\n+\/**\n+ * commit earlier encoded commmands\n+ * these would be rendered to the back-buffer - which is read in shader while rendering in XOR mode\n+ *\/\n+void commitEncodedCommands() {\n+    [mtlc.encoderManager endEncoder];\n+\n+    MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];\n+    id <MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+    [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+        [cbwrapper release];\n+    }];\n+    [commandbuf commit];\n+    [commandbuf waitUntilCompleted];\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":947,"deletions":0,"binary":false,"changes":947,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLRenderer_h_Included\n+#define MTLRenderer_h_Included\n+\n+#include \"sun_java2d_pipe_BufferedRenderPipe.h\"\n+#include \"MTLContext.h\"\n+#include \"MTLGraphicsConfig.h\"\n+#import \"MTLLayer.h\"\n+\n+#define BYTES_PER_POLY_POINT \\\n+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_POLY_POINT\n+#define BYTES_PER_SCANLINE \\\n+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_SCANLINE\n+#define BYTES_PER_SPAN \\\n+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_SPAN\n+\n+void MTLRenderer_DrawLine(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint x1, jint y1, jint x2, jint y2);\n+void MTLRenderer_DrawPixel(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint x, jint y);\n+void MTLRenderer_DrawRect(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint x, jint y, jint w, jint h);\n+void MTLRenderer_DrawPoly(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint nPoints, jint isClosed,\n+                          jint transX, jint transY,\n+                          jint *xPoints, jint *yPoints);\n+void MTLRenderer_DrawScanlines(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                               jint count, jint *scanlines);\n+void MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12,\n+                                   jfloat lw21, jfloat lw12);\n+void MTLRenderer_DrawAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12,\n+                                   jfloat lw21, jfloat lw12);\n+void MTLRenderer_FillRect(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint x, jint y, jint w, jint h);\n+void MTLRenderer_FillSpans(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                           jint count, jint *spans);\n+void MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12);\n+void MTLRenderer_FillAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12);\n+\n+#endif \/* MTLRenderer_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.h","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,1012 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jlong.h>\n+#include <jni_util.h>\n+#include <math.h>\n+\n+#include \"sun_java2d_metal_MTLRenderer.h\"\n+\n+#include \"MTLRenderer.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLSurfaceData.h\"\n+#include \"MTLUtils.h\"\n+#import \"MTLLayer.h\"\n+\n+\/**\n+ * Note: Some of the methods in this file apply a \"magic number\"\n+ * translation to line segments. It is same as what we have in\n+ * OGLrenderer.\n+ *\n+ * The \"magic numbers\" you see here have been empirically derived\n+ * after testing on a variety of graphics hardware in order to find some\n+ * reasonable middle ground between the two specifications.  The general\n+ * approach is to apply a fractional translation to vertices so that they\n+ * hit pixel centers and therefore touch the same pixels as in our other\n+ * pipelines.  Emphasis was placed on finding values so that MTL lines with\n+ * a slope of +\/- 1 hit all the same pixels as our other (software) loops.\n+ * The stepping in other diagonal lines rendered with MTL may deviate\n+ * slightly from those rendered with our software loops, but the most\n+ * important thing is that these magic numbers ensure that all MTL lines\n+ * hit the same endpoints as our software loops.\n+ *\n+ * If you find it necessary to change any of these magic numbers in the\n+ * future, just be sure that you test the changes across a variety of\n+ * hardware to ensure consistent rendering everywhere.\n+ *\/\n+\n+void MTLRenderer_DrawLine(MTLContext *mtlc, BMTLSDOps * dstOps, jint x1, jint y1, jint x2, jint y2) {\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawLine: dest is null\");\n+        return;\n+    }\n+\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLRenderer_DrawLine (x1=%d y1=%d x2=%d y2=%d), dst tex=%p\", x1, y1, x2, y2, dstOps->pTexture);\n+\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n+\n+    \/\/ DrawLine implementation same as in OGLRenderer.c\n+    struct Vertex verts[2];\n+    if (y1 == y2) {\n+        \/\/ horizontal\n+        float fx1 = (float)x1;\n+        float fx2 = (float)x2;\n+        float fy  = ((float)y1) + 0.2f;\n+\n+        if (x1 > x2) {\n+            float t = fx1; fx1 = fx2; fx2 = t;\n+        }\n+\n+        verts[0].position[0] = fx1 + 0.2f;\n+        verts[0].position[1] = fy;\n+        verts[1].position[0] = fx2 + 1.2f;\n+        verts[1].position[1] = fy;\n+    } else if (x1 == x2) {\n+        \/\/ vertical\n+        float fx  = ((float)x1) + 0.2f;\n+        float fy1 = (float)y1;\n+        float fy2 = (float)y2;\n+\n+        if (y1 > y2) {\n+            float t = fy1; fy1 = fy2; fy2 = t;\n+        }\n+\n+        verts[0].position[0] = fx;\n+        verts[0].position[1] = fy1 + 0.2f;\n+        verts[1].position[0] = fx;\n+        verts[1].position[1] = fy2 + 1.2f;\n+    } else {\n+        \/\/ diagonal\n+        float fx1 = (float)x1;\n+        float fy1 = (float)y1;\n+        float fx2 = (float)x2;\n+        float fy2 = (float)y2;\n+\n+        if (x1 < x2) {\n+            fx1 += 0.2f;\n+            fx2 += 1.0f;\n+        } else {\n+            fx1 += 0.8f;\n+            fx2 -= 0.2f;\n+        }\n+\n+        if (y1 < y2) {\n+            fy1 += 0.2f;\n+            fy2 += 1.0f;\n+        } else {\n+            fy1 += 0.8f;\n+            fy2 -= 0.2f;\n+        }\n+        verts[0].position[0] = fx1;\n+        verts[0].position[1] = fy1;\n+        verts[1].position[0] = fx2;\n+        verts[1].position[1] = fy2;\n+    }\n+\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0 vertexCount:2];\n+}\n+\n+void MTLRenderer_DrawPixel(MTLContext *mtlc, BMTLSDOps * dstOps, jint x, jint y) {\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawPixel: dest is null\");\n+        return;\n+    }\n+\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    J2dTraceLn3(J2D_TRACE_INFO, \"MTLRenderer_DrawPixel (x=%d y=%d), dst tex=%p\", x, y, dest);\n+\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n+\n+    \/\/ Translate each vertex by a fraction so\n+    \/\/ that we hit pixel centers.\n+    float fx = (float)x + 0.2f;\n+    float fy = (float)y + 0.5f;\n+    struct Vertex vert = {{fx, fy}};\n+    [mtlEncoder setVertexBytes:&vert length:sizeof(vert) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypePoint vertexStart:0 vertexCount:1];\n+}\n+\n+void MTLRenderer_DrawRect(MTLContext *mtlc, BMTLSDOps * dstOps, jint x, jint y, jint w, jint h) {\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawRect: dest is null\");\n+        return;\n+    }\n+\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLRenderer_DrawRect (x=%d y=%d w=%d h=%d), dst tex=%p\", x, y, w, h, dest);\n+\n+    \/\/ TODO: use DrawParallelogram(x, y, w, h, lw=1, lh=1)\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n+\n+    \/\/ Translate each vertex by a fraction so\n+    \/\/ that we hit pixel centers.\n+    const int verticesCount = 5;\n+    float fx = (float)x + 0.2f;\n+    float fy = (float)y + 0.5f;\n+    float fw = (float)w;\n+    float fh = (float)h;\n+    struct Vertex vertices[5] = {\n+            {{fx, fy}},\n+            {{fx + fw, fy}},\n+            {{fx + fw, fy + fh}},\n+            {{fx, fy + fh}},\n+            {{fx, fy}},\n+    };\n+    [mtlEncoder setVertexBytes:vertices length:sizeof(vertices) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeLineStrip vertexStart:0 vertexCount:verticesCount];\n+}\n+\n+const int POLYLINE_BUF_SIZE = 64;\n+\n+NS_INLINE void fillVertex(struct Vertex * vertex, int x, int y) {\n+    vertex->position[0] = x;\n+    vertex->position[1] = y;\n+}\n+\n+void MTLRenderer_DrawPoly(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                     jint nPoints, jint isClosed,\n+                     jint transX, jint transY,\n+                     jint *xPoints, jint *yPoints)\n+{\n+    \/\/ Note that BufferedRenderPipe.drawPoly() has already rejected polys\n+    \/\/ with nPoints<2, so we can be certain here that we have nPoints>=2.\n+    if (xPoints == NULL || yPoints == NULL || nPoints < 2) { \/\/ just for insurance\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawPoly: points array is empty\");\n+        return;\n+    }\n+\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawPoly: dest is null\");\n+        return;\n+    }\n+\n+    J2dTraceLn4(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: %d points, transX=%d, transY=%d, dst tex=%p\", nPoints, transX, transY, dstOps->pTexture);\n+\n+    __block struct {\n+        struct Vertex verts[POLYLINE_BUF_SIZE];\n+    } pointsChunk;\n+\n+    \/\/ We intend to submit draw commands in batches of POLYLINE_BUF_SIZE vertices at a time\n+    \/\/ Subsequent batches need to be connected - so end point in one batch is repeated as first point in subsequent batch\n+    \/\/ This inflates the total number of points by a factor of number of batches of size POLYLINE_BUF_SIZE\n+    nPoints += (nPoints\/POLYLINE_BUF_SIZE);\n+\n+    jint prevX = *(xPoints++);\n+    jint prevY = *(yPoints++);\n+    const jint firstX = prevX;\n+    const jint firstY = prevY;\n+    while (nPoints > 0) {\n+        const bool isLastChunk = nPoints <= POLYLINE_BUF_SIZE;\n+        __block int chunkSize = isLastChunk ? nPoints : POLYLINE_BUF_SIZE;\n+\n+        fillVertex(pointsChunk.verts, prevX + transX + 0.5f, prevY + transY + 0.5f);\n+        J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: Point - (%1.2f, %1.2f)\", prevX + transX + 0.5f, prevY + transY + 0.5f);\n+\n+        for (int i = 1; i < chunkSize; i++) {\n+            prevX = *(xPoints++);\n+            prevY = *(yPoints++);\n+            fillVertex(pointsChunk.verts + i, prevX + transX + 0.5f, prevY + transY + 0.5f);\n+            J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: Point - (%1.2f, %1.2f)\", prevX + transX + 0.5f,prevY + transY + 0.5f);\n+        }\n+\n+        bool drawCloseSegment = false;\n+        if (isClosed && isLastChunk) {\n+            if (chunkSize + 2 <= POLYLINE_BUF_SIZE) {\n+                fillVertex(pointsChunk.verts + chunkSize, firstX + transX + 0.5f, firstY + transY + 0.5f);\n+                J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: Point - (%1.2f, %1.2f)\",firstX + transX + 0.5f, firstY + transY + 0.5f);\n+\n+                ++chunkSize;\n+            } else\n+                drawCloseSegment = true;\n+        }\n+\n+        nPoints -= chunkSize;\n+        id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+        if (mtlEncoder == nil)\n+            return;\n+\n+        [mtlEncoder setVertexBytes:pointsChunk.verts length:sizeof(pointsChunk.verts) atIndex:MeshVertexBuffer];\n+        [mtlEncoder drawPrimitives:MTLPrimitiveTypeLineStrip vertexStart:0 vertexCount:chunkSize];\n+\n+        if (drawCloseSegment) {\n+            struct Vertex vertices[2] = {\n+                    {{prevX + transX + 0.5f, prevY + transY + 0.5f}},\n+                    {{firstX + transX + 0.5f, firstY + transY + 0.5f}}\n+            };\n+\n+            J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: last segment Point1 - (%1.2f, %1.2f)\",prevX + transX + 0.5f, prevY + transY + 0.5f);\n+            J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawPoly: last segment Point2 - (%1.2f, %1.2f)\",firstX + transX + 0.5f, firstY + transY + 0.5f);\n+\n+            [mtlEncoder setVertexBytes:vertices length:sizeof(vertices) atIndex:MeshVertexBuffer];\n+            [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0 vertexCount:2];\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLRenderer_drawPoly\n+    (JNIEnv *env, jobject mtlr,\n+     jintArray xpointsArray, jintArray ypointsArray,\n+     jint nPoints, jboolean isClosed,\n+     jint transX, jint transY)\n+{\n+    jint *xPoints, *yPoints;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLRenderer_drawPoly\");\n+\n+    xPoints = (jint *)\n+        (*env)->GetPrimitiveArrayCritical(env, xpointsArray, NULL);\n+    if (xPoints != NULL) {\n+        yPoints = (jint *)\n+            (*env)->GetPrimitiveArrayCritical(env, ypointsArray, NULL);\n+        if (yPoints != NULL) {\n+            MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();\n+            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+\n+            MTLRenderer_DrawPoly(mtlc, dstOps,\n+                                 nPoints, isClosed,\n+                                 transX, transY,\n+                                 xPoints, yPoints);\n+            if (mtlc != NULL) {\n+                RESET_PREVIOUS_OP();\n+                [mtlc.encoderManager endEncoder];\n+                MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+                id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+                [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                    [cbwrapper release];\n+                }];\n+                [commandbuf commit];\n+            }\n+\n+            (*env)->ReleasePrimitiveArrayCritical(env, ypointsArray, yPoints,\n+                                                  JNI_ABORT);\n+        }\n+        (*env)->ReleasePrimitiveArrayCritical(env, xpointsArray, xPoints,\n+                                              JNI_ABORT);\n+    }\n+}\n+\n+const int SCANLINE_MAX_VERTEX_SIZE = 4096;\n+const int VERTEX_STRUCT_SIZE = 8;\n+const int NUM_OF_VERTICES_PER_SCANLINE = 2;\n+\n+void\n+MTLRenderer_DrawScanlines(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                          jint scanlineCount, jint *scanlines)\n+{\n+\n+    J2dTraceLn2(J2D_TRACE_INFO, \"MTLRenderer_DrawScanlines (scanlineCount=%d), dst tex=%p\", scanlineCount, dstOps->pTexture);\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+            J2dTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawScanlines: dest is null\");\n+            return;\n+    }\n+    RETURN_IF_NULL(scanlines);\n+    int vertexSize = NUM_OF_VERTICES_PER_SCANLINE\n+        * scanlineCount * VERTEX_STRUCT_SIZE;\n+    J2dTraceLn1(J2D_TRACE_INFO, \"MTLRenderer_DrawScanlines: Total vertex size : %d\", vertexSize);\n+    if (vertexSize == 0) return;\n+\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+\n+    if (mtlEncoder == nil) return;\n+\n+    if (vertexSize <= SCANLINE_MAX_VERTEX_SIZE) {\n+        struct Vertex verts[NUM_OF_VERTICES_PER_SCANLINE * scanlineCount];\n+\n+        for (int j = 0, i = 0; j < scanlineCount; j++) {\n+            \/\/ Translate each vertex by a fraction so\n+            \/\/ that we hit pixel centers.\n+            float x1 = ((float)*(scanlines++)) + 0.2f;\n+            float x2 = ((float)*(scanlines++)) + 1.2f;\n+            float y  = ((float)*(scanlines++)) + 0.5f;\n+            struct Vertex v1 = {{x1, y}};\n+            struct Vertex v2 = {{x2, y}};\n+            verts[i++] = v1;\n+            verts[i++] = v2;\n+        }\n+\n+        [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+        [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0\n+            vertexCount:NUM_OF_VERTICES_PER_SCANLINE * scanlineCount];\n+    } else {\n+        int remainingScanlineCount = vertexSize;\n+        do {\n+            if (remainingScanlineCount > SCANLINE_MAX_VERTEX_SIZE) {\n+                struct Vertex verts[SCANLINE_MAX_VERTEX_SIZE\/ VERTEX_STRUCT_SIZE];\n+\n+                for (int j = 0, i = 0; j < (SCANLINE_MAX_VERTEX_SIZE \/ (VERTEX_STRUCT_SIZE * 2)); j++) {\n+                    \/\/ Translate each vertex by a fraction so\n+                    \/\/ that we hit pixel centers.\n+                    float x1 = ((float)*(scanlines++)) + 0.2f;\n+                    float x2 = ((float)*(scanlines++)) + 1.2f;\n+                    float y  = ((float)*(scanlines++)) + 0.5f;\n+                    struct Vertex v1 = {{x1, y}};\n+                    struct Vertex v2 = {{x2, y}};\n+                    verts[i++] = v1;\n+                    verts[i++] = v2;\n+                }\n+\n+                [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+                [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0\n+                    vertexCount:(SCANLINE_MAX_VERTEX_SIZE \/ VERTEX_STRUCT_SIZE)];\n+                remainingScanlineCount -= SCANLINE_MAX_VERTEX_SIZE;\n+            } else {\n+                struct Vertex verts[remainingScanlineCount \/ VERTEX_STRUCT_SIZE];\n+\n+                for (int j = 0, i = 0; j < (remainingScanlineCount \/ (VERTEX_STRUCT_SIZE * 2)); j++) {\n+                    \/\/ Translate each vertex by a fraction so\n+                    \/\/ that we hit pixel centers.\n+                    float x1 = ((float)*(scanlines++)) + 0.2f;\n+                    float x2 = ((float)*(scanlines++)) + 1.2f;\n+                    float y  = ((float)*(scanlines++)) + 0.5f;\n+                    struct Vertex v1 = {{x1, y}};\n+                    struct Vertex v2 = {{x2, y}};\n+                    verts[i++] = v1;\n+                    verts[i++] = v2;\n+                }\n+\n+                [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+                [mtlEncoder drawPrimitives:MTLPrimitiveTypeLine vertexStart:0\n+                    vertexCount:(remainingScanlineCount \/ VERTEX_STRUCT_SIZE)];\n+                remainingScanlineCount -= remainingScanlineCount;\n+            }\n+            J2dTraceLn1(J2D_TRACE_INFO,\n+                \"MTLRenderer_DrawScanlines: Remaining vertex size %d\", remainingScanlineCount);\n+        } while (remainingScanlineCount != 0);\n+    }\n+}\n+\n+void\n+MTLRenderer_FillRect(MTLContext *mtlc, BMTLSDOps * dstOps, jint x, jint y, jint w, jint h)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLRenderer_FillRect\");\n+\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillRect: current dest is null\");\n+        return;\n+    }\n+\n+    struct Vertex verts[QUAD_VERTEX_COUNT] = {\n+        { {x, y}},\n+        { {x, y+h}},\n+        { {x+w, y}},\n+        { {x+w, y+h}\n+    }};\n+\n+\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    J2dTraceLn5(J2D_TRACE_INFO, \"MTLRenderer_FillRect (x=%d y=%d w=%d h=%d), dst tex=%p\", x, y, w, h, dest);\n+\n+    \/\/ Encode render command.\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+    if (mtlEncoder == nil)\n+        return;\n+\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount: QUAD_VERTEX_COUNT];\n+}\n+\n+void MTLRenderer_FillSpans(MTLContext *mtlc, BMTLSDOps * dstOps, jint spanCount, jint *spans)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLRenderer_FillSpans\");\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillSpans: dest is null\");\n+        return;\n+    }\n+\n+    \/\/ MTLRenderCommandEncoder setVertexBytes usage is recommended if the data is of 4KB.\n+\n+    \/\/ We use a buffer that closely matches the 4KB limit size\n+    \/\/ This buffer is resued multiple times to encode draw calls of a triangle list\n+    \/\/ NOTE : Due to nature of *spans data - it is not possible to use triangle strip.\n+    \/\/ We use triangle list to draw spans\n+\n+    \/\/ Destination texture to which render commands are encoded\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    id<MTLTexture> destAA = nil;\n+    BOOL isDestOpaque = dstOps->isOpaque;\n+    if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {\n+        dest = dstOps->pStencilData;\n+        isDestOpaque = NO;\n+    }\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dest isDstOpaque:isDestOpaque];\n+    if (mtlEncoder == nil) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillSpans: mtlEncoder is nil\");\n+        return;\n+    }\n+\n+    \/\/ This is the max no of vertices (of struct Vertex - 8 bytes) we can accomodate in 4KB\n+    const int TOTAL_VERTICES_IN_BLOCK = 510;\n+    struct Vertex vertexList[TOTAL_VERTICES_IN_BLOCK]; \/\/ a total of 170 triangles ==> 85 spans\n+\n+    jfloat shapeX1 = mtlc.clip.shapeX;\n+    jfloat shapeY1 = mtlc.clip.shapeY;\n+    jfloat shapeX2 = shapeX1 + mtlc.clip.shapeWidth;\n+    jfloat shapeY2 = shapeY1 + mtlc.clip.shapeHeight;\n+\n+    int counter = 0;\n+    for (int i = 0; i < spanCount; i++) {\n+        jfloat x1 = *(spans++);\n+        jfloat y1 = *(spans++);\n+        jfloat x2 = *(spans++);\n+        jfloat y2 = *(spans++);\n+\n+        if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {\n+            if (shapeX1 > x1) shapeX1 = x1;\n+            if (shapeY1 > y1) shapeY1 = y1;\n+            if (shapeX2 < x2) shapeX2 = x2;\n+            if (shapeY2 < y2) shapeY2 = y2;\n+        }\n+\n+        struct Vertex verts[6] = {\n+            {{x1, y1}},\n+            {{x1, y2}},\n+            {{x2, y1}},\n+\n+            {{x1, y2}},\n+            {{x2, y1}},\n+            {{x2, y2}\n+        }};\n+\n+        memcpy(&vertexList[counter], &verts, sizeof(verts));\n+        counter += 6;\n+\n+        \/\/ If vertexList buffer full\n+        if (counter % TOTAL_VERTICES_IN_BLOCK == 0) {\n+            [mtlEncoder setVertexBytes:vertexList length:sizeof(vertexList) atIndex:MeshVertexBuffer];\n+            [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:TOTAL_VERTICES_IN_BLOCK];\n+            counter = 0;\n+        }\n+    }\n+\n+    \/\/ Draw triangles using remaining vertices if any\n+    if (counter != 0) {\n+        [mtlEncoder setVertexBytes:vertexList length:sizeof(vertexList) atIndex:MeshVertexBuffer];\n+        [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:counter];\n+    }\n+\n+    if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {\n+        if (shapeX1 < 0) shapeX1 = 0;\n+        if (shapeY1 < 0) shapeY1 = 0;\n+        if (shapeX1 > dest.width) shapeX1 = dest.width;\n+        if (shapeY1 > dest.height) shapeY1 = dest.height;\n+        if (shapeX2 < 0) shapeX2 = 0;\n+        if (shapeY2 < 0) shapeY2 = 0;\n+        if (shapeX2 > dest.width) shapeX2 = dest.width;\n+        if (shapeY2 > dest.height) shapeY2 = dest.height;\n+\n+        mtlc.clip.shapeX = (NSUInteger) shapeX1;\n+        mtlc.clip.shapeY = (NSUInteger) shapeY1;\n+        mtlc.clip.shapeWidth = (NSUInteger) (shapeX2 - shapeX1);\n+        mtlc.clip.shapeHeight = (NSUInteger) (shapeY2 - shapeY1);\n+    }\n+}\n+\n+void\n+MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12)\n+{\n+\n+    if (mtlc == NULL || dstOps == NULL || dstOps->pTexture == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillParallelogram: current dest is null\");\n+        return;\n+    }\n+\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    J2dTraceLn7(J2D_TRACE_INFO,\n+                \"MTLRenderer_FillParallelogram\"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f dst tex=%p)\",\n+                fx11, fy11,\n+                dx21, dy21,\n+                dx12, dy12, dest);\n+\n+    struct Vertex verts[QUAD_VERTEX_COUNT] = {\n+            { {fx11, fy11}},\n+            { {fx11+dx21, fy11+dy21}},\n+            { {fx11+dx12, fy11+dy12}},\n+            { {fx11 + dx21 + dx12, fy11+ dy21 + dy12}\n+        }};\n+\n+    \/\/ Encode render command.\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];;\n+\n+    if (mtlEncoder == nil) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_FillParallelogram: error creating MTLRenderCommandEncoder.\");\n+        return;\n+    }\n+\n+    [mtlEncoder setVertexBytes:verts length:sizeof(verts) atIndex:MeshVertexBuffer];\n+    [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount: QUAD_VERTEX_COUNT];\n+}\n+\n+void\n+MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12,\n+                              jfloat lwr21, jfloat lwr12)\n+{\n+    \/\/ dx,dy for line width in the \"21\" and \"12\" directions.\n+    jfloat ldx21 = dx21 * lwr21;\n+    jfloat ldy21 = dy21 * lwr21;\n+    jfloat ldx12 = dx12 * lwr12;\n+    jfloat ldy12 = dy12 * lwr12;\n+\n+    \/\/ calculate origin of the outer parallelogram\n+    jfloat ox11 = fx11 - (ldx21 + ldx12) \/ 2.0f;\n+    jfloat oy11 = fy11 - (ldy21 + ldy12) \/ 2.0f;\n+\n+    J2dTraceLn8(J2D_TRACE_INFO,\n+                \"MTLRenderer_DrawParallelogram\"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f lwr1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f lwr2=%6.2f)\",\n+                fx11, fy11,\n+                dx21, dy21, lwr21,\n+                dx12, dy12, lwr12);\n+\n+\n+    \/\/ Only need to generate 4 quads if the interior still\n+    \/\/ has a hole in it (i.e. if the line width ratio was\n+    \/\/ less than 1.0)\n+    if (lwr21 < 1.0f && lwr12 < 1.0f) {\n+\n+        \/\/ Note: \"TOP\", \"BOTTOM\", \"LEFT\" and \"RIGHT\" here are\n+        \/\/ relative to whether the dxNN variables are positive\n+        \/\/ and negative.  The math works fine regardless of\n+        \/\/ their signs, but for conceptual simplicity the\n+        \/\/ comments will refer to the sides as if the dxNN\n+        \/\/ were all positive.  \"TOP\" and \"BOTTOM\" segments\n+        \/\/ are defined by the dxy21 deltas.  \"LEFT\" and \"RIGHT\"\n+        \/\/ segments are defined by the dxy12 deltas.\n+\n+        \/\/ Each segment includes its starting corner and comes\n+        \/\/ to just short of the following corner.  Thus, each\n+        \/\/ corner is included just once and the only lengths\n+        \/\/ needed are the original parallelogram delta lengths\n+        \/\/ and the \"line width deltas\".  The sides will cover\n+        \/\/ the following relative territories:\n+        \/\/\n+        \/\/     T T T T T R\n+        \/\/      L         R\n+        \/\/       L         R\n+        \/\/        L         R\n+        \/\/         L         R\n+        \/\/          L B B B B B\n+\n+        \/\/ Every segment is drawn as a filled Parallelogram quad\n+        \/\/ Each quad is encoded using two triangles\n+        \/\/ For 4 segments - there are 8 triangles in total\n+        \/\/ Each triangle has 3 vertices\n+        const int TOTAL_VERTICES = 8 * 3;\n+        struct Vertex vertexList[TOTAL_VERTICES];\n+        int i = 0;\n+\n+        \/\/ TOP segment, to left side of RIGHT edge\n+        \/\/ \"width\" of original pgram, \"height\" of hor. line size\n+        fx11 = ox11;\n+        fy11 = oy11;\n+\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21, fy11 + dy21);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11 + ldx12, fy11 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+\n+        \/\/ RIGHT segment, to top of BOTTOM edge\n+        \/\/ \"width\" of vert. line size , \"height\" of original pgram\n+        fx11 = ox11 + dx21;\n+        fy11 = oy11 + dy21;\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21, fy11 + ldy21);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11 + dx12, fy11 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+\n+        \/\/ BOTTOM segment, from right side of LEFT edge\n+        \/\/ \"width\" of original pgram, \"height\" of hor. line size\n+        fx11 = ox11 + dx12 + ldx21;\n+        fy11 = oy11 + dy12 + ldy21;\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + dx21, fy11 + dy21);\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+\n+        fillVertex(vertexList + (i++), fx11 + dx21 + ldx12, fy11 + dy21 + ldy12);\n+        fillVertex(vertexList + (i++), fx11 + ldx12, fy11 + ldy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+\n+        \/\/ LEFT segment, from bottom of TOP edge\n+        \/\/ \"width\" of vert. line size , \"height\" of inner pgram\n+        fx11 = ox11 + ldx12;\n+        fy11 = oy11 + ldy12;\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+        fillVertex(vertexList + (i++), fx11 + ldx21, fy11 + ldy21);\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+\n+        fillVertex(vertexList + (i++), fx11 + ldx21 + dx12, fy11 + ldy21 + dy12);\n+        fillVertex(vertexList + (i++), fx11 + dx12, fy11 + dy12);\n+        fillVertex(vertexList + (i++), fx11, fy11);\n+\n+        \/\/ Encode render command.\n+        id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n+\n+        if (mtlEncoder == nil) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLRenderer_DrawParallelogram: error creating MTLRenderCommandEncoder.\");\n+            return;\n+        }\n+\n+        [mtlEncoder setVertexBytes:vertexList length:sizeof(vertexList) atIndex:MeshVertexBuffer];\n+        [mtlEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:TOTAL_VERTICES];\n+    } else {\n+        \/\/ The line width ratios were large enough to consume\n+        \/\/ the entire hole in the middle of the parallelogram\n+        \/\/ so we can just issue one large quad for the outer\n+        \/\/ parallelogram.\n+        dx21 += ldx21;\n+        dy21 += ldy21;\n+        dx12 += ldx12;\n+        dy12 += ldy12;\n+        MTLRenderer_FillParallelogram(mtlc, dstOps, ox11, oy11, dx21, dy21, dx12, dy12);\n+    }\n+}\n+\n+static struct AAVertex aaVertices[6];\n+static jint vertexCacheIndex = 0;\n+\n+#define AA_ADD_VERTEX(OU, OV, IU, IV, DX, DY) \\\n+    do { \\\n+        struct AAVertex *v = &aaVertices[vertexCacheIndex++]; \\\n+        v->otxtpos[0] = OU; \\\n+        v->otxtpos[1] = OV; \\\n+        v->itxtpos[0] = IU; \\\n+        v->itxtpos[1] = IV; \\\n+        v->position[0]= DX; \\\n+        v->position[1] = DY; \\\n+    } while (0)\n+\n+#define AA_ADD_TRIANGLES(ou11, ov11, iu11, iv11, ou21, ov21, iu21, iv21, ou22, ov22, iu22, iv22, ou12, ov12, iu12, iv12, DX1, DY1, DX2, DY2) \\\n+    do { \\\n+        AA_ADD_VERTEX(ou11, ov11, iu11, iv11, DX1, DY1); \\\n+        AA_ADD_VERTEX(ou21, ov21, iu21, iv21, DX2, DY1); \\\n+        AA_ADD_VERTEX(ou22, ov22, iu22, iv22, DX2, DY2); \\\n+        AA_ADD_VERTEX(ou22, ov22, iu22, iv22, DX2, DY2); \\\n+        AA_ADD_VERTEX(ou12, ov12, iu12, iv12, DX1, DY2); \\\n+        AA_ADD_VERTEX(ou11, ov11, iu11, iv11, DX1, DY1); \\\n+    } while (0)\n+\n+static MTLRenderPipelineDescriptor * templateAAPipelineDesc = nil;\n+\n+static jboolean\n+setupAAShaderState(id<MTLRenderCommandEncoder> encoder,\n+                    MTLContext *mtlc,\n+                    MTLSDOps *dstOps)\n+{\n+    if (templateAAPipelineDesc == nil) {\n+\n+        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n+        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n+        vertDesc.attributes[VertexAttributePosition].offset = 0;\n+        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n+        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct AAVertex);\n+        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n+        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+\n+        templateAAPipelineDesc = [MTLRenderPipelineDescriptor new];\n+        templateAAPipelineDesc.sampleCount = 1;\n+        templateAAPipelineDesc.vertexDescriptor = vertDesc;\n+        templateAAPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+        templateAAPipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n+        templateAAPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+        templateAAPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n+        templateAAPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n+        templateAAPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+        templateAAPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+        templateAAPipelineDesc.colorAttachments[0].blendingEnabled = YES;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].format = MTLVertexFormatFloat2;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].offset = 4*sizeof(float);\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].bufferIndex = MeshVertexBuffer;\n+        templateAAPipelineDesc.label = @\"template_aa\";\n+    }\n+\n+    id<MTLRenderPipelineState> pipelineState =\n+                [mtlc.pipelineStateStorage\n+                    getPipelineState:templateAAPipelineDesc\n+                      vertexShaderId:@\"vert_col_aa\"\n+                    fragmentShaderId:@\"frag_col_aa\"\n+                       stencilNeeded:mtlc.clip.isShape\n+                   ];\n+\n+    [encoder setRenderPipelineState:pipelineState];\n+    return JNI_TRUE;\n+}\n+\n+#define ADJUST_PGRAM(V1, DV, V2) \\\n+    do { \\\n+        if ((DV) >= 0) { \\\n+            (V2) += (DV); \\\n+        } else { \\\n+            (V1) += (DV); \\\n+        } \\\n+    } while (0)\n+\n+\/\/ Invert the following transform:\n+\/\/ DeltaT(0, 0) == (0,       0)\n+\/\/ DeltaT(1, 0) == (DX1,     DY1)\n+\/\/ DeltaT(0, 1) == (DX2,     DY2)\n+\/\/ DeltaT(1, 1) == (DX1+DX2, DY1+DY2)\n+\/\/ TM00 = DX1,   TM01 = DX2,   (TM02 = X11)\n+\/\/ TM10 = DY1,   TM11 = DY2,   (TM12 = Y11)\n+\/\/ Determinant = TM00*TM11 - TM01*TM10\n+\/\/             =  DX1*DY2  -  DX2*DY1\n+\/\/ Inverse is:\n+\/\/ IM00 =  TM11\/det,   IM01 = -TM01\/det\n+\/\/ IM10 = -TM10\/det,   IM11 =  TM00\/det\n+\/\/ IM02 = (TM01 * TM12 - TM11 * TM02) \/ det,\n+\/\/ IM12 = (TM10 * TM02 - TM00 * TM12) \/ det,\n+\n+#define DECLARE_MATRIX(MAT) \\\n+    jfloat MAT ## 00, MAT ## 01, MAT ## 02, MAT ## 10, MAT ## 11, MAT ## 12\n+\n+#define GET_INVERTED_MATRIX(MAT, X11, Y11, DX1, DY1, DX2, DY2, RET_CODE) \\\n+    do { \\\n+        jfloat det = DX1*DY2 - DX2*DY1; \\\n+        if (det == 0) { \\\n+            RET_CODE; \\\n+        } \\\n+        MAT ## 00 = DY2\/det; \\\n+        MAT ## 01 = -DX2\/det; \\\n+        MAT ## 10 = -DY1\/det; \\\n+        MAT ## 11 = DX1\/det; \\\n+        MAT ## 02 = (DX2 * Y11 - DY2 * X11) \/ det; \\\n+        MAT ## 12 = (DY1 * X11 - DX1 * Y11) \/ det; \\\n+    } while (0)\n+\n+#define TRANSFORM(MAT, TX, TY, X, Y) \\\n+    do { \\\n+        TX = (X) * MAT ## 00 + (Y) * MAT ## 01 + MAT ## 02; \\\n+        TY = (X) * MAT ## 10 + (Y) * MAT ## 11 + MAT ## 12; \\\n+    } while (0)\n+\n+void\n+MTLRenderer_FillAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12)\n+{\n+    DECLARE_MATRIX(om);\n+    \/\/ parameters for parallelogram bounding box\n+    jfloat bx11, by11, bx22, by22;\n+    \/\/ parameters for uv texture coordinates of parallelogram corners\n+    jfloat ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;\n+\n+    J2dTraceLn6(J2D_TRACE_INFO,\n+                \"MTLRenderer_FillAAParallelogram \"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f)\",\n+                fx11, fy11,\n+                dx21, dy21,\n+                dx12, dy12);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    GET_INVERTED_MATRIX(om, fx11, fy11, dx21, dy21, dx12, dy12,\n+                        return);\n+\n+    bx11 = bx22 = fx11;\n+    by11 = by22 = fy11;\n+    ADJUST_PGRAM(bx11, dx21, bx22);\n+    ADJUST_PGRAM(by11, dy21, by22);\n+    ADJUST_PGRAM(bx11, dx12, bx22);\n+    ADJUST_PGRAM(by11, dy12, by22);\n+    bx11 = (jfloat) floor(bx11);\n+    by11 = (jfloat) floor(by11);\n+    bx22 = (jfloat) ceil(bx22);\n+    by22 = (jfloat) ceil(by22);\n+\n+    TRANSFORM(om, ou11, ov11, bx11, by11);\n+    TRANSFORM(om, ou21, ov21, bx22, by11);\n+    TRANSFORM(om, ou12, ov12, bx11, by22);\n+    TRANSFORM(om, ou22, ov22, bx22, by22);\n+\n+    id<MTLRenderCommandEncoder> encoder =\n+        [mtlc.encoderManager getRenderEncoder:dstOps];\n+    setupAAShaderState(encoder, mtlc, dstOps);\n+\n+    AA_ADD_TRIANGLES(ou11, ov11, 5.f, 5.f, ou21, ov21, 6.f, 5.f, ou22, ov22, 6.f, 6.f, ou12, ov12, 5.f, 5.f, bx11, by11, bx22, by22);\n+    [encoder setVertexBytes:aaVertices length:sizeof(aaVertices) atIndex:MeshVertexBuffer];\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+    vertexCacheIndex = 0;\n+}\n+\n+void\n+MTLRenderer_FillAAParallelogramInnerOuter(MTLContext *mtlc, MTLSDOps *dstOps,\n+                                          jfloat ox11, jfloat oy11,\n+                                          jfloat ox21, jfloat oy21,\n+                                          jfloat ox12, jfloat oy12,\n+                                          jfloat ix11, jfloat iy11,\n+                                          jfloat ix21, jfloat iy21,\n+                                          jfloat ix12, jfloat iy12)\n+{\n+    DECLARE_MATRIX(om);\n+    DECLARE_MATRIX(im);\n+    \/\/ parameters for parallelogram bounding box\n+    jfloat bx11, by11, bx22, by22;\n+    \/\/ parameters for uv texture coordinates of outer parallelogram corners\n+    jfloat ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;\n+    \/\/ parameters for uv texture coordinates of inner parallelogram corners\n+    jfloat iu11, iv11, iu12, iv12, iu21, iv21, iu22, iv22;\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    GET_INVERTED_MATRIX(im, ix11, iy11, ix21, iy21, ix12, iy12,\n+                        \/\/ inner parallelogram is degenerate\n+                        \/\/ therefore it encloses no area\n+                        \/\/ fill outer\n+                        MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n+                                                        ox11, oy11,\n+                                                        ox21, oy21,\n+                                                        ox12, oy12);\n+                        return);\n+    GET_INVERTED_MATRIX(om, ox11, oy11, ox21, oy21, ox12, oy12,\n+                        return);\n+\n+    bx11 = bx22 = ox11;\n+    by11 = by22 = oy11;\n+    ADJUST_PGRAM(bx11, ox21, bx22);\n+    ADJUST_PGRAM(by11, oy21, by22);\n+    ADJUST_PGRAM(bx11, ox12, bx22);\n+    ADJUST_PGRAM(by11, oy12, by22);\n+    bx11 = (jfloat) floor(bx11);\n+    by11 = (jfloat) floor(by11);\n+    bx22 = (jfloat) ceil(bx22);\n+    by22 = (jfloat) ceil(by22);\n+\n+    TRANSFORM(om, ou11, ov11, bx11, by11);\n+    TRANSFORM(om, ou21, ov21, bx22, by11);\n+    TRANSFORM(om, ou12, ov12, bx11, by22);\n+    TRANSFORM(om, ou22, ov22, bx22, by22);\n+\n+    TRANSFORM(im, iu11, iv11, bx11, by11);\n+    TRANSFORM(im, iu21, iv21, bx22, by11);\n+    TRANSFORM(im, iu12, iv12, bx11, by22);\n+    TRANSFORM(im, iu22, iv22, bx22, by22);\n+\n+    id<MTLRenderCommandEncoder> encoder =\n+        [mtlc.encoderManager getRenderEncoder:dstOps];\n+    setupAAShaderState(encoder, mtlc, dstOps);\n+\n+    AA_ADD_TRIANGLES(ou11, ov11, iu11, iv11, ou21, ov21, iu21, iv21, ou22, ov22, iu22, iv22, ou12, ov12, iu12, iv12, bx11, by11, bx22, by22);\n+    [encoder setVertexBytes:aaVertices length:sizeof(aaVertices) atIndex:MeshVertexBuffer];\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+    vertexCacheIndex = 0;\n+}\n+\n+void\n+MTLRenderer_DrawAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12,\n+                              jfloat lwr21, jfloat lwr12)\n+{\n+    \/\/ dx,dy for line width in the \"21\" and \"12\" directions.\n+    jfloat ldx21, ldy21, ldx12, ldy12;\n+    \/\/ parameters for \"outer\" parallelogram\n+    jfloat ofx11, ofy11, odx21, ody21, odx12, ody12;\n+    \/\/ parameters for \"inner\" parallelogram\n+    jfloat ifx11, ify11, idx21, idy21, idx12, idy12;\n+\n+    J2dTraceLn8(J2D_TRACE_INFO,\n+                \"MTLRenderer_DrawAAParallelogram \"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f lwr1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f lwr2=%6.2f)\",\n+                fx11, fy11,\n+                dx21, dy21, lwr21,\n+                dx12, dy12, lwr12);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    \/\/ calculate true dx,dy for line widths from the \"line width ratios\"\n+    ldx21 = dx21 * lwr21;\n+    ldy21 = dy21 * lwr21;\n+    ldx12 = dx12 * lwr12;\n+    ldy12 = dy12 * lwr12;\n+\n+    \/\/ calculate coordinates of the outer parallelogram\n+    ofx11 = fx11 - (ldx21 + ldx12) \/ 2.0f;\n+    ofy11 = fy11 - (ldy21 + ldy12) \/ 2.0f;\n+    odx21 = dx21 + ldx21;\n+    ody21 = dy21 + ldy21;\n+    odx12 = dx12 + ldx12;\n+    ody12 = dy12 + ldy12;\n+\n+    \/\/ Only process the inner parallelogram if the line width ratio\n+    \/\/ did not consume the entire interior of the parallelogram\n+    \/\/ (i.e. if the width ratio was less than 1.0)\n+    if (lwr21 < 1.0f && lwr12 < 1.0f) {\n+        \/\/ calculate coordinates of the inner parallelogram\n+        ifx11 = fx11 + (ldx21 + ldx12) \/ 2.0f;\n+        ify11 = fy11 + (ldy21 + ldy12) \/ 2.0f;\n+        idx21 = dx21 - ldx21;\n+        idy21 = dy21 - ldy21;\n+        idx12 = dx12 - ldx12;\n+        idy12 = dy12 - ldy12;\n+\n+        MTLRenderer_FillAAParallelogramInnerOuter(mtlc, dstOps,\n+                                                  ofx11, ofy11,\n+                                                  odx21, ody21,\n+                                                  odx12, ody12,\n+                                                  ifx11, ify11,\n+                                                  idx21, idy21,\n+                                                  idx12, idy12);\n+    } else {\n+        MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n+                                        ofx11, ofy11,\n+                                        odx21, ody21,\n+                                        odx12, ody12);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":1012,"deletions":0,"binary":false,"changes":1012,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLSurfaceData_h_Included\n+#define MTLSurfaceData_h_Included\n+\n+#import \"MTLSurfaceDataBase.h\"\n+#import \"MTLGraphicsConfig.h\"\n+#import \"AWTWindow.h\"\n+#import \"MTLLayer.h\"\n+\n+\/**\n+ * The MTLSDOps structure contains the MTL-specific information for a given\n+ * MTLSurfaceData.  It is referenced by the native MTLSDOps structure.\n+ *\/\n+typedef struct _MTLSDOps {\n+    AWTView               *peerData;\n+    MTLLayer              *layer;\n+    jint              argb[4]; \/\/ background clear color\n+    MTLGraphicsConfigInfo *configInfo;\n+} MTLSDOps;\n+\n+\/\/ debug-method\n+NSString * getSurfaceDescription(const BMTLSDOps * bmtlsdOps);\n+\n+#endif \/* MTLSurfaceData_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <stdlib.h>\n+\n+#import \"sun_java2d_metal_MTLSurfaceData.h\"\n+\n+#import \"jni_util.h\"\n+#import \"MTLRenderQueue.h\"\n+#import \"MTLGraphicsConfig.h\"\n+#import \"MTLSurfaceData.h\"\n+#import \"ThreadUtilities.h\"\n+#include \"jlong.h\"\n+\n+\/**\n+ * The following methods are implemented in the windowing system (i.e. GLX\n+ * and WGL) source files.\n+ *\/\n+extern jlong MTLSD_GetNativeConfigInfo(BMTLSDOps *bmtlsdo);\n+extern jboolean MTLSD_InitMTLWindow(JNIEnv *env, BMTLSDOps *bmtlsdo);\n+extern void MTLSD_DestroyMTLSurface(JNIEnv *env, BMTLSDOps *bmtlsdo);\n+\n+void MTLSD_SetNativeDimensions(JNIEnv *env, BMTLSDOps *bmtlsdo, jint w, jint h);\n+\n+static jboolean MTLSurfaceData_initTexture(BMTLSDOps *bmtlsdo, jboolean isOpaque, jboolean rtt, jint width, jint height) {\n+    @autoreleasepool {\n+        if (bmtlsdo == NULL) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSurfaceData_initTexture: ops are null\");\n+            return JNI_FALSE;\n+        }\n+        if (width <= 0 || height <= 0) {\n+            J2dRlsTraceLn2(J2D_TRACE_ERROR, \"MTLSurfaceData_initTexture: texture dimensions is incorrect, w=%d, h=%d\", width, height);\n+            return JNI_FALSE;\n+        }\n+\n+        MTLSDOps *mtlsdo = (MTLSDOps *)bmtlsdo->privOps;\n+\n+        if (mtlsdo == NULL) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSurfaceData_initTexture: MTLSDOps are null\");\n+            return JNI_FALSE;\n+        }\n+        if (mtlsdo->configInfo == NULL || mtlsdo->configInfo->context == NULL) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSurfaceData_initTexture: MTLSDOps wasn't initialized (context is null)\");\n+            return JNI_FALSE;\n+        }\n+\n+        MTLContext* ctx = mtlsdo->configInfo->context;\n+\n+        width = (width <= MaxTextureSize) ? width : 0;\n+        height = (height <= MaxTextureSize) ? height : 0;\n+\n+        J2dTraceLn3(J2D_TRACE_VERBOSE, \"  desired texture dimensions: w=%d h=%d max=%d\",\n+                width, height, MaxTextureSize);\n+\n+        \/\/ if either dimension is 0, we cannot allocate a texture with the\n+        \/\/ requested dimensions\n+        if ((width == 0 || height == 0)) {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSurfaceData_initTexture: texture dimensions too large\");\n+            return JNI_FALSE;\n+        }\n+\n+        MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat: MTLPixelFormatBGRA8Unorm width: width height: height mipmapped: NO];\n+        textureDescriptor.usage = MTLTextureUsageUnknown;\n+        textureDescriptor.storageMode = MTLStorageModePrivate;\n+        bmtlsdo->pTexture = [ctx.device newTextureWithDescriptor: textureDescriptor];\n+\n+        MTLTextureDescriptor *stencilDataDescriptor =\n+            [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatR8Uint width:width height:height mipmapped:NO];\n+        stencilDataDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;\n+        stencilDataDescriptor.storageMode = MTLStorageModePrivate;\n+        bmtlsdo->pStencilData = [ctx.device newTextureWithDescriptor:stencilDataDescriptor];\n+        bmtlsdo->pAAStencilData = [ctx.device newTextureWithDescriptor:textureDescriptor];\n+        bmtlsdo->pStencilDataBuf = [ctx.device newBufferWithLength:width*height options:MTLResourceStorageModePrivate];\n+        bmtlsdo->pAAStencilDataBuf = [ctx.device newBufferWithLength:width*height*4 options:MTLResourceStorageModePrivate];\n+\n+\n+        MTLTextureDescriptor *stencilTextureDescriptor =\n+            [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatStencil8 width:width height:height mipmapped:NO];\n+        stencilTextureDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead | MTLTextureUsageShaderWrite;\n+        stencilTextureDescriptor.storageMode = MTLStorageModePrivate;\n+        bmtlsdo->pStencilTexture = [ctx.device newTextureWithDescriptor:stencilTextureDescriptor];\n+\n+        bmtlsdo->isOpaque = isOpaque;\n+        bmtlsdo->xOffset = 0;\n+        bmtlsdo->yOffset = 0;\n+        bmtlsdo->width = width;\n+        bmtlsdo->height = height;\n+        bmtlsdo->textureWidth = width;\n+        bmtlsdo->textureHeight = height;\n+        bmtlsdo->drawableType = rtt ? MTLSD_RT_TEXTURE : MTLSD_TEXTURE;\n+\n+        J2dTraceLn6(J2D_TRACE_VERBOSE, \"MTLSurfaceData_initTexture: w=%d h=%d bp=%p [tex=%p] opaque=%d rtt=%d\", width, height, bmtlsdo, bmtlsdo->pTexture, isOpaque, rtt);\n+        return JNI_TRUE;\n+    }\n+}\n+\n+\/**\n+ * Initializes an MTL texture, using the given width and height as\n+ * a guide.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_sun_java2d_metal_MTLSurfaceData_initTexture(\n+    JNIEnv *env, jobject mtlsd,\n+    jlong pData, jboolean isOpaque,\n+    jint width, jint height\n+) {\n+    if (!MTLSurfaceData_initTexture((BMTLSDOps *)pData, isOpaque, JNI_FALSE, width, height))\n+        return JNI_FALSE;\n+    MTLSD_SetNativeDimensions(env, (BMTLSDOps *)pData, width, height);\n+    return JNI_TRUE;\n+}\n+\n+\/**\n+ * Initializes a framebuffer object, using the given width and height as\n+ * a guide.  See MTLSD_InitTextureObject() and MTLSD_initRTexture()\n+ * for more information.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_sun_java2d_metal_MTLSurfaceData_initRTexture\n+    (JNIEnv *env, jobject mtlsd,\n+     jlong pData, jboolean isOpaque,\n+     jint width, jint height)\n+{\n+    if (!MTLSurfaceData_initTexture((BMTLSDOps *)pData, isOpaque, JNI_TRUE, width, height))\n+        return JNI_FALSE;\n+    MTLSD_SetNativeDimensions(env, (BMTLSDOps *)pData, width, height);\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_java2d_metal_MTLSurfaceData_getMTLTexturePointer(JNIEnv *env, jobject mtlsd, jlong pData) {\n+    if (pData == 0)\n+        return 0;\n+    return ptr_to_jlong(((BMTLSDOps *)pData)->pTexture);\n+}\n+\n+\/**\n+ * Initializes nativeWidth\/Height fields of the surfaceData object with\n+ * passed arguments.\n+ *\/\n+void\n+MTLSD_SetNativeDimensions(JNIEnv *env, BMTLSDOps *mtlsdo,\n+                          jint width, jint height)\n+{\n+    jobject sdObject;\n+\n+    sdObject = (*env)->NewLocalRef(env, mtlsdo->sdOps.sdObject);\n+    if (sdObject == NULL) {\n+        return;\n+    }\n+\n+    JNU_SetFieldByName(env, NULL, sdObject, \"nativeWidth\", \"I\", width);\n+    if (!((*env)->ExceptionOccurred(env))) {\n+        JNU_SetFieldByName(env, NULL, sdObject, \"nativeHeight\", \"I\", height);\n+    }\n+\n+    (*env)->DeleteLocalRef(env, sdObject);\n+}\n+\n+\/**\n+ * Deletes native Metal resources associated with this surface.\n+ *\/\n+void\n+MTLSD_Delete(JNIEnv *env, BMTLSDOps *bmtlsdo)\n+{\n+    J2dTraceLn3(J2D_TRACE_VERBOSE, \"MTLSD_Delete: type=%d %p [tex=%p]\", bmtlsdo->drawableType, bmtlsdo, bmtlsdo->pTexture);\n+    if (bmtlsdo->drawableType == MTLSD_WINDOW) {\n+        MTLSD_DestroyMTLSurface(env, bmtlsdo);\n+    } else if (\n+            bmtlsdo->drawableType == MTLSD_RT_TEXTURE\n+            || bmtlsdo->drawableType == MTLSD_TEXTURE\n+            || bmtlsdo->drawableType == MTLSD_FLIP_BACKBUFFER\n+    ) {\n+        [(NSObject *)bmtlsdo->pTexture release];\n+        [(NSObject *)bmtlsdo->pStencilTexture release];\n+        [(NSObject *)bmtlsdo->pStencilData release];\n+        [(NSObject *)bmtlsdo->pStencilDataBuf release];\n+        [(NSObject *)bmtlsdo->pAAStencilData release];\n+        [(NSObject *)bmtlsdo->pAAStencilDataBuf release];\n+        bmtlsdo->pTexture = NULL;\n+        bmtlsdo->drawableType = MTLSD_UNDEFINED;\n+    }\n+}\n+\n+\/**\n+ * This is the implementation of the general DisposeFunc defined in\n+ * SurfaceData.h and used by the Disposer mechanism.  It first flushes all\n+ * native Metal resources and then frees any memory allocated within the\n+ * native MTLSDOps structure.\n+ *\/\n+void\n+MTLSD_Dispose(JNIEnv *env, SurfaceDataOps *ops)\n+{\n+    BMTLSDOps *bmtlsdo = (BMTLSDOps *)ops;\n+    jobject graphicsConfig = bmtlsdo->graphicsConfig;\n+\n+    JNU_CallStaticMethodByName(env, NULL, \"sun\/java2d\/metal\/MTLSurfaceData\",\n+                               \"dispose\",\n+                               \"(JLsun\/java2d\/metal\/MTLGraphicsConfig;)V\",\n+                               ptr_to_jlong(ops), graphicsConfig);\n+    (*env)->DeleteGlobalRef(env, graphicsConfig);\n+    bmtlsdo->graphicsConfig = NULL;\n+}\n+\n+\/**\n+ * This is the implementation of the general surface LockFunc defined in\n+ * SurfaceData.h.\n+ *\/\n+jint\n+MTLSD_Lock(JNIEnv *env,\n+           SurfaceDataOps *ops,\n+           SurfaceDataRasInfo *pRasInfo,\n+           jint lockflags)\n+{\n+    JNU_ThrowInternalError(env, \"MTLSD_Lock not implemented!\");\n+    return SD_FAILURE;\n+}\n+\n+\/**\n+ * This is the implementation of the general GetRasInfoFunc defined in\n+ * SurfaceData.h.\n+ *\/\n+void\n+MTLSD_GetRasInfo(JNIEnv *env,\n+                 SurfaceDataOps *ops,\n+                 SurfaceDataRasInfo *pRasInfo)\n+{\n+    JNU_ThrowInternalError(env, \"MTLSD_GetRasInfo not implemented!\");\n+}\n+\n+\/**\n+ * This is the implementation of the general surface UnlockFunc defined in\n+ * SurfaceData.h.\n+ *\/\n+void\n+MTLSD_Unlock(JNIEnv *env,\n+             SurfaceDataOps *ops,\n+             SurfaceDataRasInfo *pRasInfo)\n+{\n+    JNU_ThrowInternalError(env, \"MTLSD_Unlock not implemented!\");\n+}\n+\n+\/**\n+ * This function disposes of any native windowing system resources associated\n+ * with this surface.\n+ *\/\n+void\n+MTLSD_DestroyMTLSurface(JNIEnv *env, BMTLSDOps * bmtlsdo)\n+{\n+    J2dTraceLn(J2D_TRACE_ERROR, \"MTLSD_DestroyMTLSurface not implemented!\");\n+    JNI_COCOA_ENTER(env);\n+    bmtlsdo->drawableType = MTLSD_UNDEFINED;\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+\/**\n+ * This function initializes a native window surface and caches the window\n+ * bounds in the given BMTLSDOps.  Returns JNI_TRUE if the operation was\n+ * successful; JNI_FALSE otherwise.\n+ *\/\n+jboolean\n+MTLSD_InitMTLWindow(JNIEnv *env, BMTLSDOps *bmtlsdo)\n+{\n+    if (bmtlsdo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSD_InitMTLWindow: ops are null\");\n+        return JNI_FALSE;\n+    }\n+\n+    MTLSDOps *mtlsdo = (MTLSDOps *)bmtlsdo->privOps;\n+    if (mtlsdo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSD_InitMTLWindow: priv ops are null\");\n+        return JNI_FALSE;\n+    }\n+\n+    AWTView *v = mtlsdo->peerData;\n+    if (v == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLSD_InitMTLWindow: view is invalid\");\n+        return JNI_FALSE;\n+    }\n+\n+    JNI_COCOA_ENTER(env);\n+            NSRect surfaceBounds = [v bounds];\n+            bmtlsdo->drawableType = MTLSD_WINDOW;\n+            bmtlsdo->isOpaque = JNI_TRUE;\n+            bmtlsdo->width = surfaceBounds.size.width;\n+            bmtlsdo->height = surfaceBounds.size.height;\n+    JNI_COCOA_EXIT(env);\n+\n+    J2dTraceLn2(J2D_TRACE_VERBOSE, \"  created window: w=%d h=%d\", bmtlsdo->width, bmtlsdo->height);\n+    return JNI_TRUE;\n+}\n+\n+void\n+MTLSD_SwapBuffers(JNIEnv *env, jlong pPeerData)\n+{\n+    J2dTraceLn(J2D_TRACE_ERROR, \"MTLSD_SwapBuffers -- :TODO\");\n+}\n+\n+#pragma mark -\n+#pragma mark \"--- MTLSurfaceData methods ---\"\n+\n+extern LockFunc        MTLSD_Lock;\n+extern GetRasInfoFunc  MTLSD_GetRasInfo;\n+extern UnlockFunc      MTLSD_Unlock;\n+\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLSurfaceData_initOps\n+    (JNIEnv *env, jobject mtlsd, jobject gc,\n+     jlong pConfigInfo, jlong pPeerData, jlong layerPtr,\n+     jint xoff, jint yoff, jboolean isOpaque)\n+{\n+    BMTLSDOps *bmtlsdo = (BMTLSDOps *)SurfaceData_InitOps(env, mtlsd, sizeof(BMTLSDOps));\n+    MTLSDOps *mtlsdo = (MTLSDOps *)malloc(sizeof(MTLSDOps));\n+\n+    J2dTraceLn1(J2D_TRACE_INFO, \"MTLSurfaceData_initOps p=%p\", bmtlsdo);\n+    J2dTraceLn1(J2D_TRACE_INFO, \"  pPeerData=%p\", jlong_to_ptr(pPeerData));\n+    J2dTraceLn1(J2D_TRACE_INFO, \"  layerPtr=%p\", jlong_to_ptr(layerPtr));\n+    J2dTraceLn2(J2D_TRACE_INFO, \"  xoff=%d, yoff=%d\", (int)xoff, (int)yoff);\n+\n+    gc = (*env)->NewGlobalRef(env, gc);\n+    if (gc == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n+        return;\n+    }\n+\n+    if (mtlsdo == NULL) {\n+        (*env)->DeleteGlobalRef(env, gc);\n+        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n+        return;\n+    }\n+\n+    \/\/ later the graphicsConfig will be used for deallocation of mtlsdo\n+    bmtlsdo->privOps = mtlsdo;\n+    bmtlsdo->graphicsConfig = gc;\n+\n+    bmtlsdo->sdOps.Lock               = MTLSD_Lock;\n+    bmtlsdo->sdOps.GetRasInfo         = MTLSD_GetRasInfo;\n+    bmtlsdo->sdOps.Unlock             = MTLSD_Unlock;\n+    bmtlsdo->sdOps.Dispose            = MTLSD_Dispose;\n+\n+    bmtlsdo->drawableType = MTLSD_UNDEFINED;\n+    bmtlsdo->xOffset = xoff;\n+    bmtlsdo->yOffset = yoff;\n+    bmtlsdo->isOpaque = isOpaque;\n+\n+    mtlsdo->peerData = (AWTView *)jlong_to_ptr(pPeerData);\n+    mtlsdo->layer = (MTLLayer *)jlong_to_ptr(layerPtr);\n+    mtlsdo->configInfo = (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);\n+\n+    if (mtlsdo->configInfo == NULL) {\n+        free(mtlsdo);\n+        JNU_ThrowNullPointerException(env, \"Config info is null in initOps\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLSurfaceData_clearWindow\n+(JNIEnv *env, jobject cglsd)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLSurfaceData_clearWindow\");\n+\n+    BMTLSDOps *bmtlsdo = (MTLSDOps*) SurfaceData_GetOps(env, cglsd);\n+    MTLSDOps *mtlsdo = (MTLSDOps*) bmtlsdo->privOps;\n+\n+    mtlsdo->peerData = NULL;\n+    mtlsdo->layer = NULL;\n+}\n+\n+NSString * getSurfaceDescription(const BMTLSDOps * bmtlsdOps) {\n+    if (bmtlsdOps == NULL)\n+        return @\"NULL\";\n+    return [NSString stringWithFormat:@\"%p [tex=%p, %dx%d, O=%d]\", bmtlsdOps, bmtlsdOps->pTexture, bmtlsdOps->width, bmtlsdOps->height, bmtlsdOps->isOpaque];\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLSurfaceDataBase_h_Included\n+#define MTLSurfaceDataBase_h_Included\n+\n+#include \"java_awt_image_AffineTransformOp.h\"\n+#include \"sun_java2d_metal_MTLSurfaceData.h\"\n+#include \"sun_java2d_pipe_hw_AccelSurface.h\"\n+\n+#include \"SurfaceData.h\"\n+#include \"Trace.h\"\n+\n+\/**\n+ * The MTLSDOps structure describes a native Metal surface and contains all\n+ * information pertaining to the native surface.  Some information about\n+ * the more important\/different fields:\n+ *\n+ *     void *privOps;\n+ * Pointer to native-specific (Metal) SurfaceData info, such as the\n+ * native Drawable handle and GraphicsConfig data.\n+ *\n+ *     jint drawableType;\n+ * The surface type; can be any one of the surface type constants defined\n+ * below (MTLSD_WINDOW, MTLSD_TEXTURE, etc).\n+ *\n+ *     jboolean isOpaque;\n+ * If true, the surface should be treated as being fully opaque.  If\n+ * the underlying surface (e.g. pbuffer) has an alpha channel and isOpaque\n+ * is true, then we should take appropriate action (i.e. call glColorMask()\n+ * to disable writes into the alpha channel) to ensure that the surface\n+ * remains fully opaque.\n+ *\n+ *     jint x\/yOffset\n+ * The offset in pixels of the Metal viewport origin from the lower-left\n+ * corner of the heavyweight drawable.  For example, a top-level frame on\n+ * Windows XP has lower-left insets of (4,4).  The Metal viewport origin\n+ * would typically begin at the lower-left corner of the client region (inside\n+ * the frame decorations), but AWT\/Swing will take the insets into account\n+ * when rendering into that window.  So in order to account for this, we\n+ * need to adjust the Metal viewport origin by an x\/yOffset of (-4,-4).  On\n+ * X11, top-level frames typically don't have this insets issue, so their\n+ * x\/yOffset would be (0,0) (the same applies to pbuffers).\n+ *\n+ *     jint width\/height;\n+ * The cached surface bounds.  For offscreen surface types (MTLSD_FBOBJECT,\n+ * MTLSD_TEXTURE, etc.) these values must remain constant.  Onscreen window\n+ * surfaces (MTLSD_WINDOW, MTLSD_FLIP_BACKBUFFER, etc.) may have their\n+ * bounds changed in response to a programmatic or user-initiated event, so\n+ * these values represent the last known dimensions.  To determine the true\n+ * current bounds of this surface, query the native Drawable through the\n+ * privOps field.\n+ *\n+ *     void* pTexture;\n+ * The texture object handle, as generated by MTLTextureDescriptor(). If this\n+ * value is null, the texture has not yet been initialized.\n+ *\n+ *     jint textureWidth\/Height;\n+ * The actual bounds of the texture object for this surface.\n+ * The texture image that we care about has dimensions specified by the width\n+ * and height fields in this MTLSDOps structure.\n+ *\/\n+typedef struct {\n+    SurfaceDataOps               sdOps;\n+    void                         *privOps;\n+    jobject                      graphicsConfig;\n+    jint                         drawableType;\n+    jboolean                     isOpaque;\n+    jint                         xOffset;\n+    jint                         yOffset;\n+    jint                         width;\n+    jint                         height;\n+    void*                        pTexture;\n+    void*                        pStencilData;      \/\/ stencil data to be rendered to this buffer\n+    void*                        pStencilDataBuf;   \/\/ MTLBuffer with stencil data\n+    void*                        pStencilTexture;   \/\/ stencil texture byte buffer stencil mask used in main rendering\n+    void*                        pAAStencilData;    \/\/ stencil data for AA rendering\n+    void*                        pAAStencilDataBuf; \/\/ MTLBuffer with AA stencil data\n+    jint                         textureWidth;\n+    jint                         textureHeight;\n+} BMTLSDOps;\n+\n+#define MTLSD_UNDEFINED       sun_java2d_pipe_hw_AccelSurface_UNDEFINED\n+#define MTLSD_WINDOW          sun_java2d_pipe_hw_AccelSurface_WINDOW\n+#define MTLSD_TEXTURE         sun_java2d_pipe_hw_AccelSurface_TEXTURE\n+#define MTLSD_FLIP_BACKBUFFER sun_java2d_pipe_hw_AccelSurface_FLIP_BACKBUFFER\n+#define MTLSD_RT_TEXTURE        sun_java2d_pipe_hw_AccelSurface_RT_TEXTURE\n+\n+\/**\n+ * These are shorthand names for the filtering method constants used by\n+ * image transform methods.\n+ *\/\n+#define MTLSD_XFORM_DEFAULT 0\n+#define MTLSD_XFORM_NEAREST_NEIGHBOR \\\n+    java_awt_image_AffineTransformOp_TYPE_NEAREST_NEIGHBOR\n+#define MTLSD_XFORM_BILINEAR \\\n+    java_awt_image_AffineTransformOp_TYPE_BILINEAR\n+\n+\/**\n+ * The SurfaceRasterFlags structure contains information about raster (of some MTLTexture):\n+ *\n+ *     jboolean isOpaque;\n+ * If true, indicates that this pixel format hasn't alpha component (and values of this component can contain garbage).\n+ *\n+ *     jboolean isPremultiplied;\n+ * If true, indicates that this pixel format contains color components that have been pre-multiplied by their\n+ * corresponding alpha component.\n+*\/\n+typedef struct {\n+    jboolean isOpaque;\n+    jboolean isPremultiplied;\n+} SurfaceRasterFlags;\n+\n+\/**\n+ * Exported methods.\n+ *\/\n+jint MTLSD_Lock(JNIEnv *env,\n+                SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo,\n+                jint lockflags);\n+void MTLSD_GetRasInfo(JNIEnv *env,\n+                      SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo);\n+void MTLSD_Unlock(JNIEnv *env,\n+                  SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo);\n+void MTLSD_Dispose(JNIEnv *env, SurfaceDataOps *ops);\n+void MTLSD_Delete(JNIEnv *env, BMTLSDOps *mtlsdo);\n+jint MTLSD_NextPowerOfTwo(jint val, jint max);\n+\n+#endif \/* MTLSurfaceDataBase_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceDataBase.h","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLTextRenderer_h_Included\n+#define MTLTextRenderer_h_Included\n+\n+#include <jni.h>\n+#include <jlong.h>\n+#include \"sun_java2d_pipe_BufferedTextPipe.h\"\n+#include \"MTLContext.h\"\n+#include \"MTLSurfaceData.h\"\n+\n+#define BYTES_PER_GLYPH_IMAGE \\\n+    sun_java2d_pipe_BufferedTextPipe_BYTES_PER_GLYPH_IMAGE\n+#define BYTES_PER_GLYPH_POSITION \\\n+    sun_java2d_pipe_BufferedTextPipe_BYTES_PER_GLYPH_POSITION\n+#define BYTES_PER_POSITIONED_GLYPH \\\n+    (BYTES_PER_GLYPH_IMAGE + BYTES_PER_GLYPH_POSITION)\n+\n+#define OFFSET_CONTRAST  sun_java2d_pipe_BufferedTextPipe_OFFSET_CONTRAST\n+#define OFFSET_RGBORDER  sun_java2d_pipe_BufferedTextPipe_OFFSET_RGBORDER\n+#define OFFSET_SUBPIXPOS sun_java2d_pipe_BufferedTextPipe_OFFSET_SUBPIXPOS\n+#define OFFSET_POSITIONS sun_java2d_pipe_BufferedTextPipe_OFFSET_POSITIONS\n+\n+void MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps);\n+void MTLTR_DisableGlyphVertexCache(MTLContext *mtlc);\n+id<MTLTexture> MTLTR_GetGlyphCacheTexture();\n+void MTLTR_FreeGlyphCaches();\n+\n+void MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,\n+                         jint totalGlyphs, jboolean usePositions,\n+                         jboolean subPixPos, jboolean rgbOrder,\n+                         jint lcdContrast,\n+                         jfloat glyphListOrigX, jfloat glyphListOrigY,\n+                         unsigned char *images, unsigned char *positions);\n+\n+#endif \/* MTLTextRenderer_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,777 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <limits.h>\n+#include <math.h>\n+#include <jlong.h>\n+\n+#include \"sun_java2d_metal_MTLTextRenderer.h\"\n+\n+#include \"SurfaceData.h\"\n+#include \"MTLContext.h\"\n+#include \"MTLRenderQueue.h\"\n+#include \"MTLTextRenderer.h\"\n+#include \"MTLVertexCache.h\"\n+#include \"MTLGlyphCache.h\"\n+#include \"MTLBlitLoops.h\"\n+\n+\/**\n+ * The following constants define the inner and outer bounds of the\n+ * accelerated glyph cache.\n+ *\/\n+#define MTLTR_CACHE_WIDTH       512\n+#define MTLTR_CACHE_HEIGHT      512\n+#define MTLTR_CACHE_CELL_WIDTH  32\n+#define MTLTR_CACHE_CELL_HEIGHT 32\n+\n+\/**\n+ * The current \"glyph mode\" state.  This variable is used to track the\n+ * codepath used to render a particular glyph.  This variable is reset to\n+ * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().\n+ * As each glyph is rendered, the glyphMode variable is updated to reflect\n+ * the current mode, so if the current mode is the same as the mode used\n+ * to render the previous glyph, we can avoid doing costly setup operations\n+ * each time.\n+ *\/\n+typedef enum {\n+    MODE_NOT_INITED,\n+    MODE_USE_CACHE_GRAY,\n+    MODE_USE_CACHE_LCD,\n+    MODE_NO_CACHE_GRAY,\n+    MODE_NO_CACHE_LCD,\n+    MODE_NO_CACHE_COLOR\n+} GlyphMode;\n+static GlyphMode glyphMode = MODE_NOT_INITED;\n+\n+\/**\n+ * There are two separate glyph caches: for AA and for LCD.\n+ * Once one of them is initialized as either GRAY or LCD, it\n+ * stays in that mode for the duration of the application.  It should\n+ * be safe to use this one glyph cache for all screens in a multimon\n+ * environment, since the glyph cache texture is shared between all contexts,\n+ * and (in theory) Metal drivers should be smart enough to manage that\n+ * texture across all screens.\n+ *\/\n+\n+static MTLGlyphCacheInfo *glyphCacheLCD = NULL;\n+static MTLGlyphCacheInfo *glyphCacheAA = NULL;\n+\n+\/**\n+ * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder\n+ * value has changed since the last time, it indicates that we need to\n+ * invalidate the cache, which may already store glyph images in the reverse\n+ * order.  Note that in most real world applications this value will not\n+ * change over the course of the application, but tests like Font2DTest\n+ * allow for changing the ordering at runtime, so we need to handle that case.\n+ *\/\n+static jboolean lastRGBOrder = JNI_TRUE;\n+\n+\/**\n+ * This constant defines the size of the tile to use in the\n+ * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we\n+ * restrict this value to a particular size.\n+ *\/\n+#define MTLTR_NOCACHE_TILE_SIZE 32\n+\n+static struct TxtVertex txtVertices[6];\n+static jint vertexCacheIndex = 0;\n+static id<MTLRenderCommandEncoder> lcdCacheEncoder = nil;\n+\n+#define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \\\n+    do { \\\n+        struct TxtVertex *v = &txtVertices[vertexCacheIndex++]; \\\n+        v->txtpos[0] = TX; \\\n+        v->txtpos[1] = TY; \\\n+        v->position[0]= DX; \\\n+        v->position[1] = DY; \\\n+    } while (0)\n+\n+#define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \\\n+    do { \\\n+        LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \\\n+        LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \\\n+        LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \\\n+        LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \\\n+        LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \\\n+        LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \\\n+    } while (0)\n+\n+\/**\n+ * Initializes the one glyph cache (texture and data structure).\n+ * If lcdCache is JNI_TRUE, the texture will contain RGB data,\n+ * otherwise we will simply store the grayscale\/monochrome glyph images\n+ * as intensity values.\n+ *\/\n+static jboolean\n+MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_InitGlyphCache\");\n+    \/\/ TODO : Need to verify RGB order in case of LCD\n+    MTLPixelFormat pixelFormat =\n+        lcdCache ? MTLPixelFormatBGRA8Unorm : MTLPixelFormatA8Unorm;\n+\n+    MTLGlyphCacheInfo *gcinfo;\n+    \/\/ init glyph cache data structure\n+    gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,\n+                                MTLTR_CACHE_HEIGHT,\n+                                MTLTR_CACHE_CELL_WIDTH,\n+                                MTLTR_CACHE_CELL_HEIGHT,\n+                                MTLVertexCache_FlushGlyphVertexCache);\n+\n+    if (gcinfo == NULL) {\n+        J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                      \"MTLTR_InitGlyphCache: could not init MTL glyph cache\");\n+        return JNI_FALSE;\n+    }\n+\n+    MTLTextureDescriptor *textureDescriptor =\n+        [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat\n+                                                            width:MTLTR_CACHE_WIDTH\n+                                                            height:MTLTR_CACHE_HEIGHT\n+                                                            mipmapped:NO];\n+\n+    gcinfo->texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];\n+\n+    if (lcdCache) {\n+        glyphCacheLCD = gcinfo;\n+    } else {\n+        glyphCacheAA = gcinfo;\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+id<MTLTexture>\n+MTLTR_GetGlyphCacheTexture()\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_GetGlyphCacheTexture\");\n+    if (glyphCacheAA != NULL) {\n+        return glyphCacheAA->texture;\n+    }\n+    return NULL;\n+}\n+\n+\/**\n+ * Adds the given glyph to the glyph cache (texture and data structure)\n+ * associated with the given MTLContext.\n+ *\/\n+static void\n+MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,\n+                      jboolean lcdCache)\n+{\n+    MTLCacheCellInfo *ccinfo;\n+    MTLGlyphCacheInfo *gcinfo;\n+    jint w = glyph->width;\n+    jint h = glyph->height;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_AddToGlyphCache\");\n+    if (!lcdCache) {\n+        gcinfo = glyphCacheAA;\n+    } else {\n+        gcinfo = glyphCacheLCD;\n+    }\n+\n+    if ((gcinfo == NULL) || (glyph->image == NULL)) {\n+        return;\n+    }\n+\n+    bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);\n+    if (isCacheFull) {\n+        MTLGlyphCache_Free(gcinfo);\n+        if (!lcdCache) {\n+            MTLTR_InitGlyphCache(mtlc, JNI_FALSE);\n+            gcinfo = glyphCacheAA;\n+        } else {\n+            MTLTR_InitGlyphCache(mtlc, JNI_TRUE);\n+            gcinfo = glyphCacheLCD;\n+        }\n+    }\n+    MTLGlyphCache_AddGlyph(gcinfo, glyph);\n+    ccinfo = (MTLCacheCellInfo *) glyph->cellInfo;\n+\n+    if (ccinfo != NULL) {\n+        \/\/ store glyph image in texture cell\n+        MTLRegion region = {\n+                {ccinfo->x,  ccinfo->y,   0},\n+                {w, h, 1}\n+        };\n+        if (!lcdCache) {\n+            NSUInteger bytesPerRow = 1 * w;\n+            [gcinfo->texture replaceRegion:region\n+                             mipmapLevel:0\n+                             withBytes:glyph->image\n+                             bytesPerRow:bytesPerRow];\n+        } else {\n+            unsigned int imageBytes = w * h * 4;\n+            unsigned char imageData[imageBytes];\n+            memset(&imageData, 0, sizeof(imageData));\n+\n+            for (int i = 0; i < h; i++) {\n+                for (int j = 0; j < w; j++) {\n+                    imageData[(i * w * 4) + j * 4] = glyph->image[(i * w * 3) + j * 3];\n+                    imageData[(i * w * 4) + j * 4 + 1] = glyph->image[(i * w * 3) + j * 3 + 1];\n+                    imageData[(i * w * 4) + j * 4 + 2] = glyph->image[(i * w * 3) + j * 3 + 2];\n+                    imageData[(i * w * 4) + j * 4 + 3] = 0xFF;\n+                }\n+            }\n+\n+            NSUInteger bytesPerRow = 4 * w;\n+            [gcinfo->texture replaceRegion:region\n+                             mipmapLevel:0\n+                             withBytes:imageData\n+                             bytesPerRow:bytesPerRow];\n+        }\n+    }\n+}\n+\n+static jboolean\n+MTLTR_SetLCDContrast(MTLContext *mtlc,\n+                     jint contrast,\n+                     id<MTLRenderCommandEncoder> encoder)\n+{\n+    if (![mtlc.paint isKindOfClass:[MTLColorPaint class]]) {\n+        return JNI_FALSE;\n+    }\n+    MTLColorPaint* cPaint = (MTLColorPaint *) mtlc.paint;\n+    \/\/ update the current color settings\n+    double gamma = ((double)contrast) \/ 100.0;\n+    double invgamma = 1.0\/gamma;\n+    jfloat radj, gadj, badj;\n+    jfloat clr[4];\n+    jint col = cPaint.color;\n+\n+    J2dTraceLn2(J2D_TRACE_INFO, \"primary color %x, contrast %d\", col, contrast);\n+    J2dTraceLn2(J2D_TRACE_INFO, \"gamma %f, invgamma %f\", gamma, invgamma);\n+\n+    clr[0] = ((col >> 16) & 0xFF)\/255.0f;\n+    clr[1] = ((col >> 8) & 0xFF)\/255.0f;\n+    clr[2] = ((col) & 0xFF)\/255.0f;\n+\n+    \/\/ gamma adjust the primary color\n+    radj = (float)pow(clr[0], gamma);\n+    gadj = (float)pow(clr[1], gamma);\n+    badj = (float)pow(clr[2], gamma);\n+\n+    struct LCDFrameUniforms uf = {\n+            {radj, gadj, badj},\n+            {gamma, gamma, gamma},\n+            {invgamma, invgamma, invgamma}};\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+    return JNI_TRUE;\n+}\n+\n+void\n+MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)\n+{\n+J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_EnableGlyphVertexCache\");\n+\n+    if (!MTLVertexCache_InitVertexCache()) {\n+        return;\n+    }\n+\n+    if (glyphCacheAA == NULL) {\n+        if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {\n+            return;\n+        }\n+    }\n+    MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);\n+}\n+\n+void\n+MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DisableGlyphVertexCache\");\n+    MTLVertexCache_FlushGlyphVertexCache();\n+    MTLVertexCache_FreeVertexCache();\n+}\n+\n+void MTLTR_FreeGlyphCaches() {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_FreeGlyphCaches : freeing glyph caches.\");\n+\n+    if (glyphCacheAA != NULL) {\n+        [glyphCacheAA->texture release];\n+        MTLGlyphCache_Free(glyphCacheAA);\n+        glyphCacheAA = NULL;\n+    }\n+\n+    if (glyphCacheLCD != NULL) {\n+        [glyphCacheLCD->texture release];\n+        MTLGlyphCache_Free(glyphCacheLCD);\n+        glyphCacheLCD = NULL;\n+    }\n+}\n+\n+static jboolean\n+MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,\n+                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)\n+{\n+    MTLCacheCellInfo *cell;\n+    jfloat x1, y1, x2, y2;\n+\n+    if (glyphMode != MODE_USE_CACHE_GRAY) {\n+        if (glyphMode == MODE_NO_CACHE_GRAY) {\n+            MTLVertexCache_DisableMaskCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_LCD) {\n+            [mtlc.encoderManager endEncoder];\n+            lcdCacheEncoder = nil;\n+        }\n+        MTLTR_EnableGlyphVertexCache(mtlc, dstOps);\n+        glyphMode = MODE_USE_CACHE_GRAY;\n+    }\n+\n+    if (ginfo->cellInfo == NULL) {\n+        \/\/ attempt to add glyph to accelerated glyph cache\n+        MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_FALSE);\n+\n+        if (ginfo->cellInfo == NULL) {\n+            \/\/ we'll just no-op in the rare case that the cell is NULL\n+            return JNI_TRUE;\n+        }\n+    }\n+\n+    cell = (MTLCacheCellInfo *) (ginfo->cellInfo);\n+    cell->timesRendered++;\n+\n+    x1 = (jfloat)x;\n+    y1 = (jfloat)y;\n+    x2 = x1 + ginfo->width;\n+    y2 = y1 + ginfo->height;\n+\n+    MTLVertexCache_AddGlyphQuad(mtlc,\n+                                cell->tx1, cell->ty1,\n+                                cell->tx2, cell->ty2,\n+                                x1, y1, x2, y2);\n+\n+    return JNI_TRUE;\n+}\n+\n+static jboolean\n+MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,\n+                           GlyphInfo *ginfo, jint x, jint y,\n+                           jboolean rgbOrder, jint contrast)\n+{\n+    CacheCellInfo *cell;\n+    jfloat tx1, ty1, tx2, ty2;\n+    jint w = ginfo->width;\n+    jint h = ginfo->height;\n+\n+    if (glyphMode != MODE_USE_CACHE_LCD) {\n+        if (glyphMode == MODE_NO_CACHE_GRAY) {\n+            MTLVertexCache_DisableMaskCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_GRAY) {\n+            MTLTR_DisableGlyphVertexCache(mtlc);\n+        }\n+\n+        if (glyphCacheLCD == NULL) {\n+            if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {\n+                return JNI_FALSE;\n+            }\n+        }\n+        if (lcdCacheEncoder == nil) {\n+            lcdCacheEncoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n+        }\n+        if (rgbOrder != lastRGBOrder) {\n+            \/\/ need to invalidate the cache in this case; see comments\n+            \/\/ for lastRGBOrder above\n+            MTLGlyphCache_Invalidate(glyphCacheLCD);\n+            lastRGBOrder = rgbOrder;\n+        }\n+\n+        glyphMode = MODE_USE_CACHE_LCD;\n+    }\n+\n+    if (ginfo->cellInfo == NULL) {\n+        \/\/ attempt to add glyph to accelerated glyph cache\n+        \/\/ TODO : Handle RGB order\n+        MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_TRUE);\n+\n+        if (ginfo->cellInfo == NULL) {\n+            \/\/ we'll just no-op in the rare case that the cell is NULL\n+            return JNI_TRUE;\n+        }\n+    }\n+    cell = (CacheCellInfo *) (ginfo->cellInfo);\n+    cell->timesRendered++;\n+\n+    MTLTR_SetLCDContrast(mtlc, contrast, lcdCacheEncoder);\n+    tx1 = cell->tx1;\n+    ty1 = cell->ty1;\n+    tx2 = cell->tx2;\n+    ty2 = cell->ty2;\n+\n+    J2dTraceLn4(J2D_TRACE_INFO, \"tx1 %f, ty1 %f, tx2 %f, ty2 %f\", tx1, ty1, tx2, ty2);\n+    J2dTraceLn2(J2D_TRACE_INFO, \"textureWidth %d textureHeight %d\", dstOps->textureWidth, dstOps->textureHeight);\n+\n+    LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);\n+\n+    [lcdCacheEncoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];\n+    [lcdCacheEncoder setFragmentTexture:glyphCacheLCD->texture atIndex:0];\n+    [lcdCacheEncoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+\n+    [lcdCacheEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+\n+    vertexCacheIndex = 0;\n+\n+    return JNI_TRUE;\n+}\n+\n+static jboolean\n+MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,\n+                                GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)\n+{\n+    jint tw, th;\n+    jint sx, sy, sw, sh;\n+    jint x0;\n+    jint w = ginfo->width;\n+    jint h = ginfo->height;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGrayscaleGlyphNoCache\");\n+    if (glyphMode != MODE_NO_CACHE_GRAY) {\n+        if (glyphMode == MODE_USE_CACHE_GRAY) {\n+            MTLTR_DisableGlyphVertexCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_LCD) {\n+            [mtlc.encoderManager endEncoder];\n+            lcdCacheEncoder = nil;\n+        }\n+        MTLVertexCache_EnableMaskCache(mtlc, dstOps);\n+        glyphMode = MODE_NO_CACHE_GRAY;\n+    }\n+\n+    x0 = x;\n+    tw = MTLVC_MASK_CACHE_TILE_WIDTH;\n+    th = MTLVC_MASK_CACHE_TILE_HEIGHT;\n+\n+    for (sy = 0; sy < h; sy += th, y += th) {\n+        x = x0;\n+        sh = ((sy + th) > h) ? (h - sy) : th;\n+\n+        for (sx = 0; sx < w; sx += tw, x += tw) {\n+            sw = ((sx + tw) > w) ? (w - sx) : tw;\n+\n+            J2dTraceLn7(J2D_TRACE_INFO, \"sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d\", sx, sy, x, y, sw, sh, w);\n+            MTLVertexCache_AddMaskQuad(mtlc,\n+                                       sx, sy, x, y, sw, sh,\n+                                       w, ginfo->image,\n+                                       dstOps);\n+        }\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+\n+static jboolean\n+MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,\n+                          GlyphInfo *ginfo, jint x, jint y,\n+                          jint rowBytesOffset,\n+                          jboolean rgbOrder, jint contrast)\n+{\n+    jfloat tx1, ty1, tx2, ty2;\n+    jint tw, th;\n+    jint w = ginfo->width;\n+    jint h = ginfo->height;\n+    id<MTLTexture> blitTexture = nil;\n+\n+    J2dTraceLn2(J2D_TRACE_INFO, \"MTLTR_DrawLCDGlyphNoCache x %d, y%d\", x, y);\n+    J2dTraceLn3(J2D_TRACE_INFO, \"MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d\", rowBytesOffset, rgbOrder, contrast);\n+\n+\n+    id<MTLRenderCommandEncoder> encoder = nil;\n+\n+    MTLTextureDescriptor *textureDescriptor =\n+        [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm\n+                                                            width:w\n+                                                            height:h\n+                                                            mipmapped:NO];\n+\n+    blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];\n+\n+    if (glyphMode != MODE_NO_CACHE_LCD) {\n+        if (glyphMode == MODE_NO_CACHE_GRAY) {\n+            MTLVertexCache_DisableMaskCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_GRAY) {\n+            MTLTR_DisableGlyphVertexCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_LCD) {\n+            [mtlc.encoderManager endEncoder];\n+            lcdCacheEncoder = nil;\n+        }\n+\n+        if (blitTexture == nil) {\n+            J2dTraceLn(J2D_TRACE_ERROR, \"can't obtain temporary texture object from pool\");\n+            return JNI_FALSE;\n+        }\n+\n+\n+        glyphMode = MODE_NO_CACHE_LCD;\n+    }\n+    encoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n+    MTLTR_SetLCDContrast(mtlc, contrast, encoder);\n+\n+    unsigned int imageBytes = w * h *4;\n+    unsigned char imageData[imageBytes];\n+    memset(&imageData, 0, sizeof(imageData));\n+\n+    for (int i = 0; i < h; i++) {\n+        for (int j = 0; j < w; j++) {\n+            imageData[(i * w * 4) + j * 4] = ginfo->image[((i * w * 3) + j * 3) + rowBytesOffset];\n+            imageData[(i * w * 4) + j * 4 + 1] = ginfo->image[((i * w * 3) + j * 3 + 1) + rowBytesOffset];\n+            imageData[(i * w * 4) + j * 4 + 2] = ginfo->image[((i * w * 3) + j * 3 + 2) + rowBytesOffset];\n+            imageData[(i * w * 4) + j * 4 + 3] = 0xFF;\n+        }\n+    }\n+\n+    \/\/ copy LCD mask into glyph texture tile\n+    MTLRegion region = MTLRegionMake2D(0, 0, w, h);\n+\n+    NSUInteger bytesPerRow = 4 * ginfo->width;\n+    [blitTexture replaceRegion:region\n+                 mipmapLevel:0\n+                 withBytes:imageData\n+                 bytesPerRow:bytesPerRow];\n+\n+    tx1 = 0.0f;\n+    ty1 = 0.0f;\n+    tx2 = 1.0f;\n+    ty2 = 1.0f;\n+\n+    J2dTraceLn3(J2D_TRACE_INFO, \"xOffset %d yOffset %d, dstOps->height %d\", dstOps->xOffset, dstOps->yOffset, dstOps->height);\n+    J2dTraceLn4(J2D_TRACE_INFO, \"tx1 %f, ty1 %f, tx2 %f, ty2 %f\", tx1, ty1, tx2, ty2);\n+    J2dTraceLn2(J2D_TRACE_INFO, \"textureWidth %d textureHeight %d\", dstOps->textureWidth, dstOps->textureHeight);\n+\n+    LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);\n+\n+    [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];\n+    [encoder setFragmentTexture:blitTexture atIndex:0];\n+    [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+\n+    vertexCacheIndex = 0;\n+    [mtlc.encoderManager endEncoder];\n+    [blitTexture release];\n+\n+    MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];\n+\n+    id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+    [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+        [cbwrapper release];\n+    }];\n+\n+    [commandbuf commit];\n+    [commandbuf waitUntilCompleted];\n+\n+    return JNI_TRUE;\n+}\n+\n+\/\/ see DrawGlyphList.c for more on this macro...\n+#define FLOOR_ASSIGN(l, r) \\\n+    if ((r)<0) (l) = ((int)floor(r)); else (l) = ((int)(r))\n+\n+void\n+MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,\n+                    jint totalGlyphs, jboolean usePositions,\n+                    jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,\n+                    jfloat glyphListOrigX, jfloat glyphListOrigY,\n+                    unsigned char *images, unsigned char *positions)\n+{\n+    int glyphCounter;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList\");\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+    RETURN_IF_NULL(images);\n+    if (usePositions) {\n+        RETURN_IF_NULL(positions);\n+    }\n+\n+    glyphMode = MODE_NOT_INITED;\n+    J2dTraceLn1(J2D_TRACE_INFO, \"totalGlyphs = %d\", totalGlyphs);\n+    jboolean flushBeforeLCD = JNI_FALSE;\n+\n+    for (glyphCounter = 0; glyphCounter < totalGlyphs; glyphCounter++) {\n+        J2dTraceLn(J2D_TRACE_INFO, \"Entered for loop for glyph list\");\n+        jint x, y;\n+        jfloat glyphx, glyphy;\n+        jboolean grayscale, ok;\n+        GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));\n+\n+        if (ginfo == NULL) {\n+            \/\/ this shouldn't happen, but if it does we'll just break out...\n+            J2dRlsTraceLn(J2D_TRACE_ERROR,\n+                          \"MTLTR_DrawGlyphList: glyph info is null\");\n+            break;\n+        }\n+\n+        grayscale = (ginfo->rowBytes == ginfo->width);\n+\n+        if (usePositions) {\n+            jfloat posx = NEXT_FLOAT(positions);\n+            jfloat posy = NEXT_FLOAT(positions);\n+            glyphx = glyphListOrigX + posx + ginfo->topLeftX;\n+            glyphy = glyphListOrigY + posy + ginfo->topLeftY;\n+            FLOOR_ASSIGN(x, glyphx);\n+            FLOOR_ASSIGN(y, glyphy);\n+        } else {\n+            glyphx = glyphListOrigX + ginfo->topLeftX;\n+            glyphy = glyphListOrigY + ginfo->topLeftY;\n+            FLOOR_ASSIGN(x, glyphx);\n+            FLOOR_ASSIGN(y, glyphy);\n+            glyphListOrigX += ginfo->advanceX;\n+            glyphListOrigY += ginfo->advanceY;\n+        }\n+\n+        if (ginfo->image == NULL) {\n+            J2dTraceLn(J2D_TRACE_INFO, \"Glyph image is null\");\n+            continue;\n+        }\n+\n+        J2dTraceLn2(J2D_TRACE_INFO, \"Glyph width = %d height = %d\", ginfo->width, ginfo->height);\n+        J2dTraceLn1(J2D_TRACE_INFO, \"rowBytes = %d\", ginfo->rowBytes);\n+        if (grayscale) {\n+            \/\/ grayscale or monochrome glyph data\n+            if (ginfo->width <= MTLTR_CACHE_CELL_WIDTH &&\n+                ginfo->height <= MTLTR_CACHE_CELL_HEIGHT)\n+            {\n+                J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList Grayscale cache\");\n+                ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);\n+            } else {\n+                J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList Grayscale no cache\");\n+                ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);\n+            }\n+        } else {\n+            if (!flushBeforeLCD) {\n+                [mtlc.encoderManager endEncoder];\n+                MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];\n+\n+                id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+                [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                    [cbwrapper release];\n+                }];\n+\n+                [commandbuf commit];\n+                flushBeforeLCD = JNI_TRUE;\n+            }\n+\n+            \/\/ LCD-optimized glyph data\n+            jint rowBytesOffset = 0;\n+\n+            if (subPixPos) {\n+                jint frac = (jint)((glyphx - x) * 3);\n+                if (frac != 0) {\n+                    rowBytesOffset = 3 - frac;\n+                    x += 1;\n+                }\n+            }\n+\n+            if (rowBytesOffset == 0 &&\n+                ginfo->width <= MTLTR_CACHE_CELL_WIDTH &&\n+                ginfo->height <= MTLTR_CACHE_CELL_HEIGHT)\n+            {\n+                J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList LCD cache\");\n+                ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,\n+                                                ginfo, x, y,\n+                                                rgbOrder, lcdContrast);\n+            } else {\n+                J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList LCD no cache\");\n+                ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,\n+                                               ginfo, x, y,\n+                                               rowBytesOffset,\n+                                               rgbOrder, lcdContrast);\n+            }\n+        }\n+\n+        if (!ok) {\n+            break;\n+        }\n+    }\n+    \/*\n+     * Only in case of grayscale text drawing we need to flush\n+     * cache. Still in case of LCD we are not using any intermediate\n+     * cache.\n+     *\/\n+    if (glyphMode == MODE_NO_CACHE_GRAY) {\n+        MTLVertexCache_DisableMaskCache(mtlc);\n+    } else if (glyphMode == MODE_USE_CACHE_GRAY) {\n+        MTLTR_DisableGlyphVertexCache(mtlc);\n+    } else if (glyphMode == MODE_USE_CACHE_LCD) {\n+        [mtlc.encoderManager endEncoder];\n+        lcdCacheEncoder = nil;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList\n+    (JNIEnv *env, jobject self,\n+     jint numGlyphs, jboolean usePositions,\n+     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,\n+     jfloat glyphListOrigX, jfloat glyphListOrigY,\n+     jlongArray imgArray, jfloatArray posArray)\n+{\n+    unsigned char *images;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTextRenderer_drawGlyphList\");\n+\n+    images = (unsigned char *)\n+        (*env)->GetPrimitiveArrayCritical(env, imgArray, NULL);\n+    if (images != NULL) {\n+        MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();\n+        BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+\n+        if (usePositions) {\n+            unsigned char *positions = (unsigned char *)\n+                (*env)->GetPrimitiveArrayCritical(env, posArray, NULL);\n+            if (positions != NULL) {\n+                MTLTR_DrawGlyphList(env, mtlc, dstOps,\n+                                    numGlyphs, usePositions,\n+                                    subPixPos, rgbOrder, lcdContrast,\n+                                    glyphListOrigX, glyphListOrigY,\n+                                    images, positions);\n+                (*env)->ReleasePrimitiveArrayCritical(env, posArray,\n+                                                      positions, JNI_ABORT);\n+            }\n+        } else {\n+            MTLTR_DrawGlyphList(env, mtlc, dstOps,\n+                                numGlyphs, usePositions,\n+                                subPixPos, rgbOrder, lcdContrast,\n+                                glyphListOrigX, glyphListOrigY,\n+                                images, NULL);\n+        }\n+        if (mtlc != NULL) {\n+            RESET_PREVIOUS_OP();\n+            [mtlc.encoderManager endEncoder];\n+            MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+            id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+            [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+                [cbwrapper release];\n+            }];\n+            [commandbuf commit];\n+        }\n+\n+        (*env)->ReleasePrimitiveArrayCritical(env, imgArray,\n+                                              images, JNI_ABORT);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":777,"deletions":0,"binary":false,"changes":777,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLTexturePool_h_Included\n+#define MTLTexturePool_h_Included\n+#include <time.h>\n+#import \"MTLUtils.h\"\n+\n+@class MTLPoolCell;\n+\n+@interface MTLTexturePoolItem : NSObject\n+@property (readwrite, retain) id<MTLTexture> texture;\n+@property (readwrite) bool isBusy;\n+@property (readwrite) time_t lastUsed;\n+@property (readwrite) bool isMultiSample;\n+@property (readwrite, assign) MTLTexturePoolItem* prev;\n+@property (readwrite, retain) MTLTexturePoolItem* next;\n+@property (readwrite, assign) MTLPoolCell* cell;\n+\n+- (id) initWithTexture:(id<MTLTexture>)tex cell:(MTLPoolCell*)cell;\n+@end\n+\n+@interface MTLPooledTextureHandle : NSObject\n+@property (readonly, assign) id<MTLTexture> texture;\n+@property (readonly) MTLRegion rect;\n+- (void) releaseTexture;\n+@end\n+\n+\/\/ NOTE: owns all MTLTexture objects\n+@interface MTLTexturePool : NSObject\n+@property (readwrite, retain) id<MTLDevice> device;\n+\n+- (id) initWithDevice:(id<MTLDevice>)device;\n+- (MTLPooledTextureHandle *) getTexture:(int)width height:(int)height format:(MTLPixelFormat)format;\n+- (MTLPooledTextureHandle *) getTexture:(int)width height:(int)height format:(MTLPixelFormat)format\n+                          isMultiSample:(bool)isMultiSample;\n+@end\n+\n+@interface MTLPoolCell : NSObject\n+@property (readwrite, retain) MTLTexturePoolItem* available;\n+@property (readwrite, assign) MTLTexturePoolItem* availableTail;\n+@property (readwrite, retain) MTLTexturePoolItem* occupied;\n+- (MTLTexturePoolItem *)createItem:(id<MTLDevice>)dev\n+                             width:(int)width\n+                            height:(int)height\n+                            format:(MTLPixelFormat)format\n+                     isMultiSample:(bool)isMultiSample;\n+- (NSUInteger)cleanIfBefore:(time_t)lastUsedTimeToRemove;\n+- (void)releaseItem:(MTLTexturePoolItem *)item;\n+@end\n+\n+#endif \/* MTLTexturePool_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexturePool.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MTLTexturePool.h\"\n+#import \"Trace.h\"\n+\n+#define SCREEN_MEMORY_SIZE_4K (4096*2160*4) \/\/~33,7 mb\n+#define MAX_POOL_MEMORY SCREEN_MEMORY_SIZE_4K\/2\n+#define MAX_POOL_ITEM_LIFETIME_SEC 30\n+\n+#define CELL_WIDTH_BITS 5 \/\/ ~ 32 pixel\n+#define CELL_HEIGHT_BITS 5 \/\/ ~ 32 pixel\n+\n+@implementation MTLTexturePoolItem\n+\n+@synthesize texture, isBusy, lastUsed, isMultiSample, next, cell;\n+\n+- (id) initWithTexture:(id<MTLTexture>)tex cell:(MTLPoolCell*)c{\n+    self = [super init];\n+    if (self == nil) return self;\n+    self.texture = tex;\n+    isBusy = NO;\n+    self.next = nil;\n+    self.prev = nil;\n+    self.cell = c;\n+    return self;\n+}\n+\n+- (void) dealloc {\n+    [texture release];\n+    [super dealloc];\n+}\n+\n+@end\n+\n+@implementation MTLPooledTextureHandle\n+{\n+    MTLRegion _rect;\n+    id<MTLTexture> _texture;\n+    MTLTexturePoolItem * _poolItem;\n+}\n+@synthesize texture = _texture, rect = _rect;\n+\n+- (id) initWithPoolItem:(id<MTLTexture>)texture rect:(MTLRegion)rectangle poolItem:(MTLTexturePoolItem *)poolItem {\n+    self = [super init];\n+    if (self == nil) return self;\n+\n+    _rect = rectangle;\n+    _texture = texture;\n+    _poolItem = poolItem;\n+    return self;\n+}\n+\n+- (void) releaseTexture {\n+    [_poolItem.cell releaseItem:_poolItem];\n+}\n+\n+@end\n+\n+@implementation MTLPoolCell {\n+    NSLock* _lock;\n+}\n+@synthesize available, availableTail, occupied;\n+\n+- (instancetype)init {\n+    self = [super init];\n+    if (self) {\n+        self.available = nil;\n+        self.availableTail = nil;\n+        self.occupied = nil;\n+        _lock = [[NSLock alloc] init];\n+    }\n+    return self;\n+}\n+\n+- (void)occupyItem:(MTLTexturePoolItem *)item {\n+    if (item.isBusy) return;\n+    [item retain];\n+    if (item.prev == nil) {\n+        self.available = item.next;\n+        if (item.next) {\n+            item.next.prev = nil;\n+        } else {\n+            self.availableTail = item.prev;\n+        }\n+    } else {\n+        item.prev.next = item.next;\n+        if (item.next) {\n+            item.next.prev = item.prev;\n+        } else {\n+            self.availableTail = item.prev;\n+        }\n+        item.prev = nil;\n+    }\n+    if (occupied) occupied.prev = item;\n+    item.next = occupied;\n+    self.occupied = item;\n+    [item release];\n+    item.isBusy = YES;\n+}\n+\n+- (void)releaseItem:(MTLTexturePoolItem *)item {\n+    [_lock lock];\n+    @try {\n+        if (!item.isBusy) return;\n+        [item retain];\n+        if (item.prev == nil) {\n+            self.occupied = item.next;\n+            if (item.next) item.next.prev = nil;\n+        } else {\n+            item.prev.next = item.next;\n+            if (item.next) item.next.prev = item.prev;\n+            item.prev = nil;\n+        }\n+        if (self.available) {\n+            self.available.prev = item;\n+        } else {\n+            self.availableTail = item;\n+        }\n+        item.next = self.available;\n+        self.available = item;\n+        item.isBusy = NO;\n+        [item release];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+}\n+\n+- (void)addOccupiedItem:(MTLTexturePoolItem *)item {\n+    if (self.occupied) self.occupied.prev = item;\n+    item.next = self.occupied;\n+    item.isBusy = YES;\n+    self.occupied = item;\n+}\n+\n+- (void)removeAvailableItem:(MTLTexturePoolItem*)item {\n+    [item retain];\n+    if (item.prev == nil) {\n+        self.available = item.next;\n+        if (item.next) {\n+            item.next.prev = nil;\n+            item.next = nil;\n+        } else {\n+            self.availableTail = item.prev;\n+        }\n+    } else {\n+        item.prev.next = item.next;\n+        if (item.next) {\n+            item.next.prev = item.prev;\n+            item.next = nil;\n+        } else {\n+            self.availableTail = item.prev;\n+        }\n+    }\n+    [item release];\n+}\n+\n+- (void)removeAllItems {\n+    MTLTexturePoolItem *cur = self.available;\n+    while (cur != nil) {\n+        cur = cur.next;\n+        self.available = cur;\n+    }\n+    cur = self.occupied;\n+    while (cur != nil) {\n+        cur = cur.next;\n+        self.occupied = cur;\n+    }\n+    self.availableTail = nil;\n+}\n+\n+- (MTLTexturePoolItem *)createItem:(id<MTLDevice>)dev\n+                             width:(int)width\n+                            height:(int)height\n+                            format:(MTLPixelFormat)format\n+                     isMultiSample:(bool)isMultiSample\n+{\n+    MTLTextureDescriptor *textureDescriptor =\n+            [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:format\n+                                                               width:(NSUInteger) width\n+                                                              height:(NSUInteger) height\n+                                                           mipmapped:NO];\n+    if (isMultiSample) {\n+        textureDescriptor.textureType = MTLTextureType2DMultisample;\n+        textureDescriptor.sampleCount = MTLAASampleCount;\n+        textureDescriptor.storageMode = MTLStorageModePrivate;\n+    }\n+\n+    id <MTLTexture> tex = (id <MTLTexture>) [[dev newTextureWithDescriptor:textureDescriptor] autorelease];\n+    MTLTexturePoolItem* item = [[[MTLTexturePoolItem alloc] initWithTexture:tex cell:self] autorelease];\n+    item.isMultiSample = isMultiSample;\n+    [_lock lock];\n+    @try {\n+        [self addOccupiedItem:item];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return item;\n+}\n+\n+\n+- (NSUInteger)cleanIfBefore:(time_t)lastUsedTimeToRemove {\n+    NSUInteger deallocMem = 0;\n+    [_lock lock];\n+    MTLTexturePoolItem *cur = availableTail;\n+    @try {\n+        while (cur != nil) {\n+            MTLTexturePoolItem *prev = cur.prev;\n+            if (lastUsedTimeToRemove <= 0 ||\n+                cur.lastUsed < lastUsedTimeToRemove) {\n+#ifdef DEBUG\n+                J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,\n+                             \"MTLTexturePool: remove pool item: tex=%p, w=%d h=%d, elapsed=%d\",\n+                             cur.texture, cur.texture.width, cur.texture.height,\n+                             time(NULL) - cur.lastUsed);\n+#endif \/\/DEBUG\n+                deallocMem += cur.texture.width * cur.texture.height * 4;\n+                [self removeAvailableItem:cur];\n+            } else {\n+                if (lastUsedTimeToRemove > 0) break;\n+            }\n+            cur = prev;\n+        }\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return deallocMem;\n+}\n+\n+- (MTLTexturePoolItem *)occupyItem:(int)width height:(int)height format:(MTLPixelFormat)format\n+                     isMultiSample:(bool)isMultiSample {\n+    int minDeltaArea = -1;\n+    const int requestedPixels = width*height;\n+    MTLTexturePoolItem *minDeltaTpi = nil;\n+    [_lock lock];\n+    @try {\n+        for (MTLTexturePoolItem *cur = available; cur != nil; cur = cur.next) {\n+            if (cur.texture.pixelFormat != format\n+                || cur.isMultiSample != isMultiSample) { \/\/ TODO: use swizzle when formats are not equal\n+                continue;\n+            }\n+            if (cur.texture.width < width || cur.texture.height < height) {\n+                continue;\n+            }\n+            const int deltaArea = (const int) (cur.texture.width * cur.texture.height - requestedPixels);\n+            if (minDeltaArea < 0 || deltaArea < minDeltaArea) {\n+                minDeltaArea = deltaArea;\n+                minDeltaTpi = cur;\n+                if (deltaArea == 0) {\n+                    \/\/ found exact match in current cell\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (minDeltaTpi) {\n+            [self occupyItem:minDeltaTpi];\n+        }\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return minDeltaTpi;\n+}\n+\n+- (void) dealloc {\n+    [_lock lock];\n+    @try {\n+        [self removeAllItems];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    [_lock release];\n+    [super dealloc];\n+}\n+\n+@end\n+\n+@implementation MTLTexturePool {\n+    int _memoryTotalAllocated;\n+\n+    void ** _cells;\n+    int _poolCellWidth;\n+    int _poolCellHeight;\n+}\n+\n+@synthesize device;\n+\n+- (id) initWithDevice:(id<MTLDevice>)dev {\n+    self = [super init];\n+    if (self == nil) return self;\n+\n+    _memoryTotalAllocated = 0;\n+    _poolCellWidth = 10;\n+    _poolCellHeight = 10;\n+    const int cellsCount = _poolCellWidth * _poolCellHeight;\n+    _cells = (void **)malloc(cellsCount * sizeof(void*));\n+    memset(_cells, 0, cellsCount * sizeof(void*));\n+    self.device = dev;\n+    return self;\n+}\n+\n+- (void) dealloc {\n+    for (int c = 0; c < _poolCellWidth * _poolCellHeight; ++c) {\n+        MTLPoolCell * cell = _cells[c];\n+        if (cell != NULL) {\n+            [cell release];\n+        }\n+    }\n+    free(_cells);\n+    [super dealloc];\n+}\n+\n+\/\/ NOTE: called from RQ-thread (on blit operations)\n+- (MTLPooledTextureHandle *) getTexture:(int)width height:(int)height format:(MTLPixelFormat)format {\n+    return [self getTexture:width height:height format:format isMultiSample:NO];\n+}\n+\n+\/\/ NOTE: called from RQ-thread (on blit operations)\n+- (MTLPooledTextureHandle *) getTexture:(int)width height:(int)height format:(MTLPixelFormat)format\n+                          isMultiSample:(bool)isMultiSample {\n+        \/\/ 1. clean pool if necessary\n+        const int requestedPixels = width*height;\n+        const int requestedBytes = requestedPixels*4;\n+        if (_memoryTotalAllocated + requestedBytes > MAX_POOL_MEMORY) {\n+            [self cleanIfNecessary:0]; \/\/ release all free textures\n+        } else if (_memoryTotalAllocated + requestedBytes > MAX_POOL_MEMORY\/2) {\n+            [self cleanIfNecessary:MAX_POOL_ITEM_LIFETIME_SEC]; \/\/ release only old free textures\n+        }\n+\n+        \/\/ 2. find free item\n+        const int cellX0 = width    >> CELL_WIDTH_BITS;\n+        const int cellY0 = height   >> CELL_HEIGHT_BITS;\n+        const int cellX1 = cellX0 + 1;\n+        const int cellY1 = cellY0 + 1;\n+        if (cellX1 > _poolCellWidth || cellY1 > _poolCellHeight) {\n+            const int newCellWidth = cellX1 <= _poolCellWidth ? _poolCellWidth : cellX1;\n+            const int newCellHeight = cellY1 <= _poolCellHeight ? _poolCellHeight : cellY1;\n+            const int newCellsCount = newCellWidth*newCellHeight;\n+#ifdef DEBUG\n+            J2dTraceLn2(J2D_TRACE_VERBOSE, \"MTLTexturePool: resize: %d -> %d\", _poolCellWidth * _poolCellHeight, newCellsCount);\n+#endif\n+            void ** newcells = malloc(newCellsCount*sizeof(void*));\n+            const int strideBytes = _poolCellWidth * sizeof(void*);\n+            for (int cy = 0; cy < _poolCellHeight; ++cy) {\n+                void ** dst = newcells + cy*newCellWidth;\n+                void ** src = _cells + cy * _poolCellWidth;\n+                memcpy(dst, src, strideBytes);\n+                if (newCellWidth > _poolCellWidth)\n+                    memset(dst + _poolCellWidth, 0, (newCellWidth - _poolCellWidth) * sizeof(void*));\n+            }\n+            if (newCellHeight > _poolCellHeight) {\n+                void ** dst = newcells + _poolCellHeight * newCellWidth;\n+                memset(dst, 0, (newCellHeight - _poolCellHeight) * newCellWidth * sizeof(void*));\n+            }\n+            free(_cells);\n+            _cells = newcells;\n+            _poolCellWidth = newCellWidth;\n+            _poolCellHeight = newCellHeight;\n+        }\n+\n+        MTLTexturePoolItem * minDeltaTpi = nil;\n+        int minDeltaArea = -1;\n+        for (int cy = cellY0; cy < cellY1; ++cy) {\n+            for (int cx = cellX0; cx < cellX1; ++cx) {\n+                MTLPoolCell * cell = _cells[cy * _poolCellWidth + cx];\n+                if (cell != NULL) {\n+                    MTLTexturePoolItem* tpi = [cell occupyItem:width height:height\n+                                                        format:format isMultiSample:isMultiSample];\n+                    if (!tpi) continue;\n+                    const int deltaArea = (const int) (tpi.texture.width * tpi.texture.height - requestedPixels);\n+                    if (minDeltaArea < 0 || deltaArea < minDeltaArea) {\n+                        minDeltaArea = deltaArea;\n+                        minDeltaTpi = tpi;\n+                        if (deltaArea == 0) {\n+                            \/\/ found exact match in current cell\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            if (minDeltaTpi != nil) {\n+                break;\n+            }\n+        }\n+\n+        if (minDeltaTpi == NULL) {\n+            MTLPoolCell* cell = _cells[cellY0 * _poolCellWidth + cellX0];\n+            if (cell == NULL) {\n+                cell = [[MTLPoolCell alloc] init];\n+                _cells[cellY0 * _poolCellWidth + cellX0] = cell;\n+            }\n+            minDeltaTpi = [cell createItem:device width:width height:height format:format isMultiSample:isMultiSample];\n+            _memoryTotalAllocated += requestedBytes;\n+            J2dTraceLn5(J2D_TRACE_VERBOSE, \"MTLTexturePool: created pool item: tex=%p, w=%d h=%d, pf=%d | total memory = %d Kb\", minDeltaTpi.texture, width, height, format, _memoryTotalAllocated\/1024);\n+        }\n+\n+        minDeltaTpi.isBusy = YES;\n+        minDeltaTpi.lastUsed = time(NULL);\n+        return [[[MTLPooledTextureHandle alloc] initWithPoolItem:minDeltaTpi.texture\n+                                                            rect:MTLRegionMake2D(0, 0,\n+                                                                                 minDeltaTpi.texture.width,\n+                                                                                 minDeltaTpi.texture.height)\n+                                                        poolItem:minDeltaTpi] autorelease];\n+}\n+\n+- (void) cleanIfNecessary:(int)lastUsedTimeThreshold {\n+    time_t lastUsedTimeToRemove =\n+            lastUsedTimeThreshold > 0 ?\n+                time(NULL) - lastUsedTimeThreshold :\n+                lastUsedTimeThreshold;\n+    for (int cy = 0; cy < _poolCellHeight; ++cy) {\n+        for (int cx = 0; cx < _poolCellWidth; ++cx) {\n+            MTLPoolCell * cell = _cells[cy * _poolCellWidth + cx];\n+            if (cell != NULL) {\n+                _memoryTotalAllocated -= [cell cleanIfBefore:lastUsedTimeToRemove];\n+            }\n+        }\n+    }\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexurePool.m","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLTransform_h_Included\n+#define MTLTransform_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include <jni.h>\n+\n+@interface MTLTransform : NSObject\n+- (id)init;\n+- (BOOL)isEqual:(MTLTransform *)other;\n+- (void)copyFrom:(MTLTransform *)other;\n+\n+- (void)setTransformM00:(jdouble) m00 M10:(jdouble) m10\n+                    M01:(jdouble) m01 M11:(jdouble) m11\n+                    M02:(jdouble) m02 M12:(jdouble) m12;\n+- (void)resetTransform;\n+\n+- (void)setVertexMatrix:(id<MTLRenderCommandEncoder>)encoder\n+              destWidth:(NSUInteger)dw\n+             destHeight:(NSUInteger)dh;\n+@end\n+\n+#endif \/\/ MTLTransform_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTransform.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLTransform.h\"\n+\n+#include <jni.h>\n+#include <simd\/simd.h>\n+\n+#include \"common.h\"\n+\n+@implementation MTLTransform {\n+    jboolean      _useTransform;\n+    simd_float4x4 _transform4x4;\n+    simd_float4x4 _normalize4x4; \/\/ just a buffer for setVertexMatrix\n+}\n+\n+- (id)init {\n+    self = [super init];\n+    if (self) {\n+        memset(&_normalize4x4, 0, sizeof(_normalize4x4));\n+        _normalize4x4.columns[3][0] = -1.f;\n+        _normalize4x4.columns[3][1] = 1.f;\n+        _normalize4x4.columns[3][3] = 1.0;\n+\n+        _useTransform = JNI_FALSE;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLTransform *)other {\n+    if (self == other)\n+        return YES;\n+    return _useTransform == other->_useTransform\n+           && simd_equal(_transform4x4, other->_transform4x4);\n+}\n+\n+- (void)copyFrom:(MTLTransform *)other {\n+    _useTransform = other->_useTransform;\n+    if (_useTransform) {\n+        _transform4x4 = other->_transform4x4;\n+    }\n+}\n+\n+- (void)setTransformM00:(jdouble) m00 M10:(jdouble) m10\n+                    M01:(jdouble) m01 M11:(jdouble) m11\n+                    M02:(jdouble) m02 M12:(jdouble) m12 {\n+    memset(&(_transform4x4), 0, sizeof(_transform4x4));\n+    _transform4x4.columns[0][0] = m00;\n+    _transform4x4.columns[0][1] = m10;\n+    _transform4x4.columns[1][0] = m01;\n+    _transform4x4.columns[1][1] = m11;\n+    _transform4x4.columns[3][0] = m02;\n+    _transform4x4.columns[3][1] = m12;\n+    _transform4x4.columns[3][3] = 1.0;\n+    _useTransform = JNI_TRUE;\n+}\n+\n+- (void)resetTransform {\n+    _useTransform = JNI_FALSE;\n+}\n+\n+- (void)setVertexMatrix:(id<MTLRenderCommandEncoder>)encoder\n+              destWidth:(NSUInteger)dw\n+             destHeight:(NSUInteger)dh {\n+    \/\/ update matrix for vertex shader\n+    _normalize4x4.columns[0][0] = 2\/(double)dw;\n+    _normalize4x4.columns[1][1] = -2\/(double)dh;\n+\n+    if (_useTransform) {\n+        simd_float4x4 vertexMatrix = simd_mul(_normalize4x4, _transform4x4);\n+        [encoder setVertexBytes:&(vertexMatrix) length:sizeof(vertexMatrix) atIndex:MatrixBuffer];\n+    } else {\n+        [encoder setVertexBytes:&(_normalize4x4) length:sizeof(_normalize4x4) atIndex:MatrixBuffer];\n+    }\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTransform.m","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLUtils_h_Included\n+#define MTLUtils_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#define MTLAASampleCount 4\n+\n+#endif \/* MTLUtils_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLUtils.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLUtils.h\"\n+\n+#include <jni.h>\n+#include <simd\/simd.h>\n+#import <ThreadUtilities.h>\n+#import <PropertiesUtilities.h>\n+#include \"common.h\"\n+#include \"Trace.h\"\n+\n+extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);\n+void J2dTraceTraceVector(simd_float4 pt) {\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE, \"[%lf %lf %lf %lf]\", pt.x, pt.y, pt.z, pt.w);\n+}\n+\n+void checkTransform(float * position, simd_float4x4 transform4x4) {\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE, \"check transform: \");\n+\n+    simd_float4 fpt = simd_make_float4(position[0], position[1], position[2], 1.f);\n+    simd_float4 fpt_trans = simd_mul(transform4x4, fpt);\n+    J2dTraceTraceVector(fpt);\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE, \"  ===>>>  \");\n+    J2dTraceTraceVector(fpt_trans);\n+    J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, \" \");\n+}\n+\n+static void traceMatrix(simd_float4x4 * mtx) {\n+    for (int row = 0; row < 4; ++row) {\n+        J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE, \"  [%lf %lf %lf %lf]\",\n+                    mtx->columns[0][row], mtx->columns[1][row], mtx->columns[2][row], mtx->columns[3][row]);\n+    }\n+}\n+\n+void traceRaster(char * p, int width, int height, int stride) {\n+    for (int y = 0; y < height; ++y) {\n+        for (int x = 0; x < width; ++x) {\n+            unsigned char pix0 = p[y*stride + x*4];\n+            unsigned char pix1 = p[y*stride + x*4 + 1];\n+            unsigned char pix2 = p[y*stride + x*4 + 2];\n+            unsigned char pix3 = p[y*stride + x*4 + 3];\n+            J2dTraceImpl(J2D_TRACE_INFO, JNI_FALSE,\"[%u,%u,%u,%u], \", pix0, pix1, pix2, pix3);\n+        }\n+        J2dTraceImpl(J2D_TRACE_INFO, JNI_TRUE, \"\");\n+    }\n+}\n+\n+void tracePoints(jint nPoints, jint *xPoints, jint *yPoints) {\n+    for (int i = 0; i < nPoints; i++)\n+        J2dTraceImpl(J2D_TRACE_INFO, JNI_TRUE, \"\\t(%d, %d)\", *(xPoints++), *(yPoints++));\n+}\n+\n+\n+jboolean isOptionEnabled(const char * option) {\n+    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n+\n+    NSString * optionProp = [PropertiesUtilities\n+            javaSystemPropertyForKey:[NSString stringWithUTF8String:option] withEnv:env];\n+    NSString * lowerCaseProp = [optionProp localizedLowercaseString];\n+    return [@\"true\" isEqual:lowerCaseProp];\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLUtils.m","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLVertexCache_h_Included\n+#define MTLVertexCache_h_Included\n+#include \"j2d_md.h\"\n+#include \"MTLContext.h\"\n+#include \"fontscalerdefs.h\"\n+\n+\/**\n+ * Constants that control the size of the vertex cache.\n+ *\/\n+#define MTLVC_MAX_INDEX         250\n+\n+\/**\n+ * Constants that control the size of the texture tile cache used for\n+ * mask operations.\n+ *\/\n+#define MTLVC_MASK_CACHE_TILE_WIDTH       32\n+#define MTLVC_MASK_CACHE_TILE_HEIGHT      32\n+#define MTLVC_MASK_CACHE_TILE_SIZE \\\n+   (MTLVC_MASK_CACHE_TILE_WIDTH * MTLVC_MASK_CACHE_TILE_HEIGHT)\n+\n+#define MTLVC_MASK_CACHE_WIDTH_IN_TILES   8\n+#define MTLVC_MASK_CACHE_HEIGHT_IN_TILES  4\n+\n+#define MTLVC_MASK_CACHE_WIDTH_IN_TEXELS \\\n+   (MTLVC_MASK_CACHE_TILE_WIDTH * MTLVC_MASK_CACHE_WIDTH_IN_TILES)\n+#define MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS \\\n+   (MTLVC_MASK_CACHE_TILE_HEIGHT * MTLVC_MASK_CACHE_HEIGHT_IN_TILES)\n+\n+\/*\n+ * We reserve one (fully opaque) tile in the upper-right corner for\n+ * operations where the mask is null.\n+ *\/\n+#define MTLVC_MASK_CACHE_MAX_INDEX \\\n+   ((MTLVC_MASK_CACHE_WIDTH_IN_TILES * MTLVC_MASK_CACHE_HEIGHT_IN_TILES) - 1)\n+#define MTLVC_MASK_CACHE_SPECIAL_TILE_X \\\n+   (MTLVC_MASK_CACHE_WIDTH_IN_TEXELS - MTLVC_MASK_CACHE_TILE_WIDTH)\n+#define MTLVC_MASK_CACHE_SPECIAL_TILE_Y \\\n+   (MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS - MTLVC_MASK_CACHE_TILE_HEIGHT)\n+\n+\/**\n+ * Exported methods.\n+ *\/\n+jboolean MTLVertexCache_InitVertexCache();\n+void MTLVertexCache_FlushVertexCache(MTLContext *mtlc);\n+void MTLVertexCache_FlushGlyphVertexCache();\n+void MTLVertexCache_FreeVertexCache();\n+\n+void MTLVertexCache_EnableMaskCache(MTLContext *mtlc, BMTLSDOps *dstOps);\n+void MTLVertexCache_DisableMaskCache(MTLContext *mtlc);\n+void MTLVertexCache_AddMaskQuad(MTLContext *mtlc,\n+                                jint srcx, jint srcy,\n+                                jint dstx, jint dsty,\n+                                jint width, jint height,\n+                                jint maskscan, void *mask,\n+                                BMTLSDOps *dstOps);\n+void\n+MTLVertexCache_AddGlyphQuad(MTLContext *mtlc,\n+                            jfloat tx1, jfloat ty1, jfloat tx2, jfloat ty2,\n+                            jfloat dx1, jfloat dy1, jfloat dx2, jfloat dy2);\n+void MTLVertexCache_CreateSamplingEncoder(MTLContext *mtlc, BMTLSDOps *dstOps);\n+#endif \/* MTLVertexCache_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLVertexCache.h","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"sun_java2d_SunGraphics2D.h\"\n+\n+#include \"MTLPaints.h\"\n+#include \"MTLVertexCache.h\"\n+#include \"MTLTexturePool.h\"\n+#include \"MTLTextRenderer.h\"\n+#include \"common.h\"\n+\n+typedef struct _J2DVertex {\n+    float position[2];\n+    float txtpos[2];\n+} J2DVertex;\n+\n+static J2DVertex *vertexCache = NULL;\n+static jint vertexCacheIndex = 0;\n+\n+static MTLPooledTextureHandle * maskCacheTex = NULL;\n+static jint maskCacheIndex = 0;\n+static id<MTLRenderCommandEncoder> encoder = NULL;\n+\n+#define MTLVC_ADD_VERTEX(TX, TY, DX, DY, DZ) \\\n+    do { \\\n+        J2DVertex *v = &vertexCache[vertexCacheIndex++]; \\\n+        v->txtpos[0] = TX; \\\n+        v->txtpos[1] = TY; \\\n+        v->position[0]= DX; \\\n+        v->position[1] = DY; \\\n+    } while (0)\n+\n+#define MTLVC_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \\\n+    do { \\\n+        MTLVC_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \\\n+        MTLVC_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \\\n+        MTLVC_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \\\n+        MTLVC_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \\\n+        MTLVC_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \\\n+        MTLVC_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \\\n+    } while (0)\n+\n+jboolean\n+MTLVertexCache_InitVertexCache()\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_InitVertexCache\");\n+\n+    if (vertexCache == NULL) {\n+        J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_InitVertexCache : vertexCache == NULL\");\n+        vertexCache = (J2DVertex *)malloc(MTLVC_MAX_INDEX * sizeof(J2DVertex));\n+        if (vertexCache == NULL) {\n+            return JNI_FALSE;\n+        }\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+void\n+MTLVertexCache_FlushVertexCache(MTLContext *mtlc)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_FlushVertexCache\");\n+\n+    if (vertexCacheIndex > 0) {\n+        [encoder setVertexBytes: vertexCache length:vertexCacheIndex * sizeof(J2DVertex)\n+                                                atIndex:MeshVertexBuffer];\n+\n+        [encoder setFragmentTexture:maskCacheTex.texture atIndex: 0];\n+        J2dTraceLn1(J2D_TRACE_INFO,\n+            \"MTLVertexCache_FlushVertexCache : encode %d characters\", (vertexCacheIndex \/ 6));\n+        [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:vertexCacheIndex];\n+    }\n+    vertexCacheIndex = 0;\n+    maskCacheIndex = 0;\n+\n+    if (maskCacheTex != nil) {\n+        [[mtlc getCommandBufferWrapper] registerPooledTexture:maskCacheTex];\n+        [maskCacheTex release];\n+        maskCacheTex = nil;\n+    }\n+}\n+\n+void\n+MTLVertexCache_FlushGlyphVertexCache()\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_FlushGlyphVertexCache\");\n+\n+    if (vertexCacheIndex > 0) {\n+        [encoder setVertexBytes: vertexCache length:vertexCacheIndex * sizeof(J2DVertex)\n+                                                atIndex:MeshVertexBuffer];\n+        id<MTLTexture> glyphCacheTex = MTLTR_GetGlyphCacheTexture();\n+        [encoder setFragmentTexture:glyphCacheTex atIndex: 0];\n+        J2dTraceLn1(J2D_TRACE_INFO,\n+            \"MTLVertexCache_FlushGlyphVertexCache : encode %d characters\", (vertexCacheIndex \/ 6));\n+        [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:vertexCacheIndex];\n+    }\n+    vertexCacheIndex = 0;\n+}\n+\n+void MTLVertexCache_FreeVertexCache()\n+{\n+    free(vertexCache);\n+    vertexCache = NULL;\n+}\n+\n+static jboolean\n+MTLVertexCache_InitMaskCache(MTLContext *mtlc) {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_InitMaskCache\");\n+    if (maskCacheTex == NULL) {\n+        maskCacheTex = [mtlc.texturePool getTexture:MTLVC_MASK_CACHE_WIDTH_IN_TEXELS\n+                                             height:MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS\n+                                             format:MTLPixelFormatA8Unorm];\n+        [maskCacheTex retain];\n+        if (maskCacheTex == nil) {\n+            J2dTraceLn(J2D_TRACE_ERROR, \"MTLVertexCache_InitMaskCache: can't obtain temporary texture object from pool\");\n+            return JNI_FALSE;\n+        }\n+    }\n+    \/\/ init special fully opaque tile in the upper-right corner of\n+    \/\/ the mask cache texture\n+\n+    char tile[MTLVC_MASK_CACHE_TILE_SIZE];\n+    memset(tile, 0xff, MTLVC_MASK_CACHE_TILE_SIZE);\n+\n+    jint texx = MTLVC_MASK_CACHE_TILE_WIDTH * (MTLVC_MASK_CACHE_WIDTH_IN_TILES - 1);\n+\n+    jint texy = MTLVC_MASK_CACHE_TILE_HEIGHT * (MTLVC_MASK_CACHE_HEIGHT_IN_TILES - 1);\n+\n+    NSUInteger bytesPerRow = 1 * MTLVC_MASK_CACHE_TILE_WIDTH;\n+\n+    MTLRegion region = {\n+            {texx,  texy,   0},\n+            {MTLVC_MASK_CACHE_TILE_WIDTH, MTLVC_MASK_CACHE_TILE_HEIGHT, 1}\n+    };\n+\n+\n+    \/\/ do we really need this??\n+    [maskCacheTex.texture replaceRegion:region\n+                    mipmapLevel:0\n+                      withBytes:tile\n+                    bytesPerRow:bytesPerRow];\n+\n+    return JNI_TRUE;\n+}\n+\n+void\n+MTLVertexCache_EnableMaskCache(MTLContext *mtlc, BMTLSDOps *dstOps)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_EnableMaskCache\");\n+\n+    if (!MTLVertexCache_InitVertexCache()) {\n+        return;\n+    }\n+\n+    if (maskCacheTex == NULL) {\n+        if (!MTLVertexCache_InitMaskCache(mtlc)) {\n+            return;\n+        }\n+    }\n+    MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);\n+}\n+\n+void\n+MTLVertexCache_DisableMaskCache(MTLContext *mtlc)\n+{\n+    \/\/ TODO : Once we enable check_previous_op\n+    \/\/ we will start using DisableMaskCache until then\n+    \/\/ we are force flushing vertexcache.\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_DisableMaskCache\");\n+    MTLVertexCache_FlushVertexCache(mtlc);\n+    maskCacheIndex = 0;\n+    free(vertexCache);\n+    vertexCache = NULL;\n+}\n+\n+void\n+MTLVertexCache_CreateSamplingEncoder(MTLContext *mtlc, BMTLSDOps *dstOps) {\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_CreateSamplingEncoder\");\n+    encoder = [mtlc.encoderManager getTextEncoder:dstOps\n+                                         isSrcOpaque:NO];\n+}\n+\n+void\n+MTLVertexCache_AddMaskQuad(MTLContext *mtlc,\n+                           jint srcx, jint srcy,\n+                           jint dstx, jint dsty,\n+                           jint width, jint height,\n+                           jint maskscan, void *mask,\n+                           BMTLSDOps *dstOps)\n+{\n+    jfloat tx1, ty1, tx2, ty2;\n+    jfloat dx1, dy1, dx2, dy2;\n+\n+    J2dTraceLn1(J2D_TRACE_INFO, \"MTLVertexCache_AddMaskQuad: %d\",\n+                maskCacheIndex);\n+\n+    if (maskCacheIndex >= MTLVC_MASK_CACHE_MAX_INDEX)\n+    {\n+        J2dTraceLn2(J2D_TRACE_INFO, \"maskCacheIndex = %d, vertexCacheIndex = %d\", maskCacheIndex, vertexCacheIndex);\n+        MTLVertexCache_FlushVertexCache(mtlc);\n+        MTLVertexCache_EnableMaskCache(mtlc, dstOps);\n+        maskCacheIndex = 0;\n+    }\n+\n+    if (mask != NULL) {\n+        jint texx = MTLVC_MASK_CACHE_TILE_WIDTH *\n+                    (maskCacheIndex % MTLVC_MASK_CACHE_WIDTH_IN_TILES);\n+        jint texy = MTLVC_MASK_CACHE_TILE_HEIGHT *\n+                    (maskCacheIndex \/ MTLVC_MASK_CACHE_WIDTH_IN_TILES);\n+        J2dTraceLn5(J2D_TRACE_INFO, \"texx = %d texy = %d width = %d height = %d maskscan = %d\", texx, texy, width,\n+                    height, maskscan);\n+        NSUInteger bytesPerRow = 1 * width;\n+        NSUInteger slice = bytesPerRow * srcy + srcx;\n+        MTLRegion region = {\n+                {texx,  texy,   0},\n+                {width, height, 1}\n+        };\n+\n+        \/\/ Whenever we have source stride bigger that destination stride\n+        \/\/ we need to pick appropriate source subtexture. In repalceRegion\n+        \/\/ we can give destination subtexturing properly but we can't\n+        \/\/ subtexture from system memory glyph we have. So in such\n+        \/\/ cases we are creating seperate tile and scan the source\n+        \/\/ stride into destination using memcpy. In case of OpenGL we\n+        \/\/ can update source pointers, in case of D3D we ar doing memcpy.\n+        \/\/ We can use MTLBuffer and then copy source subtexture but that\n+        \/\/ adds extra blitting logic.\n+        \/\/ TODO : Research more and try removing memcpy logic.\n+        if (maskscan <= width) {\n+            int height_offset = bytesPerRow * srcy;\n+            [maskCacheTex.texture replaceRegion:region\n+                            mipmapLevel:0\n+                              withBytes:mask + height_offset\n+                            bytesPerRow:bytesPerRow];\n+        } else {\n+            int dst_offset, src_offset;\n+            int size = 1 * width * height;\n+            char tile[size];\n+            dst_offset = 0;\n+            for (int i = srcy; i < srcy + height; i++) {\n+                J2dTraceLn2(J2D_TRACE_INFO, \"srcx = %d srcy = %d\", srcx, srcy);\n+                src_offset = maskscan * i + srcx;\n+                J2dTraceLn2(J2D_TRACE_INFO, \"src_offset = %d dst_offset = %d\", src_offset, dst_offset);\n+                memcpy(tile + dst_offset, mask + src_offset, width);\n+                dst_offset = dst_offset + width;\n+            }\n+            [maskCacheTex.texture replaceRegion:region\n+                            mipmapLevel:0\n+                              withBytes:tile\n+                            bytesPerRow:bytesPerRow];\n+        }\n+\n+        tx1 = ((jfloat) texx) \/ MTLVC_MASK_CACHE_WIDTH_IN_TEXELS;\n+        ty1 = ((jfloat) texy) \/ MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS;\n+    } else {\n+        tx1 = ((jfloat)MTLVC_MASK_CACHE_SPECIAL_TILE_X) \/\n+              MTLVC_MASK_CACHE_WIDTH_IN_TEXELS;\n+        ty1 = ((jfloat)MTLVC_MASK_CACHE_SPECIAL_TILE_Y) \/\n+              MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS;\n+    }\n+    maskCacheIndex++;\n+\n+    tx2 = tx1 + (((jfloat)width) \/ MTLVC_MASK_CACHE_WIDTH_IN_TEXELS);\n+    ty2 = ty1 + (((jfloat)height) \/ MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS);\n+\n+    dx1 = (jfloat)dstx;\n+    dy1 = (jfloat)dsty;\n+    dx2 = dx1 + width;\n+    dy2 = dy1 + height;\n+\n+    J2dTraceLn8(J2D_TRACE_INFO, \"tx1 = %f ty1 = %f tx2 = %f ty2 = %f dx1 = %f dy1 = %f dx2 = %f dy2 = %f\", tx1, ty1, tx2, ty2, dx1, dy1, dx2, dy2);\n+    MTLVC_ADD_TRIANGLES(tx1, ty1, tx2, ty2,\n+                        dx1, dy1, dx2, dy2);\n+}\n+\n+void\n+MTLVertexCache_AddGlyphQuad(MTLContext *mtlc,\n+                            jfloat tx1, jfloat ty1, jfloat tx2, jfloat ty2,\n+                            jfloat dx1, jfloat dy1, jfloat dx2, jfloat dy2)\n+{\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLVertexCache_AddGlyphQuad\");\n+\n+    if (vertexCacheIndex >= MTLVC_MAX_INDEX)\n+    {\n+        J2dTraceLn2(J2D_TRACE_INFO, \"maskCacheIndex = %d, vertexCacheIndex = %d\", maskCacheIndex, vertexCacheIndex);\n+        MTLVertexCache_FlushGlyphVertexCache();\n+    }\n+\n+    MTLVC_ADD_TRIANGLES(tx1, ty1, tx2, ty2,\n+                        dx1, dy1, dx2, dy2);\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLVertexCache.m","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef __RENDEROPTIONS_H\n+#define __RENDEROPTIONS_H\n+\n+#include <jni.h>\n+#include \"MTLSurfaceDataBase.h\"\n+\n+\/\/ Utility struct to transfer rendering paramenters\n+typedef struct {\n+    jboolean isTexture;\n+    jboolean isAA;\n+    int interpolation;\n+    SurfaceRasterFlags srcFlags;\n+    SurfaceRasterFlags dstFlags;\n+    jboolean isText;\n+    jboolean isLCD;\n+} RenderOptions;\n+\n+\n+#endif \/\/__RENDEROPTIONS_H\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/RenderOptions.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef COMMON_H\n+#define COMMON_H\n+\n+#include <simd\/simd.h>\n+\n+#define PGRAM_VERTEX_COUNT 6\n+#define QUAD_VERTEX_COUNT 4\n+#define GRAD_MAX_FRACTIONS 12\n+\n+enum GradCycleMethod {\n+    GradNoCycle = 0,\n+    GradReflect = 1,\n+    GradRepeat = 2\n+};\n+enum VertexAttributes {\n+    VertexAttributePosition = 0,\n+    VertexAttributeTexPos = 1,\n+    VertexAttributeITexPos = 2\n+};\n+\n+enum BufferIndex  {\n+    MeshVertexBuffer = 0,\n+    FrameUniformBuffer = 1,\n+    MatrixBuffer = 2\n+};\n+\n+struct FrameUniforms {\n+    vector_float4 color;\n+};\n+\n+struct TransformMatrix {\n+    matrix_float4x4 transformMatrix;\n+};\n+\n+struct GradFrameUniforms {\n+    vector_float3 params;\n+    vector_float4 color1;\n+    vector_float4 color2;\n+    int isCyclic;\n+    float extraAlpha;\n+};\n+\n+struct LinGradFrameUniforms {\n+    vector_float3 params;\n+    float fract[GRAD_MAX_FRACTIONS];\n+    vector_float4 color[GRAD_MAX_FRACTIONS];\n+    int numFracts;\n+    int isLinear;\n+    int cycleMethod;\n+    float extraAlpha;\n+};\n+\n+struct RadGradFrameUniforms {\n+    float fract[GRAD_MAX_FRACTIONS];\n+    vector_float4 color[GRAD_MAX_FRACTIONS];\n+    int numFracts;\n+    int isLinear;\n+    int cycleMethod;\n+    vector_float3 m0;\n+    vector_float3 m1;\n+    vector_float3 precalc;\n+    float extraAlpha;\n+};\n+\n+struct Vertex {\n+    float position[2];\n+};\n+\n+struct TxtVertex {\n+    float position[2];\n+    float txtpos[2];\n+};\n+\n+struct AAVertex {\n+    float position[2];\n+    float otxtpos[2];\n+    float itxtpos[2];\n+};\n+\n+\/\/ These values are mapped from AffineTransformOp\n+#define INTERPOLATION_NEAREST_NEIGHBOR 1\n+#define INTERPOLATION_BILINEAR 2\n+\/\/ #define INTERPOLATION_BICUBIC 3\n+\/\/ NOTE: Metal samplers doesn't supports bicubic interpolation\n+\/\/ see table 2.7 from https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf\n+\/\/ (probably we need to implement separate fragment shader with bicubic interpolation)\n+\n+struct TxtFrameUniforms {\n+    vector_float4 color;\n+    int mode; \/\/ NOTE: consider to use bit fields\n+    int isSrcOpaque;\n+    int isDstOpaque;\n+    float extraAlpha;\n+};\n+\n+struct TxtFrameOpRescaleUniforms {\n+    vector_float4 color;\n+    float extraAlpha;\n+\n+    int isSrcOpaque;\n+    int isNonPremult;\n+\n+    vector_float4 normScaleFactors;\n+    vector_float4 normOffsets;\n+};\n+\n+struct TxtFrameOpConvolveUniforms {\n+    float extraAlpha;\n+    int isSrcOpaque;\n+    vector_float4 imgEdge;\n+    int kernelSize;\n+    int isEdgeZeroFill;\n+};\n+\n+struct TxtFrameOpLookupUniforms {\n+    float extraAlpha;\n+    int isSrcOpaque;\n+    vector_float4 offset;\n+    int isUseSrcAlpha;\n+    int isNonPremult;\n+};\n+\n+struct AnchorData\n+{\n+    vector_float3 xParams;\n+    vector_float3 yParams;\n+};\n+\n+struct LCDFrameUniforms {\n+    vector_float3 src_adj;\n+    vector_float3 gamma;\n+    vector_float3 invgamma;\n+};\n+#endif\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/common.h","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,821 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <simd\/simd.h>\n+#include <metal_stdlib>\n+#include \"common.h\"\n+\n+using namespace metal;\n+\n+struct VertexInput {\n+    float2 position [[attribute(VertexAttributePosition)]];\n+};\n+\n+struct TxtVertexInput {\n+    float2 position [[attribute(VertexAttributePosition)]];\n+    float2 texCoords [[attribute(VertexAttributeTexPos)]];\n+};\n+\n+struct AAVertexInput {\n+    float2 position [[attribute(VertexAttributePosition)]];\n+    float2 oTexCoords [[attribute(VertexAttributeTexPos)]];\n+    float2 iTexCoords [[attribute(VertexAttributeITexPos)]];\n+};\n+\n+struct ColShaderInOut {\n+    float4 position [[position]];\n+    half4  color;\n+};\n+\n+struct AAShaderInOut {\n+    float4 position [[position]];\n+    float2 outerTexCoords;\n+    float2 innerTexCoords;\n+    half4  color;\n+};\n+\n+struct StencilShaderInOut {\n+    float4 position [[position]];\n+    char color;\n+};\n+\n+struct TxtShaderInOut {\n+    float4 position [[position]];\n+    float2 texCoords;\n+    float2 tpCoords;\n+};\n+\n+struct LCDShaderInOut {\n+    float4 position [[position]];\n+    float2 orig_pos;\n+    float2 texCoords;\n+};\n+\n+struct GradShaderInOut {\n+    float4 position [[position]];\n+    float2 texCoords;\n+};\n+\n+\n+struct ColShaderInOut_XOR {\n+    float4 position [[position]];\n+    float2 orig_pos;\n+    half4  color;\n+};\n+\n+struct TxtShaderInOut_XOR {\n+    float4 position [[position]];\n+    float2 orig_pos;\n+    float2 texCoords;\n+    float2 tpCoords;\n+};\n+\n+inline float fromLinear(float c)\n+{\n+    if (isnan(c)) c = 0.0;\n+    if (c > 1.0)\n+          c = 1.0;\n+    else if (c < 0.0)\n+          c = 0.0;\n+    else if (c < 0.0031308)\n+          c = 12.92 * c;\n+    else\n+    c = 1.055 * powr(c, 1.0\/2.4) - 0.055;\n+    return c;\n+}\n+\n+inline float3 fromLinear3(float3 c) {\n+    \/\/c.r = fromLinear(c.r);\n+    \/\/c.g = fromLinear(c.g);\n+    \/\/c.b = fromLinear(c.b);\n+    \/\/ Use approximated calculations to match software rendering\n+    c.rgb = 1.055 * pow(c.rgb, float3(0.416667)) - 0.055;\n+    return c;\n+}\n+\n+template <typename Uniforms> inline\n+float4 frag_single_grad(float a, Uniforms uniforms)\n+{\n+    int fa = floor(a);\n+    if (uniforms.isCyclic) {\n+        if (fa%2) {\n+            a = 1.0 + fa - a;\n+        } else {\n+            a = a - fa;\n+        }\n+    } else {\n+        a = saturate(a);\n+    }\n+    return mix(uniforms.color1, uniforms.color2, a);\n+}\n+\n+template <typename Uniforms> inline\n+float4 frag_multi_grad(float a, Uniforms uniforms)\n+{\n+      if (uniforms.cycleMethod > GradNoCycle) {\n+          int fa = floor(a);\n+          a = a - fa;\n+          if (uniforms.cycleMethod == GradReflect && fa%2) {\n+              a = 1.0 - a;\n+          }\n+      } else {\n+          a = saturate(a);\n+      }\n+\n+      int n = 0;\n+      for (;n < GRAD_MAX_FRACTIONS - 1; n++) {\n+          if (a <= uniforms.fract[n + 1]) break;\n+      }\n+\n+      a = (a - uniforms.fract[n]) \/ (uniforms.fract[n + 1] - uniforms.fract[n]);\n+\n+      float4 c = mix(uniforms.color[n], uniforms.color[n + 1], a);\n+      if (uniforms.isLinear) {\n+          c.rgb = fromLinear3(c.rgb);\n+      }\n+      return c;\n+}\n+\n+vertex ColShaderInOut vert_col(VertexInput in [[stage_in]],\n+       constant FrameUniforms& uniforms [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    ColShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.color = half4(uniforms.color.r, uniforms.color.g, uniforms.color.b, uniforms.color.a);\n+    return out;\n+}\n+\n+vertex AAShaderInOut vert_col_aa(AAVertexInput in [[stage_in]],\n+       constant FrameUniforms& uniforms [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    AAShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.color = half4(uniforms.color.r, uniforms.color.g, uniforms.color.b, uniforms.color.a);\n+    out.outerTexCoords = in.oTexCoords;\n+    out.innerTexCoords = in.iTexCoords;\n+    return out;\n+}\n+\n+vertex StencilShaderInOut vert_stencil(VertexInput in [[stage_in]],\n+       constant FrameUniforms& uniforms [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    StencilShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix * pos4;\n+    out.color = 0xFF;\n+    return out;\n+}\n+\n+vertex GradShaderInOut vert_grad(VertexInput in [[stage_in]], constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    GradShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    return out;\n+}\n+\n+vertex TxtShaderInOut vert_txt(TxtVertexInput in [[stage_in]], constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    TxtShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.texCoords = in.texCoords;\n+    return out;\n+}\n+\n+vertex LCDShaderInOut vert_txt_lcd(TxtVertexInput in [[stage_in]], constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    LCDShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.orig_pos = in.position;\n+    out.texCoords = in.texCoords;\n+    return out;\n+}\n+\n+vertex TxtShaderInOut vert_txt_tp(TxtVertexInput in [[stage_in]], constant AnchorData& anchorData [[buffer(FrameUniformBuffer)]], constant TransformMatrix& transform [[buffer(MatrixBuffer)]])\n+{\n+    TxtShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix * pos4;\n+\n+    \/\/ Compute texture coordinates here w.r.t. anchor rect of texture paint\n+    out.tpCoords.x = (anchorData.xParams[0] * in.position.x) +\n+                      (anchorData.xParams[1] * in.position.y) +\n+                      (anchorData.xParams[2] * out.position.w);\n+    out.tpCoords.y = (anchorData.yParams[0] * in.position.x) +\n+                      (anchorData.yParams[1] * in.position.y) +\n+                      (anchorData.yParams[2] * out.position.w);\n+    out.texCoords = in.texCoords;\n+\n+    return out;\n+}\n+\n+vertex GradShaderInOut vert_txt_grad(TxtVertexInput in [[stage_in]],\n+                                     constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    GradShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.texCoords = in.texCoords;\n+    return out;\n+}\n+\n+fragment half4 frag_col(ColShaderInOut in [[stage_in]]) {\n+    return in.color;\n+}\n+\n+fragment half4 frag_col_aa(AAShaderInOut in [[stage_in]]) {\n+    float2 oleg1 = dfdx(in.outerTexCoords);\n+    float2 oleg2 = dfdy(in.outerTexCoords);\n+    \/\/ Calculate the bounds of the distorted pixel parallelogram.\n+    float2 corner = in.outerTexCoords - (oleg1+oleg2)\/2.0;\n+    float2 omin = min(corner, corner+oleg1);\n+    omin = min(omin, corner+oleg2);\n+    omin = min(omin, corner+oleg1+oleg2);\n+    float2 omax = max(corner, corner+oleg1);\n+    omax = max(omax, corner+oleg2);\n+    omax = max(omax, corner+oleg1+oleg2);\n+    \/\/ Calculate the vectors for the \"legs\" of the pixel parallelogram\n+    \/\/ for the inner parallelogram.\n+    float2 ileg1 = dfdx(in.innerTexCoords);\n+    float2 ileg2 = dfdy(in.innerTexCoords);\n+    \/\/ Calculate the bounds of the distorted pixel parallelogram.\n+    corner = in.innerTexCoords - (ileg1+ileg2)\/2.0;\n+    float2 imin = min(corner, corner+ileg1);\n+    imin = min(imin, corner+ileg2);\n+    imin = min(imin, corner+ileg1+ileg2);\n+    float2 imax = max(corner, corner+ileg1);\n+    imax = max(imax, corner+ileg2);\n+    imax = max(imax, corner+ileg1+ileg2);\n+    \/\/ Clamp the bounds of the parallelograms to the unit square to\n+    \/\/ estimate the intersection of the pixel parallelogram with\n+    \/\/ the unit square.  The ratio of the 2 rectangle areas is a\n+    \/\/ reasonable estimate of the proportion of coverage.\n+    float2 o1 = clamp(omin, 0.0, 1.0);\n+    float2 o2 = clamp(omax, 0.0, 1.0);\n+    float oint = (o2.y-o1.y)*(o2.x-o1.x);\n+    float oarea = (omax.y-omin.y)*(omax.x-omin.x);\n+    float2 i1 = clamp(imin, 0.0, 1.0);\n+    float2 i2 = clamp(imax, 0.0, 1.0);\n+    float iint = (i2.y-i1.y)*(i2.x-i1.x);\n+    float iarea = (imax.y-imin.y)*(imax.x-imin.x);\n+    \/\/ Proportion of pixel in outer shape minus the proportion\n+    \/\/ of pixel in the inner shape == the coverage of the pixel\n+    \/\/ in the area between the two.\n+    float coverage = oint\/oarea - iint \/ iarea;\n+    return (in.color * coverage);\n+}\n+\n+fragment unsigned int frag_stencil(StencilShaderInOut in [[stage_in]]) {\n+    return in.color;\n+}\n+\n+\/\/ NOTE:\n+\/\/ 1. consider to make shaders without IF-conditions\n+\/\/ 2. we can pass interpolation mode via uniforms and select corresponding sampler in shader\n+\/\/  but it can cause performance problems (something like getTextureSampler(hint) will be invoked\n+\/\/  for every pixel)\n+\n+fragment half4 frag_txt(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    float srcA = uniforms.isSrcOpaque ? 1 : pixelColor.a;\n+    if (uniforms.mode) {\n+        float3 c = mix(pixelColor.rgb, uniforms.color.rgb, srcA);\n+        return half4(c.r, c.g, c.b ,\n+                     (uniforms.isSrcOpaque) ?\n+                      uniforms.color.a : pixelColor.a*uniforms.color.a);\n+    }\n+\n+    return half4(pixelColor.r,\n+                 pixelColor.g,\n+                 pixelColor.b, srcA)*uniforms.extraAlpha;\n+}\n+\n+fragment half4 frag_text(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    return half4(uniforms.color * pixelColor.a);\n+}\n+\n+fragment half4 frag_txt_tp(TxtShaderInOut vert [[stage_in]],\n+                       texture2d<float, access::sample> renderTexture [[texture(0)]],\n+                       texture2d<float, access::sample> paintTexture [[texture(1)]],\n+                       constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+                       sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 renderColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    float4 paintColor = paintTexture.sample(textureSampler, vert.tpCoords);\n+    const float srcA = uniforms.isSrcOpaque ? 1 : paintColor.a;\n+    return half4(paintColor.r*renderColor.a,\n+                 paintColor.g*renderColor.a,\n+                 paintColor.b*renderColor.a,\n+                 srcA*renderColor.a) * uniforms.extraAlpha;\n+}\n+\n+fragment half4 frag_txt_grad(GradShaderInOut in [[stage_in]],\n+                         constant GradFrameUniforms& uniforms [[buffer(0)]],\n+                         texture2d<float, access::sample> renderTexture [[texture(0)]])\n+{\n+    constexpr sampler textureSampler (address::repeat, mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    float4 renderColor = renderTexture.sample(textureSampler, in.texCoords);\n+\n+    float3 v = float3(in.position.x-0.5, in.position.y-0.5, 1);\n+    float  a = (dot(v,uniforms.params)-0.25)*2.0;\n+    return half4(frag_single_grad(a, uniforms)*renderColor.a)*uniforms.extraAlpha;\n+}\n+\n+fragment half4 frag_txt_lin_grad(GradShaderInOut in [[stage_in]],\n+                                 constant LinGradFrameUniforms& uniforms [[buffer(0)]],\n+                                 texture2d<float, access::sample> renderTexture [[texture(0)]])\n+{\n+    constexpr sampler textureSampler (address::repeat, mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    float4 renderColor = renderTexture.sample(textureSampler, in.texCoords);\n+    float3 v = float3(in.position.x, in.position.y, 1);\n+    float  a = dot(v,uniforms.params);\n+    return half4(frag_multi_grad(a, uniforms)*renderColor.a)*uniforms.extraAlpha;\n+}\n+\n+fragment half4 frag_txt_rad_grad(GradShaderInOut in [[stage_in]],\n+                                 constant RadGradFrameUniforms& uniforms [[buffer(0)]],\n+                                 texture2d<float, access::sample> renderTexture [[texture(0)]])\n+{\n+    constexpr sampler textureSampler (address::repeat, mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    float4 renderColor = renderTexture.sample(textureSampler, in.texCoords);\n+\n+    float3 fragCoord = float3(in.position.x-0.5, in.position.y-0.5, 1);\n+    float  x = dot(fragCoord, uniforms.m0);\n+    float  y = dot(fragCoord, uniforms.m1);\n+    float  xfx = x - uniforms.precalc.x;\n+    float  a = (uniforms.precalc.x*xfx + sqrt(xfx*xfx + y*y*uniforms.precalc.y))*uniforms.precalc.z;\n+    return half4(frag_multi_grad(a, uniforms)*renderColor.a)*uniforms.extraAlpha;\n+}\n+\n+\n+fragment half4 aa_frag_txt(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        texture2d<float, access::sample> stencilTexture [[texture(1)]],\n+        constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    if (!is_null_texture(stencilTexture)) {\n+        float4 stencil = stencilTexture.sample(textureSampler, vert.texCoords);\n+        if (stencil.r ==  0.0) {\n+            discard_fragment();\n+        }\n+    }\n+    return half4(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a);\n+}\n+\n+fragment half4 frag_txt_op_rescale(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> srcTex [[texture(0)]],\n+        constant TxtFrameOpRescaleUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);\n+    const float srcA = uniforms.isSrcOpaque ? 1 : srcColor.a;\n+\n+    \/\/ TODO: check uniforms.isNonPremult and pre-multiply if necessary\n+    return half4(srcColor.r*uniforms.normScaleFactors.r + uniforms.normOffsets.r,\n+                 srcColor.g*uniforms.normScaleFactors.g + uniforms.normOffsets.g,\n+                 srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA)*uniforms.extraAlpha;\n+\n+    \/\/ NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the\n+    \/\/ same here.\n+    \/\/\n+    \/\/ GL-shader impl:\n+    \/\/\"    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);\"\n+    \/\/\"    %s\"                                                      \/\/ (placeholder for un-premult code: srcColor.rgb \/= srcColor.a;)\n+    \/\/\"    vec4 result = (srcColor * scaleFactors) + offsets;\"      \/\/ rescale source value\n+    \/\/\"    %s\"                                                      \/\/ (placeholder for re-premult code: result.rgb *= result.a;)\n+    \/\/\"    gl_FragColor = result * gl_Color;\"                       \/\/ modulate with gl_Color in order to apply extra alpha\n+}\n+\n+fragment half4 frag_txt_op_convolve(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> srcTex [[texture(0)]],\n+        constant TxtFrameOpConvolveUniforms& uniforms [[buffer(1)]],\n+        const device float * kernelVals [[buffer(2)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 sum = float4(0, 0, 0, 0);\n+    if (vert.texCoords[0] < uniforms.imgEdge[0]\n+        || vert.texCoords[1] < uniforms.imgEdge[1]\n+        || vert.texCoords[0] > uniforms.imgEdge[2]\n+        || vert.texCoords[1] > uniforms.imgEdge[3]\n+    ) {\n+        if (!uniforms.isEdgeZeroFill) {\n+            sum = srcTex.sample(textureSampler, vert.texCoords);\n+        }\n+    }\n+\n+    for (int i = 0; i < uniforms.kernelSize; i++) {\n+        float3 kern = float3(kernelVals[i*3], kernelVals[i*3 + 1], kernelVals[i*3 + 2]);\n+        float2 pos = float2(vert.texCoords.x + kern.x, vert.texCoords.y + kern.y);\n+        float4 pixCol = srcTex.sample(textureSampler, pos);\n+        sum.r += kern.z * pixCol.r;\n+        sum.g += kern.z * pixCol.g;\n+        sum.b += kern.z * pixCol.b;\n+        sum.a += kern.z * pixCol.a;\n+    }\n+    const float srcA = uniforms.isSrcOpaque ? 1 : sum.a;\n+    return half4(sum.r, sum.g, sum.b, srcA)*uniforms.extraAlpha;\n+\n+    \/\/ NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the\n+    \/\/ same here.\n+    \/\/\n+    \/\/ GL-shader impl:\n+    \/\/\"    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||\"\n+    \/\/\"        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))\"\n+    \/\/\"    {\"\n+    \/\/\"        %s\"      \/\/ (placeholder for edge condition code)\n+    \/\/\"    } else {\"\n+    \/\/\"        sum = vec4(0.0);\"\n+    \/\/\"        for (i = 0; i < MAX_KERNEL_SIZE; i++) {\"\n+    \/\/\"            sum +=\"\n+    \/\/\"                kernelVals[i].z *\"\n+    \/\/\"                texture%s(baseImage,\"\n+    \/\/\"                          gl_TexCoord[0].st + kernelVals[i].xy);\"\n+    \/\/\"        }\"\n+    \/\/\"    }\"\n+    \/\/\"\"\n+    \/\/\"    gl_FragColor = sum * gl_Color;\" \/\/ modulate with gl_Color in order to apply extra alpha\n+}\n+\n+fragment half4 frag_txt_op_lookup(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> srcTex [[texture(0)]],\n+        texture2d<float, access::sample> lookupTex [[texture(1)]],\n+        constant TxtFrameOpLookupUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]]\n+) {\n+    float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);\n+    float4 srcIndex = srcColor - uniforms.offset;\n+    const float2 posR = float2(srcIndex.r, 0.125);\n+    const float2 posG = float2(srcIndex.g, 0.375);\n+    const float2 posB = float2(srcIndex.b, 0.625);\n+\n+    float4 lookupR = lookupTex.sample(textureSampler, posR);\n+    float4 lookupG = lookupTex.sample(textureSampler, posG);\n+    float4 lookupB = lookupTex.sample(textureSampler, posB);\n+    const float srcA = uniforms.isSrcOpaque ? 1 : srcColor.a;\n+    const float a = uniforms.isUseSrcAlpha ? srcA : lookupTex.sample(textureSampler, float2(srcIndex.a, 0.875)).a;\n+\n+    \/\/ TODO: check uniforms.isNonPremult and pre-multiply if necessary\n+    return half4(lookupR.a, lookupG.a, lookupB.a, a)*uniforms.extraAlpha;\n+\n+    \/\/ NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the\n+    \/\/ same here.\n+    \/\/\n+    \/\/ GL-shader impl:\n+    \/\/\"    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);\"\n+    \/\/\"    %s\"                                  \/\/ (placeholder for un-premult code)\n+    \/\/\"    vec4 srcIndex = srcColor - offset;\"  \/\/ subtract offset from original index\n+    \/\/\n+    \/\/      \/\/ use source value as input to lookup table (note that\n+    \/\/      \/\/ \"v\" texcoords are hardcoded to hit texel centers of\n+    \/\/      \/\/ each row\/band in texture)\n+    \/\/\"    vec4 result;\"\n+    \/\/\"    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;\"\n+    \/\/\"    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;\"\n+    \/\/\"    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;\"\n+    \/\/\"    %s\"                                  \/\/ (placeholder for alpha store code)\n+    \/\/\"    %s\"                                  \/\/ (placeholder for re-premult code)\n+    \/\/\"    gl_FragColor = result * gl_Color;\"   \/\/ modulate with gl_Color in order to apply extra alpha\n+}\n+\n+fragment half4 frag_grad(GradShaderInOut in [[stage_in]],\n+                         constant GradFrameUniforms& uniforms [[buffer(0)]]) {\n+    float3 v = float3(in.position.x-0.5, in.position.y-0.5, 1);\n+    float  a = (dot(v,uniforms.params)-0.25)*2.0;\n+    return half4(frag_single_grad(a, uniforms)) * uniforms.extraAlpha;\n+}\n+\n+\/\/ LinGradFrameUniforms\n+fragment half4 frag_lin_grad(GradShaderInOut in [[stage_in]],\n+                             constant LinGradFrameUniforms& uniforms [[buffer(0)]]) {\n+    float3 v = float3(in.position.x-0.5, in.position.y-0.5, 1);\n+    float  a = dot(v, uniforms.params);\n+    return half4(frag_multi_grad(a, uniforms))*uniforms.extraAlpha;\n+}\n+\n+fragment half4 frag_rad_grad(GradShaderInOut in [[stage_in]],\n+                             constant RadGradFrameUniforms& uniforms [[buffer(0)]]) {\n+    float3 fragCoord = float3(in.position.x-0.5, in.position.y-0.5, 1);\n+    float  x = dot(fragCoord, uniforms.m0);\n+    float  y = dot(fragCoord, uniforms.m1);\n+    float  xfx = x - uniforms.precalc.x;\n+    float  a = (uniforms.precalc.x*xfx + sqrt(xfx*xfx + y*y*uniforms.precalc.y))*uniforms.precalc.z;\n+    return half4(frag_multi_grad(a, uniforms))*uniforms.extraAlpha;\n+}\n+\n+vertex TxtShaderInOut vert_tp(VertexInput in [[stage_in]],\n+       constant AnchorData& anchorData [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]])\n+{\n+    TxtShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix * pos4;\n+\n+    \/\/ Compute texture coordinates here w.r.t. anchor rect of texture paint\n+    out.texCoords.x = (anchorData.xParams[0] * in.position.x) +\n+                      (anchorData.xParams[1] * in.position.y) +\n+                      (anchorData.xParams[2] * out.position.w);\n+    out.texCoords.y = (anchorData.yParams[0] * in.position.x) +\n+                      (anchorData.yParams[1] * in.position.y) +\n+                      (anchorData.yParams[2] * out.position.w);\n+\n+    return out;\n+}\n+\n+fragment half4 frag_tp(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]])\n+{\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    const float srcA = uniforms.isSrcOpaque ? 1 : pixelColor.a;\n+    return half4(pixelColor.r, pixelColor.g, pixelColor.b, srcA) * uniforms.extraAlpha;\n+}\n+\n+\n+\n+\/* The variables involved in the equation can be expressed as follows:\n+ *\n+ *   Cs = Color component of the source (foreground color) [0.0, 1.0]\n+ *   Cd = Color component of the destination (background color) [0.0, 1.0]\n+ *   Cr = Color component to be written to the destination [0.0, 1.0]\n+ *   Ag = Glyph alpha (aka intensity or coverage) [0.0, 1.0]\n+ *   Ga = Gamma adjustment in the range [1.0, 2.5]\n+ *   (^ means raised to the power)\n+ *\n+ * And here is the theoretical equation approximated by this shader:\n+ *\n+ *            Cr = (Ag*(Cs^Ga) + (1-Ag)*(Cd^Ga)) ^ (1\/Ga)\n+ *\/\n+fragment float4 lcd_color(\n+        LCDShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> glyphTexture [[texture(0)]],\n+        texture2d<float, access::sample> dstTexture [[texture(1)]],\n+        constant LCDFrameUniforms& uniforms [[buffer(1)]])\n+{\n+    float3 src_adj = uniforms.src_adj;\n+    float3 gamma = uniforms.gamma;\n+    float3 invgamma = uniforms.invgamma;\n+\n+    constexpr sampler glyphTextureSampler (address::repeat,\n+                                      mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    \/\/ load the RGB value from the glyph image at the current texcoord\n+    float3 glyph_clr = float3(glyphTexture.sample(glyphTextureSampler, vert.texCoords));\n+\n+    if (glyph_clr.r == 0.0f && glyph_clr.g == 0.0f && glyph_clr.b == 0.0f) {\n+        \/\/ zero coverage, so skip this fragment\n+        discard_fragment();\n+    }\n+\n+    \/\/ load the RGB value from the corresponding destination pixel\n+    uint2 texCoord = {(unsigned int)(vert.orig_pos.x), (unsigned int)(vert.orig_pos.y)};\n+    float4 dst_clr = dstTexture.read(texCoord);\n+\n+    \/\/ gamma adjust the dest color\n+    float3 dst_adj = pow(dst_clr.rgb, gamma);\n+\n+    \/\/ linearly interpolate the three color values\n+    float3 result = mix(dst_adj, src_adj, glyph_clr);\n+\n+    \/\/ gamma re-adjust the resulting color (alpha is always set to 1.0)\n+    return float4(pow(result.rgb, invgamma), 1.0);\n+\n+}\n+\/\/ Compute shader to transfer clipping data to the texture used for manual clipping in\n+\/\/ aa_frag_txt shader\n+kernel void stencil2tex(const device uchar *imageBuffer [[buffer(0)]],\n+    device uchar4 *outputBuffer [[buffer(1)]],\n+    uint gid [[thread_position_in_grid]])\n+{\n+    uchar p = imageBuffer[gid];\n+    outputBuffer[gid] = uchar4(p, p, p, p);\n+}\n+\n+\/\/ work item deals with 4 byte pixel\n+\/\/ assuming that data is aligned\n+kernel void rgb_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                        device uchar *outputBuffer [[buffer(1)]],\n+                        uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid];     \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 1]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid + 2]; \/\/ b\n+    outputBuffer[4 * gid + 3] = 255;                      \/\/ a\n+}\n+\n+kernel void bgr_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                        device uchar *outputBuffer [[buffer(1)]],\n+                        uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 2]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 1]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid];     \/\/ b\n+    outputBuffer[4 * gid + 3] = 255;                      \/\/ a\n+}\n+\n+kernel void xrgb_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                         device uchar *outputBuffer [[buffer(1)]],\n+                         uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 1]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 2]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid + 3]; \/\/ b\n+    outputBuffer[4 * gid + 3] = imageBuffer[4 * gid];     \/\/ a\n+}\n+\n+\n+kernel void xbgr_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                         device uchar *outputBuffer [[buffer(1)]],\n+                         uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 3]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 2]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid + 1]; \/\/ b\n+    outputBuffer[4 * gid + 3] = imageBuffer[4 * gid];     \/\/ a\n+}\n+\n+\/\/ ----------------------------------------------------------------------------\n+\/\/ Shaders for rendering in XOR Mode\n+\/\/ ----------------------------------------------------------------------------\n+vertex ColShaderInOut_XOR vert_col_xorMode(VertexInput in [[stage_in]],\n+       constant FrameUniforms& uniforms [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]])\n+{\n+    ColShaderInOut_XOR out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.orig_pos = in.position;\n+    out.color = half4(uniforms.color.r, uniforms.color.g, uniforms.color.b, uniforms.color.a);\n+    return out;\n+}\n+\n+fragment half4 frag_col_xorMode(ColShaderInOut_XOR in [[stage_in]],\n+        texture2d<float, access::read> renderTexture [[texture(0)]])\n+{\n+    uint2 texCoord = {(unsigned int)(in.orig_pos.x), (unsigned int)(in.orig_pos.y)};\n+\n+    float4 pixelColor = renderTexture.read(texCoord);\n+    half4 color = in.color;\n+\n+    half4 c;\n+    c.r = float( (unsigned char)(pixelColor.r * 255.0) ^ (unsigned char)(color.r * 255.0)) \/ 255.0f;\n+    c.g = float( (unsigned char)(pixelColor.g * 255.0) ^ (unsigned char)(color.g * 255.0)) \/ 255.0f;\n+    c.b = float( (unsigned char)(pixelColor.b * 255.0) ^ (unsigned char)(color.b * 255.0)) \/ 255.0f;\n+    c.a = 1.0;\n+\n+    return c;\n+}\n+\n+\n+vertex TxtShaderInOut_XOR vert_txt_xorMode(\n+        TxtVertexInput in [[stage_in]],\n+        constant TransformMatrix& transform [[buffer(MatrixBuffer)]])\n+{\n+    TxtShaderInOut_XOR out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.orig_pos = in.position;\n+    out.texCoords = in.texCoords;\n+    return out;\n+}\n+\n+fragment half4 frag_txt_xorMode(\n+        TxtShaderInOut_XOR vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        texture2d<float, access::read> backgroundTexture [[texture(1)]],\n+        constant TxtFrameUniforms& uniforms [[buffer(1)]],\n+        sampler textureSampler [[sampler(0)]])\n+{\n+    uint2 texCoord = {(unsigned int)(vert.orig_pos.x), (unsigned int)(vert.orig_pos.y)};\n+    float4 bgColor = backgroundTexture.read(texCoord);\n+\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+    float srcA = uniforms.isSrcOpaque ? 1 : pixelColor.a;\n+\n+    float4 c;\n+    if (uniforms.mode) {\n+        c = mix(pixelColor, uniforms.color, srcA);\n+    } else {\n+        c = float4(pixelColor.r,\n+                 pixelColor.g,\n+                 pixelColor.b, srcA)*uniforms.extraAlpha;\n+    }\n+\n+    half4 ret;\n+    ret.r = half( (unsigned char)(c.r * 255.0) ^ (unsigned char)(bgColor.r * 255.0)) \/ 255.0f;\n+    ret.g = half( (unsigned char)(c.g * 255.0) ^ (unsigned char)(bgColor.g * 255.0)) \/ 255.0f;\n+    ret.b = half( (unsigned char)(c.b * 255.0) ^ (unsigned char)(bgColor.b * 255.0)) \/ 255.0f;\n+    ret.a = c.a + (1.0 - c.a) * bgColor.a;\n+\n+    return ret;\n+}\n+\n+\n+\/*\n+    \/\/ --------------------------------------------------------------------------------------\n+    Currently, gradient paint and texture paint XOR mode rendering has been implemented\n+    through tile based rendering (similar to OGL) that uses MTLBlitLoops_SurfaceToSwBlit method for\n+    getting framebuffer tiles and render using a different render pipe (not MTLRenderer)\n+\n+    In metal, we can avoid tile based rendering and use below shaders.\n+    NOTE: These two shaders are incomplete and need some tweak.\n+    \/\/ --------------------------------------------------------------------------------------\n+\n+fragment half4 frag_grad_xorMode(GradShaderInOut_XOR in [[stage_in]],\n+                         texture2d<float, access::read> renderTexture [[texture(0)]],\n+                         constant GradFrameUniforms& uniforms [[buffer(0)]]) {\n+    uint2 texCoord = {(unsigned int)(in.orig_pos.x), (unsigned int)(in.orig_pos.y)};\n+    float4 pixelColor = renderTexture.read(texCoord);\n+\n+    float3 v = float3(in.position.x, in.position.y, 1);\n+    float  a = (dot(v,uniforms.params)-0.25)*2.0;\n+    float4 c = mix(uniforms.color1, uniforms.color2, a);\n+\n+    half4 ret;\n+    ret.r = float( (unsigned char)(pixelColor.r * 255.0) ^ (unsigned char)(c.r * 255.0)) \/ 255.0f;\n+    ret.g = float( (unsigned char)(pixelColor.g * 255.0) ^ (unsigned char)(c.g * 255.0)) \/ 255.0f;\n+    ret.b = float( (unsigned char)(pixelColor.b * 255.0) ^ (unsigned char)(c.b * 255.0)) \/ 255.0f;\n+\n+    return half4(ret);\n+}\n+\n+\n+fragment half4 frag_tp_xorMode(\n+        TxtShaderInOut vert [[stage_in]],\n+        texture2d<float, access::sample> renderTexture [[texture(0)]],\n+        texture2d<float, access::read> backgroundTexture [[texture(1)]],\n+        constant int& xorColor[[buffer(0)]])\n+{\n+    uint2 texCoord = {(unsigned int)(vert.orig_pos.x), (unsigned int)(vert.orig_pos.y)};\n+    float4 bgColor = backgroundTexture.read(texCoord);\n+\n+    constexpr sampler textureSampler (address::repeat,\n+                                      mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);\n+\n+    pixelColor.r = float( (unsigned char)(pixelColor.r * 255.0) ^ ((xorColor >> 16) & 0xFF) ) \/ 255.0f;\n+    pixelColor.g = float( (unsigned char)(pixelColor.g * 255.0) ^ ((xorColor >> 8) & 0xFF)) \/ 255.0f;\n+    pixelColor.b = float( (unsigned char)(pixelColor.b * 255.0) ^ (xorColor & 0xFF)) \/ 255.0f;\n+    pixelColor.a = 1.0;\n+\n+    half4 ret;\n+    ret.r = half( (unsigned char)(pixelColor.r * 255.0) ^ (unsigned char)(bgColor.r * 255.0)) \/ 255.0f;\n+    ret.g = half( (unsigned char)(pixelColor.g * 255.0) ^ (unsigned char)(bgColor.g * 255.0)) \/ 255.0f;\n+    ret.b = half( (unsigned char)(pixelColor.b * 255.0) ^ (unsigned char)(bgColor.b * 255.0)) \/ 255.0f;\n+    ret.a = 1.0;\n+\n+    return ret;\n+\n+    \/\/ This implementation defaults alpha to 1.0 as if source is opaque\n+    \/\/TODO : implement alpha component value if source is transparent\n+}\n+*\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal","additions":821,"deletions":0,"binary":false,"changes":821,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+#\n+# Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+\n+SOURCEPATH=src\n+CLASSES=build\n+DIST=dist\n+RESOURCES=resources\n+\n+RENDERPERF_CLASSES = $(CLASSES)\/renderperf\/RenderPerfTest.class\n+RENDERPERFLCD_CLASSES = $(CLASSES)\/renderperf\/RenderPerfLCDTest.class\n+RENDERPERF_SOURCES = $(SOURCEPATH)\/renderperf\/RenderPerfTest.java\n+RENDERPERFLCD_SOURCES = $(SOURCEPATH)\/renderperf\/RenderPerfLCDTest.java\n+\n+RENDERPERF_RESOURCES = $(CLASSES)\/renderperf\/images\/duke.png\n+\n+all: mkdirs $(DIST)\/RenderPerfTest.jar $(DIST)\/RenderPerfLCDTest.jar\n+\n+run: mkdirs $(DIST)\/RenderPerfTest.jar\n+\tjava -jar $(DIST)\/RenderPerfTest.jar\n+\n+$(DIST)\/RenderPerfTest.jar: \\\n+\t$(RENDERPERF_CLASSES) $(RENDERPERF_RESOURCES) \\\n+\t$(CLASSES)\/renderperf.manifest\n+\tjar cvmf $(CLASSES)\/renderperf.manifest $(DIST)\/RenderPerfTest.jar -C $(CLASSES) .\n+\n+$(DIST)\/RenderPerfLCDTest.jar: \\\n+\t$(RENDERPERFLCD_CLASSES) $(RENDERPERFLCD_RESOURCES) \\\n+\t$(CLASSES)\/renderperflcd.manifest\n+\tjar cvmf $(CLASSES)\/renderperflcd.manifest $(DIST)\/RenderPerfLCDTest.jar -C $(CLASSES) .\n+\n+$(CLASSES)\/renderperf\/images\/%: $(RESOURCES)\/renderperf\/images\/%\n+\tcp -r $< $@\n+\n+\n+$(CLASSES)\/renderperf.manifest:\n+\techo \"Main-Class: renderperf.RenderPerfTest\" > $@\n+\n+$(CLASSES)\/renderperflcd.manifest:\n+\techo \"Main-Class: renderperf.RenderPerfLCDTest\" > $@\n+\n+$(DIST):\n+\tmkdir  $(DIST)\n+\n+$(CLASSES):\n+\tmkdir $(CLASSES)\n+\tmkdir -p $(CLASSES)\/renderperf\/images\n+\n+mkdirs: $(DIST) $(CLASSES)\n+\n+$(RENDERPERF_CLASSES): $(RENDERPERF_SOURCES)\n+\tjavac -g:none -d $(CLASSES) -sourcepath $(SOURCEPATH) $<\n+\n+$(RENDERPERFLCD_CLASSES): $(RENDERPERFLCD_SOURCES)\n+\tjavac -g:none -d $(CLASSES) -sourcepath $(SOURCEPATH) $<\n+\n+clean:\n+\trm -rf $(CLASSES)\n+\trm -rf $(DIST)\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/Makefile","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+-----------------------------------------------------------------------\n+Introduction\n+-----------------------------------------------------------------------\n+\n+RenderPerfTest is a set of on-screen rendering microbenchmarks  to\n+analyze the  performance of Java2D graphical primitives rendering\n+\n+-----------------------------------------------------------------------\n+How To Compile\n+-----------------------------------------------------------------------\n+\n+#> cd RenderPerfTest\n+\n+The benchmark can be compiled by using either ant:\n+\n+#> ant\n+\n+or gnumake (assuming there's 'javac' in the path):\n+\n+#> gnumake\n+\n+The jar files will be generated into RenderPerfTest\/dist directory.\n+\n+-----------------------------------------------------------------------\n+How To Run RenderPerfTest\n+-----------------------------------------------------------------------\n+Run all tests\n+#> ant run\n+  or\n+#> java -jar dist\/RenderPerfTest.jar\n+\n+Run particular test cases\n+\n+#> java -jar dist\/RenderPerfTest.jar WhiteTextGray ...\n\\ No newline at end of file\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/README","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+<!--\n+ Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+\n+<project name=\"RenderPerfTest\" default=\"dist\" basedir=\".\">\n+    <description>\n+        simple example build file\n+    <\/description>\n+  <!-- set global properties for this build -->\n+  <property name=\"src\" location=\"src\"\/>\n+  <property name=\"build\" location=\"build\"\/>\n+  <property name=\"dist\"  location=\"dist\"\/>\n+  <property name=\"resources\"  location=\"resources\"\/>\n+\n+  <target name=\"init\">\n+    <!-- Create the time stamp -->\n+    <tstamp\/>\n+    <!-- Create the build directory structure used by compile -->\n+    <mkdir dir=\"${build}\"\/>\n+  <\/target>\n+\n+  <target name=\"compile\" depends=\"init\"\n+        description=\"compile the source \" >\n+    <!-- Compile the java code from ${src} into ${build} -->\n+    <javac includeantruntime=\"false\" debug=\"off\" srcdir=\"${src}\" destdir=\"${build}\"\/>\n+  <\/target>\n+\n+  <target name=\"run\" depends=\"dist\"\n+    description=\"run RenderPerfTest\" >\n+    <java jar=\"${dist}\/RenderPerfTest.jar\"\n+       fork=\"true\"\n+    >\n+    <\/java>\n+  <\/target>\n+\n+  <target name=\"resources\" depends=\"init\"\n+        description=\"copy resources into build dir\" >\n+    <!-- Copy the resource files from ${resources} into ${build}\/ -->\n+    <mkdir dir=\"${dist}\"\/>\n+    <mkdir dir=\"${dist}\/renderperf\"\/>\n+    <mkdir dir=\"${build}\/renderperf\/images\"\/>\n+    <copy todir=\"${build}\/renderperf\/images\">\n+      <fileset dir=\"resources\/renderperf\/images\" \/>\n+    <\/copy>\n+  <\/target>\n+\n+  <target name=\"dist\" depends=\"compile, resources\"\n+        description=\"generate the distribution\" >\n+    <!-- Create the distribution directory -->\n+    <mkdir dir=\"${dist}\"\/>\n+\n+    <!-- Put everything in ${build} into the J2DBench.jar file -->\n+    <jar jarfile=\"${dist}\/RenderPerfTest.jar\" basedir=\"${build}\">\n+      <manifest>\n+        <attribute name=\"Built-By\" value=\"${user.name}\"\/>\n+\t<attribute name=\"Main-Class\" value=\"renderperf.RenderPerfTest\"\/>\n+      <\/manifest>\n+    <\/jar>\n+  <\/target>\n+\n+  <target name=\"clean\"\n+        description=\"clean up\" >\n+    <!-- Delete the ${build} and ${dist} directory trees -->\n+    <delete dir=\"${build}\"\/>\n+    <delete dir=\"${dist}\"\/>\n+  <\/target>\n+<\/project>\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/build.xml","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/resources\/renderperf\/images\/duke.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/J2Ddemo\/images\/duke.png","status":"copied"},{"patch":"@@ -0,0 +1,373 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package renderperf;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.QuadCurve2D;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+\n+public class RenderPerfLCDTest {\n+    private static HashSet<String> ignoredTests = new HashSet<>();\n+\n+    private final static int N = 1000;\n+    private final static float WIDTH = 800;\n+    private final static float HEIGHT = 800;\n+    private final static float R = 25;\n+    private final static int BW = 50;\n+    private final static int BH = 50;\n+    private final static int COUNT = 300;\n+    private final static int DELAY = 10;\n+    private final static int RESOLUTION = 5;\n+    private final static int COLOR_TOLERANCE = 10;\n+    private final static int MAX_MEASURE_TIME = 5000;\n+\n+\n+    interface Configurable {\n+        void configure(Graphics2D g2d);\n+    }\n+\n+    interface Renderable {\n+        void setup(Graphics2D g2d);\n+        void render(Graphics2D g2d);\n+        void update();\n+    }\n+\n+    static class Particles {\n+        private float[] bx;\n+        private float[] by;\n+        private float[] vx;\n+        private float[] vy;\n+        private float r;\n+        private int n;\n+\n+        private float x0;\n+        private float y0;\n+        private float width;\n+        private float height;\n+\n+        Particles(int n, float r, float x0, float y0, float width, float height) {\n+            bx = new float[n];\n+            by = new float[n];\n+            vx = new float[n];\n+            vy = new float[n];\n+            this.n = n;\n+            this.r = r;\n+            this.x0 = x0;\n+            this.y0 = y0;\n+            this.width = width;\n+            this.height = height;\n+            for (int i = 0; i < n; i++) {\n+                bx[i] = (float) (x0 + r + 0.1 + Math.random() * (width - 2 * r - 0.2 - x0));\n+                by[i] = (float) (y0 + r + 0.1 + Math.random() * (height - 2 * r - 0.2 - y0));\n+                vx[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n+                vy[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n+            }\n+\n+        }\n+\n+        void render(Graphics2D g2d, ParticleRenderer renderer) {\n+            for (int i = 0; i < n; i++) {\n+                renderer.render(g2d, i, bx, by, vx, vy);\n+            }\n+        }\n+\n+        void update() {\n+            for (int i = 0; i < n; i++) {\n+                bx[i] += vx[i];\n+                if (bx[i] + r > width || bx[i] - r < x0) vx[i] = -vx[i];\n+                by[i] += vy[i];\n+                if (by[i] + r > height || by[i] - r < y0) vy[i] = -vy[i];\n+            }\n+\n+        }\n+\n+    }\n+\n+    ParticleRenderable createPR(ParticleRenderer renderer) {\n+        return new ParticleRenderable(renderer);\n+    }\n+\n+    static class ParticleRenderable implements Renderable {\n+        ParticleRenderer renderer;\n+        Configurable configure;\n+\n+        ParticleRenderable(ParticleRenderer renderer, Configurable configure) {\n+            this.renderer = renderer;\n+            this.configure = configure;\n+        }\n+\n+        ParticleRenderable(ParticleRenderer renderer) {\n+            this(renderer, null);\n+        }\n+\n+        @Override\n+        public void setup(Graphics2D g2d) {\n+            if (configure != null) configure.configure(g2d);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d) {\n+            balls.render(g2d, renderer);\n+        }\n+\n+        @Override\n+        public void update() {\n+            balls.update();\n+        }\n+\n+        public ParticleRenderable configure(Configurable configure) {\n+            this.configure = configure;\n+            return this;\n+        }\n+    }\n+\n+    interface ParticleRenderer {\n+        void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy);\n+\n+    }\n+\n+    static class WhiteTextParticleRenderer implements ParticleRenderer {\n+        float r;\n+\n+        WhiteTextParticleRenderer(float r) {\n+            this.r = r;\n+        }\n+\n+        void setPaint(Graphics2D g2d, int id) {\n+            g2d.setColor(Color.WHITE);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            setPaint(g2d, id);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] - r));\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)y[id]);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] + r));\n+        }\n+    }\n+\n+    static class TextParticleRenderer extends WhiteTextParticleRenderer {\n+        Color[] colors;\n+\n+        float r;\n+\n+        TextParticleRenderer(int n, float r) {\n+            super(r);\n+            colors = new Color[n];\n+            this.r = r;\n+            for (int i = 0; i < n; i++) {\n+                colors[i] = new Color((float) Math.random(),\n+                        (float) Math.random(), (float) Math.random());\n+            }\n+        }\n+\n+        void setPaint(Graphics2D g2d, int id) {\n+            g2d.setColor(colors[id % colors.length]);\n+        }\n+    }\n+\n+    static class PerfMeter {\n+        private String name;\n+        private int frame = 0;\n+\n+        private JPanel panel;\n+\n+        private long time;\n+        private double execTime = 0;\n+        private Color expColor = Color.RED;\n+        AtomicBoolean waiting = new AtomicBoolean(false);\n+        private double fps;\n+\n+        PerfMeter(String name) {\n+            this.name = name;\n+        }\n+\n+        PerfMeter exec(final Renderable renderable) throws Exception {\n+            final CountDownLatch latch = new CountDownLatch(COUNT);\n+            final CountDownLatch latchFrame = new CountDownLatch(1);\n+            final long endTime = System.currentTimeMillis() + MAX_MEASURE_TIME;\n+\n+            final Frame f = new Frame();\n+            f.addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosed(WindowEvent e) {\n+                    latchFrame.countDown();\n+                }\n+            });\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+\n+                    panel = new JPanel()\n+                    {\n+                        @Override\n+                        protected void paintComponent(Graphics g) {\n+\n+                            super.paintComponent(g);\n+                            time = System.nanoTime();\n+                            Graphics2D g2d = (Graphics2D) g.create();\n+                            renderable.setup(g2d);\n+                            renderable.render(g2d);\n+                            g2d.setColor(expColor);\n+                            g.fillRect(0, 0, BW, BH);\n+                        }\n+                    };\n+\n+                    panel.setPreferredSize(new Dimension((int)(WIDTH + BW), (int)(HEIGHT + BH)));\n+                    panel.setBackground(Color.BLACK);\n+                    f.add(panel);\n+                    \/\/f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+                    f.pack();\n+                    f.setVisible(true);\n+                }\n+            });\n+            Robot robot = new Robot();\n+\n+            Timer timer = new Timer(DELAY, e -> {\n+\n+                if (waiting.compareAndSet(false, true)) {\n+                    Color c = robot.getPixelColor(\n+                            panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW \/ 2,\n+                            panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BW \/ 2);\n+                    if (isAlmostEqual(c, Color.BLUE)) {\n+                        expColor = Color.RED;\n+                    } else {\n+                        expColor = Color.BLUE;\n+                    }\n+                    renderable.update();\n+                    panel.getParent().repaint();\n+\n+                } else {\n+                    while (!isAlmostEqual(\n+                            robot.getPixelColor(\n+                                    panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW\/2,\n+                                    panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BH\/2),\n+                            expColor))\n+                    {\n+                        try {\n+                            Thread.sleep(RESOLUTION);\n+                        } catch (InterruptedException ex) {\n+                            ex.printStackTrace();\n+                        }\n+                    }\n+                    time = System.nanoTime() - time;\n+                    execTime += time;\n+                    frame++;\n+                    waiting.set(false);\n+                }\n+\n+                if (System.currentTimeMillis() < endTime) {\n+                    latch.countDown();\n+                } else {\n+                    while(latch.getCount() > 0) latch.countDown();\n+                }\n+            });\n+            timer.start();\n+            latch.await();\n+            SwingUtilities.invokeAndWait(() -> {\n+                timer.stop();\n+                f.setVisible(false);\n+                f.dispose();\n+            });\n+\n+            latchFrame.await();\n+            if (execTime != 0 && frame != 0) {\n+                fps = 1e9 \/ (execTime \/ frame);\n+            } else {\n+                fps = 0;\n+            }\n+\n+            return this;\n+        }\n+\n+        private void report() {\n+            System.err.println(name + \" : \" + String.format(\"%.2f FPS\", fps));\n+        }\n+\n+        private boolean isAlmostEqual(Color c1, Color c2) {\n+            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE ||\n+                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE ||\n+                    Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n+\n+        }\n+    }\n+\n+    private static final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n+    private static final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n+\n+    private static final Configurable TextLCD = (Graphics2D g2d) ->\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+\n+    public void testTextBubblesLCD() throws Exception {\n+        (new PerfMeter(\"TextLCD\")).exec(createPR(textRenderer).configure(TextLCD)).report();\n+    }\n+\n+    public static void main(String[] args)\n+            throws InvocationTargetException, IllegalAccessException, NoSuchMethodException\n+    {\n+        RenderPerfLCDTest test = new RenderPerfLCDTest();\n+\n+        if (args.length > 0) {\n+            for (String testCase : args) {\n+                Method m = RenderPerfLCDTest.class.getDeclaredMethod(testCase);\n+                m.invoke(test);\n+            }\n+        } else {\n+            Method[] methods = RenderPerfLCDTest.class.getDeclaredMethods();\n+            for (Method m : methods) {\n+                if (m.getName().startsWith(\"test\") && !ignoredTests.contains(m.getName())) {\n+                    m.invoke(test);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfLCDTest.java","additions":373,"deletions":0,"binary":false,"changes":373,"status":"added"},{"patch":"@@ -0,0 +1,986 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package renderperf;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.LinearGradientPaint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.QuadCurve2D;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.DataBufferShort;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+import javax.swing.WindowConstants;\n+\n+public class RenderPerfTest {\n+    private static HashSet<String> ignoredTests = new HashSet<>();\n+\n+    static {\n+        ignoredTests.add(\"testWiredBoxAA\");\n+    }\n+\n+    private final static int N = 1000;\n+    private final static float WIDTH = 800;\n+    private final static float HEIGHT = 800;\n+    private final static float R = 25;\n+    private final static int BW = 50;\n+    private final static int BH = 50;\n+    private final static int COUNT = 300;\n+    private final static int DELAY = 10;\n+    private final static int RESOLUTION = 5;\n+    private final static int COLOR_TOLERANCE = 10;\n+    private final static int MAX_MEASURE_TIME = 5000;\n+\n+\n+    interface Configurable {\n+        void configure(Graphics2D g2d);\n+    }\n+\n+    interface Renderable {\n+        void setup(Graphics2D g2d);\n+        void render(Graphics2D g2d);\n+        void update();\n+    }\n+\n+    static class Particles {\n+        private float[] bx;\n+        private float[] by;\n+        private float[] vx;\n+        private float[] vy;\n+        private float r;\n+        private int n;\n+\n+        private float x0;\n+        private float y0;\n+        private float width;\n+        private float height;\n+\n+        Particles(int n, float r, float x0, float y0, float width, float height) {\n+            bx = new float[n];\n+            by = new float[n];\n+            vx = new float[n];\n+            vy = new float[n];\n+            this.n = n;\n+            this.r = r;\n+            this.x0 = x0;\n+            this.y0 = y0;\n+            this.width = width;\n+            this.height = height;\n+            for (int i = 0; i < n; i++) {\n+                bx[i] = (float) (x0 + r + 0.1 + Math.random() * (width - 2 * r - 0.2 - x0));\n+                by[i] = (float) (y0 + r + 0.1 + Math.random() * (height - 2 * r - 0.2 - y0));\n+                vx[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n+                vy[i] = 0.1f * (float) (Math.random() * 2 * r - r);\n+            }\n+\n+        }\n+\n+        void render(Graphics2D g2d, ParticleRenderer renderer) {\n+            for (int i = 0; i < n; i++) {\n+                renderer.render(g2d, i, bx, by, vx, vy);\n+            }\n+        }\n+\n+        void update() {\n+            for (int i = 0; i < n; i++) {\n+                bx[i] += vx[i];\n+                if (bx[i] + r > width || bx[i] - r < x0) vx[i] = -vx[i];\n+                by[i] += vy[i];\n+                if (by[i] + r > height || by[i] - r < y0) vy[i] = -vy[i];\n+            }\n+\n+        }\n+\n+    }\n+\n+    ParticleRenderable createPR(ParticleRenderer renderer) {\n+        return new ParticleRenderable(renderer);\n+    }\n+\n+    static class ParticleRenderable implements Renderable {\n+        ParticleRenderer renderer;\n+        Configurable configure;\n+\n+        ParticleRenderable(ParticleRenderer renderer, Configurable configure) {\n+            this.renderer = renderer;\n+            this.configure = configure;\n+        }\n+\n+        ParticleRenderable(ParticleRenderer renderer) {\n+            this(renderer, null);\n+        }\n+\n+        @Override\n+        public void setup(Graphics2D g2d) {\n+            if (configure != null) configure.configure(g2d);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d) {\n+            balls.render(g2d, renderer);\n+        }\n+\n+        @Override\n+        public void update() {\n+            balls.update();\n+        }\n+\n+        public ParticleRenderable configure(Configurable configure) {\n+            this.configure = configure;\n+            return this;\n+        }\n+    }\n+\n+    interface ParticleRenderer {\n+        void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy);\n+\n+    }\n+\n+    static class FlatParticleRenderer implements ParticleRenderer {\n+        Color[] colors;\n+        float r;\n+\n+        FlatParticleRenderer(int n, float r) {\n+            colors = new Color[n];\n+            this.r = r;\n+            for (int i = 0; i < n; i++) {\n+                colors[i] = new Color((float) Math.random(),\n+                        (float) Math.random(), (float) Math.random());\n+            }\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.fillOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+        }\n+\n+    }\n+\n+    static class ClipFlatParticleRenderer extends FlatParticleRenderer {\n+\n+        ClipFlatParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            if ((id % 10) == 0) {\n+                g2d.setColor(colors[id % colors.length]);\n+                g2d.setClip(new Ellipse2D.Double((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r)));\n+                g2d.fillRect((int) (x[id] - 2 * r), (int) (y[id] - 2 * r), (int) (4 * r), (int) (4 * r));\n+            }\n+        }\n+\n+    }\n+    static class WhiteTextParticleRenderer implements ParticleRenderer {\n+        float r;\n+\n+        WhiteTextParticleRenderer(float r) {\n+            this.r = r;\n+        }\n+\n+        void setPaint(Graphics2D g2d, int id) {\n+            g2d.setColor(Color.WHITE);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            setPaint(g2d, id);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] - r));\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)y[id]);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] + r));\n+        }\n+    }\n+\n+    static class TextParticleRenderer extends WhiteTextParticleRenderer {\n+        Color[] colors;\n+\n+        float r;\n+\n+        TextParticleRenderer(int n, float r) {\n+            super(r);\n+            colors = new Color[n];\n+            this.r = r;\n+            for (int i = 0; i < n; i++) {\n+                colors[i] = new Color((float) Math.random(),\n+                        (float) Math.random(), (float) Math.random());\n+            }\n+        }\n+\n+        void setPaint(Graphics2D g2d, int id) {\n+            g2d.setColor(colors[id % colors.length]);\n+        }\n+    }\n+\n+    static class LargeTextParticleRenderer extends TextParticleRenderer {\n+\n+        LargeTextParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            setPaint(g2d, id);\n+            Font font = new Font(\"LucidaGrande\", Font.PLAIN, 32);\n+            g2d.setFont(font);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] - r));\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)y[id]);\n+            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n+                    (int)(x[id] - r), (int)(y[id] + r));\n+        }\n+    }\n+\n+    static class FlatOvalRotParticleRenderer extends FlatParticleRenderer {\n+\n+\n+        FlatOvalRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        void setPaint(Graphics2D g2d, int id) {\n+            g2d.setColor(colors[id % colors.length]);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            setPaint(g2d, id);\n+            if (Math.abs(vx[id] + vy[id]) > 0.001) {\n+                AffineTransform t = (AffineTransform) g2d.getTransform().clone();\n+                double l = vx[id] \/ Math.sqrt(vx[id] * vx[id] + vy[id] * vy[id]);\n+                if (vy[id] < 0) {\n+                    l = -l;\n+                }\n+                g2d.translate(x[id], y[id]);\n+                g2d.rotate(Math.acos(l));\n+                g2d.fillOval(-(int)r, (int)(-0.5*r), (int) (2 * r), (int)r);\n+                g2d.setTransform(t);\n+            } else {\n+                g2d.fillOval((int)(x[id] - r), (int)(y[id] - 0.5*r),\n+                        (int) (2 * r), (int) r);\n+            }\n+        }\n+    }\n+\n+    static class LinGradOvalRotParticleRenderer extends FlatOvalRotParticleRenderer {\n+\n+\n+        LinGradOvalRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        void setPaint(Graphics2D g2d, int id) {\n+            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n+            Point2D end = new Point2D.Double( 2 * r, r);\n+            float[] dist = {0.0f, 1.0f};\n+            Color[] cls = {colors[id %colors.length], colors[(colors.length - id) %colors.length]};\n+            LinearGradientPaint p =\n+                    new LinearGradientPaint(start, end, dist, cls);\n+            g2d.setPaint(p);\n+        }\n+    }\n+\n+    static class LinGrad3OvalRotParticleRenderer extends FlatOvalRotParticleRenderer {\n+\n+\n+        LinGrad3OvalRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        void setPaint(Graphics2D g2d, int id) {\n+            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n+            Point2D end = new Point2D.Double( 2 * r, r);\n+            float[] dist = {0.0f, 0.5f, 1.0f};\n+            Color[] cls = {\n+                colors[id %colors.length],\n+                colors[(colors.length - id) %colors.length],\n+                colors[(id*5) %colors.length]};\n+            LinearGradientPaint p =\n+                new LinearGradientPaint(start, end, dist, cls);\n+            g2d.setPaint(p);\n+        }\n+    }\n+\n+    static class RadGrad3OvalRotParticleRenderer extends FlatOvalRotParticleRenderer {\n+\n+\n+        RadGrad3OvalRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        void setPaint(Graphics2D g2d, int id) {\n+            Point2D start = new Point2D.Double();\n+            float[] dist = {0.0f, 0.5f, 1.0f};\n+            Color[] cls = {\n+                colors[id %colors.length],\n+                colors[(colors.length - id) %colors.length],\n+                colors[(id*5) %colors.length]};\n+            RadialGradientPaint p =\n+                new RadialGradientPaint(start, r, dist, cls);\n+            g2d.setPaint(p);\n+        }\n+    }\n+\n+    static class FlatBoxParticleRenderer extends FlatParticleRenderer {\n+\n+\n+        FlatBoxParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.fillRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+\n+        }\n+\n+    }\n+\n+    static class ClipFlatBoxParticleRenderer extends FlatParticleRenderer {\n+\n+\n+        ClipFlatBoxParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            if ((id % 10) == 0) {\n+                g2d.setColor(colors[id % colors.length]);\n+                g2d.setClip((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n+                g2d.fillRect((int) (x[id] - 2 * r), (int) (y[id] - 2 * r), (int) (4 * r), (int) (4 * r));\n+            }\n+        }\n+    }\n+\n+    static class ImgParticleRenderer extends FlatParticleRenderer {\n+        BufferedImage dukeImg;\n+\n+        ImgParticleRenderer(int n, float r) {\n+            super(n, r);\n+            try {\n+                dukeImg = ImageIO.read(\n+                        Objects.requireNonNull(\n+                                RenderPerfTest.class.getClassLoader().getResourceAsStream(\n+                                        \"renderperf\/images\/duke.png\")));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.drawImage(dukeImg, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+        }\n+\n+    }\n+\n+    static class FlatBoxRotParticleRenderer extends FlatParticleRenderer {\n+\n+\n+        FlatBoxRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            if (Math.abs(vx[id] + vy[id]) > 0.001) {\n+                AffineTransform t = (AffineTransform) g2d.getTransform().clone();\n+                double l = vx[id] \/ Math.sqrt(vx[id] * vx[id] + vy[id] * vy[id]);\n+                if (vy[id] < 0) {\n+                    l = -l;\n+                }\n+                g2d.translate(x[id], y[id]);\n+                g2d.rotate(Math.acos(l));\n+                g2d.fillRect(-(int)r, -(int)r, (int) (2 * r), (int) (2 * r));\n+                g2d.setTransform(t);\n+            } else {\n+                g2d.fillRect((int)(x[id] - r), (int)(y[id] - r),\n+                        (int) (2 * r), (int) (2 * r));\n+            }\n+        }\n+    }\n+\n+    static class WiredParticleRenderer extends FlatParticleRenderer {\n+\n+\n+        WiredParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.drawOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+        }\n+\n+    }\n+    static class WiredBoxParticleRenderer extends FlatParticleRenderer {\n+\n+        WiredBoxParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.drawRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+        }\n+\n+    }\n+    static class SegParticleRenderer extends FlatParticleRenderer {\n+\n+        SegParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            double v = Math.sqrt(vx[id]*vx[id]+vy[id]*vy[id]);\n+            float nvx = (float) (vx[id]\/v);\n+            float nvy = (float) (vy[id]\/v);\n+            g2d.setColor(colors[id % colors.length]);\n+            g2d.drawLine((int)(x[id] - r*nvx), (int)(y[id] - r*nvy),\n+                    (int)(x[id] + 2*r*nvx), (int)(y[id] + 2*r*nvy));\n+        }\n+\n+    }\n+\n+\n+    static class WiredQuadParticleRenderer extends FlatParticleRenderer {\n+\n+        WiredQuadParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            if (id > 2 && (id % 3) == 0) {\n+                g2d.setColor(colors[id % colors.length]);\n+                g2d.draw(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+            }\n+\n+        }\n+    }\n+\n+    static class FlatQuadParticleRenderer extends FlatParticleRenderer {\n+\n+        FlatQuadParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            if (id > 2 && (id % 3) == 0) {\n+                g2d.setColor(colors[id % colors.length]);\n+                g2d.fill(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+            }\n+\n+        }\n+    }\n+\n+    static class BlitImageParticleRenderer extends FlatParticleRenderer {\n+        BufferedImage image;\n+\n+        BlitImageParticleRenderer(int n, float r, BufferedImage img) {\n+            super(n, r);\n+            image = img;\n+            fill(image);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            g2d.drawImage(image, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+        }\n+\n+        private static void fill(final Image image) {\n+            final Graphics2D graphics = (Graphics2D) image.getGraphics();\n+            graphics.setComposite(AlphaComposite.Src);\n+            for (int i = 0; i < image.getHeight(null); ++i) {\n+                graphics.setColor(new Color(i, 0, 0));\n+                graphics.fillRect(0, i, image.getWidth(null), 1);\n+            }\n+            graphics.dispose();\n+        }\n+\n+    }\n+\n+    static class SwBlitImageParticleRenderer extends BlitImageParticleRenderer {\n+\n+        SwBlitImageParticleRenderer(int n, float r, final int type) {\n+            super(n, r, makeUnmanagedBI(type));\n+        }\n+\n+        private static BufferedImage makeUnmanagedBI(final int type) {\n+            final BufferedImage bi = new BufferedImage(17, 33, type);\n+            final DataBuffer db = bi.getRaster().getDataBuffer();\n+            if (db instanceof DataBufferInt) {\n+                ((DataBufferInt) db).getData();\n+            } else if (db instanceof DataBufferShort) {\n+                ((DataBufferShort) db).getData();\n+            } else if (db instanceof DataBufferByte) {\n+                ((DataBufferByte) db).getData();\n+            }\n+            bi.setAccelerationPriority(0.0f);\n+            return bi;\n+        }\n+    }\n+\n+    static class SurfaceBlitImageParticleRenderer extends BlitImageParticleRenderer {\n+\n+        SurfaceBlitImageParticleRenderer(int n, float r, final int type) {\n+            super(n, r, makeManagedBI(type));\n+        }\n+\n+        private static BufferedImage makeManagedBI(final int type) {\n+            final BufferedImage bi = new BufferedImage(17, 33, type);\n+            bi.setAccelerationPriority(1.0f);\n+            return bi;\n+        }\n+    }\n+\n+    static class PerfMeter {\n+        private String name;\n+        private int frame = 0;\n+\n+        private JPanel panel;\n+\n+        private long time;\n+        private double execTime = 0;\n+        private Color expColor = Color.RED;\n+        AtomicBoolean waiting = new AtomicBoolean(false);\n+        private double fps;\n+\n+        PerfMeter(String name) {\n+            this.name = name;\n+        }\n+\n+        PerfMeter exec(final Renderable renderable) throws Exception {\n+            final CountDownLatch latch = new CountDownLatch(COUNT);\n+            final CountDownLatch latchFrame = new CountDownLatch(1);\n+            final long endTime = System.currentTimeMillis() + MAX_MEASURE_TIME;\n+\n+            final JFrame f = new JFrame();\n+            f.addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosed(WindowEvent e) {\n+                    latchFrame.countDown();\n+                }\n+            });\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+\n+                    panel = new JPanel()\n+                    {\n+                        @Override\n+                        protected void paintComponent(Graphics g) {\n+\n+                            super.paintComponent(g);\n+                            time = System.nanoTime();\n+                            Graphics2D g2d = (Graphics2D) g.create();\n+                            renderable.setup(g2d);\n+                            renderable.render(g2d);\n+                            g2d.setColor(expColor);\n+                            g.fillRect(0, 0, BW, BH);\n+                        }\n+                    };\n+\n+                    panel.setPreferredSize(new Dimension((int)(WIDTH + BW), (int)(HEIGHT + BH)));\n+                    panel.setBackground(Color.BLACK);\n+                    f.add(panel);\n+                    f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+                    f.pack();\n+                    f.setVisible(true);\n+                }\n+            });\n+            Robot robot = new Robot();\n+\n+            Timer timer = new Timer(DELAY, e -> {\n+\n+                if (waiting.compareAndSet(false, true)) {\n+                    Color c = robot.getPixelColor(\n+                            panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW \/ 2,\n+                            panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BW \/ 2);\n+                    if (isAlmostEqual(c, Color.BLUE)) {\n+                        expColor = Color.RED;\n+                    } else {\n+                        expColor = Color.BLUE;\n+                    }\n+                    renderable.update();\n+                    panel.getParent().repaint();\n+\n+                } else {\n+                    while (!isAlmostEqual(\n+                            robot.getPixelColor(\n+                                    panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW\/2,\n+                                    panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BH\/2),\n+                            expColor))\n+                    {\n+                        try {\n+                            Thread.sleep(RESOLUTION);\n+                        } catch (InterruptedException ex) {\n+                            ex.printStackTrace();\n+                        }\n+                    }\n+                    time = System.nanoTime() - time;\n+                    execTime += time;\n+                    frame++;\n+                    waiting.set(false);\n+                }\n+\n+                if (System.currentTimeMillis() < endTime) {\n+                    latch.countDown();\n+                } else {\n+                    while(latch.getCount() > 0) latch.countDown();\n+                }\n+            });\n+            timer.start();\n+            latch.await();\n+            SwingUtilities.invokeAndWait(() -> {\n+                timer.stop();\n+                f.setVisible(false);\n+                f.dispose();\n+            });\n+\n+            latchFrame.await();\n+            if (execTime != 0 && frame != 0) {\n+                fps = 1e9 \/ (execTime \/ frame);\n+            } else {\n+                fps = 0;\n+            }\n+\n+            return this;\n+        }\n+\n+        private void report() {\n+            System.err.println(name + \" : \" + String.format(\"%.2f FPS\", fps));\n+        }\n+\n+        private boolean isAlmostEqual(Color c1, Color c2) {\n+            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE ||\n+                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE ||\n+                    Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n+\n+        }\n+    }\n+\n+    private static final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n+    private static final ParticleRenderer flatRenderer = new FlatParticleRenderer(N, R);\n+    private static final ParticleRenderer clipFlatRenderer = new ClipFlatParticleRenderer(N, R);\n+    private static final ParticleRenderer flatOvalRotRenderer = new FlatOvalRotParticleRenderer(N, R);\n+    private static final ParticleRenderer flatBoxRenderer = new FlatBoxParticleRenderer(N, R);\n+    private static final ParticleRenderer clipFlatBoxParticleRenderer = new ClipFlatBoxParticleRenderer(N, R);\n+    private static final ParticleRenderer flatBoxRotRenderer = new FlatBoxRotParticleRenderer(N, R);\n+    private static final ParticleRenderer linGradOvalRotRenderer = new LinGradOvalRotParticleRenderer(N, R);\n+    private static final ParticleRenderer linGrad3OvalRotRenderer = new LinGrad3OvalRotParticleRenderer(N, R);\n+    private static final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n+    private static final ParticleRenderer wiredRenderer = new WiredParticleRenderer(N, R);\n+    private static final ParticleRenderer wiredBoxRenderer = new WiredBoxParticleRenderer(N, R);\n+    private static final ParticleRenderer segRenderer = new SegParticleRenderer(N, R);\n+    private static final ParticleRenderer flatQuadRenderer = new FlatQuadParticleRenderer(N, R);\n+    private static final ParticleRenderer wiredQuadRenderer = new WiredQuadParticleRenderer(N, R);\n+    private static final ParticleRenderer imgRenderer = new ImgParticleRenderer(N, R);\n+    private static final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n+    private static final ParticleRenderer largeTextRenderer = new LargeTextParticleRenderer(N, R);\n+    private static final ParticleRenderer whiteTextRenderer = new WhiteTextParticleRenderer(R);\n+    private static final ParticleRenderer argbSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private static final ParticleRenderer bgrSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+    private static final ParticleRenderer argbSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private static final ParticleRenderer bgrSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+\n+    private static final Configurable AA = (Graphics2D g2d) ->\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+            RenderingHints.VALUE_ANTIALIAS_ON);\n+\n+    private static final Configurable TextLCD = (Graphics2D g2d) ->\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+\n+    private static final Configurable TextAA = (Graphics2D g2d) ->\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+\n+    private static final Configurable XORMode = (Graphics2D g2d) ->\n+        {g2d.setXORMode(Color.WHITE);};\n+\n+    private static final Configurable XORModeLCDText = (Graphics2D g2d) ->\n+        {g2d.setXORMode(Color.WHITE);\n+         g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+         RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);};\n+\n+\n+    public void testFlatOval() throws Exception {\n+        (new PerfMeter(\"FlatOval\")).exec(createPR(flatRenderer)).report();\n+    }\n+\n+    public void testFlatOvalAA() throws Exception {\n+        (new PerfMeter(\"FlatOvalAA\")).exec(createPR(flatRenderer).configure(AA)).report();\n+    }\n+\n+    public void testClipFlatOval() throws Exception {\n+        (new PerfMeter(\"ClipFlatOval\")).exec(createPR(clipFlatRenderer)).report();\n+    }\n+\n+    public void testClipFlatOvalAA() throws Exception {\n+        (new PerfMeter(\"ClipFlatOvalAA\")).exec(createPR(clipFlatRenderer).configure(AA)).report();\n+    }\n+\n+    public void testFlatBox() throws Exception {\n+        (new PerfMeter(\"FlatBox\")).exec(createPR(flatBoxRenderer)).report();\n+    }\n+\n+    public void testFlatBoxAA() throws Exception {\n+        (new PerfMeter(\"FlatBoxAA\")).exec(createPR(flatBoxRenderer).configure(AA)).report();\n+    }\n+\n+    public void testClipFlatBox() throws Exception {\n+        (new PerfMeter(\"ClipFlatBox\")).exec(createPR(clipFlatBoxParticleRenderer)).report();\n+    }\n+\n+    public void testClipFlatBoxAA() throws Exception {\n+        (new PerfMeter(\"ClipFlatBoxAA\")).exec(createPR(clipFlatBoxParticleRenderer).configure(AA)).report();\n+    }\n+\n+    public void testImage() throws Exception {\n+        (new PerfMeter(\"Image\")).exec(createPR(imgRenderer)).report();\n+    }\n+\n+    public void testImageAA() throws Exception {\n+        (new PerfMeter(\"ImageAA\")).exec(createPR(imgRenderer).configure(AA)).report();\n+    }\n+\n+    public void testRotatedBox() throws Exception {\n+        (new PerfMeter(\"RotatedBox\")).exec(createPR(flatBoxRotRenderer)).report();\n+    }\n+\n+    public void testRotatedBoxAA() throws Exception {\n+        (new PerfMeter(\"RotatedBoxAA\")).exec(createPR(flatBoxRotRenderer).configure(AA)).report();\n+    }\n+\n+    public void testRotatedOval() throws Exception {\n+        (new PerfMeter(\"RotatedOval\")).exec(createPR(flatOvalRotRenderer)).report();\n+    }\n+\n+    public void testRotatedOvalAA() throws Exception {\n+        (new PerfMeter(\"RotatedOvalAA\")).exec(createPR(flatOvalRotRenderer).configure(AA)).report();\n+    }\n+\n+    public void testLinGrad3RotatedOval() throws Exception {\n+        (new PerfMeter(\"LinGrad3RotatedOval\")).exec(createPR(linGrad3OvalRotRenderer)).report();\n+    }\n+\n+    public void testLinGrad3RotatedOvalAA() throws Exception {\n+        (new PerfMeter(\"LinGrad3RotatedOvalAA\")).exec(createPR(linGrad3OvalRotRenderer).configure(AA)).report();\n+    }\n+\n+    public void testRadGrad3RotatedOval() throws Exception {\n+        (new PerfMeter(\"RadGrad3RotatedOval\")).exec(createPR(radGrad3OvalRotRenderer)).report();\n+    }\n+\n+    public void testRadGrad3RotatedOvalAA() throws Exception {\n+        (new PerfMeter(\"RadGrad3RotatedOvalAA\")).exec(createPR(radGrad3OvalRotRenderer).configure(AA)).report();\n+    }\n+\n+    public void testLinGradRotatedOval() throws Exception {\n+        (new PerfMeter(\"LinGradRotatedOval\")).exec(createPR(linGradOvalRotRenderer)).report();\n+    }\n+\n+    public void testLinGradRotatedOvalAA() throws Exception {\n+        (new PerfMeter(\"LinGradRotatedOvalAA\")).exec(createPR(linGradOvalRotRenderer).configure(AA)).report();\n+    }\n+\n+    public void testWiredBubbles() throws Exception {\n+        (new PerfMeter(\"WiredBubbles\")).exec(createPR(wiredRenderer)).report();\n+    }\n+\n+    public void testWiredBubblesAA() throws Exception {\n+        (new PerfMeter(\"WiredBubblesAA\")).exec(createPR(wiredRenderer).configure(AA)).report();\n+    }\n+\n+    public void testWiredBox() throws Exception {\n+        (new PerfMeter(\"WiredBox\")).exec(createPR(wiredBoxRenderer)).report();\n+    }\n+\n+    public void testWiredBoxAA() throws Exception {\n+        (new PerfMeter(\"WiredBoxAA\")).exec(createPR(wiredBoxRenderer).configure(AA)).report();\n+    }\n+\n+    public void testLines() throws Exception {\n+        (new PerfMeter(\"Lines\")).exec(createPR(segRenderer)).report();\n+    }\n+\n+    public void testLinesAA() throws Exception {\n+        (new PerfMeter(\"LinesAA\")).exec(createPR(segRenderer).configure(AA)).report();\n+    }\n+\n+    public void testFlatQuad() throws Exception {\n+        (new PerfMeter(\"FlatQuad\")).exec(createPR(flatQuadRenderer)).report();\n+    }\n+\n+    public void testFlatQuadAA() throws Exception {\n+        (new PerfMeter(\"FlatQuadAA\")).exec(createPR(flatQuadRenderer).configure(AA)).report();\n+    }\n+\n+    public void testWiredQuad() throws Exception {\n+        (new PerfMeter(\"WiredQuad\")).exec(createPR(wiredQuadRenderer)).report();\n+    }\n+\n+    public void testWiredQuadAA() throws Exception {\n+        (new PerfMeter(\"WiredQuadAA\")).exec(createPR(wiredQuadRenderer).configure(AA)).report();\n+    }\n+\n+    public void testTextNoAA() throws Exception {\n+        (new PerfMeter(\"TextNoAA\")).exec(createPR(textRenderer)).report();\n+    }\n+\n+    public void testTextLCD() throws Exception {\n+        (new PerfMeter(\"TextLCD\")).exec(createPR(textRenderer).configure(TextLCD)).report();\n+    }\n+\n+    public void testTextGray() throws Exception {\n+        (new PerfMeter(\"TextGray\")).exec(createPR(textRenderer).configure(TextAA)).report();\n+    }\n+\n+    public void testLargeTextNoAA() throws Exception {\n+        (new PerfMeter(\"LargeTextNoAA\")).exec(createPR(largeTextRenderer)).report();\n+    }\n+\n+    public void testLargeTextLCD() throws Exception {\n+        (new PerfMeter(\"LargeTextLCD\")).exec(createPR(largeTextRenderer).configure(TextLCD)).report();\n+    }\n+\n+    public void testLargeTextGray() throws Exception {\n+        (new PerfMeter(\"LargeTextGray\")).exec(createPR(largeTextRenderer).configure(TextAA)).report();\n+    }\n+    public void testWhiteTextNoAA() throws Exception {\n+        (new PerfMeter(\"WhiteTextNoAA\")).exec(createPR(whiteTextRenderer)).report();\n+    }\n+\n+    public void testWhiteTextLCD() throws Exception {\n+        (new PerfMeter(\"WhiteTextLCD\")).exec(createPR(whiteTextRenderer).configure(TextLCD)).report();\n+    }\n+\n+    public void testWhiteTextGray() throws Exception {\n+        (new PerfMeter(\"WhiteTextGray\")).exec(createPR(whiteTextRenderer).configure(TextAA)).report();\n+    }\n+\n+    public void testArgbSwBlitImage() throws Exception {\n+        (new PerfMeter(\"ArgbSwBlitImage\")).exec(createPR(argbSwBlitImageRenderer)).report();\n+    }\n+\n+    public void testBgrSwBlitImage() throws Exception {\n+        (new PerfMeter(\"BgrSwBlitImage\")).exec(createPR(bgrSwBlitImageRenderer)).report();\n+    }\n+\n+    public void testArgbSurfaceBlitImage() throws Exception {\n+        (new PerfMeter(\"ArgbSurfaceBlitImageRenderer\")).exec(createPR(argbSurfaceBlitImageRenderer)).report();\n+    }\n+\n+    public void testBgrSurfaceBlitImage() throws Exception {\n+        (new PerfMeter(\"BgrSurfaceBlitImage\")).exec(createPR(bgrSurfaceBlitImageRenderer)).report();\n+    }\n+\n+    public void testFlatOval_XOR() throws Exception {\n+        (new PerfMeter(\"FlatOval_XOR\")).exec(createPR(flatRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testRotatedBox_XOR() throws Exception {\n+        (new PerfMeter(\"RotatedBox_XOR\")).exec(createPR(flatBoxRotRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testLines_XOR() throws Exception {\n+        (new PerfMeter(\"Lines_XOR\")).exec(createPR(segRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testImage_XOR() throws Exception {\n+        (new PerfMeter(\"Image_XOR\")).exec(createPR(imgRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testTextNoAA_XOR() throws Exception {\n+        (new PerfMeter(\"TextNoAA_XOR\")).exec(createPR(textRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testTextLCD_XOR() throws Exception {\n+        (new PerfMeter(\"TextLCD_XOR\")).exec(createPR(textRenderer).configure(XORModeLCDText)).report();\n+    }\n+\n+    public static void main(String[] args)\n+            throws InvocationTargetException, IllegalAccessException, NoSuchMethodException\n+    {\n+        RenderPerfTest test = new RenderPerfTest();\n+\n+        if (args.length > 0) {\n+            for (String testCase : args) {\n+                Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + testCase);\n+                m.invoke(test);\n+            }\n+        } else {\n+            Method[] methods = RenderPerfTest.class.getDeclaredMethods();\n+            for (Method m : methods) {\n+                if (m.getName().startsWith(\"test\") && !ignoredTests.contains(m.getName())) {\n+                    m.invoke(test);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":986,"deletions":0,"binary":false,"changes":986,"status":"added"}]}