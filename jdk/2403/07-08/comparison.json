{"files":[{"patch":"@@ -71,0 +71,4 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque;\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-                  isText:(jboolean)isText;\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD;\n@@ -55,0 +56,1 @@\n+@property (assign) jboolean lcd;\n@@ -68,0 +70,1 @@\n+    jboolean _isLCD;\n@@ -92,0 +95,1 @@\n+@synthesize lcd = _isLCD;\n@@ -122,1 +126,2 @@\n-                  isText:(jboolean)isText {\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD {\n@@ -128,0 +133,1 @@\n+    _isLCD = isLCD;\n@@ -176,0 +182,1 @@\n+        && _isLCD == renderOptions->isLCD\n@@ -185,0 +192,1 @@\n+    _isLCD = renderOptions->isLCD;\n@@ -278,1 +286,1 @@\n-  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE};\n+  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -285,1 +293,1 @@\n-    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -309,0 +317,8 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque\n+{\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, {isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_TRUE};\n+    return [self getEncoder:dest renderOptions:&roptions];\n+}\n+\n@@ -315,1 +331,1 @@\n-    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -330,1 +346,1 @@\n-    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE};\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE, JNI_FALSE};\n@@ -410,1 +426,2 @@\n-                      isText:renderOptions->isText];\n+                      isText:renderOptions->isText\n+                      isLCD:renderOptions->isLCD];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -165,1 +165,2 @@\n-        J2dTraceLn4(J2D_TRACE_WARNING, \"replaceTextureRegion: dest size: (%d, %d) less than source size: (%d, %d)\", dw, dh, sw, sh);\n+        J2dTraceLn4(J2D_TRACE_ERROR, \"replaceTextureRegion: dest size: (%d, %d) less than source size: (%d, %d)\", dw, dh, sw, sh);\n+        return;\n@@ -216,0 +217,8 @@\n+        [mtlc.encoderManager endEncoder];\n+\n+        MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];\n+        id<MTLCommandBuffer> commandbuf = [cbwrapper getCommandBuffer];\n+        [commandbuf addCompletedHandler:^(id <MTLCommandBuffer> commandbuf) {\n+            [cbwrapper release];\n+        }];\n+        [commandbuf commit];\n@@ -755,0 +764,26 @@\n+    jint texWidth = ((id<MTLTexture>)dstOps->pTexture).width;\n+    jint texHeight = ((id<MTLTexture>)dstOps->pTexture).height;\n+\n+    SurfaceDataBounds srcBounds, dstBounds;\n+    srcBounds.x1 = x;\n+    srcBounds.y1 = y;\n+    srcBounds.x2 = srcBounds.x1 + width;\n+    srcBounds.y2 = srcBounds.y1 + height;\n+    dstBounds.x1 = x + dx;\n+    dstBounds.y1 = y + dy;\n+    dstBounds.x2 = dstBounds.x1 + width;\n+    dstBounds.y2 = dstBounds.y1 + height;\n+\n+    SurfaceData_IntersectBoundsXYXY(&srcBounds, 0, 0, texWidth, texHeight);\n+    SurfaceData_IntersectBoundsXYXY(&dstBounds, 0, 0, texWidth, texHeight);\n+    SurfaceData_IntersectBlitBounds(&dstBounds, &srcBounds, -dx, -dy);\n+\n+    int srcWidth = (srcBounds.x2 - srcBounds.x1);\n+    int srcHeight = (srcBounds.y2 - srcBounds.y1);\n+\n+   if ((srcBounds.x1 < srcBounds.x2 && srcBounds.y1 < srcBounds.y2) &&\n+       (dstBounds.x1 < dstBounds.x2 && dstBounds.y1 < dstBounds.y2))\n+   {\n+        @autoreleasepool {\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n@@ -756,7 +791,3 @@\n-    @autoreleasepool {\n-        id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n-        id<MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];\n-\n-        \/\/ Create an intrermediate buffer\n-        int totalBuffsize = width * height * 4;\n-        id <MTLBuffer> buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];\n+            \/\/ Create an intrermediate buffer\n+            int totalBuffsize = srcWidth * srcHeight * 4;\n+            id <MTLBuffer> buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];\n@@ -764,3 +795,3 @@\n-        [blitEncoder copyFromTexture:dstOps->pTexture\n-                sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)\n-                 toBuffer:buff destinationOffset:0 destinationBytesPerRow:(width * 4) destinationBytesPerImage:totalBuffsize];\n+            [blitEncoder copyFromTexture:dstOps->pTexture\n+                    sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(srcBounds.x1, srcBounds.y1, 0) sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n+                     toBuffer:buff destinationOffset:0 destinationBytesPerRow:(srcWidth * 4) destinationBytesPerImage:totalBuffsize];\n@@ -768,7 +799,4 @@\n-        [blitEncoder copyFromBuffer:buff\n-                sourceOffset:0 sourceBytesPerRow:width*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(width, height, 1)\n-                toTexture:dstOps->pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];\n-        [blitEncoder endEncoding];\n-\n-        [cb commit];\n-    }\n+            [blitEncoder copyFromBuffer:buff\n+                    sourceOffset:0 sourceBytesPerRow:srcWidth*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(srcWidth, srcHeight, 1)\n+                    toTexture:dstOps->pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dstBounds.x1, dstBounds.y1, 0)];\n+            [blitEncoder endEncoding];\n@@ -776,2 +804,3 @@\n-    \/\/ TODO:\n-    \/\/  1. check rect bounds\n+            [cb commit];\n+        }\n+   }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -275,1 +275,20 @@\n-    [encoder setScissorRect:_clipRect];\n+    \/\/ Clamping clip rect to the destination area\n+    MTLScissorRect rect = _clipRect;\n+\n+    if (rect.x > dw) {\n+        rect.x = dw;\n+    }\n+\n+    if (rect.y > dh) {\n+        rect.y = dh;\n+    }\n+\n+    if (rect.x + rect.width > dw) {\n+        rect.width = dw - rect.x;\n+    }\n+\n+    if (rect.y + rect.height > dh) {\n+        rect.height = dh - rect.y;\n+    }\n+\n+    [encoder setScissorRect:rect];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.m","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -197,10 +197,0 @@\n-    NSView *scratchSurface =\n-        [[NSView alloc]\n-            initWithFrame: contentRect];\n-    if (scratchSurface == nil) {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: NSView is NULL\");\n-        [argValue addObject: [NSNumber numberWithLong: 0L]];\n-        return;\n-    }\n-    [window setContentView: scratchSurface];\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;\n@@ -96,0 +97,11 @@\n+    templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateLCDPipelineDesc.sampleCount = 1;\n+    templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n+    templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+    templateLCDPipelineDesc.label = @\"template_lcd\";\n@@ -163,0 +175,5 @@\n+        if (renderOptions->isLCD) {\n+            vertShader = @\"vert_txt_lcd\";\n+            fragShader = @\"lcd_color\";\n+            rpDesc = [[templateLCDPipelineDesc copy] autorelease];\n+        }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -101,1 +101,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-const int NUM_OF_VERTICES_PER_SCANLINE = 3;\n+const int NUM_OF_VERTICES_PER_SCANLINE = 2;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,114 +250,0 @@\n-static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;\n-\n-\/**\n- * Enables the LCD text shader and updates any related state, such as the\n- * gamma lookup table textures.\n- *\/\n-static jboolean\n-MTLTR_EnableLCDGlyphModeState(id<MTLRenderCommandEncoder> encoder,\n-                              MTLContext *mtlc,\n-                              MTLSDOps *dstOps,\n-                              jint contrast)\n-{\n-    if (![mtlc.paint isKindOfClass:[MTLColorPaint class]]) {\n-        return JNI_FALSE;\n-    }\n-    MTLColorPaint* cPaint = (MTLColorPaint *) mtlc.paint;\n-    \/\/ create the LCD text shader, if necessary\n-    if (templateLCDPipelineDesc == nil) {\n-\n-        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n-        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n-        vertDesc.attributes[VertexAttributePosition].offset = 0;\n-        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n-        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n-        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n-        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-\n-        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n-        templateLCDPipelineDesc.sampleCount = 1;\n-        templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n-        templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-        templateLCDPipelineDesc.label = @\"template_lcd\";\n-    }\n-\n-    id<MTLRenderPipelineState> pipelineState =\n-                [mtlc.pipelineStateStorage\n-                    getPipelineState:templateLCDPipelineDesc\n-                    vertexShaderId:@\"vert_txt_lcd\"\n-                    fragmentShaderId:@\"lcd_color\"\n-                   ];\n-\n-    [encoder setRenderPipelineState:pipelineState];\n-\n-    \/\/ update the current color settings\n-    double gamma = ((double)contrast) \/ 100.0;\n-    double invgamma = 1.0\/gamma;\n-    jfloat radj, gadj, badj;\n-    jfloat clr[4];\n-    jint col = cPaint.color;\n-\n-    J2dTraceLn2(J2D_TRACE_INFO, \"primary color %x, contrast %d\", col, contrast);\n-    J2dTraceLn2(J2D_TRACE_INFO, \"gamma %f, invgamma %f\", gamma, invgamma);\n-\n-    clr[0] = ((col >> 16) & 0xFF)\/255.0f;\n-    clr[1] = ((col >> 8) & 0xFF)\/255.0f;\n-    clr[2] = ((col) & 0xFF)\/255.0f;\n-\n-    \/\/ gamma adjust the primary color\n-    radj = (float)pow(clr[0], gamma);\n-    gadj = (float)pow(clr[1], gamma);\n-    badj = (float)pow(clr[2], gamma);\n-\n-    struct LCDFrameUniforms uf = {\n-            {radj, gadj, badj},\n-            {gamma, gamma, gamma},\n-            {invgamma, invgamma, invgamma}};\n-    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n-\n-    return JNI_TRUE;\n-}\n-\n-static jboolean\n-MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)\n-{\n-    if (templateLCDPipelineDesc == nil) {\n-\n-        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n-        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n-        vertDesc.attributes[VertexAttributePosition].offset = 0;\n-        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n-        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n-        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n-        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-\n-        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n-        templateLCDPipelineDesc.sampleCount = 1;\n-        templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n-        templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-        templateLCDPipelineDesc.label = @\"template_lcd\";\n-    }\n-\n-    id<MTLRenderPipelineState> pipelineState =\n-                [mtlc.pipelineStateStorage\n-                    getPipelineState:templateLCDPipelineDesc\n-                    vertexShaderId:@\"vert_txt_lcd\"\n-                    fragmentShaderId:@\"lcd_color\"\n-                   ];\n-\n-    [lcdCacheEncoder setRenderPipelineState:pipelineState];\n-    return JNI_TRUE;\n-}\n-\n@@ -366,1 +252,2 @@\n-                     jint contrast)\n+                     jint contrast,\n+                     id<MTLRenderCommandEncoder> encoder)\n@@ -395,1 +282,1 @@\n-    [lcdCacheEncoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n@@ -507,2 +394,1 @@\n-            lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n-            MTLTR_SetLCDCachePipelineState(mtlc);\n+            lcdCacheEncoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n@@ -533,1 +419,1 @@\n-    MTLTR_SetLCDContrast(mtlc, contrast);\n+    MTLTR_SetLCDContrast(mtlc, contrast, lcdCacheEncoder);\n@@ -644,5 +530,2 @@\n-    encoder = [mtlc.encoderManager getTextureEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n-    if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))\n-    {\n-        return JNI_FALSE;\n-    }\n+    encoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n+    MTLTR_SetLCDContrast(mtlc, contrast, encoder);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":7,"deletions":124,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    jboolean isLCD;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/RenderOptions.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -763,0 +763,9 @@\n+    private static final Configurable XORMode = (Graphics2D g2d) ->\n+        {g2d.setXORMode(Color.WHITE);};\n+\n+    private static final Configurable XORModeLCDText = (Graphics2D g2d) ->\n+        {g2d.setXORMode(Color.WHITE);\n+         g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+         RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);};\n+\n+\n@@ -934,0 +943,24 @@\n+    public void testFlatOval_XOR() throws Exception {\n+        (new PerfMeter(\"FlatOval_XOR\")).exec(createPR(flatRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testRotatedBox_XOR() throws Exception {\n+        (new PerfMeter(\"RotatedBox_XOR\")).exec(createPR(flatBoxRotRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testLines_XOR() throws Exception {\n+        (new PerfMeter(\"Lines_XOR\")).exec(createPR(segRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testImage_XOR() throws Exception {\n+        (new PerfMeter(\"Image_XOR\")).exec(createPR(imgRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testTextNoAA_XOR() throws Exception {\n+        (new PerfMeter(\"TextNoAA_XOR\")).exec(createPR(textRenderer).configure(XORMode)).report();\n+    }\n+\n+    public void testTextLCD_XOR() throws Exception {\n+        (new PerfMeter(\"TextLCD_XOR\")).exec(createPR(textRenderer).configure(XORModeLCDText)).report();\n+    }\n+\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"}]}