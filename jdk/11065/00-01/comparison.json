{"files":[{"patch":"@@ -4235,0 +4235,54 @@\n+\/\/------------------------------verify_bidirectional_edges---------------------\n+\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n+\/\/ there is a corresponding Def-Use edge.\n+void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+  \/\/ Allocate stack of size C->live_nodes()\/16 to avoid frequent realloc\n+  uint stack_size = live_nodes() >> 4;\n+  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n+  nstack.push(_root);\n+\n+  while (nstack.size() > 0) {\n+    Node* n = nstack.pop();\n+    if (visited.member(n)) {\n+      continue;\n+    }\n+    visited.push(n);\n+\n+    \/\/ Walk over all input edges, checking for correspondence\n+    uint length = n->len();\n+    for (uint i = 0; i < length; i++) {\n+      Node* in = n->in(i);\n+      if (in != NULL && !visited.member(in)) {\n+        nstack.push(in); \/\/ Put it on stack\n+      }\n+      if (in != NULL && !in->is_top()) {\n+        \/\/ Count instances of `next`\n+        int cnt = 0;\n+        for (uint idx = 0; idx < in->_outcnt; idx++) {\n+          if (in->_out[idx] == n) {\n+            cnt++;\n+          }\n+        }\n+        assert(cnt > 0, \"Failed to find Def-Use edge.\");\n+        \/\/ Check for duplicate edges\n+        \/\/ walk the input array downcounting the input edges to n\n+        for (uint j = 0; j < length; j++) {\n+          if (n->in(j) == in) {\n+            cnt--;\n+          }\n+        }\n+        assert(cnt == 0, \"Mismatched edge count.\");\n+      } else if (in == NULL) {\n+        assert(i == 0 || i >= n->req() ||\n+               n->is_Region() || n->is_Phi() || n->is_ArrayCopy() ||\n+               (n->is_Unlock() && i == (n->req() - 1)) ||\n+               (n->is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n+              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n+      } else {\n+        assert(in->is_top(), \"sanity\");\n+        \/\/ Nothing to check.\n+      }\n+    }\n+  }\n+}\n+\n@@ -4241,3 +4295,0 @@\n-    \/\/ Allocate stack of size C->live_nodes()\/16 to avoid frequent realloc\n-    uint stack_size = live_nodes() >> 4;\n-    Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n@@ -4245,2 +4296,2 @@\n-    \/\/ Call recursive graph walk to check edges\n-    Node::verify_edges(_root, visited, nstack);\n+    \/\/ Call graph walk to check edges\n+    verify_bidirectional_edges(visited);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":56,"deletions":5,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1169,0 +1169,3 @@\n+  \/\/ Verify bi-directional correspondence of edges\n+  void verify_bidirectional_edges(Unique_Node_List &visited);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2683,51 +2683,0 @@\n-\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n-\/\/ there is a corresponding Def-Use edge.\n-\/\/------------------------------verify_edges-----------------------------------\n-void Node::verify_edges(Node* root, Unique_Node_List &visited, Node_List &nstack) {\n-  nstack.push(root);\n-\n-  while (nstack.size() > 0) {\n-    Node* next = nstack.pop();\n-    if (visited.member(next)) {\n-      continue;\n-    }\n-    visited.push(next);\n-\n-    \/\/ Walk over all input edges, checking for correspondence\n-    uint length = next->len();\n-    for (uint i = 0; i < length; i++) {\n-      Node* n = next->in(i);\n-      if (n != NULL && !visited.member(n)) {\n-        nstack.push(n); \/\/ Put it on stack\n-      }\n-      if (n != NULL && !n->is_top()) {\n-        \/\/ Count instances of `next`\n-        int cnt = 0;\n-        for (uint idx = 0; idx < n->_outcnt; idx++) {\n-          if (n->_out[idx] == next) {\n-            cnt++;\n-          }\n-        }\n-        assert(cnt > 0, \"Failed to find Def-Use edge.\");\n-        \/\/ Check for duplicate edges\n-        \/\/ walk the input array downcounting the input edges to n\n-        for(uint j = 0; j < length; j++) {\n-          if (next->in(j) == n) {\n-            cnt--;\n-          }\n-        }\n-        assert(cnt == 0, \"Mismatched edge count.\");\n-      } else if (n == NULL) {\n-        assert(i >= next->req() || i == 0 ||\n-               next->is_Region() || next->is_Phi() || next->is_ArrayCopy() ||\n-               (next->is_Unlock() && i == (next->req() - 1)) ||\n-               (next->is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n-              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n-      } else {\n-        assert(n->is_top(), \"sanity\");\n-        \/\/ Nothing to check.\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1220,1 +1220,0 @@\n-  static void verify_edges(Node* root, Unique_Node_List &visited, Node_List &nstack); \/\/ Verify bi-directional edges\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}