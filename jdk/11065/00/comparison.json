{"files":[{"patch":"@@ -4241,0 +4241,4 @@\n+    \/\/ Allocate stack of size C->live_nodes()\/16 to avoid frequent realloc\n+    uint stack_size = live_nodes() >> 4;\n+    Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n+\n@@ -4242,1 +4246,1 @@\n-    _root->verify_edges(visited);\n+    Node::verify_edges(_root, visited, nstack);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2686,4 +2686,2 @@\n-void Node::verify_edges(Unique_Node_List &visited) {\n-  uint i, j, idx;\n-  int  cnt;\n-  Node *n;\n+void Node::verify_edges(Node* root, Unique_Node_List &visited, Node_List &nstack) {\n+  nstack.push(root);\n@@ -2691,18 +2689,13 @@\n-  \/\/ Recursive termination test\n-  if (visited.member(this))  return;\n-  visited.push(this);\n-\n-  \/\/ Walk over all input edges, checking for correspondence\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if (n != NULL && !n->is_top()) {\n-      \/\/ Count instances of (Node *)this\n-      cnt = 0;\n-      for (idx = 0; idx < n->_outcnt; idx++ ) {\n-        if (n->_out[idx] == (Node *)this)  cnt++;\n-      }\n-      assert( cnt > 0,\"Failed to find Def-Use edge.\" );\n-      \/\/ Check for duplicate edges\n-      \/\/ walk the input array downcounting the input edges to n\n-      for( j = 0; j < len(); j++ ) {\n-        if( in(j) == n ) cnt--;\n+  while (nstack.size() > 0) {\n+    Node* next = nstack.pop();\n+    if (visited.member(next)) {\n+      continue;\n+    }\n+    visited.push(next);\n+\n+    \/\/ Walk over all input edges, checking for correspondence\n+    uint length = next->len();\n+    for (uint i = 0; i < length; i++) {\n+      Node* n = next->in(i);\n+      if (n != NULL && !visited.member(n)) {\n+        nstack.push(n); \/\/ Put it on stack\n@@ -2710,4 +2703,22 @@\n-      assert( cnt == 0,\"Mismatched edge count.\");\n-    } else if (n == NULL) {\n-      assert(i >= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() || (is_Unlock() && i == req()-1)\n-              || (is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n+      if (n != NULL && !n->is_top()) {\n+        \/\/ Count instances of `next`\n+        int cnt = 0;\n+        for (uint idx = 0; idx < n->_outcnt; idx++) {\n+          if (n->_out[idx] == next) {\n+            cnt++;\n+          }\n+        }\n+        assert(cnt > 0, \"Failed to find Def-Use edge.\");\n+        \/\/ Check for duplicate edges\n+        \/\/ walk the input array downcounting the input edges to n\n+        for(uint j = 0; j < length; j++) {\n+          if (next->in(j) == n) {\n+            cnt--;\n+          }\n+        }\n+        assert(cnt == 0, \"Mismatched edge count.\");\n+      } else if (n == NULL) {\n+        assert(i >= next->req() || i == 0 ||\n+               next->is_Region() || next->is_Phi() || next->is_ArrayCopy() ||\n+               (next->is_Unlock() && i == (next->req() - 1)) ||\n+               (next->is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n@@ -2715,3 +2726,4 @@\n-    } else {\n-      assert(n->is_top(), \"sanity\");\n-      \/\/ Nothing to check.\n+      } else {\n+        assert(n->is_top(), \"sanity\");\n+        \/\/ Nothing to check.\n+      }\n@@ -2720,6 +2732,0 @@\n-  \/\/ Recursive walk over all input edges\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if( n != NULL )\n-      in(i)->verify_edges(visited);\n-  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":41,"deletions":35,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-  void verify_edges(Unique_Node_List &visited); \/\/ Verify bi-directional edges\n+  static void verify_edges(Node* root, Unique_Node_List &visited, Node_List &nstack); \/\/ Verify bi-directional edges\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}