{"files":[{"patch":"@@ -4235,0 +4235,54 @@\n+\/\/------------------------------verify_bidirectional_edges---------------------\n+\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n+\/\/ there is a corresponding Def-Use edge.\n+void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+  \/\/ Allocate stack of size C->live_nodes()\/16 to avoid frequent realloc\n+  uint stack_size = live_nodes() >> 4;\n+  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n+  nstack.push(_root);\n+\n+  while (nstack.size() > 0) {\n+    Node* n = nstack.pop();\n+    if (visited.member(n)) {\n+      continue;\n+    }\n+    visited.push(n);\n+\n+    \/\/ Walk over all input edges, checking for correspondence\n+    uint length = n->len();\n+    for (uint i = 0; i < length; i++) {\n+      Node* in = n->in(i);\n+      if (in != NULL && !visited.member(in)) {\n+        nstack.push(in); \/\/ Put it on stack\n+      }\n+      if (in != NULL && !in->is_top()) {\n+        \/\/ Count instances of `next`\n+        int cnt = 0;\n+        for (uint idx = 0; idx < in->_outcnt; idx++) {\n+          if (in->_out[idx] == n) {\n+            cnt++;\n+          }\n+        }\n+        assert(cnt > 0, \"Failed to find Def-Use edge.\");\n+        \/\/ Check for duplicate edges\n+        \/\/ walk the input array downcounting the input edges to n\n+        for (uint j = 0; j < length; j++) {\n+          if (n->in(j) == in) {\n+            cnt--;\n+          }\n+        }\n+        assert(cnt == 0, \"Mismatched edge count.\");\n+      } else if (in == NULL) {\n+        assert(i == 0 || i >= n->req() ||\n+               n->is_Region() || n->is_Phi() || n->is_ArrayCopy() ||\n+               (n->is_Unlock() && i == (n->req() - 1)) ||\n+               (n->is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n+              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n+      } else {\n+        assert(in->is_top(), \"sanity\");\n+        \/\/ Nothing to check.\n+      }\n+    }\n+  }\n+}\n+\n@@ -4241,2 +4295,3 @@\n-    \/\/ Call recursive graph walk to check edges\n-    _root->verify_edges(visited);\n+\n+    \/\/ Call graph walk to check edges\n+    verify_bidirectional_edges(visited);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1169,0 +1169,3 @@\n+  \/\/ Verify bi-directional correspondence of edges\n+  void verify_bidirectional_edges(Unique_Node_List &visited);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2683,45 +2683,0 @@\n-\/\/ For each input edge to a node (ie - for each Use-Def edge), verify that\n-\/\/ there is a corresponding Def-Use edge.\n-\/\/------------------------------verify_edges-----------------------------------\n-void Node::verify_edges(Unique_Node_List &visited) {\n-  uint i, j, idx;\n-  int  cnt;\n-  Node *n;\n-\n-  \/\/ Recursive termination test\n-  if (visited.member(this))  return;\n-  visited.push(this);\n-\n-  \/\/ Walk over all input edges, checking for correspondence\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if (n != NULL && !n->is_top()) {\n-      \/\/ Count instances of (Node *)this\n-      cnt = 0;\n-      for (idx = 0; idx < n->_outcnt; idx++ ) {\n-        if (n->_out[idx] == (Node *)this)  cnt++;\n-      }\n-      assert( cnt > 0,\"Failed to find Def-Use edge.\" );\n-      \/\/ Check for duplicate edges\n-      \/\/ walk the input array downcounting the input edges to n\n-      for( j = 0; j < len(); j++ ) {\n-        if( in(j) == n ) cnt--;\n-      }\n-      assert( cnt == 0,\"Mismatched edge count.\");\n-    } else if (n == NULL) {\n-      assert(i >= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy() || (is_Unlock() && i == req()-1)\n-              || (is_MemBar() && i == 5), \/\/ the precedence edge to a membar can be removed during macro node expansion\n-              \"only region, phi, arraycopy, unlock or membar nodes have null data edges\");\n-    } else {\n-      assert(n->is_top(), \"sanity\");\n-      \/\/ Nothing to check.\n-    }\n-  }\n-  \/\/ Recursive walk over all input edges\n-  for( i = 0; i < len(); i++ ) {\n-    n = in(i);\n-    if( n != NULL )\n-      in(i)->verify_edges(visited);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1220,1 +1220,0 @@\n-  void verify_edges(Unique_Node_List &visited); \/\/ Verify bi-directional edges\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}