{"files":[{"patch":"@@ -3132,15 +3132,25 @@\n-            int off = 0;\n-            int next = 0;\n-            boolean limited = limit > 0;\n-            ArrayList<String> list = new ArrayList<>();\n-            while ((next = indexOf(ch, off)) != -1) {\n-                if (!limited || list.size() < limit - 1) {\n-                    list.add(substring(off, next));\n-                    off = next + 1;\n-                } else {    \/\/ last one\n-                    \/\/assert (list.size() == limit - 1);\n-                    int last = length();\n-                    list.add(substring(off, last));\n-                    off = last;\n-                    break;\n-                }\n+            \/\/ All the checks above can potentially be constant folded by\n+            \/\/ a JIT\/AOT compiler when the regex is a constant string.\n+            \/\/ That requires method inlining of the checks, which is only\n+            \/\/ possible when the actual split logic is in a separate method\n+            \/\/ because the large split loop can usually not be inlined.\n+            return split(ch, limit);\n+        }\n+        return Pattern.compile(regex).split(this, limit);\n+    }\n+\n+    private String[] split(char ch, int limit) {\n+        int off = 0;\n+        int next = 0;\n+        boolean limited = limit > 0;\n+        ArrayList<String> list = new ArrayList<>();\n+        while ((next = indexOf(ch, off)) != -1) {\n+            if (!limited || list.size() < limit - 1) {\n+                list.add(substring(off, next));\n+                off = next + 1;\n+            } else {    \/\/ last one\n+                \/\/assert (list.size() == limit - 1);\n+                int last = length();\n+                list.add(substring(off, last));\n+                off = last;\n+                break;\n@@ -3148,14 +3158,14 @@\n-            \/\/ If no match was found, return this\n-            if (off == 0)\n-                return new String[]{this};\n-\n-            \/\/ Add remaining segment\n-            if (!limited || list.size() < limit)\n-                list.add(substring(off, length()));\n-\n-            \/\/ Construct result\n-            int resultSize = list.size();\n-            if (limit == 0) {\n-                while (resultSize > 0 && list.get(resultSize - 1).isEmpty()) {\n-                    resultSize--;\n-                }\n+        }\n+        \/\/ If no match was found, return this\n+        if (off == 0)\n+            return new String[]{this};\n+\n+        \/\/ Add remaining segment\n+        if (!limited || list.size() < limit)\n+            list.add(substring(off, length()));\n+\n+        \/\/ Construct result\n+        int resultSize = list.size();\n+        if (limit == 0) {\n+            while (resultSize > 0 && list.get(resultSize - 1).isEmpty()) {\n+                resultSize--;\n@@ -3163,2 +3173,0 @@\n-            String[] result = new String[resultSize];\n-            return list.subList(0, resultSize).toArray(result);\n@@ -3166,1 +3174,2 @@\n-        return Pattern.compile(regex).split(this, limit);\n+        String[] result = new String[resultSize];\n+        return list.subList(0, resultSize).toArray(result);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":41,"deletions":32,"binary":false,"changes":73,"status":"modified"}]}