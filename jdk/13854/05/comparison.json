{"files":[{"patch":"@@ -239,1 +239,1 @@\n-  iterate_roots(&doit, \/*is_relocating_pointers=*\/false);\n+  iterate_roots(&doit);\n@@ -393,10 +393,4 @@\n-void ArchiveBuilder::iterate_sorted_roots(MetaspaceClosure* it, bool is_relocating_pointers) {\n-  int i;\n-\n-  if (!is_relocating_pointers) {\n-    \/\/ Don't relocate _symbol, so we can safely call decrement_refcount on the\n-    \/\/ original symbols.\n-    int num_symbols = _symbols->length();\n-    for (i = 0; i < num_symbols; i++) {\n-      it->push(_symbols->adr_at(i));\n-    }\n+void ArchiveBuilder::iterate_sorted_roots(MetaspaceClosure* it) {\n+  int num_symbols = _symbols->length();\n+  for (int i = 0; i < num_symbols; i++) {\n+    it->push(_symbols->adr_at(i));\n@@ -406,1 +400,1 @@\n-  for (i = 0; i < num_klasses; i++) {\n+  for (int i = 0; i < num_klasses; i++) {\n@@ -410,1 +404,1 @@\n-  iterate_roots(it, is_relocating_pointers);\n+  iterate_roots(it);\n@@ -425,1 +419,1 @@\n-      _builder->remember_embedded_pointer_in_copied_obj(enclosing_ref(), ref);\n+      _builder->remember_embedded_pointer_in_gathered_obj(enclosing_ref(), ref);\n@@ -437,1 +431,1 @@\n-  remember_embedded_pointer_in_copied_obj(enclosing_ref, ref);\n+  remember_embedded_pointer_in_gathered_obj(enclosing_ref, ref);\n@@ -464,2 +458,2 @@\n-void ArchiveBuilder::remember_embedded_pointer_in_copied_obj(MetaspaceClosure::Ref* enclosing_ref,\n-                                                             MetaspaceClosure::Ref* ref) {\n+void ArchiveBuilder::remember_embedded_pointer_in_gathered_obj(MetaspaceClosure::Ref* enclosing_ref,\n+                                                               MetaspaceClosure::Ref* ref) {\n@@ -488,1 +482,1 @@\n-  iterate_sorted_roots(&doit, \/*is_relocating_pointers=*\/false);\n+  iterate_sorted_roots(&doit);\n@@ -642,0 +636,13 @@\n+\/\/ This is used by code that hand-assemble data structures, such as the LambdaProxyClassKey, that are\n+\/\/ not handled by MetaspaceClosure.\n+void ArchiveBuilder::write_pointer_in_buffer(address* ptr_location, address src_addr) {\n+  assert(is_in_buffer_space(ptr_location), \"must be\");\n+  if (src_addr == nullptr) {\n+    *ptr_location = nullptr;\n+    ArchivePtrMarker::clear_pointer(ptr_location);\n+  } else {\n+    *ptr_location = get_buffered_addr(src_addr);\n+    ArchivePtrMarker::mark_pointer(ptr_location);\n+  }\n+}\n+\n@@ -662,24 +669,0 @@\n-class RefRelocator: public MetaspaceClosure {\n-  ArchiveBuilder* _builder;\n-\n-public:\n-  RefRelocator(ArchiveBuilder* builder) : _builder(builder) {}\n-\n-  virtual bool do_ref(Ref* ref, bool read_only) {\n-    if (ref->not_null()) {\n-      ref->update(_builder->get_buffered_addr(ref->obj()));\n-      ArchivePtrMarker::mark_pointer(ref->addr());\n-    }\n-    return false; \/\/ Do not recurse.\n-  }\n-};\n-\n-void ArchiveBuilder::relocate_roots() {\n-  log_info(cds)(\"Relocating external roots ... \");\n-  ResourceMark rm;\n-  RefRelocator doit(this);\n-  iterate_sorted_roots(&doit, \/*is_relocating_pointers=*\/true);\n-  doit.finish();\n-  log_info(cds)(\"done\");\n-}\n-\n@@ -692,10 +675,0 @@\n-\/\/ We must relocate vmClasses::_klasses[] only after we have copied the\n-\/\/ java objects in during dump_java_heap_objects(): during the object copy, we operate on\n-\/\/ old objects which assert that their klass is the original klass.\n-void ArchiveBuilder::relocate_vm_classes() {\n-  log_info(cds)(\"Relocating vmClasses::_klasses[] ... \");\n-  ResourceMark rm;\n-  RefRelocator doit(this);\n-  vmClasses::metaspace_pointers_do(&doit);\n-}\n-\n@@ -718,1 +691,1 @@\n-    Klass* k = klasses()->at(i);\n+    Klass* k = get_buffered_addr(klasses()->at(i));\n@@ -801,0 +774,4 @@\n+  if (!is_in_buffer_space(p)) {\n+    \/\/ p must be a \"source\" address\n+    p = get_buffered_addr(p);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":30,"deletions":53,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  void iterate_sorted_roots(MetaspaceClosure* it, bool is_relocating_pointers);\n+  void iterate_sorted_roots(MetaspaceClosure* it);\n@@ -259,1 +259,1 @@\n-  virtual void iterate_roots(MetaspaceClosure* it, bool is_relocating_pointers) = 0;\n+  virtual void iterate_roots(MetaspaceClosure* it) = 0;\n@@ -306,0 +306,5 @@\n+  inline static u4 to_offset_u4(uintx offset) {\n+    guarantee(offset <= MAX_SHARED_DELTA, \"must be 32-bit offset \" INTPTR_FORMAT, offset);\n+    return (u4)offset;\n+  }\n+\n@@ -320,2 +325,1 @@\n-    guarantee(offset <= MAX_SHARED_DELTA, \"must be 32-bit offset \" INTPTR_FORMAT, offset);\n-    return (u4)offset;\n+    return to_offset_u4(offset);\n@@ -327,2 +331,1 @@\n-    guarantee(offset <= MAX_SHARED_DELTA, \"must be 32-bit offset \" INTPTR_FORMAT, offset);\n-    return (u4)offset;\n+    return to_offset_u4(offset);\n@@ -341,1 +344,1 @@\n-  void remember_embedded_pointer_in_copied_obj(MetaspaceClosure::Ref* enclosing_ref, MetaspaceClosure::Ref* ref);\n+  void remember_embedded_pointer_in_gathered_obj(MetaspaceClosure::Ref* enclosing_ref, MetaspaceClosure::Ref* ref);\n@@ -378,2 +381,0 @@\n-  void relocate_roots();\n-  void relocate_vm_classes();\n@@ -386,0 +387,5 @@\n+  void write_pointer_in_buffer(address* ptr_location, address src_addr);\n+  template <typename T> void write_pointer_in_buffer(T* ptr_location, T src_addr) {\n+    write_pointer_in_buffer((address*)ptr_location, (address)src_addr);\n+  }\n+\n@@ -387,0 +393,4 @@\n+  template <typename T> T get_buffered_addr(T src_addr) const {\n+    return (T)get_buffered_addr((address)src_addr);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -265,0 +265,15 @@\n+void WriteClosure::do_ptr(void** p) {\n+  \/\/ Write ptr into the archive; ptr can be:\n+  \/\/   (a) null                 -> written as 0\n+  \/\/   (b) a \"buffered\" address -> written as is\n+  \/\/   (c) a \"source\"   address -> convert to \"buffered\" and write\n+  \/\/ The common case is (c). E.g., when writing the vmClasses into the archive.\n+  \/\/ We have (b) only when we don't have a corresponding source object. E.g.,\n+  \/\/ the archived c++ vtable entries.\n+  address ptr = *(address*)p;\n+  if (ptr != nullptr && !ArchiveBuilder::current()->is_in_buffer_space(ptr)) {\n+    ptr = ArchiveBuilder::current()->get_buffered_addr(ptr);\n+  }\n+  _dump_region->append_intptr_t((intptr_t)ptr, true);\n+}\n+\n@@ -285,1 +300,1 @@\n-    _dump_region->append_intptr_t(*(intptr_t*)start, true);\n+    do_ptr((void**)start);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -187,3 +187,1 @@\n-  void do_ptr(void** p) {\n-    _dump_region->append_intptr_t((intptr_t)*p, true);\n-  }\n+  void do_ptr(void** p);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  case MetaspaceObj::SharedClassPathEntryType:\n@@ -271,1 +272,1 @@\n-            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_TYPES_DO\",\n+            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_TYPES_DO or the cases in this 'switch' statement\",\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-    relocate_roots();\n@@ -178,1 +177,1 @@\n-  virtual void iterate_roots(MetaspaceClosure* it, bool is_relocating_pointers) {\n+  virtual void iterate_roots(MetaspaceClosure* it) {\n@@ -219,1 +218,1 @@\n-    Klass* k = klasses()->at(i);\n+    Klass* k = get_buffered_addr(klasses()->at(i));\n@@ -234,1 +233,1 @@\n-\n+  assert(is_in_buffer_space(ik), \"method sorting must be done on buffered class, not original class\");\n@@ -318,3 +317,1 @@\n-  Array<u8>* table = FileMapInfo::saved_shared_path_table().table();\n-  SharedPathTable runtime_table(table, FileMapInfo::shared_path_table().size());\n-  _header->set_shared_path_table(runtime_table);\n+  _header->set_shared_path_table(FileMapInfo::shared_path_table().table());\n@@ -397,1 +394,0 @@\n-    FileMapInfo::clone_shared_path_table(current);\n@@ -421,1 +417,0 @@\n-  FileMapInfo::clone_shared_path_table(CHECK);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-  st->print_cr(\"- shared_path_table_size:         %d\", _shared_path_table_size);\n@@ -456,1 +455,0 @@\n-\n@@ -463,4 +461,1 @@\n-  it->push(&_table);\n-  for (int i=0; i<_size; i++) {\n-    path_at(i)->metaspace_pointers_do(it);\n-  }\n+  it->push(&_entries);\n@@ -470,25 +465,10 @@\n-  size_t entry_size = sizeof(SharedClassPathEntry);\n-  int num_entries = 0;\n-  num_entries += ClassLoader::num_boot_classpath_entries();\n-  num_entries += ClassLoader::num_app_classpath_entries();\n-  num_entries += ClassLoader::num_module_path_entries();\n-  num_entries += FileMapInfo::num_non_existent_class_paths();\n-  size_t bytes = entry_size * num_entries;\n-\n-  _table = MetadataFactory::new_array<u8>(loader_data, (int)bytes, CHECK);\n-  _size = num_entries;\n-}\n-\n-\/\/ Make a copy of the _shared_path_table for use during dynamic CDS dump.\n-\/\/ It is needed because some Java code continues to execute after dynamic dump has finished.\n-\/\/ However, during dynamic dump, we have modified FileMapInfo::_shared_path_table so\n-\/\/ FileMapInfo::shared_path(i) returns incorrect information in ClassLoader::record_result().\n-void FileMapInfo::copy_shared_path_table(ClassLoaderData* loader_data, TRAPS) {\n-  size_t entry_size = sizeof(SharedClassPathEntry);\n-  size_t bytes = entry_size * _shared_path_table.size();\n-\n-  Array<u8>* array = MetadataFactory::new_array<u8>(loader_data, (int)bytes, CHECK);\n-  _saved_shared_path_table = SharedPathTable(array, _shared_path_table.size());\n-\n-  for (int i = 0; i < _shared_path_table.size(); i++) {\n-    _saved_shared_path_table.path_at(i)->copy_from(shared_path(i), loader_data, CHECK);\n+  const int num_entries =\n+    ClassLoader::num_boot_classpath_entries() +\n+    ClassLoader::num_app_classpath_entries() +\n+    ClassLoader::num_module_path_entries() +\n+    FileMapInfo::num_non_existent_class_paths();\n+  _entries = MetadataFactory::new_array<SharedClassPathEntry*>(loader_data, num_entries, CHECK);\n+  for (int i = 0; i < num_entries; i++) {\n+    SharedClassPathEntry* ent =\n+      new (loader_data, SharedClassPathEntry::size(), MetaspaceObj::SharedClassPathEntryType, THREAD) SharedClassPathEntry;\n+    _entries->at_put(i, ent);\n@@ -496,18 +476,0 @@\n-  _saved_shared_path_table_array = array;\n-}\n-\n-void FileMapInfo::clone_shared_path_table(TRAPS) {\n-  Arguments::assert_is_dumping_archive();\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  ClassPathEntry* jrt = ClassLoader::get_jrt_entry();\n-\n-  assert(jrt != nullptr,\n-         \"No modular java runtime image present when allocating the CDS classpath entry table\");\n-\n-  if (_saved_shared_path_table_array != nullptr) {\n-    MetadataFactory::free_array<u8>(loader_data, _saved_shared_path_table_array);\n-    _saved_shared_path_table_array = nullptr;\n-  }\n-\n-  copy_shared_path_table(loader_data, CHECK);\n@@ -539,1 +501,0 @@\n-  clone_shared_path_table(CHECK);\n@@ -2331,8 +2292,0 @@\n-void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it, bool use_copy) {\n-  if (use_copy) {\n-    _saved_shared_path_table.metaspace_pointers_do(it);\n-  } else {\n-    _shared_path_table.metaspace_pointers_do(it);\n-  }\n-}\n-\n@@ -2343,2 +2296,0 @@\n-SharedPathTable FileMapInfo::_saved_shared_path_table;\n-Array<u8>*      FileMapInfo::_saved_shared_path_table_array = nullptr;\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":11,"deletions":60,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -51,1 +52,1 @@\n-class SharedClassPathEntry {\n+class SharedClassPathEntry : public MetaspaceObj {\n@@ -72,0 +73,7 @@\n+  SharedClassPathEntry() : _type(0), _is_module_path(false),\n+                           _from_class_path_attr(false), _timestamp(0),\n+                           _filesize(0), _name(nullptr), _manifest(nullptr) {}\n+  static int size() {\n+    static_assert(is_aligned(sizeof(SharedClassPathEntry), wordSize), \"must be\");\n+    return (int)(sizeof(SharedClassPathEntry) \/ wordSize);\n+  }\n@@ -75,0 +83,1 @@\n+  MetaspaceObj::Type type() const { return SharedClassPathEntryType; }\n@@ -109,2 +118,1 @@\n-  Array<u8>* _table;\n-  int _size;\n+  Array<SharedClassPathEntry*>* _entries;\n@@ -112,2 +120,2 @@\n-  SharedPathTable() : _table(nullptr), _size(0) {}\n-  SharedPathTable(Array<u8>* table, int size) : _table(table), _size(size) {}\n+  SharedPathTable() : _entries(nullptr) {}\n+  SharedPathTable(Array<SharedClassPathEntry*>* entries) : _entries(entries) {}\n@@ -119,1 +127,1 @@\n-    return _size;\n+    return _entries == nullptr ? 0 : _entries->length();\n@@ -122,7 +130,1 @@\n-    if (index < 0) {\n-      return nullptr;\n-    }\n-    assert(index < _size, \"sanity\");\n-    char* p = (char*)_table->data();\n-    p += sizeof(SharedClassPathEntry) * index;\n-    return (SharedClassPathEntry*)p;\n+    return _entries->at(index);\n@@ -130,2 +132,2 @@\n-  Array<u8>* table() {return _table;}\n-  void set_table(Array<u8>* table) {_table = table;}\n+  Array<SharedClassPathEntry*>* table() {return _entries;}\n+  void set_table(Array<SharedClassPathEntry*>* table) {_entries = table;}\n@@ -218,1 +220,0 @@\n-  int    _shared_path_table_size;\n@@ -293,1 +294,0 @@\n-    _shared_path_table_size = table.size();\n@@ -302,2 +302,2 @@\n-    return SharedPathTable((Array<u8>*)from_mapped_offset(_shared_path_table_offset),\n-                           _shared_path_table_size);\n+    return SharedPathTable((Array<SharedClassPathEntry*>*)\n+                           from_mapped_offset(_shared_path_table_offset));\n@@ -341,1 +341,0 @@\n-  \/\/ TODO: Probably change the following to be non-static\n@@ -343,2 +342,0 @@\n-  static SharedPathTable       _saved_shared_path_table;\n-  static Array<u8>*            _saved_shared_path_table_array;  \/\/ remember the table array for cleanup\n@@ -364,4 +361,0 @@\n-  static SharedPathTable saved_shared_path_table() {\n-    assert(_saved_shared_path_table.size() >= 0, \"Sanity check\");\n-    return _saved_shared_path_table;\n-  }\n@@ -370,1 +363,3 @@\n-  static void metaspace_pointers_do(MetaspaceClosure* it, bool use_copy = true);\n+  static void metaspace_pointers_do(MetaspaceClosure* it) {\n+    _shared_path_table.metaspace_pointers_do(it);\n+  }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -49,7 +50,9 @@\n-void LambdaProxyClassKey::mark_pointers() {\n-  ArchivePtrMarker::mark_pointer(&_caller_ik);\n-  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n-  ArchivePtrMarker::mark_pointer(&_invoked_name);\n-  ArchivePtrMarker::mark_pointer(&_invoked_type);\n-  ArchivePtrMarker::mark_pointer(&_member_method);\n-  ArchivePtrMarker::mark_pointer(&_method_type);\n+void LambdaProxyClassKey::init_for_archive(LambdaProxyClassKey& dumptime_key) {\n+  ArchiveBuilder* b = ArchiveBuilder::current();\n+\n+  b->write_pointer_in_buffer(&_caller_ik,                dumptime_key._caller_ik);\n+  b->write_pointer_in_buffer(&_instantiated_method_type, dumptime_key._instantiated_method_type);\n+  b->write_pointer_in_buffer(&_invoked_name,             dumptime_key._invoked_name);\n+  b->write_pointer_in_buffer(&_invoked_type,             dumptime_key._invoked_type);\n+  b->write_pointer_in_buffer(&_member_method,            dumptime_key._member_method);\n+  b->write_pointer_in_buffer(&_method_type,              dumptime_key._method_type);\n@@ -65,0 +68,23 @@\n+\n+#ifndef PRODUCT\n+void LambdaProxyClassKey::print_on(outputStream* st) const {\n+  ResourceMark rm;\n+  st->print_cr(\"LambdaProxyClassKey       : \" INTPTR_FORMAT \" hash: %0x08x\", p2i(this), hash());\n+  st->print_cr(\"_caller_ik                : %s\", _caller_ik->external_name());\n+  st->print_cr(\"_instantiated_method_type : %s\", _instantiated_method_type->as_C_string());\n+  st->print_cr(\"_invoked_name             : %s\", _invoked_name->as_C_string());\n+  st->print_cr(\"_invoked_type             : %s\", _invoked_type->as_C_string());\n+  st->print_cr(\"_member_method            : %s\", _member_method->name()->as_C_string());\n+  st->print_cr(\"_method_type              : %s\", _method_type->as_C_string());\n+}\n+\n+void RunTimeLambdaProxyClassInfo::print_on(outputStream* st) const {\n+  _key.print_on(st);\n+}\n+#endif\n+\n+void RunTimeLambdaProxyClassInfo::init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+  _key.init_for_archive(key);\n+  ArchiveBuilder::current()->write_pointer_in_buffer(&_proxy_klass_head,\n+                                                     info._proxy_klasses->at(0));\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class outputStream;\n@@ -76,1 +77,0 @@\n-  void mark_pointers();\n@@ -105,0 +105,6 @@\n+\n+  void init_for_archive(LambdaProxyClassKey& dumptime_key);\n+\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const;\n+#endif\n@@ -144,6 +150,1 @@\n-  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    _key = key;\n-    _key.mark_pointers();\n-    _proxy_klass_head = info._proxy_klasses->at(0);\n-    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n-  }\n+  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info);\n@@ -157,0 +158,3 @@\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const;\n+#endif\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -454,2 +454,2 @@\n-  virtual void iterate_roots(MetaspaceClosure* it, bool is_relocating_pointers) {\n-    FileMapInfo::metaspace_pointers_do(it, false);\n+  virtual void iterate_roots(MetaspaceClosure* it) {\n+    FileMapInfo::metaspace_pointers_do(it);\n@@ -510,1 +510,0 @@\n-  \/\/ Dump supported java heap objects\n@@ -512,2 +511,0 @@\n-\n-  builder.relocate_roots();\n@@ -516,2 +513,0 @@\n-  builder.relocate_vm_classes();\n-\n@@ -591,2 +586,1 @@\n-    \/\/ tolerate this. (Note that unregistered classes are loaded by the null\n-    \/\/ loader during DumpSharedSpaces).\n+    \/\/ tolerate this.\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n-  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n-  _klass = info._klass;\n+  builder->write_pointer_in_buffer(&_klass, info._klass);\n+\n@@ -65,2 +65,1 @@\n-    InstanceKlass* n_h = info.nest_host();\n-    set_nest_host(n_h);\n+    builder->write_pointer_in_buffer(nest_host_addr(), info.nest_host());\n@@ -76,2 +75,0 @@\n-\n-  ArchivePtrMarker::mark_pointer(&_klass);\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,4 +183,0 @@\n-  void set_nest_host(InstanceKlass* k) {\n-    *nest_host_addr() = k;\n-    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n-  }\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1169,13 +1169,10 @@\n-    if (len > 1) {\n-      for (int i = 0; i < len-1; i++) {\n-        InstanceKlass* ok0 = info._proxy_klasses->at(i+0); \/\/ this is original klass\n-        InstanceKlass* ok1 = info._proxy_klasses->at(i+1); \/\/ this is original klass\n-        assert(ArchiveBuilder::current()->is_in_buffer_space(ok0), \"must be\");\n-        assert(ArchiveBuilder::current()->is_in_buffer_space(ok1), \"must be\");\n-        InstanceKlass* bk0 = ok0;\n-        InstanceKlass* bk1 = ok1;\n-        assert(bk0->next_link() == 0, \"must be called after Klass::remove_unshareable_info()\");\n-        assert(bk1->next_link() == 0, \"must be called after Klass::remove_unshareable_info()\");\n-        bk0->set_next_link(bk1);\n-        bk1->set_lambda_proxy_is_available();\n-        ArchivePtrMarker::mark_pointer(bk0->next_link_addr());\n+    InstanceKlass* last_buff_k = nullptr;\n+\n+    for (int i = len - 1; i >= 0; i--) {\n+      InstanceKlass* orig_k = info._proxy_klasses->at(i);\n+      InstanceKlass* buff_k = ArchiveBuilder::current()->get_buffered_addr(orig_k);\n+      assert(ArchiveBuilder::current()->is_in_buffer_space(buff_k), \"must be\");\n+      buff_k->set_lambda_proxy_is_available();\n+      buff_k->set_next_link(last_buff_k);\n+      if (last_buff_k != nullptr) {\n+        ArchivePtrMarker::mark_pointer(buff_k->next_link_addr());\n@@ -1183,0 +1180,1 @@\n+      last_buff_k = buff_k;\n@@ -1184,1 +1182,0 @@\n-    info._proxy_klasses->at(0)->set_lambda_proxy_is_available();\n@@ -1208,0 +1205,1 @@\n+      name = ArchiveBuilder::current()->get_buffered_addr(name);\n@@ -1221,1 +1219,2 @@\n-      RunTimeClassInfo::set_for(info._klass, record);\n+      InstanceKlass* buffered_klass = ArchiveBuilder::current()->get_buffered_addr(info._klass);\n+      RunTimeClassInfo::set_for(buffered_klass, record);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -373,0 +373,1 @@\n+  f(SharedClassPathEntry) \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}