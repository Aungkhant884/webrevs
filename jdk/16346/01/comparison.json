{"files":[{"patch":"@@ -89,1 +89,1 @@\n-    __ corrected_idivl(dreg, lreg, rreg, is_irem);\n+    __ corrected_idivl(dreg, lreg, rreg, is_irem, \/* is_signed *\/ true);\n@@ -175,2 +175,6 @@\n-      case lir_div: __ corrected_idivq(dest->as_register_lo(), lreg_lo, rreg_lo, false); break;\n-      case lir_rem: __ corrected_idivq(dest->as_register_lo(), lreg_lo, rreg_lo, true); break;\n+      case lir_div: __ corrected_idivq(dest->as_register_lo(), lreg_lo, rreg_lo,\n+                                       \/* want_remainder *\/ false, \/* is_signed *\/ true);\n+                    break;\n+      case lir_rem: __ corrected_idivq(dest->as_register_lo(), lreg_lo, rreg_lo,\n+                                       \/* want_remainder *\/ true, \/* is_signed *\/ true);\n+                    break;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arith_riscv.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2389,1 +2389,1 @@\n-                                    bool want_remainder)\n+                                    bool want_remainder, bool is_signed)\n@@ -2405,1 +2405,5 @@\n-    divw(result, rs1, rs2);\n+    if (is_signed) {\n+      divw(result, rs1, rs2);\n+    } else {\n+      divuw(result, rs1, rs2);\n+    }\n@@ -2413,1 +2417,1 @@\n-                                    bool want_remainder)\n+                                    bool want_remainder, bool is_signed)\n@@ -2428,1 +2432,5 @@\n-    div(result, rs1, rs2);\n+    if (is_signed) {\n+      div(result, rs1, rs2);\n+    } else {\n+      divu(result, rs1, rs2);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-                      bool want_remainder);\n+                      bool want_remainder, bool is_signed);\n@@ -246,1 +246,1 @@\n-                      bool want_remainder);\n+                      bool want_remainder, bool is_signed);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2446,1 +2446,9 @@\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, false);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_divuw(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n@@ -2454,1 +2462,9 @@\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, false);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n+  %}\n+\n+  enc_class riscv_enc_divu(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ false, \/* is_signed *\/ false);\n@@ -2462,1 +2478,1 @@\n-    __ corrected_idivl(dst_reg, src1_reg, src2_reg, true);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n@@ -2470,1 +2486,1 @@\n-    __ corrected_idivq(dst_reg, src1_reg, src2_reg, true);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n@@ -6676,0 +6692,9 @@\n+instruct UdivI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{\n+  match(Set dst (UDivI src1 src2));\n+  ins_cost(IDIVSI_COST);\n+  format %{ \"divuw  $dst, $src1, $src2\\t#@UdivI\"%}\n+\n+  ins_encode(riscv_enc_divuw(dst, src1, src2));\n+  ins_pipe(idiv_reg_reg);\n+%}\n+\n@@ -6698,0 +6723,20 @@\n+instruct UdivL(iRegLNoSp dst, iRegL src1, iRegL src2) %{\n+  match(Set dst (UDivL src1 src2));\n+  ins_cost(IDIVDI_COST);\n+\n+  format %{\n+    \"bltz $src2, Lltz\\t#@UdivL\\n\\t\"\n+    \"divu $dst, $src1, $src2\\n\\t\"\n+    \"j    Ldone\\n\\t\"\n+    \"Lltz:\"\n+    \"sub  $dst, $src1, $src2\\n\\t\"\n+    \"not  $dst, $dst\\n\\t\"\n+    \"and  $dst, $dst, $src1\\n\\t\"\n+    \"srli $dst, $dst, 63\\n\\t\"\n+    \"Ldone:\\t#@UdivL\"\n+  %}\n+\n+  ins_encode(riscv_enc_divu(dst, src1, src2));\n+  ins_pipe(ldiv_reg_reg);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1321,1 +1321,1 @@\n-  __ corrected_idivl(x10, x11, x10, \/* want_remainder *\/ false);\n+  __ corrected_idivl(x10, x11, x10, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n@@ -1334,1 +1334,1 @@\n-  __ corrected_idivl(x10, x11, x10, \/* want_remainder *\/ true);\n+  __ corrected_idivl(x10, x11, x10, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n@@ -1353,1 +1353,1 @@\n-  __ corrected_idivq(x10, x11, x10, \/* want_remainder *\/ false);\n+  __ corrected_idivq(x10, x11, x10, \/* want_remainder *\/ false, \/* is_signed *\/ true);\n@@ -1366,1 +1366,1 @@\n-  __ corrected_idivq(x10, x11, x10, \/* want_remainder *\/ true);\n+  __ corrected_idivq(x10, x11, x10, \/* want_remainder *\/ true, \/* is_signed *\/ true);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}