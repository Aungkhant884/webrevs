{"files":[{"patch":"@@ -2389,1 +2389,1 @@\n-                                    bool want_remainder)\n+                                    bool want_remainder, bool is_signed)\n@@ -2405,1 +2405,5 @@\n-    divw(result, rs1, rs2);\n+    if (is_signed) {\n+      divw(result, rs1, rs2);\n+    } else {\n+      divuw(result, rs1, rs2);\n+    }\n@@ -2413,1 +2417,1 @@\n-                                    bool want_remainder)\n+                                    bool want_remainder, bool is_signed)\n@@ -2428,1 +2432,14 @@\n-    div(result, rs1, rs2);\n+    if (is_signed) {\n+      div(result, rs1, rs2);\n+    } else {\n+      Label Lltz, Ldone;\n+      bltz(rs2, Lltz);\n+      divu(result, rs1, rs2);\n+      j(Ldone);\n+      bind(Lltz); \/\/ For the algorithm details, check j.l.Long::divideUnsigned\n+      sub(result, rs1, rs2);\n+      notr(result, result);\n+      andr(result, result, rs1);\n+      srli(result, result, 63);\n+      bind(Ldone);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-                      bool want_remainder);\n+                      bool want_remainder, bool is_signed = true);\n@@ -246,1 +246,1 @@\n-                      bool want_remainder);\n+                      bool want_remainder, bool is_signed = true);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2449,0 +2449,8 @@\n+  enc_class riscv_enc_divuw(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivl(dst_reg, src1_reg, src2_reg, false, false);\n+  %}\n+\n@@ -2457,0 +2465,8 @@\n+  enc_class riscv_enc_divu(iRegI dst, iRegI src1, iRegI src2) %{\n+    C2_MacroAssembler _masm(&cbuf);\n+    Register dst_reg = as_Register($dst$$reg);\n+    Register src1_reg = as_Register($src1$$reg);\n+    Register src2_reg = as_Register($src2$$reg);\n+    __ corrected_idivq(dst_reg, src1_reg, src2_reg, false, false);\n+  %}\n+\n@@ -6676,0 +6692,9 @@\n+instruct UdivI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{\n+  match(Set dst (UDivI src1 src2));\n+  ins_cost(IDIVSI_COST);\n+  format %{ \"divuw  $dst, $src1, $src2\\t#@UdivI\"%}\n+\n+  ins_encode(riscv_enc_divuw(dst, src1, src2));\n+  ins_pipe(idiv_reg_reg);\n+%}\n+\n@@ -6698,0 +6723,20 @@\n+instruct UdivL(iRegLNoSp dst, iRegL src1, iRegL src2) %{\n+  match(Set dst (UDivL src1 src2));\n+  ins_cost(IDIVDI_COST);\n+\n+  format %{\n+    \"bltz $src2, Lltz\\t#@UdivL\\n\\t\"\n+    \"divu $dst, $src1, $src2\\n\\t\"\n+    \"j    Ldone\\n\\t\"\n+    \"Lltz:\"\n+    \"sub  $dst, $src1, $src2\\n\\t\"\n+    \"not  $dst, $dst\\n\\t\"\n+    \"and  $dst, $dst, $src1\\n\\t\"\n+    \"srli $dst, $dst, 63\\n\\t\"\n+    \"Ldone:\\t#@UdivL\"\n+  %}\n+\n+  ins_encode(riscv_enc_divu(dst, src1, src2));\n+  ins_pipe(ldiv_reg_reg);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}