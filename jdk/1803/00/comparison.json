{"files":[{"patch":"@@ -117,1 +117,1 @@\n-void ConstantTable::emit(CodeBuffer& cb) {\n+bool ConstantTable::emit(CodeBuffer& cb) const {\n@@ -146,0 +146,6 @@\n+      if (constant_addr == NULL) {\n+        return false;\n+      }\n+      assert((constant_addr - _masm.code()->consts()->start()) == con.offset(),\n+             \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n+\n@@ -147,3 +153,6 @@\n-      for (uint i = 1; i < n->outcnt(); i++) {\n-        address temp_addr = _masm.address_constant(dummy + i);\n-        assert(temp_addr, \"consts section too small\");\n+      address last_addr;\n+      for (uint j = 1; j < n->outcnt(); j++) {\n+        last_addr = _masm.address_constant(dummy + j);\n+        if (last_addr == NULL) {\n+          return false;\n+        }\n@@ -151,1 +160,10 @@\n-      break;\n+#ifdef ASSERT\n+      address start = _masm.code()->consts()->start();\n+      address new_constant_addr = last_addr - ((n->outcnt() - 1) * sizeof(address));\n+      \/\/ Expanding the jump-table could result in an expansion of the const code section.\n+      \/\/ In that case, we need to check if the new constant address matches the offset.\n+      assert((constant_addr - start == con.offset()) || (new_constant_addr - start == con.offset()),\n+             \"must be: %d == %d or %d == %d (after an expansion)\", (int)(constant_addr - start), (int)(con.offset()),\n+             (int)(new_constant_addr - start), (int)(con.offset()));\n+#endif\n+      continue; \/\/ Loop\n@@ -161,1 +179,4 @@\n-    assert(constant_addr, \"consts section too small\");\n+\n+    if (constant_addr == NULL) {\n+      return false;\n+    }\n@@ -163,1 +184,1 @@\n-            \"must be: %d == %d\", (int) (constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n+            \"must be: %d == %d\", (int)(constant_addr - _masm.code()->consts()->start()), (int)(con.offset()));\n@@ -165,0 +186,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  void emit(CodeBuffer& cb);\n+  bool emit(CodeBuffer& cb) const;\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1428,1 +1428,4 @@\n-    constant_table().emit(*cb);\n+    if (!constant_table().emit(*cb)) {\n+      C->record_failure(\"consts section overflow\");\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8257513\n+ * @summary Stress testing code buffers resulted in an assertion failure due to not taking expand calls into account\n+ *          which can fail more often with -XX:+StressCodeBuffers. Perform some more sanity flag testing.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+StressCodeBuffers compiler.codecache.TestStressCodeBuffers\n+ * @run main\/othervm -Xcomp -XX:+StressCodeBuffers compiler.codecache.TestStressCodeBuffers\n+ *\/\n+\n+package compiler.codecache;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class TestStressCodeBuffers {\n+\n+    static MethodHandle permh;\n+\n+    public static void main(String[] args) throws Exception {\n+        test();\n+    }\n+\n+    public static void test() throws Exception {\n+        MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n+        MethodHandle mh = lookup.findStatic(TestStressCodeBuffers.class, \"bar\",\n+                                            MethodType.methodType(void.class, int.class, long.class));\n+        permh = MethodHandles.permuteArguments(mh, mh.type(), 0, 1); \/\/ Triggers assertion failure\n+    }\n+\n+    public static void bar(int x, long y) {}\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/TestStressCodeBuffers.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}