{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-\n+import java.util.function.Predicate;\n@@ -41,1 +41,0 @@\n-import com.sun.tools.javac.util.Filter;\n@@ -55,1 +54,1 @@\n-    private static final Filter<Symbol> VALIDATOR = sym -> {\n+    private static final Predicate<Symbol> VALIDATOR = sym -> {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacScope.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.function.Predicate;\n@@ -73,1 +74,1 @@\n-    public final Iterable<Symbol> getSymbols(Filter<Symbol> sf) {\n+    public final Iterable<Symbol> getSymbols(Predicate<Symbol> sf) {\n@@ -87,1 +88,1 @@\n-    public abstract Iterable<Symbol> getSymbols(Filter<Symbol> sf, LookupKind lookupKind);\n+    public abstract Iterable<Symbol> getSymbols(Predicate<Symbol> sf, LookupKind lookupKind);\n@@ -98,1 +99,1 @@\n-    public final Iterable<Symbol> getSymbolsByName(final Name name, final Filter<Symbol> sf) {\n+    public final Iterable<Symbol> getSymbolsByName(final Name name, final Predicate<Symbol> sf) {\n@@ -112,1 +113,1 @@\n-    public abstract Iterable<Symbol> getSymbolsByName(final Name name, final Filter<Symbol> sf,\n+    public abstract Iterable<Symbol> getSymbolsByName(final Name name, final Predicate<Symbol> sf,\n@@ -125,1 +126,1 @@\n-    public Symbol findFirst(Name name, Filter<Symbol> sf) {\n+    public Symbol findFirst(Name name, Predicate<Symbol> sf) {\n@@ -133,1 +134,1 @@\n-    public boolean anyMatch(Filter<Symbol> filter) {\n+    public boolean anyMatch(Predicate<Symbol> filter) {\n@@ -163,1 +164,1 @@\n-    private static final Filter<Symbol> noFilter = null;\n+    private static final Predicate<Symbol> noFilter = null;\n@@ -517,1 +518,1 @@\n-        protected Entry lookup(Name name, Filter<Symbol> sf) {\n+        protected Entry lookup(Name name, Predicate<Symbol> sf) {\n@@ -521,1 +522,1 @@\n-            while (e.scope != null && (e.sym.name != name || (sf != null && !sf.accepts(e.sym))))\n+            while (e.scope != null && (e.sym.name != name || (sf != null && !sf.test(e.sym))))\n@@ -526,1 +527,1 @@\n-        public Symbol findFirst(Name name, Filter<Symbol> sf) {\n+        public Symbol findFirst(Name name, Predicate<Symbol> sf) {\n@@ -566,1 +567,1 @@\n-        public boolean anyMatch(Filter<Symbol> sf) {\n+        public boolean anyMatch(Predicate<Symbol> sf) {\n@@ -570,1 +571,1 @@\n-        public Iterable<Symbol> getSymbols(final Filter<Symbol> sf,\n+        public Iterable<Symbol> getSymbols(final Predicate<Symbol> sf,\n@@ -619,1 +620,1 @@\n-                    while (currEntry != null && sf != null && !sf.accepts(currEntry.sym)) {\n+                    while (currEntry != null && sf != null && !sf.test(currEntry.sym)) {\n@@ -627,1 +628,1 @@\n-                                                 final Filter<Symbol> sf,\n+                                                 final Predicate<Symbol> sf,\n@@ -732,2 +733,2 @@\n-        public Entry next(Filter<Symbol> sf) {\n-            if (shadowed.sym == null || sf == null || sf.accepts(shadowed.sym)) return shadowed;\n+        public Entry next(Predicate<Symbol> sf) {\n+            if (shadowed.sym == null || sf == null || sf.test(shadowed.sym)) return shadowed;\n@@ -818,1 +819,1 @@\n-        public Iterable<Symbol> getSymbolsByName(Name name, Filter<Symbol> sf, LookupKind lookupKind) {\n+        public Iterable<Symbol> getSymbolsByName(Name name, Predicate<Symbol> sf, LookupKind lookupKind) {\n@@ -851,2 +852,2 @@\n-            public Iterable<Symbol> getSymbols(Filter<Symbol> sf, LookupKind lookupKind) {\n-                return sf == null || sf.accepts(sym) ? content : Collections.emptyList();\n+            public Iterable<Symbol> getSymbols(Predicate<Symbol> sf, LookupKind lookupKind) {\n+                return sf == null || sf.test(sym) ? content : Collections.emptyList();\n@@ -857,1 +858,1 @@\n-                                                     Filter<Symbol> sf,\n+                                                     Predicate<Symbol> sf,\n@@ -860,1 +861,1 @@\n-                       (sf == null || sf.accepts(sym)) ? content : Collections.emptyList();\n+                       (sf == null || sf.test(sym)) ? content : Collections.emptyList();\n@@ -931,1 +932,1 @@\n-        public Iterable<Symbol> getSymbols(final Filter<Symbol> sf, final LookupKind lookupKind) {\n+        public Iterable<Symbol> getSymbols(final Predicate<Symbol> sf, final LookupKind lookupKind) {\n@@ -954,1 +955,1 @@\n-                                                 final Filter<Symbol> sf,\n+                                                 final Predicate<Symbol> sf,\n@@ -1078,1 +1079,1 @@\n-        public Iterable<Symbol> getSymbols(final Filter<Symbol> sf,\n+        public Iterable<Symbol> getSymbols(final Predicate<Symbol> sf,\n@@ -1088,1 +1089,1 @@\n-                                                 final Filter<Symbol> sf,\n+                                                 final Predicate<Symbol> sf,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Scope.java","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.function.Predicate;\n@@ -2164,1 +2165,1 @@\n-            public static final Filter<Symbol> implementation_filter = s ->\n+            public static final Predicate<Symbol> implementation_filter = s ->\n@@ -2167,1 +2168,1 @@\n-        public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter<Symbol> implFilter) {\n+        public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Predicate<Symbol> implFilter) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -647,1 +648,1 @@\n-    public static List<Type> filter(List<Type> ts, Filter<Type> tf) {\n+    public static List<Type> filter(List<Type> ts, Predicate<Type> tf) {\n@@ -650,1 +651,1 @@\n-            if (tf.accepts(t)) {\n+            if (tf.test(t)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.function.Predicate;\n@@ -947,2 +948,4 @@\n-        private Filter<Symbol> bridgeFilter = new Filter<Symbol>() {\n-            public boolean accepts(Symbol t) {\n+        \/\/ Use anonymous class instead of lambda expression intentionally,\n+        \/\/ because the variable `names` has modifier: final.\n+        private Predicate<Symbol> bridgeFilter = new Predicate<Symbol>() {\n+            public boolean test(Symbol t) {\n@@ -955,0 +958,1 @@\n+\n@@ -980,1 +984,1 @@\n-    class DescriptorFilter implements Filter<Symbol> {\n+    class DescriptorFilter implements Predicate<Symbol> {\n@@ -989,1 +993,1 @@\n-       public boolean accepts(Symbol sym) {\n+       public boolean test(Symbol sym) {\n@@ -2933,1 +2937,1 @@\n-            final Filter<Symbol> implFilter;\n+            final Predicate<Symbol> implFilter;\n@@ -2938,1 +2942,1 @@\n-                    Filter<Symbol> scopeFilter,\n+                    Predicate<Symbol> scopeFilter,\n@@ -2947,1 +2951,1 @@\n-            boolean matches(Filter<Symbol> scopeFilter, boolean checkResult, int mark) {\n+            boolean matches(Predicate<Symbol> scopeFilter, boolean checkResult, int mark) {\n@@ -2954,1 +2958,1 @@\n-        MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter<Symbol> implFilter) {\n+        MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Predicate<Symbol> implFilter) {\n@@ -2974,1 +2978,1 @@\n-        private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter<Symbol> implFilter) {\n+        private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Predicate<Symbol> implFilter) {\n@@ -2999,1 +3003,1 @@\n-    public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter<Symbol> implFilter) {\n+    public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Predicate<Symbol> implFilter) {\n@@ -3020,2 +3024,2 @@\n-            Filter<Symbol> combine(Filter<Symbol> sf) {\n-                return s -> !s.owner.isInterface() && (sf == null || sf.accepts(s));\n+            Predicate<Symbol> combine(Predicate<Symbol> sf) {\n+                return s -> !s.owner.isInterface() && (sf == null || sf.test(s));\n@@ -3025,1 +3029,1 @@\n-            public Iterable<Symbol> getSymbols(Filter<Symbol> sf, LookupKind lookupKind) {\n+            public Iterable<Symbol> getSymbols(Predicate<Symbol> sf, LookupKind lookupKind) {\n@@ -3030,1 +3034,1 @@\n-            public Iterable<Symbol> getSymbolsByName(Name name, Filter<Symbol> sf, LookupKind lookupKind) {\n+            public Iterable<Symbol> getSymbolsByName(Name name, Predicate<Symbol> sf, LookupKind lookupKind) {\n@@ -3190,1 +3194,1 @@\n-            Filter<Symbol> filter = new MethodFilter(ms, site);\n+            Predicate<Symbol> filter = new MethodFilter(ms, site);\n@@ -3223,1 +3227,1 @@\n-            private class MethodFilter implements Filter<Symbol> {\n+            private class MethodFilter implements Predicate<Symbol> {\n@@ -3233,1 +3237,2 @@\n-                public boolean accepts(Symbol s) {\n+                @Override\n+                public boolean test(Symbol s) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.Predicate;\n@@ -2140,1 +2141,1 @@\n-    private Filter<Symbol> equalsHasCodeFilter = s -> MethodSymbol.implementation_filter.accepts(s) &&\n+    private Predicate<Symbol> equalsHasCodeFilter = s -> MethodSymbol.implementation_filter.test(s) &&\n@@ -2219,2 +2220,2 @@\n-        return (cf.accepts(s1) &&\n-                cf.accepts(s2) &&\n+        return (cf.test(s1) &&\n+                cf.test(s2) &&\n@@ -2586,1 +2587,1 @@\n-     private class ClashFilter implements Filter<Symbol> {\n+     private class ClashFilter implements Predicate<Symbol> {\n@@ -2599,1 +2600,2 @@\n-         public boolean accepts(Symbol s) {\n+         @Override\n+         public boolean test(Symbol s) {\n@@ -2650,1 +2652,1 @@\n-     private class DefaultMethodClashFilter implements Filter<Symbol> {\n+     private class DefaultMethodClashFilter implements Predicate<Symbol> {\n@@ -2658,1 +2660,2 @@\n-         public boolean accepts(Symbol s) {\n+         @Override\n+         public boolean test(Symbol s) {\n@@ -3805,1 +3808,1 @@\n-        Filter<Symbol> duplicates = candidate -> candidate != sym && !candidate.type.isErroneous();\n+        Predicate<Symbol> duplicates = candidate -> candidate != sym && !candidate.type.isErroneous();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import java.util.function.Predicate;\n@@ -1123,1 +1124,1 @@\n-        final Filter<JCTree> treeFilter;\n+        final Predicate<JCTree> treeFilter;\n@@ -1132,1 +1133,1 @@\n-                if (treeFilter.accepts(tree)) {\n+                if (treeFilter.test(tree)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -703,1 +704,1 @@\n-                Filter<Symbol> enumConstantFilter =\n+                Predicate<Symbol> enumConstantFilter =\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,1 @@\n+import java.util.function.Predicate;\n@@ -1232,1 +1233,1 @@\n-    protected static class BoundFilter implements Filter<Type> {\n+    protected static class BoundFilter implements Predicate<Type> {\n@@ -1241,1 +1242,1 @@\n-        public boolean accepts(Type t) {\n+        public boolean test(Type t) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.Predicate;\n@@ -53,1 +54,0 @@\n-import com.sun.tools.javac.util.Filter;\n@@ -150,1 +150,1 @@\n-    private List<Type> filterVars(Filter<UndetVar> fu) {\n+    private List<Type> filterVars(Predicate<UndetVar> fu) {\n@@ -154,1 +154,1 @@\n-            if (fu.accepts(uv)) {\n+            if (fu.test(uv)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1801,1 +1801,1 @@\n-        class LookupFilter implements Filter<Symbol> {\n+        class LookupFilter implements Predicate<Symbol> {\n@@ -1809,1 +1809,2 @@\n-            public boolean accepts(Symbol s) {\n+            @Override\n+            public boolean test(Symbol s) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import com.sun.tools.javac.util.Filter;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/FilteredMemberList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.function.Predicate;\n@@ -278,1 +279,1 @@\n-    protected boolean peekToken(Filter<TokenKind> tk) {\n+    protected boolean peekToken(Predicate<TokenKind> tk) {\n@@ -282,2 +283,2 @@\n-    protected boolean peekToken(int lookahead, Filter<TokenKind> tk) {\n-        return tk.accepts(S.token(lookahead + 1).kind);\n+    protected boolean peekToken(int lookahead, Predicate<TokenKind> tk) {\n+        return tk.test(S.token(lookahead + 1).kind);\n@@ -286,1 +287,1 @@\n-    protected boolean peekToken(Filter<TokenKind> tk1, Filter<TokenKind> tk2) {\n+    protected boolean peekToken(Predicate<TokenKind> tk1, Predicate<TokenKind> tk2) {\n@@ -290,3 +291,3 @@\n-    protected boolean peekToken(int lookahead, Filter<TokenKind> tk1, Filter<TokenKind> tk2) {\n-        return tk1.accepts(S.token(lookahead + 1).kind) &&\n-                tk2.accepts(S.token(lookahead + 2).kind);\n+    protected boolean peekToken(int lookahead, Predicate<TokenKind> tk1, Predicate<TokenKind> tk2) {\n+        return tk1.test(S.token(lookahead + 1).kind) &&\n+                tk2.test(S.token(lookahead + 2).kind);\n@@ -295,1 +296,1 @@\n-    protected boolean peekToken(Filter<TokenKind> tk1, Filter<TokenKind> tk2, Filter<TokenKind> tk3) {\n+    protected boolean peekToken(Predicate<TokenKind> tk1, Predicate<TokenKind> tk2, Predicate<TokenKind> tk3) {\n@@ -299,4 +300,4 @@\n-    protected boolean peekToken(int lookahead, Filter<TokenKind> tk1, Filter<TokenKind> tk2, Filter<TokenKind> tk3) {\n-        return tk1.accepts(S.token(lookahead + 1).kind) &&\n-                tk2.accepts(S.token(lookahead + 2).kind) &&\n-                tk3.accepts(S.token(lookahead + 3).kind);\n+    protected boolean peekToken(int lookahead, Predicate<TokenKind> tk1, Predicate<TokenKind> tk2, Predicate<TokenKind> tk3) {\n+        return tk1.test(S.token(lookahead + 1).kind) &&\n+                tk2.test(S.token(lookahead + 2).kind) &&\n+                tk3.test(S.token(lookahead + 3).kind);\n@@ -306,1 +307,1 @@\n-    protected boolean peekToken(Filter<TokenKind>... kinds) {\n+    protected boolean peekToken(Predicate<TokenKind>... kinds) {\n@@ -311,1 +312,1 @@\n-    protected boolean peekToken(int lookahead, Filter<TokenKind>... kinds) {\n+    protected boolean peekToken(int lookahead, Predicate<TokenKind>... kinds) {\n@@ -313,1 +314,1 @@\n-            if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {\n+            if (!kinds[lookahead].test(S.token(lookahead + 1).kind)) {\n@@ -1827,1 +1828,1 @@\n-    protected Filter<TokenKind> LAX_IDENTIFIER = t -> t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;\n+    protected Predicate<TokenKind> LAX_IDENTIFIER = t -> t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;\n@@ -2121,1 +2122,1 @@\n-        } else if (LAX_IDENTIFIER.accepts(token.kind)) {\n+        } else if (LAX_IDENTIFIER.test(token.kind)) {\n@@ -2204,1 +2205,1 @@\n-                if (LAX_IDENTIFIER.accepts(token.kind)) {\n+                if (LAX_IDENTIFIER.test(token.kind)) {\n@@ -2697,1 +2698,1 @@\n-            } else if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.accepts(token.kind)) {\n+            } else if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n@@ -2850,1 +2851,1 @@\n-            Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;\n+            Name label = LAX_IDENTIFIER.test(token.kind) ? ident() : null;\n@@ -2857,1 +2858,1 @@\n-            Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;\n+            Name label = LAX_IDENTIFIER.test(token.kind) ? ident() : null;\n@@ -3049,1 +3050,1 @@\n-            if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.accepts(token.kind)) {\n+            if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3231,1 +3232,1 @@\n-        if (LAX_IDENTIFIER.accepts(token.kind)) {\n+        if (LAX_IDENTIFIER.test(token.kind)) {\n@@ -3432,1 +3433,1 @@\n-                LAX_IDENTIFIER.accepts(token.kind) ||\n+                LAX_IDENTIFIER.test(token.kind) ||\n@@ -3505,1 +3506,1 @@\n-        if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.accepts(token.kind)) {\n+        if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3767,1 +3768,1 @@\n-                if (LAX_IDENTIFIER.accepts(token.kind)) {\n+                if (LAX_IDENTIFIER.test(token.kind)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Predicate;\n@@ -93,1 +94,1 @@\n-    public enum TokenKind implements Formattable, Filter<TokenKind> {\n+    public enum TokenKind implements Formattable, Predicate<TokenKind> {\n@@ -266,1 +267,1 @@\n-        public boolean accepts(TokenKind that) {\n+        public boolean test(TokenKind that) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.util;\n-\n-\/**\n- * Simple filter acting as a boolean predicate. Method accepts return true if\n- * the supplied element matches against the filter.\n- *\/\n-public interface Filter<T> {\n-    \/**\n-     * Does this element match against the filter?\n-     * @param t element to be checked\n-     * @return true if the element satisfy constraints imposed by filter\n-     *\/\n-    boolean accepts(T t);\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Filter.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-        private final Filter<JCDiagnostic> filter;\n+        private final Predicate<JCDiagnostic> filter;\n@@ -141,1 +141,1 @@\n-        public DeferredDiagnosticHandler(Log log, Filter<JCDiagnostic> filter) {\n+        public DeferredDiagnosticHandler(Log log, Predicate<JCDiagnostic> filter) {\n@@ -149,1 +149,1 @@\n-                (filter == null || filter.accepts(diag))) {\n+                (filter == null || filter.test(diag))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,1 @@\n-                    } else if ((isVoid || (lastmode & TYPE) != 0) && LAX_IDENTIFIER.accepts(token.kind)) {\n+                    } else if ((isVoid || (lastmode & TYPE) != 0) && LAX_IDENTIFIER.test(token.kind)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-                    } else if ((isVoid || (lastmode & TYPE) != 0) && LAX_IDENTIFIER.accepts(token.kind)) {\n+                    } else if ((isVoid || (lastmode & TYPE) != 0) && LAX_IDENTIFIER.test(token.kind)) {\n","filename":"test\/langtools\/tools\/javac\/parser\/extend\/TrialParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.Predicate;\n@@ -140,2 +141,3 @@\n-        class OddFilter implements Filter<Symbol> {\n-            public boolean accepts(Symbol s) {\n+        class OddFilter implements Predicate<Symbol> {\n+            @Override\n+            public boolean test(Symbol s) {\n@@ -180,1 +182,1 @@\n-        void checkElems(CompoundScope cs, Filter<Symbol> sf) {\n+        void checkElems(CompoundScope cs, Predicate<Symbol> sf) {\n@@ -202,1 +204,1 @@\n-        void checkShadowed(CompoundScope cs, Filter<Symbol> sf) {\n+        void checkShadowed(CompoundScope cs, Predicate<Symbol> sf) {\n@@ -221,1 +223,1 @@\n-        List<Symbol> filter(List<Symbol> elems, Filter<Symbol> sf) {\n+        List<Symbol> filter(List<Symbol> elems, Predicate<Symbol> sf) {\n@@ -224,1 +226,1 @@\n-                if (sf.accepts(s)) {\n+                if (sf.test(s)) {\n","filename":"test\/langtools\/tools\/javac\/scope\/7017664\/CompoundScopeTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}