{"files":[{"patch":"@@ -241,3 +241,11 @@\n-        if (out instanceof ChannelOutputStream cos\n-                && ch instanceof FileChannel fc) {\n-            WritableByteChannel wbc = cos.channel();\n+        if (out instanceof ChannelOutputStream cos) {\n+            if (ch instanceof FileChannel fc) {\n+                WritableByteChannel wbc = cos.channel();\n+\n+                if (wbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(fc, wbc);\n+                    }\n+                }\n@@ -245,2 +253,1 @@\n-            if (wbc instanceof FileChannel dst) {\n-                return transfer(fc, dst);\n+                return transfer(fc, wbc);\n@@ -249,5 +256,9 @@\n-            if (wbc instanceof SelectableChannel sc) {\n-                synchronized (sc.blockingLock()) {\n-                    if (!sc.isBlocking())\n-                        throw new IllegalBlockingModeException();\n-                    return transfer(fc, wbc);\n+            if (cos.channel() instanceof FileChannel fc) {\n+                ReadableByteChannel rbc = ch;\n+\n+                if (rbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(rbc, fc);\n+                    }\n@@ -255,1 +266,0 @@\n-            }\n@@ -257,1 +267,2 @@\n-            return transfer(fc, wbc);\n+                return transfer(rbc, fc);\n+            }\n@@ -275,0 +286,24 @@\n+\n+    private static long transfer(ReadableByteChannel src, FileChannel dst) throws IOException {\n+        long initialPos = dst.position();\n+        long pos = initialPos;\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(DEFAULT_BUFFER_SIZE);\n+        try {\n+            for (int bytesRead = 0; bytesRead > -1;) {\n+                pos += dst.transferFrom(src, pos, Long.MAX_VALUE);\n+                bytesRead = src.read(bb); \/\/ detect end-of-stream\n+                if (bytesRead > -1) {\n+                    bb.flip();\n+                    while (bb.hasRemaining()) {\n+                        dst.write(bb);\n+                    }\n+                    bb.clear();\n+                    pos += bytesRead;\n+                }\n+            };\n+        } finally {\n+            dst.position(pos);\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+        return pos - initialPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.BufferedInputStream;\n@@ -47,0 +48,1 @@\n+import java.util.function.Function;\n@@ -99,1 +101,1 @@\n-            \/\/ tests FileChannel.transferTo(WritableChannelOutput)\n+            \/\/ tests FileChannel.transferTo(WritableByteChannelOutput)\n@@ -103,0 +105,6 @@\n+            \/\/ tests FileChannel.transferFrom(SelectableChannelOutput) optimized case\n+            { selectableChannelInput(), fileChannelOutput() },\n+\n+            \/\/ tests FileChannel.transferFrom(ReadableByteChannelInput) optimized case\n+            { readableByteChannelInput(), fileChannelOutput() },\n+\n@@ -158,9 +166,6 @@\n-    \/*\n-     * Special test for file-to-file transfer of more than 2 GB. This test\n-     * covers multiple iterations of FileChannel.transerTo(FileChannel),\n-     * which ChannelInputStream.transferTo() only applies in this particular\n-     * case, and cannot get tested using a single byte[] due to size limitation\n-     * of arrays.\n-     *\/\n-    @Test\n-    public void testMoreThanTwoGB() throws IOException {\n+    @FunctionalInterface\n+    private interface CheckedFunction<T, R, E extends Throwable> {\n+        R apply(T t) throws E;\n+    }\n+\n+    private static void testMoreThanTwoGB(String testName, CheckedFunction<Path, ReadableByteChannel, IOException> factory) throws IOException {\n@@ -169,1 +174,1 @@\n-        String sourceName = String.format(\"test3GBSource%s.tmp\",\n+        String sourceName = String.format(\"test3GB%sSource%s.tmp\", testName,\n@@ -175,1 +180,1 @@\n-            String targetName = String.format(\"test3GBTarget%s.tmp\",\n+            String targetName = String.format(\"test3GB%sTarget%s.tmp\", testName,\n@@ -202,2 +207,2 @@\n-                \/\/ of Filechannel.transferTo(FileChannel)\n-                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n+                \/\/ of FileChannel.transferTo(WritableByteChannel) or FileChannel.transferFrom(ReadableByteChannel)\n+                try (InputStream inputStream = Channels.newInputStream(factory.apply(sourceFile));\n@@ -224,2 +229,26 @@\n-     * Special test of whether selectable channel based transfer throws blocking\n-     * mode exception.\n+     * Special test for file-to-stream transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transferTo(WritableByteChannel),\n+     * which ChannelInputStream.transferTo() only applies in this particular\n+     * case, and cannot get tested using a single byte[] due to size limitation\n+     * of arrays.\n+     *\/\n+    @Test\n+    public void testMoreThanTwoGBtoStream() throws IOException {\n+        testMoreThanTwoGB(\"toStream\", FileChannel::open);\n+    }\n+\n+    \/*\n+     * Special test for stream-to-file transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transferFrom(ReadableByteChannel),\n+     * which ChannelInputStream.transferFrom() only applies in this particular\n+     * case, and cannot get tested using a single byte[] due to size limitation\n+     * of arrays.\n+     *\/\n+    @Test\n+    public void testMoreThanTwoGBfromStream() throws IOException {\n+        testMoreThanTwoGB(\"fromStream\", sourceFile -> Channels.newChannel(\n+                new BufferedInputStream(Files.newInputStream(sourceFile))));\n+    }\n+\n+    \/*\n+     * Special test whether selectable channel based transfer throws blocking mode exception.\n@@ -354,0 +383,19 @@\n+    \/*\n+     * Creates a provider for an input stream which wraps a selectable channel\n+     *\/\n+    private static InputStreamProvider selectableChannelInput() throws IOException {\n+        return new InputStreamProvider() {\n+            public InputStream input(byte... bytes) throws Exception {\n+                Pipe pipe = Pipe.open();\n+                new Thread(() -> {\n+                    try (OutputStream os = Channels.newOutputStream(pipe.sink())) {\n+                      os.write(bytes);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).start();\n+                return Channels.newInputStream(pipe.source());\n+            }\n+        };\n+    }\n+\n@@ -374,0 +422,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a selectable channel\n+     *\/\n@@ -400,0 +451,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a writable byte channel but is not a file channel\n+     *\/\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":70,"deletions":16,"binary":false,"changes":86,"status":"modified"}]}