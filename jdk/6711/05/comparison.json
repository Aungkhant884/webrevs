{"files":[{"patch":"@@ -241,3 +241,11 @@\n-        if (out instanceof ChannelOutputStream cos\n-                && ch instanceof FileChannel fc) {\n-            WritableByteChannel wbc = cos.channel();\n+        if (out instanceof ChannelOutputStream cos) {\n+            if (ch instanceof FileChannel fc) {\n+                WritableByteChannel wbc = cos.channel();\n+\n+                if (wbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(fc, wbc);\n+                    }\n+                }\n@@ -245,2 +253,1 @@\n-            if (wbc instanceof FileChannel dst) {\n-                return transfer(fc, dst);\n+                return transfer(fc, wbc);\n@@ -249,5 +256,9 @@\n-            if (wbc instanceof SelectableChannel sc) {\n-                synchronized (sc.blockingLock()) {\n-                    if (!sc.isBlocking())\n-                        throw new IllegalBlockingModeException();\n-                    return transfer(fc, wbc);\n+            if (cos.channel() instanceof FileChannel fc) {\n+                ReadableByteChannel rbc = ch;\n+\n+                if (rbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(rbc, fc);\n+                    }\n@@ -255,1 +266,0 @@\n-            }\n@@ -257,1 +267,2 @@\n-            return transfer(fc, wbc);\n+                return transfer(rbc, fc);\n+            }\n@@ -275,0 +286,24 @@\n+\n+    private static long transfer(ReadableByteChannel src, FileChannel dst) throws IOException {\n+        long initialPos = dst.position();\n+        long pos = initialPos;\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(DEFAULT_BUFFER_SIZE);\n+        try {\n+            for (int bytesRead = 0; bytesRead > -1;) {\n+                pos += dst.transferFrom(src, pos, Long.MAX_VALUE);\n+                bytesRead = src.read(bb); \/\/ detect end-of-stream\n+                if (bytesRead > -1) {\n+                    bb.flip();\n+                    while (bb.hasRemaining()) {\n+                        dst.write(bb);\n+                    }\n+                    bb.clear();\n+                    pos += bytesRead;\n+                }\n+            };\n+        } finally {\n+            dst.position(pos);\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+        return pos - initialPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.BufferedInputStream;\n@@ -99,1 +100,1 @@\n-            \/\/ tests FileChannel.transferTo(WritableChannelOutput)\n+            \/\/ tests FileChannel.transferTo(WritableByteChannelOutput)\n@@ -103,0 +104,6 @@\n+            \/\/ tests FileChannel.transferFrom(SelectableChannelOutput) optimized case\n+            { selectableChannelInput(), fileChannelOutput() },\n+\n+            \/\/ tests FileChannel.transferFrom(ReadableByteChannelInput) optimized case\n+            { readableByteChannelInput(), fileChannelOutput() },\n+\n@@ -159,2 +166,2 @@\n-     * Special test for file-to-file transfer of more than 2 GB. This test\n-     * covers multiple iterations of FileChannel.transerTo(FileChannel),\n+     * Special test for file-to-stream transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transferTo(WritableByteChannel),\n@@ -166,1 +173,1 @@\n-    public void testMoreThanTwoGB() throws IOException {\n+    public void testMoreThanTwoGBtoStream() throws IOException {\n@@ -169,1 +176,1 @@\n-        String sourceName = String.format(\"test3GBSource%s.tmp\",\n+        String sourceName = String.format(\"test3GBtoStreamSource%s.tmp\",\n@@ -175,1 +182,1 @@\n-            String targetName = String.format(\"test3GBTarget%s.tmp\",\n+            String targetName = String.format(\"test3GBtoStreamTarget%s.tmp\",\n@@ -202,1 +209,1 @@\n-                \/\/ of Filechannel.transferTo(FileChannel)\n+                \/\/ of FileChannel.transferTo(WritableByteChannel)\n@@ -224,2 +231,67 @@\n-     * Special test of whether selectable channel based transfer throws blocking\n-     * mode exception.\n+     * Special test for stream-to-file transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transferFrom(ReadableByteChannel),\n+     * which ChannelInputStream.transferFrom() only applies in this particular\n+     * case, and cannot get tested using a single byte[] due to size limitation\n+     * of arrays.\n+     *\/\n+    @Test\n+    public void testMoreThanTwoGBfromStream() throws IOException {\n+        \/\/ prepare two temporary files to be compared at the end of the test\n+        \/\/ set the source file name\n+        String sourceName = String.format(\"test3GBfromStreamSource%s.tmp\",\n+            String.valueOf(RND.nextInt(Integer.MAX_VALUE)));\n+        Path sourceFile = CWD.resolve(sourceName);\n+\n+        try {\n+            \/\/ set the target file name\n+            String targetName = String.format(\"test3GBfromStreamTarget%s.tmp\",\n+                String.valueOf(RND.nextInt(Integer.MAX_VALUE)));\n+            Path targetFile = CWD.resolve(targetName);\n+\n+            try {\n+                \/\/ calculate initial position to be just short of 2GB\n+                final long initPos = 2047*BYTES_PER_WRITE;\n+\n+                \/\/ create the source file with a hint to be sparse\n+                try (FileChannel fc = FileChannel.open(sourceFile, CREATE_NEW, SPARSE, WRITE, APPEND);) {\n+                    \/\/ set initial position to avoid writing nearly 2GB\n+                    fc.position(initPos);\n+\n+                    \/\/ fill the remainder of the file with random bytes\n+                    int nw = (int)(NUM_WRITES - initPos\/BYTES_PER_WRITE);\n+                    for (int i = 0; i < nw; i++) {\n+                        byte[] rndBytes = createRandomBytes(BYTES_PER_WRITE, 0);\n+                        ByteBuffer src = ByteBuffer.wrap(rndBytes);\n+                        fc.write(src);\n+                    }\n+                }\n+\n+                \/\/ create the target file with a hint to be sparse\n+                try (FileChannel fc = FileChannel.open(targetFile, CREATE_NEW, WRITE, SPARSE);) {\n+                }\n+\n+                \/\/ performing actual transfer, effectively by multiple invocations of\n+                \/\/ FileChannel.transferFrom(ReadableByteChannel)\n+                try (InputStream inputStream = Channels.newInputStream(Channels.newChannel(\n+                        new BufferedInputStream(Files.newInputStream(sourceFile))));\n+                     OutputStream outputStream = Channels.newOutputStream(FileChannel.open(targetFile, WRITE))) {\n+                    long count = inputStream.transferTo(outputStream);\n+\n+                    \/\/ compare reported transferred bytes, must be 3 GB\n+                    \/\/ less the value of the initial position\n+                    assertEquals(count, BYTES_WRITTEN - initPos);\n+                }\n+\n+                \/\/ compare content of both files, failing if different\n+                assertEquals(Files.mismatch(sourceFile, targetFile), -1);\n+\n+            } finally {\n+                 Files.delete(targetFile);\n+            }\n+        } finally {\n+            Files.delete(sourceFile);\n+        }\n+    }\n+\n+    \/*\n+     * Special test whether selectable channel based transfer throws blocking mode exception.\n@@ -354,0 +426,19 @@\n+    \/*\n+     * Creates a provider for an input stream which wraps a selectable channel\n+     *\/\n+    private static InputStreamProvider selectableChannelInput() throws IOException {\n+        return new InputStreamProvider() {\n+            public InputStream input(byte... bytes) throws Exception {\n+                Pipe pipe = Pipe.open();\n+                new Thread(() -> {\n+                    try (OutputStream os = Channels.newOutputStream(pipe.sink())) {\n+                      os.write(bytes);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).start();\n+                return Channels.newInputStream(pipe.source());\n+            }\n+        };\n+    }\n+\n@@ -374,0 +465,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a selectable channel\n+     *\/\n@@ -400,0 +494,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a writable byte channel but is not a file channel\n+     *\/\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":106,"deletions":9,"binary":false,"changes":115,"status":"modified"}]}