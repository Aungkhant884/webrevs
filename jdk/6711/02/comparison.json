{"files":[{"patch":"@@ -241,3 +241,11 @@\n-        if (out instanceof ChannelOutputStream cos\n-                && ch instanceof FileChannel fc) {\n-            WritableByteChannel wbc = cos.channel();\n+        if (out instanceof ChannelOutputStream cos) {\n+            if (ch instanceof FileChannel fc) {\n+                WritableByteChannel wbc = cos.channel();\n+\n+                if (wbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(fc, wbc);\n+                    }\n+                }\n@@ -245,2 +253,1 @@\n-            if (wbc instanceof FileChannel dst) {\n-                return transfer(fc, dst);\n+                return transfer(fc, wbc);\n@@ -249,5 +256,9 @@\n-            if (wbc instanceof SelectableChannel sc) {\n-                synchronized (sc.blockingLock()) {\n-                    if (!sc.isBlocking())\n-                        throw new IllegalBlockingModeException();\n-                    return transfer(fc, wbc);\n+            if (cos.channel() instanceof FileChannel fc) {\n+                ReadableByteChannel rbc = ch;\n+\n+                if (rbc instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        if (!sc.isBlocking())\n+                            throw new IllegalBlockingModeException();\n+                        return transfer(rbc, fc);\n+                    }\n@@ -255,1 +266,0 @@\n-            }\n@@ -257,1 +267,2 @@\n-            return transfer(fc, wbc);\n+                return transfer(rbc, fc);\n+            }\n@@ -275,0 +286,24 @@\n+\n+    private static long transfer(ReadableByteChannel src, FileChannel dst) throws IOException {\n+        long initialPos = dst.position();\n+        long pos = initialPos;\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(DEFAULT_BUFFER_SIZE);\n+        try {\n+            for (int bytesRead = 0; bytesRead > -1;) {\n+                pos += dst.transferFrom(src, pos, Long.MAX_VALUE);\n+                bytesRead = src.read(bb); \/\/ detect end-of-stream\n+                if (bytesRead > -1) {\n+                    bb.flip();\n+                    while (bb.hasRemaining()) {\n+                        dst.write(bb);\n+                    }\n+                    bb.clear();\n+                    pos += bytesRead;\n+                }\n+            };\n+        } finally {\n+            dst.position(pos);\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+        return pos - initialPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.BufferedInputStream;\n@@ -95,1 +96,1 @@\n-            \/\/ tests FileChannel.transferTo(WritableChannelOutput) optimized case\n+            \/\/ tests FileChannel.transferTo(WritableByteChannelOutput) optimized case\n@@ -98,0 +99,6 @@\n+            \/\/ tests FileChannel.transferFrom(SelectableChannelOutput) optimized case\n+            { selectableChannelInput(), fileChannelOutput() },\n+\n+            \/\/ tests FileChannel.transferFrom(ReadableByteChannelInput) optimized case\n+            { readableByteChannelInput(), fileChannelOutput() },\n+\n@@ -150,2 +157,2 @@\n-     * Special test for file-to-file transfer of more than two GB.\n-     * This test covers multiple iterations of FileChannel.transerTo(FileChannel),\n+     * Special test for file-to-stream transfer of more than two GB.\n+     * This test covers multiple iterations of FileChannel.transferTo(WritableByteChannel),\n@@ -156,2 +163,2 @@\n-    public void testMoreThanTwoGB() throws IOException {\n-        Path sourceFile = Files.createTempFile(CWD, \"test2GBSource\", null);\n+    public void testMoreThanTwoGBtoStream() throws IOException {\n+        Path sourceFile = Files.createTempFile(CWD, \"test2GBtoStreamSource\", null);\n@@ -160,1 +167,1 @@\n-            Path targetFile = Files.createTempFile(CWD, \"test2GBtarget\", null);\n+            Path targetFile = Files.createTempFile(CWD, \"test2GBtoStreamTarget\", null);\n@@ -166,1 +173,2 @@\n-                \/\/ performing actual transfer, effectively by multiple invocations of Filechannel.transferTo(FileChannel)\n+                \/\/ performing actual transfer, effectively by multiple invocations of\n+                \/\/ FileChannel.transferTo(WritableByteChannel)\n@@ -188,0 +196,41 @@\n+    \/*\n+     * Special test for stream-to-file transfer of more than two GB.\n+     * This test covers multiple iterations of FileChannel.transferFrom(ReadableByteChannel),\n+     * which ChannelInputStream.transferTo() only applies in this particular case,\n+     * and cannot get tested using a single byte[] due to size limitation of arrays.\n+     *\/\n+    @Test\n+    public void testMoreThanTwoGBfromStream() throws IOException {\n+        Path sourceFile = Files.createTempFile(CWD, \"test2GBfromStreamSource\", null);\n+        try {\n+            \/\/ preparing two temporary files which will be compared at the end of the test\n+            Path targetFile = Files.createTempFile(CWD, \"test2GBfromStreamTarget\", null);\n+            try {\n+                \/\/ writing 3 GB of random bytes into source file\n+                for (int i = 0; i < NUM_WRITES; i++)\n+                    Files.write(sourceFile, createRandomBytes(BYTES_PER_WRITE, 0), StandardOpenOption.APPEND);\n+\n+                \/\/ performing actual transfer, effectively by multiple invocations of\n+                \/\/ FileChannel.transferFrom(ReadableByteChannel)\n+                long count;\n+                try (InputStream inputStream = Channels.newInputStream(Channels.newChannel(\n+                        new BufferedInputStream(Files.newInputStream(sourceFile))));\n+                     OutputStream outputStream = Channels\n+                             .newOutputStream(FileChannel.open(targetFile, StandardOpenOption.WRITE))) {\n+                    count = inputStream.transferTo(outputStream);\n+                }\n+\n+                \/\/ comparing reported transferred bytes, must be 3 GB\n+                assertEquals(count, BYTES_WRITTEN);\n+\n+                \/\/ comparing content of both files, failing in case of any difference\n+                assertEquals(Files.mismatch(sourceFile, targetFile), -1);\n+\n+            } finally {\n+                 Files.delete(targetFile);\n+            }\n+        } finally {\n+            Files.delete(sourceFile);\n+        }\n+    }\n+    \n@@ -312,0 +361,19 @@\n+    \/*\n+     * Creates a provider for an input stream which wraps a selectable channel\n+     *\/\n+    private static InputStreamProvider selectableChannelInput() throws IOException {\n+        return new InputStreamProvider() {\n+            public InputStream input(byte... bytes) throws Exception {\n+                Pipe pipe = Pipe.open();\n+                new Thread(() -> {\n+                    try (OutputStream os = Channels.newOutputStream(pipe.sink())) {\n+                      os.write(bytes);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).start();\n+                return Channels.newInputStream(pipe.source());\n+            }\n+        };\n+    }\n+\n@@ -332,0 +400,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a selectable channel\n+     *\/\n@@ -358,0 +429,3 @@\n+    \/*\n+     * Creates a provider for an output stream which wraps a writable byte channel but is not a file channel\n+     *\/\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":81,"deletions":7,"binary":false,"changes":88,"status":"modified"}]}