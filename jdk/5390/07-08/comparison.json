{"files":[{"patch":"@@ -598,1 +598,1 @@\n-  \/\/ v0: current state, result of multiply\/reduce\n+  \/\/ v0: input \/ output: current state, result of multiply\/reduce\n@@ -600,1 +600,2 @@\n-  \/\/ v2: one block of data (the ciphertext)\n+  \/\/ v2: input: one block of data (the ciphertext)\n+  \/\/     also used as a temp once the data has been consumed\n@@ -602,2 +603,3 @@\n-  \/\/ v4: high part of product\n-  \/\/ v5: low part ...\n+  \/\/ v4: output: high part of product\n+  \/\/ v5: output: low part ...\n+  \/\/ v6: unused\n@@ -636,1 +638,1 @@\n-    \/\/ data into current state.\n+    \/\/ data into v0, v0+ofs, the current state.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_aes.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2858,1 +2858,6 @@\n-\n+    \/\/ NB: bulk_width can be 4 or 8. 8 gives slightly faster\n+    \/\/ performance with larger data sizes, but it also means that the\n+    \/\/ fast path isn't used until you have at least 8 blocks, and up\n+    \/\/ to 127 bytes of data will be executed on the slow path. For\n+    \/\/ that reason, and also so as not to blow away too much icache, 4\n+    \/\/ blocks seems like a sensible compromise.\n@@ -2862,29 +2867,33 @@\n-    \/\/ int result = len;\n-    \/\/ while (len-- > 0) {\n-    \/\/     if (used >= blockSize) {\n-    \/\/         if (len >= bulk_width * blockSize()) {\n-    \/\/             CTR_large_block();\n-    \/\/             if (len == 0)\n-    \/\/                 break; \/* goto DONE; *\/\n-    \/\/         }\n-    \/\/         for (;;) {\n-    \/\/             16ByteVector v0 = counter;\n-    \/\/             embeddedCipher.encryptBlock(v0, 0, encryptedCounter, 0);\n-    \/\/             used = 0;\n-    \/\/             if (len < blockSize)\n-    \/\/                 break;  \/* goto NEXT *\/\n-    \/\/             16ByteVector v1 = load16Bytes(in, offset);\n-    \/\/             v1 = v1 ^ encryptedCounter;\n-    \/\/             store16Bytes(out, offset);\n-    \/\/             used = blockSize;\n-    \/\/             offset += blockSize;\n-    \/\/             len -= blockSize;\n-    \/\/             if (len == 0)\n-    \/\/                 goto DONE;\n-    \/\/         }\n-    \/\/     }\n-    \/\/     NEXT:\n-    \/\/     out[outOff++] = (byte)(in[inOff++] ^ encryptedCounter[used++]);\n-    \/\/ }\n-    \/\/ DONE:\n-    \/\/ return result;\n+    \/\/    if (len == 0) {\n+    \/\/        goto DONE;\n+    \/\/    }\n+    \/\/    int result = len;\n+    \/\/    do {\n+    \/\/        if (used >= blockSize) {\n+    \/\/            if (len >= bulk_width * blockSize) {\n+    \/\/                CTR_large_block();\n+    \/\/                if (len == 0)\n+    \/\/                    goto DONE;\n+    \/\/            }\n+    \/\/            for (;;) {\n+    \/\/                16ByteVector v0 = counter;\n+    \/\/                embeddedCipher.encryptBlock(v0, 0, encryptedCounter, 0);\n+    \/\/                used = 0;\n+    \/\/                if (len < blockSize)\n+    \/\/                    break;    \/* goto NEXT *\/\n+    \/\/                16ByteVector v1 = load16Bytes(in, offset);\n+    \/\/                v1 = v1 ^ encryptedCounter;\n+    \/\/                store16Bytes(out, offset);\n+    \/\/                used = blockSize;\n+    \/\/                offset += blockSize;\n+    \/\/                len -= blockSize;\n+    \/\/                if (len == 0)\n+    \/\/                    goto DONE;\n+    \/\/            }\n+    \/\/        }\n+    \/\/      NEXT:\n+    \/\/        out[outOff++] = (byte)(in[inOff++] ^ encryptedCounter[used++]);\n+    \/\/        len--;\n+    \/\/    } while (len != 0);\n+    \/\/  DONE:\n+    \/\/    return result;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":39,"deletions":30,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+  \/\/ All Apple-darwin Arm processors have AES.\n+  _features |= CPU_AES;\n+\n@@ -92,3 +95,0 @@\n-  \/\/ All Apple-darwin Arm processors have AES.\n-  _features |= CPU_AES;\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}