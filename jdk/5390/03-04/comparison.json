{"files":[{"patch":"@@ -0,0 +1,1448 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP\n+#define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP\n+\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"oops\/compressedOops.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+\/\/ MacroAssembler extends Assembler by frequently used macros.\n+\/\/\n+\/\/ Instructions for which a 'better' code sequence exists depending\n+\/\/ on arguments should also go in here.\n+\n+class MacroAssembler: public Assembler {\n+  friend class LIR_Assembler;\n+\n+ public:\n+  using Assembler::mov;\n+  using Assembler::movi;\n+\n+ protected:\n+\n+  \/\/ Support for VM calls\n+  \/\/\n+  \/\/ This is the base routine called by the different versions of call_VM_leaf. The interpreter\n+  \/\/ may customize this version by overriding it for its purposes (e.g., to save\/restore\n+  \/\/ additional registers when doing a VM call).\n+  virtual void call_VM_leaf_base(\n+    address entry_point,               \/\/ the entry point\n+    int     number_of_arguments,        \/\/ the number of arguments to pop after the call\n+    Label *retaddr = NULL\n+  );\n+\n+  virtual void call_VM_leaf_base(\n+    address entry_point,               \/\/ the entry point\n+    int     number_of_arguments,        \/\/ the number of arguments to pop after the call\n+    Label &retaddr) {\n+    call_VM_leaf_base(entry_point, number_of_arguments, &retaddr);\n+  }\n+\n+  \/\/ This is the base routine called by the different versions of call_VM. The interpreter\n+  \/\/ may customize this version by overriding it for its purposes (e.g., to save\/restore\n+  \/\/ additional registers when doing a VM call).\n+  \/\/\n+  \/\/ If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base\n+  \/\/ returns the register which contains the thread upon return. If a thread register has been\n+  \/\/ specified, the return value will correspond to that register. If no last_java_sp is specified\n+  \/\/ (noreg) than rsp will be used instead.\n+  virtual void call_VM_base(           \/\/ returns the register containing the thread upon return\n+    Register oop_result,               \/\/ where an oop-result ends up if any; use noreg otherwise\n+    Register java_thread,              \/\/ the thread if computed before     ; use noreg otherwise\n+    Register last_java_sp,             \/\/ to set up last_Java_frame in stubs; use noreg otherwise\n+    address  entry_point,              \/\/ the entry point\n+    int      number_of_arguments,      \/\/ the number of arguments (w\/o thread) to pop after the call\n+    bool     check_exceptions          \/\/ whether to check for pending exceptions after return\n+  );\n+\n+  void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);\n+\n+  enum KlassDecodeMode {\n+    KlassDecodeNone,\n+    KlassDecodeZero,\n+    KlassDecodeXor,\n+    KlassDecodeMovk\n+  };\n+\n+  KlassDecodeMode klass_decode_mode();\n+\n+ private:\n+  static KlassDecodeMode _klass_decode_mode;\n+\n+ public:\n+  MacroAssembler(CodeBuffer* code) : Assembler(code) {}\n+\n+ \/\/ These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.\n+ \/\/ The implementation is only non-empty for the InterpreterMacroAssembler,\n+ \/\/ as only the interpreter handles PopFrame and ForceEarlyReturn requests.\n+ virtual void check_and_handle_popframe(Register java_thread);\n+ virtual void check_and_handle_earlyret(Register java_thread);\n+\n+  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod);\n+\n+  \/\/ Helper functions for statistics gathering.\n+  \/\/ Unconditional atomic increment.\n+  void atomic_incw(Register counter_addr, Register tmp, Register tmp2);\n+  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {\n+    lea(tmp1, counter_addr);\n+    atomic_incw(tmp1, tmp2, tmp3);\n+  }\n+  \/\/ Load Effective Address\n+  void lea(Register r, const Address &a) {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), a.rspec());\n+    a.lea(this, r);\n+  }\n+\n+  \/* Sometimes we get misaligned loads and stores, usually from Unsafe\n+     accesses, and these can exceed the offset range. *\/\n+  Address legitimize_address(const Address &a, int size, Register scratch) {\n+    if (a.getMode() == Address::base_plus_offset) {\n+      if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {\n+        block_comment(\"legitimize_address {\");\n+        lea(scratch, a);\n+        block_comment(\"} legitimize_address\");\n+        return Address(scratch);\n+      }\n+    }\n+    return a;\n+  }\n+\n+  void addmw(Address a, Register incr, Register scratch) {\n+    ldrw(scratch, a);\n+    addw(scratch, scratch, incr);\n+    strw(scratch, a);\n+  }\n+\n+  \/\/ Add constant to memory word\n+  void addmw(Address a, int imm, Register scratch) {\n+    ldrw(scratch, a);\n+    if (imm > 0)\n+      addw(scratch, scratch, (unsigned)imm);\n+    else\n+      subw(scratch, scratch, (unsigned)-imm);\n+    strw(scratch, a);\n+  }\n+\n+  void bind(Label& L) {\n+    Assembler::bind(L);\n+    code()->clear_last_insn();\n+  }\n+\n+  void membar(Membar_mask_bits order_constraint);\n+\n+  using Assembler::ldr;\n+  using Assembler::str;\n+  using Assembler::ldrw;\n+  using Assembler::strw;\n+\n+  void ldr(Register Rx, const Address &adr);\n+  void ldrw(Register Rw, const Address &adr);\n+  void str(Register Rx, const Address &adr);\n+  void strw(Register Rx, const Address &adr);\n+\n+  \/\/ Frame creation and destruction shared between JITs.\n+  void build_frame(int framesize);\n+  void remove_frame(int framesize);\n+\n+  virtual void _call_Unimplemented(address call_site) {\n+    mov(rscratch2, call_site);\n+  }\n+\n+\/\/ Microsoft's MSVC team thinks that the __FUNCSIG__ is approximately (sympathy for calling conventions) equivalent to __PRETTY_FUNCTION__\n+\/\/ Also, from Clang patch: \"It is very similar to GCC's PRETTY_FUNCTION, except it prints the calling convention.\"\n+\/\/ https:\/\/reviews.llvm.org\/D3311\n+\n+#ifdef _WIN64\n+#define call_Unimplemented() _call_Unimplemented((address)__FUNCSIG__)\n+#else\n+#define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)\n+#endif\n+\n+  \/\/ aliases defined in AARCH64 spec\n+\n+  template<class T>\n+  inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }\n+\n+  inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }\n+  inline void cmp(Register Rd, unsigned imm) = delete;\n+\n+  inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }\n+  inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }\n+\n+  void cset(Register Rd, Assembler::Condition cond) {\n+    csinc(Rd, zr, zr, ~cond);\n+  }\n+  void csetw(Register Rd, Assembler::Condition cond) {\n+    csincw(Rd, zr, zr, ~cond);\n+  }\n+\n+  void cneg(Register Rd, Register Rn, Assembler::Condition cond) {\n+    csneg(Rd, Rn, Rn, ~cond);\n+  }\n+  void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {\n+    csnegw(Rd, Rn, Rn, ~cond);\n+  }\n+\n+  inline void movw(Register Rd, Register Rn) {\n+    if (Rd == sp || Rn == sp) {\n+      addw(Rd, Rn, 0U);\n+    } else {\n+      orrw(Rd, zr, Rn);\n+    }\n+  }\n+  inline void mov(Register Rd, Register Rn) {\n+    assert(Rd != r31_sp && Rn != r31_sp, \"should be\");\n+    if (Rd == Rn) {\n+    } else if (Rd == sp || Rn == sp) {\n+      add(Rd, Rn, 0U);\n+    } else {\n+      orr(Rd, zr, Rn);\n+    }\n+  }\n+\n+  inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }\n+  inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }\n+\n+  inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }\n+  inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }\n+\n+  inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }\n+  inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }\n+\n+  inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    bfmw(Rd, Rn, ((32 - lsb) & 31), (width - 1));\n+  }\n+  inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    bfm(Rd, Rn, ((64 - lsb) & 63), (width - 1));\n+  }\n+\n+  inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    bfmw(Rd, Rn, lsb, (lsb + width - 1));\n+  }\n+  inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    bfm(Rd, Rn, lsb , (lsb + width - 1));\n+  }\n+\n+  inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    sbfmw(Rd, Rn, ((32 - lsb) & 31), (width - 1));\n+  }\n+  inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    sbfm(Rd, Rn, ((64 - lsb) & 63), (width - 1));\n+  }\n+\n+  inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    sbfmw(Rd, Rn, lsb, (lsb + width - 1));\n+  }\n+  inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    sbfm(Rd, Rn, lsb , (lsb + width - 1));\n+  }\n+\n+  inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    ubfmw(Rd, Rn, ((32 - lsb) & 31), (width - 1));\n+  }\n+  inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    ubfm(Rd, Rn, ((64 - lsb) & 63), (width - 1));\n+  }\n+\n+  inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    ubfmw(Rd, Rn, lsb, (lsb + width - 1));\n+  }\n+  inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {\n+    ubfm(Rd, Rn, lsb , (lsb + width - 1));\n+  }\n+\n+  inline void asrw(Register Rd, Register Rn, unsigned imm) {\n+    sbfmw(Rd, Rn, imm, 31);\n+  }\n+\n+  inline void asr(Register Rd, Register Rn, unsigned imm) {\n+    sbfm(Rd, Rn, imm, 63);\n+  }\n+\n+  inline void lslw(Register Rd, Register Rn, unsigned imm) {\n+    ubfmw(Rd, Rn, ((32 - imm) & 31), (31 - imm));\n+  }\n+\n+  inline void lsl(Register Rd, Register Rn, unsigned imm) {\n+    ubfm(Rd, Rn, ((64 - imm) & 63), (63 - imm));\n+  }\n+\n+  inline void lsrw(Register Rd, Register Rn, unsigned imm) {\n+    ubfmw(Rd, Rn, imm, 31);\n+  }\n+\n+  inline void lsr(Register Rd, Register Rn, unsigned imm) {\n+    ubfm(Rd, Rn, imm, 63);\n+  }\n+\n+  inline void rorw(Register Rd, Register Rn, unsigned imm) {\n+    extrw(Rd, Rn, Rn, imm);\n+  }\n+\n+  inline void ror(Register Rd, Register Rn, unsigned imm) {\n+    extr(Rd, Rn, Rn, imm);\n+  }\n+\n+  inline void sxtbw(Register Rd, Register Rn) {\n+    sbfmw(Rd, Rn, 0, 7);\n+  }\n+  inline void sxthw(Register Rd, Register Rn) {\n+    sbfmw(Rd, Rn, 0, 15);\n+  }\n+  inline void sxtb(Register Rd, Register Rn) {\n+    sbfm(Rd, Rn, 0, 7);\n+  }\n+  inline void sxth(Register Rd, Register Rn) {\n+    sbfm(Rd, Rn, 0, 15);\n+  }\n+  inline void sxtw(Register Rd, Register Rn) {\n+    sbfm(Rd, Rn, 0, 31);\n+  }\n+\n+  inline void uxtbw(Register Rd, Register Rn) {\n+    ubfmw(Rd, Rn, 0, 7);\n+  }\n+  inline void uxthw(Register Rd, Register Rn) {\n+    ubfmw(Rd, Rn, 0, 15);\n+  }\n+  inline void uxtb(Register Rd, Register Rn) {\n+    ubfm(Rd, Rn, 0, 7);\n+  }\n+  inline void uxth(Register Rd, Register Rn) {\n+    ubfm(Rd, Rn, 0, 15);\n+  }\n+  inline void uxtw(Register Rd, Register Rn) {\n+    ubfm(Rd, Rn, 0, 31);\n+  }\n+\n+  inline void cmnw(Register Rn, Register Rm) {\n+    addsw(zr, Rn, Rm);\n+  }\n+  inline void cmn(Register Rn, Register Rm) {\n+    adds(zr, Rn, Rm);\n+  }\n+\n+  inline void cmpw(Register Rn, Register Rm) {\n+    subsw(zr, Rn, Rm);\n+  }\n+  inline void cmp(Register Rn, Register Rm) {\n+    subs(zr, Rn, Rm);\n+  }\n+\n+  inline void negw(Register Rd, Register Rn) {\n+    subw(Rd, zr, Rn);\n+  }\n+\n+  inline void neg(Register Rd, Register Rn) {\n+    sub(Rd, zr, Rn);\n+  }\n+\n+  inline void negsw(Register Rd, Register Rn) {\n+    subsw(Rd, zr, Rn);\n+  }\n+\n+  inline void negs(Register Rd, Register Rn) {\n+    subs(Rd, zr, Rn);\n+  }\n+\n+  inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {\n+    addsw(zr, Rn, Rm, kind, shift);\n+  }\n+  inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {\n+    adds(zr, Rn, Rm, kind, shift);\n+  }\n+\n+  inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {\n+    subsw(zr, Rn, Rm, kind, shift);\n+  }\n+  inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {\n+    subs(zr, Rn, Rm, kind, shift);\n+  }\n+\n+  inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {\n+    subw(Rd, zr, Rn, kind, shift);\n+  }\n+\n+  inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {\n+    sub(Rd, zr, Rn, kind, shift);\n+  }\n+\n+  inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {\n+    subsw(Rd, zr, Rn, kind, shift);\n+  }\n+\n+  inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {\n+    subs(Rd, zr, Rn, kind, shift);\n+  }\n+\n+  inline void mnegw(Register Rd, Register Rn, Register Rm) {\n+    msubw(Rd, Rn, Rm, zr);\n+  }\n+  inline void mneg(Register Rd, Register Rn, Register Rm) {\n+    msub(Rd, Rn, Rm, zr);\n+  }\n+\n+  inline void mulw(Register Rd, Register Rn, Register Rm) {\n+    maddw(Rd, Rn, Rm, zr);\n+  }\n+  inline void mul(Register Rd, Register Rn, Register Rm) {\n+    madd(Rd, Rn, Rm, zr);\n+  }\n+\n+  inline void smnegl(Register Rd, Register Rn, Register Rm) {\n+    smsubl(Rd, Rn, Rm, zr);\n+  }\n+  inline void smull(Register Rd, Register Rn, Register Rm) {\n+    smaddl(Rd, Rn, Rm, zr);\n+  }\n+\n+  inline void umnegl(Register Rd, Register Rn, Register Rm) {\n+    umsubl(Rd, Rn, Rm, zr);\n+  }\n+  inline void umull(Register Rd, Register Rn, Register Rm) {\n+    umaddl(Rd, Rn, Rm, zr);\n+  }\n+\n+#define WRAP(INSN)                                                            \\\n+  void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \\\n+    if ((VM_Version::features() & VM_Version::CPU_A53MAC) && Ra != zr)        \\\n+      nop();                                                                  \\\n+    Assembler::INSN(Rd, Rn, Rm, Ra);                                          \\\n+  }\n+\n+  WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)\n+  WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)\n+#undef WRAP\n+\n+\n+  \/\/ macro assembly operations needed for aarch64\n+\n+  \/\/ first two private routines for loading 32 bit or 64 bit constants\n+private:\n+\n+  void mov_immediate64(Register dst, uint64_t imm64);\n+  void mov_immediate32(Register dst, uint32_t imm32);\n+\n+  int push(unsigned int bitset, Register stack);\n+  int pop(unsigned int bitset, Register stack);\n+\n+  int push_fp(unsigned int bitset, Register stack);\n+  int pop_fp(unsigned int bitset, Register stack);\n+\n+  void mov(Register dst, Address a);\n+\n+public:\n+  void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }\n+  void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }\n+\n+  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n+  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+\n+  static RegSet call_clobbered_registers();\n+\n+  \/\/ Push and pop everything that might be clobbered by a native\n+  \/\/ runtime call except rscratch1 and rscratch2.  (They are always\n+  \/\/ scratch, so we don't have to protect them.)  Only save the lower\n+  \/\/ 64 bits of each vector register. Additonal registers can be excluded\n+  \/\/ in a passed RegSet.\n+  void push_call_clobbered_registers_except(RegSet exclude);\n+  void pop_call_clobbered_registers_except(RegSet exclude);\n+\n+  void push_call_clobbered_registers() {\n+    push_call_clobbered_registers_except(RegSet());\n+  }\n+  void pop_call_clobbered_registers() {\n+    pop_call_clobbered_registers_except(RegSet());\n+  }\n+\n+\n+  \/\/ now mov instructions for loading absolute addresses and 32 or\n+  \/\/ 64 bit integers\n+\n+  inline void mov(Register dst, address addr)             { mov_immediate64(dst, (uint64_t)addr); }\n+\n+  inline void mov(Register dst, int imm64)                { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, long imm64)               { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, long long imm64)          { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned int imm64)       { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned long imm64)      { mov_immediate64(dst, (uint64_t)imm64); }\n+  inline void mov(Register dst, unsigned long long imm64) { mov_immediate64(dst, (uint64_t)imm64); }\n+\n+  inline void movw(Register dst, uint32_t imm32)\n+  {\n+    mov_immediate32(dst, imm32);\n+  }\n+\n+  void mov(Register dst, RegisterOrConstant src) {\n+    if (src.is_register())\n+      mov(dst, src.as_register());\n+    else\n+      mov(dst, src.as_constant());\n+  }\n+\n+  void movptr(Register r, uintptr_t imm64);\n+\n+  void mov(FloatRegister Vd, SIMD_Arrangement T, uint32_t imm32);\n+\n+  void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {\n+    orr(Vd, T, Vn, Vn);\n+  }\n+\n+\n+public:\n+\n+  \/\/ Generalized Test Bit And Branch, including a \"far\" variety which\n+  \/\/ spans more than 32KiB.\n+  void tbr(Condition cond, Register Rt, int bitpos, Label &dest, bool isfar = false) {\n+    assert(cond == EQ || cond == NE, \"must be\");\n+\n+    if (isfar)\n+      cond = ~cond;\n+\n+    void (Assembler::* branch)(Register Rt, int bitpos, Label &L);\n+    if (cond == Assembler::EQ)\n+      branch = &Assembler::tbz;\n+    else\n+      branch = &Assembler::tbnz;\n+\n+    if (isfar) {\n+      Label L;\n+      (this->*branch)(Rt, bitpos, L);\n+      b(dest);\n+      bind(L);\n+    } else {\n+      (this->*branch)(Rt, bitpos, dest);\n+    }\n+  }\n+\n+  \/\/ macro instructions for accessing and updating floating point\n+  \/\/ status register\n+  \/\/\n+  \/\/ FPSR : op1 == 011\n+  \/\/        CRn == 0100\n+  \/\/        CRm == 0100\n+  \/\/        op2 == 001\n+\n+  inline void get_fpsr(Register reg)\n+  {\n+    mrs(0b11, 0b0100, 0b0100, 0b001, reg);\n+  }\n+\n+  inline void set_fpsr(Register reg)\n+  {\n+    msr(0b011, 0b0100, 0b0100, 0b001, reg);\n+  }\n+\n+  inline void clear_fpsr()\n+  {\n+    msr(0b011, 0b0100, 0b0100, 0b001, zr);\n+  }\n+\n+  \/\/ DCZID_EL0: op1 == 011\n+  \/\/            CRn == 0000\n+  \/\/            CRm == 0000\n+  \/\/            op2 == 111\n+  inline void get_dczid_el0(Register reg)\n+  {\n+    mrs(0b011, 0b0000, 0b0000, 0b111, reg);\n+  }\n+\n+  \/\/ CTR_EL0:   op1 == 011\n+  \/\/            CRn == 0000\n+  \/\/            CRm == 0000\n+  \/\/            op2 == 001\n+  inline void get_ctr_el0(Register reg)\n+  {\n+    mrs(0b011, 0b0000, 0b0000, 0b001, reg);\n+  }\n+\n+  \/\/ idiv variant which deals with MINLONG as dividend and -1 as divisor\n+  int corrected_idivl(Register result, Register ra, Register rb,\n+                      bool want_remainder, Register tmp = rscratch1);\n+  int corrected_idivq(Register result, Register ra, Register rb,\n+                      bool want_remainder, Register tmp = rscratch1);\n+\n+  \/\/ Support for NULL-checks\n+  \/\/\n+  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ If the accessed location is M[reg + offset] and the offset is known, provide the\n+  \/\/ offset. No explicit code generation is needed if the offset is within a certain\n+  \/\/ range (0 <= offset <= page_size).\n+\n+  virtual void null_check(Register reg, int offset = -1);\n+  static bool needs_explicit_null_check(intptr_t offset);\n+  static bool uses_implicit_null_check(void* address);\n+\n+  static address target_addr_for_insn(address insn_addr, unsigned insn);\n+  static address target_addr_for_insn(address insn_addr) {\n+    unsigned insn = *(unsigned*)insn_addr;\n+    return target_addr_for_insn(insn_addr, insn);\n+  }\n+\n+  \/\/ Required platform-specific helpers for Label::patch_instructions.\n+  \/\/ They _shadow_ the declarations in AbstractAssembler, which are undefined.\n+  static int pd_patch_instruction_size(address branch, address target);\n+  static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {\n+    pd_patch_instruction_size(branch, target);\n+  }\n+  static address pd_call_destination(address branch) {\n+    return target_addr_for_insn(branch);\n+  }\n+#ifndef PRODUCT\n+  static void pd_print_patched_instruction(address branch);\n+#endif\n+\n+  static int patch_oop(address insn_addr, address o);\n+  static int patch_narrow_klass(address insn_addr, narrowKlass n);\n+\n+  address emit_trampoline_stub(int insts_call_instruction_offset, address target);\n+  void emit_static_call_stub();\n+\n+  \/\/ The following 4 methods return the offset of the appropriate move instruction\n+\n+  \/\/ Support for fast byte\/short loading with zero extension (depending on particular CPU)\n+  int load_unsigned_byte(Register dst, Address src);\n+  int load_unsigned_short(Register dst, Address src);\n+\n+  \/\/ Support for fast byte\/short loading with sign extension (depending on particular CPU)\n+  int load_signed_byte(Register dst, Address src);\n+  int load_signed_short(Register dst, Address src);\n+\n+  int load_signed_byte32(Register dst, Address src);\n+  int load_signed_short32(Register dst, Address src);\n+\n+  \/\/ Support for sign-extension (hi:lo = extend_sign(lo))\n+  void extend_sign(Register hi, Register lo);\n+\n+  \/\/ Load and store values by size and signed-ness\n+  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);\n+  void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);\n+\n+  \/\/ Support for inc\/dec with optimal instruction selection depending on value\n+\n+  \/\/ x86_64 aliases an unqualified register\/address increment and\n+  \/\/ decrement to call incrementq and decrementq but also supports\n+  \/\/ explicitly sized calls to incrementq\/decrementq or\n+  \/\/ incrementl\/decrementl\n+\n+  \/\/ for aarch64 the proper convention would be to use\n+  \/\/ increment\/decrement for 64 bit operatons and\n+  \/\/ incrementw\/decrementw for 32 bit operations. so when porting\n+  \/\/ x86_64 code we can leave calls to increment\/decrement as is,\n+  \/\/ replace incrementq\/decrementq with increment\/decrement and\n+  \/\/ replace incrementl\/decrementl with incrementw\/decrementw.\n+\n+  \/\/ n.b. increment\/decrement calls with an Address destination will\n+  \/\/ need to use a scratch register to load the value to be\n+  \/\/ incremented. increment\/decrement calls which add or subtract a\n+  \/\/ constant value greater than 2^12 will need to use a 2nd scratch\n+  \/\/ register to hold the constant. so, a register increment\/decrement\n+  \/\/ may trash rscratch2 and an address increment\/decrement trash\n+  \/\/ rscratch and rscratch2\n+\n+  void decrementw(Address dst, int value = 1);\n+  void decrementw(Register reg, int value = 1);\n+\n+  void decrement(Register reg, int value = 1);\n+  void decrement(Address dst, int value = 1);\n+\n+  void incrementw(Address dst, int value = 1);\n+  void incrementw(Register reg, int value = 1);\n+\n+  void increment(Register reg, int value = 1);\n+  void increment(Address dst, int value = 1);\n+\n+\n+  \/\/ Alignment\n+  void align(int modulus);\n+\n+  \/\/ Stack frame creation\/removal\n+  void enter()\n+  {\n+    stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+    mov(rfp, sp);\n+  }\n+  void leave()\n+  {\n+    mov(sp, rfp);\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  }\n+\n+  \/\/ Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)\n+  \/\/ The pointer will be loaded into the thread register.\n+  void get_thread(Register thread);\n+\n+\n+  \/\/ Support for VM calls\n+  \/\/\n+  \/\/ It is imperative that all calls into the VM are handled via the call_VM macros.\n+  \/\/ They make sure that the stack linkage is setup correctly. call_VM's correspond\n+  \/\/ to ENTRY\/ENTRY_X entry points while call_VM_leaf's correspond to LEAF entry points.\n+\n+\n+  void call_VM(Register oop_result,\n+               address entry_point,\n+               bool check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               address entry_point,\n+               Register arg_1,\n+               bool check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               address entry_point,\n+               Register arg_1, Register arg_2,\n+               bool check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               address entry_point,\n+               Register arg_1, Register arg_2, Register arg_3,\n+               bool check_exceptions = true);\n+\n+  \/\/ Overloadings with last_Java_sp\n+  void call_VM(Register oop_result,\n+               Register last_java_sp,\n+               address entry_point,\n+               int number_of_arguments = 0,\n+               bool check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               Register last_java_sp,\n+               address entry_point,\n+               Register arg_1, bool\n+               check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               Register last_java_sp,\n+               address entry_point,\n+               Register arg_1, Register arg_2,\n+               bool check_exceptions = true);\n+  void call_VM(Register oop_result,\n+               Register last_java_sp,\n+               address entry_point,\n+               Register arg_1, Register arg_2, Register arg_3,\n+               bool check_exceptions = true);\n+\n+  void get_vm_result  (Register oop_result, Register thread);\n+  void get_vm_result_2(Register metadata_result, Register thread);\n+\n+  \/\/ These always tightly bind to MacroAssembler::call_VM_base\n+  \/\/ bypassing the virtual implementation\n+  void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);\n+  void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);\n+  void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);\n+  void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);\n+  void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);\n+\n+  void call_VM_leaf(address entry_point,\n+                    int number_of_arguments = 0);\n+  void call_VM_leaf(address entry_point,\n+                    Register arg_1);\n+  void call_VM_leaf(address entry_point,\n+                    Register arg_1, Register arg_2);\n+  void call_VM_leaf(address entry_point,\n+                    Register arg_1, Register arg_2, Register arg_3);\n+\n+  \/\/ These always tightly bind to MacroAssembler::call_VM_leaf_base\n+  \/\/ bypassing the virtual implementation\n+  void super_call_VM_leaf(address entry_point);\n+  void super_call_VM_leaf(address entry_point, Register arg_1);\n+  void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);\n+  void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);\n+  void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);\n+\n+  \/\/ last Java Frame (fills frame anchor)\n+  void set_last_Java_frame(Register last_java_sp,\n+                           Register last_java_fp,\n+                           address last_java_pc,\n+                           Register scratch);\n+\n+  void set_last_Java_frame(Register last_java_sp,\n+                           Register last_java_fp,\n+                           Label &last_java_pc,\n+                           Register scratch);\n+\n+  void set_last_Java_frame(Register last_java_sp,\n+                           Register last_java_fp,\n+                           Register last_java_pc,\n+                           Register scratch);\n+\n+  void reset_last_Java_frame(Register thread);\n+\n+  \/\/ thread in the default location (rthread)\n+  void reset_last_Java_frame(bool clear_fp);\n+\n+  \/\/ Stores\n+  void store_check(Register obj);                \/\/ store check for obj - register is destroyed afterwards\n+  void store_check(Register obj, Address dst);   \/\/ same as above, dst is exact store location (reg. is destroyed)\n+\n+  void resolve_jobject(Register value, Register thread, Register tmp);\n+\n+  \/\/ C 'boolean' to Java boolean: x == 0 ? 0 : 1\n+  void c2bool(Register x);\n+\n+  void load_method_holder_cld(Register rresult, Register rmethod);\n+  void load_method_holder(Register holder, Register method);\n+\n+  \/\/ oop manipulations\n+  void load_klass(Register dst, Register src);\n+  void store_klass(Register dst, Register src);\n+  void cmp_klass(Register oop, Register trial_klass, Register tmp);\n+\n+  void resolve_weak_handle(Register result, Register tmp);\n+  void resolve_oop_handle(Register result, Register tmp = r5);\n+  void load_mirror(Register dst, Register method, Register tmp = r5);\n+\n+  void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,\n+                      Register tmp1, Register tmp_thread);\n+\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+                       Register tmp1, Register tmp_thread);\n+\n+  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,\n+                     Register thread_tmp = noreg, DecoratorSet decorators = 0);\n+\n+  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,\n+                              Register thread_tmp = noreg, DecoratorSet decorators = 0);\n+  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n+                      Register tmp_thread = noreg, DecoratorSet decorators = 0);\n+\n+  \/\/ currently unimplemented\n+  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ stored using routines that take a jobject.\n+  void store_heap_oop_null(Address dst);\n+\n+  void store_klass_gap(Register dst, Register src);\n+\n+  \/\/ This dummy is to prevent a call to store_heap_oop from\n+  \/\/ converting a zero (like NULL) into a Register by giving\n+  \/\/ the compiler two choices it can't resolve\n+\n+  void store_heap_oop(Address dst, void* dummy);\n+\n+  void encode_heap_oop(Register d, Register s);\n+  void encode_heap_oop(Register r) { encode_heap_oop(r, r); }\n+  void decode_heap_oop(Register d, Register s);\n+  void decode_heap_oop(Register r) { decode_heap_oop(r, r); }\n+  void encode_heap_oop_not_null(Register r);\n+  void decode_heap_oop_not_null(Register r);\n+  void encode_heap_oop_not_null(Register dst, Register src);\n+  void decode_heap_oop_not_null(Register dst, Register src);\n+\n+  void set_narrow_oop(Register dst, jobject obj);\n+\n+  void encode_klass_not_null(Register r);\n+  void decode_klass_not_null(Register r);\n+  void encode_klass_not_null(Register dst, Register src);\n+  void decode_klass_not_null(Register dst, Register src);\n+\n+  void set_narrow_klass(Register dst, Klass* k);\n+\n+  \/\/ if heap base register is used - reinit it with the correct value\n+  void reinit_heapbase();\n+\n+  DEBUG_ONLY(void verify_heapbase(const char* msg);)\n+\n+  void push_CPU_state(bool save_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n+  void pop_CPU_state(bool restore_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n+\n+  \/\/ Round up to a power of two\n+  void round_to(Register reg, int modulus);\n+\n+  \/\/ allocation\n+  void eden_allocate(\n+    Register obj,                      \/\/ result: pointer to object after successful allocation\n+    Register var_size_in_bytes,        \/\/ object size in bytes if unknown at compile time; invalid otherwise\n+    int      con_size_in_bytes,        \/\/ object size in bytes if   known at compile time\n+    Register t1,                       \/\/ temp register\n+    Label&   slow_case                 \/\/ continuation point if fast allocation fails\n+  );\n+  void tlab_allocate(\n+    Register obj,                      \/\/ result: pointer to object after successful allocation\n+    Register var_size_in_bytes,        \/\/ object size in bytes if unknown at compile time; invalid otherwise\n+    int      con_size_in_bytes,        \/\/ object size in bytes if   known at compile time\n+    Register t1,                       \/\/ temp register\n+    Register t2,                       \/\/ temp register\n+    Label&   slow_case                 \/\/ continuation point if fast allocation fails\n+  );\n+  void verify_tlab();\n+\n+  \/\/ interface method calling\n+  void lookup_interface_method(Register recv_klass,\n+                               Register intf_klass,\n+                               RegisterOrConstant itable_index,\n+                               Register method_result,\n+                               Register scan_temp,\n+                               Label& no_such_interface,\n+                   bool return_method = true);\n+\n+  \/\/ virtual method calling\n+  \/\/ n.b. x86 allows RegisterOrConstant for vtable_index\n+  void lookup_virtual_method(Register recv_klass,\n+                             RegisterOrConstant vtable_index,\n+                             Register method_result);\n+\n+  \/\/ Test sub_klass against super_klass, with fast and slow paths.\n+\n+  \/\/ The fast path produces a tri-state answer: yes \/ no \/ maybe-slow.\n+  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ If super_check_offset is -1, the value is loaded up from super_klass.\n+  \/\/ No registers are killed, except temp_reg.\n+  void check_klass_subtype_fast_path(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp_reg,\n+                                     Label* L_success,\n+                                     Label* L_failure,\n+                                     Label* L_slow_path,\n+                RegisterOrConstant super_check_offset = RegisterOrConstant(-1));\n+\n+  \/\/ The rest of the type check; must be wired to a corresponding fast path.\n+  \/\/ It does not repeat the fast path logic, so don't use it standalone.\n+  \/\/ The temp_reg and temp2_reg can be noreg, if no temps are available.\n+  \/\/ Updates the sub's secondary super cache as necessary.\n+  \/\/ If set_cond_codes, condition codes will be Z on success, NZ on failure.\n+  void check_klass_subtype_slow_path(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp_reg,\n+                                     Register temp2_reg,\n+                                     Label* L_success,\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n+\n+  \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ Falls through on failure.\n+  void check_klass_subtype(Register sub_klass,\n+                           Register super_klass,\n+                           Register temp_reg,\n+                           Label& L_success);\n+\n+  void clinit_barrier(Register klass,\n+                      Register thread,\n+                      Label* L_fast_path = NULL,\n+                      Label* L_slow_path = NULL);\n+\n+  Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);\n+\n+  void verify_sve_vector_length();\n+  void reinitialize_ptrue() {\n+    if (UseSVE > 0) {\n+      sve_ptrue(ptrue, B);\n+    }\n+  }\n+  void verify_ptrue();\n+\n+  \/\/ Debugging\n+\n+  \/\/ only if +VerifyOops\n+  void verify_oop(Register reg, const char* s = \"broken oop\");\n+  void verify_oop_addr(Address addr, const char * s = \"broken oop addr\");\n+\n+\/\/ TODO: verify method and klass metadata (compare against vptr?)\n+  void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}\n+  void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}\n+\n+#define verify_method_ptr(reg) _verify_method_ptr(reg, \"broken method \" #reg, __FILE__, __LINE__)\n+#define verify_klass_ptr(reg) _verify_klass_ptr(reg, \"broken klass \" #reg, __FILE__, __LINE__)\n+\n+  \/\/ only if +VerifyFPU\n+  void verify_FPU(int stack_depth, const char* s = \"illegal FPU state\");\n+\n+  \/\/ prints msg, dumps registers and stops execution\n+  void stop(const char* msg);\n+\n+  static void debug64(char* msg, int64_t pc, int64_t regs[]);\n+\n+  void untested()                                { stop(\"untested\"); }\n+\n+  void unimplemented(const char* what = \"\");\n+\n+  void should_not_reach_here()                   { stop(\"should not reach here\"); }\n+\n+  \/\/ Stack overflow checking\n+  void bang_stack_with_offset(int offset) {\n+    \/\/ stack grows down, caller passes positive offset\n+    assert(offset > 0, \"must bang with negative offset\");\n+    sub(rscratch2, sp, offset);\n+    str(zr, Address(rscratch2));\n+  }\n+\n+  \/\/ Writes to stack successive pages until offset reached to check for\n+  \/\/ stack overflow + shadow pages.  Also, clobbers tmp\n+  void bang_stack_size(Register size, Register tmp);\n+\n+  \/\/ Check for reserved stack access in method being exited (for JIT)\n+  void reserved_stack_check();\n+\n+  \/\/ Arithmetics\n+\n+  void addptr(const Address &dst, int32_t src);\n+  void cmpptr(Register src1, Address src2);\n+\n+  void cmpoop(Register obj1, Register obj2);\n+\n+  \/\/ Various forms of CAS\n+\n+  void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n+                          Label &suceed, Label *fail);\n+  void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,\n+                  Label &suceed, Label *fail);\n+\n+  void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,\n+                  Label &suceed, Label *fail);\n+\n+  void atomic_add(Register prev, RegisterOrConstant incr, Register addr);\n+  void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);\n+  void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);\n+  void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);\n+\n+  void atomic_xchg(Register prev, Register newv, Register addr);\n+  void atomic_xchgw(Register prev, Register newv, Register addr);\n+  void atomic_xchgl(Register prev, Register newv, Register addr);\n+  void atomic_xchglw(Register prev, Register newv, Register addr);\n+  void atomic_xchgal(Register prev, Register newv, Register addr);\n+  void atomic_xchgalw(Register prev, Register newv, Register addr);\n+\n+  void orptr(Address adr, RegisterOrConstant src) {\n+    ldr(rscratch1, adr);\n+    if (src.is_register())\n+      orr(rscratch1, rscratch1, src.as_register());\n+    else\n+      orr(rscratch1, rscratch1, src.as_constant());\n+    str(rscratch1, adr);\n+  }\n+\n+  \/\/ A generic CAS; success or failure is in the EQ flag.\n+  \/\/ Clobbers rscratch1\n+  void cmpxchg(Register addr, Register expected, Register new_val,\n+               enum operand_size size,\n+               bool acquire, bool release, bool weak,\n+               Register result);\n+\n+private:\n+  void compare_eq(Register rn, Register rm, enum operand_size size);\n+\n+#ifdef ASSERT\n+  \/\/ Template short-hand support to clean-up after a failed call to trampoline\n+  \/\/ call generation (see trampoline_call() below),  when a set of Labels must\n+  \/\/ be reset (before returning).\n+  template<typename Label, typename... More>\n+  void reset_labels(Label &lbl, More&... more) {\n+    lbl.reset(); reset_labels(more...);\n+  }\n+  template<typename Label>\n+  void reset_labels(Label &lbl) {\n+    lbl.reset();\n+  }\n+#endif\n+\n+public:\n+  \/\/ Calls\n+\n+  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL);\n+\n+  static bool far_branches() {\n+    return ReservedCodeCacheSize > branch_range;\n+  }\n+\n+  \/\/ Jumps that can reach anywhere in the code cache.\n+  \/\/ Trashes tmp.\n+  void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+  void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+\n+  static int far_branch_size() {\n+    if (far_branches()) {\n+      return 3 * 4;  \/\/ adrp, add, br\n+    } else {\n+      return 4;\n+    }\n+  }\n+\n+  \/\/ Emit the CompiledIC call idiom\n+  address ic_call(address entry, jint method_index = 0);\n+\n+public:\n+\n+  \/\/ Data\n+\n+  void mov_metadata(Register dst, Metadata* obj);\n+  Address allocate_metadata_address(Metadata* obj);\n+  Address constant_oop_address(jobject obj);\n+\n+  void movoop(Register dst, jobject obj, bool immediate = false);\n+\n+  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.\n+  void kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp, Register tmp2, Register tmp3);\n+  \/\/ CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.\n+  void kernel_crc32c(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp, Register tmp2, Register tmp3);\n+\n+  \/\/ Stack push and pop individual 64 bit registers\n+  void push(Register src);\n+  void pop(Register dst);\n+\n+  \/\/ push all registers onto the stack\n+  void pusha();\n+  void popa();\n+\n+  void repne_scan(Register addr, Register value, Register count,\n+                  Register scratch);\n+  void repne_scanw(Register addr, Register value, Register count,\n+                   Register scratch);\n+\n+  typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);\n+  typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);\n+\n+  \/\/ If a constant does not fit in an immediate field, generate some\n+  \/\/ number of MOV instructions and then perform the operation\n+  void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,\n+                             add_sub_imm_insn insn1,\n+                             add_sub_reg_insn insn2);\n+  \/\/ Seperate vsn which sets the flags\n+  void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,\n+                             add_sub_imm_insn insn1,\n+                             add_sub_reg_insn insn2);\n+\n+#define WRAP(INSN)                                                      \\\n+  void INSN(Register Rd, Register Rn, unsigned imm) {                   \\\n+    wrap_add_sub_imm_insn(Rd, Rn, imm, &Assembler::INSN, &Assembler::INSN); \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm,                      \\\n+             enum shift_kind kind, unsigned shift = 0) {                \\\n+    Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm) {                    \\\n+    Assembler::INSN(Rd, Rn, Rm);                                        \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm,                      \\\n+           ext::operation option, int amount = 0) {                     \\\n+    Assembler::INSN(Rd, Rn, Rm, option, amount);                        \\\n+  }\n+\n+  WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)\n+\n+#undef WRAP\n+#define WRAP(INSN)                                                      \\\n+  void INSN(Register Rd, Register Rn, unsigned imm) {                   \\\n+    wrap_adds_subs_imm_insn(Rd, Rn, imm, &Assembler::INSN, &Assembler::INSN); \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm,                      \\\n+             enum shift_kind kind, unsigned shift = 0) {                \\\n+    Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm) {                    \\\n+    Assembler::INSN(Rd, Rn, Rm);                                        \\\n+  }                                                                     \\\n+                                                                        \\\n+  void INSN(Register Rd, Register Rn, Register Rm,                      \\\n+           ext::operation option, int amount = 0) {                     \\\n+    Assembler::INSN(Rd, Rn, Rm, option, amount);                        \\\n+  }\n+\n+  WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)\n+\n+  void add(Register Rd, Register Rn, RegisterOrConstant increment);\n+  void addw(Register Rd, Register Rn, RegisterOrConstant increment);\n+  void sub(Register Rd, Register Rn, RegisterOrConstant decrement);\n+  void subw(Register Rd, Register Rn, RegisterOrConstant decrement);\n+\n+  void adrp(Register reg1, const Address &dest, uint64_t &byte_offset);\n+\n+  void tableswitch(Register index, jint lowbound, jint highbound,\n+                   Label &jumptable, Label &jumptable_end, int stride = 1) {\n+    adr(rscratch1, jumptable);\n+    subsw(rscratch2, index, lowbound);\n+    subsw(zr, rscratch2, highbound - lowbound);\n+    br(Assembler::HS, jumptable_end);\n+    add(rscratch1, rscratch1, rscratch2,\n+        ext::sxtw, exact_log2(stride * Assembler::instruction_size));\n+    br(rscratch1);\n+  }\n+\n+  \/\/ Form an address from base + offset in Rd.  Rd may or may not\n+  \/\/ actually be used: you must use the Address that is returned.  It\n+  \/\/ is up to you to ensure that the shift provided matches the size\n+  \/\/ of your data.\n+  Address form_address(Register Rd, Register base, int64_t byte_offset, int shift);\n+\n+  \/\/ Return true iff an address is within the 48-bit AArch64 address\n+  \/\/ space.\n+  bool is_valid_AArch64_address(address a) {\n+    return ((uint64_t)a >> 48) == 0;\n+  }\n+\n+  \/\/ Load the base of the cardtable byte map into reg.\n+  void load_byte_map_base(Register reg);\n+\n+  \/\/ Prolog generator routines to support switch between x86 code and\n+  \/\/ generated ARM code\n+\n+  \/\/ routine to generate an x86 prolog for a stub function which\n+  \/\/ bootstraps into the generated ARM code which directly follows the\n+  \/\/ stub\n+  \/\/\n+\n+  public:\n+\n+  void ldr_constant(Register dest, const Address &const_addr) {\n+    if (NearCpool) {\n+      ldr(dest, const_addr);\n+    } else {\n+      uint64_t offset;\n+      adrp(dest, InternalAddress(const_addr.target()), offset);\n+      ldr(dest, Address(dest, offset));\n+    }\n+  }\n+\n+  address read_polling_page(Register r, relocInfo::relocType rtype);\n+  void get_polling_page(Register dest, relocInfo::relocType rtype);\n+\n+  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.\n+  void update_byte_crc32(Register crc, Register val, Register table);\n+  void update_word_crc32(Register crc, Register v, Register tmp,\n+        Register table0, Register table1, Register table2, Register table3,\n+        bool upper = false);\n+\n+  address has_negatives(Register ary1, Register len, Register result);\n+\n+  address arrays_equals(Register a1, Register a2, Register result, Register cnt1,\n+                        Register tmp1, Register tmp2, Register tmp3, int elem_size);\n+\n+  void string_equals(Register a1, Register a2, Register result, Register cnt1,\n+                     int elem_size);\n+\n+  void fill_words(Register base, Register cnt, Register value);\n+  void zero_words(Register base, uint64_t cnt);\n+  address zero_words(Register ptr, Register cnt);\n+  void zero_dcache_blocks(Register base, Register cnt);\n+\n+  static const int zero_words_block_size;\n+\n+  address byte_array_inflate(Register src, Register dst, Register len,\n+                             FloatRegister vtmp1, FloatRegister vtmp2,\n+                             FloatRegister vtmp3, Register tmp4);\n+\n+  void char_array_compress(Register src, Register dst, Register len,\n+                           FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n+                           FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n+                           Register result);\n+\n+  void encode_iso_array(Register src, Register dst,\n+                        Register len, Register result,\n+                        FloatRegister Vtmp1, FloatRegister Vtmp2,\n+                        FloatRegister Vtmp3, FloatRegister Vtmp4);\n+  void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,\n+                FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,\n+                FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,\n+                FloatRegister tmpC4, Register tmp1, Register tmp2,\n+                Register tmp3, Register tmp4, Register tmp5);\n+  void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,\n+      address pio2, address dsin_coef, address dcos_coef);\n+ private:\n+  \/\/ begin trigonometric functions support block\n+  void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);\n+  void generate__kernel_rem_pio2(address two_over_pi, address pio2);\n+  void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);\n+  void generate_kernel_cos(FloatRegister x, address dcos_coef);\n+  \/\/ end trigonometric functions support block\n+  void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,\n+                       Register src1, Register src2);\n+  void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {\n+    add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);\n+  }\n+  void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,\n+                             Register y, Register y_idx, Register z,\n+                             Register carry, Register product,\n+                             Register idx, Register kdx);\n+  void multiply_128_x_128_loop(Register y, Register z,\n+                               Register carry, Register carry2,\n+                               Register idx, Register jdx,\n+                               Register yz_idx1, Register yz_idx2,\n+                               Register tmp, Register tmp3, Register tmp4,\n+                               Register tmp7, Register product_hi);\n+  void kernel_crc32_using_crc32(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n+  void kernel_crc32c_using_crc32c(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n+\n+  void ghash_modmul_wide (int index, FloatRegister result,\n+                          FloatRegister result_lo, FloatRegister result_hi, FloatRegister b,\n+                          FloatRegister a, FloatRegister vzr, FloatRegister a1_xor_a0, FloatRegister p,\n+                          FloatRegister t1, FloatRegister t2, FloatRegister t3);\n+  void ghash_modmul (FloatRegister result,\n+                     FloatRegister result_lo, FloatRegister result_hi, FloatRegister b,\n+                     FloatRegister a, FloatRegister vzr, FloatRegister a1_xor_a0, FloatRegister p,\n+                     FloatRegister t1, FloatRegister t2, FloatRegister t3);\n+  void ghash_load_wide(int index, Register data, FloatRegister result, FloatRegister state);\n+public:\n+  void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,\n+                       Register zlen, Register tmp1, Register tmp2, Register tmp3,\n+                       Register tmp4, Register tmp5, Register tmp6, Register tmp7);\n+  void mul_add(Register out, Register in, Register offs, Register len, Register k);\n+  void ghash_multiply(FloatRegister result_lo, FloatRegister result_hi,\n+                      FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n+                      FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3);\n+  void ghash_multiply_wide(int index,\n+                           FloatRegister result_lo, FloatRegister result_hi,\n+                           FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n+                           FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3);\n+  void ghash_reduce(FloatRegister result, FloatRegister lo, FloatRegister hi,\n+                    FloatRegister p, FloatRegister z, FloatRegister t1);\n+  void ghash_reduce_wide(int index, FloatRegister result, FloatRegister lo, FloatRegister hi,\n+                    FloatRegister p, FloatRegister z, FloatRegister t1);\n+  void ghash_processBlocks_wide(address p, Register state, Register subkeyH,\n+                                Register data, Register blocks, int unrolls);\n+\n+\n+  void aesenc_loadkeys(Register key, Register keylen);\n+  void aesecb_encrypt(Register from, Register to, Register keylen,\n+                      FloatRegister data = v0, int unrolls = 1);\n+  void aesecb_decrypt(Register from, Register to, Register key, Register keylen);\n+  void aes_round(FloatRegister input, FloatRegister subkey);\n+\n+  \/\/ Place an ISB after code may have been modified due to a safepoint.\n+  void safepoint_isb();\n+\n+private:\n+  \/\/ Return the effective address r + (r1 << ext) + offset.\n+  \/\/ Uses rscratch2.\n+  Address offsetted_address(Register r, Register r1, Address::extend ext,\n+                            int offset, int size);\n+\n+private:\n+  \/\/ Returns an address on the stack which is reachable with a ldr\/str of size\n+  \/\/ Uses rscratch2 if the address is not directly reachable\n+  Address spill_address(int size, int offset, Register tmp=rscratch2);\n+  Address sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp=rscratch2);\n+\n+  bool merge_alignment_check(Register base, size_t size, int64_t cur_offset, int64_t prev_offset) const;\n+\n+  \/\/ Check whether two loads\/stores can be merged into ldp\/stp.\n+  bool ldst_can_merge(Register rx, const Address &adr, size_t cur_size_in_bytes, bool is_store) const;\n+\n+  \/\/ Merge current load\/store with previous load\/store into ldp\/stp.\n+  void merge_ldst(Register rx, const Address &adr, size_t cur_size_in_bytes, bool is_store);\n+\n+  \/\/ Try to merge two loads\/stores into ldp\/stp. If success, returns true else false.\n+  bool try_merge_ldst(Register rt, const Address &adr, size_t cur_size_in_bytes, bool is_store);\n+\n+public:\n+  void spill(Register Rx, bool is64, int offset) {\n+    if (is64) {\n+      str(Rx, spill_address(8, offset));\n+    } else {\n+      strw(Rx, spill_address(4, offset));\n+    }\n+  }\n+  void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {\n+    str(Vx, T, spill_address(1 << (int)T, offset));\n+  }\n+  void spill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_str(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n+  void unspill(Register Rx, bool is64, int offset) {\n+    if (is64) {\n+      ldr(Rx, spill_address(8, offset));\n+    } else {\n+      ldrw(Rx, spill_address(4, offset));\n+    }\n+  }\n+  void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {\n+    ldr(Vx, T, spill_address(1 << (int)T, offset));\n+  }\n+  void unspill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_ldr(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n+  void spill_copy128(int src_offset, int dst_offset,\n+                     Register tmp1=rscratch1, Register tmp2=rscratch2) {\n+    if (src_offset < 512 && (src_offset & 7) == 0 &&\n+        dst_offset < 512 && (dst_offset & 7) == 0) {\n+      ldp(tmp1, tmp2, Address(sp, src_offset));\n+      stp(tmp1, tmp2, Address(sp, dst_offset));\n+    } else {\n+      unspill(tmp1, true, src_offset);\n+      spill(tmp1, true, dst_offset);\n+      unspill(tmp1, true, src_offset+8);\n+      spill(tmp1, true, dst_offset+8);\n+    }\n+  }\n+  void spill_copy_sve_vector_stack_to_stack(int src_offset, int dst_offset,\n+                                            int sve_vec_reg_size_in_bytes) {\n+    assert(sve_vec_reg_size_in_bytes % 16 == 0, \"unexpected sve vector reg size\");\n+    for (int i = 0; i < sve_vec_reg_size_in_bytes \/ 16; i++) {\n+      spill_copy128(src_offset, dst_offset);\n+      src_offset += 16;\n+      dst_offset += 16;\n+    }\n+  }\n+  void cache_wb(Address line);\n+  void cache_wbsync(bool is_pre);\n+\n+private:\n+  \/\/ Check the current thread doesn't need a cross modify fence.\n+  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n+\n+};\n+\n+#ifdef ASSERT\n+inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }\n+#endif\n+\n+\/**\n+ * class SkipIfEqual:\n+ *\n+ * Instantiating this class will result in assembly code being output that will\n+ * jump around any code emitted between the creation of the instance and it's\n+ * automatic destruction at the end of a scope block, depending on the value of\n+ * the flag passed to the constructor, which will be checked at run-time.\n+ *\/\n+class SkipIfEqual {\n+ private:\n+  MacroAssembler* _masm;\n+  Label _label;\n+\n+ public:\n+   SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);\n+   ~SkipIfEqual();\n+};\n+\n+struct tableswitch {\n+  Register _reg;\n+  int _insn_index; jint _first_key; jint _last_key;\n+  Label _after;\n+  Label _branches;\n+};\n+\n+#endif \/\/ CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1448,"deletions":0,"binary":false,"changes":1448,"status":"added"}]}