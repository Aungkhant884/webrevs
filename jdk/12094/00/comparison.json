{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-  if (fp == NULL) {\n+  if (fp == nullptr) {\n@@ -317,1 +317,1 @@\n-  while (fgets(line, sizeof(line), fp) != NULL) {\n+  while (fgets(line, sizeof(line), fp) != nullptr) {\n@@ -319,1 +319,1 @@\n-    while (keywords_to_match[i] != NULL) {\n+    while (keywords_to_match[i] != nullptr) {\n@@ -357,2 +357,2 @@\n-  if (NULL == tmp) {\n-    return NULL;\n+  if (nullptr == tmp) {\n+    return nullptr;\n@@ -367,2 +367,2 @@\n-  if (NULL == tmp) {\n-    return NULL;\n+  if (nullptr == tmp) {\n+    return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-char*  Arguments::_jvm_flags_file               = NULL;\n-char** Arguments::_jvm_flags_array              = NULL;\n+char*  Arguments::_jvm_flags_file               = nullptr;\n+char** Arguments::_jvm_flags_array              = nullptr;\n@@ -78,1 +78,1 @@\n-char** Arguments::_jvm_args_array               = NULL;\n+char** Arguments::_jvm_args_array               = nullptr;\n@@ -80,2 +80,2 @@\n-char*  Arguments::_java_command                 = NULL;\n-SystemProperty* Arguments::_system_properties   = NULL;\n+char*  Arguments::_java_command                 = nullptr;\n+SystemProperty* Arguments::_system_properties   = nullptr;\n@@ -86,1 +86,1 @@\n-const char*  Arguments::_java_vendor_url_bug    = NULL;\n+const char*  Arguments::_java_vendor_url_bug    = nullptr;\n@@ -99,2 +99,2 @@\n-char*  Arguments::SharedArchivePath             = NULL;\n-char*  Arguments::SharedDynamicArchivePath      = NULL;\n+char*  Arguments::SharedArchivePath             = nullptr;\n+char*  Arguments::SharedDynamicArchivePath      = nullptr;\n@@ -110,3 +110,3 @@\n-abort_hook_t     Arguments::_abort_hook         = NULL;\n-exit_hook_t      Arguments::_exit_hook          = NULL;\n-vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;\n+abort_hook_t     Arguments::_abort_hook         = nullptr;\n+exit_hook_t      Arguments::_exit_hook          = nullptr;\n+vfprintf_hook_t  Arguments::_vfprintf_hook      = nullptr;\n@@ -115,6 +115,6 @@\n-SystemProperty *Arguments::_sun_boot_library_path = NULL;\n-SystemProperty *Arguments::_java_library_path = NULL;\n-SystemProperty *Arguments::_java_home = NULL;\n-SystemProperty *Arguments::_java_class_path = NULL;\n-SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;\n-SystemProperty *Arguments::_vm_info = NULL;\n+SystemProperty *Arguments::_sun_boot_library_path = nullptr;\n+SystemProperty *Arguments::_java_library_path = nullptr;\n+SystemProperty *Arguments::_java_home = nullptr;\n+SystemProperty *Arguments::_java_class_path = nullptr;\n+SystemProperty *Arguments::_jdk_boot_class_path_append = nullptr;\n+SystemProperty *Arguments::_vm_info = nullptr;\n@@ -122,2 +122,2 @@\n-GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = NULL;\n-PathString *Arguments::_boot_class_path = NULL;\n+GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = nullptr;\n+PathString *Arguments::_boot_class_path = nullptr;\n@@ -126,1 +126,1 @@\n-char* Arguments::_ext_dirs = NULL;\n+char* Arguments::_ext_dirs = nullptr;\n@@ -133,1 +133,1 @@\n-  if (new_value == NULL) {\n+  if (new_value == nullptr) {\n@@ -137,1 +137,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -148,1 +148,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -150,1 +150,1 @@\n-    if (_value != NULL) {\n+    if (_value != nullptr) {\n@@ -154,3 +154,3 @@\n-    assert(sp != NULL, \"Unable to allocate space for new append path value\");\n-    if (sp != NULL) {\n-      if (_value != NULL) {\n+    assert(sp != nullptr, \"Unable to allocate space for new append path value\");\n+    if (sp != nullptr) {\n+      if (_value != nullptr) {\n@@ -170,2 +170,2 @@\n-  if (value == NULL) {\n-    _value = NULL;\n+  if (value == nullptr) {\n+    _value = nullptr;\n@@ -179,1 +179,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -181,1 +181,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -186,1 +186,1 @@\n-  assert(module_name != NULL && path != NULL, \"Invalid module name or path value\");\n+  assert(module_name != nullptr && path != nullptr, \"Invalid module name or path value\");\n@@ -194,1 +194,1 @@\n-  if (_module_name != NULL) {\n+  if (_module_name != nullptr) {\n@@ -196,1 +196,1 @@\n-    _module_name = NULL;\n+    _module_name = nullptr;\n@@ -198,1 +198,1 @@\n-  if (_path != NULL) {\n+  if (_path != nullptr) {\n@@ -200,1 +200,1 @@\n-    _path = NULL;\n+    _path = nullptr;\n@@ -205,2 +205,2 @@\n-  if (key == NULL) {\n-    _key = NULL;\n+  if (key == nullptr) {\n+    _key = nullptr;\n@@ -211,1 +211,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -221,2 +221,2 @@\n-  if (options == NULL) {\n-    _options = NULL;\n+  if (options == nullptr) {\n+    _options = nullptr;\n@@ -229,1 +229,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -250,1 +250,1 @@\n-  const char* tail = NULL;\n+  const char* tail = nullptr;\n@@ -252,1 +252,1 @@\n-  if (tail != NULL && *tail == '\\0') {\n+  if (tail != nullptr && *tail == '\\0') {\n@@ -264,1 +264,1 @@\n-  for (\/* empty *\/; *names != NULL; ++names) {\n+  for (\/* empty *\/; *names != nullptr; ++names) {\n@@ -279,2 +279,2 @@\n-  assert((*option)->optionString != NULL, \"invariant\");\n-  char* tail = NULL;\n+  assert((*option)->optionString != nullptr, \"invariant\");\n+  char* tail = nullptr;\n@@ -326,1 +326,1 @@\n-  _libraryList.add(new AgentLibrary(name, options, false, NULL));\n+  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n@@ -330,1 +330,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n@@ -334,1 +334,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL, true));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n@@ -398,1 +398,1 @@\n-  _boot_class_path = new PathString(NULL);\n+  _boot_class_path = new PathString(nullptr);\n@@ -410,1 +410,1 @@\n-  \/\/ Properties values are set to NULL and they are\n+  \/\/ Properties values are set to nullptr and they are\n@@ -412,3 +412,3 @@\n-  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", NULL,  true);\n-  _java_library_path = new SystemProperty(\"java.library.path\", NULL,  true);\n-  _java_home =  new SystemProperty(\"java.home\", NULL,  true);\n+  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", nullptr,  true);\n+  _java_library_path = new SystemProperty(\"java.library.path\", nullptr,  true);\n+  _java_home =  new SystemProperty(\"java.home\", nullptr,  true);\n@@ -420,1 +420,1 @@\n-  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", NULL, false, true);\n+  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", nullptr, false, true);\n@@ -573,1 +573,1 @@\n-  { NULL, JDK_Version(0), JDK_Version(0) }\n+  { nullptr, JDK_Version(0), JDK_Version(0) }\n@@ -585,1 +585,1 @@\n-  { NULL, NULL}\n+  { nullptr, nullptr}\n@@ -599,1 +599,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -609,1 +609,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -620,1 +620,1 @@\n-        if (real_flag != NULL) {\n+        if (real_flag != nullptr) {\n@@ -635,1 +635,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -652,1 +652,1 @@\n-  for (size_t i = 0; aliased_jvm_flags[i].alias_name != NULL; i++) {\n+  for (size_t i = 0; aliased_jvm_flags[i].alias_name != nullptr; i++) {\n@@ -663,1 +663,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -692,1 +692,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -725,1 +725,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -740,1 +740,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -849,1 +849,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -860,1 +860,1 @@\n-  size_t old_len = old_value != NULL ? strlen(old_value) : 0;\n+  size_t old_len = old_value != nullptr ? strlen(old_value) : 0;\n@@ -863,1 +863,1 @@\n-  char* free_this_too = NULL;\n+  char* free_this_too = nullptr;\n@@ -897,1 +897,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -915,1 +915,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -924,1 +924,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -933,2 +933,2 @@\n-  if (real_name == NULL) {\n-    return NULL;\n+  if (real_name == nullptr) {\n+    return nullptr;\n@@ -966,1 +966,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -1003,1 +1003,1 @@\n-  assert(bldarray != NULL, \"illegal argument\");\n+  assert(bldarray != nullptr, \"illegal argument\");\n@@ -1005,1 +1005,1 @@\n-  if (arg == NULL) {\n+  if (arg == nullptr) {\n@@ -1012,1 +1012,1 @@\n-  if (*bldarray == NULL) {\n+  if (*bldarray == nullptr) {\n@@ -1032,2 +1032,2 @@\n-  if (args == NULL || count == 0) {\n-    return NULL;\n+  if (args == nullptr || count == 0) {\n+    return nullptr;\n@@ -1037,1 +1037,1 @@\n-    length += strlen(args[i]) + 1; \/\/ add 1 for a space or NULL terminating character\n+    length += strlen(args[i]) + 1; \/\/ add 1 for a space or null terminating character\n@@ -1042,2 +1042,2 @@\n-    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or NULL terminating character\n-    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with NULL character\n+    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or null terminating character\n+    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with null character\n@@ -1061,1 +1061,1 @@\n-  if (_java_class_path != NULL) {\n+  if (_java_class_path != nullptr) {\n@@ -1090,1 +1090,1 @@\n-  if (java_command() != NULL) {\n+  if (java_command() != nullptr) {\n@@ -1127,1 +1127,1 @@\n-  if (equal_sign == NULL) {\n+  if (equal_sign == nullptr) {\n@@ -1149,1 +1149,1 @@\n-  if (found_flag != NULL) {\n+  if (found_flag != nullptr) {\n@@ -1180,1 +1180,1 @@\n-    if (fuzzy_matched != NULL) {\n+    if (fuzzy_matched != nullptr) {\n@@ -1195,1 +1195,1 @@\n-  if (stream == NULL) {\n+  if (stream == nullptr) {\n@@ -1269,1 +1269,1 @@\n-  if (eq == NULL) {\n+  if (eq == nullptr) {\n@@ -1313,1 +1313,1 @@\n-      if (old_java_command != NULL) {\n+      if (old_java_command != nullptr) {\n@@ -1326,1 +1326,1 @@\n-      if (old_java_vendor_url_bug != NULL) {\n+      if (old_java_vendor_url_bug != nullptr) {\n@@ -1358,1 +1358,1 @@\n-  while (sp != NULL) {\n+  while (sp != nullptr) {\n@@ -1377,1 +1377,1 @@\n-  if (ArchiveClassesAtExit != NULL) {\n+  if (ArchiveClassesAtExit != nullptr) {\n@@ -1385,1 +1385,1 @@\n-    if (get_property(unsupported_properties[i]) != NULL) {\n+    if (get_property(unsupported_properties[i]) != nullptr) {\n@@ -1478,1 +1478,1 @@\n-  \/\/ We need to fit both the NULL page and the heap into the memory budget, while\n+  \/\/ We need to fit both the null page and the heap into the memory budget, while\n@@ -1480,1 +1480,1 @@\n-  \/\/ NULL page is located before the heap, we pad the NULL page to the conservative\n+  \/\/ null page is located before the heap, we pad the null page to the conservative\n@@ -1911,1 +1911,1 @@\n-  assert(_sun_java_launcher != NULL, \"property must have value\");\n+  assert(_sun_java_launcher != nullptr, \"property must have value\");\n@@ -2002,1 +2002,1 @@\n-  if (option_type == NULL) {\n+  if (option_type == nullptr) {\n@@ -2160,1 +2160,1 @@\n-    if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {\n+    if ((_name = strrchr(name, (int) *os::file_separator())) == nullptr) {\n@@ -2197,1 +2197,1 @@\n-  assert(patch_mod_tail != NULL, \"Unexpected NULL patch-module value\");\n+  assert(patch_mod_tail != nullptr, \"Unexpected null patch-module value\");\n@@ -2200,1 +2200,1 @@\n-  if (module_equal == NULL) {\n+  if (module_equal == nullptr) {\n@@ -2207,1 +2207,1 @@\n-    if (module_name != NULL) {\n+    if (module_name != nullptr) {\n@@ -2246,1 +2246,1 @@\n-    bool silent = (option == NULL); \/\/ Allow testing to silence error messages\n+    bool silent = (option == nullptr); \/\/ Allow testing to silence error messages\n@@ -2348,1 +2348,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2350,1 +2350,1 @@\n-        size_t len = (pos == NULL) ? strlen(tail) : pos - tail;\n+        size_t len = (pos == nullptr) ? strlen(tail) : pos - tail;\n@@ -2354,2 +2354,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2413,1 +2413,1 @@\n-      if(tail != NULL) {\n+      if(tail != nullptr) {\n@@ -2416,1 +2416,1 @@\n-        if (pos == NULL) {\n+        if (pos == nullptr) {\n@@ -2425,2 +2425,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2445,1 +2445,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2880,1 +2880,1 @@\n-      if (jvmciFlag != NULL && jvmciFlag->is_unlocked()) {\n+      if (jvmciFlag != nullptr && jvmciFlag->is_unlocked()) {\n@@ -2939,1 +2939,1 @@\n-  if (_patch_mod_prefix == NULL) {\n+  if (_patch_mod_prefix == nullptr) {\n@@ -2993,1 +2993,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -3003,1 +3003,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -3082,1 +3082,1 @@\n-  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n@@ -3088,1 +3088,1 @@\n-  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n@@ -3095,1 +3095,1 @@\n-    if (SharedArchiveFile == NULL) {\n+    if (SharedArchiveFile == nullptr) {\n@@ -3099,1 +3099,1 @@\n-    if (ArchiveClassesAtExit != NULL) {\n+    if (ArchiveClassesAtExit != nullptr) {\n@@ -3142,1 +3142,1 @@\n-    _args.options = NULL;\n+    _args.options = nullptr;\n@@ -3146,1 +3146,1 @@\n-    _vm_options_file_arg = NULL;\n+    _vm_options_file_arg = nullptr;\n@@ -3158,1 +3158,1 @@\n-    if (options_arr == NULL) {\n+    if (options_arr == nullptr) {\n@@ -3166,1 +3166,1 @@\n-      if (options_arr[i].optionString == NULL) {\n+      if (options_arr[i].optionString == nullptr) {\n@@ -3181,1 +3181,1 @@\n-  bool  found_vm_options_file_arg() { return _vm_options_file_arg != NULL; }\n+  bool  found_vm_options_file_arg() { return _vm_options_file_arg != nullptr; }\n@@ -3185,1 +3185,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3192,1 +3192,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3195,1 +3195,1 @@\n-    if (_args.options == NULL) return;\n+    if (_args.options == nullptr) return;\n@@ -3207,1 +3207,1 @@\n-    assert(_args.options == NULL, \"shouldn't be set yet\");\n+    assert(_args.options == nullptr, \"shouldn't be set yet\");\n@@ -3244,1 +3244,1 @@\n-  if (buffer == NULL || os::have_special_privileges()) {\n+  if (buffer == nullptr || os::have_special_privileges()) {\n@@ -3248,1 +3248,1 @@\n-  if ((buffer = os::strdup(buffer)) == NULL) {\n+  if ((buffer = os::strdup(buffer)) == nullptr) {\n@@ -3287,1 +3287,1 @@\n-  \/\/ '+ 1' for NULL termination even with max bytes\n+  \/\/ '+ 1' for null termination even with max bytes\n@@ -3291,1 +3291,1 @@\n-  if (NULL == buf) {\n+  if (nullptr == buf) {\n@@ -3371,1 +3371,1 @@\n-    \/\/ steal a white space character and set it to NULL\n+    \/\/ steal a white space character and set it to null\n@@ -3377,1 +3377,1 @@\n-    option.extraInfo = NULL;\n+    option.extraInfo = nullptr;\n@@ -3414,1 +3414,1 @@\n-  if (end != NULL) *end = '\\0';\n+  if (end != nullptr) *end = '\\0';\n@@ -3426,1 +3426,1 @@\n-  if (archive_path == NULL) {\n+  if (archive_path == nullptr) {\n@@ -3445,1 +3445,1 @@\n-  if (end_ptr == NULL || end_ptr == begin_ptr) {\n+  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n@@ -3459,1 +3459,1 @@\n-  assert(end_ptr != NULL, \"sanity\");\n+  assert(end_ptr != nullptr, \"sanity\");\n@@ -3511,1 +3511,1 @@\n-        char* base_archive_path = NULL;\n+        char* base_archive_path = nullptr;\n@@ -3529,1 +3529,1 @@\n-        } else if (base_archive_path == NULL) {\n+        } else if (base_archive_path == nullptr) {\n@@ -3540,2 +3540,2 @@\n-        if (SharedArchivePath == NULL) {\n-          assert(SharedDynamicArchivePath == NULL, \"must be\");\n+        if (SharedArchivePath == nullptr) {\n+          assert(SharedDynamicArchivePath == nullptr, \"must be\");\n@@ -3754,1 +3754,1 @@\n-    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, NULL, NULL, &errstream);\n+    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, nullptr, nullptr, &errstream);\n@@ -3826,1 +3826,1 @@\n-  if (vmoptions != NULL) {\n+  if (vmoptions != nullptr) {\n@@ -3863,1 +3863,1 @@\n-  settings_file_specified = (flags_file != NULL);\n+  settings_file_specified = (flags_file != nullptr);\n@@ -3961,1 +3961,1 @@\n-  if (DumpLoadedClassList != NULL) {\n+  if (DumpLoadedClassList != nullptr) {\n@@ -3979,1 +3979,1 @@\n-                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", nullptr);\n@@ -4112,1 +4112,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4122,1 +4122,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4132,1 +4132,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4134,1 +4134,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4137,1 +4137,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4142,1 +4142,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4146,1 +4146,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4153,2 +4153,2 @@\n-        \/\/ Property is internal and not jdk.boot.class.path.append so return NULL.\n-        return NULL;\n+        \/\/ Property is internal and not jdk.boot.class.path.append so return null.\n+        return nullptr;\n@@ -4158,1 +4158,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4163,1 +4163,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -4166,1 +4166,1 @@\n-    while (p->next() != NULL) {\n+    while (p->next() != nullptr) {\n@@ -4175,1 +4175,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4190,1 +4190,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4196,1 +4196,1 @@\n-  for (prop = *plist; prop != NULL; prop = prop->next()) {\n+  for (prop = *plist; prop != nullptr; prop = prop->next()) {\n@@ -4215,1 +4215,1 @@\n-\/\/ NULL terminator character is not long enough for holding the expanded\n+\/\/ null terminator character is not long enough for holding the expanded\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":167,"deletions":167,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    const char* file;        \/\/ NULL -> stdout\n+    const char* file;        \/\/ null -> stdout\n@@ -116,1 +116,1 @@\n-                          value() != NULL);\n+                          value() != nullptr);\n@@ -146,1 +146,1 @@\n-  \/\/ Is this library valid or not. Don't rely on os_lib == NULL as statically\n+  \/\/ Is this library valid or not. Don't rely on os_lib == nullptr as statically\n@@ -188,1 +188,1 @@\n-  bool is_empty() const                     { return _first == NULL; }\n+  bool is_empty() const                     { return _first == nullptr; }\n@@ -199,1 +199,1 @@\n-    lib->_next = NULL;\n+    lib->_next = nullptr;\n@@ -205,2 +205,2 @@\n-    AgentLibrary* prev = NULL;\n-    for (curr = first(); curr != NULL; prev = curr, curr = curr->next()) {\n+    AgentLibrary* prev = nullptr;\n+    for (curr = first(); curr != nullptr; prev = curr, curr = curr->next()) {\n@@ -211,1 +211,1 @@\n-    assert(curr != NULL, \"always should be found\");\n+    assert(curr != nullptr, \"always should be found\");\n@@ -213,1 +213,1 @@\n-    if (curr != NULL) {\n+    if (curr != nullptr) {\n@@ -215,1 +215,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -223,1 +223,1 @@\n-      curr->_next = NULL;\n+      curr->_next = nullptr;\n@@ -228,2 +228,2 @@\n-    _first = NULL;\n-    _last = NULL;\n+    _first = nullptr;\n+    _last = nullptr;\n@@ -439,1 +439,1 @@\n-    return is_bad_option(option, ignore, NULL);\n+    return is_bad_option(option, ignore, nullptr);\n@@ -470,1 +470,1 @@\n-  \/\/ Return NULL if the arg has expired.\n+  \/\/ Return nullptr if the arg has expired.\n@@ -523,1 +523,1 @@\n-    if (_jvm_flags_file != NULL) {\n+    if (_jvm_flags_file != nullptr) {\n@@ -606,1 +606,1 @@\n-    assert(get_boot_class_path() == NULL, \"Boot class path previously set\");\n+    assert(get_boot_class_path() == nullptr, \"Boot class path previously set\");\n@@ -624,1 +624,1 @@\n-  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(NULL);\n+  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(nullptr);\n@@ -679,5 +679,5 @@\n-\/\/ similar to UNSUPPORTED_OPTION but sets flag to NULL\n-#define UNSUPPORTED_OPTION_NULL(opt)                     \\\n-do {                                                     \\\n-  if (opt) {                                             \\\n-    if (FLAG_IS_CMDLINE(opt)) {                          \\\n+\/\/ similar to UNSUPPORTED_OPTION but sets flag to nullptr\n+#define UNSUPPORTED_OPTION_NULL(opt)                         \\\n+do {                                                         \\\n+  if (opt) {                                                 \\\n+    if (FLAG_IS_CMDLINE(opt)) {                              \\\n@@ -685,3 +685,3 @@\n-    }                                                    \\\n-    FLAG_SET_DEFAULT(opt, NULL);                         \\\n-  }                                                      \\\n+    }                                                        \\\n+    FLAG_SET_DEFAULT(opt, nullptr);                          \\\n+  }                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-  \/\/ Performs atomic compare of *dest and NULL, and replaces *dest\n+  \/\/ Performs atomic compare of *dest and nullptr, and replaces *dest\n@@ -759,1 +759,1 @@\n-  D* expected_null = NULL;\n+  D* expected_null = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-    bool print_monitor_info = (owner != NULL) && (owner->mark() == markWord::from_pointer((void*)this));\n+    bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1909,1 +1909,1 @@\n-  const bool is_last = empty && chunk->parent() == NULL;\n+  const bool is_last = empty && chunk->parent() == nullptr;\n@@ -2609,1 +2609,1 @@\n-    assert(bs != NULL, \"freeze\/thaw invoked before BarrierSet is set\");\n+    assert(bs != nullptr, \"freeze\/thaw invoked before BarrierSet is set\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-  assert (chunk->at(0)->scope() != NULL,\"expect only compiled java frames\");\n+  assert (chunk->at(0)->scope() != nullptr,\"expect only compiled java frames\");\n@@ -242,1 +242,1 @@\n-  if (objects != NULL) {\n+  if (objects != nullptr) {\n@@ -255,1 +255,1 @@\n-    bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+    bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n@@ -279,1 +279,1 @@\n-    assert (cvf->scope() != NULL,\"expect only compiled java frames\");\n+    assert (cvf->scope() != nullptr,\"expect only compiled java frames\");\n@@ -298,1 +298,1 @@\n-              if (monitor != NULL && monitor->object() == mi->owner()) {\n+              if (monitor != nullptr && monitor->object() == mi->owner()) {\n@@ -361,1 +361,1 @@\n-  assert(current->deopt_mark() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_mark() == nullptr, \"Pending deopt!\");\n@@ -376,1 +376,1 @@\n-  assert(current->deopt_compiled_method() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_compiled_method() == nullptr, \"Pending deopt!\");\n@@ -435,1 +435,1 @@\n-    guarantee(expressions != NULL && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n@@ -438,1 +438,1 @@\n-    guarantee(exceptionObject() != NULL, \"exception oop can not be null\");\n+    guarantee(exceptionObject() != nullptr, \"exception oop can not be null\");\n@@ -450,1 +450,1 @@\n-  assert(current->vframe_array_head() == NULL, \"Pending deopt!\");\n+  assert(current->vframe_array_head() == nullptr, \"Pending deopt!\");\n@@ -468,1 +468,1 @@\n-  if (deoptee_nm != NULL && deoptee_nm->is_method_handle_return(deoptee.pc()))\n+  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n@@ -607,1 +607,1 @@\n-  assert(CodeCache::find_blob(frame_pcs[0]) != NULL, \"bad pc\");\n+  assert(CodeCache::find_blob(frame_pcs[0]) != nullptr, \"bad pc\");\n@@ -610,1 +610,1 @@\n-  if (exceptionObject() != NULL) {\n+  if (exceptionObject() != nullptr) {\n@@ -658,1 +658,1 @@\n-  if (array == NULL) {\n+  if (array == nullptr) {\n@@ -661,1 +661,1 @@\n-  thread->set_vframe_array_head(NULL);\n+  thread->set_vframe_array_head(nullptr);\n@@ -667,1 +667,1 @@\n-  if (old_array != NULL) {\n+  if (old_array != nullptr) {\n@@ -669,1 +669,1 @@\n-    old_array->set_unroll_block(NULL);\n+    old_array->set_unroll_block(nullptr);\n@@ -678,2 +678,2 @@\n-  thread->set_deopt_mark(NULL);\n-  thread->set_deopt_compiled_method(NULL);\n+  thread->set_deopt_mark(nullptr);\n+  thread->set_deopt_compiled_method(nullptr);\n@@ -758,1 +758,1 @@\n-  thread->frame_anchor()->set_last_Java_sp(NULL);\n+  thread->frame_anchor()->set_last_Java_sp(nullptr);\n@@ -922,1 +922,1 @@\n-  if (nmethod_only != NULL) {\n+  if (nmethod_only != nullptr) {\n@@ -949,1 +949,1 @@\n-    guarantee(ik != NULL, \"%s must be loaded\", klass_name_str);\n+    guarantee(ik != nullptr, \"%s must be loaded\", klass_name_str);\n@@ -975,1 +975,1 @@\n-    if (_singleton == NULL) {\n+    if (_singleton == nullptr) {\n@@ -988,1 +988,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1007,5 +1007,5 @@\n-template<> BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>* BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>::_singleton = NULL;\n-template<> BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>* BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>::_singleton = NULL;\n-template<> BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>* BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>::_singleton = NULL;\n-template<> BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>* BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>::_singleton = NULL;\n-template<> BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>* BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>::_singleton = NULL;\n+template<> BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>* BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>::_singleton = nullptr;\n+template<> BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>* BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>::_singleton = nullptr;\n+template<> BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>* BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>::_singleton = nullptr;\n+template<> BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>* BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>::_singleton = nullptr;\n+template<> BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>* BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>::_singleton = nullptr;\n@@ -1029,1 +1029,1 @@\n-    if (_singleton == NULL) {\n+    if (_singleton == nullptr) {\n@@ -1050,1 +1050,1 @@\n-BooleanBoxCache* BooleanBoxCache::_singleton = NULL;\n+BooleanBoxCache* BooleanBoxCache::_singleton = nullptr;\n@@ -1067,1 +1067,1 @@\n-   return NULL;\n+   return nullptr;\n@@ -1085,1 +1085,1 @@\n-    oop obj = NULL;\n+    oop obj = nullptr;\n@@ -1093,1 +1093,1 @@\n-        if (obj != NULL) {\n+        if (obj != nullptr) {\n@@ -1101,1 +1101,1 @@\n-      if (obj == NULL) {\n+      if (obj == nullptr) {\n@@ -1122,1 +1122,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n@@ -1127,1 +1127,1 @@\n-    assert(obj != NULL || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n+    assert(obj != nullptr || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n@@ -1329,1 +1329,1 @@\n-  while (ik != NULL) {\n+  while (ik != nullptr) {\n@@ -1502,1 +1502,1 @@\n-            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) NULL));\n+            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) nullptr));\n@@ -1508,1 +1508,1 @@\n-            if (waiting_monitor != NULL && waiting_monitor->object() == obj()) {\n+            if (waiting_monitor != nullptr && waiting_monitor->object() == obj()) {\n@@ -1588,1 +1588,1 @@\n-    if (monitors != NULL) {\n+    if (monitors != nullptr) {\n@@ -1591,1 +1591,1 @@\n-        if (src->obj() != NULL) {\n+        if (src->obj() != nullptr) {\n@@ -1609,1 +1609,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -1611,1 +1611,1 @@\n-    assert(cm != NULL, \"only compiled methods can deopt\");\n+    assert(cm != nullptr, \"only compiled methods can deopt\");\n@@ -1665,3 +1665,3 @@\n-  if (imm_mdo != NULL) {\n-    ProfileData* pdata = imm_mdo->allocate_bci_to_data(imm_scope->bci(), NULL);\n-    if (pdata != NULL && pdata->is_BitData()) {\n+  if (imm_mdo != nullptr) {\n+    ProfileData* pdata = imm_mdo->allocate_bci_to_data(imm_scope->bci(), nullptr);\n+    if (pdata != nullptr && pdata->is_BitData()) {\n@@ -1676,1 +1676,1 @@\n-  if (trap_mdo != NULL) {\n+  if (trap_mdo != nullptr) {\n@@ -1729,1 +1729,1 @@\n-  if (mdo == NULL && create_if_missing && !HAS_PENDING_EXCEPTION) {\n+  if (mdo == nullptr && create_if_missing && !HAS_PENDING_EXCEPTION) {\n@@ -1816,2 +1816,2 @@\n-  assert(nm != NULL, \"invariant\");\n-  assert(method != NULL, \"invariant\");\n+  assert(nm != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n@@ -1973,1 +1973,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1984,1 +1984,1 @@\n-      Symbol* class_name = NULL;\n+      Symbol* class_name = nullptr;\n@@ -1991,1 +1991,1 @@\n-          if (xtty != NULL)\n+          if (xtty != nullptr)\n@@ -1996,1 +1996,1 @@\n-        if (xtty != NULL)\n+        if (xtty != nullptr)\n@@ -1999,1 +1999,1 @@\n-      if (xtty != NULL && trap_mdo != NULL && (int)reason < (int)MethodData::_trap_hist_limit) {\n+      if (xtty != nullptr && trap_mdo != nullptr && (int)reason < (int)MethodData::_trap_hist_limit) {\n@@ -2007,1 +2007,1 @@\n-        int dos = (pdata == NULL)? 0: pdata->trap_state();\n+        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n@@ -2017,1 +2017,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -2030,1 +2030,1 @@\n-          if (installed_code_name != NULL) {\n+          if (installed_code_name != nullptr) {\n@@ -2045,1 +2045,1 @@\n-        if (class_name != NULL) {\n+        if (class_name != nullptr) {\n@@ -2052,1 +2052,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -2181,2 +2181,2 @@\n-    ProfileData* pdata = NULL;\n-    if (ProfileTraps && CompilerConfig::is_c2_or_jvmci_compiler_enabled() && update_trap_state && trap_mdo != NULL) {\n+    ProfileData* pdata = nullptr;\n+    if (ProfileTraps && CompilerConfig::is_c2_or_jvmci_compiler_enabled() && update_trap_state && trap_mdo != nullptr) {\n@@ -2263,1 +2263,1 @@\n-      if (pdata != NULL) {\n+      if (pdata != nullptr) {\n@@ -2276,1 +2276,1 @@\n-      if ((reason != Reason_rtm_state_change) && (trap_mdo != NULL) &&\n+      if ((reason != Reason_rtm_state_change) && (trap_mdo != nullptr) &&\n@@ -2283,1 +2283,1 @@\n-      if (reason == Reason_tenured && trap_mdo != NULL) {\n+      if (reason == Reason_tenured && trap_mdo != nullptr) {\n@@ -2353,1 +2353,1 @@\n-  ProfileData* pdata = NULL;\n+  ProfileData* pdata = nullptr;\n@@ -2363,1 +2363,1 @@\n-    pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : NULL);\n+    pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : nullptr);\n@@ -2365,1 +2365,1 @@\n-    if (pdata != NULL) {\n+    if (pdata != nullptr) {\n@@ -2367,1 +2367,1 @@\n-        if (LogCompilation && xtty != NULL) {\n+        if (LogCompilation && xtty != nullptr) {\n@@ -2388,1 +2388,1 @@\n-      if (LogCompilation && xtty != NULL) {\n+      if (LogCompilation && xtty != nullptr) {\n@@ -2419,1 +2419,1 @@\n-                           NULL,\n+                           nullptr,\n@@ -2643,1 +2643,1 @@\n-  juint* bc_counter_addr = NULL;\n+  juint* bc_counter_addr = nullptr;\n@@ -2650,1 +2650,1 @@\n-      if ((counter == 0 && bc_counter_addr == NULL)\n+      if ((counter == 0 && bc_counter_addr == nullptr)\n@@ -2658,1 +2658,1 @@\n-  if (bc_counter_addr == NULL) {\n+  if (bc_counter_addr == nullptr) {\n@@ -2675,1 +2675,1 @@\n-  if (reason_str == NULL && action_str == NULL) {\n+  if (reason_str == nullptr && action_str == nullptr) {\n@@ -2680,1 +2680,1 @@\n-    if (reason_str == NULL || !strcmp(reason_str, trap_reason_name(reason))) {\n+    if (reason_str == nullptr || !strcmp(reason_str, trap_reason_name(reason))) {\n@@ -2682,1 +2682,1 @@\n-        if (action_str == NULL || !strcmp(action_str, trap_action_name(action))) {\n+        if (action_str == nullptr || !strcmp(action_str, trap_action_name(action))) {\n@@ -2699,1 +2699,1 @@\n-    if (xtty != NULL)  xtty->head(\"statistics type='deoptimization'\");\n+    if (xtty != nullptr)  xtty->head(\"statistics type='deoptimization'\");\n@@ -2731,1 +2731,1 @@\n-    if (xtty != NULL)  xtty->tail(\"statistics\");\n+    if (xtty != nullptr)  xtty->tail(\"statistics\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-  static void deoptimize_all_marked(nmethod* nmethod_only = NULL);\n+  static void deoptimize_all_marked(nmethod* nmethod_only = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n@@ -91,1 +91,1 @@\n-    while (vf != NULL && cur_depth < d1) {\n+    while (vf != nullptr && cur_depth < d1) {\n@@ -96,1 +96,1 @@\n-    while (vf != NULL && ((cur_depth <= d2) || !vf->is_entry_frame())) {\n+    while (vf != nullptr && ((cur_depth <= d2) || !vf->is_entry_frame())) {\n@@ -128,1 +128,1 @@\n-    if (vt_oop != NULL && java_lang_VirtualThread::is_instance(vt_oop)) {\n+    if (vt_oop != nullptr && java_lang_VirtualThread::is_instance(vt_oop)) {\n@@ -146,1 +146,1 @@\n-      while (vf != NULL) {\n+      while (vf != nullptr) {\n@@ -177,2 +177,2 @@\n-  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n-  assert(_deoptee_thread != NULL, \"deoptee thread must not be NULL\");\n+  assert(_calling_thread != nullptr, \"calling thread must not be null\");\n+  assert(_deoptee_thread != nullptr, \"deoptee thread must not be null\");\n@@ -208,1 +208,1 @@\n-  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n+  assert(_calling_thread != nullptr, \"calling thread must not be null\");\n@@ -309,1 +309,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-    : _calling_thread(calling_thread), _deoptee_thread(NULL),\n+    : _calling_thread(calling_thread), _deoptee_thread(nullptr),\n@@ -133,1 +133,1 @@\n-  bool all_threads()    const { return _deoptee_thread == NULL; }\n+  bool all_threads()    const { return _deoptee_thread == nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -64,2 +64,2 @@\n-  if (md == NULL)\n-    return NULL;\n+  if (md == nullptr)\n+    return nullptr;\n@@ -72,2 +72,2 @@\n-  if (type_annos == NULL)\n-    return NULL;\n+  if (type_annos == nullptr)\n+    return nullptr;\n@@ -188,1 +188,1 @@\n-      if (obj->obj_field(offset()) != NULL) {\n+      if (obj->obj_field(offset()) != nullptr) {\n@@ -191,1 +191,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"nullptr\");\n@@ -195,1 +195,1 @@\n-      if (obj->obj_field(offset()) != NULL) {\n+      if (obj->obj_field(offset()) != nullptr) {\n@@ -198,1 +198,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"nullptr\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  product(ccstr, DummyManageableStringFlag, NULL, MANAGEABLE,               \\\n+  product(ccstr, DummyManageableStringFlag, nullptr, MANAGEABLE,               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-\/\/ Get custom message for this locked flag, or NULL if\n+\/\/ Get custom message for this locked flag, or null if\n@@ -228,1 +228,1 @@\n-      if (cp != NULL) {\n+      if (cp != nullptr) {\n@@ -230,1 +230,1 @@\n-        while ((eol = strchr(cp, '\\n')) != NULL) {\n+        while ((eol = strchr(cp, '\\n')) != nullptr) {\n@@ -432,1 +432,1 @@\n-    if (cp != NULL) {\n+    if (cp != nullptr) {\n@@ -463,1 +463,1 @@\n-    default: ShouldNotReachHere(); return \"NULL\";\n+    default: ShouldNotReachHere(); return \"nullptr\";\n@@ -546,1 +546,1 @@\n-  JVMFlag() \/\/ The iteration code wants a flag with a NULL name at the end of the table.\n+  JVMFlag() \/\/ The iteration code wants a flag with a null name at the end of the table.\n@@ -575,1 +575,1 @@\n-  if (flag != NULL) {\n+  if (flag != nullptr) {\n@@ -579,1 +579,1 @@\n-      return (return_flag ? flag : NULL);\n+      return (return_flag ? flag : nullptr);\n@@ -586,1 +586,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -592,1 +592,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -597,1 +597,1 @@\n-  JVMFlag* match = NULL;\n+  JVMFlag* match = nullptr;\n@@ -601,1 +601,1 @@\n-  for (JVMFlag* current = &flagTable[0]; current->_name != NULL; current++) {\n+  for (JVMFlag* current = &flagTable[0]; current->_name != nullptr; current++) {\n@@ -609,2 +609,2 @@\n-  if (match == NULL) {\n-    return NULL;\n+  if (match == nullptr) {\n+    return nullptr;\n@@ -615,1 +615,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -620,1 +620,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -693,1 +693,1 @@\n-  for (JVMFlag* current = &flagTable[0]; current->_name != NULL; current++) {\n+  for (JVMFlag* current = &flagTable[0]; current->_name != nullptr; current++) {\n@@ -731,1 +731,1 @@\n-  if (array != NULL) {\n+  if (array != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-    if (constraint != NULL && constraint->phase() <= static_cast<int>(JVMFlagLimit::validating_phase())) {\n+    if (constraint != nullptr && constraint->phase() <= static_cast<int>(JVMFlagLimit::validating_phase())) {\n@@ -110,1 +110,1 @@\n-    if (range != NULL) {\n+    if (range != nullptr) {\n@@ -122,1 +122,1 @@\n-    if (range != NULL) {\n+    if (range != nullptr) {\n@@ -304,1 +304,1 @@\n-  if (flag == NULL) return JVMFlag::INVALID_FLAG;\n+  if (flag == nullptr) return JVMFlag::INVALID_FLAG;\n@@ -308,2 +308,2 @@\n-  char* new_value = NULL;\n-  if (*value != NULL) {\n+  char* new_value = nullptr;\n+  if (*value != nullptr) {\n@@ -313,1 +313,1 @@\n-  if (!flag->is_default() && old_value != NULL) {\n+  if (!flag->is_default() && old_value != nullptr) {\n@@ -321,1 +321,1 @@\n-  *value = NULL;\n+  *value = nullptr;\n@@ -358,1 +358,1 @@\n-  if (range != NULL) {\n+  if (range != nullptr) {\n@@ -362,1 +362,1 @@\n-    if (limit != NULL) {\n+    if (limit != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-\/\/  \/* If you use a wrong type, or a NULL flag, an error code is returned *\/\n+\/\/  \/* If you use a wrong type, or a null flag, an error code is returned *\/\n@@ -83,1 +83,1 @@\n-    if (flag == NULL) {\n+    if (flag == nullptr) {\n@@ -113,1 +113,1 @@\n-    if (flag == NULL) {\n+    if (flag == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  \/\/ These functions return NULL for develop flags in a PRODUCT build\n+  \/\/ These functions return null for develop flags in a PRODUCT build\n@@ -71,1 +71,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -76,1 +76,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -126,1 +126,1 @@\n-  LimitGetter<int>::get_limit(NULL, 0\n+  LimitGetter<int>::get_limit(nullptr, 0\n@@ -157,1 +157,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -165,1 +165,1 @@\n-    if (get_range_at(flag_enum) != NULL &&\n+    if (get_range_at(flag_enum) != nullptr &&\n@@ -182,1 +182,1 @@\n-    if (constraint != NULL && constraint->phase() == static_cast<int>(phase) &&\n+    if (constraint != nullptr && constraint->phase() == static_cast<int>(phase) &&\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-\/\/ If the given flag doesn't have a range, NULL is returned.\n+\/\/ If the given flag doesn't have a range, null is returned.\n@@ -66,1 +66,1 @@\n-\/\/ If the given flag doesn't have a constraint, NULL is returned.\n+\/\/ If the given flag doesn't have a constraint, null is returned.\n@@ -88,1 +88,1 @@\n-    if (limit != NULL && (limit->_kind & required_kind) != 0) {\n+    if (limit != nullptr && (limit->_kind & required_kind) != 0) {\n@@ -92,1 +92,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  DEBUG_ONLY (_update_for_id = NULL;)\n+  DEBUG_ONLY (_update_for_id = nullptr;)\n@@ -73,1 +73,1 @@\n-  if (walk_cont == WalkContinuation::include && thread != NULL && thread->last_continuation() != NULL) {\n+  if (walk_cont == WalkContinuation::include && thread != nullptr && thread->last_continuation() != nullptr) {\n@@ -79,1 +79,1 @@\n-  for (int i = 0; i < reg_count ; i++ ) _location[i] = NULL;\n+  for (int i = 0; i < reg_count ; i++ ) _location[i] = nullptr;\n@@ -84,1 +84,1 @@\n-  _thread         = NULL;\n+  _thread         = nullptr;\n@@ -89,1 +89,1 @@\n-  DEBUG_ONLY (_update_for_id = NULL;)\n+  DEBUG_ONLY (_update_for_id = nullptr;)\n@@ -97,1 +97,1 @@\n-  for (int i = 0; i < reg_count ; i++ ) _location[i] = NULL;\n+  for (int i = 0; i < reg_count ; i++ ) _location[i] = nullptr;\n@@ -103,1 +103,1 @@\n-  assert(map != NULL, \"RegisterMap must be present\");\n+  assert(map != nullptr, \"RegisterMap must be present\");\n@@ -137,1 +137,1 @@\n-  return _chunk() != NULL ? _chunk()->cont() : (oop)NULL;\n+  return _chunk() != nullptr ? _chunk()->cont() : (oop)nullptr;\n@@ -141,2 +141,2 @@\n-  assert(chunk == NULL || _walk_cont, \"\");\n-  assert(chunk == NULL || _chunk.not_null(), \"\");\n+  assert(chunk == nullptr || _walk_cont, \"\");\n+  assert(chunk == nullptr || _chunk.not_null(), \"\");\n@@ -146,1 +146,1 @@\n-  if (chunk == NULL) {\n+  if (chunk == nullptr) {\n@@ -172,1 +172,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -181,1 +181,1 @@\n-    if (src != NULL) {\n+    if (src != nullptr) {\n@@ -222,1 +222,1 @@\n-  if (_cb != NULL && _cb->is_nmethod()) {\n+  if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -240,1 +240,1 @@\n-  return (_cb != NULL &&\n+  return (_cb != nullptr &&\n@@ -252,1 +252,1 @@\n-  return (_cb != NULL && _cb->is_runtime_stub());\n+  return (_cb != nullptr && _cb->is_runtime_stub());\n@@ -256,1 +256,1 @@\n-  return (_cb != NULL && _cb->is_safepoint_stub());\n+  return (_cb != nullptr && _cb->is_safepoint_stub());\n@@ -289,1 +289,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -307,1 +307,1 @@\n-  assert(_cb != NULL && _cb->is_compiled(), \"must be an nmethod\");\n+  assert(_cb != nullptr && _cb->is_compiled(), \"must be an nmethod\");\n@@ -334,1 +334,1 @@\n-  assert(thread == NULL\n+  assert(thread == nullptr\n@@ -338,1 +338,1 @@\n-  assert(_cb != NULL && _cb->is_compiled(), \"must be\");\n+  assert(_cb != nullptr && _cb->is_compiled(), \"must be\");\n@@ -354,1 +354,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n@@ -504,1 +504,1 @@\n-  if (sp() == NULL)            return \"Empty\";\n+  if (sp() == nullptr)            return \"Empty\";\n@@ -510,1 +510,1 @@\n-  NOT_PRODUCT(address end   = NULL;)\n+  NOT_PRODUCT(address end   = nullptr;)\n@@ -513,1 +513,1 @@\n-  if (sp() != NULL)\n+  if (sp() != nullptr)\n@@ -524,1 +524,1 @@\n-    if (desc != NULL) {\n+    if (desc != nullptr) {\n@@ -534,1 +534,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -537,1 +537,1 @@\n-    if (end == NULL) {\n+    if (end == nullptr) {\n@@ -547,1 +547,1 @@\n-  print_value_on(st,NULL);\n+  print_value_on(st,nullptr);\n@@ -608,1 +608,1 @@\n-  if (buf == NULL || buflen < 1) return;\n+  if (buf == nullptr || buflen < 1) return;\n@@ -617,1 +617,1 @@\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n+    while ((p2 = strstr(p1, os::file_separator())) != nullptr) p1 = p2 + len;\n@@ -644,1 +644,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -647,1 +647,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -655,1 +655,1 @@\n-          if (module->version() != NULL) {\n+          if (module->version() != nullptr) {\n@@ -665,1 +665,1 @@\n-      if (desc != NULL) {\n+      if (desc != nullptr) {\n@@ -675,1 +675,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -687,1 +687,1 @@\n-          if (module->version() != NULL) {\n+          if (module->version() != nullptr) {\n@@ -698,1 +698,1 @@\n-          if (jvmciName != NULL) {\n+          if (jvmciName != nullptr) {\n@@ -856,1 +856,1 @@\n-    _f = NULL; \/\/ will be set later\n+    _f = nullptr; \/\/ will be set later\n@@ -917,1 +917,1 @@\n-  Symbol* signature = NULL;\n+  Symbol* signature = nullptr;\n@@ -966,4 +966,4 @@\n-  assert(_cb != NULL, \"sanity check\");\n-  assert((oop_map() == NULL) == (_cb->oop_maps() == NULL), \"frame and _cb must agree that oopmap is set or not\");\n-  if (oop_map() != NULL) {\n-    if (df != NULL) {\n+  assert(_cb != nullptr, \"sanity check\");\n+  assert((oop_map() == nullptr) == (_cb->oop_maps() == nullptr), \"frame and _cb must agree that oopmap is set or not\");\n+  if (oop_map() != nullptr) {\n+    if (df != nullptr) {\n@@ -986,1 +986,1 @@\n-  if (cf != NULL)\n+  if (cf != nullptr)\n@@ -1013,1 +1013,1 @@\n-    if (loc == NULL) {\n+    if (loc == nullptr) {\n@@ -1019,1 +1019,1 @@\n-      assert(loc != NULL, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n+      assert(loc != nullptr, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n@@ -1075,3 +1075,3 @@\n-  if (oop_adr == NULL) {\n-    guarantee(oop_adr != NULL, \"bad register save location\");\n-    return NULL;\n+  if (oop_adr == nullptr) {\n+    guarantee(oop_adr != nullptr, \"bad register save location\");\n+    return nullptr;\n@@ -1087,1 +1087,1 @@\n-  assert(_cb != NULL && _cb->is_nmethod() && nm->method()->is_native(),\n+  assert(_cb != nullptr && _cb->is_nmethod() && nm->method()->is_native(),\n@@ -1096,1 +1096,1 @@\n-  assert(_cb != NULL && _cb->is_nmethod() && nm->method()->is_native(),\n+  assert(_cb != nullptr && _cb->is_nmethod() && nm->method()->is_native(),\n@@ -1106,1 +1106,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -1128,1 +1128,1 @@\n-  \/*if (_cb != NULL && _cb->is_nmethod()) {\n+  \/*if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -1140,1 +1140,1 @@\n-    char *t = NULL;\n+    char *t = nullptr;\n@@ -1158,1 +1158,1 @@\n-  if (_cb != NULL && _cb->is_nmethod()) {\n+  if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -1169,1 +1169,1 @@\n-    assert(m != NULL, \"expecting a method in this frame\");\n+    assert(m != nullptr, \"expecting a method in this frame\");\n@@ -1197,1 +1197,1 @@\n-    oops_do_internal(&VerifyOopClosure::verify_oop, NULL, NULL, DerivedPointerIterationMode::_ignore, map, false);\n+    oops_do_internal(&VerifyOopClosure::verify_oop, nullptr, nullptr, DerivedPointerIterationMode::_ignore, map, false);\n@@ -1308,2 +1308,2 @@\n-    if (p != NULL && (((intptr_t)p & WordAlignmentMask) == 0)) {\n-      const char* type_name = NULL;\n+    if (p != nullptr && (((intptr_t)p & WordAlignmentMask) == 0)) {\n+      const char* type_name = nullptr;\n@@ -1318,1 +1318,1 @@\n-      if (type_name != NULL) {\n+      if (type_name != nullptr) {\n@@ -1353,1 +1353,1 @@\n-    if (desc != NULL) {\n+    if (desc != nullptr) {\n@@ -1356,1 +1356,1 @@\n-        desc->description() != NULL ? desc->description()               : \"?\"), 2);\n+        desc->description() != nullptr ? desc->description()               : \"?\"), 2);\n@@ -1382,1 +1382,1 @@\n-    intptr_t* tos = NULL;\n+    intptr_t* tos = nullptr;\n@@ -1389,1 +1389,1 @@\n-    if (tos != NULL) {\n+    if (tos != nullptr) {\n@@ -1393,1 +1393,1 @@\n-    if (reg_map != NULL) {\n+    if (reg_map != nullptr) {\n@@ -1395,1 +1395,1 @@\n-      oops_do(&oopsFn, NULL, &oopsFn, reg_map);\n+      oops_do(&oopsFn, nullptr, &oopsFn, reg_map);\n@@ -1465,1 +1465,1 @@\n-    if (reg_map != NULL && is_java_frame()) {\n+    if (reg_map != nullptr && is_java_frame()) {\n@@ -1467,1 +1467,1 @@\n-      for (ScopeDesc* scope = cm->scope_desc_at(pc()); scope != NULL; scope = scope->sender(), scope_no++) {\n+      for (ScopeDesc* scope = cm->scope_desc_at(pc()); scope != nullptr; scope = scope->sender(), scope_no++) {\n@@ -1474,1 +1474,1 @@\n-          int scvs_length = scvs != NULL ? scvs->length() : 0;\n+          int scvs_length = scvs != nullptr ? scvs->length() : 0;\n@@ -1477,1 +1477,1 @@\n-            if (stack_address != NULL) {\n+            if (stack_address != nullptr) {\n@@ -1484,1 +1484,1 @@\n-          int scvs_length = scvs != NULL ? scvs->length() : 0;\n+          int scvs_length = scvs != nullptr ? scvs->length() : 0;\n@@ -1487,1 +1487,1 @@\n-            if (stack_address != NULL) {\n+            if (stack_address != nullptr) {\n@@ -1495,1 +1495,1 @@\n-      oops_do(&oopsFn, NULL, &oopsFn, reg_map);\n+      oops_do(&oopsFn, nullptr, &oopsFn, reg_map);\n@@ -1498,1 +1498,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -1518,2 +1518,2 @@\n-    if ((_cb != NULL) &&\n-        (_cb->name() != NULL)) {\n+    if ((_cb != nullptr) &&\n+        (_cb->name() != nullptr)) {\n@@ -1584,1 +1584,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n@@ -1617,1 +1617,1 @@\n-  intptr_t* last = NULL;\n+  intptr_t* last = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-    if (_oop_map == NULL) {\n+    if (_oop_map == nullptr) {\n@@ -162,1 +162,1 @@\n-  \/\/ should have an id() of NULL so it is a distinguishing value for an unmatchable frame.\n+  \/\/ should have an id() of null so it is a distinguishing value for an unmatchable frame.\n@@ -165,1 +165,1 @@\n-  \/\/ A NULL id is only valid when comparing for equality.\n+  \/\/ A null id is only valid when comparing for equality.\n@@ -178,1 +178,1 @@\n-  bool is_empty()                const { return _pc == NULL; }\n+  bool is_empty()                const { return _pc == nullptr; }\n@@ -418,1 +418,1 @@\n-  void print_value() const { print_value_on(tty,NULL); }\n+  void print_value() const { print_value_on(tty,nullptr); }\n@@ -426,1 +426,1 @@\n-  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=NULL);\n+  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=nullptr);\n@@ -460,1 +460,1 @@\n-    oops_do_internal(f, cf, NULL, dpim, map, true);\n+    oops_do_internal(f, cf, nullptr, dpim, map, true);\n@@ -469,1 +469,1 @@\n-    oops_do_internal(f, cf, NULL, derived_mode, map, true);\n+    oops_do_internal(f, cf, nullptr, derived_mode, map, true);\n@@ -497,2 +497,2 @@\n-    location = NULL;\n-    description = NULL;\n+    location = nullptr;\n+    description = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  return StubRoutines::is_stub_code(pc()) || (_cb != NULL && _cb->is_adapter_blob());\n+  return StubRoutines::is_stub_code(pc()) || (_cb != nullptr && _cb->is_adapter_blob());\n@@ -62,1 +62,1 @@\n-  return _cb != NULL && _cb->is_upcall_stub();\n+  return _cb != nullptr && _cb->is_upcall_stub();\n@@ -66,1 +66,1 @@\n-  if (_cb != NULL &&\n+  if (_cb != nullptr &&\n@@ -85,1 +85,1 @@\n-    assert(reg_map->thread() == NULL || reg_map->thread()->is_in_usable_stack(usp), INTPTR_FORMAT, p2i(usp));\n+    assert(reg_map->thread() == nullptr || reg_map->thread()->is_in_usable_stack(usp), INTPTR_FORMAT, p2i(usp));\n@@ -96,2 +96,2 @@\n-  \/\/ if (_cb == NULL) _cb = CodeCache::find_blob(_pc);\n-  if (_cb == NULL) {\n+  \/\/ if (_cb == nullptr) _cb = CodeCache::find_blob(_pc);\n+  if (_cb == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (_oop_map == NULL && slot >= 0) {\n+    if (_oop_map == nullptr && slot >= 0) {\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -547,1 +547,1 @@\n-  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n+  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                            \\\n@@ -601,1 +601,1 @@\n-  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n+  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                    \\\n@@ -629,1 +629,1 @@\n-          \"Start debugger when an implicit OS (e.g. NULL) \"                 \\\n+          \"Start debugger when an implicit OS (e.g. nullptr) \"                 \\\n@@ -835,1 +835,1 @@\n-  product(ccstr, TraceJVMTI, NULL,                                          \\\n+  product(ccstr, TraceJVMTI, nullptr,                                          \\\n@@ -1035,1 +1035,1 @@\n-  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                                 \\\n@@ -1039,1 +1039,1 @@\n-  product(ccstr, ErrorFile, NULL,                                           \\\n+  product(ccstr, ErrorFile, nullptr,                                           \\\n@@ -1076,1 +1076,1 @@\n-  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                      \\\n@@ -1080,1 +1080,1 @@\n-  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n+  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,               \\\n@@ -1744,1 +1744,1 @@\n-  product(ccstr, PerfDataSaveFile, NULL,                                    \\\n+  product(ccstr, PerfDataSaveFile, nullptr,                                    \\\n@@ -1824,1 +1824,1 @@\n-  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, PauseAtStartupFile, nullptr, DIAGNOSTIC,                      \\\n@@ -1931,1 +1931,1 @@\n-  product(ccstr, AllocateHeapAt, NULL,                                      \\\n+  product(ccstr, AllocateHeapAt, nullptr,                                      \\\n@@ -1966,1 +1966,1 @@\n-  JFR_ONLY(product(ccstr, FlightRecorderOptions, NULL,                      \\\n+  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                      \\\n@@ -1969,1 +1969,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, NULL,                       \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  return real_allocate_handle(NULL);\n+  return real_allocate_handle(nullptr);\n@@ -56,1 +56,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -58,1 +58,1 @@\n-    if (h._thread != NULL) {                                           \\\n+    if (h._thread != nullptr) {                                        \\\n@@ -67,1 +67,1 @@\n-    _thread = NULL;                                                    \\\n+    _thread = nullptr;                                                 \\\n@@ -73,1 +73,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -75,1 +75,1 @@\n-    if (s._thread != NULL) {                                           \\\n+    if (s._thread != nullptr) {                                        \\\n@@ -84,1 +84,1 @@\n-    _thread = NULL;                                                    \\\n+    _thread = nullptr;                                                 \\\n@@ -89,1 +89,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -125,1 +125,1 @@\n-  if (_prev != NULL) _prev->oops_do(f);\n+  if (_prev != nullptr) _prev->oops_do(f);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-  oop     obj() const                            { return _handle == NULL ? (oop)NULL : *_handle; }\n-  oop     non_null_obj() const                   { assert(_handle != NULL, \"resolving NULL handle\"); return *_handle; }\n+  oop     obj() const                            { return _handle == nullptr ? (oop)nullptr : *_handle; }\n+  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving nullptr handle\"); return *_handle; }\n@@ -75,1 +75,1 @@\n-  Handle()                                       { _handle = NULL; }\n+  Handle()                                       { _handle = nullptr; }\n@@ -88,2 +88,2 @@\n-  bool    is_null() const                        { return _handle == NULL; }\n-  bool    not_null() const                       { return _handle != NULL; }\n+  bool    is_null() const                        { return _handle == nullptr; }\n+  bool    not_null() const                       { return _handle != nullptr; }\n@@ -102,1 +102,1 @@\n-  static oop raw_resolve(oop *handle)            { return handle == NULL ? (oop)NULL : *handle; }\n+  static oop raw_resolve(oop *handle)            { return handle == nullptr ? (oop)nullptr : *handle; }\n@@ -147,1 +147,1 @@\n-    type*        non_null_obj() const            { assert(_value != NULL, \"resolving NULL _value\"); return _value; } \\\n+    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving nullptr _value\"); return _value; } \\\n@@ -151,1 +151,1 @@\n-    name##Handle () : _value(NULL), _thread(NULL) {}   \\\n+    name##Handle () : _value(nullptr), _thread(nullptr) {}   \\\n@@ -169,2 +169,2 @@\n-    bool    is_null() const                      { return _value == NULL; } \\\n-    bool    not_null() const                     { return _value != NULL; } \\\n+    bool    is_null() const                      { return _value == nullptr; } \\\n+    bool    not_null() const                     { return _value != nullptr; } \\\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  if (obj == NULL) {\n-    _handle = NULL;\n+  if (obj == nullptr) {\n+    _handle = nullptr;\n@@ -50,1 +50,1 @@\n-  assert(_handle != NULL, \"should not use replace\");\n+  assert(_handle != nullptr, \"should not use replace\");\n@@ -68,1 +68,1 @@\n-  if (obj != NULL) {                                                   \\\n+  if (obj != nullptr) {                                                   \\\n@@ -88,1 +88,1 @@\n-  if(_chunk->next() != NULL) {\n+  if(_chunk->next() != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    : HandshakeOperation(cl, target, NULL), _start_time_ns(start_ns) {}\n+    : HandshakeOperation(cl, target, nullptr), _start_time_ns(start_ns) {}\n@@ -191,1 +191,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -203,1 +203,1 @@\n-  if (target != NULL) {\n+  if (target != nullptr) {\n@@ -214,1 +214,1 @@\n-static void check_handshake_timeout(jlong start_time, HandshakeOperation* op, JavaThread* target = NULL) {\n+static void check_handshake_timeout(jlong start_time, HandshakeOperation* op, JavaThread* target = nullptr) {\n@@ -224,1 +224,1 @@\n-static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int emitted_handshakes_executed, const char* extra = NULL) {\n+static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int emitted_handshakes_executed, const char* extra = nullptr) {\n@@ -231,2 +231,2 @@\n-                        extra != NULL ? \", \" : \"\",\n-                        extra != NULL ? extra : \"\");\n+                        extra != nullptr ? \", \" : \"\",\n+                        extra != nullptr ? extra : \"\");\n@@ -248,1 +248,1 @@\n-    for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+    for (JavaThread* thr = jtiwh.next(); thr != nullptr; thr = jtiwh.next()) {\n@@ -276,1 +276,1 @@\n-      for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+      for (JavaThread* thr = jtiwh.next(); thr != nullptr; thr = jtiwh.next()) {\n@@ -309,1 +309,1 @@\n-  if (_requester != NULL && _requester != executing_thread && _requester->is_Java_thread()) {\n+  if (_requester != nullptr && _requester != executing_thread && _requester->is_Java_thread()) {\n@@ -346,1 +346,1 @@\n-  HandshakeOperation cto(hs_cl, NULL, Thread::current());\n+  HandshakeOperation cto(hs_cl, nullptr, Thread::current());\n@@ -499,1 +499,1 @@\n-  return get_op_for_self(allow_suspend, check_async_exception) != NULL;\n+  return get_op_for_self(allow_suspend, check_async_exception) != nullptr;\n@@ -504,2 +504,2 @@\n-  MutexLocker ml(_lock.owned_by_self() ? NULL :  &_lock, Mutex::_no_safepoint_check_flag);\n-  return _queue.peek(async_exception_filter) != NULL;\n+  MutexLocker ml(_lock.owned_by_self() ? nullptr :  &_lock, Mutex::_no_safepoint_check_flag);\n+  return _queue.peek(async_exception_filter) != nullptr;\n@@ -551,2 +551,2 @@\n-    if (op != NULL) {\n-      assert(op->_target == NULL || op->_target == Thread::current(), \"Wrong thread\");\n+    if (op != nullptr) {\n+      assert(op->_target == nullptr || op->_target == Thread::current(), \"Wrong thread\");\n@@ -649,1 +649,1 @@\n-  assert(op != NULL, \"Must have an op\");\n+  assert(op != nullptr, \"Must have an op\");\n@@ -651,1 +651,1 @@\n-  assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n+  assert(op->_target == nullptr || _handshakee == op->_target, \"Wrong thread\");\n@@ -661,1 +661,1 @@\n-  set_active_handshaker(NULL);\n+  set_active_handshaker(nullptr);\n@@ -706,1 +706,1 @@\n-  assert(_handshakee->threadObj() != NULL, \"cannot suspend with a NULL threadObj\");\n+  assert(_handshakee->threadObj() != nullptr, \"cannot suspend with a nullptr threadObj\");\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-AbstractICache::flush_icache_stub_t AbstractICache::_flush_icache_stub = NULL;\n+AbstractICache::flush_icache_stub_t AbstractICache::_flush_icache_stub = nullptr;\n@@ -39,1 +39,1 @@\n-  if (b == NULL) {\n+  if (b == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/icache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  if (current_thread->active_handles() == NULL) return;\n+  if (current_thread->active_handles() == nullptr) return;\n@@ -223,1 +223,1 @@\n-    if (cb != NULL && !(cb->is_runtime_stub() || cb->is_uncommon_trap_stub())) return;\n+    if (cb != nullptr && !(cb->is_runtime_stub() || cb->is_uncommon_trap_stub())) return;\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-    assert(thread != NULL, \"must be active Java thread\");\n+    assert(thread != nullptr, \"must be active Java thread\");\n@@ -148,1 +148,1 @@\n-  ThreadInVMfromUnknown() : _thread(NULL) {\n+  ThreadInVMfromUnknown() : _thread(nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  if ((m->method_data() != NULL) &&\n+  if ((m->method_data() != nullptr) &&\n@@ -135,1 +135,1 @@\n-        if (m->method_data() != NULL && m->method_data()->parameters_type_data() != NULL) {\n+        if (m->method_data() != nullptr && m->method_data()->parameters_type_data() != nullptr) {\n@@ -298,1 +298,1 @@\n-    CompileBroker::print_heapinfo(NULL, \"all\", 4096); \/\/ details\n+    CompileBroker::print_heapinfo(nullptr, \"all\", 4096); \/\/ details\n@@ -363,1 +363,1 @@\n-    CompileBroker::print_heapinfo(NULL, \"all\", 4096); \/\/ details\n+    CompileBroker::print_heapinfo(nullptr, \"all\", 4096); \/\/ details\n@@ -494,1 +494,1 @@\n-    assert(ArchiveClassesAtExit != NULL, \"Must be already set\");\n+    assert(ArchiveClassesAtExit != nullptr, \"Must be already set\");\n@@ -530,2 +530,2 @@\n-      ThreadLocalStorage::is_initialized() ? Thread::current_or_null() : NULL;\n-  if (thread == NULL) {\n+      ThreadLocalStorage::is_initialized() ? Thread::current_or_null() : nullptr;\n+  if (thread == nullptr) {\n@@ -541,1 +541,1 @@\n-  if (VMThread::vm_thread() != NULL) {\n+  if (VMThread::vm_thread() != nullptr) {\n@@ -592,1 +592,1 @@\n-    if (thread != NULL && thread->is_Java_thread()) {\n+    if (thread != nullptr && thread->is_Java_thread()) {\n@@ -625,1 +625,1 @@\n-  if (error != NULL) {\n+  if (error != nullptr) {\n@@ -628,1 +628,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -645,1 +645,1 @@\n-  if (error != NULL) {\n+  if (error != nullptr) {\n@@ -648,1 +648,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -661,1 +661,1 @@\n-  vm_notify_during_shutdown(NULL, NULL);\n+  vm_notify_during_shutdown(nullptr, nullptr);\n@@ -672,1 +672,1 @@\n-  JavaThread* THREAD = JavaThread::current(); \/\/ can't be NULL\n+  JavaThread* THREAD = JavaThread::current(); \/\/ can't be nullptr\n@@ -678,1 +678,1 @@\n-  vm_notify_during_shutdown(NULL, NULL);\n+  vm_notify_during_shutdown(nullptr, nullptr);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-extern void vm_exit_during_initialization(const char* error, const char* message = NULL);\n-extern void vm_shutdown_during_initialization(const char* error, const char* message = NULL);\n+extern void vm_exit_during_initialization(const char* error, const char* message = nullptr);\n+extern void vm_shutdown_during_initialization(const char* error, const char* message = nullptr);\n@@ -60,1 +60,1 @@\n-extern void vm_exit_during_cds_dumping(const char* error, const char* message = NULL);\n+extern void vm_exit_during_cds_dumping(const char* error, const char* message = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == nullptr so\n@@ -98,1 +98,1 @@\n-  assert (_thread->thread_state() != _thread_in_native, \"cannot set native pc to NULL\");\n+  assert (_thread->thread_state() != _thread_in_native, \"cannot set native pc to null\");\n@@ -179,1 +179,1 @@\n-  Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();\n+  Klass* recvrKlass = receiver.is_null() ? (Klass*)nullptr : receiver->klass();\n@@ -410,2 +410,2 @@\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(NULL, alternative_target());\n-        if (verified_entry_point != NULL) {\n+        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+        if (verified_entry_point != nullptr) {\n@@ -444,1 +444,1 @@\n-    thread->set_vm_result(NULL);\n+    thread->set_vm_result(nullptr);\n@@ -476,1 +476,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  bool             is_first_frame() const   { return _anchor.last_Java_sp() == NULL; }\n+  bool             is_first_frame() const   { return _anchor.last_Java_sp() == nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  \/\/ Whenever _last_Java_sp != NULL other anchor fields MUST be valid!\n+  \/\/ Whenever _last_Java_sp != nullptr other anchor fields MUST be valid!\n@@ -75,1 +75,1 @@\n-  \/\/ It is important that when last_Java_sp != NULL that the rest of the frame\n+  \/\/ It is important that when last_Java_sp != nullptr that the rest of the frame\n@@ -78,2 +78,2 @@\n-  bool has_last_Java_frame() const                   { return _last_Java_sp != NULL; }\n-  \/\/ This is very dangerous unless sp == NULL\n+  bool has_last_Java_frame() const                   { return _last_Java_sp != nullptr; }\n+  \/\/ This is very dangerous unless sp == nullptr\n@@ -82,1 +82,1 @@\n-  void zap(void)                                     { _last_Java_sp = NULL; }\n+  void zap(void)                                     { _last_Java_sp = nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-OopStorage* JavaThread::_thread_oop_storage = NULL;\n+OopStorage* JavaThread::_thread_oop_storage = nullptr;\n@@ -152,1 +152,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -157,1 +157,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -160,2 +160,2 @@\n-  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n-  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, nullptr);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, nullptr);\n@@ -177,1 +177,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -186,1 +186,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -195,1 +195,1 @@\n-  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+  if (_scopedValueCache.ptr_raw() != nullptr) { \/\/ i.e. if the OopHandle has been allocated\n@@ -198,1 +198,1 @@\n-    assert(p == NULL, \"not yet initialized\");\n+    assert(p == nullptr, \"not yet initialized\");\n@@ -203,1 +203,1 @@\n-  set_scopedValueCache(NULL);\n+  set_scopedValueCache(nullptr);\n@@ -207,1 +207,1 @@\n-  if (vthread_oop != NULL) {\n+  if (vthread_oop != nullptr) {\n@@ -215,1 +215,1 @@\n-  assert(threadObj() == NULL, \"should only create Java thread object once\");\n+  assert(threadObj() == nullptr, \"should only create Java thread object once\");\n@@ -228,1 +228,1 @@\n-  if (thread_name != NULL) {\n+  if (thread_name != nullptr) {\n@@ -285,2 +285,2 @@\n-  if (new_counters == NULL) {\n-    return NULL;\n+  if (new_counters == nullptr) {\n+    return nullptr;\n@@ -288,1 +288,1 @@\n-  if (old_counters == NULL) {\n+  if (old_counters == nullptr) {\n@@ -306,1 +306,1 @@\n-  if (new_counters == NULL) {\n+  if (new_counters == nullptr) {\n@@ -326,1 +326,1 @@\n-    if (new_counters == NULL) {\n+    if (new_counters == nullptr) {\n@@ -412,1 +412,1 @@\n-  _current_pending_monitor(NULL),\n+  _current_pending_monitor(nullptr),\n@@ -414,3 +414,3 @@\n-  _current_waiting_monitor(NULL),\n-  _active_handles(NULL),\n-  _free_handle_block(NULL),\n+  _current_waiting_monitor(nullptr),\n+  _active_handles(nullptr),\n+  _free_handle_block(nullptr),\n@@ -544,1 +544,1 @@\n-  if (_threadObj.peek() == NULL) {\n+  if (_threadObj.peek() == nullptr) {\n@@ -546,1 +546,1 @@\n-    \/\/ been interrupted. We can find NULL during VM initialization\n+    \/\/ been interrupted. We can find null during VM initialization\n@@ -601,1 +601,1 @@\n-  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n+  \/\/ The _osthread may be null here because we ran out of memory (too many threads active).\n@@ -620,1 +620,1 @@\n-  _SleepEvent = NULL;\n+  _SleepEvent = nullptr;\n@@ -625,1 +625,1 @@\n-  if (old_array != NULL) {\n+  if (old_array != nullptr) {\n@@ -627,1 +627,1 @@\n-    old_array->set_unroll_block(NULL);\n+    old_array->set_unroll_block(nullptr);\n@@ -633,1 +633,1 @@\n-  if (updates != NULL) {\n+  if (updates != nullptr) {\n@@ -638,1 +638,1 @@\n-    set_deferred_updates(NULL);\n+    set_deferred_updates(nullptr);\n@@ -643,1 +643,1 @@\n-  if (_thread_stat != NULL) delete _thread_stat;\n+  if (_thread_stat != nullptr) delete _thread_stat;\n@@ -700,1 +700,1 @@\n-  assert(_threadObj.peek() != NULL, \"just checking\");\n+  assert(_threadObj.peek() != nullptr, \"just checking\");\n@@ -736,1 +736,1 @@\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n+  java_lang_Thread::set_thread(threadObj(), nullptr);\n@@ -743,1 +743,1 @@\n-  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n+  return (threadObj != nullptr && java_lang_Thread::is_daemon(threadObj));\n@@ -881,1 +881,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -883,1 +883,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -887,1 +887,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -889,1 +889,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -906,1 +906,1 @@\n-  char* thread_name = NULL;\n+  char* thread_name = nullptr;\n@@ -952,1 +952,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -954,1 +954,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -958,1 +958,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -960,1 +960,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -982,1 +982,1 @@\n-    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n+    JavaThread *ret = op == nullptr ? nullptr : JavaThread::cast(op->calling_thread());\n@@ -990,1 +990,1 @@\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1011,1 +1011,1 @@\n-  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n+  guarantee(monitor_chunks() != nullptr, \"must be non empty\");\n@@ -1033,1 +1033,1 @@\n-  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(java_throwable != nullptr, \"should have an _async_exception to throw\");\n@@ -1245,1 +1245,1 @@\n-        while (found != NULL) {\n+        while (found != nullptr) {\n@@ -1313,1 +1313,1 @@\n-  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  assert(old_handles != nullptr && new_handles != nullptr, \"should not be null\");\n@@ -1325,1 +1325,1 @@\n-  old_handles->set_pop_frame_link(NULL);\n+  old_handles->set_pop_frame_link(nullptr);\n@@ -1336,1 +1336,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -1344,1 +1344,1 @@\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1349,1 +1349,1 @@\n-  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n+  assert(vframe_array_head() == nullptr, \"deopt in progress at a safepoint!\");\n@@ -1353,1 +1353,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n@@ -1367,1 +1367,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1388,1 +1388,1 @@\n-  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  StackWatermarkSet::finish_processing(this, nullptr \/* context *\/, StackWatermarkKind::gc);\n@@ -1413,1 +1413,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1427,1 +1427,1 @@\n-    if (ct->env() != NULL) {\n+    if (ct->env() != nullptr) {\n@@ -1431,1 +1431,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1465,1 +1465,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1473,1 +1473,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1476,1 +1476,1 @@\n-      assert(vt != NULL, \"\");\n+      assert(vt != nullptr, \"\");\n@@ -1487,1 +1487,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1489,1 +1489,1 @@\n-      task->print(st, NULL, true, false);\n+      task->print(st, nullptr, true, false);\n@@ -1547,1 +1547,1 @@\n-  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+  oops_do(&VerifyOopClosure::verify_oop, nullptr);\n@@ -1554,1 +1554,1 @@\n-\/\/ Most callers of this method assume that it can't return NULL but a\n+\/\/ Most callers of this method assume that it can't return null but a\n@@ -1559,1 +1559,1 @@\n-\/\/ for such that this method never returns NULL.\n+\/\/ for such that this method never returns null.\n@@ -1570,1 +1570,1 @@\n-\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n+\/\/ Returns a non-null representation of this thread's name, or a suitable\n@@ -1582,1 +1582,1 @@\n-    if (thread_obj != NULL) {\n+    if (thread_obj != nullptr) {\n@@ -1584,2 +1584,2 @@\n-      if (name != NULL) {\n-        if (buf == NULL) {\n+      if (name != nullptr) {\n+        if (buf == nullptr) {\n@@ -1611,1 +1611,1 @@\n-  assert(name_str != NULL, \"unexpected NULL thread name\");\n+  assert(name_str != nullptr, \"unexpected null thread name\");\n@@ -1617,1 +1617,1 @@\n-  assert(thread_obj != NULL, \"precondition\");\n+  assert(thread_obj != nullptr, \"precondition\");\n@@ -1620,1 +1620,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1671,1 +1671,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1674,1 +1674,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1710,1 +1710,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1744,1 +1744,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1796,1 +1796,1 @@\n-  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n+  assert(_popframe_preserved_args == nullptr, \"should not wipe out old PopFrame preserved arguments\");\n@@ -1819,1 +1819,1 @@\n-  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n+  assert(_popframe_preserved_args != nullptr, \"should not free PopFrame preserved arguments twice\");\n@@ -1821,1 +1821,1 @@\n-  _popframe_preserved_args = NULL;\n+  _popframe_preserved_args = nullptr;\n@@ -1841,1 +1841,1 @@\n-    if (obj == NULL) return;\n+    if (obj == nullptr) return;\n@@ -1941,1 +1941,1 @@\n-  guarantee (entry != NULL, \"Not a carrier thread\");\n+  guarantee (entry != nullptr, \"Not a carrier thread\");\n@@ -1955,1 +1955,1 @@\n-  assert(reg_map != NULL, \"a map must be given\");\n+  assert(reg_map != nullptr, \"a map must be given\");\n@@ -1959,1 +1959,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1971,1 +1971,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2046,1 +2046,1 @@\n-  if (shutdown_klass != NULL) {\n+  if (shutdown_klass != nullptr) {\n@@ -2095,1 +2095,1 @@\n-  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+  assert(target->osthread() != nullptr, \"target thread is not properly initialized\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":89,"deletions":89,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  \/\/ be NULLed. This is because we rarely ever see the race and end up\n+  \/\/ be nulled. This is because we rarely ever see the race and end up\n@@ -166,1 +166,1 @@\n-    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    \/\/ Especially, reloading pointer from thread after null check must be prevented.\n@@ -227,1 +227,1 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -517,1 +517,1 @@\n-  \/\/ Thread oop. threadObj() can be NULL for initial JavaThread\n+  \/\/ Thread oop. threadObj() can be null for initial JavaThread\n@@ -539,1 +539,1 @@\n-  \/\/ Allocates a new Java level thread object for this thread. thread_name may be NULL.\n+  \/\/ Allocates a new Java level thread object for this thread. thread_name may be null.\n@@ -598,1 +598,1 @@\n-  bool cont_fastpath() const                   { return _cont_fastpath == NULL && _cont_fastpath_thread_state != 0; }\n+  bool cont_fastpath() const                   { return _cont_fastpath == nullptr && _cont_fastpath_thread_state != 0; }\n@@ -709,2 +709,2 @@\n-  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n-  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n+  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == nullptr, \"must be\"); _jvmci._alternate_call_target = a; }\n+  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == nullptr, \"must be\"); _jvmci._implicit_exception_pc = a; }\n@@ -732,2 +732,2 @@\n-    set_exception_oop(NULL);\n-    set_exception_pc(NULL);\n+    set_exception_oop(nullptr);\n+    set_exception_pc(nullptr);\n@@ -850,2 +850,2 @@\n-  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != NULL; }\n-  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = NULL; }\n+  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != nullptr; }\n+  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = nullptr; }\n@@ -879,1 +879,1 @@\n-  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+  const char* get_thread_name_string(char* buf = nullptr, int buflen = 0) const;\n@@ -972,1 +972,1 @@\n-  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  \/\/ Returns the current thread as a JavaThread, or nullptr if not attached\n@@ -1003,1 +1003,1 @@\n-  \/\/ one which means NULL can be returned. JvmtiThreadState::state_for()\n+  \/\/ one which means null can be returned. JvmtiThreadState::state_for()\n@@ -1006,1 +1006,1 @@\n-  \/\/ returns it. JvmtiThreadState::state_for() will return NULL only if\n+  \/\/ returns it. JvmtiThreadState::state_for() will return null only if\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-  assert(current_or_null() == NULL || current_or_null() == this,\n+  assert(current_or_null() == nullptr || current_or_null() == this,\n@@ -228,2 +228,2 @@\n-  assert((k == NULL && _class_to_be_initialized != NULL) ||\n-         (k != NULL && _class_to_be_initialized == NULL), \"incorrect usage\");\n+  assert((k == nullptr && _class_to_be_initialized != nullptr) ||\n+         (k != nullptr && _class_to_be_initialized == nullptr), \"incorrect usage\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-OopStorage* JNIHandles::_global_handles = NULL;\n-OopStorage* JNIHandles::_weak_global_handles = NULL;\n+OopStorage* JNIHandles::_global_handles = nullptr;\n+OopStorage* JNIHandles::_weak_global_handles = nullptr;\n@@ -62,1 +62,1 @@\n-\/\/ Used by NewLocalRef which requires NULL on out-of-memory\n+\/\/ Used by NewLocalRef which requires null on out-of-memory\n@@ -64,2 +64,2 @@\n-  if (obj == NULL) {\n-    return NULL;                \/\/ ignore null handles\n+  if (obj == nullptr) {\n+    return nullptr;                \/\/ ignore null handles\n@@ -88,1 +88,1 @@\n-  jobject res = NULL;\n+  jobject res = nullptr;\n@@ -93,3 +93,3 @@\n-    \/\/ Return NULL on allocation failure.\n-    if (ptr != NULL) {\n-      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n+    \/\/ Return null on allocation failure.\n+    if (ptr != nullptr) {\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(nullptr), \"invariant\");\n@@ -110,1 +110,1 @@\n-  jweak res = NULL;\n+  jweak res = nullptr;\n@@ -115,3 +115,3 @@\n-    \/\/ Return NULL on allocation failure.\n-    if (ptr != NULL) {\n-      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n+    \/\/ Return nullptr on allocation failure.\n+    if (ptr != nullptr) {\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(nullptr), \"invariant\");\n@@ -128,1 +128,1 @@\n-\/\/ Resolve some erroneous cases to NULL, rather than treating them as\n+\/\/ Resolve some erroneous cases to null, rather than treating them as\n@@ -130,1 +130,1 @@\n-\/\/ treated as NULL (though a deleted and later reallocated handle\n+\/\/ treated as null (though a deleted and later reallocated handle\n@@ -133,2 +133,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -141,1 +141,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -144,1 +144,1 @@\n-  return value == NULL;\n+  return value == nullptr;\n@@ -148,1 +148,1 @@\n-  if (handle != NULL) {\n+  if (handle != nullptr) {\n@@ -150,1 +150,1 @@\n-    NativeAccess<>::oop_store(oop_ptr, (oop)NULL);\n+    NativeAccess<>::oop_store(oop_ptr, (oop)nullptr);\n@@ -157,1 +157,1 @@\n-  if (handle != NULL) {\n+  if (handle != nullptr) {\n@@ -159,1 +159,1 @@\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(oop_ptr, (oop)NULL);\n+    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(oop_ptr, (oop)nullptr);\n@@ -184,1 +184,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -215,1 +215,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -219,1 +219,1 @@\n-  while (block != NULL) {\n+  while (block != nullptr) {\n@@ -234,1 +234,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -244,1 +244,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -251,1 +251,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -318,1 +318,1 @@\n-    \/\/ NOT using Access here; just bare clobbering to NULL, since the\n+    \/\/ NOT using Access here; just bare clobbering to null, since the\n@@ -327,1 +327,1 @@\n-  assert(thread == NULL || thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n+  assert(thread == nullptr || thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n@@ -332,1 +332,1 @@\n-  if (thread != NULL && thread->free_handle_block() != NULL) {\n+  if (thread != nullptr && thread->free_handle_block() != nullptr) {\n@@ -339,2 +339,2 @@\n-      if (block == NULL) {\n-        return NULL;\n+      if (block == nullptr) {\n+        return nullptr;\n@@ -349,2 +349,2 @@\n-  block->_next = NULL;\n-  block->_pop_frame_link = NULL;\n+  block->_next = nullptr;\n+  block->_pop_frame_link = nullptr;\n@@ -352,2 +352,2 @@\n-  debug_only(block->_last = NULL);\n-  debug_only(block->_free_list = NULL);\n+  debug_only(block->_last = nullptr);\n+  debug_only(block->_free_list = nullptr);\n@@ -360,1 +360,1 @@\n-  assert(thread == NULL || thread == Thread::current(), \"sanity check\");\n+  assert(thread == nullptr || thread == Thread::current(), \"sanity check\");\n@@ -363,1 +363,1 @@\n-  \/\/ Note that if thread == NULL, we use it as an implicit argument that\n+  \/\/ Note that if thread == nullptr, we use it as an implicit argument that\n@@ -366,1 +366,1 @@\n-  if (thread != NULL ) {\n+  if (thread != nullptr ) {\n@@ -369,1 +369,1 @@\n-    block->_pop_frame_link = NULL;\n+    block->_pop_frame_link = nullptr;\n@@ -373,2 +373,2 @@\n-    if ( freelist != NULL ) {\n-      while ( block->_next != NULL ) block = block->_next;\n+    if ( freelist != nullptr ) {\n+      while ( block->_next != nullptr ) block = block->_next;\n@@ -377,1 +377,1 @@\n-    block = NULL;\n+    block = nullptr;\n@@ -379,2 +379,2 @@\n-    DEBUG_ONLY(block->set_pop_frame_link(NULL));\n-    while (block != NULL) {\n+    DEBUG_ONLY(block->set_pop_frame_link(nullptr));\n+    while (block != nullptr) {\n@@ -383,1 +383,1 @@\n-      assert(block->pop_frame_link() == NULL, \"pop_frame_link should be NULL\");\n+      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be nullptr\");\n@@ -388,1 +388,1 @@\n-  if (pop_frame_link != NULL) {\n+  if (pop_frame_link != nullptr) {\n@@ -401,2 +401,2 @@\n-  while (current_chain != NULL) {\n-    for (JNIHandleBlock* current = current_chain; current != NULL;\n+  while (current_chain != nullptr) {\n+    for (JNIHandleBlock* current = current_chain; current != nullptr;\n@@ -404,1 +404,1 @@\n-      assert(current == current_chain || current->pop_frame_link() == NULL,\n+      assert(current == current_chain || current->pop_frame_link() == nullptr,\n@@ -432,1 +432,1 @@\n-    for (JNIHandleBlock* current = _next; current != NULL;\n+    for (JNIHandleBlock* current = _next; current != nullptr;\n@@ -434,2 +434,2 @@\n-      assert(current->_last == NULL, \"only first block should have _last set\");\n-      assert(current->_free_list == NULL,\n+      assert(current->_last == nullptr, \"only first block should have _last set\");\n+      assert(current->_free_list == nullptr,\n@@ -440,1 +440,1 @@\n-        for (current = current->_next; current != NULL; current = current->_next) {\n+        for (current = current->_next; current != nullptr; current = current->_next) {\n@@ -450,1 +450,1 @@\n-    _free_list = NULL;\n+    _free_list = nullptr;\n@@ -464,1 +464,1 @@\n-  if (_free_list != NULL) {\n+  if (_free_list != nullptr) {\n@@ -471,1 +471,1 @@\n-  if (_last->_next != NULL) {\n+  if (_last->_next != nullptr) {\n@@ -482,2 +482,2 @@\n-    if (_last->_next == NULL) {\n-      return NULL;\n+    if (_last->_next == nullptr) {\n+      return nullptr;\n@@ -492,1 +492,1 @@\n-  assert(_allocate_before_rebuild == 0 && _free_list == NULL, \"just checking\");\n+  assert(_allocate_before_rebuild == 0 && _free_list == nullptr, \"just checking\");\n@@ -495,1 +495,1 @@\n-  for (JNIHandleBlock* current = this; current != NULL; current = current->_next) {\n+  for (JNIHandleBlock* current = this; current != nullptr; current = current->_next) {\n@@ -500,1 +500,1 @@\n-        *handle = _free_list == NULL ? 0 : tag_free_list((uintptr_t)_free_list);\n+        *handle = _free_list == nullptr ? 0 : tag_free_list((uintptr_t)_free_list);\n@@ -527,1 +527,1 @@\n-  for (JNIHandleBlock* current = (JNIHandleBlock*) this; current != NULL; current = current->_next) {\n+  for (JNIHandleBlock* current = (JNIHandleBlock*) this; current != nullptr; current = current->_next) {\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  \/\/ The category predicates all require handle != NULL.\n+  \/\/ The category predicates all require handle != nullptr.\n@@ -121,1 +121,1 @@\n-  \/\/ precondition: handle != NULL.\n+  \/\/ precondition: handle != nullptr.\n@@ -173,2 +173,2 @@\n-  static JNIHandleBlock* allocate_block(JavaThread* thread = NULL, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-  static void release_block(JNIHandleBlock* block, JavaThread* thread = NULL);\n+  static JNIHandleBlock* allocate_block(JavaThread* thread = nullptr, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+  static void release_block(JNIHandleBlock* block, JavaThread* thread = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -81,1 +81,1 @@\n-    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n+    assert(external_guard || result != nullptr, \"Invalid JNI handle\");\n@@ -86,1 +86,1 @@\n-    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n+    assert(external_guard || result != nullptr, \"Invalid JNI handle\");\n@@ -92,2 +92,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -100,2 +100,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -114,1 +114,1 @@\n-  assert(handle != NULL, \"JNI handle should not be null\");\n+  assert(handle != nullptr, \"JNI handle should not be null\");\n@@ -116,1 +116,1 @@\n-  assert(result != NULL, \"NULL read from jni handle\");\n+  assert(result != nullptr, \"nullptr read from jni handle\");\n@@ -121,2 +121,2 @@\n-  if (handle != NULL) {\n-    *local_ptr(handle) = NULL;\n+  if (handle != nullptr) {\n+    *local_ptr(handle) = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-JniPeriodicCheckerTask*              JniPeriodicChecker::_task   = NULL;\n+JniPeriodicCheckerTask*              JniPeriodicChecker::_task   = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    static bool is_active() { return _task != NULL; }\n+    static bool is_active() { return _task != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/jniPeriodicChecker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (our_watermark == NULL) {\n+  if (our_watermark == nullptr) {\n@@ -59,1 +59,1 @@\n-  StackWatermarkSet::finish_processing(_jt, NULL \/* context *\/, StackWatermarkKind::gc);\n+  StackWatermarkSet::finish_processing(_jt, nullptr \/* context *\/, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  _next               = NULL;\n+  _next               = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    assert(in_flight_mutex != NULL, \"must be\");\n+    assert(in_flight_mutex != nullptr, \"must be\");\n@@ -47,1 +47,1 @@\n-    _in_flight_mutex = NULL;\n+    _in_flight_mutex = nullptr;\n@@ -49,1 +49,1 @@\n-  bool not_released() { return _in_flight_mutex != NULL; }\n+  bool not_released() { return _in_flight_mutex != nullptr; }\n@@ -127,1 +127,1 @@\n-  assert_owner(NULL);\n+  assert_owner(nullptr);\n@@ -148,1 +148,1 @@\n-  assert_owner(NULL);\n+  assert_owner(nullptr);\n@@ -174,1 +174,1 @@\n-    assert_owner(NULL);\n+    assert_owner(nullptr);\n@@ -192,1 +192,1 @@\n-  assert_owner(NULL);\n+  assert_owner(nullptr);\n@@ -198,1 +198,1 @@\n-  set_owner(NULL);\n+  set_owner(nullptr);\n@@ -219,1 +219,1 @@\n-  \/\/ conceptually set the owner to NULL in anticipation of\n+  \/\/ conceptually set the owner to null in anticipation of\n@@ -221,1 +221,1 @@\n-  set_owner(NULL);\n+  set_owner(nullptr);\n@@ -240,1 +240,1 @@\n-  \/\/ conceptually set the owner to NULL in anticipation of\n+  \/\/ conceptually set the owner to null in anticipation of\n@@ -242,1 +242,1 @@\n-  set_owner(NULL);\n+  set_owner(nullptr);\n@@ -259,1 +259,1 @@\n-    assert_owner(NULL);\n+    assert_owner(nullptr);\n@@ -270,1 +270,1 @@\n-  assert_owner(NULL);\n+  assert_owner(nullptr);\n@@ -274,1 +274,1 @@\n-Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(NULL) {\n+Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(nullptr) {\n@@ -276,1 +276,1 @@\n-  assert(name != NULL, \"Mutex requires a name\");\n+  assert(name != nullptr, \"Mutex requires a name\");\n@@ -366,1 +366,1 @@\n-  if (expected == NULL) {\n+  if (expected == nullptr) {\n@@ -379,1 +379,1 @@\n-  for (res = tmp = locks; tmp != NULL; tmp = tmp->next()) {\n+  for (res = tmp = locks; tmp != nullptr; tmp = tmp->next()) {\n@@ -389,2 +389,2 @@\n-  for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp->next()) {\n-    if (tmp != this && (res == NULL || tmp->rank() < res->rank())) {\n+  for (res = nullptr, tmp = locks; tmp != nullptr; tmp = tmp->next()) {\n+    if (tmp != this && (res == nullptr || tmp->rank() < res->rank())) {\n@@ -404,2 +404,2 @@\n-  for (Mutex* tmp = locks_owned; tmp != NULL; tmp = tmp->next()) {\n-    if (tmp->next() != NULL) {\n+  for (Mutex* tmp = locks_owned; tmp != nullptr; tmp = tmp->next()) {\n+    if (tmp->next() != nullptr) {\n@@ -419,1 +419,1 @@\n-    if (least != NULL && ((least->rank() <= Mutex::nosafepoint && thread->is_Java_thread()) ||\n+    if (least != nullptr && ((least->rank() <= Mutex::nosafepoint && thread->is_Java_thread()) ||\n@@ -439,1 +439,1 @@\n-    if (least != NULL && least->rank() <= this->rank()) {\n+    if (least != nullptr && least->rank() <= this->rank()) {\n@@ -464,2 +464,2 @@\n-  \/\/ It is illegal to set the mutex from one non-NULL\n-  \/\/ owner to another--it must be owned by NULL as an\n+  \/\/ It is illegal to set the mutex from one non-null\n+  \/\/ owner to another--it must be owned by null as an\n@@ -468,1 +468,1 @@\n-  if (new_owner != NULL) {\n+  if (new_owner != nullptr) {\n@@ -472,1 +472,1 @@\n-    assert(owner() == NULL, \"setting the owner thread of an already owned mutex\");\n+    assert(owner() == nullptr, \"setting the owner thread of an already owned mutex\");\n@@ -493,1 +493,1 @@\n-    assert(old_owner != NULL, \"removing the owner thread of an unowned mutex\");\n+    assert(old_owner != nullptr, \"removing the owner thread of an unowned mutex\");\n@@ -496,1 +496,1 @@\n-    raw_set_owner(NULL); \/\/ set the owner\n+    raw_set_owner(nullptr); \/\/ set the owner\n@@ -502,1 +502,1 @@\n-    Mutex* prev = NULL;\n+    Mutex* prev = nullptr;\n@@ -504,1 +504,1 @@\n-    for (; locks != NULL; prev = locks, locks = locks->next()) {\n+    for (; locks != nullptr; prev = locks, locks = locks->next()) {\n@@ -511,1 +511,1 @@\n-    if (prev == NULL) {\n+    if (prev == nullptr) {\n@@ -516,1 +516,1 @@\n-    _next = NULL;\n+    _next = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  \/\/ the low-level _lock, or to NULL before it has released the _lock. Accesses by any thread other\n+  \/\/ the low-level _lock, or to null before it has released the _lock. Accesses by any thread other\n@@ -171,1 +171,1 @@\n-  bool is_locked() const                     { return owner() != NULL; }\n+  bool is_locked() const                     { return owner() != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,17 +45,17 @@\n-Mutex*   Patching_lock                = NULL;\n-Mutex*   CompiledMethod_lock          = NULL;\n-Monitor* SystemDictionary_lock        = NULL;\n-Mutex*   InvokeMethodTable_lock       = NULL;\n-Mutex*   SharedDictionary_lock        = NULL;\n-Monitor* ClassInitError_lock          = NULL;\n-Mutex*   Module_lock                  = NULL;\n-Mutex*   CompiledIC_lock              = NULL;\n-Mutex*   InlineCacheBuffer_lock       = NULL;\n-Mutex*   VMStatistic_lock             = NULL;\n-Mutex*   JmethodIdCreation_lock       = NULL;\n-Mutex*   JfieldIdCreation_lock        = NULL;\n-Monitor* JNICritical_lock             = NULL;\n-Mutex*   JvmtiThreadState_lock        = NULL;\n-Monitor* EscapeBarrier_lock           = NULL;\n-Monitor* JvmtiVTMSTransition_lock     = NULL;\n-Monitor* Heap_lock                    = NULL;\n+Mutex*   Patching_lock                = nullptr;\n+Mutex*   CompiledMethod_lock          = nullptr;\n+Monitor* SystemDictionary_lock        = nullptr;\n+Mutex*   InvokeMethodTable_lock       = nullptr;\n+Mutex*   SharedDictionary_lock        = nullptr;\n+Monitor* ClassInitError_lock          = nullptr;\n+Mutex*   Module_lock                  = nullptr;\n+Mutex*   CompiledIC_lock              = nullptr;\n+Mutex*   InlineCacheBuffer_lock       = nullptr;\n+Mutex*   VMStatistic_lock             = nullptr;\n+Mutex*   JmethodIdCreation_lock       = nullptr;\n+Mutex*   JfieldIdCreation_lock        = nullptr;\n+Monitor* JNICritical_lock             = nullptr;\n+Mutex*   JvmtiThreadState_lock        = nullptr;\n+Monitor* EscapeBarrier_lock           = nullptr;\n+Monitor* JvmtiVTMSTransition_lock     = nullptr;\n+Monitor* Heap_lock                    = nullptr;\n@@ -63,1 +63,1 @@\n-Mutex*   PSOldGenExpand_lock      = NULL;\n+Mutex*   PSOldGenExpand_lock      = nullptr;\n@@ -65,35 +65,35 @@\n-Mutex*   AdapterHandlerLibrary_lock   = NULL;\n-Mutex*   SignatureHandlerLibrary_lock = NULL;\n-Mutex*   VtableStubs_lock             = NULL;\n-Mutex*   SymbolArena_lock             = NULL;\n-Monitor* StringDedup_lock             = NULL;\n-Mutex*   StringDedupIntern_lock       = NULL;\n-Monitor* CodeCache_lock               = NULL;\n-Mutex*   TouchedMethodLog_lock        = NULL;\n-Mutex*   RetData_lock                 = NULL;\n-Monitor* VMOperation_lock             = NULL;\n-Monitor* Threads_lock                 = NULL;\n-Mutex*   NonJavaThreadsList_lock      = NULL;\n-Mutex*   NonJavaThreadsListSync_lock  = NULL;\n-Monitor* CGC_lock                     = NULL;\n-Monitor* STS_lock                     = NULL;\n-Monitor* G1OldGCCount_lock            = NULL;\n-Mutex*   G1DetachedRefinementStats_lock = NULL;\n-Mutex*   MarkStackFreeList_lock       = NULL;\n-Mutex*   MarkStackChunkList_lock      = NULL;\n-Mutex*   MonitoringSupport_lock       = NULL;\n-Mutex*   ParGCRareEvent_lock          = NULL;\n-Monitor* ConcurrentGCBreakpoints_lock = NULL;\n-Mutex*   Compile_lock                 = NULL;\n-Monitor* MethodCompileQueue_lock      = NULL;\n-Monitor* CompileThread_lock           = NULL;\n-Monitor* Compilation_lock             = NULL;\n-Mutex*   CompileTaskAlloc_lock        = NULL;\n-Mutex*   CompileStatistics_lock       = NULL;\n-Mutex*   DirectivesStack_lock         = NULL;\n-Mutex*   MultiArray_lock              = NULL;\n-Monitor* Terminator_lock              = NULL;\n-Monitor* InitCompleted_lock           = NULL;\n-Monitor* BeforeExit_lock              = NULL;\n-Monitor* Notify_lock                  = NULL;\n-Mutex*   ExceptionCache_lock          = NULL;\n+Mutex*   AdapterHandlerLibrary_lock   = nullptr;\n+Mutex*   SignatureHandlerLibrary_lock = nullptr;\n+Mutex*   VtableStubs_lock             = nullptr;\n+Mutex*   SymbolArena_lock             = nullptr;\n+Monitor* StringDedup_lock             = nullptr;\n+Mutex*   StringDedupIntern_lock       = nullptr;\n+Monitor* CodeCache_lock               = nullptr;\n+Mutex*   TouchedMethodLog_lock        = nullptr;\n+Mutex*   RetData_lock                 = nullptr;\n+Monitor* VMOperation_lock             = nullptr;\n+Monitor* Threads_lock                 = nullptr;\n+Mutex*   NonJavaThreadsList_lock      = nullptr;\n+Mutex*   NonJavaThreadsListSync_lock  = nullptr;\n+Monitor* CGC_lock                     = nullptr;\n+Monitor* STS_lock                     = nullptr;\n+Monitor* G1OldGCCount_lock            = nullptr;\n+Mutex*   G1DetachedRefinementStats_lock = nullptr;\n+Mutex*   MarkStackFreeList_lock       = nullptr;\n+Mutex*   MarkStackChunkList_lock      = nullptr;\n+Mutex*   MonitoringSupport_lock       = nullptr;\n+Mutex*   ParGCRareEvent_lock          = nullptr;\n+Monitor* ConcurrentGCBreakpoints_lock = nullptr;\n+Mutex*   Compile_lock                 = nullptr;\n+Monitor* MethodCompileQueue_lock      = nullptr;\n+Monitor* CompileThread_lock           = nullptr;\n+Monitor* Compilation_lock             = nullptr;\n+Mutex*   CompileTaskAlloc_lock        = nullptr;\n+Mutex*   CompileStatistics_lock       = nullptr;\n+Mutex*   DirectivesStack_lock         = nullptr;\n+Mutex*   MultiArray_lock              = nullptr;\n+Monitor* Terminator_lock              = nullptr;\n+Monitor* InitCompleted_lock           = nullptr;\n+Monitor* BeforeExit_lock              = nullptr;\n+Monitor* Notify_lock                  = nullptr;\n+Mutex*   ExceptionCache_lock          = nullptr;\n@@ -101,1 +101,1 @@\n-Mutex*   FullGCALot_lock              = NULL;\n+Mutex*   FullGCALot_lock              = nullptr;\n@@ -104,1 +104,1 @@\n-Mutex*   tty_lock                     = NULL;\n+Mutex*   tty_lock                     = nullptr;\n@@ -106,4 +106,4 @@\n-Mutex*   RawMonitor_lock              = NULL;\n-Mutex*   PerfDataMemAlloc_lock        = NULL;\n-Mutex*   PerfDataManager_lock         = NULL;\n-Mutex*   OopMapCacheAlloc_lock        = NULL;\n+Mutex*   RawMonitor_lock              = nullptr;\n+Mutex*   PerfDataMemAlloc_lock        = nullptr;\n+Mutex*   PerfDataManager_lock         = nullptr;\n+Mutex*   OopMapCacheAlloc_lock        = nullptr;\n@@ -111,4 +111,4 @@\n-Mutex*   FreeList_lock                = NULL;\n-Mutex*   OldSets_lock                 = NULL;\n-Mutex*   Uncommit_lock                = NULL;\n-Monitor* RootRegionScan_lock          = NULL;\n+Mutex*   FreeList_lock                = nullptr;\n+Mutex*   OldSets_lock                 = nullptr;\n+Mutex*   Uncommit_lock                = nullptr;\n+Monitor* RootRegionScan_lock          = nullptr;\n@@ -116,8 +116,8 @@\n-Mutex*   Management_lock              = NULL;\n-Monitor* MonitorDeflation_lock        = NULL;\n-Monitor* Service_lock                 = NULL;\n-Monitor* Notification_lock            = NULL;\n-Monitor* PeriodicTask_lock            = NULL;\n-Monitor* RedefineClasses_lock         = NULL;\n-Mutex*   Verify_lock                  = NULL;\n-Monitor* Zip_lock                     = NULL;\n+Mutex*   Management_lock              = nullptr;\n+Monitor* MonitorDeflation_lock        = nullptr;\n+Monitor* Service_lock                 = nullptr;\n+Monitor* Notification_lock            = nullptr;\n+Monitor* PeriodicTask_lock            = nullptr;\n+Monitor* RedefineClasses_lock         = nullptr;\n+Mutex*   Verify_lock                  = nullptr;\n+Monitor* Zip_lock                     = nullptr;\n@@ -126,4 +126,4 @@\n-Mutex*   JfrStacktrace_lock           = NULL;\n-Monitor* JfrMsg_lock                  = NULL;\n-Mutex*   JfrBuffer_lock               = NULL;\n-Monitor* JfrThreadSampler_lock        = NULL;\n+Mutex*   JfrStacktrace_lock           = nullptr;\n+Monitor* JfrMsg_lock                  = nullptr;\n+Mutex*   JfrBuffer_lock               = nullptr;\n+Monitor* JfrThreadSampler_lock        = nullptr;\n@@ -133,1 +133,1 @@\n-Mutex*   UnsafeJlong_lock             = NULL;\n+Mutex*   UnsafeJlong_lock             = nullptr;\n@@ -135,1 +135,1 @@\n-Mutex*   CodeHeapStateAnalytics_lock  = NULL;\n+Mutex*   CodeHeapStateAnalytics_lock  = nullptr;\n@@ -137,1 +137,1 @@\n-Monitor* ContinuationRelativize_lock  = NULL;\n+Monitor* ContinuationRelativize_lock  = nullptr;\n@@ -139,8 +139,8 @@\n-Mutex*   Metaspace_lock               = NULL;\n-Monitor* MetaspaceCritical_lock       = NULL;\n-Mutex*   ClassLoaderDataGraph_lock    = NULL;\n-Monitor* ThreadsSMRDelete_lock        = NULL;\n-Mutex*   ThreadIdTableCreate_lock     = NULL;\n-Mutex*   SharedDecoder_lock           = NULL;\n-Mutex*   DCmdFactory_lock             = NULL;\n-Mutex*   NMTQuery_lock                = NULL;\n+Mutex*   Metaspace_lock               = nullptr;\n+Monitor* MetaspaceCritical_lock       = nullptr;\n+Mutex*   ClassLoaderDataGraph_lock    = nullptr;\n+Monitor* ThreadsSMRDelete_lock        = nullptr;\n+Mutex*   ThreadIdTableCreate_lock     = nullptr;\n+Mutex*   SharedDecoder_lock           = nullptr;\n+Mutex*   DCmdFactory_lock             = nullptr;\n+Mutex*   NMTQuery_lock                = nullptr;\n@@ -150,1 +150,1 @@\n-Mutex*   CDSClassFileStream_lock      = NULL;\n+Mutex*   CDSClassFileStream_lock      = nullptr;\n@@ -152,7 +152,7 @@\n-Mutex*   DumpTimeTable_lock           = NULL;\n-Mutex*   CDSLambda_lock               = NULL;\n-Mutex*   DumpRegion_lock              = NULL;\n-Mutex*   ClassListFile_lock           = NULL;\n-Mutex*   UnregisteredClassesTable_lock= NULL;\n-Mutex*   LambdaFormInvokers_lock      = NULL;\n-Mutex*   ScratchObjects_lock          = NULL;\n+Mutex*   DumpTimeTable_lock           = nullptr;\n+Mutex*   CDSLambda_lock               = nullptr;\n+Mutex*   DumpRegion_lock              = nullptr;\n+Mutex*   ClassListFile_lock           = nullptr;\n+Mutex*   UnregisteredClassesTable_lock= nullptr;\n+Mutex*   LambdaFormInvokers_lock      = nullptr;\n+Mutex*   ScratchObjects_lock          = nullptr;\n@@ -160,1 +160,1 @@\n-Mutex*   Bootclasspath_lock           = NULL;\n+Mutex*   Bootclasspath_lock           = nullptr;\n@@ -163,2 +163,2 @@\n-Monitor* JVMCI_lock                   = NULL;\n-Monitor* JVMCIRuntime_lock            = NULL;\n+Monitor* JVMCI_lock                   = nullptr;\n+Monitor* JVMCIRuntime_lock            = nullptr;\n@@ -175,1 +175,1 @@\n-  assert(lock != NULL, \"Need non-NULL lock\");\n+  assert(lock != nullptr, \"Need non-nullptr lock\");\n@@ -184,1 +184,1 @@\n-  assert(lock != NULL, \"Need non-NULL lock\");\n+  assert(lock != nullptr, \"Need non-null lock\");\n@@ -193,1 +193,1 @@\n-  assert(lock != NULL, \"Need non-NULL lock\");\n+  assert(lock != nullptr, \"Need non-null lock\");\n@@ -408,1 +408,1 @@\n-     if (_mutex_array[i]->owner() != NULL) {\n+     if (_mutex_array[i]->owner() != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":101,"deletions":101,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    if (_mutex != NULL) {\n+    if (_mutex != nullptr) {\n@@ -210,1 +210,1 @@\n-    if (_mutex != NULL) {\n+    if (_mutex != nullptr) {\n@@ -220,1 +220,1 @@\n-    if (_mutex != NULL) {\n+    if (_mutex != nullptr) {\n@@ -231,1 +231,1 @@\n-\/\/ It also disallows NULL.\n+\/\/ It also disallows null.\n@@ -245,1 +245,1 @@\n-    assert(monitor != NULL, \"NULL monitor not allowed\");\n+    assert(monitor != nullptr, \"null monitor not allowed\");\n@@ -251,1 +251,1 @@\n-    assert(monitor != NULL, \"NULL monitor not allowed\");\n+    assert(monitor != nullptr, \"null monitor not allowed\");\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  List() : _head(NULL), _protect() {}\n+  List() : _head(nullptr), _protect() {}\n@@ -69,2 +69,2 @@\n-NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {\n-  assert(BarrierSet::barrier_set() != NULL, \"NonJavaThread created too soon!\");\n+NonJavaThread::NonJavaThread() : Thread(), _next(nullptr) {\n+  assert(BarrierSet::barrier_set() != nullptr, \"NonJavaThread created too soon!\");\n@@ -89,1 +89,1 @@\n-    for (NonJavaThread* t = *p; t != NULL; p = &t->_next, t = *p) {\n+    for (NonJavaThread* t = *p; t != nullptr; p = &t->_next, t = *p) {\n@@ -101,1 +101,1 @@\n-  _next = NULL;                 \/\/ Safe to drop the link now.\n+  _next = nullptr;                 \/\/ Safe to drop the link now.\n@@ -109,1 +109,1 @@\n-  assert(this->name() != NULL, \"thread name was not set before it was started\");\n+  assert(this->name() != nullptr, \"thread name was not set before it was started\");\n@@ -126,2 +126,2 @@\n-  _name(NULL),\n-  _processed_thread(NULL),\n+  _name(nullptr),\n+  _processed_thread(nullptr),\n@@ -136,1 +136,1 @@\n-  guarantee(_name == NULL, \"Only get to set name once.\");\n+  guarantee(_name == nullptr, \"Only get to set name once.\");\n@@ -157,1 +157,1 @@\n-WatcherThread* WatcherThread::_watcher_thread   = NULL;\n+WatcherThread* WatcherThread::_watcher_thread   = nullptr;\n@@ -162,1 +162,1 @@\n-  assert(watcher_thread() == NULL, \"we can only allocate one WatcherThread\");\n+  assert(watcher_thread() == nullptr, \"we can only allocate one WatcherThread\");\n@@ -288,1 +288,1 @@\n-    _watcher_thread = NULL;\n+    _watcher_thread = nullptr;\n@@ -296,1 +296,1 @@\n-  if (watcher_thread() == NULL && _startable) {\n+  if (watcher_thread() == nullptr && _startable) {\n@@ -316,1 +316,1 @@\n-    if (watcher != NULL) {\n+    if (watcher != nullptr) {\n@@ -324,1 +324,1 @@\n-  while (watcher_thread() != NULL) {\n+  while (watcher_thread() != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  bool end() const { return _current == NULL; }\n+  bool end() const { return _current == nullptr; }\n@@ -94,1 +94,1 @@\n-  virtual const char* name() const { return _name == NULL ? \"Unknown Thread\" : _name; }\n+  virtual const char* name() const { return _name == nullptr ? \"Unknown Thread\" : _name; }\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  char* bytes = NULL;                                                      \\\n+  char* bytes = nullptr;                                                   \\\n@@ -73,1 +73,1 @@\n-  if (klassname != NULL) {                                                 \\\n+  if (klassname != nullptr) {                                              \\\n@@ -124,1 +124,1 @@\n-OopStorage* ObjectMonitor::_oop_storage = NULL;\n+OopStorage* ObjectMonitor::_oop_storage = nullptr;\n@@ -262,1 +262,1 @@\n-  _owner(NULL),\n+  _owner(nullptr),\n@@ -264,1 +264,1 @@\n-  _next_om(NULL),\n+  _next_om(nullptr),\n@@ -266,4 +266,4 @@\n-  _EntryList(NULL),\n-  _cxq(NULL),\n-  _succ(NULL),\n-  _Responsible(NULL),\n+  _EntryList(nullptr),\n+  _cxq(nullptr),\n+  _succ(nullptr),\n+  _Responsible(nullptr),\n@@ -273,1 +273,1 @@\n-  _WaitSet(NULL),\n+  _WaitSet(nullptr),\n@@ -285,1 +285,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -292,1 +292,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -300,1 +300,1 @@\n-    _om->_succ = NULL;\n+    _om->_succ = nullptr;\n@@ -312,1 +312,1 @@\n-      _om->_succ = NULL;\n+      _om->_succ = nullptr;\n@@ -325,2 +325,2 @@\n-  void* cur = try_set_owner_from(NULL, current);\n-  if (cur == NULL) {\n+  void* cur = try_set_owner_from(nullptr, current);\n+  if (cur == nullptr) {\n@@ -376,1 +376,1 @@\n-    if (l_object != NULL) {\n+    if (l_object != nullptr) {\n@@ -399,1 +399,1 @@\n-    assert(current->current_pending_monitor() == NULL, \"invariant\");\n+    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n@@ -422,1 +422,1 @@\n-        current->set_current_pending_monitor(NULL);\n+        current->set_current_pending_monitor(nullptr);\n@@ -487,2 +487,2 @@\n-  if (own != NULL) return 0;\n-  if (try_set_owner_from(NULL, current) == NULL) {\n+  if (own != nullptr) return 0;\n+  if (try_set_owner_from(nullptr, current) == nullptr) {\n@@ -530,1 +530,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -533,1 +533,1 @@\n-    set_owner_from(NULL, DEFLATER_MARKER);\n+    set_owner_from(nullptr, DEFLATER_MARKER);\n@@ -539,1 +539,1 @@\n-    \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n+    \/\/ Set a nullptr owner to DEFLATER_MARKER to force any contending thread\n@@ -542,2 +542,2 @@\n-    if (try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n-      \/\/ The owner field is no longer NULL so we lost the race since the\n+    if (try_set_owner_from(nullptr, DEFLATER_MARKER) != nullptr) {\n+      \/\/ The owner field is no longer null so we lost the race since the\n@@ -552,2 +552,2 @@\n-      \/\/ NULL if it is still DEFLATER_MARKER.\n-      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      \/\/ null if it is still DEFLATER_MARKER.\n+      if (try_set_owner_from(DEFLATER_MARKER, nullptr) != DEFLATER_MARKER) {\n@@ -564,1 +564,1 @@\n-      \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n+      \/\/ ObjectMonitor is now busy. Restore owner to nullptr if it is\n@@ -566,1 +566,1 @@\n-      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      if (try_set_owner_from(DEFLATER_MARKER, nullptr) != DEFLATER_MARKER) {\n@@ -579,1 +579,1 @@\n-  guarantee(_cxq == NULL, \"must be no contending threads: cxq=\"\n+  guarantee(_cxq == nullptr, \"must be no contending threads: cxq=\"\n@@ -581,1 +581,1 @@\n-  guarantee(_EntryList == NULL,\n+  guarantee(_EntryList == nullptr,\n@@ -585,1 +585,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -614,1 +614,1 @@\n-  guarantee(obj != NULL, \"must be non-NULL\");\n+  guarantee(obj != nullptr, \"must be non-null\");\n@@ -624,1 +624,1 @@\n-  if (l_object == NULL) {\n+  if (l_object == nullptr) {\n@@ -633,1 +633,1 @@\n-  \/\/ The dmw has to be neutral (not NULL, not locked and not marked).\n+  \/\/ The dmw has to be neutral (not null, not locked and not marked).\n@@ -669,1 +669,1 @@\n-    \/\/ We report NULL instead of DEFLATER_MARKER here because is_busy()\n+    \/\/ We report nullptr instead of DEFLATER_MARKER here because is_busy()\n@@ -786,1 +786,1 @@\n-  if (nxt == NULL && _EntryList == NULL) {\n+  if (nxt == nullptr && _EntryList == nullptr) {\n@@ -864,1 +864,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -881,1 +881,1 @@\n-  if (_succ == current) _succ = NULL;\n+  if (_succ == current) _succ = nullptr;\n@@ -885,1 +885,1 @@\n-    _Responsible = NULL;\n+    _Responsible = nullptr;\n@@ -941,2 +941,2 @@\n-  assert(current != NULL, \"invariant\");\n-  assert(currentNode != NULL, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  assert(currentNode != nullptr, \"invariant\");\n@@ -984,1 +984,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -1006,1 +1006,1 @@\n-  if (_succ == current) _succ = NULL;\n+  if (_succ == current) _succ = nullptr;\n@@ -1025,2 +1025,2 @@\n-    if (nxt != NULL) nxt->_prev = prv;\n-    if (prv != NULL) prv->_next = nxt;\n+    if (nxt != nullptr) nxt->_prev = prv;\n+    if (prv != nullptr) prv->_next = nxt;\n@@ -1028,2 +1028,2 @@\n-    assert(nxt == NULL || nxt->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n-    assert(prv == NULL || prv->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+    assert(nxt == nullptr || nxt->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+    assert(prv == nullptr || prv->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n@@ -1046,1 +1046,1 @@\n-    assert(v != NULL, \"invariant\");\n+    assert(v != nullptr, \"invariant\");\n@@ -1056,2 +1056,2 @@\n-      ObjectWaiter* q = NULL;\n-      for (p = v; p != NULL && p != currentNode; p = p->_next) {\n+      ObjectWaiter* q = nullptr;\n+      for (p = v; p != nullptr && p != currentNode; p = p->_next) {\n@@ -1064,1 +1064,1 @@\n-      assert(q != NULL, \"invariant\");\n+      assert(q != nullptr, \"invariant\");\n@@ -1171,1 +1171,1 @@\n-  _Responsible = NULL;\n+  _Responsible = nullptr;\n@@ -1193,1 +1193,1 @@\n-    if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {\n+    if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != nullptr) {\n@@ -1200,1 +1200,1 @@\n-    \/\/ then this thread can simply store NULL into _owner and exit without\n+    \/\/ then this thread can simply store null into _owner and exit without\n@@ -1234,1 +1234,1 @@\n-    if (try_set_owner_from(NULL, current) != NULL) {\n+    if (try_set_owner_from(nullptr, current) != nullptr) {\n@@ -1240,1 +1240,1 @@\n-    ObjectWaiter* w = NULL;\n+    ObjectWaiter* w = nullptr;\n@@ -1243,1 +1243,1 @@\n-    if (w != NULL) {\n+    if (w != nullptr) {\n@@ -1247,1 +1247,1 @@\n-      \/\/ then calls exit().  Exit release the lock by setting O._owner to NULL.\n+      \/\/ then calls exit().  Exit release the lock by setting O._owner to null.\n@@ -1263,1 +1263,1 @@\n-    if (w == NULL) continue;\n+    if (w == nullptr) continue;\n@@ -1267,1 +1267,1 @@\n-    \/\/ The following loop is tantamount to: w = swap(&cxq, NULL)\n+    \/\/ The following loop is tantamount to: w = swap(&cxq, nullptr)\n@@ -1269,2 +1269,2 @@\n-      assert(w != NULL, \"Invariant\");\n-      ObjectWaiter* u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)NULL);\n+      assert(w != nullptr, \"Invariant\");\n+      ObjectWaiter* u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)nullptr);\n@@ -1275,2 +1275,2 @@\n-    assert(w != NULL, \"invariant\");\n-    assert(_EntryList == NULL, \"invariant\");\n+    assert(w != nullptr, \"invariant\");\n+    assert(_EntryList == nullptr, \"invariant\");\n@@ -1288,1 +1288,1 @@\n-    ObjectWaiter* q = NULL;\n+    ObjectWaiter* q = nullptr;\n@@ -1290,1 +1290,1 @@\n-    for (p = w; p != NULL; p = p->_next) {\n+    for (p = w; p != nullptr; p = p->_next) {\n@@ -1297,1 +1297,1 @@\n-    \/\/ In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL\n+    \/\/ In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = nullptr\n@@ -1303,1 +1303,1 @@\n-    if (_succ != NULL) continue;\n+    if (_succ != nullptr) continue;\n@@ -1306,1 +1306,1 @@\n-    if (w != NULL) {\n+    if (w != nullptr) {\n@@ -1320,1 +1320,1 @@\n-  \/\/ 2. ST _owner = NULL\n+  \/\/ 2. ST _owner = nullptr\n@@ -1326,1 +1326,1 @@\n-  \/\/ Hygiene -- once we've set _owner = NULL we can't safely dereference Wakee again.\n+  \/\/ Hygiene -- once we've set _owner = nullptr we can't safely dereference Wakee again.\n@@ -1329,1 +1329,1 @@\n-  Wakee  = NULL;\n+  Wakee  = nullptr;\n@@ -1430,2 +1430,2 @@\n-  assert(event != NULL, \"invariant\");\n-  assert(monitor != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n+  assert(monitor != nullptr, \"invariant\");\n@@ -1507,1 +1507,1 @@\n-  _Responsible = NULL;\n+  _Responsible = nullptr;\n@@ -1579,1 +1579,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -1641,1 +1641,1 @@\n-  current->set_current_waiting_monitor(NULL);\n+  current->set_current_waiting_monitor(nullptr);\n@@ -1677,1 +1677,1 @@\n-  if (iterator != NULL) {\n+  if (iterator != nullptr) {\n@@ -1692,2 +1692,2 @@\n-    if (list != NULL) {\n-      assert(list->_prev == NULL, \"invariant\");\n+    if (list != nullptr) {\n+      assert(list->_prev == nullptr, \"invariant\");\n@@ -1699,2 +1699,2 @@\n-    if (list == NULL) {\n-      iterator->_next = iterator->_prev = NULL;\n+    if (list == nullptr) {\n+      iterator->_next = iterator->_prev = nullptr;\n@@ -1739,1 +1739,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -1758,1 +1758,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -1764,1 +1764,1 @@\n-  while (_WaitSet != NULL) {\n+  while (_WaitSet != nullptr) {\n@@ -1890,1 +1890,1 @@\n-  if (_succ == NULL) {\n+  if (_succ == nullptr) {\n@@ -1893,1 +1893,1 @@\n-  Thread* prv = NULL;\n+  Thread* prv = nullptr;\n@@ -1932,3 +1932,3 @@\n-    if (ox == NULL) {\n-      ox = static_cast<JavaThread*>(try_set_owner_from(NULL, current));\n-      if (ox == NULL) {\n+    if (ox == nullptr) {\n+      ox = static_cast<JavaThread*>(try_set_owner_from(nullptr, current));\n+      if (ox == nullptr) {\n@@ -1938,1 +1938,1 @@\n-          _succ = NULL;\n+          _succ = nullptr;\n@@ -1966,1 +1966,1 @@\n-    if (ox != prv && prv != NULL) {\n+    if (ox != prv && prv != nullptr) {\n@@ -1978,1 +1978,1 @@\n-    if (_succ == NULL) {\n+    if (_succ == nullptr) {\n@@ -1999,1 +1999,1 @@\n-    _succ = NULL;\n+    _succ = nullptr;\n@@ -2044,1 +2044,1 @@\n-  if (ox == NULL) return 0;\n+  if (ox == nullptr) return 0;\n@@ -2071,2 +2071,2 @@\n-  _next     = NULL;\n-  _prev     = NULL;\n+  _next     = nullptr;\n+  _prev     = nullptr;\n@@ -2079,1 +2079,1 @@\n-  assert(_event != NULL, \"invariant\");\n+  assert(_event != nullptr, \"invariant\");\n@@ -2091,3 +2091,3 @@\n-  assert(node != NULL, \"should not add NULL node\");\n-  assert(node->_prev == NULL, \"node already in list\");\n-  assert(node->_next == NULL, \"node already in list\");\n+  assert(node != nullptr, \"should not add null node\");\n+  assert(node->_prev == nullptr, \"node already in list\");\n+  assert(node->_next == nullptr, \"node already in list\");\n@@ -2095,1 +2095,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -2120,3 +2120,3 @@\n-  assert(node != NULL, \"should not dequeue NULL node\");\n-  assert(node->_prev != NULL, \"node already removed from list\");\n-  assert(node->_next != NULL, \"node already removed from list\");\n+  assert(node != nullptr, \"should not dequeue nullptr node\");\n+  assert(node->_prev != nullptr, \"node already removed from list\");\n+  assert(node->_next != nullptr, \"node already removed from list\");\n@@ -2129,1 +2129,1 @@\n-    _WaitSet = NULL;\n+    _WaitSet = nullptr;\n@@ -2140,2 +2140,2 @@\n-  node->_next = NULL;\n-  node->_prev = NULL;\n+  node->_next = nullptr;\n+  node->_prev = nullptr;\n@@ -2146,7 +2146,7 @@\n-PerfCounter * ObjectMonitor::_sync_ContendedLockAttempts       = NULL;\n-PerfCounter * ObjectMonitor::_sync_FutileWakeups               = NULL;\n-PerfCounter * ObjectMonitor::_sync_Parks                       = NULL;\n-PerfCounter * ObjectMonitor::_sync_Notifications               = NULL;\n-PerfCounter * ObjectMonitor::_sync_Inflations                  = NULL;\n-PerfCounter * ObjectMonitor::_sync_Deflations                  = NULL;\n-PerfLongVariable * ObjectMonitor::_sync_MonExtant              = NULL;\n+PerfCounter * ObjectMonitor::_sync_ContendedLockAttempts       = nullptr;\n+PerfCounter * ObjectMonitor::_sync_FutileWakeups               = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Parks                       = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Notifications               = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Inflations                  = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Deflations                  = nullptr;\n+PerfLongVariable * ObjectMonitor::_sync_MonExtant              = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,6 +187,6 @@\n-  #define OM_PERFDATA_OP(f, op_str)              \\\n-    do {                                         \\\n-      if (ObjectMonitor::_sync_ ## f != NULL &&  \\\n-          PerfDataManager::has_PerfData()) {     \\\n-        ObjectMonitor::_sync_ ## f->op_str;      \\\n-      }                                          \\\n+  #define OM_PERFDATA_OP(f, op_str)                 \\\n+    do {                                            \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr &&  \\\n+          PerfDataManager::has_PerfData()) {        \\\n+        ObjectMonitor::_sync_ ## f->op_str;         \\\n+      }                                             \\\n@@ -249,1 +249,1 @@\n-  void*     owner() const;  \/\/ Returns NULL if DEFLATER_MARKER is observed.\n+  void*     owner() const;  \/\/ Returns null if DEFLATER_MARKER is observed.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  return owner != NULL && owner != DEFLATER_MARKER;\n+  return owner != nullptr && owner != DEFLATER_MARKER;\n@@ -64,1 +64,1 @@\n-\/\/ Returns NULL if DEFLATER_MARKER is observed.\n+\/\/ Returns null if DEFLATER_MARKER is observed.\n@@ -67,1 +67,1 @@\n-  return owner != DEFLATER_MARKER ? owner : NULL;\n+  return owner != DEFLATER_MARKER ? owner : nullptr;\n@@ -76,1 +76,1 @@\n-\/\/ field == DEFLATER_MARKER and any non-NULL value won't do the trick.\n+\/\/ field == DEFLATER_MARKER and any non-null value won't do the trick.\n@@ -103,1 +103,1 @@\n-  Atomic::release_store(&_owner, (void*)NULL);\n+  Atomic::release_store(&_owner, (void*)nullptr);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  if (func != NULL) {\n+  if (func != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,2 @@\n-OSThread*         os::_starting_thread    = NULL;\n-address           os::_polling_page       = NULL;\n+OSThread*         os::_starting_thread    = nullptr;\n+address           os::_polling_page       = nullptr;\n@@ -114,1 +114,1 @@\n-\/\/ Returns buffer, or NULL if it failed.\n+\/\/ Returns buffer, or null if it failed.\n@@ -122,1 +122,1 @@\n-\/\/ Returns buffer, or NULL if it failed.\n+\/\/ Returns buffer, or null if it failed.\n@@ -132,3 +132,3 @@\n-  if (buffer == NULL) {\n-    assert(false, \"NULL buffer\");\n-    return NULL;\n+  if (buffer == nullptr) {\n+    assert(false, \"null buffer\");\n+    return nullptr;\n@@ -138,1 +138,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -148,1 +148,1 @@\n-    if (gmtime_pd(&seconds_since_19700101, &time_struct) == NULL) {\n+    if (gmtime_pd(&seconds_since_19700101, &time_struct) == nullptr) {\n@@ -150,1 +150,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -153,1 +153,1 @@\n-    if (localtime_pd(&seconds_since_19700101, &time_struct) == NULL) {\n+    if (localtime_pd(&seconds_since_19700101, &time_struct) == nullptr) {\n@@ -155,1 +155,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -221,1 +221,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -296,1 +296,1 @@\n-          if (a[n] != NULL) {\n+          if (a[n] != nullptr) {\n@@ -315,1 +315,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -321,1 +321,1 @@\n-    } else if (strchr(pname, *os::path_separator()) != NULL) {\n+    } else if (strchr(pname, *os::path_separator()) != nullptr) {\n@@ -325,1 +325,1 @@\n-      if (pelements != NULL) {\n+      if (pelements != nullptr) {\n@@ -328,2 +328,2 @@\n-          \/\/ Really shouldn't be NULL, but check can't hurt.\n-          size_t plen = (path == NULL) ? 0 : strlen(path);\n+          \/\/ Really shouldn't be null, but check can't hurt.\n+          size_t plen = (path == nullptr) ? 0 : strlen(path);\n@@ -428,1 +428,1 @@\n-        if (klass != NULL) {\n+        if (klass != nullptr) {\n@@ -445,1 +445,1 @@\n-          if (tty != NULL) {\n+          if (tty != nullptr) {\n@@ -451,1 +451,1 @@\n-            if (os::exception_name(sig, tmp_sig_name, 16) != NULL)\n+            if (os::exception_name(sig, tmp_sig_name, 16) != nullptr)\n@@ -502,1 +502,1 @@\n-static void* _native_java_library = NULL;\n+static void* _native_java_library = nullptr;\n@@ -505,1 +505,1 @@\n-  if (_native_java_library == NULL) {\n+  if (_native_java_library == nullptr) {\n@@ -514,1 +514,1 @@\n-    if (_native_java_library == NULL) {\n+    if (_native_java_library == nullptr) {\n@@ -541,1 +541,1 @@\n-  assert(agent_lib != NULL, \"sanity check\");\n+  assert(agent_lib != nullptr, \"sanity check\");\n@@ -544,1 +544,1 @@\n-  void *entryName = NULL;\n+  void *entryName = nullptr;\n@@ -550,1 +550,1 @@\n-  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : NULL);\n+  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n@@ -553,1 +553,1 @@\n-    if (agent_function_name == NULL) {\n+    if (agent_function_name == nullptr) {\n@@ -558,1 +558,1 @@\n-    if (entryName != NULL) {\n+    if (entryName != nullptr) {\n@@ -572,2 +572,2 @@\n-  assert(agent_lib != NULL, \"sanity check\");\n-  if (agent_lib->name() == NULL) {\n+  assert(agent_lib != nullptr, \"sanity check\");\n+  if (agent_lib->name() == nullptr) {\n@@ -582,1 +582,1 @@\n-  if (ret != NULL) {\n+  if (ret != nullptr) {\n@@ -597,1 +597,1 @@\n-  if (dup_str == NULL) return NULL;\n+  if (dup_str == nullptr) return nullptr;\n@@ -604,1 +604,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -647,1 +647,1 @@\n-  void* rc = NULL;\n+  void* rc = nullptr;\n@@ -657,1 +657,1 @@\n-  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n@@ -663,1 +663,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -670,1 +670,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -674,2 +674,2 @@\n-  if (outer_ptr == NULL) {\n-    return NULL;\n+  if (outer_ptr == nullptr) {\n+    return nullptr;\n@@ -697,1 +697,1 @@\n-  void* rc = NULL;\n+  void* rc = nullptr;\n@@ -702,1 +702,1 @@\n-  if (memblock == NULL) {\n+  if (memblock == nullptr) {\n@@ -709,1 +709,1 @@\n-  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n@@ -715,1 +715,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -725,1 +725,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -738,1 +738,1 @@\n-    if (new_outer_ptr == NULL) {\n+    if (new_outer_ptr == nullptr) {\n@@ -765,2 +765,2 @@\n-    if (rc == NULL) {\n-      return NULL;\n+    if (rc == nullptr) {\n+      return nullptr;\n@@ -783,1 +783,1 @@\n-  if (memblock == NULL) {\n+  if (memblock == nullptr) {\n@@ -863,1 +863,1 @@\n-  abort(dump_core && CreateCoredumpOnCrash, NULL, NULL);\n+  abort(dump_core && CreateCoredumpOnCrash, nullptr, nullptr);\n@@ -879,1 +879,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -906,1 +906,1 @@\n-      if (args_start != NULL) {\n+      if (args_start != nullptr) {\n@@ -927,1 +927,1 @@\n-      if (p2 != NULL) {\n+      if (p2 != nullptr) {\n@@ -990,1 +990,1 @@\n-  if (startStr == NULL) startStr = \"\";\n+  if (startStr == nullptr) startStr = \"\";\n@@ -1008,1 +1008,1 @@\n-    for (int i = 0; env_list[i] != NULL; i++) {\n+    for (int i = 0; env_list[i] != nullptr; i++) {\n@@ -1010,1 +1010,1 @@\n-      if (envvar != NULL) {\n+      if (envvar != nullptr) {\n@@ -1073,1 +1073,1 @@\n-  if (nl != NULL) {\n+  if (nl != nullptr) {\n@@ -1078,1 +1078,1 @@\n-  if (localtime_pd(&tloc, &tz) != NULL) {\n+  if (localtime_pd(&tloc, &tz) != nullptr) {\n@@ -1109,1 +1109,1 @@\n-\/\/ Helps to prove validity of a not-NULL pointer.\n+\/\/ Helps to prove validity of a non-null pointer.\n@@ -1133,3 +1133,3 @@\n-  \/\/ Handle NULL first, so later checks don't need to protect against it.\n-  if (addr == NULL) {\n-    st->print_cr(\"0x0 is NULL\");\n+  \/\/ Handle null first, so later checks don't need to protect against it.\n+  if (addr == nullptr) {\n+    st->print_cr(\"0x0 is nullptr\");\n@@ -1141,1 +1141,1 @@\n-  if (b != NULL) {\n+  if (b != nullptr) {\n@@ -1333,1 +1333,1 @@\n-  if (file != NULL) {\n+  if (file != nullptr) {\n@@ -1355,1 +1355,1 @@\n-  if (jimage == NULL) return false;\n+  if (jimage == nullptr) return false;\n@@ -1366,1 +1366,1 @@\n-  if (base_classes == NULL) return false;\n+  if (base_classes == nullptr) return false;\n@@ -1379,1 +1379,1 @@\n-  if (filename == NULL || strlen(filename) == 0) {\n+  if (filename == nullptr || strlen(filename) == 0) {\n@@ -1400,2 +1400,2 @@\n-  if (path == NULL || strlen(path) == 0 || file_name_length == (size_t)NULL) {\n-    return NULL;\n+  if (path == nullptr || strlen(path) == 0 || file_name_length == (size_t)nullptr) {\n+    return nullptr;\n@@ -1409,1 +1409,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -1502,1 +1502,1 @@\n-      (void)::poll(NULL, 0, 100);\n+      (void)::poll(nullptr, 0, 100);\n@@ -1740,1 +1740,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1748,1 +1748,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1865,3 +1865,3 @@\n-  \/\/ On all current implementations NULL is interpreted as any available address.\n-  char* result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n-  if (result != NULL) {\n+  \/\/ On all current implementations null is interpreted as any available address.\n+  char* result = os::map_memory_to_file(nullptr \/* addr *\/, bytes, file_desc);\n+  if (result != nullptr) {\n@@ -1875,1 +1875,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1885,1 +1885,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1926,1 +1926,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  \/\/ Returns buffer, or NULL if it failed.\n+  \/\/ Returns buffer, or null if it failed.\n@@ -300,1 +300,1 @@\n-  \/\/ Returns buffer, or NULL if it failed.\n+  \/\/ Returns buffer, or nullptr if it failed.\n@@ -676,1 +676,1 @@\n-  \/\/ set to -1 (if offset is non-NULL).\n+  \/\/ set to -1 (if offset is non-null).\n@@ -684,1 +684,1 @@\n-  \/\/ and offset is set to -1 (if offset is non-NULL).\n+  \/\/ and offset is set to -1 (if offset is non-null).\n@@ -701,1 +701,1 @@\n-                                              char* buf = NULL, int buflen = 0,\n+                                              char* buf = nullptr, int buflen = 0,\n@@ -715,1 +715,1 @@\n-  \/\/ in case of an error NULL is returned and an error message is stored in ebuf\n+  \/\/ in case of an error null is returned and an error message is stored in ebuf\n@@ -820,1 +820,1 @@\n-  \/\/ return current frame. pc() and sp() are set to NULL on failure.\n+  \/\/ return current frame. pc() and sp() are set to null on failure.\n@@ -830,1 +830,1 @@\n-  \/\/ returns NULL if exception_code is not an OS exception\/signal.\n+  \/\/ returns null if exception_code is not an OS exception\/signal.\n@@ -872,1 +872,1 @@\n-  \/\/ handles NULL pointers\n+  \/\/ handles null pointers\n@@ -875,1 +875,1 @@\n-  \/\/ Like strdup, but exit VM when strdup() returns NULL\n+  \/\/ Like strdup, but exit VM when strdup() returns null\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/os.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-ParkEvent * volatile ParkEvent::FreeList = NULL ;\n+ParkEvent * volatile ParkEvent::FreeList = nullptr ;\n@@ -67,1 +67,1 @@\n-    if (ev != NULL) {\n+    if (ev != nullptr) {\n@@ -73,2 +73,2 @@\n-  if (ev != NULL) {\n-    guarantee (ev->AssociatedWith == NULL, \"invariant\") ;\n+  if (ev != nullptr) {\n+    guarantee (ev->AssociatedWith == nullptr, \"invariant\") ;\n@@ -82,1 +82,1 @@\n-  ev->FreeNext       = NULL ;\n+  ev->FreeNext       = nullptr ;\n@@ -87,3 +87,3 @@\n-  if (ev == NULL) return ;\n-  guarantee (ev->FreeNext == NULL      , \"invariant\") ;\n-  ev->AssociatedWith = NULL ;\n+  if (ev == nullptr) return ;\n+  guarantee (ev->FreeNext == nullptr      , \"invariant\") ;\n+  ev->AssociatedWith = nullptr ;\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,3 +140,3 @@\n-       AssociatedWith = NULL ;\n-       FreeNext       = NULL ;\n-       ListNext       = NULL ;\n+       AssociatedWith = nullptr ;\n+       FreeNext       = nullptr ;\n+       ListNext       = nullptr ;\n","filename":"src\/hotspot\/share\/runtime\/park.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,3 @@\n-PerfDataList*   PerfDataManager::_all = NULL;\n-PerfDataList*   PerfDataManager::_sampled = NULL;\n-PerfDataList*   PerfDataManager::_constants = NULL;\n+PerfDataList*   PerfDataManager::_all = nullptr;\n+PerfDataList*   PerfDataManager::_sampled = nullptr;\n+PerfDataList*   PerfDataManager::_constants = nullptr;\n@@ -83,1 +83,1 @@\n-                  : _name(NULL), _v(v), _u(u), _on_c_heap(false), _valuep(NULL) {\n+                  : _name(nullptr), _v(v), _u(u), _on_c_heap(false), _valuep(nullptr) {\n@@ -139,1 +139,1 @@\n-  if (psmp == NULL) {\n+  if (psmp == nullptr) {\n@@ -197,1 +197,1 @@\n-                                  _sampled(sampled), _sample_helper(NULL) {\n+                                  _sampled(sampled), _sample_helper(nullptr) {\n@@ -205,1 +205,1 @@\n-                                  _sampled(NULL), _sample_helper(helper) {\n+                                  _sampled(nullptr), _sample_helper(helper) {\n@@ -211,1 +211,1 @@\n-  if (_sample_helper != NULL) {\n+  if (_sample_helper != nullptr) {\n@@ -226,2 +226,2 @@\n-  \/\/ copied if s2 == NULL.\n-  strncpy((char *)_valuep, s2 == NULL ? \"\" : s2, _length);\n+  \/\/ copied if s2 == nullptr.\n+  strncpy((char *)_valuep, s2 == nullptr ? \"\" : s2, _length);\n@@ -236,1 +236,1 @@\n-                                  initial_value == NULL ? 1 :\n+                                  initial_value == nullptr ? 1 :\n@@ -242,1 +242,1 @@\n-    if (is_valid() && initial_value != NULL &&\n+    if (is_valid() && initial_value != nullptr &&\n@@ -258,1 +258,1 @@\n-  if (_all == NULL)\n+  if (_all == nullptr)\n@@ -273,2 +273,2 @@\n-                                _all->length(), _sampled == NULL ? 0 : _sampled->length(),\n-                                _constants == NULL ? 0 : _constants->length());\n+                                _all->length(), _sampled == nullptr ? 0 : _sampled->length(),\n+                                _constants == nullptr ? 0 : _constants->length());\n@@ -285,3 +285,3 @@\n-  _all = NULL;\n-  _sampled = NULL;\n-  _constants = NULL;\n+  _all = nullptr;\n+  _sampled = nullptr;\n+  _constants = nullptr;\n@@ -295,1 +295,1 @@\n-  if (_all == NULL) {\n+  if (_all == nullptr) {\n@@ -306,1 +306,1 @@\n-    if (_constants == NULL) {\n+    if (_constants == nullptr) {\n@@ -314,1 +314,1 @@\n-    if (_sampled == NULL) {\n+    if (_sampled == nullptr) {\n@@ -325,2 +325,2 @@\n-  if (_sampled == NULL)\n-    return NULL;\n+  if (_sampled == nullptr)\n+    return nullptr;\n@@ -333,2 +333,2 @@\n-   assert(ns != NULL, \"ns string required\");\n-   assert(name != NULL, \"name string required\");\n+   assert(ns != nullptr, \"ns string required\");\n+   assert(name != nullptr, \"name string required\");\n@@ -397,1 +397,1 @@\n-  if (max_length == 0 && s != NULL) max_length = (int)strlen(s);\n+  if (max_length == 0 && s != nullptr) max_length = (int)strlen(s);\n@@ -439,1 +439,1 @@\n-  if (!UsePerfData) return NULL;\n+  if (!UsePerfData) return nullptr;\n@@ -479,1 +479,1 @@\n-  if (!UsePerfData) return NULL;\n+  if (!UsePerfData) return nullptr;\n@@ -514,1 +514,1 @@\n-  if (pd == NULL)\n+  if (pd == nullptr)\n@@ -527,1 +527,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -534,1 +534,1 @@\n-  assert(copy != NULL, \"just checking\");\n+  assert(copy != nullptr, \"just checking\");\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -310,1 +310,1 @@\n-    inline bool is_valid() { return _valuep != NULL; }\n+    inline bool is_valid() { return _valuep != nullptr; }\n@@ -607,1 +607,1 @@\n-    \/\/ or NULL if it doesn't exist.\n+    \/\/ or null if it doesn't exist.\n@@ -612,1 +612,1 @@\n-    bool contains(const char* name) { return find_by_name(name) != NULL; }\n+    bool contains(const char* name) { return find_by_name(name) != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  if (_all != NULL) {\n+  if (_all != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/perfData.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,3 @@\n-char*                    PerfMemory::_start = NULL;\n-char*                    PerfMemory::_end = NULL;\n-char*                    PerfMemory::_top = NULL;\n+char*                    PerfMemory::_start = nullptr;\n+char*                    PerfMemory::_end = nullptr;\n+char*                    PerfMemory::_top = nullptr;\n@@ -55,1 +55,1 @@\n-PerfDataPrologue*        PerfMemory::_prologue = NULL;\n+PerfDataPrologue*        PerfMemory::_prologue = nullptr;\n@@ -109,1 +109,1 @@\n-  if (_start == NULL) {\n+  if (_start == nullptr) {\n@@ -139,1 +139,1 @@\n-  assert(_prologue != NULL, \"prologue pointer must be initialized\");\n+  assert(_prologue != nullptr, \"prologue pointer must be initialized\");\n@@ -166,1 +166,1 @@\n-  if (_start != NULL && _prologue->overflow != 0) {\n+  if (_start != nullptr && _prologue->overflow != 0) {\n@@ -191,1 +191,1 @@\n-  if (_start != NULL) {\n+  if (_start != nullptr) {\n@@ -209,1 +209,1 @@\n-  if (!UsePerfData) return NULL;\n+  if (!UsePerfData) return nullptr;\n@@ -220,1 +220,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-  char* dest_file = NULL;\n+  char* dest_file = nullptr;\n@@ -248,1 +248,1 @@\n-  if (PerfDataSaveFile != NULL) {\n+  if (PerfDataSaveFile != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-      return ((_start != NULL) && (addr >= _start) && (addr < _end));\n+      return ((_start != nullptr) && (addr >= _start) && (addr < _end));\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {\n+  if (mirror == nullptr || java_lang_Class::is_primitive(mirror)) {\n@@ -63,2 +63,2 @@\n-  const char * source_file = NULL;\n-  Klass* caller = NULL;\n+  const char * source_file = nullptr;\n+  Klass* caller = nullptr;\n@@ -78,1 +78,1 @@\n-      if (s != NULL) {\n+      if (s != nullptr) {\n@@ -83,1 +83,1 @@\n-  if (caller != NULL) {\n+  if (caller != nullptr) {\n@@ -87,1 +87,1 @@\n-    if (source_file != NULL) {\n+    if (source_file != nullptr) {\n@@ -98,1 +98,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -105,1 +105,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -113,1 +113,1 @@\n-  if (box == NULL) {\n+  if (box == nullptr) {\n@@ -277,1 +277,1 @@\n-      if (obj != NULL) {\n+      if (obj != nullptr) {\n@@ -336,1 +336,1 @@\n-  if (element_mirror == NULL) {\n+  if (element_mirror == nullptr) {\n@@ -359,1 +359,1 @@\n-  if (element_mirror == NULL) {\n+  if (element_mirror == nullptr) {\n@@ -446,1 +446,1 @@\n-  if ((current_class == NULL) ||\n+  if ((current_class == nullptr) ||\n@@ -495,1 +495,1 @@\n-    assert(package_to != NULL, \"can not obtain new_class' package\");\n+    assert(package_to != nullptr, \"can not obtain new_class' package\");\n@@ -533,2 +533,2 @@\n-  char * msg = NULL;\n-  if (result != OTHER_PROBLEM && new_class != NULL && current_class != NULL) {\n+  char * msg = nullptr;\n+  if (result != OTHER_PROBLEM && new_class != nullptr && current_class != nullptr) {\n@@ -541,1 +541,1 @@\n-    ModuleEntry* module_to = NULL;\n+    ModuleEntry* module_to = nullptr;\n@@ -558,1 +558,1 @@\n-        assert(jlm != NULL, \"Null jlm in module_to ModuleEntry\");\n+        assert(jlm != nullptr, \"Null jlm in module_to ModuleEntry\");\n@@ -570,1 +570,1 @@\n-      assert(new_class->package() != NULL,\n+      assert(new_class->package() != nullptr,\n@@ -585,1 +585,1 @@\n-        assert(jlm != NULL, \"Null jlm in module_from ModuleEntry\");\n+        assert(jlm != nullptr, \"Null jlm in module_from ModuleEntry\");\n@@ -621,1 +621,1 @@\n-  if ((current_class == NULL) ||\n+  if ((current_class == nullptr) ||\n@@ -751,1 +751,1 @@\n-    } else if (return_type != NULL) {\n+    } else if (return_type != nullptr) {\n@@ -784,1 +784,1 @@\n-  oop return_type_oop = NULL;\n+  oop return_type_oop = nullptr;\n@@ -786,1 +786,1 @@\n-  if (parameter_types.is_null() || return_type_oop == NULL) return NULL;\n+  if (parameter_types.is_null() || return_type_oop == nullptr) return nullptr;\n@@ -796,1 +796,1 @@\n-  if (name == NULL) return NULL;\n+  if (name == nullptr) return nullptr;\n@@ -810,1 +810,1 @@\n-  if (method->generic_signature() != NULL) {\n+  if (method->generic_signature() != nullptr) {\n@@ -833,2 +833,2 @@\n-  objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);\n-  if (parameter_types.is_null()) return NULL;\n+  objArrayHandle parameter_types = get_parameter_types(method, parameter_count, nullptr, CHECK_NULL);\n+  if (parameter_types.is_null()) return nullptr;\n@@ -849,1 +849,1 @@\n-  if (method->generic_signature() != NULL) {\n+  if (method->generic_signature() != nullptr) {\n@@ -896,1 +896,1 @@\n-  if(NULL != sym) {\n+  if(nullptr != sym) {\n@@ -900,1 +900,1 @@\n-    java_lang_reflect_Parameter::set_name(rh(), NULL);\n+    java_lang_reflect_Parameter::set_name(rh(), nullptr);\n@@ -1097,1 +1097,1 @@\n-      if (arg != NULL) {\n+      if (arg != nullptr) {\n@@ -1156,1 +1156,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -1173,1 +1173,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  if (!_klass->is_interface() && _klass->super() != NULL) {\n+  if (!_klass->is_interface() && _klass->super() != nullptr) {\n@@ -54,1 +54,1 @@\n-  } else if (_walk_defaults && (_defaults_checked == false)  && (_base_klass->default_methods() != NULL)) {\n+  } else if (_walk_defaults && (_defaults_checked == false)  && (_base_klass->default_methods() != nullptr)) {\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-  bool in_cont()        const { return _chunk() != NULL; } \/\/ Whether we are currently on the hstack; if true, frames are relativized\n+  bool in_cont()        const { return _chunk() != nullptr; } \/\/ Whether we are currently on the hstack; if true, frames are relativized\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-  set_code_array(NULL);\n+  set_code_array(nullptr);\n@@ -132,1 +132,1 @@\n-  set_compressed_line_number_table(NULL);\n+  set_compressed_line_number_table(nullptr);\n@@ -176,1 +176,1 @@\n-  assert(_changes != NULL, \"changes vector must be initialized\");\n+  assert(_changes != nullptr, \"changes vector must be initialized\");\n@@ -504,1 +504,1 @@\n-          if (new_data == NULL) {\n+          if (new_data == nullptr) {\n@@ -520,1 +520,1 @@\n-              frame_addr, new_offset_delta, NULL);\n+              frame_addr, new_offset_delta, nullptr);\n@@ -542,1 +542,1 @@\n-      if (ff != NULL) {\n+      if (ff != nullptr) {\n@@ -577,1 +577,1 @@\n-  if (code_array() != NULL) {\n+  if (code_array() != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/relocator.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  int  instruction_length_at(int bci)             { return Bytecodes::length_at(NULL, code_array() + bci); }\n+  int  instruction_length_at(int bci)             { return Bytecodes::length_at(nullptr, code_array() + bci); }\n@@ -122,1 +122,1 @@\n-    if (_listener != NULL)\n+    if (_listener != nullptr)\n","filename":"src\/hotspot\/share\/runtime\/relocator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-  while (tmp_tss != NULL) {\n+  while (tmp_tss != nullptr) {\n@@ -231,1 +231,1 @@\n-  ThreadSafepointState *tss_head = NULL;\n+  ThreadSafepointState *tss_head = nullptr;\n@@ -235,1 +235,1 @@\n-    assert(cur_tss->get_next() == NULL, \"Must be NULL\");\n+    assert(cur_tss->get_next() == nullptr, \"Must be nullptr\");\n@@ -243,1 +243,1 @@\n-  *p_prev = NULL;\n+  *p_prev = nullptr;\n@@ -251,1 +251,1 @@\n-    assert(tss_head == NULL, \"Must be empty\");\n+    assert(tss_head == nullptr, \"Must be empty\");\n@@ -266,1 +266,1 @@\n-    while (cur_tss != NULL) {\n+    while (cur_tss != nullptr) {\n@@ -270,1 +270,1 @@\n-        *p_prev = NULL;\n+        *p_prev = nullptr;\n@@ -273,1 +273,1 @@\n-        tmp->set_next(NULL);\n+        tmp->set_next(nullptr);\n@@ -290,1 +290,1 @@\n-  assert(tss_head == NULL, \"Must be empty\");\n+  assert(tss_head == nullptr, \"Must be empty\");\n@@ -601,1 +601,1 @@\n-  assert(heap != NULL, \"heap not initialized yet?\");\n+  assert(heap != nullptr, \"heap not initialized yet?\");\n@@ -604,1 +604,1 @@\n-  if (cleanup_workers != NULL) {\n+  if (cleanup_workers != nullptr) {\n@@ -687,1 +687,1 @@\n-  assert(thread != NULL, \"thread must be set\");\n+  assert(thread != nullptr, \"thread must be set\");\n@@ -808,1 +808,1 @@\n-    _safepoint_id(SafepointSynchronize::InactiveSafepointCounter), _next(NULL) {\n+    _safepoint_id(SafepointSynchronize::InactiveSafepointCounter), _next(nullptr) {\n@@ -819,1 +819,1 @@\n-    thread->set_safepoint_state(NULL);\n+    thread->set_safepoint_state(nullptr);\n@@ -896,1 +896,1 @@\n-  assert(cb != NULL && cb->is_compiled(), \"return address should be in nmethod\");\n+  assert(cb != nullptr && cb->is_compiled(), \"return address should be in nmethod\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-DEBUG_ONLY(JavaThread* ServiceThread::_instance = NULL;)\n-JvmtiDeferredEvent* ServiceThread::_jvmti_event = NULL;\n+DEBUG_ONLY(JavaThread* ServiceThread::_instance = nullptr;)\n+JvmtiDeferredEvent* ServiceThread::_jvmti_event = nullptr;\n@@ -154,1 +154,1 @@\n-      _jvmti_event = NULL;  \/\/ reset\n+      _jvmti_event = nullptr;  \/\/ reset\n@@ -206,1 +206,1 @@\n-  assert(_instance != NULL, \"cannot enqueue events before the service thread runs\");\n+  assert(_instance != nullptr, \"cannot enqueue events before the service thread runs\");\n@@ -215,1 +215,1 @@\n-  if (_jvmti_event != NULL) {\n+  if (_jvmti_event != nullptr) {\n@@ -225,2 +225,2 @@\n-  if (cf != NULL) {\n-    if (_jvmti_event != NULL) {\n+  if (cf != nullptr) {\n+    if (_jvmti_event != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -562,1 +562,1 @@\n-  current->set_exception_pc(NULL);\n+  current->set_exception_pc(nullptr);\n@@ -571,2 +571,2 @@\n-  CompiledMethod* nm = (blob != NULL) ? blob->as_compiled_method_or_null() : NULL;\n-  if (nm != NULL) {\n+  CompiledMethod* nm = (blob != nullptr) ? blob->as_compiled_method_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -606,1 +606,1 @@\n-  if (blob != NULL && blob->is_upcall_stub()) {\n+  if (blob != nullptr && blob->is_upcall_stub()) {\n@@ -616,2 +616,2 @@\n-  guarantee(blob == NULL || !blob->is_runtime_stub(), \"caller should have skipped stub\");\n-  guarantee(!VtableStubs::contains(return_address), \"NULL exceptions in vtables should have been handled already!\");\n+  guarantee(blob == nullptr || !blob->is_runtime_stub(), \"caller should have skipped stub\");\n+  guarantee(!VtableStubs::contains(return_address), \"null exceptions in vtables should have been handled already!\");\n@@ -629,1 +629,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -644,1 +644,1 @@\n-  guarantee(cb != NULL && cb->is_compiled(), \"safepoint polling: pc must refer to an nmethod\");\n+  guarantee(cb != nullptr && cb->is_compiled(), \"safepoint polling: pc must refer to an nmethod\");\n@@ -661,1 +661,1 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -665,1 +665,1 @@\n-    assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != nullptr,\n@@ -669,1 +669,1 @@\n-    assert(SharedRuntime::polling_page_safepoint_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_safepoint_handler_blob() != nullptr,\n@@ -694,1 +694,1 @@\n-    if (trap_mdo != NULL) {\n+    if (trap_mdo != nullptr) {\n@@ -699,2 +699,2 @@\n-        ProfileData* pdata = trap_mdo->allocate_bci_to_data(bci, NULL);\n-        if (pdata != NULL && pdata->is_BitData()) {\n+        ProfileData* pdata = trap_mdo->allocate_bci_to_data(bci, nullptr);\n+        if (pdata != nullptr && pdata->is_BitData()) {\n@@ -738,1 +738,1 @@\n-  assert(cm != NULL, \"must exist\");\n+  assert(cm != nullptr, \"must exist\");\n@@ -747,1 +747,1 @@\n-    if (t != NULL) {\n+    if (t != nullptr) {\n@@ -794,1 +794,1 @@\n-        if (sd != NULL) {\n+        if (sd != nullptr) {\n@@ -799,1 +799,1 @@\n-    } while (recursive_exception || (!top_frame_only && handler_bci < 0 && sd != NULL));\n+    } while (recursive_exception || (!top_frame_only && handler_bci < 0 && sd != nullptr));\n@@ -807,1 +807,1 @@\n-  if (t == NULL && (nm->is_compiled_by_c1() || handler_bci != -1)) {\n+  if (t == nullptr && (nm->is_compiled_by_c1() || handler_bci != -1)) {\n@@ -818,2 +818,2 @@\n-  if (t == NULL && nm->is_compiled_by_c1()) {\n-    assert(nm->unwind_handler_begin() != NULL, \"\");\n+  if (t == nullptr && nm->is_compiled_by_c1()) {\n+    assert(nm->unwind_handler_begin() != nullptr, \"\");\n@@ -824,1 +824,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -835,1 +835,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -856,1 +856,1 @@\n-  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -862,1 +862,1 @@\n-  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -900,1 +900,1 @@\n-  address target_pc = NULL;\n+  address target_pc = nullptr;\n@@ -922,1 +922,1 @@\n-        assert(current->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n+        assert(current->deopt_mark() == nullptr, \"no stack overflow from deopt blob\/uncommon trap\");\n@@ -935,2 +935,2 @@\n-          \/\/ If vt_stub is NULL, then return NULL to signal handler to report the SEGV error.\n-          if (vt_stub == NULL) return NULL;\n+          \/\/ If vt_stub is null, then return null to signal handler to report the SEGV error.\n+          if (vt_stub == nullptr) return nullptr;\n@@ -955,2 +955,2 @@\n-          \/\/ If code blob is NULL, then return NULL to signal handler to report the SEGV error.\n-          if (cb == NULL) return NULL;\n+          \/\/ If code blob is null, then return null to signal handler to report the SEGV error.\n+          if (cb == nullptr) return nullptr;\n@@ -967,1 +967,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -995,1 +995,1 @@\n-          \/\/ If there's an unexpected fault, target_pc might be NULL,\n+          \/\/ If there's an unexpected fault, target_pc might be null,\n@@ -1006,1 +1006,1 @@\n-        guarantee(cm != NULL, \"must have containing compiled method for implicit division-by-zero exceptions\");\n+        guarantee(cm != nullptr, \"must have containing compiled method for implicit division-by-zero exceptions\");\n@@ -1011,1 +1011,1 @@\n-        \/\/ If there's an unexpected fault, target_pc might be NULL,\n+        \/\/ If there's an unexpected fault, target_pc might be null,\n@@ -1039,1 +1039,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1079,2 +1079,2 @@\n-  assert(thread != NULL, \"No thread\");\n-  if (thread == NULL) {\n+  assert(thread != nullptr, \"No thread\");\n+  if (thread == nullptr) {\n@@ -1086,1 +1086,1 @@\n-  return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);\n+  return (obj == nullptr) ? 0 : java_lang_Thread::thread_id(obj);\n@@ -1166,1 +1166,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1248,1 +1248,1 @@\n-      if (callee == NULL) {\n+      if (callee == nullptr) {\n@@ -1277,1 +1277,1 @@\n-    Klass* rk = NULL;\n+    Klass* rk = nullptr;\n@@ -1371,1 +1371,1 @@\n-  if (callee != NULL) {\n+  if (callee != nullptr) {\n@@ -1375,1 +1375,1 @@\n-  if (callee != NULL && !callee->is_in_use()) {\n+  if (callee != nullptr && !callee->is_in_use()) {\n@@ -1377,1 +1377,1 @@\n-    callee = NULL;\n+    callee = nullptr;\n@@ -1380,1 +1380,1 @@\n-  address dest_entry_point = callee == NULL ? 0 : callee->entry_point(); \/\/ used below\n+  address dest_entry_point = callee == nullptr ? 0 : callee->entry_point(); \/\/ used below\n@@ -1388,1 +1388,1 @@\n-    Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n+    Klass* klass = invoke_code == Bytecodes::_invokehandle ? nullptr : receiver->klass();\n@@ -1410,1 +1410,1 @@\n-        (callee == NULL || (callee->is_in_use() && callee_method->code() == callee))) {\n+        (callee == nullptr || (callee->is_in_use() && callee_method->code() == callee))) {\n@@ -1416,1 +1416,1 @@\n-        assert((cb != NULL) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n+        assert((cb != nullptr) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n@@ -1431,1 +1431,1 @@\n-            callee != NULL && callee->is_compiled_by_jvmci()) {\n+            callee != nullptr && callee->is_compiled_by_jvmci()) {\n@@ -1457,1 +1457,1 @@\n-  guarantee(caller_cb != NULL && caller_cb->is_compiled(), \"must be called from compiled method\");\n+  guarantee(caller_cb != nullptr && caller_cb->is_compiled(), \"must be called from compiled method\");\n@@ -1461,2 +1461,2 @@\n-  \/\/ note: a) receiver is NULL for static calls\n-  \/\/       b) an exception is thrown if receiver is NULL for non-static calls\n+  \/\/ note: a) receiver is null for static calls\n+  \/\/       b) an exception is thrown if receiver is null for non-static calls\n@@ -1563,1 +1563,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n@@ -1591,1 +1591,1 @@\n-    guarantee(callee != NULL && callee->is_method(), \"bad handshake\");\n+    guarantee(callee != nullptr && callee->is_method(), \"bad handshake\");\n@@ -1593,1 +1593,1 @@\n-    current->set_callee_target(NULL);\n+    current->set_callee_target(nullptr);\n@@ -1617,1 +1617,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n@@ -1647,1 +1647,1 @@\n-      Klass *recv_klass = (recv != NULL) ? recv->klass() : NULL;\n+      Klass *recv_klass = (recv != nullptr) ? recv->klass() : nullptr;\n@@ -1672,1 +1672,1 @@\n-      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+      enter_special = caller.cb() != nullptr && caller.cb()->is_compiled()\n@@ -1689,1 +1689,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n@@ -1702,1 +1702,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n@@ -1716,1 +1716,1 @@\n-  assert(callee_method->verified_code_entry() != NULL, \" Jump to zero!\");\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n@@ -1742,1 +1742,1 @@\n-    if (ic_oop != NULL) {\n+    if (ic_oop != nullptr) {\n@@ -1753,1 +1753,1 @@\n-        \/\/ We can't assert for callee_method->code() != NULL because it\n+        \/\/ We can't assert for callee_method->code() != nullptr because it\n@@ -1806,1 +1806,1 @@\n-  \/\/ receiver is NULL for static calls. An exception is thrown for NULL\n+  \/\/ receiver is null for static calls. An exception is thrown for null\n@@ -1957,1 +1957,1 @@\n-    address call_addr = NULL;\n+    address call_addr = nullptr;\n@@ -1968,1 +1968,1 @@\n-    if (call_addr != NULL) {\n+    if (call_addr != nullptr) {\n@@ -2064,1 +2064,1 @@\n-    if (callee != NULL && (callee == cb || callee->is_adapter_blob())) {\n+    if (callee != nullptr && (callee == cb || callee->is_adapter_blob())) {\n@@ -2116,1 +2116,1 @@\n-  if (callee == NULL) {\n+  if (callee == nullptr) {\n@@ -2121,1 +2121,1 @@\n-  if (cb == NULL || !cb->is_compiled() || callee->is_unloading()) {\n+  if (cb == nullptr || !cb->is_compiled() || callee->is_unloading()) {\n@@ -2138,2 +2138,2 @@\n-  \/\/ call site with the same old data. clear_code will set code() to NULL\n-  \/\/ at the end of it. If we happen to see that NULL then we can skip trying\n+  \/\/ call site with the same old data. clear_code will set code() to null\n+  \/\/ at the end of it. If we happen to see that null then we can skip trying\n@@ -2141,1 +2141,1 @@\n-  \/\/ from_compiled_entry and the NULL isn't present yet then we lose the race\n+  \/\/ from_compiled_entry and the nullptr isn't present yet then we lose the race\n@@ -2144,1 +2144,1 @@\n-  if (moop->code() == NULL) return;\n+  if (moop->code() == nullptr) return;\n@@ -2197,1 +2197,1 @@\n-  if (src == NULL || dest == NULL) {\n+  if (src == nullptr || dest == nullptr) {\n@@ -2223,2 +2223,2 @@\n-  Symbol* target_klass_name = NULL;\n-  if (target_klass == NULL) {\n+  Symbol* target_klass_name = nullptr;\n+  if (target_klass == nullptr) {\n@@ -2238,2 +2238,2 @@\n-  assert(target_klass != NULL || target_klass_name != NULL, \"one must be provided\");\n-  const char* target_name = target_klass == NULL ? target_klass_name->as_klass_external_name() :\n+  assert(target_klass != nullptr || target_klass_name != nullptr, \"one must be provided\");\n+  const char* target_name = target_klass == nullptr ? target_klass_name->as_klass_external_name() :\n@@ -2247,1 +2247,1 @@\n-  if (target_klass != NULL && caster_klass->module() == target_klass->module()) {\n+  if (target_klass != nullptr && caster_klass->module() == target_klass->module()) {\n@@ -2251,2 +2251,2 @@\n-    target_klass_description = (target_klass != NULL) ? target_klass->class_in_module_of_loader() : \"\";\n-    klass_separator = (target_klass != NULL) ? \"; \" : \"\";\n+    target_klass_description = (target_klass != nullptr) ? target_klass->class_in_module_of_loader() : \"\";\n+    klass_separator = (target_klass != nullptr) ? \"; \" : \"\";\n@@ -2259,1 +2259,1 @@\n-  if (message == NULL) {\n+  if (message == nullptr) {\n@@ -2329,1 +2329,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='SharedRuntime'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='SharedRuntime'\");\n@@ -2366,1 +2366,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -2385,2 +2385,2 @@\n-    Method* method = (nm == NULL) ? NULL : nm->method();\n-    if (method != NULL) {\n+    Method* method = (nm == nullptr) ? nullptr : nm->method();\n+    if (method != nullptr) {\n@@ -2720,6 +2720,6 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = nullptr;\n@@ -2727,1 +2727,1 @@\n-BufferBlob* AdapterHandlerLibrary::_buffer = NULL;\n+BufferBlob* AdapterHandlerLibrary::_buffer = nullptr;\n@@ -2754,5 +2754,5 @@\n-  AdapterBlob* no_arg_blob = NULL;\n-  AdapterBlob* int_arg_blob = NULL;\n-  AdapterBlob* obj_arg_blob = NULL;\n-  AdapterBlob* obj_int_arg_blob = NULL;\n-  AdapterBlob* obj_obj_arg_blob = NULL;\n+  AdapterBlob* no_arg_blob = nullptr;\n+  AdapterBlob* int_arg_blob = nullptr;\n+  AdapterBlob* obj_arg_blob = nullptr;\n+  AdapterBlob* obj_int_arg_blob = nullptr;\n+  AdapterBlob* obj_obj_arg_blob = nullptr;\n@@ -2768,1 +2768,1 @@\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, nullptr),\n@@ -2773,1 +2773,1 @@\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, NULL, true);\n+    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr, true);\n@@ -2787,5 +2787,5 @@\n-    assert(no_arg_blob != NULL &&\n-          obj_arg_blob != NULL &&\n-          int_arg_blob != NULL &&\n-          obj_int_arg_blob != NULL &&\n-          obj_obj_arg_blob != NULL, \"Initial adapters must be properly created\");\n+    assert(no_arg_blob != nullptr &&\n+          obj_arg_blob != nullptr &&\n+          int_arg_blob != nullptr &&\n+          obj_int_arg_blob != nullptr &&\n+          obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n@@ -2848,1 +2848,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2901,1 +2901,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -2906,1 +2906,1 @@\n-  AdapterBlob* new_adapter = NULL;\n+  AdapterBlob* new_adapter = nullptr;\n@@ -2921,1 +2921,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -2924,1 +2924,1 @@\n-        AdapterBlob* comparison_blob = NULL;\n+        AdapterBlob* comparison_blob = nullptr;\n@@ -2926,1 +2926,1 @@\n-        assert(comparison_blob == NULL, \"no blob should be created when creating an adapter for comparison\");\n+        assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n@@ -2939,1 +2939,1 @@\n-  if (new_adapter != NULL) {\n+  if (new_adapter != nullptr) {\n@@ -2954,1 +2954,1 @@\n-  bool contains_all_checks = StubRoutines::code2() != NULL;\n+  bool contains_all_checks = StubRoutines::code2() != nullptr;\n@@ -2988,1 +2988,1 @@\n-  if (new_adapter == NULL) {\n+  if (new_adapter == nullptr) {\n@@ -2992,1 +2992,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3006,1 +3006,1 @@\n-      if (first_pc != NULL) {\n+      if (first_pc != nullptr) {\n@@ -3026,4 +3026,4 @@\n-  if (base == NULL)  base = _c2i_entry;\n-  assert(base <= _c2i_entry || _c2i_entry == NULL, \"\");\n-  assert(base <= _c2i_unverified_entry || _c2i_unverified_entry == NULL, \"\");\n-  assert(base <= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, \"\");\n+  if (base == nullptr)  base = _c2i_entry;\n+  assert(base <= _c2i_entry || _c2i_entry == nullptr, \"\");\n+  assert(base <= _c2i_unverified_entry || _c2i_unverified_entry == nullptr, \"\");\n+  assert(base <= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == nullptr, \"\");\n@@ -3035,1 +3035,1 @@\n-  assert(old_base != NULL, \"\");\n+  assert(old_base != nullptr, \"\");\n@@ -3037,1 +3037,1 @@\n-  if (_i2c_entry != NULL)\n+  if (_i2c_entry != nullptr)\n@@ -3039,1 +3039,1 @@\n-  if (_c2i_entry != NULL)\n+  if (_c2i_entry != nullptr)\n@@ -3041,1 +3041,1 @@\n-  if (_c2i_unverified_entry != NULL)\n+  if (_c2i_unverified_entry != nullptr)\n@@ -3043,1 +3043,1 @@\n-  if (_c2i_no_clinit_check_entry != NULL)\n+  if (_c2i_no_clinit_check_entry != nullptr)\n@@ -3069,1 +3069,1 @@\n-  assert(_saved_code != NULL && other->_saved_code != NULL, \"code not saved\");\n+  assert(_saved_code != nullptr && other->_saved_code != nullptr, \"code not saved\");\n@@ -3088,1 +3088,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -3101,1 +3101,1 @@\n-    if (method->code() != NULL) {\n+    if (method->code() != nullptr) {\n@@ -3111,1 +3111,1 @@\n-    if (buf != NULL) {\n+    if (buf != nullptr) {\n@@ -3152,1 +3152,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -3171,1 +3171,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -3289,1 +3289,1 @@\n-    if (kptr->obj() != NULL) active_monitor_count++;\n+    if (kptr->obj() != nullptr) active_monitor_count++;\n@@ -3313,1 +3313,1 @@\n-    if (kptr2->obj() != NULL) {         \/\/ Avoid 'holes' in the monitor array\n+    if (kptr2->obj() != nullptr) {         \/\/ Avoid 'holes' in the monitor array\n@@ -3375,1 +3375,1 @@\n-  if (get_i2c_entry() != NULL) {\n+  if (get_i2c_entry() != nullptr) {\n@@ -3378,1 +3378,1 @@\n-  if (get_c2i_entry() != NULL) {\n+  if (get_c2i_entry() != nullptr) {\n@@ -3381,1 +3381,1 @@\n-  if (get_c2i_unverified_entry() != NULL) {\n+  if (get_c2i_unverified_entry() != nullptr) {\n@@ -3384,1 +3384,1 @@\n-  if (get_c2i_no_clinit_check_entry() != NULL) {\n+  if (get_c2i_no_clinit_check_entry() != nullptr) {\n@@ -3408,1 +3408,1 @@\n-  CompiledMethod* nm = NULL;\n+  CompiledMethod* nm = nullptr;\n@@ -3422,1 +3422,1 @@\n-    Method* method = NULL;\n+    Method* method = nullptr;\n@@ -3426,1 +3426,1 @@\n-      if (method != NULL && method->has_reserved_stack_access()) {\n+      if (method != nullptr && method->has_reserved_stack_access()) {\n@@ -3431,1 +3431,1 @@\n-      if (cb != NULL && cb->is_compiled()) {\n+      if (cb != nullptr && cb->is_compiled()) {\n@@ -3436,1 +3436,1 @@\n-        for (ScopeDesc *sd = nm->scope_desc_near(fr.pc()); sd != NULL; sd = sd->sender()) {\n+        for (ScopeDesc *sd = nm->scope_desc_near(fr.pc()); sd != nullptr; sd = sd->sender()) {\n@@ -3438,1 +3438,1 @@\n-          if (method != NULL && method->has_reserved_stack_access()) {\n+          if (method != nullptr && method->has_reserved_stack_access()) {\n@@ -3466,1 +3466,1 @@\n-  if (new_obj == NULL) return;\n+  if (new_obj == nullptr) return;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":146,"deletions":146,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,1 @@\n-    assert(_ic_miss_blob!= NULL, \"oops\");\n+    assert(_ic_miss_blob!= nullptr, \"oops\");\n@@ -224,1 +224,1 @@\n-    assert(_wrong_method_blob!= NULL, \"oops\");\n+    assert(_wrong_method_blob!= nullptr, \"oops\");\n@@ -229,1 +229,1 @@\n-    assert(_wrong_method_abstract_blob!= NULL, \"oops\");\n+    assert(_wrong_method_abstract_blob!= nullptr, \"oops\");\n@@ -239,1 +239,1 @@\n-    assert(_resolve_opt_virtual_call_blob != NULL, \"oops\");\n+    assert(_resolve_opt_virtual_call_blob != nullptr, \"oops\");\n@@ -243,1 +243,1 @@\n-    assert(_resolve_virtual_call_blob != NULL, \"oops\");\n+    assert(_resolve_virtual_call_blob != nullptr, \"oops\");\n@@ -247,1 +247,1 @@\n-    assert(_resolve_static_call_blob != NULL, \"oops\");\n+    assert(_resolve_static_call_blob != nullptr, \"oops\");\n@@ -267,1 +267,1 @@\n-  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = NULL);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = nullptr);\n@@ -318,1 +318,1 @@\n-  static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = NULL);\n+  static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = nullptr);\n@@ -382,1 +382,1 @@\n-  \/\/ NULL is being passed as the second VMRegPair array, so arguments are either\n+  \/\/ null is being passed as the second VMRegPair array, so arguments are either\n@@ -689,1 +689,1 @@\n-                                        address c2i_no_clinit_check_entry = NULL);\n+                                        address c2i_no_clinit_check_entry = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -192,1 +192,1 @@\n-  if (_method == NULL && _param_size > fp_max_size_of_parameters) {\n+  if (_method == nullptr && _param_size > fp_max_size_of_parameters) {\n@@ -209,1 +209,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -307,1 +307,1 @@\n-  \/\/ avoid a number of NULL checks in the parser\n+  \/\/ avoid a number of null checks in the parser\n@@ -309,1 +309,1 @@\n-  _names = NULL;\n+  _names = nullptr;\n@@ -316,1 +316,1 @@\n-    assert(_names == NULL, \"_names unexpectedly created\");\n+    assert(_names == nullptr, \"_names unexpectedly created\");\n@@ -322,1 +322,1 @@\n-  if (_names != NULL) {\n+  if (_names != nullptr) {\n@@ -337,1 +337,1 @@\n-    return (tem == NULL ? limit : tem + 1 - base);\n+    return (tem == nullptr ? limit : tem + 1 - base);\n@@ -349,1 +349,1 @@\n-      return (tem == NULL ? limit : tem + 1 - base);\n+      return (tem == nullptr ? limit : tem + 1 - base);\n@@ -492,1 +492,1 @@\n-    if (_names == NULL) {\n+    if (_names == nullptr) {\n@@ -504,1 +504,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -507,1 +507,1 @@\n-  Klass* k = NULL;\n+  Klass* k = nullptr;\n@@ -509,1 +509,1 @@\n-    \/\/ Note:  SD::resolve_or_null returns NULL for most failure modes,\n+    \/\/ Note:  SD::resolve_or_null returns null for most failure modes,\n@@ -537,2 +537,2 @@\n-  if (klass == NULL) {\n-    return NULL;\n+  if (klass == nullptr) {\n+    return nullptr;\n@@ -556,1 +556,1 @@\n-  initialize_load_origin(NULL);\n+  initialize_load_origin(nullptr);\n@@ -562,1 +562,1 @@\n-  assert(load_origin != NULL, \"\");\n+  assert(load_origin != nullptr, \"\");\n@@ -573,1 +573,1 @@\n-  assert(_load_origin != NULL, \"\");\n+  assert(_load_origin != nullptr, \"\");\n@@ -603,1 +603,1 @@\n-  if (method_sig != NULL && len > 1 && method_sig[index] == JVM_SIGNATURE_FUNC) {\n+  if (method_sig != nullptr && len > 1 && method_sig[index] == JVM_SIGNATURE_FUNC) {\n@@ -625,1 +625,1 @@\n-  return (type_sig != NULL && len >= 1 &&\n+  return (type_sig != nullptr && len >= 1 &&\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -362,1 +362,1 @@\n-      _method(NULL) {\n+      _method(nullptr) {\n@@ -578,1 +578,1 @@\n-    _handles_cached = (load_origin == NULL);\n+    _handles_cached = (load_origin == nullptr);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  const ImmutableOopMap* oopmap() const { if (_oopmap == NULL) get_oopmap(); return _oopmap; }\n+  const ImmutableOopMap* oopmap() const { if (_oopmap == nullptr) get_oopmap(); return _oopmap; }\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    if (chunk != NULL && chunk->has_bitmap()) {\n+    if (chunk != nullptr && chunk->has_bitmap()) {\n@@ -70,2 +70,2 @@\n-      \/\/ The narrow_oop_base could be NULL or be the address\n-      \/\/ of the page below heap. Use NULL value for both cases.\n+      \/\/ The narrow_oop_base could be null or be the address\n+      \/\/ of the page below heap. Use null value for both cases.\n@@ -77,1 +77,1 @@\n-  if (chunk != NULL) {\n+  if (chunk != nullptr) {\n@@ -102,1 +102,1 @@\n-  if (chunk != NULL) {\n+  if (chunk != nullptr) {\n@@ -114,1 +114,1 @@\n-         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+         p2i(addr), chunk != nullptr, chunk != nullptr && chunk->has_bitmap() && UseCompressedOops);\n@@ -122,1 +122,1 @@\n-         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+         p2i(addr), chunk != nullptr, chunk != nullptr && chunk->has_bitmap() && UseCompressedOops);\n@@ -244,1 +244,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -248,1 +248,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -259,1 +259,1 @@\n-    assert(value_addr == NULL || reg_map->thread() == NULL || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n+    assert(value_addr == nullptr || reg_map->thread() == nullptr || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n@@ -267,1 +267,1 @@\n-  assert(value_addr == NULL || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != NULL && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n+  assert(value_addr == nullptr || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != nullptr && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n@@ -295,1 +295,1 @@\n-      if (_handle_value() != NULL) {\n+      if (_handle_value() != nullptr) {\n@@ -298,1 +298,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,1 @@\n-    _next(NULL),\n+    _next(nullptr),\n@@ -166,1 +166,1 @@\n-    _iterator(NULL),\n+    _iterator(nullptr),\n@@ -219,1 +219,1 @@\n-    _iterator = NULL;\n+    _iterator = nullptr;\n@@ -231,1 +231,1 @@\n-  if (_iterator != NULL && _iterator->has_next()) {\n+  if (_iterator != nullptr && _iterator->has_next()) {\n@@ -246,1 +246,1 @@\n-    start_processing_impl(NULL \/* context *\/);\n+    start_processing_impl(nullptr \/* context *\/);\n@@ -248,1 +248,1 @@\n-    _iterator->process_one(NULL \/* context *\/);\n+    _iterator->process_one(nullptr \/* context *\/);\n@@ -302,1 +302,1 @@\n-    watermark->finish_processing(NULL \/* context *\/);\n+    watermark->finish_processing(nullptr \/* context *\/);\n@@ -319,1 +319,1 @@\n-      start_processing_impl(NULL \/* context *\/);\n+      start_processing_impl(nullptr \/* context *\/);\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    _head(NULL) {}\n+    _head(nullptr) {}\n@@ -44,1 +44,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -84,1 +84,1 @@\n-  for (StackWatermark* current = head(jt); current != NULL; current = current->next()) {\n+  for (StackWatermark* current = head(jt); current != nullptr; current = current->next()) {\n@@ -93,1 +93,1 @@\n-  for (StackWatermark* current = head(jt); current != NULL; current = current->next()) {\n+  for (StackWatermark* current = head(jt); current != nullptr; current = current->next()) {\n@@ -105,1 +105,1 @@\n-  for (StackWatermark* current = head(jt); current != NULL; current = current->next()) {\n+  for (StackWatermark* current = head(jt); current != nullptr; current = current->next()) {\n@@ -114,1 +114,1 @@\n-  if (watermark != NULL) {\n+  if (watermark != nullptr) {\n@@ -123,1 +123,1 @@\n-  if (watermark != NULL) {\n+  if (watermark != nullptr) {\n@@ -132,1 +132,1 @@\n-  for (StackWatermark* current = head(jt); current != NULL; current = current->next()) {\n+  for (StackWatermark* current = head(jt); current != nullptr; current = current->next()) {\n@@ -142,1 +142,1 @@\n-  if (watermark != NULL) {\n+  if (watermark != nullptr) {\n@@ -152,1 +152,1 @@\n-  for (StackWatermark* current = head(jt); current != NULL; current = current->next()) {\n+  for (StackWatermark* current = head(jt); current != nullptr; current = current->next()) {\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  for (StackWatermark* stack_watermark = head(jt); stack_watermark != NULL; stack_watermark = stack_watermark->next()) {\n+  for (StackWatermark* stack_watermark = head(jt); stack_watermark != nullptr; stack_watermark = stack_watermark->next()) {\n@@ -38,1 +38,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -47,1 +47,1 @@\n-  return get(jt, kind) != NULL;\n+  return get(jt, kind) != nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-StatSamplerTask*              StatSampler::_task   = NULL;\n-PerfDataList*                 StatSampler::_sampled = NULL;\n+StatSamplerTask*              StatSampler::_task   = nullptr;\n+PerfDataList*                 StatSampler::_sampled = nullptr;\n@@ -110,1 +110,1 @@\n-  _task = NULL;\n+  _task = nullptr;\n@@ -126,1 +126,1 @@\n-  if (_sampled != NULL) {\n+  if (_sampled != nullptr) {\n@@ -128,1 +128,1 @@\n-    _sampled = NULL;\n+    _sampled = nullptr;\n@@ -138,1 +138,1 @@\n-  assert(list != NULL, \"null list unexpected\");\n+  assert(list != nullptr, \"null list unexpected\");\n@@ -164,1 +164,1 @@\n-  \/\/   if (_sampled != NULL) {\n+  \/\/   if (_sampled != nullptr) {\n@@ -166,1 +166,1 @@\n-  \/\/     _sampled = NULL;\n+  \/\/     _sampled = nullptr;\n@@ -171,1 +171,1 @@\n-  assert(_sampled != NULL, \"list not initialized\");\n+  assert(_sampled != nullptr, \"list not initialized\");\n@@ -199,1 +199,1 @@\n-  assert(value_oop != NULL, \"property must have a value\");\n+  assert(value_oop != nullptr, \"property must have a value\");\n@@ -214,1 +214,1 @@\n-  assert(value != NULL, \"property name should be have a value: %s\", name);\n+  assert(value != nullptr, \"property name should be have a value: %s\", name);\n@@ -216,1 +216,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    static bool is_active() { return _task != NULL; }\n+    static bool is_active() { return _task != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/statSampler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-StubCodeDesc* StubCodeDesc::_list = NULL;\n+StubCodeDesc* StubCodeDesc::_list = nullptr;\n@@ -43,1 +43,1 @@\n-  while (p != NULL && !p->contains(pc)) {\n+  while (p != nullptr && !p->contains(pc)) {\n@@ -74,1 +74,1 @@\n-  if (blob != NULL) {\n+  if (blob != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    assert(_end == NULL || begin <= _end, \"begin & end not properly ordered\");\n+    assert(_end == nullptr || begin <= _end, \"begin & end not properly ordered\");\n@@ -71,1 +71,1 @@\n-  static StubCodeDesc* desc_for(address pc);     \/\/ returns the code descriptor for the code containing pc or NULL\n+  static StubCodeDesc* desc_for(address pc);     \/\/ returns the code descriptor for the code containing pc or null\n@@ -73,1 +73,1 @@\n-  StubCodeDesc(const char* group, const char* name, address begin, address end = NULL) {\n+  StubCodeDesc(const char* group, const char* name, address begin, address end = nullptr) {\n@@ -75,1 +75,1 @@\n-    assert(name != NULL, \"no name specified\");\n+    assert(name != nullptr, \"no name specified\");\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-UnsafeCopyMemory* UnsafeCopyMemory::_table                      = NULL;\n+UnsafeCopyMemory* UnsafeCopyMemory::_table                      = nullptr;\n@@ -46,1 +46,1 @@\n-address UnsafeCopyMemory::_common_exit_stub_pc                  = NULL;\n+address UnsafeCopyMemory::_common_exit_stub_pc                  = nullptr;\n@@ -53,3 +53,3 @@\n-BufferBlob* StubRoutines::_code1                                = NULL;\n-BufferBlob* StubRoutines::_code2                                = NULL;\n-BufferBlob* StubRoutines::_code3                                = NULL;\n+BufferBlob* StubRoutines::_code1                                = nullptr;\n+BufferBlob* StubRoutines::_code2                                = nullptr;\n+BufferBlob* StubRoutines::_code3                                = nullptr;\n@@ -57,2 +57,2 @@\n-address StubRoutines::_call_stub_return_address                 = NULL;\n-address StubRoutines::_call_stub_entry                          = NULL;\n+address StubRoutines::_call_stub_return_address                 = nullptr;\n+address StubRoutines::_call_stub_entry                          = nullptr;\n@@ -60,7 +60,7 @@\n-address StubRoutines::_catch_exception_entry                    = NULL;\n-address StubRoutines::_forward_exception_entry                  = NULL;\n-address StubRoutines::_throw_AbstractMethodError_entry          = NULL;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = NULL;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = NULL;\n-address StubRoutines::_throw_StackOverflowError_entry           = NULL;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = NULL;\n+address StubRoutines::_catch_exception_entry                    = nullptr;\n+address StubRoutines::_forward_exception_entry                  = nullptr;\n+address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n+address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n+address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n+address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n+address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -68,6 +68,6 @@\n-address StubRoutines::_verify_oop_subroutine_entry              = NULL;\n-address StubRoutines::_atomic_xchg_entry                        = NULL;\n-address StubRoutines::_atomic_cmpxchg_entry                     = NULL;\n-address StubRoutines::_atomic_cmpxchg_long_entry                = NULL;\n-address StubRoutines::_atomic_add_entry                         = NULL;\n-address StubRoutines::_fence_entry                              = NULL;\n+address StubRoutines::_verify_oop_subroutine_entry              = nullptr;\n+address StubRoutines::_atomic_xchg_entry                        = nullptr;\n+address StubRoutines::_atomic_cmpxchg_entry                     = nullptr;\n+address StubRoutines::_atomic_cmpxchg_long_entry                = nullptr;\n+address StubRoutines::_atomic_add_entry                         = nullptr;\n+address StubRoutines::_fence_entry                              = nullptr;\n@@ -103,2 +103,2 @@\n-address StubRoutines::_data_cache_writeback              = NULL;\n-address StubRoutines::_data_cache_writeback_sync         = NULL;\n+address StubRoutines::_data_cache_writeback              = nullptr;\n+address StubRoutines::_data_cache_writeback_sync         = nullptr;\n@@ -106,4 +106,4 @@\n-address StubRoutines::_checkcast_arraycopy               = NULL;\n-address StubRoutines::_checkcast_arraycopy_uninit        = NULL;\n-address StubRoutines::_unsafe_arraycopy                  = NULL;\n-address StubRoutines::_generic_arraycopy                 = NULL;\n+address StubRoutines::_checkcast_arraycopy               = nullptr;\n+address StubRoutines::_checkcast_arraycopy_uninit        = nullptr;\n+address StubRoutines::_unsafe_arraycopy                  = nullptr;\n+address StubRoutines::_generic_arraycopy                 = nullptr;\n@@ -118,62 +118,62 @@\n-address StubRoutines::_aescrypt_encryptBlock               = NULL;\n-address StubRoutines::_aescrypt_decryptBlock               = NULL;\n-address StubRoutines::_cipherBlockChaining_encryptAESCrypt = NULL;\n-address StubRoutines::_cipherBlockChaining_decryptAESCrypt = NULL;\n-address StubRoutines::_electronicCodeBook_encryptAESCrypt  = NULL;\n-address StubRoutines::_electronicCodeBook_decryptAESCrypt  = NULL;\n-address StubRoutines::_counterMode_AESCrypt                = NULL;\n-address StubRoutines::_galoisCounterMode_AESCrypt          = NULL;\n-address StubRoutines::_ghash_processBlocks                 = NULL;\n-address StubRoutines::_chacha20Block                       = NULL;\n-address StubRoutines::_base64_encodeBlock                  = NULL;\n-address StubRoutines::_base64_decodeBlock                  = NULL;\n-address StubRoutines::_poly1305_processBlocks              = NULL;\n-\n-address StubRoutines::_md5_implCompress      = NULL;\n-address StubRoutines::_md5_implCompressMB    = NULL;\n-address StubRoutines::_sha1_implCompress     = NULL;\n-address StubRoutines::_sha1_implCompressMB   = NULL;\n-address StubRoutines::_sha256_implCompress   = NULL;\n-address StubRoutines::_sha256_implCompressMB = NULL;\n-address StubRoutines::_sha512_implCompress   = NULL;\n-address StubRoutines::_sha512_implCompressMB = NULL;\n-address StubRoutines::_sha3_implCompress     = NULL;\n-address StubRoutines::_sha3_implCompressMB   = NULL;\n-\n-address StubRoutines::_updateBytesCRC32 = NULL;\n-address StubRoutines::_crc_table_adr =    NULL;\n-\n-address StubRoutines::_crc32c_table_addr = NULL;\n-address StubRoutines::_updateBytesCRC32C = NULL;\n-address StubRoutines::_updateBytesAdler32 = NULL;\n-\n-address StubRoutines::_multiplyToLen = NULL;\n-address StubRoutines::_squareToLen = NULL;\n-address StubRoutines::_mulAdd = NULL;\n-address StubRoutines::_montgomeryMultiply = NULL;\n-address StubRoutines::_montgomerySquare = NULL;\n-address StubRoutines::_bigIntegerRightShiftWorker = NULL;\n-address StubRoutines::_bigIntegerLeftShiftWorker = NULL;\n-\n-address StubRoutines::_vectorizedMismatch = NULL;\n-\n-address StubRoutines::_dexp = NULL;\n-address StubRoutines::_dlog = NULL;\n-address StubRoutines::_dlog10 = NULL;\n-address StubRoutines::_dpow = NULL;\n-address StubRoutines::_dsin = NULL;\n-address StubRoutines::_dcos = NULL;\n-address StubRoutines::_dlibm_sin_cos_huge = NULL;\n-address StubRoutines::_dlibm_reduce_pi04l = NULL;\n-address StubRoutines::_dlibm_tan_cot_huge = NULL;\n-address StubRoutines::_dtan = NULL;\n-\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n-\n-address StubRoutines::_cont_thaw          = NULL;\n-address StubRoutines::_cont_returnBarrier = NULL;\n-address StubRoutines::_cont_returnBarrierExc = NULL;\n-\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = NULL;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = NULL;)\n+address StubRoutines::_aescrypt_encryptBlock               = nullptr;\n+address StubRoutines::_aescrypt_decryptBlock               = nullptr;\n+address StubRoutines::_cipherBlockChaining_encryptAESCrypt = nullptr;\n+address StubRoutines::_cipherBlockChaining_decryptAESCrypt = nullptr;\n+address StubRoutines::_electronicCodeBook_encryptAESCrypt  = nullptr;\n+address StubRoutines::_electronicCodeBook_decryptAESCrypt  = nullptr;\n+address StubRoutines::_counterMode_AESCrypt                = nullptr;\n+address StubRoutines::_galoisCounterMode_AESCrypt          = nullptr;\n+address StubRoutines::_ghash_processBlocks                 = nullptr;\n+address StubRoutines::_chacha20Block                       = nullptr;\n+address StubRoutines::_base64_encodeBlock                  = nullptr;\n+address StubRoutines::_base64_decodeBlock                  = nullptr;\n+address StubRoutines::_poly1305_processBlocks              = nullptr;\n+\n+address StubRoutines::_md5_implCompress      = nullptr;\n+address StubRoutines::_md5_implCompressMB    = nullptr;\n+address StubRoutines::_sha1_implCompress     = nullptr;\n+address StubRoutines::_sha1_implCompressMB   = nullptr;\n+address StubRoutines::_sha256_implCompress   = nullptr;\n+address StubRoutines::_sha256_implCompressMB = nullptr;\n+address StubRoutines::_sha512_implCompress   = nullptr;\n+address StubRoutines::_sha512_implCompressMB = nullptr;\n+address StubRoutines::_sha3_implCompress     = nullptr;\n+address StubRoutines::_sha3_implCompressMB   = nullptr;\n+\n+address StubRoutines::_updateBytesCRC32 = nullptr;\n+address StubRoutines::_crc_table_adr =    nullptr;\n+\n+address StubRoutines::_crc32c_table_addr = nullptr;\n+address StubRoutines::_updateBytesCRC32C = nullptr;\n+address StubRoutines::_updateBytesAdler32 = nullptr;\n+\n+address StubRoutines::_multiplyToLen = nullptr;\n+address StubRoutines::_squareToLen = nullptr;\n+address StubRoutines::_mulAdd = nullptr;\n+address StubRoutines::_montgomeryMultiply = nullptr;\n+address StubRoutines::_montgomerySquare = nullptr;\n+address StubRoutines::_bigIntegerRightShiftWorker = nullptr;\n+address StubRoutines::_bigIntegerLeftShiftWorker = nullptr;\n+\n+address StubRoutines::_vectorizedMismatch = nullptr;\n+\n+address StubRoutines::_dexp = nullptr;\n+address StubRoutines::_dlog = nullptr;\n+address StubRoutines::_dlog10 = nullptr;\n+address StubRoutines::_dpow = nullptr;\n+address StubRoutines::_dsin = nullptr;\n+address StubRoutines::_dcos = nullptr;\n+address StubRoutines::_dlibm_sin_cos_huge = nullptr;\n+address StubRoutines::_dlibm_reduce_pi04l = nullptr;\n+address StubRoutines::_dlibm_tan_cot_huge = nullptr;\n+address StubRoutines::_dtan = nullptr;\n+\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+\n+address StubRoutines::_cont_thaw          = nullptr;\n+address StubRoutines::_cont_returnBarrier = nullptr;\n+address StubRoutines::_cont_returnBarrierExc = nullptr;\n+\n+JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n+JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n@@ -211,1 +211,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -215,1 +215,1 @@\n-  if (_code1 == NULL) {\n+  if (_code1 == nullptr) {\n@@ -222,1 +222,1 @@\n-    if (_code1 == NULL) {\n+    if (_code1 == nullptr) {\n@@ -271,1 +271,1 @@\n-  if (_code3 == NULL) {\n+  if (_code3 == nullptr) {\n@@ -275,1 +275,1 @@\n-    if (_code3 == NULL) {\n+    if (_code3 == nullptr) {\n@@ -287,1 +287,1 @@\n-  if (_code2 == NULL) {\n+  if (_code2 == nullptr) {\n@@ -294,1 +294,1 @@\n-    if (_code2 == NULL) {\n+    if (_code2 == nullptr) {\n@@ -323,1 +323,1 @@\n-  if (_##type##_fill != NULL) {                                                              \\\n+  if (_##type##_fill != nullptr) {                                                              \\\n@@ -510,1 +510,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -514,1 +514,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -587,1 +587,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -596,1 +596,1 @@\n-  _ucm_entry = NULL;\n+  _ucm_entry = nullptr;\n@@ -598,1 +598,1 @@\n-    address err_exit_pc = NULL;\n+    address err_exit_pc = nullptr;\n@@ -600,1 +600,1 @@\n-      err_exit_pc = error_exit_pc != NULL ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();\n+      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();\n@@ -602,2 +602,2 @@\n-    assert(err_exit_pc != NULL || continue_at_scope_end, \"error exit not set\");\n-    _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen->assembler()->pc(), NULL, err_exit_pc);\n+    assert(err_exit_pc != nullptr || continue_at_scope_end, \"error exit not set\");\n+    _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n@@ -608,1 +608,1 @@\n-  if (_ucm_entry != NULL) {\n+  if (_ucm_entry != nullptr) {\n@@ -610,1 +610,1 @@\n-    if (_ucm_entry->error_exit_pc() == NULL) {\n+    if (_ucm_entry->error_exit_pc() == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":107,"deletions":107,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-  UnsafeCopyMemory() : _start_pc(NULL), _end_pc(NULL), _error_exit_pc(NULL) {}\n+  UnsafeCopyMemory() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n@@ -120,1 +120,1 @@\n-  UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = NULL);\n+  UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n@@ -273,2 +273,2 @@\n-      (_code1 != NULL && _code1->blob_contains(addr)) ||\n-      (_code2 != NULL && _code2->blob_contains(addr)) ;\n+      (_code1 != nullptr && _code1->blob_contains(addr)) ||\n+      (_code2 != nullptr && _code2->blob_contains(addr)) ;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-  ObjectMonitor* prev = NULL;\n+  ObjectMonitor* prev = nullptr;\n@@ -132,2 +132,2 @@\n-  \/\/ The in-use list head can be NULL during the final audit.\n-  while (m != NULL) {\n+  \/\/ The in-use list head can be null during the final audit.\n+  while (m != nullptr) {\n@@ -146,2 +146,2 @@\n-      } while (next != NULL && next->is_being_async_deflated());\n-      if (prev == NULL) {\n+      } while (next != nullptr && next->is_being_async_deflated());\n+      if (prev == nullptr) {\n@@ -204,1 +204,1 @@\n-  char* bytes = NULL;                                                      \\\n+  char* bytes = nullptr;                                                      \\\n@@ -208,1 +208,1 @@\n-  if (klassname != NULL) {                                                 \\\n+  if (klassname != nullptr) {                                                 \\\n@@ -311,1 +311,1 @@\n-  if (obj == NULL) return false;  \/\/ slow-path for invalid obj\n+  if (obj == nullptr) return false;  \/\/ slow-path for invalid obj\n@@ -325,1 +325,1 @@\n-    if (mon->first_waiter() != NULL) {\n+    if (mon->first_waiter() != nullptr) {\n@@ -338,1 +338,1 @@\n-      } while (mon->first_waiter() != NULL && all);\n+      } while (mon->first_waiter() != nullptr && all);\n@@ -359,1 +359,1 @@\n-  if (obj == NULL) return false;       \/\/ Need to throw NPE\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -372,1 +372,1 @@\n-    if (m->object_peek() == NULL) {\n+    if (m->object_peek() == nullptr) {\n@@ -390,1 +390,1 @@\n-    \/\/ non-NULL so this BasicLock is not seen as recursive nor as\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n@@ -399,1 +399,1 @@\n-    if (owner == NULL && m->try_set_owner_from(NULL, current) == NULL) {\n+    if (owner == nullptr && m->try_set_owner_from(nullptr, current) == nullptr) {\n@@ -435,1 +435,1 @@\n-    if (newline != NULL) {\n+    if (newline != nullptr) {\n@@ -499,1 +499,1 @@\n-      lock->set_displaced_header(markWord::from_pointer(NULL));\n+      lock->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -531,1 +531,1 @@\n-      \/\/ If the displaced header is NULL, then this exit matches up with\n+      \/\/ If the displaced header is null, then this exit matches up with\n@@ -661,1 +661,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -667,1 +667,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -862,1 +862,1 @@\n-    ObjectMonitor* monitor = NULL;\n+    ObjectMonitor* monitor = nullptr;\n@@ -996,1 +996,1 @@\n-  address owner = NULL;\n+  address owner = nullptr;\n@@ -1010,1 +1010,1 @@\n-    assert(monitor != NULL, \"monitor should be non-null\");\n+    assert(monitor != nullptr, \"monitor should be non-null\");\n@@ -1014,2 +1014,2 @@\n-  if (owner != NULL) {\n-    \/\/ owning_thread_from_monitor_owner() may also return NULL here\n+  if (owner != nullptr) {\n+    \/\/ owning_thread_from_monitor_owner() may also return null here\n@@ -1024,1 +1024,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1043,1 +1043,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1068,1 +1068,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1184,1 +1184,1 @@\n-  assert(event != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n@@ -1301,2 +1301,2 @@\n-      \/\/ with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.\n-      m->set_owner_from(NULL, mark.locker());\n+      \/\/ with CAS.  That is, we can avoid the xchg-nullptr .... ST idiom.\n+      m->set_owner_from(nullptr, mark.locker());\n@@ -1336,1 +1336,1 @@\n-    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to current.\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n@@ -1348,1 +1348,1 @@\n-      m = NULL;\n+      m = nullptr;\n@@ -1383,1 +1383,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1396,1 +1396,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1474,1 +1474,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1482,1 +1482,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1503,1 +1503,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1517,1 +1517,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1540,1 +1540,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1684,1 +1684,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1692,1 +1692,1 @@\n-  assert(ls != NULL, \"sanity check\");\n+  assert(ls != nullptr, \"sanity check\");\n@@ -1763,1 +1763,1 @@\n-                  \"have non-NULL _header field.\", p2i(n));\n+                  \"have non-null _header field.\", p2i(n));\n@@ -1767,1 +1767,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1805,2 +1805,2 @@\n-                 mid->is_busy(), mark.hash() != 0, mid->owner() != NULL,\n-                 p2i(obj), obj == NULL ? \"\" : obj->klass()->external_name());\n+                 mid->is_busy(), mark.hash() != 0, mid->owner() != nullptr,\n+                 p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-  bool has_next() const { return _current != NULL; }\n+  bool has_next() const { return _current != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? NULL : PeriodicTask_lock);\n+  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? nullptr : PeriodicTask_lock);\n@@ -98,1 +98,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n@@ -111,1 +111,1 @@\n-  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? NULL : PeriodicTask_lock);\n+  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? nullptr : PeriodicTask_lock);\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-THREAD_LOCAL Thread* Thread::_thr_current = NULL;\n+THREAD_LOCAL Thread* Thread::_thr_current = nullptr;\n@@ -73,1 +73,1 @@\n-DEBUG_ONLY(Thread* Thread::_starting_thread = NULL;)\n+DEBUG_ONLY(Thread* Thread::_starting_thread = nullptr;)\n@@ -80,1 +80,1 @@\n-  set_stack_base(NULL);\n+  set_stack_base(nullptr);\n@@ -86,1 +86,1 @@\n-  set_osthread(NULL);\n+  set_osthread(nullptr);\n@@ -88,2 +88,2 @@\n-  DEBUG_ONLY(_current_resource_mark = NULL;)\n-  set_handle_area(new (mtThread) HandleArea(NULL));\n+  DEBUG_ONLY(_current_resource_mark = nullptr;)\n+  set_handle_area(new (mtThread) HandleArea(nullptr));\n@@ -91,2 +91,2 @@\n-  set_last_handle_mark(NULL);\n-  DEBUG_ONLY(_missed_ic_stub_refill_verifier = NULL);\n+  set_last_handle_mark(nullptr);\n+  DEBUG_ONLY(_missed_ic_stub_refill_verifier = nullptr);\n@@ -96,2 +96,2 @@\n-  _threads_hazard_ptr = NULL;\n-  _threads_list_ptr = NULL;\n+  _threads_hazard_ptr = nullptr;\n+  _threads_list_ptr = nullptr;\n@@ -105,1 +105,1 @@\n-  debug_only(_owned_locks = NULL;)\n+  debug_only(_owned_locks = nullptr;)\n@@ -109,1 +109,1 @@\n-  _current_pending_raw_monitor = NULL;\n+  _current_pending_raw_monitor = nullptr;\n@@ -137,1 +137,1 @@\n-  if (barrier_set != NULL) {\n+  if (barrier_set != nullptr) {\n@@ -144,1 +144,1 @@\n-    assert(Thread::current_or_null() == NULL, \"creating thread before barrier set\");\n+    assert(Thread::current_or_null() == nullptr, \"creating thread before barrier set\");\n@@ -158,1 +158,1 @@\n-  assert(_thr_current == NULL, \"Thread::current already initialized\");\n+  assert(_thr_current == nullptr, \"Thread::current already initialized\");\n@@ -161,1 +161,1 @@\n-  assert(ThreadLocalStorage::thread() == NULL, \"ThreadLocalStorage::thread already initialized\");\n+  assert(ThreadLocalStorage::thread() == nullptr, \"ThreadLocalStorage::thread already initialized\");\n@@ -169,1 +169,1 @@\n-  _thr_current = NULL;\n+  _thr_current = nullptr;\n@@ -171,1 +171,1 @@\n-  ThreadLocalStorage::set_thread(NULL);\n+  ThreadLocalStorage::set_thread(nullptr);\n@@ -202,1 +202,1 @@\n-  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() != nullptr, \"current thread is unset\");\n@@ -229,1 +229,1 @@\n-  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() != nullptr, \"current thread is unset\");\n@@ -242,1 +242,1 @@\n-  assert(Thread::current_or_null() == NULL, \"current thread still present\");\n+  assert(Thread::current_or_null() == nullptr, \"current thread still present\");\n@@ -257,1 +257,1 @@\n-  if (barrier_set != NULL) {\n+  if (barrier_set != nullptr) {\n@@ -265,1 +265,1 @@\n-  assert(last_handle_mark() != NULL, \"check we have an element\");\n+  assert(last_handle_mark() != nullptr, \"check we have an element\");\n@@ -267,1 +267,1 @@\n-  assert(last_handle_mark() == NULL, \"check we have reached the end\");\n+  assert(last_handle_mark() == nullptr, \"check we have reached the end\");\n@@ -270,2 +270,2 @@\n-  \/\/ Set to NULL as a termination indicator for has_terminated().\n-  Atomic::store(&_ParkEvent, (ParkEvent*)NULL);\n+  \/\/ Set to null as a termination indicator for has_terminated().\n+  Atomic::store(&_ParkEvent, (ParkEvent*)nullptr);\n@@ -276,2 +276,2 @@\n-  \/\/ osthread() can be NULL, if creation of thread failed.\n-  if (osthread() != NULL) os::free_thread(osthread());\n+  \/\/ osthread() can be nullptr, if creation of thread failed.\n+  if (osthread() != nullptr) os::free_thread(osthread());\n@@ -318,1 +318,1 @@\n-  if (target->osthread() == NULL || target->osthread()->get_state() <= INITIALIZED) {\n+  if (target->osthread() == nullptr || target->osthread()->get_state() <= INITIALIZED) {\n@@ -360,1 +360,1 @@\n-       stlp != NULL; stlp = stlp->previous()) {\n+       stlp != nullptr; stlp = stlp->previous()) {\n@@ -420,1 +420,1 @@\n-      assert(_cur_thr->processed_thread() == NULL, \"nesting not supported\");\n+      assert(_cur_thr->processed_thread() == nullptr, \"nesting not supported\");\n@@ -423,1 +423,1 @@\n-      _cur_thr = NULL;\n+      _cur_thr = nullptr;\n@@ -429,2 +429,2 @@\n-      assert(_cur_thr->processed_thread() != NULL, \"nesting not supported\");\n-      _cur_thr->set_processed_thread(NULL);\n+      assert(_cur_thr->processed_thread() != nullptr, \"nesting not supported\");\n+      _cur_thr->set_processed_thread(nullptr);\n@@ -444,1 +444,1 @@\n-  if (metadata_handles() != NULL) {\n+  if (metadata_handles() != nullptr) {\n@@ -453,1 +453,1 @@\n-  if (osthread() != NULL) {\n+  if (osthread() != nullptr) {\n@@ -494,1 +494,1 @@\n-  if (os_thr != NULL) {\n+  if (os_thr != nullptr) {\n@@ -518,1 +518,1 @@\n-  if (cur == NULL) {\n+  if (cur == nullptr) {\n@@ -540,1 +540,1 @@\n-  assert(_starting_thread == NULL, \"already initialized: \"\n+  assert(_starting_thread == nullptr, \"already initialized: \"\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,1 +348,1 @@\n-  \/\/ Returns the current thread (ASSERTS if NULL)\n+  \/\/ Returns the current thread (ASSERTS if nullptr)\n@@ -350,1 +350,1 @@\n-  \/\/ Returns the current thread, or NULL if not attached\n+  \/\/ Returns the current thread, or null if not attached\n@@ -352,1 +352,1 @@\n-  \/\/ Returns the current thread, or NULL if not attached, and is\n+  \/\/ Returns the current thread, or null if not attached, and is\n@@ -438,1 +438,1 @@\n-  \/\/ Apply \"cf->do_code_blob\" (if !NULL) to all code blobs active in frames\n+  \/\/ Apply \"cf->do_code_blob\" (if !nullptr) to all code blobs active in frames\n@@ -538,1 +538,1 @@\n-  address stack_base() const           { assert(_stack_base != NULL,\"Sanity check\"); return _stack_base; }\n+  address stack_base() const           { assert(_stack_base != nullptr,\"Sanity check\"); return _stack_base; }\n@@ -572,1 +572,1 @@\n-  bool owns_locks() const                        { return owned_locks() != NULL; }\n+  bool owns_locks() const                        { return owned_locks() != nullptr; }\n@@ -608,1 +608,1 @@\n-  \/\/ _ParkEvent is just a convenient field we can NULL out after setting the JavaThread termination state\n+  \/\/ _ParkEvent is just a convenient field we can null out after setting the JavaThread termination state\n@@ -610,1 +610,1 @@\n-  bool has_terminated()                       { return Atomic::load(&_ParkEvent) == NULL; };\n+  bool has_terminated()                       { return Atomic::load(&_ParkEvent) == nullptr; };\n@@ -639,1 +639,1 @@\n-  assert(current != NULL, \"Thread::current() called on detached thread\");\n+  assert(current != nullptr, \"Thread::current() called on detached thread\");\n@@ -650,1 +650,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -658,1 +658,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-ThreadsList*          ThreadsSMRSupport::_to_delete_list = NULL;\n+ThreadsList*          ThreadsSMRSupport::_to_delete_list = nullptr;\n@@ -212,1 +212,1 @@\n-    return val_ptr != NULL && *val_ptr == 1;\n+    return val_ptr != nullptr && *val_ptr == 1;\n@@ -256,1 +256,1 @@\n-    if (thread == NULL) return;\n+    if (thread == nullptr) return;\n@@ -261,1 +261,1 @@\n-    ThreadsList *current_list = NULL;\n+    ThreadsList *current_list = nullptr;\n@@ -265,1 +265,1 @@\n-      if (current_list == NULL) {\n+      if (current_list == nullptr) {\n@@ -280,1 +280,1 @@\n-      if (thread->cmpxchg_threads_hazard_ptr(NULL, current_list) == current_list) return;\n+      if (thread->cmpxchg_threads_hazard_ptr(nullptr, current_list) == current_list) return;\n@@ -311,1 +311,1 @@\n-    if (thread == NULL) return;\n+    if (thread == nullptr) return;\n@@ -313,1 +313,1 @@\n-    if (hazard_ptr == NULL) return;\n+    if (hazard_ptr == nullptr) return;\n@@ -347,1 +347,1 @@\n-    if (thread == NULL) return;\n+    if (thread == nullptr) return;\n@@ -349,1 +349,1 @@\n-    if (current_list == NULL) {\n+    if (current_list == nullptr) {\n@@ -361,1 +361,1 @@\n-    for (JavaThread *p = jti.first(); p != NULL; p = jti.next()) {\n+    for (JavaThread *p = jti.first(); p != nullptr; p = jti.next()) {\n@@ -379,1 +379,1 @@\n-    if (thread == NULL) return;\n+    if (thread == nullptr) return;\n@@ -381,1 +381,1 @@\n-    if (hazard_ptr == NULL) return;\n+    if (hazard_ptr == nullptr) return;\n@@ -415,1 +415,1 @@\n-  assert(_thread != NULL, \"sanity check\");\n+  assert(_thread != nullptr, \"sanity check\");\n@@ -420,1 +420,1 @@\n-  if (_thread->get_threads_hazard_ptr() == NULL && _previous == NULL) {\n+  if (_thread->get_threads_hazard_ptr() == nullptr && _previous == nullptr) {\n@@ -433,2 +433,2 @@\n-  assert(_thread != NULL, \"sanity check\");\n-  assert(_thread->get_threads_hazard_ptr() == NULL, \"sanity check\");\n+  assert(_thread != nullptr, \"sanity check\");\n+  assert(_thread->get_threads_hazard_ptr() == nullptr, \"sanity check\");\n@@ -486,1 +486,1 @@\n-  assert(_thread != NULL, \"sanity check\");\n+  assert(_thread != nullptr, \"sanity check\");\n@@ -507,1 +507,1 @@\n-  _thread->set_threads_hazard_ptr(NULL);\n+  _thread->set_threads_hazard_ptr(nullptr);\n@@ -523,1 +523,1 @@\n-  assert(_thread != NULL, \"sanity check\");\n+  assert(_thread != nullptr, \"sanity check\");\n@@ -528,1 +528,1 @@\n-  \/\/ case, we set this thread's hazard ptr back to NULL and we do it before\n+  \/\/ case, we set this thread's hazard ptr back to null and we do it before\n@@ -530,2 +530,2 @@\n-  _thread->set_threads_hazard_ptr(NULL);\n-  if (_previous != NULL) {\n+  _thread->set_threads_hazard_ptr(nullptr);\n+  if (_previous != nullptr) {\n@@ -562,1 +562,1 @@\n-    assert(_previous == NULL || ThreadsList::is_valid(_previous->_list),\n+    assert(_previous == nullptr || ThreadsList::is_valid(_previous->_list),\n@@ -574,1 +574,1 @@\n-  assert(_list != NULL, \"_list must not be NULL\");\n+  assert(_list != nullptr, \"_list must not be null\");\n@@ -623,1 +623,1 @@\n-\/\/ No real entries, just the final NULL terminator.\n+\/\/ No real entries, just the final nullptr terminator.\n@@ -626,1 +626,1 @@\n-\/\/ Result has 'entries + 1' elements, with the last being the NULL terminator.\n+\/\/ Result has 'entries + 1' elements, with the last being the null terminator.\n@@ -632,1 +632,1 @@\n-  data[entries] = NULL;         \/\/ Make sure the final entry is NULL.\n+  data[entries] = nullptr;         \/\/ Make sure the final entry is null.\n@@ -662,1 +662,1 @@\n-  _next_list(NULL),\n+  _next_list(nullptr),\n@@ -696,1 +696,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -710,1 +710,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -718,1 +718,1 @@\n-      if (tobj != NULL && java_tid == java_lang_Thread::thread_id(tobj)) {\n+      if (tobj != nullptr && java_tid == java_lang_Thread::thread_id(tobj)) {\n@@ -731,1 +731,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -739,1 +739,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -793,1 +793,1 @@\n-\/\/ If thread_oop_p is not NULL, then the caller wants to use the oop\n+\/\/ If thread_oop_p is not null, then the caller wants to use the oop\n@@ -801,2 +801,2 @@\n-  assert(this->list() != NULL, \"must have a ThreadsList\");\n-  assert(jt_pp != NULL, \"must have a return JavaThread pointer\");\n+  assert(this->list() != nullptr, \"must have a ThreadsList\");\n+  assert(jt_pp != nullptr, \"must have a return JavaThread pointer\");\n@@ -805,2 +805,2 @@\n-  \/\/ The JVM_* interfaces don't allow a NULL thread parameter; JVM\/TI\n-  \/\/ allows a NULL thread parameter to signify \"current thread\" which\n+  \/\/ The JVM_* interfaces don't allow a null thread parameter; JVM\/TI\n+  \/\/ allows a null thread parameter to signify \"current thread\" which\n@@ -812,1 +812,1 @@\n-  if (thread_oop_p != NULL) {\n+  if (thread_oop_p != nullptr) {\n@@ -819,1 +819,1 @@\n-  if (java_thread == NULL) {\n+  if (java_thread == nullptr) {\n@@ -906,2 +906,2 @@\n-  ThreadsList* prev = NULL;\n-  ThreadsList* next = NULL;\n+  ThreadsList* prev = nullptr;\n+  ThreadsList* next = nullptr;\n@@ -909,1 +909,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -913,1 +913,1 @@\n-      if (prev != NULL) {\n+      if (prev != nullptr) {\n@@ -963,1 +963,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -1078,1 +1078,1 @@\n-          while (current != NULL) {\n+          while (current != nullptr) {\n@@ -1146,1 +1146,1 @@\n-  if (hazard_ptr != NULL) {\n+  if (hazard_ptr != nullptr) {\n@@ -1149,1 +1149,1 @@\n-  if (EnableThreadSMRStatistics && thread->_threads_list_ptr != NULL) {\n+  if (EnableThreadSMRStatistics && thread->_threads_list_ptr != nullptr) {\n@@ -1157,1 +1157,1 @@\n-    if (current != NULL) {\n+    if (current != nullptr) {\n@@ -1161,1 +1161,1 @@\n-    while (current != NULL) {\n+    while (current != nullptr) {\n@@ -1178,1 +1178,1 @@\n-  ThreadsList* saved_threads_list = NULL;\n+  ThreadsList* saved_threads_list = nullptr;\n@@ -1190,1 +1190,1 @@\n-  if (_to_delete_list != NULL) {\n+  if (_to_delete_list != nullptr) {\n@@ -1198,1 +1198,1 @@\n-           t_list != NULL; t_list = t_list->next_list()) {\n+           t_list != nullptr; t_list = t_list->next_list()) {\n@@ -1257,1 +1257,1 @@\n-  for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {\n+  for (JavaThread *jt = jti.first(); jt != nullptr; jt = jti.next()) {\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-\/\/   JavaThread* jt = NULL;\n-\/\/   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &jt, NULL);\n+\/\/   JavaThread* jt = nullptr;\n+\/\/   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &jt, nullptr);\n@@ -64,1 +64,1 @@\n-\/\/   JavaThread* jt = NULL;\n+\/\/   JavaThread* jt = nullptr;\n@@ -66,1 +66,1 @@\n-\/\/   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &jt, NULL);\n+\/\/   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &jt, nullptr);\n@@ -75,1 +75,1 @@\n-\/\/   JavaThread *jt = NULL;\n+\/\/   JavaThread *jt = nullptr;\n@@ -263,1 +263,1 @@\n-    _previous(NULL),\n+    _previous(nullptr),\n@@ -265,1 +265,1 @@\n-    _list(NULL),\n+    _list(nullptr),\n@@ -340,1 +340,1 @@\n-\/\/   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {\n+\/\/   for (JavaThread *jt = jti.first(); jt != nullptr; jt = jti.next()) {\n@@ -350,1 +350,1 @@\n-    assert(list != NULL, \"ThreadsList must not be NULL.\");\n+    assert(list != nullptr, \"ThreadsList must not be nullptr.\");\n@@ -364,1 +364,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -395,1 +395,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  MutexLocker ml(Threads_lock->owned_by_self() ? NULL : Threads_lock);\n+  MutexLocker ml(Threads_lock->owned_by_self() ? nullptr : Threads_lock);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,1 @@\n-  bool found = ik != NULL &&\n+  bool found = ik != nullptr &&\n@@ -184,2 +184,2 @@\n-    if (name_oop == NULL) {\n-      return NULL;\n+    if (name_oop == nullptr) {\n+      return nullptr;\n@@ -190,1 +190,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -220,1 +220,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -522,1 +522,1 @@\n-    JavaThread::_jvmci_old_thread_counters = NULL;\n+    JavaThread::_jvmci_old_thread_counters = nullptr;\n@@ -820,2 +820,2 @@\n-  OnLoadEntry_t on_load_entry = NULL;\n-  void *library = NULL;\n+  OnLoadEntry_t on_load_entry = nullptr;\n+  void *library = nullptr;\n@@ -834,1 +834,1 @@\n-      if (library == NULL) {\n+      if (library == nullptr) {\n@@ -840,1 +840,1 @@\n-        vm_exit_during_initialization(buf, NULL);\n+        vm_exit_during_initialization(buf, nullptr);\n@@ -849,1 +849,1 @@\n-      if (library == NULL) { \/\/ Try the library path directory.\n+      if (library == nullptr) { \/\/ Try the library path directory.\n@@ -853,1 +853,1 @@\n-        if (library == NULL) {\n+        if (library == nullptr) {\n@@ -866,1 +866,1 @@\n-          vm_exit_during_initialization(buf, NULL);\n+          vm_exit_during_initialization(buf, nullptr);\n@@ -904,1 +904,1 @@\n-  for (agent = Arguments::libraries(); agent != NULL; agent = next) {\n+  for (agent = Arguments::libraries(); agent != nullptr; agent = next) {\n@@ -910,1 +910,1 @@\n-    if (on_load_entry == NULL) {\n+    if (on_load_entry == nullptr) {\n@@ -912,1 +912,1 @@\n-      if (on_load_entry != NULL) {\n+      if (on_load_entry != nullptr) {\n@@ -932,1 +932,1 @@\n-  for (agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+  for (agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n@@ -946,1 +946,1 @@\n-    if (on_load_entry != NULL) {\n+    if (on_load_entry != nullptr) {\n@@ -948,1 +948,1 @@\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n@@ -969,1 +969,1 @@\n-  for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+  for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n@@ -979,1 +979,1 @@\n-    if (unload_entry != NULL) {\n+    if (unload_entry != nullptr) {\n@@ -994,1 +994,1 @@\n-  for (agent = Arguments::libraries(); agent != NULL; agent = agent->next()) {\n+  for (agent = Arguments::libraries(); agent != nullptr; agent = agent->next()) {\n@@ -997,1 +997,1 @@\n-    if (on_load_entry != NULL) {\n+    if (on_load_entry != nullptr) {\n@@ -1002,1 +1002,1 @@\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n@@ -1376,2 +1376,2 @@\n-  \/\/ NULL owner means not locked so we can skip the search\n-  if (owner == NULL) return NULL;\n+  \/\/ null owner means not locked so we can skip the search\n+  if (owner == nullptr) return nullptr;\n@@ -1387,1 +1387,1 @@\n-  if (UseHeavyMonitors) return NULL;\n+  if (UseHeavyMonitors) return nullptr;\n@@ -1393,1 +1393,1 @@\n-  JavaThread* the_owner = NULL;\n+  JavaThread* the_owner = nullptr;\n@@ -1419,1 +1419,1 @@\n-    if (thread != NULL) {\n+    if (thread != nullptr) {\n@@ -1482,1 +1482,1 @@\n-  if (this_thread != NULL) {\n+  if (this_thread != nullptr) {\n@@ -1531,1 +1531,1 @@\n-  if (Universe::heap() != NULL) {\n+  if (Universe::heap() != nullptr) {\n@@ -1558,2 +1558,2 @@\n-      \/\/ Keep task in local variable for NULL check.\n-      \/\/ ct->_task might be set to NULL by concurring compiler thread\n+      \/\/ Keep task in local variable for null check.\n+      \/\/ ct->_task might be set to null by concurring compiler thread\n@@ -1563,1 +1563,1 @@\n-      if (task != NULL) {\n+      if (task != nullptr) {\n@@ -1566,1 +1566,1 @@\n-        task->print(st, NULL, short_form, true);\n+        task->print(st, nullptr, short_form, true);\n@@ -1577,1 +1577,1 @@\n-  if (thread != NULL) thread->verify();\n+  if (thread != nullptr) thread->verify();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  _print    = NULL;\n+  _print    = nullptr;\n@@ -37,1 +37,1 @@\n-    _accum = NULL;\n+    _accum = nullptr;\n@@ -49,1 +49,1 @@\n-  _print    = NULL;\n+  _print    = nullptr;\n@@ -59,1 +59,1 @@\n-  _active   = ttlpf!= NULL;\n+  _active   = ttlpf!= nullptr;\n@@ -65,1 +65,1 @@\n-    _accum = NULL;\n+    _accum = nullptr;\n@@ -75,1 +75,1 @@\n-  if (_accum != NULL) {\n+  if (_accum != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/timerTrace.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    log_is_enabled(TT_LEVEL, __VA_ARGS__) ? static_cast<TraceTimerLogPrintFunc>(&LogImpl<LOG_TAGS(__VA_ARGS__)>::write<LogLevel::TT_LEVEL>) : (TraceTimerLogPrintFunc)NULL\n+    log_is_enabled(TT_LEVEL, __VA_ARGS__) ? static_cast<TraceTimerLogPrintFunc>(&LogImpl<LOG_TAGS(__VA_ARGS__)>::write<LogLevel::TT_LEVEL>) : (TraceTimerLogPrintFunc)nullptr\n","filename":"src\/hotspot\/share\/runtime\/timerTrace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-static Thread* unhandled_oop_print = NULL;\n+static Thread* unhandled_oop_print = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  UnhandledOopEntry() : _oop_ptr(NULL), _ok_for_gc(false) {}\n+  UnhandledOopEntry() : _oop_ptr(nullptr), _ok_for_gc(false) {}\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  assert(fr != NULL, \"must have frame\");\n+  assert(fr != nullptr, \"must have frame\");\n@@ -73,1 +73,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -99,2 +99,2 @@\n-  if (_fr.is_empty()) return NULL;\n-  if (_fr.is_entry_frame() && _fr.is_first_frame()) return NULL;\n+  if (_fr.is_empty()) return nullptr;\n+  if (_fr.is_entry_frame() && _fr.is_first_frame()) return nullptr;\n@@ -102,1 +102,1 @@\n-  if (s.is_first_frame()) return NULL;\n+  if (s.is_first_frame()) return nullptr;\n@@ -112,1 +112,1 @@\n-  while (f != NULL) {\n+  while (f != nullptr) {\n@@ -118,1 +118,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -136,2 +136,2 @@\n-  ObjectMonitor *pending_monitor = NULL;\n-  if (waiting_monitor == NULL) {\n+  ObjectMonitor *pending_monitor = nullptr;\n+  if (waiting_monitor == nullptr) {\n@@ -140,2 +140,2 @@\n-  oop pending_obj = (pending_monitor != NULL ? pending_monitor->object() : (oop) NULL);\n-  oop waiting_obj = (waiting_monitor != NULL ? waiting_monitor->object() : (oop) NULL);\n+  oop pending_obj = (pending_monitor != nullptr ? pending_monitor->object() : (oop) nullptr);\n+  oop waiting_obj = (waiting_monitor != nullptr ? waiting_monitor->object() : (oop) nullptr);\n@@ -147,1 +147,1 @@\n-    if (obj == NULL) continue; \/\/ skip unowned monitor\n+    if (obj == nullptr) continue; \/\/ skip unowned monitor\n@@ -203,1 +203,1 @@\n-    } else if (thread()->current_park_blocker() != NULL) {\n+    } else if (thread()->current_park_blocker() != nullptr) {\n@@ -211,1 +211,1 @@\n-      if (k != NULL) {\n+      if (k != nullptr) {\n@@ -230,1 +230,1 @@\n-          if (obj() != NULL) {\n+          if (obj() != nullptr) {\n@@ -236,1 +236,1 @@\n-      if (monitor->owner() != NULL) {\n+      if (monitor->owner() != nullptr) {\n@@ -269,1 +269,1 @@\n-  return stack_chunk() == NULL ? fr().interpreter_frame_bcp() : stack_chunk()->interpreter_frame_bcp(fr());\n+  return stack_chunk() == nullptr ? fr().interpreter_frame_bcp() : stack_chunk()->interpreter_frame_bcp(fr());\n@@ -273,1 +273,1 @@\n-  assert(stack_chunk() == NULL, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n+  assert(stack_chunk() == nullptr, \"Not supported for heap frames\"); \/\/ unsupported for now because seems to be unused\n@@ -280,1 +280,1 @@\n-  if (stack_chunk() == NULL) { \/\/ no monitors in continuations\n+  if (stack_chunk() == nullptr) { \/\/ no monitors in continuations\n@@ -295,1 +295,1 @@\n-  return stack_chunk() == NULL ? fr().interpreter_frame_method() : stack_chunk()->interpreter_frame_method(fr());\n+  return stack_chunk() == nullptr ? fr().interpreter_frame_method() : stack_chunk()->interpreter_frame_method(fr());\n@@ -310,1 +310,1 @@\n-  return new StackValue(addr != NULL ? *addr : 0);\n+  return new StackValue(addr != nullptr ? *addr : 0);\n@@ -314,1 +314,1 @@\n-  assert(addr != NULL, \"invariant\");\n+  assert(addr != nullptr, \"invariant\");\n@@ -332,1 +332,1 @@\n-  assert(result != NULL, \"invariant\");\n+  assert(result != nullptr, \"invariant\");\n@@ -336,1 +336,1 @@\n-    if (chunk == NULL) {\n+    if (chunk == nullptr) {\n@@ -342,1 +342,1 @@\n-    assert(addr != NULL, \"invariant\");\n+    assert(addr != nullptr, \"invariant\");\n@@ -345,1 +345,1 @@\n-    assert(sv != NULL, \"sanity check\");\n+    assert(sv != nullptr, \"sanity check\");\n@@ -358,1 +358,1 @@\n-  assert(result != NULL, \"invariant\");\n+  assert(result != nullptr, \"invariant\");\n@@ -362,1 +362,1 @@\n-    if (chunk == NULL) {\n+    if (chunk == nullptr) {\n@@ -364,1 +364,1 @@\n-      assert(addr != NULL, \"invariant\");\n+      assert(addr != nullptr, \"invariant\");\n@@ -367,1 +367,1 @@\n-        addr = NULL;\n+        addr = nullptr;\n@@ -377,1 +377,1 @@\n-    assert(sv != NULL, \"sanity check\");\n+    assert(sv != nullptr, \"sanity check\");\n@@ -436,1 +436,1 @@\n-  if (values == NULL || values->size() == 0) return;\n+  if (values == nullptr || values->size() == 0) return;\n@@ -452,1 +452,1 @@\n-    assert(sv != NULL, \"sanity check\");\n+    assert(sv != nullptr, \"sanity check\");\n@@ -596,1 +596,1 @@\n-  javaVFrame* result = NULL;\n+  javaVFrame* result = nullptr;\n@@ -622,1 +622,1 @@\n-  if (WizardMode) _fr.print_value_on(tty,NULL);\n+  if (WizardMode) _fr.print_value_on(tty,nullptr);\n@@ -673,1 +673,1 @@\n-    } else if (monitor->owner() == NULL) {\n+    } else if (monitor->owner() == nullptr) {\n@@ -704,1 +704,1 @@\n-    if (source_name != NULL && (line_number != -1)) {\n+    if (source_name != nullptr && (line_number != -1)) {\n@@ -711,1 +711,1 @@\n-  if (fr().sp() != NULL) {\n+  if (fr().sp() != nullptr) {\n@@ -737,1 +737,1 @@\n-  _fr.print_value_on(tty,NULL);\n+  _fr.print_value_on(tty,nullptr);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-    assert(vf == NULL || vf->is_java_frame(), \"must be java frame\");\n+    assert(vf == nullptr || vf->is_java_frame(), \"must be java frame\");\n@@ -178,1 +178,1 @@\n-    assert(vf == NULL || vf->is_interpreted_frame(), \"must be interpreted frame\");\n+    assert(vf == nullptr || vf->is_interpreted_frame(), \"must be interpreted frame\");\n@@ -297,1 +297,1 @@\n-      assert( cb() != NULL && cb()->is_compiled(), \"usage\");\n+      assert( cb() != nullptr && cb()->is_compiled(), \"usage\");\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-inline vframeStreamCommon::vframeStreamCommon(RegisterMap reg_map) : _reg_map(reg_map), _cont_entry(NULL) {\n+inline vframeStreamCommon::vframeStreamCommon(RegisterMap reg_map) : _reg_map(reg_map), _cont_entry(nullptr) {\n@@ -42,1 +42,1 @@\n-  if (_reg_map.cont() != NULL) {\n+  if (_reg_map.cont() != nullptr) {\n@@ -44,1 +44,1 @@\n-  } else if (_cont_entry != NULL) {\n+  } else if (_cont_entry != nullptr) {\n@@ -47,1 +47,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -82,1 +82,1 @@\n-      assert(_cont_entry != NULL, \"\");\n+      assert(_cont_entry != nullptr, \"\");\n@@ -84,1 +84,1 @@\n-      assert(!_reg_map.process_frames() || _cont_entry->cont_oop(_reg_map.thread()) != NULL, \"_cont: \" INTPTR_FORMAT, p2i(_cont_entry));\n+      assert(!_reg_map.process_frames() || _cont_entry->cont_oop(_reg_map.thread()) != nullptr, \"_cont: \" INTPTR_FORMAT, p2i(_cont_entry));\n@@ -94,1 +94,1 @@\n-      assert(_reg_map.cont() != NULL, \"\");\n+      assert(_reg_map.cont() != nullptr, \"\");\n@@ -207,2 +207,2 @@\n-  if (cb() != NULL && cb()->is_compiled()) {\n-    assert(nm()->method() != NULL, \"must be\");\n+  if (cb() != nullptr && cb()->is_compiled()) {\n+    assert(nm()->method() != nullptr, \"must be\");\n@@ -215,1 +215,1 @@\n-      if (pc_desc == NULL) {\n+      if (pc_desc == nullptr) {\n@@ -232,1 +232,1 @@\n-        JavaThreadState state = _thread != NULL ? _thread->thread_state() : _thread_in_Java;\n+        JavaThreadState state = _thread != nullptr ? _thread->thread_state() : _thread_in_Java;\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  if (_monitors != NULL) {\n+  if (_monitors != nullptr) {\n@@ -54,1 +54,1 @@\n-     _monitors = NULL;\n+     _monitors = nullptr;\n@@ -83,1 +83,1 @@\n-      _monitors = NULL;\n+      _monitors = nullptr;\n@@ -96,1 +96,1 @@\n-          dest->set_obj(NULL);\n+          dest->set_obj(nullptr);\n@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n+          assert(monitor->owner() == nullptr || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n@@ -221,1 +221,1 @@\n-  assert(thread->deopt_compiled_method() != NULL, \"compiled method should be known\");\n+  assert(thread->deopt_compiled_method() != nullptr, \"compiled method should be known\");\n@@ -245,1 +245,1 @@\n-    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != NULL &&\n+    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr &&\n@@ -250,1 +250,1 @@\n-      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != NULL && state->is_earlyret_pending()) {\n+      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n@@ -252,1 +252,1 @@\n-        state->set_earlyret_oop(NULL);\n+        state->set_earlyret_oop(nullptr);\n@@ -281,1 +281,1 @@\n-  assert(method() != NULL, \"method must exist\");\n+  assert(method() != nullptr, \"method must exist\");\n@@ -284,1 +284,1 @@\n-  int locks = monitors() == NULL ? 0 : monitors()->number_of_monitors();\n+  int locks = monitors() == nullptr ? 0 : monitors()->number_of_monitors();\n@@ -319,1 +319,1 @@\n-    if (mdo != NULL) {\n+    if (mdo != nullptr) {\n@@ -358,2 +358,2 @@\n-          if (o == NULL) {\n-            tty->print_cr(\"NULL\");\n+          if (o == nullptr) {\n+            tty->print_cr(\"null\");\n@@ -402,2 +402,2 @@\n-          if (o == NULL) {\n-            tty->print_cr(\"NULL\");\n+          if (o == nullptr) {\n+            tty->print_cr(\"null\");\n@@ -412,1 +412,1 @@\n-        \/\/ A dead location. If it is an oop then we need a NULL to prevent GC from following it\n+        \/\/ A dead location. If it is an oop then we need a null to prevent GC from following it\n@@ -430,1 +430,1 @@\n-      assert(saved_args != NULL, \"must have been saved by interpreter\");\n+      assert(saved_args != nullptr, \"must have been saved by interpreter\");\n@@ -470,1 +470,1 @@\n-  _locals = _expressions = NULL;\n+  _locals = _expressions = nullptr;\n@@ -479,1 +479,1 @@\n-  int locks = monitors() == NULL ? 0 : monitors()->number_of_monitors();\n+  int locks = monitors() == nullptr ? 0 : monitors()->number_of_monitors();\n@@ -509,1 +509,1 @@\n-  result->set_unroll_block(NULL); \/\/ initialize it\n+  result->set_unroll_block(nullptr); \/\/ initialize it\n@@ -527,1 +527,1 @@\n-  if (reg_map != NULL) {\n+  if (reg_map != nullptr) {\n@@ -541,1 +541,1 @@\n-        _callee_registers[i] = src != NULL ? *src : NULL_WORD;\n+        _callee_registers[i] = src != nullptr ? *src : NULL_WORD;\n@@ -544,1 +544,1 @@\n-        \/\/      _callee_registers[i] = src != NULL ? *src : NULL_WORD;\n+        \/\/      _callee_registers[i] = src != nullptr ? *src : NULL_WORD;\n@@ -548,1 +548,1 @@\n-      _callee_registers[i] = src != NULL ? *src : NULL_WORD;\n+      _callee_registers[i] = src != nullptr ? *src : NULL_WORD;\n@@ -550,1 +550,1 @@\n-      if (src != NULL) {\n+      if (src != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (scope() == NULL) return new StackValueCollection(0);\n+  if (scope() == nullptr) return new StackValueCollection(0);\n@@ -59,1 +59,1 @@\n-  if (scv_list == NULL) return new StackValueCollection(0);\n+  if (scv_list == nullptr) return new StackValueCollection(0);\n@@ -73,1 +73,1 @@\n-    if (list != NULL ) {\n+    if (list != nullptr ) {\n@@ -114,2 +114,2 @@\n-  jvmtiDeferredLocalVariableSet* locals = NULL;\n-  if (deferred != NULL ) {\n+  jvmtiDeferredLocalVariableSet* locals = nullptr;\n+  if (deferred != nullptr ) {\n@@ -130,1 +130,1 @@\n-  if (locals == NULL) {\n+  if (locals == nullptr) {\n@@ -150,1 +150,1 @@\n-  if (lcls != NULL) {\n+  if (lcls != nullptr) {\n@@ -164,1 +164,1 @@\n-  if (exprs != NULL) {\n+  if (exprs != nullptr) {\n@@ -177,1 +177,1 @@\n-  if (mtrs != NULL) {\n+  if (mtrs != nullptr) {\n@@ -190,1 +190,1 @@\n-  if (scope() == NULL) return new StackValueCollection(0);\n+  if (scope() == nullptr) return new StackValueCollection(0);\n@@ -192,1 +192,1 @@\n-  if (scv_list == NULL) return new StackValueCollection(0);\n+  if (scv_list == nullptr) return new StackValueCollection(0);\n@@ -206,1 +206,1 @@\n-    if (list != NULL ) {\n+    if (list != nullptr ) {\n@@ -244,1 +244,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -262,1 +262,1 @@\n-  if (monitors == NULL) {\n+  if (monitors == nullptr) {\n@@ -288,1 +288,1 @@\n-  if (list != NULL ) {\n+  if (list != nullptr ) {\n@@ -304,1 +304,1 @@\n-  _scope  = NULL;\n+  _scope  = nullptr;\n@@ -317,1 +317,1 @@\n-  guarantee(_scope != NULL, \"scope must be present\");\n+  guarantee(_scope != nullptr, \"scope must be present\");\n@@ -331,1 +331,1 @@\n-  if (scope() == NULL) return true;\n+  if (scope() == nullptr) return true;\n@@ -342,1 +342,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -359,1 +359,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -369,1 +369,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -379,1 +379,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -384,1 +384,1 @@\n-  return (scope()->objects() != NULL) || scope()->has_ea_local_in_scope();\n+  return (scope()->objects() != nullptr) || scope()->has_ea_local_in_scope();\n@@ -388,1 +388,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -398,1 +398,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    assert(vf == NULL || vf->is_compiled_frame(), \"must be compiled frame\");\n+    assert(vf == nullptr || vf->is_compiled_frame(), \"must be compiled frame\");\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-  VM_Operation() : _calling_thread(NULL) {}\n+  VM_Operation() : _calling_thread(nullptr) {}\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-  if (_deadlocks != NULL) {\n+  if (_deadlocks != nullptr) {\n@@ -190,1 +190,1 @@\n-    while (cycle != NULL) {\n+    while (cycle != nullptr) {\n@@ -207,1 +207,1 @@\n-  if (_out != NULL) {\n+  if (_out != nullptr) {\n@@ -209,1 +209,1 @@\n-    for (DeadlockCycle* cycle = _deadlocks; cycle != NULL; cycle = cycle->next()) {\n+    for (DeadlockCycle* cycle = _deadlocks; cycle != nullptr; cycle = cycle->next()) {\n@@ -230,1 +230,1 @@\n-  _threads = NULL;\n+  _threads = nullptr;\n@@ -304,1 +304,1 @@\n-      ThreadConcurrentLocks* tcl = NULL;\n+      ThreadConcurrentLocks* tcl = nullptr;\n@@ -316,1 +316,1 @@\n-      if (th() == NULL) {\n+      if (th() == nullptr) {\n@@ -326,1 +326,1 @@\n-      if (jt != NULL && !_result->t_list()->includes(jt)) {\n+      if (jt != nullptr && !_result->t_list()->includes(jt)) {\n@@ -330,1 +330,1 @@\n-        jt = NULL;\n+        jt = nullptr;\n@@ -332,1 +332,1 @@\n-      if (jt == NULL || \/* thread not alive *\/\n+      if (jt == nullptr || \/* thread not alive *\/\n@@ -335,1 +335,1 @@\n-        \/\/ add a NULL snapshot if skipped\n+        \/\/ add a nullptr snapshot if skipped\n@@ -339,1 +339,1 @@\n-      ThreadConcurrentLocks* tcl = NULL;\n+      ThreadConcurrentLocks* tcl = nullptr;\n@@ -356,1 +356,1 @@\n-Thread * volatile VM_Exit::_shutdown_thread = NULL;\n+Thread * volatile VM_Exit::_shutdown_thread = nullptr;\n@@ -412,1 +412,1 @@\n-          if (ct->compiler() == NULL || !ct->compiler()->is_jvmci()) {\n+          if (ct->compiler() == nullptr || !ct->compiler()->is_jvmci()) {\n@@ -482,1 +482,1 @@\n-  if (exit_hook != NULL) {\n+  if (exit_hook != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,2 +184,2 @@\n-  VM_FindDeadlocks(bool concurrent_locks) :  _concurrent_locks(concurrent_locks), _deadlocks(NULL), _out(NULL), _setter() {};\n-  VM_FindDeadlocks(outputStream* st) : _concurrent_locks(true), _deadlocks(NULL), _out(st) {};\n+  VM_FindDeadlocks(bool concurrent_locks) :  _concurrent_locks(concurrent_locks), _deadlocks(nullptr), _out(nullptr), _setter() {};\n+  VM_FindDeadlocks(outputStream* st) : _concurrent_locks(true), _deadlocks(nullptr), _out(st) {};\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3079,1 +3079,1 @@\n-    while (types->typeName != NULL) {\n+    while (types->typeName != nullptr) {\n@@ -3100,1 +3100,1 @@\n-  const char* start = NULL;\n+  const char* start = nullptr;\n@@ -3106,1 +3106,1 @@\n-  if (start != NULL) {\n+  if (start != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  \/\/ the fact that it has a NULL fieldName\n+  \/\/ the fact that it has a null fieldName\n@@ -115,1 +115,1 @@\n-  \/\/ the fact that it has a NULL typeName\n+  \/\/ the fact that it has a nullptr typeName\n@@ -122,1 +122,1 @@\n-  \/\/ the fact that it has a NULL typeName\n+  \/\/ the fact that it has a null typeName\n@@ -129,1 +129,1 @@\n-  \/\/ the fact that it has a NULL typeName\n+  \/\/ the fact that it has a null typeName\n@@ -160,1 +160,1 @@\n- { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 0, offset_of(typeName, fieldName), NULL },\n+ { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 0, offset_of(typeName, fieldName), nullptr },\n@@ -173,1 +173,1 @@\n-\/\/ The type string is given as NULL, indicating an \"opaque\" type.\n+\/\/ The type string is given as null, indicating an \"opaque\" type.\n@@ -175,1 +175,1 @@\n-  { QUOTE(typeName), QUOTE(fieldName), NULL, 0, offset_of(typeName, fieldName), NULL },\n+  { QUOTE(typeName), QUOTE(fieldName), nullptr, 0, offset_of(typeName, fieldName), nullptr },\n@@ -179,1 +179,1 @@\n-\/\/ The type string is given as NULL, indicating an \"opaque\" type.\n+\/\/ The type string is given as null, indicating an \"opaque\" type.\n@@ -181,1 +181,1 @@\n- { QUOTE(typeName), QUOTE(fieldName), NULL, 1, 0, (void*) &typeName::fieldName },\n+ { QUOTE(typeName), QUOTE(fieldName), nullptr, 1, 0, (void*) &typeName::fieldName },\n@@ -185,1 +185,1 @@\n- { NULL, NULL, NULL, 0, 0, NULL }\n+ { nullptr, nullptr, nullptr, 0, 0, nullptr }\n@@ -236,1 +236,1 @@\n- { QUOTE(type), NULL,              0, 0, 0, sizeof(type) },\n+ { QUOTE(type), nullptr,              0, 0, 0, sizeof(type) },\n@@ -239,1 +239,1 @@\n- { QUOTE(type), NULL,              1, 0, 0, sizeof(type) },\n+ { QUOTE(type), nullptr,              1, 0, 0, sizeof(type) },\n@@ -242,1 +242,1 @@\n- { QUOTE(type), NULL,              0, 1, 0, sizeof(type) },\n+ { QUOTE(type), nullptr,              0, 1, 0, sizeof(type) },\n@@ -245,1 +245,1 @@\n- { QUOTE(type), NULL,              0, 1, 1, sizeof(type) },\n+ { QUOTE(type), nullptr,              0, 1, 1, sizeof(type) },\n@@ -248,1 +248,1 @@\n- { NULL, NULL, 0, 0, 0, 0 }\n+ { nullptr, nullptr, 0, 0, 0, 0 }\n@@ -251,1 +251,1 @@\n- { type* dummyObj = NULL; superclass* dummySuperObj = dummyObj; }\n+ { type* dummyObj = nullptr; superclass* dummySuperObj = dummyObj; }\n@@ -272,1 +272,1 @@\n- { NULL, 0 }\n+ { nullptr, 0 }\n@@ -287,1 +287,1 @@\n- { NULL, 0 }\n+ { nullptr, 0 }\n@@ -305,1 +305,1 @@\n- { NULL, NULL }\n+ { nullptr, nullptr }\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,3 @@\n-Monitor*          VMThread::_terminate_lock     = NULL;\n-VMThread*         VMThread::_vm_thread          = NULL;\n-VM_Operation*     VMThread::_cur_vm_operation   = NULL;\n+Monitor*          VMThread::_terminate_lock     = nullptr;\n+VMThread*         VMThread::_vm_thread          = nullptr;\n+VM_Operation*     VMThread::_cur_vm_operation   = nullptr;\n@@ -108,2 +108,2 @@\n-PerfCounter*      VMThread::_perf_accumulated_vm_operation_time = NULL;\n-VMOperationTimeoutTask* VMThread::_timeout_task = NULL;\n+PerfCounter*      VMThread::_perf_accumulated_vm_operation_time = nullptr;\n+VMOperationTimeoutTask* VMThread::_timeout_task = nullptr;\n@@ -113,1 +113,1 @@\n-  assert(vm_thread() == NULL, \"we can only allocate one VMThread\");\n+  assert(vm_thread() == nullptr, \"we can only allocate one VMThread\");\n@@ -128,1 +128,1 @@\n-    assert(_timeout_task == NULL, \"sanity\");\n+    assert(_timeout_task == nullptr, \"sanity\");\n@@ -147,1 +147,1 @@\n-  _vm_thread = NULL;      \/\/ VM thread is gone\n+  _vm_thread = nullptr;      \/\/ VM thread is gone\n@@ -180,1 +180,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -215,1 +215,1 @@\n-    \/\/ VM thread to enter any lock at Safepoint as long as its _owner is NULL.\n+    \/\/ VM thread to enter any lock at Safepoint as long as its _owner is null.\n@@ -260,2 +260,2 @@\n-  assert(event != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n+  assert(op != nullptr, \"invariant\");\n@@ -304,2 +304,2 @@\n-  assert(_cur_vm_operation == NULL, \"should not have an op yet\");\n-  assert(_next_vm_operation == NULL, \"should not have an op yet\");\n+  assert(_cur_vm_operation == nullptr, \"should not have an op yet\");\n+  assert(_next_vm_operation == nullptr, \"should not have an op yet\");\n@@ -323,2 +323,2 @@\n-  assert(_cur_vm_operation  == NULL, \"Already have an op\");\n-  assert(_next_vm_operation == NULL, \"Already have an op\");\n+  assert(_cur_vm_operation  == nullptr, \"Already have an op\");\n+  assert(_next_vm_operation == nullptr, \"Already have an op\");\n@@ -340,1 +340,1 @@\n-  if (_next_vm_operation != NULL) {\n+  if (_next_vm_operation != nullptr) {\n@@ -394,2 +394,2 @@\n-  VM_Operation* prev_vm_operation = NULL;\n-  if (_cur_vm_operation != NULL) {\n+  VM_Operation* prev_vm_operation = nullptr;\n+  if (_cur_vm_operation != nullptr) {\n@@ -410,1 +410,1 @@\n-  EventMarkVMOperation em(\"Executing %sVM operation: %s\", prev_vm_operation != NULL ? \"nested \" : \"\", op->name());\n+  EventMarkVMOperation em(\"Executing %sVM operation: %s\", prev_vm_operation != nullptr ? \"nested \" : \"\", op->name());\n@@ -413,1 +413,1 @@\n-                       prev_vm_operation != NULL ? \"nested\" : \"\",\n+                       prev_vm_operation != nullptr ? \"nested\" : \"\",\n@@ -446,1 +446,1 @@\n-  _next_vm_operation = NULL;\n+  _next_vm_operation = nullptr;\n@@ -452,1 +452,1 @@\n-    if (_next_vm_operation != NULL) {\n+    if (_next_vm_operation != nullptr) {\n@@ -462,1 +462,1 @@\n-      if (_next_vm_operation != NULL) {\n+      if (_next_vm_operation != nullptr) {\n@@ -466,2 +466,2 @@\n-    assert(_next_vm_operation == NULL, \"Must be\");\n-    assert(_cur_vm_operation  == NULL, \"Must be\");\n+    assert(_next_vm_operation == nullptr, \"Must be\");\n+    assert(_cur_vm_operation  == nullptr, \"Must be\");\n@@ -470,1 +470,1 @@\n-    if (_next_vm_operation != NULL) {\n+    if (_next_vm_operation != nullptr) {\n@@ -481,1 +481,1 @@\n-  assert(_cur_vm_operation == NULL, \"no current one should be executing\");\n+  assert(_cur_vm_operation == nullptr, \"no current one should be executing\");\n@@ -494,1 +494,1 @@\n-    assert(_next_vm_operation != NULL, \"Must have one\");\n+    assert(_next_vm_operation != nullptr, \"Must have one\");\n@@ -554,1 +554,1 @@\n-  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+  oops_do(&VerifyOopClosure::verify_oop, nullptr);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    assert(op != NULL, \"sanity\");\n+    assert(op != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}