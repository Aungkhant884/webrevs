{"files":[{"patch":"@@ -159,1 +159,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -511,17 +511,8 @@\n-  \/\/ Internal counting is based on signed int counters. They tend to\n-  \/\/ overflow with longer-running workloads on fast machines. To shift\n-  \/\/ the overflow limit, we interpret the return value as unsigned int.\n-  \/\/ This is ok because counters are unsigned by nature, and it gives us\n-  \/\/ another factor of 2 before the counter values become meaningless.\n-  \/\/ Print a \"overflow\" notification to create awareness.\n-  const char* addMsg;\n-  unsigned int maxInt = (1U<<31) - 1;\n-  unsigned int iic    = (unsigned int)interpreter_invocation_count();\n-  addMsg = (iic > maxInt) ? \"counter in overflow\" : \"\";\n-  tty->print_cr (\"  interpreter_invocation_count: \" UINT32_FORMAT_W(11) \" %s\", iic, addMsg);\n-  unsigned int ic     = (unsigned int)invocation_count();\n-  addMsg = (ic  > maxInt) ? \"counter in overflow\" : \"\";\n-  tty->print_cr (\"  invocation_counter:           \" UINT32_FORMAT_W(11) \" %s\", ic, addMsg);\n-  unsigned int bec    = (unsigned int)backedge_count();\n-  addMsg = (bec > maxInt) ? \"counter in overflow\" : \"\";\n-  tty->print_cr (\"  backedge_counter:             \" UINT32_FORMAT_W(11) \" %s\", bec, addMsg);\n+  \/\/ Counting based on signed int counters tends to overflow with\n+  \/\/ longer-running workloads on fast machines. The counters under\n+  \/\/ consideration here, however, are limited in range by counting\n+  \/\/ logic. See InvocationCounter:count_limit for example.\n+  \/\/ No \"overflow precautions\" need to be implemented here.\n+  tty->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n+  tty->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n+  tty->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n@@ -530,3 +521,1 @@\n-    unsigned int dcc    = (unsigned int)method_data()->decompile_count();\n-    addMsg = (dcc > maxInt) ? \"counter in overflow\" : \"\";\n-    tty->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11)\" %s\", dcc, addMsg);\n+    tty->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -99,2 +99,5 @@\n-  return (int32_t)(((uint32_t)(*b)->invocation_count() + (*b)->compiled_invocation_count())\n-                 - ((uint32_t)(*a)->invocation_count() + (*a)->compiled_invocation_count()));\n+  \/\/ compiled_invocation_count() returns int64_t, forcing the entire expression\n+  \/\/ to be evaluated as int64_t. Overflow is not an issue.\n+  int64_t diff = (((*b)->invocation_count() + (*b)->compiled_invocation_count())\n+                - ((*a)->invocation_count() + (*a)->compiled_invocation_count()));\n+  return (diff < 0) ? -1 : (diff > 0) ? 1 : 0;\n@@ -152,1 +155,1 @@\n-  if ((uint32_t)m->invocation_count() + m->compiled_invocation_count() >= 1) {\n+  if (m->invocation_count() + m->compiled_invocation_count() >= 1) {\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}