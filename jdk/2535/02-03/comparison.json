{"files":[{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/threadSMR.hpp\"\n@@ -1005,0 +1006,2 @@\n+      ThreadsListHandle tlh;\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1024,0 +1027,2 @@\n+      ThreadsListHandle tlh;\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1109,0 +1114,2 @@\n+      ThreadsListHandle tlh;\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1128,0 +1135,2 @@\n+      ThreadsListHandle tlh;\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2937,2 +2937,0 @@\n-  \/\/ A nested ThreadsListHandle will grab the Threads_lock so create\n-  \/\/ tlh before we resolve throwable.\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,4 +280,9 @@\n-\n-  \/\/ If the target JavaThread is not protected, then we return the\n-  \/\/ specified non-NULL string:\n-  return thread->as_Java_thread()->get_thread_name(\"<NOT FILLED IN>\");\n+  oop threadObj = thread->as_Java_thread()->threadObj();\n+  if (threadObj == NULL) {\n+    return \"NULL\";\n+  }\n+  oop name = java_lang_Thread::name(threadObj);\n+  if (name == NULL) {\n+    return \"<NOT FILLED IN>\";\n+  }\n+  return java_lang_String::as_utf8_string(name);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-\/\/ Is the target JavaThread protected by this Thread:\n+\/\/ Is the target JavaThread protected by the calling Thread:\n@@ -487,2 +487,3 @@\n-  if (current() == p) {\n-    \/\/ Current thread is always protected:\n+  Thread* thread = Thread::current();\n+  if (thread == p || thread->is_VM_thread()) {\n+    \/\/ Target JavaThread is self or access by the VMThread is always protected:\n@@ -494,1 +495,1 @@\n-  for (SafeThreadsListPtr* stlp = _threads_list_ptr; stlp != NULL; stlp = stlp->previous()) {\n+  for (SafeThreadsListPtr* stlp = thread->_threads_list_ptr; stlp != NULL; stlp = stlp->previous()) {\n@@ -2546,5 +2547,2 @@\n-const char* JavaThread::get_thread_name(const char* default_name) const {\n-  Thread* thread = Thread::current();\n-  ThreadsListHandle tlh(thread);\n-\n-  if (thread->is_JavaThread_protected(this)) {\n+const char* JavaThread::get_thread_name() const {\n+  if (Thread::is_JavaThread_protected(this)) {\n@@ -2555,0 +2553,19 @@\n+\/\/#ifdef ASSERT\n+  Thread *current_thread = Thread::current();\n+\/\/#endif\n+  \/\/ Use this with -XX:+UseNewCode to diagnose locations that are missing\n+  \/\/ a ThreadsListHandle:\n+  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT\n+  \/\/           \" is not protecting this=\" INTPTR_FORMAT,\n+  \/\/           p2i(current_thread), p2i(this));\n+  guarantee(false, \"current_thread=\" INTPTR_FORMAT\n+            \" is not protecting this=\" INTPTR_FORMAT,\n+            p2i(current_thread), p2i(this));\n+\n+  \/\/ Note: Since this JavaThread isn't protected by a TLH, the call to\n+  \/\/ this->is_handshake_safe_for() may crash, but we have debug bits so...\n+  assert(SafepointSynchronize::is_at_safepoint() ||\n+         this->is_handshake_safe_for(current_thread), \"JavaThread=\"\n+         INTPTR_FORMAT \" is not protected, not at a safepoint and \"\n+         \"not handshake safe.\", p2i(this));\n+\n@@ -2556,1 +2573,1 @@\n-  return (default_name != NULL) ? default_name : Thread::name();\n+  return Thread::name();\n@@ -2917,0 +2934,6 @@\n+void Threads::java_threads_do(JavaThreadIteratorWithHandle* jtiwh_p, ThreadClosure* tc) {\n+  for (; JavaThread *jt = jtiwh_p->next(); ) {\n+    tc->do_thread(jt);\n+  }\n+}\n+\n@@ -2930,0 +2953,5 @@\n+void Threads::threads_do(JavaThreadIteratorWithHandle* jtiwh_p, ThreadClosure* tc) {\n+  java_threads_do(jtiwh_p, tc);\n+  non_java_threads_do(tc);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class JavaThreadIteratorWithHandle;\n@@ -203,2 +204,2 @@\n-  \/\/ Is the target JavaThread protected by this Thread:\n-  bool is_JavaThread_protected(const JavaThread* p);\n+  \/\/ Is the target JavaThread protected by the calling Thread:\n+  static bool is_JavaThread_protected(const JavaThread* p);\n@@ -1541,1 +1542,1 @@\n-  const char* get_thread_name(const char* default_name = NULL) const;\n+  const char* get_thread_name() const;\n@@ -1787,0 +1788,1 @@\n+  static void java_threads_do(JavaThreadIteratorWithHandle* jtiwh_p, ThreadClosure* tc);\n@@ -1789,0 +1791,1 @@\n+  static void threads_do(JavaThreadIteratorWithHandle* jtiwh_p, ThreadClosure* tc);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -847,2 +847,2 @@\n-    MutexLocker ml(Threads_lock);\n-    Threads::threads_do(&vmtcc);\n+    JavaThreadIteratorWithHandle jtiwh;\n+    Threads::threads_do(&jtiwh, &vmtcc);\n@@ -1619,1 +1619,1 @@\n-  void do_unlocked();\n+  void do_string_allocs();\n@@ -1635,3 +1635,0 @@\n-\/\/\n-\/\/ Called with Threads_lock held\n-\/\/\n@@ -1639,1 +1636,0 @@\n-  assert(Threads_lock->owned_by_self(), \"Must hold Threads_lock\");\n@@ -1662,2 +1658,1 @@\n-\/\/ Called without Threads_lock, we can allocate String objects.\n-void ThreadTimesClosure::do_unlocked() {\n+void ThreadTimesClosure::do_string_allocs() {\n@@ -1707,2 +1702,2 @@\n-    MutexLocker ml(THREAD, Threads_lock);\n-    Threads::threads_do(&ttc);\n+    JavaThreadIteratorWithHandle jtiwh;\n+    Threads::threads_do(&jtiwh, &ttc);\n@@ -1710,1 +1705,1 @@\n-  ttc.do_unlocked();\n+  ttc.do_string_allocs();\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"}]}