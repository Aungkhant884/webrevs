{"files":[{"patch":"@@ -1006,0 +1006,2 @@\n+      ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1009,1 +1011,0 @@\n-        MutexLocker mu(Threads_lock);\n@@ -1026,0 +1027,2 @@\n+      ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1029,1 +1032,0 @@\n-        MutexLocker mu(Threads_lock);\n@@ -1112,0 +1114,2 @@\n+      ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1115,1 +1119,0 @@\n-        MutexLocker mu(Threads_lock);\n@@ -1132,0 +1135,2 @@\n+      ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+      assert(tlh.includes(ct), \"ct=\" INTPTR_FORMAT \" exited unexpectedly.\", p2i(ct));\n@@ -1135,1 +1140,0 @@\n-        MutexLocker mu(Threads_lock);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2937,2 +2937,0 @@\n-  \/\/ A nested ThreadsListHandle will grab the Threads_lock so create\n-  \/\/ tlh before we resolve throwable.\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,46 @@\n+\/\/ Is the target JavaThread protected by the calling Thread\n+\/\/ or by some other mechanism:\n+bool Thread::is_JavaThread_protected(const JavaThread* p) {\n+  \/\/ Do the simplest check first:\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ The target is protected since JavaThreads cannot exit\n+    \/\/ while we're at a safepoint.\n+    return true;\n+  }\n+\n+  \/\/ Now make the simple checks based on who the caller is:\n+  Thread* current_thread = Thread::current();\n+  if (current_thread == p || Threads_lock->owner() == current_thread) {\n+    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+    \/\/ but we already have the current thread so check directly.\n+    return true;\n+  }\n+\n+  \/\/ Check the ThreadsLists associated with the calling thread (if any)\n+  \/\/ to see if one of them protects the target JavaThread:\n+  for (SafeThreadsListPtr* stlp = current_thread->_threads_list_ptr;\n+       stlp != NULL; stlp = stlp->previous()) {\n+    if (stlp->list()->includes(p)) {\n+      \/\/ The target JavaThread is protected by this ThreadsList:\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+  guarantee(false, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+            INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+\n+  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+  \/\/ we'll be able to figure out what protection mechanism is missing.\n+  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+         \" is not protected and not handshake safe.\", p2i(p));\n+\n+  \/\/ The target JavaThread is not protected so it is not safe to query:\n+  return false;\n+}\n+\n@@ -2522,1 +2568,1 @@\n-\/\/ seen prior to having it's threadObj set (eg JNI attaching threads and\n+\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n@@ -2526,8 +2572,3 @@\n-#ifdef ASSERT\n-  \/\/ early safepoints can hit while current thread does not yet have TLS\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Current JavaThreads are allowed to get their own name without\n-    \/\/ the Threads_lock.\n-    if (Thread::current() != this) {\n-      assert_locked_or_safepoint_or_handshake(Threads_lock, this);\n-    }\n+  if (Thread::is_JavaThread_protected(this)) {\n+    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n+    return get_thread_name_string();\n@@ -2535,2 +2576,3 @@\n-#endif \/\/ ASSERT\n-  return get_thread_name_string();\n+\n+  \/\/ The target JavaThread is not protected so we return the default:\n+  return Thread::name();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -204,0 +204,4 @@\n+  \/\/ Is the target JavaThread protected by the calling Thread\n+  \/\/ or by some other mechanism:\n+  static bool is_JavaThread_protected(const JavaThread* p);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}