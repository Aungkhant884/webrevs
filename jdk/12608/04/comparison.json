{"files":[{"patch":"@@ -397,0 +397,110 @@\n+    \/**\n+     * Returns the angle theta from the conversion of rectangular\n+     * coordinates (x, y) to polar coordinates (r, theta).\n+     *\n+     * Method :\n+     *      1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).\n+     *      2. Reduce x to positive by (if x and y are unexceptional):\n+     *              ARG (x+iy) = arctan(y\/x)           ... if x > 0,\n+     *              ARG (x+iy) = pi - arctan[y\/(-x)]   ... if x < 0,\n+     *\n+     * Special cases:\n+     *\n+     *      ATAN2((anything), NaN ) is NaN;\n+     *      ATAN2(NAN , (anything) ) is NaN;\n+     *      ATAN2(+-0, +(anything but NaN)) is +-0  ;\n+     *      ATAN2(+-0, -(anything but NaN)) is +-pi ;\n+     *      ATAN2(+-(anything but 0 and NaN), 0) is +-pi\/2;\n+     *      ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;\n+     *      ATAN2(+-(anything but INF and NaN), -INF) is +-pi;\n+     *      ATAN2(+-INF,+INF ) is +-pi\/4 ;\n+     *      ATAN2(+-INF,-INF ) is +-3pi\/4;\n+     *      ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi\/2;\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Atan2 {\n+        private Atan2() {throw new UnsupportedOperationException();}\n+\n+        private static final double\n+            tiny    = 1.0e-300,\n+            pi_o_4  = 0x1.921fb54442d18p-1,  \/\/ 7.8539816339744827900E-01\n+            pi_o_2  = 0x1.921fb54442d18p0,   \/\/ 1.5707963267948965580E+00\n+            pi_lo   = 0x1.1a62633145c07p-53; \/\/ 1.2246467991473531772E-16\n+\n+        static double compute(double y, double x) {\n+            double z;\n+            int k, m, hx, hy, ix, iy;\n+            \/*unsigned*\/ int lx, ly;\n+\n+            hx = __HI(x);\n+            ix = hx & 0x7fff_ffff;\n+            lx = __LO(x);\n+            hy = __HI(y);\n+            iy = hy&0x7fff_ffff;\n+            ly = __LO(y);\n+            if (Double.isNaN(x) || Double.isNaN(y))\n+                return x + y;\n+            if (((hx - 0x3ff0_0000) | lx) == 0) \/\/ x = 1.0\n+                return StrictMath.atan(y);\n+            m = ((hy >> 31) & 1)|((hx >> 30) & 2);  \/\/ 2*sign(x) + sign(y)\n+\n+            \/\/ when y = 0\n+            if ((iy | ly) == 0) {\n+                switch(m) {\n+                case 0:\n+                case 1: return y;               \/\/ atan(+\/-0, +anything)  = +\/-0\n+                case 2: return  Math.PI + tiny; \/\/ atan(+0,   -anything)  =  pi\n+                case 3: return -Math.PI - tiny; \/\/ atan(-0,   -anything)  = -pi\n+                }\n+            }\n+            \/\/ when x = 0\n+            if ((ix | lx) == 0) {\n+                return (hy < 0)?  -pi_o_2 - tiny : pi_o_2 + tiny;\n+            }\n+\n+            \/\/ when x is INF\n+            if (ix == 0x7ff0_0000) {\n+                if (iy == 0x7ff0_0000) {\n+                    switch(m) {\n+                    case 0: return  pi_o_4 + tiny;      \/\/ atan(+INF, +INF)\n+                    case 1: return -pi_o_4 - tiny;      \/\/ atan(-INF, +INF)\n+                    case 2: return  3.0*pi_o_4 + tiny;  \/\/ atan(+INF, -INF)\n+                    case 3: return -3.0*pi_o_4 - tiny;  \/\/ atan(-INF, -INF)\n+                    }\n+                } else {\n+                    switch(m) {\n+                    case 0: return  0.0;                \/\/ atan(+..., +INF)\n+                    case 1: return -0.0;                \/\/ atan(-..., +INF)\n+                    case 2: return  Math.PI + tiny;     \/\/ atan(+..., -INF)\n+                    case 3: return -Math.PI - tiny;     \/\/ atan(-..., -INF)\n+                    }\n+                }\n+            }\n+            \/\/ when y is INF\n+            if (iy == 0x7ff0_0000) {\n+                return (hy < 0)? -pi_o_2 - tiny : pi_o_2 + tiny;\n+            }\n+\n+            \/\/ compute y\/x\n+            k = (iy - ix) >> 20;\n+            if (k > 60) {   \/\/ |y\/x| >  2**60\n+                z = pi_o_2+0.5*pi_lo;\n+            } else if (hx < 0 && k < -60) { \/\/ |y|\/x < -2**60\n+                z = 0.0;\n+            } else { \/\/ safe to do y\/x\n+                z = StrictMath.atan(Math.abs(y\/x));\n+            }\n+            switch (m) {\n+            case 0:  return  z;                     \/\/ atan(+, +)\n+            case 1:  return -z;                     \/\/ atan(-, +)\n+            case 2:  return  Math.PI - (z - pi_lo); \/\/ atan(+, -)\n+            default: return (z - pi_lo) - Math.PI;  \/\/ atan(-, -), case 3\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -550,1 +550,3 @@\n-    public static native double atan2(double y, double x);\n+    public static double atan2(double y, double x) {\n+        return FdLibm.Atan2.compute(y, x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4984407\n+ * @bug 4984407 8302028\n@@ -33,1 +33,1 @@\n-    static int testAtan2Case(double input1, double input2, double expected) {\n+    public static void main(String... args) {\n@@ -35,2 +35,0 @@\n-        failures += Tests.test(\"StrictMath.atan2\", input1, input2, StrictMath::atan2, expected);\n-        failures += Tests.test(\"Math.atan2\",       input1, input2, Math::atan2,       expected);\n@@ -38,1 +36,7 @@\n-        return failures;\n+        failures += testAtan2();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing atan2 incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n@@ -41,1 +45,4 @@\n-    static int testAtan2() {\n+    \/**\n+     * Special cases from the spec interspersed with test cases.\n+     *\/\n+    private static int testAtan2() {\n@@ -43,0 +50,14 @@\n+        double NaNd      = Double.NaN;\n+        double MIN_VALUE = Double.MIN_VALUE;\n+        double MIN_NORM  = Double.MIN_NORMAL;\n+        double MAX_VALUE = Double.MAX_VALUE;\n+        double InfinityD = Double.POSITIVE_INFINITY;\n+        double PI        = Math.PI;\n+\n+        \/*\n+         * If either argument is NaN, then the result is NaN.\n+         *\/\n+        for(double nan : Tests.NaNs) {\n+            failures += testAtan2Case(nan, 0.0, NaNd);\n+            failures += testAtan2Case(0.0, nan, NaNd);\n+        }\n@@ -45,1 +66,160 @@\n-            {-3.0,      Double.POSITIVE_INFINITY,       -0.0},\n+            \/*\n+             * If the first argument is positive zero and the second\n+             * argument is positive, or the first argument is positive\n+             * and finite and the second argument is positive\n+             * infinity, then the result is positive zero.\n+             *\/\n+            {+0.0,       MIN_VALUE, +0.0},\n+            {+0.0,       MIN_NORM,  +0.0},\n+            {+0.0,       1.0,       +0.0},\n+            {+0.0,       MAX_VALUE, +0.0},\n+            {+0.0,       InfinityD, +0.0},\n+\n+            {MIN_VALUE,  InfinityD, +0.0},\n+            {MIN_NORM,   InfinityD, +0.0},\n+            {1.0,        InfinityD, +0.0},\n+            {MAX_VALUE,  InfinityD, +0.0},\n+            {MIN_VALUE,  InfinityD, +0.0},\n+\n+            \/*\n+             * If the first argument is negative zero and the second\n+             * argument is positive, or the first argument is negative\n+             * and finite and the second argument is positive\n+             * infinity, then the result is negative zero.\n+             *\/\n+            {-0.0,       MIN_VALUE, -0.0},\n+            {-0.0,       MIN_NORM,  -0.0},\n+            {-0.0,       1.0,       -0.0},\n+            {-0.0,       MAX_VALUE, -0.0},\n+            {-0.0,       InfinityD, -0.0},\n+\n+            {-MIN_VALUE, InfinityD, -0.0},\n+            {-MIN_NORM,  InfinityD, -0.0},\n+            {-1.0,       InfinityD, -0.0},\n+            {-MAX_VALUE, InfinityD, -0.0},\n+\n+            \/*\n+             * If the first argument is positive zero and the second\n+             * argument is negative, or the first argument is positive\n+             * and finite and the second argument is negative\n+             * infinity, then the result is the double value closest\n+             * to pi.\n+             *\/\n+            {+0.0,      -MIN_VALUE, PI},\n+            {+0.0,      -MIN_NORM,  PI},\n+            {+0.0,      -1.0,       PI},\n+            {+0.0,      -MAX_VALUE, PI},\n+            {+0.0,      -InfinityD, PI},\n+\n+            {MIN_VALUE, -InfinityD, PI},\n+            {MIN_NORM,  -InfinityD, PI},\n+            {1.0,       -InfinityD, PI},\n+            {MAX_VALUE, -InfinityD, PI},\n+\n+            \/*\n+             * If the first argument is negative zero and the second\n+             * argument is negative, or the first argument is negative\n+             * and finite and the second argument is negative\n+             * infinity, then the result is the double value closest\n+             * to -pi.\n+             *\/\n+            {-0.0,      -MIN_VALUE, -PI},\n+            {-0.0,      -MIN_NORM,  -PI},\n+            {-0.0,      -1.0,       -PI},\n+            {-0.0,      -MAX_VALUE, -PI},\n+            {-0.0,      -InfinityD, -PI},\n+\n+            {-MIN_VALUE, -InfinityD, -PI},\n+            {-MIN_NORM,  -InfinityD, -PI},\n+            {-1.0,       -InfinityD, -PI},\n+            {-MAX_VALUE, -InfinityD, -PI},\n+\n+            \/*\n+             * If the first argument is positive and the second\n+             * argument is positive zero or negative zero, or the\n+             * first argument is positive infinity and the second\n+             * argument is finite, then the result is the double value\n+             * closest to pi\/2.\n+             *\/\n+            {MIN_VALUE,  +0.0,        PI\/2.0},\n+            {MIN_NORM,   +0.0,        PI\/2.0},\n+            {1.0,        +0.0,        PI\/2.0},\n+            {MAX_VALUE,  +0.0,        PI\/2.0},\n+\n+            {MIN_VALUE,  -0.0,        PI\/2.0},\n+            {MIN_VALUE,  -0.0,        PI\/2.0},\n+            {MIN_NORM,   -0.0,        PI\/2.0},\n+            {1.0,        -0.0,        PI\/2.0},\n+            {MAX_VALUE,  -0.0,        PI\/2.0},\n+\n+            {InfinityD,  -MIN_VALUE,  PI\/2.0},\n+            {InfinityD,  -MIN_NORM,   PI\/2.0},\n+            {InfinityD,  -1.0,        PI\/2.0},\n+            {InfinityD,  -MAX_VALUE,  PI\/2.0},\n+\n+            {InfinityD,  MIN_VALUE,   PI\/2.0},\n+            {InfinityD,  MIN_NORM,    PI\/2.0},\n+            {InfinityD,  1.0,         PI\/2.0},\n+            {InfinityD,  MAX_VALUE,   PI\/2.0},\n+\n+            \/*\n+             * If the first argument is negative and the second argument is\n+             * positive zero or negative zero, or the first argument is\n+             * negative infinity and the second argument is finite, then the\n+             * result is the double value closest to -pi\/2.\n+             *\/\n+            {-MIN_VALUE,  +0.0,        -PI\/2.0},\n+            {-MIN_NORM,   +0.0,        -PI\/2.0},\n+            {-1.0,        +0.0,        -PI\/2.0},\n+            {-MAX_VALUE,  +0.0,        -PI\/2.0},\n+\n+            {-MIN_VALUE,  -0.0,        -PI\/2.0},\n+            {-MIN_VALUE,  -0.0,        -PI\/2.0},\n+            {-MIN_NORM,   -0.0,        -PI\/2.0},\n+            {-1.0,        -0.0,        -PI\/2.0},\n+            {-MAX_VALUE,  -0.0,        -PI\/2.0},\n+\n+            {-InfinityD,  -MIN_VALUE,  -PI\/2.0},\n+            {-InfinityD,  -MIN_NORM,   -PI\/2.0},\n+            {-InfinityD,  -1.0,        -PI\/2.0},\n+            {-InfinityD,  -MAX_VALUE,  -PI\/2.0},\n+\n+            {-InfinityD,  MIN_VALUE,   -PI\/2.0},\n+            {-InfinityD,  MIN_NORM,    -PI\/2.0},\n+            {-InfinityD,  1.0,         -PI\/2.0},\n+            {-InfinityD,  MAX_VALUE,   -PI\/2.0},\n+\n+            \/*\n+             * If both arguments are positive infinity, then the result is the\n+             * double value closest to pi\/4.\n+             *\/\n+            {InfinityD,  InfinityD,     PI\/4.0},\n+\n+            \/*\n+             * If the first argument is positive infinity and the\n+             * second argument is negative infinity, then the result\n+             * is the double value closest to 3*pi\/4.\n+             *\/\n+            \/\/ Note: in terms of computation, the result of the double\n+            \/\/ expression\n+            \/\/   3*PI\/4.0\n+            \/\/ is the same as a high-precision decimal value of pi\n+            \/\/ scaled accordingly and rounded to double:\n+            \/\/   BigDecimal bdPi = new BigDecimal(\"3.14159265358979323846264338327950288419716939937510\");\n+            \/\/   bdPi.multiply(BigDecimal.valueOf(3)).divide(BigDecimal.valueOf(4)).doubleValue();\n+            {InfinityD,  -InfinityD,     3*PI\/4.0},\n+\n+            \/*\n+             * If the first argument is negative infinity and the second\n+             * argument is positive infinity, then the result is the double\n+             * value closest to -pi\/4.\n+             *\/\n+            {-InfinityD,  InfinityD,     -PI\/4.0},\n+\n+            \/*\n+             * If both arguments are negative infinity, then the result is the\n+             * double value closest to -3*pi\/4.\n+             *\/\n+            {-InfinityD,  -InfinityD,     -3*PI\/4.0},\n+\n+            {-3.0,         InfinityD,     -0.0},\n@@ -49,1 +229,1 @@\n-            failures+=testAtan2Case(testCase[0], testCase[1], testCase[2]);\n+            failures += testAtan2Case(testCase[0], testCase[1], testCase[2]);\n@@ -55,1 +235,1 @@\n-    public static void main(String... argv) {\n+    private static int testAtan2Case(double input1, double input2, double expected) {\n@@ -57,0 +237,2 @@\n+        failures += Tests.test(\"StrictMath.atan2\", input1, input2, StrictMath::atan2, expected);\n+        failures += Tests.test(\"Math.atan2\",       input1, input2, Math::atan2,       expected);\n@@ -58,7 +240,1 @@\n-        failures += testAtan2();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing atan2 incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n+        return failures;\n","filename":"test\/jdk\/java\/lang\/Math\/Atan2Tests.java","additions":193,"deletions":17,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4851638\n+ * @key randomness\n+ * @summary Tests for StrictMath.atan2\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build Atan2Tests\n+ * @run main Atan2Tests\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+\n+\/**\n+ * The tests in ..\/Math\/Atan2Tests.java test properties that should\n+ * hold for any atan2 implementation, including the FDLIBM-based one\n+ * required for StrictMath.atan2.  Therefore, the test cases in\n+ * ..\/Math\/Atan2Tests.java are run against both the Math and\n+ * StrictMath versions of atan2.  The role of this test is to verify\n+ * that the FDLIBM atan2 algorithm is being used by running golden\n+ * file tests on values that may vary from one conforming atan2\n+ * implementation to another.\n+ *\/\n+\n+public class Atan2Tests {\n+    private Atan2Tests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing atan2 incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.atan2 against transliteration port of atan2.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+\n+        double MIN_VALUE = Double.MIN_VALUE;\n+        double MIN_NORM  = Double.MIN_NORMAL;\n+        double MAX_VALUE = Double.MAX_VALUE;\n+        double InfinityD = Double.POSITIVE_INFINITY;\n+        double PI        = Math.PI;\n+\n+        \/\/ The exact special cases for infinity, NaN, zero,\n+        \/\/ etc. inputs are checked in the Math tests.\n+\n+        \/\/ Test exotic NaN bit patterns\n+        double[][] exoticNaNs = {\n+            {Double.longBitsToDouble(0x7FF0_0000_0000_0001L), 0.0},\n+            {0.0, Double.longBitsToDouble(0x7FF0_0000_0000_0001L)},\n+            {Double.longBitsToDouble(0xFFF_00000_0000_0001L), 0.0},\n+            {0.0, Double.longBitsToDouble(0xFFF0_0000_0000_0001L)},\n+            {Double.longBitsToDouble(0x7FF_00000_7FFF_FFFFL), 0.0},\n+            {0.0, Double.longBitsToDouble(0x7FF0_7FFF_0000_FFFFL)},\n+            {Double.longBitsToDouble(0xFFF_00000_7FFF_FFFFL), 0.0},\n+            {0.0, Double.longBitsToDouble(0xFFF0_7FFF_0000_FFFFL)},\n+        };\n+\n+        for (double[] exoticNaN: exoticNaNs) {\n+            failures += testAtan2Case(exoticNaN[0], exoticNaN[1],\n+                                      FdlibmTranslit.atan2(exoticNaN[0], exoticNaN[1]));\n+        }\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[][] decisionPoints = {\n+            \/\/ If x == 1, return atan(y)\n+            {0.5, Math.nextDown(1.0)},\n+            {0.5, 1.0},\n+            {0.5, Math.nextUp(1.0)},\n+\n+            { MIN_VALUE,  MIN_VALUE},\n+            { MIN_VALUE, -MIN_VALUE},\n+            {-MIN_VALUE,  MIN_VALUE},\n+            {-MIN_VALUE, -MIN_VALUE},\n+\n+            { MAX_VALUE,  MAX_VALUE},\n+            { MAX_VALUE, -MAX_VALUE},\n+            {-MAX_VALUE,  MAX_VALUE},\n+            {-MAX_VALUE, -MAX_VALUE},\n+\n+            { MIN_VALUE,  MAX_VALUE},\n+            { MAX_VALUE,  MIN_VALUE},\n+\n+            {-MIN_VALUE,  MAX_VALUE},\n+            {-MAX_VALUE,  MIN_VALUE},\n+\n+            {MIN_VALUE,  -MAX_VALUE},\n+            {MAX_VALUE,  -MIN_VALUE},\n+\n+            {-MIN_VALUE, -MAX_VALUE},\n+            {-MAX_VALUE, -MIN_VALUE},\n+        };\n+\n+        for (double[] decisionPoint: decisionPoints) {\n+            failures += testAtan2Case(decisionPoint[0], decisionPoint[1],\n+                                      FdlibmTranslit.atan2(decisionPoint[0], decisionPoint[1]));\n+        }\n+\n+        \/\/ atan2 looks at the ratio y\/x and executes different code\n+        \/\/ paths accordingly: tests for 2^60 and 2^-60.\n+\n+        double y = 1.0;\n+        double x = 0x1.0p60;\n+        double increment_x = Math.ulp(x);\n+        double increment_y = Math.ulp(y);\n+        y = y - 128*increment_y;\n+        x = x - 128*increment_x;\n+\n+        for (int i = 0; i < 256; i++, x += increment_x) {\n+            for (int j = 0; j < 256; j++, y += increment_y) {\n+                failures += testAtan2Case( y,  x, FdlibmTranslit.atan2( y,  x));\n+                failures += testAtan2Case(-y,  x, FdlibmTranslit.atan2(-y,  x));\n+                failures += testAtan2Case( y, -x, FdlibmTranslit.atan2( y, -x));\n+                failures += testAtan2Case(-y, -x, FdlibmTranslit.atan2(-y, -x));\n+\n+                failures += testAtan2Case( 2.0*y,  2.0*x, FdlibmTranslit.atan2( 2.0*y,  2.0*x));\n+                failures += testAtan2Case(-2.0*y,  2.0*x, FdlibmTranslit.atan2(-2.0*y,  2.0*x));\n+                failures += testAtan2Case( 2.0*y, -2.0*x, FdlibmTranslit.atan2( 2.0*y, -2.0*x));\n+                failures += testAtan2Case(-2.0*y, -2.0*x, FdlibmTranslit.atan2(-2.0*y, -2.0*x));\n+\n+                failures += testAtan2Case( 0.5*y,  0.5*x, FdlibmTranslit.atan2( 0.5*y,  0.5*x));\n+                failures += testAtan2Case(-0.5*y,  0.5*x, FdlibmTranslit.atan2(-0.5*y,  0.5*x));\n+                failures += testAtan2Case( 0.5*y, -0.5*x, FdlibmTranslit.atan2( 0.5*y, -0.5*x));\n+                failures += testAtan2Case(-0.5*y, -0.5*x, FdlibmTranslit.atan2(-0.5*y, -0.5*x));\n+\n+                \/\/ Switch argument position\n+                failures += testAtan2Case( x,  y, FdlibmTranslit.atan2( x,  y));\n+                failures += testAtan2Case(-x,  y, FdlibmTranslit.atan2(-x,  y));\n+                failures += testAtan2Case( x, -y, FdlibmTranslit.atan2( x, -y));\n+                failures += testAtan2Case(-x, -y, FdlibmTranslit.atan2(-x, -y));\n+\n+                failures += testAtan2Case( 0.5*x,  0.5*y, FdlibmTranslit.atan2( 0.5*x,  0.5*y));\n+                failures += testAtan2Case(-0.5*x,  0.5*y, FdlibmTranslit.atan2(-0.5*x,  0.5*y));\n+                failures += testAtan2Case( 0.5*x, -0.5*y, FdlibmTranslit.atan2( 0.5*x, -0.5*y));\n+                failures += testAtan2Case(-0.5*x, -0.5*y, FdlibmTranslit.atan2(-0.5*x, -0.5*y));\n+            }\n+        }\n+\n+        \/\/ Check random values\n+        for (int k = 0; k < 200; k++ ) {\n+            y = random.nextDouble();\n+            x = random.nextDouble();\n+            failures += testAtan2Case(y, x, FdlibmTranslit.atan2(y, x));\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAtan2Case(double input1, double input2, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"StrictMath.atan2(double)\", input1, input2,\n+                               StrictMath::atan2, expected);\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Atan2Tests.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026 8301444\n+ * @bug 8301833 8302026 8301444 8302028\n@@ -133,1 +133,1 @@\n-         \/\/ new BinaryTestCase(\"atan2\", FdlibmTranslit::atan2, StrictMath::atan2, 20, 20),\n+            new BinaryTestCase(\"atan2\", FdlibmTranslit::atan2, StrictMath::atan2, 20, 20),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+    public static double atan2(double y, double x) {\n+        return Atan2.compute(y, x);\n+    }\n+\n@@ -399,0 +403,104 @@\n+    \/**\n+     * Returns the angle theta from the conversion of rectangular\n+     * coordinates (x, y) to polar coordinates (r, theta).\n+     *\n+     * Method :\n+     *      1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).\n+     *      2. Reduce x to positive by (if x and y are unexceptional):\n+     *              ARG (x+iy) = arctan(y\/x)           ... if x > 0,\n+     *              ARG (x+iy) = pi - arctan[y\/(-x)]   ... if x < 0,\n+     *\n+     * Special cases:\n+     *\n+     *      ATAN2((anything), NaN ) is NaN;\n+     *      ATAN2(NAN , (anything) ) is NaN;\n+     *      ATAN2(+-0, +(anything but NaN)) is +-0  ;\n+     *      ATAN2(+-0, -(anything but NaN)) is +-pi ;\n+     *      ATAN2(+-(anything but 0 and NaN), 0) is +-pi\/2;\n+     *      ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;\n+     *      ATAN2(+-(anything but INF and NaN), -INF) is +-pi;\n+     *      ATAN2(+-INF,+INF ) is +-pi\/4 ;\n+     *      ATAN2(+-INF,-INF ) is +-3pi\/4;\n+     *      ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi\/2;\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Atan2 {\n+        private static final double\n+            tiny  = 1.0e-300,\n+            zero  = 0.0,\n+            pi_o_4  = 7.8539816339744827900E-01, \/* 0x3FE921FB, 0x54442D18 *\/\n+            pi_o_2  = 1.5707963267948965580E+00, \/* 0x3FF921FB, 0x54442D18 *\/\n+            pi      = 3.1415926535897931160E+00, \/* 0x400921FB, 0x54442D18 *\/\n+            pi_lo   = 1.2246467991473531772E-16; \/* 0x3CA1A626, 0x33145C07 *\/\n+\n+        static double compute(double y, double x) {\n+            double z;\n+            int k,m,hx,hy,ix,iy;\n+            \/*unsigned*\/ int lx,ly;\n+\n+            hx = __HI(x); ix = hx&0x7fffffff;\n+            lx = __LO(x);\n+            hy = __HI(y); iy = hy&0x7fffffff;\n+            ly = __LO(y);\n+            if(((ix|((lx|-lx)>>>31))>0x7ff00000)|| \/\/ Note unsigned shifts\n+               ((iy|((ly|-ly)>>>31))>0x7ff00000))    \/* x or y is NaN *\/\n+                return x+y;\n+            if(((hx-0x3ff00000)|lx)==0) return atan(y);   \/* x=1.0 *\/\n+            m = ((hy>>31)&1)|((hx>>30)&2);  \/* 2*sign(x)+sign(y) *\/\n+\n+            \/* when y = 0 *\/\n+            if((iy|ly)==0) {\n+                switch(m) {\n+                case 0:\n+                case 1: return y;       \/* atan(+-0,+anything)=+-0 *\/\n+                case 2: return  pi+tiny;\/* atan(+0,-anything) = pi *\/\n+                case 3: return -pi-tiny;\/* atan(-0,-anything) =-pi *\/\n+                }\n+            }\n+            \/* when x = 0 *\/\n+            if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;\n+\n+            \/* when x is INF *\/\n+            if(ix==0x7ff00000) {\n+                if(iy==0x7ff00000) {\n+                    switch(m) {\n+                    case 0: return  pi_o_4+tiny;\/* atan(+INF,+INF) *\/\n+                    case 1: return -pi_o_4-tiny;\/* atan(-INF,+INF) *\/\n+                    case 2: return  3.0*pi_o_4+tiny;\/*atan(+INF,-INF)*\/\n+                    case 3: return -3.0*pi_o_4-tiny;\/*atan(-INF,-INF)*\/\n+                    }\n+                } else {\n+                    switch(m) {\n+                    case 0: return  zero  ;     \/* atan(+...,+INF) *\/\n+                    case 1: return -1.0*zero  ; \/* atan(-...,+INF) *\/\n+                    case 2: return  pi+tiny  ;  \/* atan(+...,-INF) *\/\n+                    case 3: return -pi-tiny  ;  \/* atan(-...,-INF) *\/\n+                    }\n+                }\n+            }\n+            \/* when y is INF *\/\n+            if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;\n+\n+            \/* compute y\/x *\/\n+            k = (iy-ix)>>20;\n+            if(k > 60) z=pi_o_2+0.5*pi_lo;  \/* |y\/x| >  2**60 *\/\n+            else if(hx<0&&k<-60) z=0.0;     \/* |y|\/x < -2**60 *\/\n+            else z=atan(Math.abs(y\/x));         \/* safe to do y\/x *\/\n+            switch (m) {\n+            case 0: return       z  ;   \/* atan(+,+) *\/\n+            case 1:\n+                \/\/ original:__HI(z) ^= 0x80000000;\n+                z = __HI(z, __HI(z) ^ 0x80000000);\n+                return       z  ;   \/* atan(-,+) *\/\n+            case 2: return  pi-(z-pi_lo);\/* atan(+,-) *\/\n+            default: \/* case 3 *\/\n+                return  (z-pi_lo)-pi;\/* atan(-,-) *\/\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"}]}