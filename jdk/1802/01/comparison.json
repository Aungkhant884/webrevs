{"files":[{"patch":"@@ -135,1 +135,1 @@\n-void VMError::reset_signal_handlers() {\n+void VMError::install_secondary_signal_handler() {\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-void VMError::reset_signal_handlers() {\n+void VMError::install_secondary_signal_handler() {\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-    if (Debugging || VMError::fatal_error_in_progress())  return NULL;\n+    if (Debugging || VMError::is_error_reported())  return NULL;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -543,2 +543,1 @@\n-  if (VMError::is_error_reported() &&\n-      VMError::get_first_error_tid() == os::current_thread_id()) {\n+  if (VMError::is_error_reported_in_current_thread()) {\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -87,2 +86,1 @@\n-  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();\n-  if (error_handling_thread) {\n+  if (VMError::is_error_reported_in_current_thread()) {\n@@ -94,1 +92,0 @@\n-\n@@ -98,2 +95,1 @@\n-  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();\n-  if (error_handling_thread) {\n+  if (VMError::is_error_reported_in_current_thread()) {\n@@ -107,1 +103,0 @@\n-\n@@ -109,2 +104,1 @@\n-  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();\n-  if (error_handling_thread) {\n+  if (VMError::is_error_reported_in_current_thread()) {\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-    return !VMError::fatal_error_in_progress();\n+    return !VMError::is_error_reported();\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,4 +66,19 @@\n-bool VMError::_error_reported = false;\n-\n-\/\/ call this when the VM is dying--it might loosen some asserts\n-bool VMError::is_error_reported() { return _error_reported; }\n+bool              VMError::coredump_status;\n+char              VMError::coredump_message[O_BUFLEN];\n+int               VMError::_current_step;\n+const char*       VMError::_current_step_info;\n+volatile jlong    VMError::_reporting_start_time = -1;\n+volatile bool     VMError::_reporting_did_timeout = false;\n+volatile jlong    VMError::_step_start_time = -1;\n+volatile bool     VMError::_step_did_timeout = false;\n+volatile intptr_t VMError::_first_error_tid = -1;\n+int               VMError::_id;\n+const char*       VMError::_message;\n+char              VMError::_detail_msg[1024];\n+Thread*           VMError::_thread;\n+address           VMError::_pc;\n+void*             VMError::_siginfo;\n+void*             VMError::_context;\n+const char*       VMError::_filename;\n+int               VMError::_lineno;\n+size_t            VMError::_size;\n@@ -83,1 +98,1 @@\n-const char *env_list[] = {\n+static const char* env_list[] = {\n@@ -154,3 +169,0 @@\n-bool VMError::coredump_status;\n-char VMError::coredump_message[O_BUFLEN];\n-\n@@ -361,29 +373,4 @@\n-\/\/ This is the main function to report a fatal error. Only one thread can\n-\/\/ call this function, so we don't need to worry about MT-safety. But it's\n-\/\/ possible that the error handler itself may crash or die on an internal\n-\/\/ error, for example, when the stack\/heap is badly damaged. We must be\n-\/\/ able to handle recursive errors that happen inside error handler.\n-\/\/\n-\/\/ Error reporting is done in several steps. If a crash or internal error\n-\/\/ occurred when reporting an error, the nested signal\/exception handler\n-\/\/ can skip steps that are already (or partially) done. Error reporting will\n-\/\/ continue from the next step. This allows us to retrieve and print\n-\/\/ information that may be unsafe to get after a fatal error. If it happens,\n-\/\/ you may find nested report_and_die() frames when you look at the stack\n-\/\/ in a debugger.\n-\/\/\n-\/\/ In general, a hang in error handler is much worse than a crash or internal\n-\/\/ error, as it's harder to recover from a hang. Deadlock can happen if we\n-\/\/ try to grab a lock that is already owned by current thread, or if the\n-\/\/ owner is blocked forever (e.g. in os::infinite_sleep()). If possible, the\n-\/\/ error handler and all the functions it called should avoid grabbing any\n-\/\/ lock. An important thing to notice is that memory allocation needs a lock.\n-\/\/\n-\/\/ We should avoid using large stack allocated buffers. Many errors happen\n-\/\/ when stack space is already low. Making things even worse is that there\n-\/\/ could be nested report_and_die() calls on stack (see above). Only one\n-\/\/ thread can report error, so large buffers are statically allocated in data\n-\/\/ segment.\n-\n-int          VMError::_current_step;\n-const char*  VMError::_current_step_info;\n+\/\/ Returns true if at least one thread reported a fatal error and fatal error handling is in process.\n+bool VMError::is_error_reported() {\n+  return _first_error_tid != -1;\n+}\n@@ -391,4 +378,4 @@\n-volatile jlong VMError::_reporting_start_time = -1;\n-volatile bool VMError::_reporting_did_timeout = false;\n-volatile jlong VMError::_step_start_time = -1;\n-volatile bool VMError::_step_did_timeout = false;\n+\/\/ Returns true if the current thread reported a fatal error.\n+bool VMError::is_error_reported_in_current_thread() {\n+  return _first_error_tid == os::current_thread_id();\n+}\n@@ -425,0 +412,26 @@\n+\/\/ This is the main function to report a fatal error. Only one thread can\n+\/\/ call this function, so we don't need to worry about MT-safety. But it's\n+\/\/ possible that the error handler itself may crash or die on an internal\n+\/\/ error, for example, when the stack\/heap is badly damaged. We must be\n+\/\/ able to handle recursive errors that happen inside error handler.\n+\/\/\n+\/\/ Error reporting is done in several steps. If a crash or internal error\n+\/\/ occurred when reporting an error, the nested signal\/exception handler\n+\/\/ can skip steps that are already (or partially) done. Error reporting will\n+\/\/ continue from the next step. This allows us to retrieve and print\n+\/\/ information that may be unsafe to get after a fatal error. If it happens,\n+\/\/ you may find nested report_and_die() frames when you look at the stack\n+\/\/ in a debugger.\n+\/\/\n+\/\/ In general, a hang in error handler is much worse than a crash or internal\n+\/\/ error, as it's harder to recover from a hang. Deadlock can happen if we\n+\/\/ try to grab a lock that is already owned by current thread, or if the\n+\/\/ owner is blocked forever (e.g. in os::infinite_sleep()). If possible, the\n+\/\/ error handler and all the functions it called should avoid grabbing any\n+\/\/ lock. An important thing to notice is that memory allocation needs a lock.\n+\/\/\n+\/\/ We should avoid using large stack allocated buffers. Many errors happen\n+\/\/ when stack space is already low. Making things even worse is that there\n+\/\/ could be nested report_and_die() calls on stack (see above). Only one\n+\/\/ thread can report error, so large buffers are statically allocated in data\n+\/\/ segment.\n@@ -657,1 +670,0 @@\n-\n@@ -698,1 +710,0 @@\n-\n@@ -1243,2 +1254,0 @@\n-volatile intptr_t VMError::_first_error_tid = -1;\n-\n@@ -1301,11 +1310,0 @@\n-int         VMError::_id;\n-const char* VMError::_message;\n-char        VMError::_detail_msg[1024];\n-Thread*     VMError::_thread;\n-address     VMError::_pc;\n-void*       VMError::_siginfo;\n-void*       VMError::_context;\n-const char* VMError::_filename;\n-int         VMError::_lineno;\n-size_t      VMError::_size;\n-\n@@ -1398,3 +1396,0 @@\n-    \/\/ first time\n-    _error_reported = true;\n-\n@@ -1423,1 +1418,1 @@\n-    reset_signal_handlers();\n+    install_secondary_signal_handler();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":55,"deletions":60,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -87,7 +87,3 @@\n-  static bool _error_reported;\n-\n- public:\n-\n-  \/\/ set signal handlers on Solaris\/Linux or the default exception filter\n-  \/\/ on Windows, to handle recursive crashes.\n-  static void reset_signal_handlers();\n+  \/\/ Install secondary signal handler to handle secondary faults during error reporting\n+  \/\/ (see VMError::crash_handler)\n+  static void install_secondary_signal_handler();\n@@ -174,5 +170,0 @@\n-  \/\/ check to see if fatal error reporting is in progress\n-  static bool fatal_error_in_progress() { return _first_error_tid != -1; }\n-\n-  static intptr_t get_first_error_tid() { return _first_error_tid; }\n-\n@@ -183,1 +174,2 @@\n-  \/\/ Support for avoiding multiple asserts\n+  \/\/ Returns true if at least one thread reported a fatal error and\n+  \/\/  fatal error handling is in process.\n@@ -186,0 +178,3 @@\n+  \/\/ Returns true if the current thread reported a fatal error.\n+  static bool is_error_reported_in_current_thread();\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"}]}