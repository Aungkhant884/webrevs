{"files":[{"patch":"@@ -57,2 +57,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics() :\n-  ShenandoahHeuristics(),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(heap_stats),\n@@ -87,1 +87,1 @@\n-  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t capacity    = _heap_stats->soft_max_capacity();\n@@ -131,1 +131,1 @@\n-  size_t available = ShenandoahHeap::heap()->free_set()->available();\n+  size_t available = _heap_stats->available();\n@@ -199,5 +199,4 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n-  size_t allocated = heap->bytes_allocated_since_gc_start();\n+  size_t max_capacity = _heap_stats->max_capacity();\n+  size_t capacity = _heap_stats->soft_max_capacity();\n+  size_t available = _heap_stats->available();\n+  size_t allocated = _heap_stats->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -54,0 +55,11 @@\n+\/*\n+ * The adaptive heuristic tracks the allocation behavior and average cycle\n+ * time of the application. It attempts to start a cycle with enough time\n+ * to complete before the available memory is exhausted. It errors on the\n+ * side of starting cycles early to avoid allocation failures (degenerated\n+ * cycles).\n+ *\n+ * This heuristic limits the number of regions for evacuation such that the\n+ * evacuation reserve is respected. This helps it avoid allocation failures\n+ * during evacuation. It preferentially selects regions with the most garbage.\n+ *\/\n@@ -56,1 +68,1 @@\n-  ShenandoahAdaptiveHeuristics();\n+  ShenandoahAdaptiveHeuristics(ShenandoahHeapStats* heap_stats);\n@@ -102,0 +114,1 @@\n+protected:\n@@ -106,1 +119,1 @@\n-  \/\/ tend to over estimate the rate at which mutators will deplete the\n+  \/\/ tend to overestimate the rate at which mutators will deplete the\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics() : ShenandoahHeuristics() {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(heap_stats) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+\/*\n+ * This is a diagnostic heuristic that continuously runs collections\n+ * cycles and adds every region with any garbage to the collection set.\n+ *\/\n@@ -32,1 +36,1 @@\n-  ShenandoahAggressiveHeuristics();\n+  ShenandoahAggressiveHeuristics(ShenandoahHeapStats* heap_stats);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics() : ShenandoahHeuristics() {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(heap_stats) {\n@@ -48,5 +49,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _heap_stats->max_capacity();\n+  size_t capacity = _heap_stats->soft_max_capacity();\n+  size_t available = _heap_stats->available();\n@@ -68,1 +67,1 @@\n-  size_t bytes_allocated = heap->bytes_allocated_since_gc_start();\n+  size_t bytes_allocated = _heap_stats->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+\/*\n+ * This heuristic has simpler triggers than the adaptive heuristic. The\n+ * size of the collection set is limited to 3\/4 of available memory.\n+ *\/\n@@ -32,1 +36,1 @@\n-  ShenandoahCompactHeuristics();\n+  ShenandoahCompactHeuristics(ShenandoahHeapStats* heap_stats);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHHEAPSTATS_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHHEAPSTATS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * The purpose of this interface is to decouple the heuristics from a\n+ * direct dependency on the ShenandoahHeap singleton instance. This is\n+ * done to facilitate future unit testing of the heuristics and to support\n+ * future operational modes of Shenandoah in which the heap may be split\n+ * into generations.\n+ *\/\n+class ShenandoahHeapStats {\n+public:\n+  virtual size_t soft_max_capacity() const = 0;\n+  virtual size_t max_capacity() const = 0;\n+  virtual size_t available() const = 0;\n+  virtual size_t bytes_allocated_since_gc_start() const = 0;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHHEAPSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -45,1 +45,2 @@\n-ShenandoahHeuristics::ShenandoahHeuristics() :\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahHeapStats* heap_stats) :\n+  _heap_stats(heap_stats),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -61,0 +63,5 @@\n+\/*\n+ * Shenandoah heuristics are primarily responsible for deciding when to start\n+ * a collection cycle and choosing which regions will be evacuated during the\n+ * cycle.\n+ *\/\n@@ -72,0 +79,3 @@\n+  \/\/ Source of information about the heap\n+  ShenandoahHeapStats* _heap_stats;\n+\n@@ -96,1 +106,1 @@\n-  ShenandoahHeuristics();\n+  ShenandoahHeuristics(ShenandoahHeapStats* heap_stats);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+ShenandoahPassiveHeuristics::ShenandoahPassiveHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(heap_stats) {}\n+\n@@ -56,1 +59,1 @@\n-  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n+  size_t max_capacity = _heap_stats->max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,9 @@\n+\/*\n+ * The passive heuristic is for use only with the passive mode. In\n+ * the passive mode, Shenandoah only performs STW (i.e., degenerated)\n+ * collections. All the barriers are disabled and there are no concurrent\n+ * activities. Therefore, this heuristic _never_ triggers a cycle. It\n+ * will select regions for evacuation based on ShenandoahEvacReserve,\n+ * ShenandoahEvacWaste and ShenandoahGarbageThreshold. Note that it does\n+ * not attempt to evacuate regions with more garbage.\n+ *\/\n@@ -32,0 +41,2 @@\n+  ShenandoahPassiveHeuristics(ShenandoahHeapStats* heap_stats);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics() : ShenandoahHeuristics() {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahHeapStats* heap_stats) :\n+  ShenandoahHeuristics(heap_stats) {\n@@ -43,5 +44,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _heap_stats->max_capacity();\n+  size_t capacity = _heap_stats->soft_max_capacity();\n+  size_t available = _heap_stats->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+\/*\n+ * The static heuristic will trigger cycles if the available memory falls\n+ * below ShenandoahMinFreeThreshold percentage of total capacity. This\n+ * heuristic will attempt to evacuation any region with any garbage.\n+ *\/\n@@ -32,1 +37,1 @@\n-  ShenandoahStaticHeuristics();\n+  ShenandoahStaticHeuristics(ShenandoahHeapStats* heap_stats);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -70,0 +71,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -71,1 +73,1 @@\n-    return new ShenandoahAggressiveHeuristics();\n+    return new ShenandoahAggressiveHeuristics(heap);\n@@ -73,1 +75,1 @@\n-    return new ShenandoahStaticHeuristics();\n+    return new ShenandoahStaticHeuristics(heap);\n@@ -75,1 +77,1 @@\n-    return new ShenandoahAdaptiveHeuristics();\n+    return new ShenandoahAdaptiveHeuristics(heap);\n@@ -77,1 +79,1 @@\n-    return new ShenandoahCompactHeuristics();\n+    return new ShenandoahCompactHeuristics(heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -62,1 +63,1 @@\n-  return new ShenandoahPassiveHeuristics();\n+  return new ShenandoahPassiveHeuristics(ShenandoahHeap::heap());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -58,0 +59,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -59,1 +61,1 @@\n-    return new ShenandoahAggressiveHeuristics();\n+    return new ShenandoahAggressiveHeuristics(heap);\n@@ -61,1 +63,1 @@\n-    return new ShenandoahStaticHeuristics();\n+    return new ShenandoahStaticHeuristics(heap);\n@@ -63,1 +65,1 @@\n-    return new ShenandoahAdaptiveHeuristics();\n+    return new ShenandoahAdaptiveHeuristics(heap);\n@@ -65,1 +67,1 @@\n-    return new ShenandoahCompactHeuristics();\n+    return new ShenandoahCompactHeuristics(heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -665,0 +665,4 @@\n+size_t ShenandoahHeap::available() const {\n+  return free_set()->available();\n+}\n+\n@@ -1902,1 +1906,1 @@\n-size_t ShenandoahHeap::bytes_allocated_since_gc_start() {\n+size_t ShenandoahHeap::bytes_allocated_since_gc_start() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeapStats.hpp\"\n@@ -119,1 +120,1 @@\n-class ShenandoahHeap : public CollectedHeap {\n+class ShenandoahHeap : public CollectedHeap, public ShenandoahHeapStats {\n@@ -194,1 +195,1 @@\n-  size_t bytes_allocated_since_gc_start();\n+  size_t bytes_allocated_since_gc_start() const override;\n@@ -199,1 +200,1 @@\n-  size_t soft_max_capacity() const;\n+  size_t soft_max_capacity() const override;\n@@ -204,0 +205,1 @@\n+  size_t available()         const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}