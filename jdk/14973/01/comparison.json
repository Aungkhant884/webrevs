{"files":[{"patch":"@@ -1363,1 +1363,2 @@\n-                                                  ConNode* zero, Invariance& invar, Deoptimization::DeoptReason reason) {\n+                                                  ConNode* zero,\n+                                                  Invariance& invar, Deoptimization::DeoptReason reason, Node*& max_value) {\n@@ -1460,2 +1461,4 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                                          offset, init, limit, stride, rng, overflow, reason);\n+    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj,\n+                                                          upper_bound_proj, scale,\n+                                                          offset, init, limit, stride, rng, overflow, reason,\n+                                                          max_value);\n@@ -1489,3 +1492,6 @@\n-                                                             IfProjNode* predicate_proj, IfProjNode* upper_bound_proj,\n-                                                             int scale, Node* offset, Node* init, Node* limit, jint stride,\n-                                                             Node* rng, bool& overflow, Deoptimization::DeoptReason reason) {\n+                                                             IfProjNode* predicate_proj,\n+                                                             IfProjNode* upper_bound_proj, int scale, Node* offset,\n+                                                             Node* init, Node* limit,\n+                                                             jint stride, Node* rng, bool& overflow,\n+                                                             Deoptimization::DeoptReason reason,\n+                                                             Node*& max_value) {\n@@ -1498,0 +1504,2 @@\n+  add_template_assertion_predicate_helper(predicate_proj, reason, upper_bound_proj, bol,\n+                                          overflow ? Op_If : iff->Opcode());\n@@ -1508,10 +1516,5 @@\n-  Node* init_stride = loop->_head->as_CountedLoop()->stride();\n-  Node* opaque_stride = new OpaqueLoopStrideNode(C, init_stride);\n-  register_new_node(opaque_stride, new_proj);\n-  Node* max_value = new SubINode(opaque_stride, init_stride);\n-  register_new_node(max_value, new_proj);\n-  max_value = new AddINode(opaque_init, max_value);\n-  register_new_node(max_value, new_proj);\n-  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-  max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-  register_new_node(max_value, predicate_proj);\n+  if (max_value == nullptr) {\n+    \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n+    iv_phi_assertion_predicate_condition(loop->_head->as_CountedLoop(), new_proj, opaque_init, max_value);\n+    new_proj = add_template_assertion_predicate_helper(predicate_proj, reason, new_proj, bol, Op_If);\n+  }\n@@ -1521,5 +1524,1 @@\n-  opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  C->add_template_assertion_predicate_opaq(opaque_bol);\n-  register_new_node(opaque_bol, new_proj);\n-  new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n-  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n+  add_template_assertion_predicate_helper(predicate_proj, reason, new_proj, bol, overflow ? Op_If : iff->Opcode());\n@@ -1532,0 +1531,10 @@\n+IfProjNode* PhaseIdealLoop::add_template_assertion_predicate_helper(IfProjNode* predicate_proj, Deoptimization::DeoptReason reason,\n+                                                                    IfProjNode* new_proj, BoolNode* bol, const int opcode) {\n+  Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); \/\/ This will go away once loop opts are over\n+  C->add_template_assertion_predicate_opaq(opaque_bol);\n+  register_new_node(opaque_bol, new_proj);\n+  new_proj = create_new_if_for_predicate(predicate_proj, nullptr, reason, opcode);\n+  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n+  return new_proj;\n+}\n+\n@@ -1628,0 +1637,1 @@\n+  Node* max_value = nullptr;\n@@ -1659,1 +1669,1 @@\n-                                               Deoptimization::Reason_predicate) | hoisted;\n+                                               Deoptimization::Reason_predicate, max_value) | hoisted;\n@@ -1675,2 +1685,3 @@\n-        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profiled_loop_predicate_proj, cl, zero, invar,\n-                                               Deoptimization::Reason_profile_predicate) | hoisted;\n+        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profiled_loop_predicate_proj, cl, zero,\n+                                               invar,\n+                                               Deoptimization::Reason_profile_predicate, max_value) | hoisted;\n@@ -1691,1 +1702,2 @@\n-      hoisted = loop_predication_impl_helper(loop, if_proj, profiled_loop_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+      hoisted = loop_predication_impl_helper(loop, if_proj, profiled_loop_predicate_proj, cl, zero, invar,\n+                                             Deoptimization::Reason_profile_predicate, max_value) | hoisted;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1335,0 +1335,2 @@\n+    \/\/ go through a temporary list to preserve predicate's order\n+    Node_List predicates;\n@@ -1340,0 +1342,7 @@\n+      predicates.push(predicate);\n+      predicate = predicate->in(0)->in(0);\n+    }\n+    while (predicates.size() > 0) {\n+      predicate = predicates.pop();\n+      iff = predicate->in(0)->as_If();\n+      uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n@@ -1378,1 +1387,0 @@\n-      predicate = predicate->in(0)->in(0);\n@@ -2008,0 +2016,2 @@\n+  \/\/ go through a temporary list to preserve predicate's order\n+  Node_List predicates;\n@@ -2014,0 +2024,7 @@\n+    predicates.push(entry);\n+    entry = entry->in(0)->in(0);\n+  }\n+  while (predicates.size() > 0) {\n+    entry = predicates.pop();\n+    IfNode* iff = entry->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n@@ -2031,1 +2048,0 @@\n-    entry = entry->in(0)->in(0);\n@@ -2049,0 +2065,2 @@\n+  \/\/ go through a temporary list to preserve predicate's order\n+  Node_List predicates;\n@@ -2055,0 +2073,7 @@\n+    predicates.push(ctrl);\n+    ctrl = ctrl->in(0)->in(0);\n+  }\n+  while (predicates.size() > 0) {\n+    ctrl = predicates.pop();\n+    IfNode* iff = ctrl->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n@@ -2060,1 +2085,0 @@\n-    ctrl = ctrl->in(0)->in(0);\n@@ -2807,0 +2831,4 @@\n+  return add_assertion_predicate_test(loop, ctrl, overflow, bol);\n+}\n+\n+Node* PhaseIdealLoop::add_assertion_predicate_test(IdealLoopTree* loop, Node* ctrl, bool overflow, BoolNode* bol) {\n@@ -2910,0 +2938,1 @@\n+  Node* max_value = nullptr;\n@@ -3017,9 +3046,5 @@\n-          Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n-          register_new_node(opaque_stride, loop_entry);\n-          Node* max_value = new SubINode(opaque_stride, cl->stride());\n-          register_new_node(max_value, loop_entry);\n-          max_value = new AddINode(opaque_init, max_value);\n-          register_new_node(max_value, loop_entry);\n-          \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-          max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-          register_new_node(max_value, loop_entry);\n+          if (max_value == nullptr) {\n+            \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n+            BoolNode* bol = iv_phi_assertion_predicate_condition(cl, loop_entry, opaque_init, max_value);\n+            loop_entry = add_assertion_predicate_test(loop, loop_entry, true, bol);\n+          }\n@@ -3140,0 +3165,31 @@\n+BoolNode* PhaseIdealLoop::iv_phi_assertion_predicate_condition(const CountedLoopNode* cl, Node* ctrl,\n+                                                               Node* opaque_init,\n+                                                               Node*& max_value) {\n+  const Type* phi_t = cl->phi()->bottom_type();\n+  Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n+  register_new_node(opaque_stride, ctrl);\n+  max_value = new SubINode(opaque_stride, cl->stride());\n+  register_new_node(max_value, ctrl);\n+  max_value = new AddINode(opaque_init, max_value);\n+  register_new_node(max_value, ctrl);\n+  BoolNode* bol;\n+  if (cl->stride_con() > 0) {\n+    Node* lo = _igvn.intcon(phi_t->is_int()->_lo);\n+    set_ctrl(lo, C->root());\n+    Node* cmp = new CmpINode(max_value, lo);\n+    register_new_node(cmp, ctrl);\n+    bol = new BoolNode(cmp, BoolTest::ge);\n+    register_new_node(bol, ctrl);\n+  } else {\n+    Node* hi = _igvn.intcon(phi_t->is_int()->_hi);\n+    set_ctrl(hi, C->root());\n+    Node* cmp = new CmpINode(max_value, hi);\n+    register_new_node(cmp, ctrl);\n+    bol = new BoolNode(cmp, BoolTest::le);\n+    register_new_node(bol, ctrl);\n+  }\n+  max_value = new CastIINode(max_value, phi_t);\n+  register_new_node(max_value, ctrl);\n+  return bol;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":68,"deletions":12,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1363,1 +1363,1 @@\n-                                    Invariance& invar, Deoptimization::DeoptReason reason);\n+                                    Invariance& invar, Deoptimization::DeoptReason reason, Node*& max_value);\n@@ -1368,3 +1368,5 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj, IfProjNode* predicate_proj,\n-                                               IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n-                                               jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason);\n+  IfProjNode*\n+  add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj, IfProjNode* predicate_proj,\n+                                   IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n+                                   jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason,\n+                                   Node*& max_value);\n@@ -1720,0 +1722,8 @@\n+\n+  Node* add_assertion_predicate_test(IdealLoopTree* loop, Node* ctrl, bool overflow, BoolNode* bol);\n+\n+  IfProjNode* add_template_assertion_predicate_helper(IfProjNode* predicate_proj, Deoptimization::DeoptReason reason,\n+                                                      IfProjNode* new_proj, BoolNode* bol, const int opcode);\n+\n+  BoolNode* iv_phi_assertion_predicate_condition(const CountedLoopNode* cl, Node* ctrl, Node* opaque_init,\n+                                                 Node*& max_value);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308504\n+ * @summary CastII for assert predicate becomes top but control flow path is not proven dead\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:RepeatCompilation=100\n+ *                   -XX:+StressIGVN\n+ *                   -XX:CompileOnly=compiler.loopopts.TestLoopPredicateCastIIBecomesTop::test\n+ *                   compiler.loopopts.TestLoopPredicateCastIIBecomesTop\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestLoopPredicateCastIIBecomesTop {\n+    static int N;\n+\n+    static void test() {\n+        int arr[] = new int[N];\n+        short s = 1;\n+        double d = 1.0;\n+        for (int i = 49; i > 8; i--) {\n+            for (int j = 7; j > i; j -= 3) {\n+                if (i == 8) {\n+                    s *= arr[1];\n+                }\n+                d = arr[j];\n+            }\n+        }\n+        Double.doubleToLongBits(d);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopPredicateCastIIBecomesTop.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}