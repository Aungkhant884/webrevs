{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -692,6 +692,8 @@\n-            List<SignatureScheme> sss = new LinkedList<>();\n-            for (int id : crm.algorithmIds) {\n-                SignatureScheme ss = SignatureScheme.valueOf(id);\n-                if (ss != null) {\n-                    sss.add(ss);\n-                }\n+            List<SignatureScheme> sss =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc.sslConfig,\n+                            chc.algorithmConstraints, chc.negotiatedProtocol,\n+                            crm.algorithmIds);\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n@@ -699,0 +701,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,0 +282,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n@@ -333,1 +337,1 @@\n-                    \"received CertificateRequest handshake message\");\n+                    \"received ClientHello handshake message\");\n@@ -506,0 +510,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +481,1 @@\n-    private KeyManager createKeyManager(\n+    static KeyManager createKeyManager(\n@@ -537,1 +537,1 @@\n-    private TrustManager createTrustManager(\n+    static TrustManager createTrustManager(\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    private static boolean isOpen(SSLEngine engine) {\n+    static boolean isOpen(SSLEngine engine) {\n@@ -243,1 +243,1 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,381 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.2.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=true\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+\n+public class SigAlgosExtTestWithTLS12 extends SSLEngineTemplate {\n+\n+    private static final boolean CLIENT_AUTH\n+            = Boolean.getBoolean(\"test.clientAuth\");\n+    private static final boolean EXPECT_FAIL\n+            = Boolean.getBoolean(\"test.expectFail\");\n+\n+    private static final String[] CA_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n+            \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n+            \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n+            \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n+            \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n+            \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n+            \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n+            \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n+            \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n+            \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n+            \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n+            \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n+            \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n+            \"J8FXY9Nj\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_KEYS = new String[] {\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n+            \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n+            \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n+            \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n+            \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"\n+    };\n+\n+    private static final String[] EE_ALGS = new String[] {\n+            \"EC\",\n+            \"EC\"\n+    };\n+\n+    private static final String[] EE_ALIASES = new String[] {\n+            \"EC-SHA256\",\n+            \"EC-SHA384\"\n+    };\n+\n+    private static final Map<Integer, String> SIG_SCHEMES_MAP = Map.of(\n+            0x0403, \"ecdsa_secp256r1_sha256\",\n+            0x0503, \"ecdsa_secp384r1_sha384\");\n+\n+    private static final int TLS_HS_CLI_HELLO = 1;\n+    private static final int TLS_HS_CERT_REQ = 13;\n+    private static final int HELLO_EXT_SIG_ALGS = 13;\n+\n+    public SigAlgosExtTestWithTLS12() throws Exception {\n+        super();\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager for client use.\n+     *\/\n+    public KeyManager createClientKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createClientTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public KeyManager createServerKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createServerTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(CLIENT_AUTH);\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n+        return clientEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+\n+        try {\n+            new SigAlgosExtTestWithTLS12().run();\n+            if (EXPECT_FAIL) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (EXPECT_FAIL && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            clientEngine.wrap(clientOut, cTOs);\n+            cTOs.flip();\n+\n+            \/\/ Consume the ClientHello and get the server flight of handshake\n+            \/\/ messages.  We expect that it will be one TLS record containing\n+            \/\/ multiple handshake messages, one of which is a CertificateRequest\n+            \/\/ when the client authentication is required.\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            \/\/ Wrap the server flight\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+\n+            if (CLIENT_AUTH && EXPECT_FAIL) {\n+                twistCertReqMsg(sTOc);\n+            }\n+\n+            clientEngine.unwrap(sTOc, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                clientEngine.closeOutbound();\n+                dataDone = true;\n+                serverEngine.closeOutbound();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Twists signature schemes in CertificateRequest message for negative\n+     * client authentication cases.\n+     *\n+     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n+     *      that the position of the ByteBuffer is on the first byte of the TLS\n+     *      record header.\n+     *\n+     * @throws SSLException if the incoming ByteBuffer does not contain a\n+     *      well-formed TLS message.\n+     *\/\n+    private static void twistCertReqMsg(\n+            ByteBuffer tlsRecord) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        \/\/ Simple sanity checks\n+        if (type != 22) {\n+            throw new SSLException(\"Not a handshake: Type = \" + type);\n+        } else if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+\n+            if (msgType == TLS_HS_CERT_REQ) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                int bufPos = tlsRecord.position();\n+                ByteBuffer buf = tlsRecord.slice(bufPos, msgLen);\n+\n+                \/\/ Replace the signature scheme with an unknown value\n+                twistSigSchemesCertReq(buf, (short) 0x0000);\n+                byte[] bufBytes = new byte[buf.limit()];\n+                buf.get(bufBytes);\n+                tlsRecord.put(bufPos, bufBytes);\n+\n+                break;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+    }\n+\n+    \/**\n+     * Replace the signature schemes in CertificateRequest message with an\n+     * alternative value.  It is assumed that the provided ByteBuffer has its\n+     * position set at the first byte of the CertificateRequest message body\n+     * (AFTER the handshake header) and contains the entire CR message.  Upon\n+     * successful completion of this method the ByteBuffer will have its\n+     * position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the CertificateRequest bytes\n+     * @param altSigScheme an alternative signature scheme\n+     *\/\n+    private static void twistSigSchemesCertReq(ByteBuffer data,\n+                                               Short altSigScheme) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            System.err.println(\n+                    \"Use alternative signature scheme: \" + altSigScheme);\n+            data.putShort(data.position(), altSigScheme);\n+        }\n+\n+        data.reset();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.3, but doesn't cover client authentication.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS13\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS13\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSocket;\n+\n+public class SigAlgosExtTestWithTLS13 extends SSLSocketTemplate {\n+\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getClientContextParameters());\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        socket.setEnabledProtocols(new String[] { \"TLSv1.3\" });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean expectFail = Boolean.getBoolean(\"test.expectFail\");\n+        try {\n+            new SigAlgosExtTestWithTLS13().run();\n+            if (expectFail) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (expectFail && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}