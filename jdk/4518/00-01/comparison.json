{"files":[{"patch":"@@ -136,1 +136,1 @@\n-  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct enabled\n+  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct are enabled\n@@ -193,1 +193,1 @@\n-    \/\/ the pids controller is not there on older Linux distros\n+    \/\/ pids controller is optional. All other controllers are required\n@@ -198,1 +198,1 @@\n-    if (! cg_infos[i]._enabled) {\n+    if (log_is_enabled(Debug, os, container) && !cg_infos[i]._enabled) {\n@@ -424,1 +424,1 @@\n-  if (!cg_infos[PIDS_IDX]._data_complete) {\n+  if (log_is_enabled(Debug, os, container) && !cg_infos[PIDS_IDX]._data_complete) {\n@@ -554,0 +554,19 @@\n+\n+jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n+  \/\/ it is also found in the pids controller\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+    jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,10 @@\n+\n+char* CgroupV1Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(pidsmax);\n+}\n+\n@@ -251,2 +261,1 @@\n- *    -1 for no setup\n- *    -3 for \"max\" (special value)\n+ *    -1 for unlimited\n@@ -257,12 +266,2 @@\n-\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: \" JLONG_FORMAT, JLONG_FORMAT, pidsmax);\n-  if (pidsmax < 0) {\n-    \/\/ check for potential special value\n-    char myline[1024];\n-    int err2;\n-    err2 = subsystem_file_line_contents(_pids, \"\/pids.max\", NULL, \"%1023s\", myline);\n-    if (err2 != 0) {\n-      if (strncmp(myline, \"max\", 3) == 0) return -3;\n-    }\n-  }\n+  char * pidsmax_str = pids_max_val();\n+  jlong pidsmax = limit_from_str(pidsmax_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+    char * pids_max_val();\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,18 +206,0 @@\n-jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == NULL) {\n-    return OSCONTAINER_ERROR;\n-  }\n-  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n-  }\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n-  }\n-  os::free(limit_str);\n-  return (jlong)limit;\n-}\n-\n@@ -247,12 +229,5 @@\n-jlong CgroupV2Subsystem::pids_max() {\n-  \/\/ we have to handle the special \"max\" value\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: \" JLONG_FORMAT, JLONG_FORMAT, pidsmax);\n-  \/\/ not a number -> could be \"max\"\n-  if (pidsmax < 0) {\n-    char myline[1024];\n-    int err2;\n-    err2 = subsystem_file_line_contents(_unified, \"\/pids.max\", NULL, \"%1023s\", myline);\n-    if (err2 != 0) {\n-      if (strncmp(myline, \"max\", 3) == 0) return -3;\n-    }\n+char* CgroupV2Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n@@ -260,0 +235,15 @@\n+  return os::strdup(pidsmax);\n+}\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::pids_max() {\n+  char * pidsmax_str = pids_max_val();\n+  jlong pidsmax = limit_from_str(pidsmax_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":20,"deletions":30,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    jlong limit_from_str(char* limit_str);\n+    char *pids_max_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2316,5 +2316,1 @@\n-    if (j == -3) {\n-      st->print_cr(\"max\");\n-    } else {\n-      st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n-    }\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+    public static final String MAX_VAL = \"max\";\n+\n+    public static long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,1 +415,2 @@\n-        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(pids, \"pids.max\"));\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(pids, \"pids.max\");\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    private static final String MAX_VAL = \"max\";\n@@ -152,8 +151,1 @@\n-        return limitFromString(quota);\n-    }\n-\n-    private long limitFromString(String strVal) {\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        return Long.parseLong(strVal);\n+        return CgroupSubsystem.limitFromString(quota);\n@@ -254,1 +246,1 @@\n-        return limitFromString(strVal);\n+        return CgroupSubsystem.limitFromString(strVal);\n@@ -282,1 +274,1 @@\n-        long swapLimit = limitFromString(strVal);\n+        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n@@ -313,1 +305,1 @@\n-        return limitFromString(softLimitStr);\n+        return CgroupSubsystem.limitFromString(softLimitStr);\n@@ -319,1 +311,1 @@\n-        return limitFromString(pidsMaxStr);\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-            \"pids    9   80  1\";  \/\/  the 3 did not match 9\n+            \"pids    9   80  1\";  \/\/ hierarchy has to match procSelfCgroupHybridContent\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}