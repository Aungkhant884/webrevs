{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+\/\/ controller names have to match the *_IDX indices\n+static const char* cg_controller_name[] = { \"cpu\", \"cpuset\", \"cpuacct\", \"memory\", \"pids\" };\n+\n@@ -42,0 +45,1 @@\n+  CgroupV1Controller* pids = NULL;\n@@ -96,12 +100,19 @@\n-    if (strcmp(info._name, \"memory\") == 0) {\n-      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n-      memory->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuset\") == 0) {\n-      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuset->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpu\") == 0) {\n-      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpu->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuacct->set_subsystem_path(info._cgroup_path);\n+    if (info._data_complete) { \/\/ pids controller might have incomplete data\n+      if (strcmp(info._name, \"memory\") == 0) {\n+        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuset\") == 0) {\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpu\") == 0) {\n+        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"pids\") == 0) {\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids->set_subsystem_path(info._cgroup_path);\n+      }\n+    } else {\n+      log_debug(os, container)(\"CgroupInfo for %s not complete\", cg_controller_name[i]);\n@@ -111,1 +122,1 @@\n-  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, pids, memory);\n@@ -125,1 +136,1 @@\n-  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct enabled\n@@ -127,1 +138,2 @@\n-  bool all_controllers_enabled;\n+  \/\/ pids might not be enabled on older Linux distros (SLES 12.1, RHEL 7.1)\n+  bool all_required_controllers_enabled;\n@@ -139,4 +151,3 @@\n-      log_debug(os, container)(\"Can't open %s, %s\",\n-                               proc_cgroups, os::strerror(errno));\n-      *flags = INVALID_CGROUPS_GENERIC;\n-      return false;\n+    log_debug(os, container)(\"Can't open %s, %s\", proc_cgroups, os::strerror(errno));\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -170,0 +181,5 @@\n+    } else if (strcmp(name, \"pids\") == 0) {\n+      log_info(os, container)(\"Detected optional pids controller entry in %s\", proc_cgroups);\n+      cg_infos[PIDS_IDX]._name = os::strdup(name);\n+      cg_infos[PIDS_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[PIDS_IDX]._enabled = (enabled == 1);\n@@ -175,1 +191,1 @@\n-  all_controllers_enabled = true;\n+  all_required_controllers_enabled = true;\n@@ -177,2 +193,8 @@\n-    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n-    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+    \/\/ the pids controller is not there on older Linux distros\n+    if (i != PIDS_IDX) {\n+      is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+      all_required_controllers_enabled = all_required_controllers_enabled && cg_infos[i]._enabled;\n+    }\n+    if (! cg_infos[i]._enabled) {\n+      log_debug(os, container)(\"controller %s is not enabled\\n\", cg_controller_name[i]);\n+    }\n@@ -181,2 +203,2 @@\n-  if (!all_controllers_enabled) {\n-    \/\/ one or more controllers disabled, disable container support\n+  if (!all_required_controllers_enabled) {\n+    \/\/ one or more required controllers disabled, disable container support\n@@ -223,1 +245,1 @@\n-        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for memory\");\n@@ -226,1 +248,1 @@\n-        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuset\");\n@@ -229,1 +251,1 @@\n-        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpu\");\n@@ -232,1 +254,1 @@\n-        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuacc\");\n@@ -234,0 +256,4 @@\n+      } else if (strcmp(token, \"pids\") == 0) {\n+        assert(hierarchy_id == cg_infos[PIDS_IDX]._hierarchy_id, \"\/proc\/cgroups (%d) and \/proc\/self\/cgroup (%d) hierarchy mismatch for pids\",\n+                                                                 cg_infos[PIDS_IDX]._hierarchy_id, hierarchy_id);\n+        cg_infos[PIDS_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -284,1 +310,1 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n@@ -291,0 +317,2 @@\n+     *\n+     * 44 31 0:39 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:23 - cgroup cgroup rw,pids\n@@ -336,0 +364,6 @@\n+        } else if (strcmp(token, \"pids\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[PIDS_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[PIDS_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[PIDS_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[PIDS_IDX]._data_complete = true;\n@@ -390,0 +424,4 @@\n+  if (!cg_infos[PIDS_IDX]._data_complete) {\n+    log_debug(os, container)(\"Optional cgroup v1 pids subsystem not found\");\n+    \/\/ keep the other controller info, pids is optional\n+  }\n@@ -393,1 +431,0 @@\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":68,"deletions":31,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,2 @@\n-\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n-#define CG_INFO_LENGTH 4\n+\/\/ Five controllers: cpu, cpuset, cpuacct, memory, pids\n+#define CG_INFO_LENGTH 5\n@@ -70,0 +70,1 @@\n+#define PIDS_IDX       4\n@@ -245,0 +246,1 @@\n+    virtual jlong pids_max() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,27 @@\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for no setup\n+ *    -3 for \"max\" (special value)\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::pids_max() {\n+  if (_pids == NULL) return OSCONTAINER_ERROR;\n+\n+  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.max\",\n+                     \"Maximum number of tasks is: \" JLONG_FORMAT, JLONG_FORMAT, pidsmax);\n+  if (pidsmax < 0) {\n+    \/\/ check for potential special value\n+    char myline[1024];\n+    int err2;\n+    err2 = subsystem_file_line_contents(_pids, \"\/pids.max\", NULL, \"%1023s\", myline);\n+    if (err2 != 0) {\n+      if (strncmp(myline, \"max\", 3) == 0) return -3;\n+    }\n+  }\n+  return pidsmax;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,2 @@\n+    jlong pids_max();\n+\n@@ -104,0 +106,1 @@\n+    CgroupV1Controller* _pids = NULL;\n@@ -109,0 +112,1 @@\n+                      CgroupV1Controller* pids,\n@@ -113,0 +117,1 @@\n+      _pids = pids;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -247,0 +247,16 @@\n+jlong CgroupV2Subsystem::pids_max() {\n+  \/\/ we have to handle the special \"max\" value\n+  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.max\",\n+                     \"Maximum number of tasks is: \" JLONG_FORMAT, JLONG_FORMAT, pidsmax);\n+  \/\/ not a number -> could be \"max\"\n+  if (pidsmax < 0) {\n+    char myline[1024];\n+    int err2;\n+    err2 = subsystem_file_line_contents(_unified, \"\/pids.max\", NULL, \"%1023s\", myline);\n+    if (err2 != 0) {\n+      if (strncmp(myline, \"max\", 3) == 0) return -3;\n+    }\n+  }\n+  return pidsmax;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+    jlong pids_max();\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,5 @@\n+\n+jlong OSContainer::pids_max() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->pids_max();\n+}\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+  static jlong pids_max();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2222,0 +2222,1 @@\n+    st->print_cr(\"container information not found.\");\n@@ -2310,0 +2311,12 @@\n+  j = OSContainer::OSContainer::pids_max();\n+  st->print(\"maximum number of tasks: \");\n+  if (j > 0) {\n+    st->print_cr(JLONG_FORMAT, j);\n+  } else {\n+    if (j == -3) {\n+      st->print_cr(\"max\");\n+    } else {\n+      st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-  CgroupInfo cg_infos[4];\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+    @Override\n+    public long getPidsMax() {\n+        return subsystem.getPidsMax();\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final String PIDS_CTRL = \"pids\";\n@@ -152,0 +153,1 @@\n+            case PIDS_CTRL:     infos.put(PIDS_CTRL, info); break;\n@@ -254,0 +256,1 @@\n+                    case PIDS_CTRL:\n@@ -305,0 +308,1 @@\n+                        case PIDS_CTRL:\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    private CgroupV1SubsystemController pids;\n@@ -129,0 +130,9 @@\n+            case \"pids\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setPidsController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n@@ -173,0 +183,4 @@\n+    private void setPidsController(CgroupV1SubsystemController pids) {\n+        this.pids = pids;\n+    }\n+\n@@ -397,0 +411,6 @@\n+    \/*****************************************************************\n+     *  pids subsystem\n+     ****************************************************************\/\n+    public long getPidsMax() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(pids, \"pids.max\"));\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -316,0 +316,6 @@\n+    @Override\n+    public long getPidsMax() {\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(unified, \"pids.max\");\n+        return limitFromString(pidsMaxStr);\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -355,0 +355,13 @@\n+    \/*****************************************************************\n+     * pids subsystem\n+     ****************************************************************\/\n+\n+    \/**\n+     * Returns the maximum number of tasks that may be created in the Isolation Group.\n+     *\n+     * @return The maximum number of tasks or -1 if the metric is not available.\n+     *         Returns -3 if it is unlimited (\"max\")\n+     *\n+     *\/\n+    public long getPidsMax();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -108,0 +108,1 @@\n+            \"pids 0 1 1\\n\" +\n@@ -171,1 +172,1 @@\n-            \"pids    3   80  1\";\n+            \"pids    9   80  1\";  \/\/  the 3 did not match 9\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}