{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -122,2 +120,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -299,2 +295,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -304,2 +299,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,0 +149,13 @@\n+        public static char decodeSingleOrReplace(int b1, int b2, int p, char replace) {\n+            if (b1 < b1Min || b1 > b1Max || b2 < b2Min || b2 > b2Max)\n+                return replace;\n+            int index = (b1 - b1Min) * dbSegSize + b2 - b2Min;\n+            char c = b2c[p].charAt(index);\n+            if (c == UNMAPPABLE_DECODING)\n+                return replace;\n+            if ((b2cIsSupp[index] & (1 << p)) == 0) {\n+                return c;\n+            }\n+            return replace;\n+        }\n+\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_TW.java.template","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -12335,2 +12335,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -12341,2 +12339,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -12588,2 +12584,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -12593,2 +12588,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/GB18030.java.template","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -215,2 +215,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -221,2 +219,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -487,2 +483,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -492,2 +487,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/IBM29626C.java.template","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,9 +67,2 @@\n-        private final int G0 = 0;\n-        private final int G1 = 1;\n-        private final int G2 = 2;\n-        private final int G3 = 3;\n-        private final int G4 = 4;\n-        private final int SS2 =  0x8E;\n-        private final int SS3 =  0x8F;\n-\n-        private int firstByte, state;\n+        private static final int SS2 =  0x8E;\n+        private static final int SS3 =  0x8F;\n@@ -86,2 +78,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -91,2 +82,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -98,1 +87,1 @@\n-                char outputChar = '\\uFFFD';\n+                char outputChar;\n@@ -160,1 +149,1 @@\n-                    char outputChar = '\\uFFFD';\n+                    char outputChar;\n@@ -215,1 +204,1 @@\n-            if (true && src.hasArray() && dst.hasArray())\n+            if (src.hasArray() && dst.hasArray())\n@@ -221,4 +210,4 @@\n-        private final static String byteToCharTable;\n-        private final static String mappingTableG1;\n-        private final static String mappingTableG2;\n-        private final static String mappingTableG3;\n+        private static final String byteToCharTable;\n+        private static final String mappingTableG1;\n+        private static final String mappingTableG2;\n+        private static final String mappingTableG3;\n@@ -2752,3 +2741,3 @@\n-        private final static String index2;\n-        private final static String index2a;\n-        private final static String index2b;\n+        private static final String index2;\n+        private static final String index2a;\n+        private static final String index2b;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/IBM33722.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,2 +78,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -84,2 +82,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/IBM964.java.template","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -509,2 +507,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -824,2 +820,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -829,4 +824,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n-\n-            int outputSize = 0;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISCII91.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,10 +42,0 @@\n-\n-    private static final byte ISO_ESC = 0x1b;\n-    private static final byte ISO_SI = 0x0f;\n-    private static final byte ISO_SO = 0x0e;\n-    private static final byte ISO_SS2_7 = 0x4e;\n-    private static final byte ISO_SS3_7 = 0x4f;\n-    private static final byte MSB = (byte)0x80;\n-    private static final char REPLACE_CHAR = '\\uFFFD';\n-    private static final byte minDesignatorLength = 3;\n-\n@@ -56,22 +46,1 @@\n-    public CharsetDecoder newDecoder() {\n-        return new Decoder(this);\n-    }\n-\n-    public CharsetEncoder newEncoder() {\n-        return new Encoder(this);\n-    }\n-\n-    protected static class Decoder extends CharsetDecoder {\n-\n-        \/\/ Value to be filled by subclass\n-        protected byte SODesig[][];\n-        protected byte SS2Desig[][] = null;\n-        protected byte SS3Desig[][] = null;\n-\n-        protected CharsetDecoder SODecoder[];\n-        protected CharsetDecoder SS2Decoder[] = null;\n-        protected CharsetDecoder SS3Decoder[] = null;\n-\n-        private static final byte SOFlag = 0;\n-        private static final byte SS2Flag = 1;\n-        private static final byte SS3Flag = 2;\n+    public abstract CharsetDecoder newDecoder();\n@@ -79,3 +48,1 @@\n-        private int curSODes, curSS2Des, curSS3Des;\n-        private boolean shiftout;\n-        private CharsetDecoder tmpDecoder[];\n+    public abstract CharsetEncoder newEncoder();\n@@ -83,10 +50,6 @@\n-        protected Decoder(Charset cs) {\n-            super(cs, 1.0f, 1.0f);\n-        }\n-\n-        protected void implReset() {\n-            curSODes = 0;\n-            curSS2Des = 0;\n-            curSS3Des = 0;\n-            shiftout = false;\n-        }\n+    \/\/ No default Decoder implementation is provided here; the concrete\n+    \/\/ encodings differ enough that most had been specialized for\n+    \/\/ performance reasons, leaving the generic implementation that existed\n+    \/\/ here before JDK-8261418 unused except by ISO2022_KR. As both a\n+    \/\/ simplification and an optimization the implementation was moved\n+    \/\/ there and specialized.\n@@ -94,284 +57,1 @@\n-        private char decode(byte byte1, byte byte2, byte shiftFlag)\n-        {\n-            byte1 |= MSB;\n-            byte2 |= MSB;\n-\n-            byte[] tmpByte = { byte1,byte2 };\n-            char[] tmpChar = new char[1];\n-            int     i = 0,\n-                    tmpIndex = 0;\n-\n-            switch(shiftFlag) {\n-            case SOFlag:\n-                tmpIndex = curSODes;\n-                tmpDecoder = SODecoder;\n-                break;\n-            case SS2Flag:\n-                tmpIndex = curSS2Des;\n-                tmpDecoder = SS2Decoder;\n-                break;\n-            case SS3Flag:\n-                tmpIndex = curSS3Des;\n-                tmpDecoder = SS3Decoder;\n-                break;\n-            }\n-\n-            if (tmpDecoder != null) {\n-                for(i = 0; i < tmpDecoder.length; i++) {\n-                    if(tmpIndex == i) {\n-                        try {\n-                            ByteBuffer bb = ByteBuffer.wrap(tmpByte,0,2);\n-                            CharBuffer cc = CharBuffer.wrap(tmpChar,0,1);\n-                            tmpDecoder[i].decode(bb, cc, true);\n-                            cc.flip();\n-                            return cc.get();\n-                        } catch (Exception e) {}\n-                    }\n-                }\n-            }\n-            return REPLACE_CHAR;\n-        }\n-\n-        private int findDesig(byte[] in, int sp, int sl, byte[][] desigs) {\n-            if (desigs == null) return -1;\n-            int i = 0;\n-            while (i < desigs.length) {\n-                if (desigs[i] != null && sl - sp >= desigs[i].length) {\n-                    int j = 0;\n-                    while (j < desigs[i].length && in[sp+j] == desigs[i][j]) { j++; }\n-                    if (j == desigs[i].length)\n-                        return i;\n-                }\n-                i++;\n-            }\n-            return -1;\n-        }\n-\n-        private int findDesigBuf(ByteBuffer in, byte[][] desigs) {\n-            if (desigs == null) return -1;\n-            int i = 0;\n-            while (i < desigs.length) {\n-                if (desigs[i] != null && in.remaining() >= desigs[i].length) {\n-                    int j = 0;\n-                    in.mark();\n-                    while (j < desigs[i].length && in.get() == desigs[i][j]) { j++; }\n-                    if (j == desigs[i].length)\n-                        return i;\n-                    in.reset();\n-                }\n-                i++;\n-            }\n-            return -1;\n-        }\n-\n-        private CoderResult decodeArrayLoop(ByteBuffer src,\n-                                            CharBuffer dst)\n-        {\n-            byte[] sa = src.array();\n-            int sp = src.arrayOffset() + src.position();\n-            int sl = src.arrayOffset() + src.limit();\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n-\n-            char[] da = dst.array();\n-            int dp = dst.arrayOffset() + dst.position();\n-            int dl = dst.arrayOffset() + dst.limit();\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n-\n-            int b1 = 0, b2 = 0, b3 = 0;\n-\n-            try {\n-                while (sp < sl) {\n-                    b1 = sa[sp] & 0xff;\n-                    int inputSize = 1;\n-                    switch (b1) {\n-                        case ISO_SO:\n-                            shiftout = true;\n-                            inputSize = 1;\n-                            break;\n-                        case ISO_SI:\n-                            shiftout = false;\n-                            inputSize = 1;\n-                            break;\n-                        case ISO_ESC:\n-                            if (sl - sp - 1 < minDesignatorLength)\n-                                return CoderResult.UNDERFLOW;\n-\n-                            int desig = findDesig(sa, sp + 1, sl, SODesig);\n-                            if (desig != -1) {\n-                                curSODes = desig;\n-                                inputSize = SODesig[desig].length + 1;\n-                                break;\n-                            }\n-                            desig = findDesig(sa, sp + 1, sl, SS2Desig);\n-                            if (desig != -1) {\n-                                curSS2Des = desig;\n-                                inputSize = SS2Desig[desig].length + 1;\n-                                break;\n-                            }\n-                            desig = findDesig(sa, sp + 1, sl, SS3Desig);\n-                            if (desig != -1) {\n-                                curSS3Des = desig;\n-                                inputSize = SS3Desig[desig].length + 1;\n-                                break;\n-                            }\n-                            if (sl - sp < 2)\n-                                return CoderResult.UNDERFLOW;\n-                            b1 = sa[sp + 1];\n-                            switch(b1) {\n-                            case ISO_SS2_7:\n-                                if (sl - sp < 4)\n-                                    return CoderResult.UNDERFLOW;\n-                                b2 = sa[sp +2];\n-                                b3 = sa[sp +3];\n-                                if (dl - dp <1)\n-                                    return CoderResult.OVERFLOW;\n-                                da[dp] = decode((byte)b2,\n-                                                (byte)b3,\n-                                                SS2Flag);\n-                                dp++;\n-                                inputSize = 4;\n-                                break;\n-                            case ISO_SS3_7:\n-                                if (sl - sp < 4)\n-                                    return CoderResult.UNDERFLOW;\n-                                b2 = sa[sp + 2];\n-                                b3 = sa[sp + 3];\n-                                if (dl - dp <1)\n-                                    return CoderResult.OVERFLOW;\n-                                da[dp] = decode((byte)b2,\n-                                                (byte)b3,\n-                                                SS3Flag);\n-                                dp++;\n-                                inputSize = 4;\n-                                break;\n-                            default:\n-                                return CoderResult.malformedForLength(2);\n-                            }\n-                            break;\n-                        default:\n-                            if (dl - dp < 1)\n-                                return CoderResult.OVERFLOW;\n-                            if (!shiftout) {\n-                                da[dp++]=(char)(sa[sp] & 0xff);\n-                            } else {\n-                                if (dl - dp < 1)\n-                                    return CoderResult.OVERFLOW;\n-                                if (sl - sp < 2)\n-                                    return CoderResult.UNDERFLOW;\n-                                b2 = sa[sp+1] & 0xff;\n-                                da[dp++] = decode((byte)b1,\n-                                                  (byte)b2,\n-                                                   SOFlag);\n-                                inputSize = 2;\n-                            }\n-                            break;\n-                    }\n-                    sp += inputSize;\n-                }\n-                return CoderResult.UNDERFLOW;\n-            } finally {\n-                src.position(sp - src.arrayOffset());\n-                dst.position(dp - dst.arrayOffset());\n-            }\n-        }\n-\n-        private CoderResult decodeBufferLoop(ByteBuffer src,\n-                                             CharBuffer dst)\n-        {\n-            int mark = src.position();\n-            int b1 = 0, b2 = 0, b3 = 0;\n-\n-            try {\n-                while (src.hasRemaining()) {\n-                    b1 = src.get();\n-                    int inputSize = 1;\n-                    switch (b1) {\n-                        case ISO_SO:\n-                            shiftout = true;\n-                            break;\n-                        case ISO_SI:\n-                            shiftout = false;\n-                            break;\n-                        case ISO_ESC:\n-                            if (src.remaining() < minDesignatorLength)\n-                                return CoderResult.UNDERFLOW;\n-\n-                            int desig = findDesigBuf(src, SODesig);\n-                            if (desig != -1) {\n-                                curSODes = desig;\n-                                inputSize = SODesig[desig].length + 1;\n-                                break;\n-                            }\n-                            desig = findDesigBuf(src, SS2Desig);\n-                            if (desig != -1) {\n-                                curSS2Des = desig;\n-                                inputSize = SS2Desig[desig].length + 1;\n-                                break;\n-                            }\n-                            desig = findDesigBuf(src, SS3Desig);\n-                            if (desig != -1) {\n-                                curSS3Des = desig;\n-                                inputSize = SS3Desig[desig].length + 1;\n-                                break;\n-                            }\n-\n-                            if (src.remaining() < 1)\n-                                return CoderResult.UNDERFLOW;\n-                            b1 = src.get();\n-                            switch(b1) {\n-                                case ISO_SS2_7:\n-                                    if (src.remaining() < 2)\n-                                        return CoderResult.UNDERFLOW;\n-                                    b2 = src.get();\n-                                    b3 = src.get();\n-                                    if (dst.remaining() < 1)\n-                                        return CoderResult.OVERFLOW;\n-                                    dst.put(decode((byte)b2,\n-                                                   (byte)b3,\n-                                                   SS2Flag));\n-                                    inputSize = 4;\n-                                    break;\n-                                case ISO_SS3_7:\n-                                    if (src.remaining() < 2)\n-                                        return CoderResult.UNDERFLOW;\n-                                    b2 = src.get();\n-                                    b3 = src.get();\n-                                    if (dst.remaining() < 1)\n-                                        return CoderResult.OVERFLOW;\n-                                    dst.put(decode((byte)b2,\n-                                                   (byte)b3,\n-                                                   SS3Flag));\n-                                    inputSize = 4;\n-                                    break;\n-                                default:\n-                                    return CoderResult.malformedForLength(2);\n-                            }\n-                            break;\n-                        default:\n-                            if (dst.remaining() < 1)\n-                                return CoderResult.OVERFLOW;\n-                            if (!shiftout) {\n-                                dst.put((char)(b1 & 0xff));\n-                            } else {\n-                                if (dst.remaining() < 1)\n-                                    return CoderResult.OVERFLOW;\n-                                if (src.remaining() < 1)\n-                                    return CoderResult.UNDERFLOW;\n-                                b2 = src.get() & 0xff;\n-                                dst.put(decode((byte)b1,\n-                                                      (byte)b2,\n-                                                        SOFlag));\n-                                inputSize = 2;\n-                            }\n-                            break;\n-                    }\n-                    mark += inputSize;\n-                }\n-                return CoderResult.UNDERFLOW;\n-            } catch (Exception e) { e.printStackTrace(); return CoderResult.OVERFLOW; }\n-            finally {\n-                src.position(mark);\n-            }\n-        }\n+    protected static class Encoder extends CharsetEncoder {\n@@ -379,9 +59,5 @@\n-        protected CoderResult decodeLoop(ByteBuffer src,\n-                                         CharBuffer dst)\n-        {\n-            if (src.hasArray() && dst.hasArray())\n-                return decodeArrayLoop(src, dst);\n-            else\n-                return decodeBufferLoop(src, dst);\n-        }\n-    }\n+        private static final byte ISO_ESC = 0x1b;\n+        private static final byte ISO_SI = 0x0f;\n+        private static final byte ISO_SO = 0x0e;\n+        private static final byte ISO_SS2_7 = 0x4e;\n+        private static final byte ISO_SS3_7 = 0x4f;\n@@ -389,1 +65,0 @@\n-    protected static class Encoder extends CharsetEncoder {\n@@ -394,1 +69,0 @@\n-        private final byte MSB = (byte)0x80;\n@@ -431,3 +105,3 @@\n-            char        convChar[] = {unicode};\n-            byte        convByte[] = new byte[4];\n-            int         converted;\n+            char[] convChar = {unicode};\n+            byte[] convByte = new byte[4];\n+            int converted;\n@@ -494,2 +168,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -499,2 +172,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -502,2 +173,2 @@\n-            int outputSize = 0;\n-            byte[]  outputByte = new byte[8];\n+            int outputSize;\n+            byte[] outputByte = new byte[8];\n@@ -560,3 +231,2 @@\n-            int outputSize = 0;\n-            byte[]  outputByte = new byte[8];\n-            int     inputSize = 0;                 \/\/ Size of input\n+            int outputSize;\n+            byte[] outputByte = new byte[8];\n@@ -587,1 +257,1 @@\n-                        if(inputChar == '\\n'){\n+                        if (inputChar == '\\n') {\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022.java","additions":24,"deletions":354,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.nio.charset.CharacterCodingException;\n@@ -89,4 +88,2 @@\n-        private static final Charset gb2312 = new EUC_CN();\n-        private static final Charset cns = new EUC_TW();\n-        private final DoubleByte.Decoder gb2312Decoder;\n-        private final EUC_TW.Decoder cnsDecoder;\n+        private static final DoubleByte.Decoder GB2312 =\n+                (DoubleByte.Decoder)new EUC_CN().newDecoder();\n@@ -98,2 +95,0 @@\n-            gb2312Decoder = (DoubleByte.Decoder)gb2312.newDecoder();\n-            cnsDecoder = (EUC_TW.Decoder)cns.newDecoder();\n@@ -110,1 +105,1 @@\n-            int p = 0;\n+            int p;\n@@ -117,6 +112,4 @@\n-            char[] ret = cnsDecoder.toUnicode(byte1 & 0xff,\n-                                              byte2 & 0xff,\n-                                              p);\n-            if (ret == null || ret.length == 2)\n-                return REPLACE_CHAR;\n-            return ret[0];\n+            return EUC_TW.Decoder.decodeSingleOrReplace(byte1 & 0xff,\n+                                                        byte2 & 0xff,\n+                                                        p,\n+                                                        REPLACE_CHAR);\n@@ -129,2 +122,2 @@\n-                return gb2312Decoder.decodeDouble(byte1 & 0xff,\n-                                                  byte2 & 0xff);\n+                return GB2312.decodeDouble(byte1 & 0xff,\n+                                           byte2 & 0xff);\n@@ -132,6 +125,4 @@\n-                char[] ret = cnsDecoder.toUnicode(byte1 & 0xff,\n-                                                  byte2 & 0xff,\n-                                                  0);\n-                if (ret == null)\n-                    return REPLACE_CHAR;\n-                return ret[0];\n+                return EUC_TW.Decoder.decodeSingleOrReplace(byte1 & 0xff,\n+                                                            byte2 & 0xff,\n+                                                            0,\n+                                                            REPLACE_CHAR);\n@@ -145,3 +136,3 @@\n-            byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n-            int inputSize = 0;\n-            char c = REPLACE_CHAR;\n+            byte b1, b2, b3, b4;\n+            int inputSize;\n+            char c;\n@@ -267,3 +258,3 @@\n-            int inputSize = 0;\n-            byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n-            char c = REPLACE_CHAR;\n+            int inputSize;\n+            byte b1, b2, b3, b4;\n+            char c;\n@@ -274,2 +265,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -280,2 +269,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -309,1 +296,1 @@\n-                                if (b3 == 'A'){              \/\/ \"$A\"\n+                                if (b3 == 'A') {              \/\/ \"$A\"\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_CN.java","additions":21,"deletions":34,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n@@ -36,1 +34,0 @@\n-import java.nio.charset.CoderResult;\n@@ -69,0 +66,4 @@\n+        private static final byte[] SOD = new byte[] {'$', ')', 'G' };\n+        private static final byte[] SS2D = new byte[] {'$', '*', 'H' };\n+        private static final byte[] SS3D = new byte[] {'$', '+', 'I' };\n+\n@@ -72,3 +73,3 @@\n-            SODesig =  new byte[] {'$', ')', 'G' };\n-            SS2Desig = new byte[] {'$', '*', 'H' };\n-            SS3Desig = new byte[] {'$', '+', 'I' };\n+            SODesig = SOD;\n+            SS2Desig = SS2D;\n+            SS3Desig = SS3D;\n@@ -78,1 +79,1 @@\n-        private byte[] bb = new byte[4];\n+        private final byte[] bb = new byte[4];\n@@ -80,1 +81,1 @@\n-            int n = 0;\n+            int n;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_CN_CNS.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n@@ -36,1 +34,0 @@\n-import java.nio.charset.CoderResult;\n@@ -69,0 +66,3 @@\n+\n+        private static final byte[] SOD = new byte[] {'$', ')', 'A' };\n+\n@@ -72,1 +72,1 @@\n-            SODesig = new byte[] { '$', ')', 'A'};\n+            SODesig = SOD;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_CN_GB.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-        final static DoubleByte.Decoder DEC0208 =\n+        static final DoubleByte.Decoder DEC0208 =\n@@ -181,2 +181,2 @@\n-        private DoubleByte.Decoder dec0208;\n-        private DoubleByte.Decoder dec0212;\n+        private final DoubleByte.Decoder dec0208;\n+        private final DoubleByte.Decoder dec0212;\n@@ -206,3 +206,3 @@\n-            int inputSize = 0;\n-            int b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n-            char c = UNMAPPABLE_DECODING;\n+            int inputSize;\n+            int b1, b2, b3, b4;\n+            char c;\n@@ -212,2 +212,0 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n@@ -218,2 +216,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n@@ -334,2 +330,2 @@\n-            int b1 = 0, b2 = 0, b3 = 0, b4=0;\n-            char c = UNMAPPABLE_DECODING;\n+            int b1, b2, b3, b4;\n+            char c;\n@@ -468,1 +464,1 @@\n-        private static byte[] repl = { (byte)0x21, (byte)0x29 };\n+        private static final byte[] repl = { (byte)0x21, (byte)0x29 };\n@@ -471,3 +467,3 @@\n-        private DoubleByte.Encoder enc0208;\n-        private DoubleByte.Encoder enc0212;\n-        private boolean doSBKANA;\n+        private final DoubleByte.Encoder enc0208;\n+        private final DoubleByte.Encoder enc0212;\n+        private final boolean doSBKANA;\n@@ -538,2 +534,1 @@\n-            assert (sp <= sl);\n-            sp = (sp <= sl ? sp : sl);\n+\n@@ -543,2 +538,0 @@\n-            assert (dp <= dl);\n-            dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_JP.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -70,2 +70,32 @@\n-    private static class Decoder extends ISO2022.Decoder {\n-        public Decoder(Charset cs)\n+\n+    private static class Decoder extends CharsetDecoder {\n+\n+        private static final byte[] SOD = new byte[] {'$', ')', 'C' };\n+\n+        private static final DoubleByte.Decoder KSC5601 = (DoubleByte.Decoder)\n+                new EUC_KR().newDecoder();\n+\n+        private static final byte ISO_ESC = 0x1b;\n+        private static final byte ISO_SI = 0x0f;\n+        private static final byte ISO_SO = 0x0e;\n+        private static final byte ISO_SS2_7 = 0x4e;\n+        private static final byte ISO_SS3_7 = 0x4f;\n+        private static final byte MSB = (byte)0x80;\n+        private static final char REPLACE_CHAR = '\\uFFFD';\n+        private static final byte minDesignatorLength = 3;\n+\n+        private static final byte SOFlag = 0;\n+        private static final byte SS2Flag = 1;\n+        private static final byte SS3Flag = 2;\n+\n+        private boolean shiftout;\n+\n+        private Decoder(Charset cs) {\n+            super(cs, 1.0f, 1.0f);\n+        }\n+\n+        protected void implReset() {\n+            shiftout = false;\n+        }\n+\n+        private char decode(byte byte1, byte byte2, byte shiftFlag)\n@@ -73,3 +103,127 @@\n-            super(cs);\n-            SODesig = new byte[][] {{(byte)'$', (byte)')', (byte)'C'}};\n-            SODecoder = new CharsetDecoder[1];\n+            if (shiftFlag == SOFlag) {\n+                return KSC5601.decodeDouble((byte1 | MSB) & 0xFF, (byte2 | MSB) & 0xFF);\n+            }\n+            return REPLACE_CHAR;\n+        }\n+\n+        private boolean findDesig(byte[] in, int sp, int sl) {\n+            if (sl - sp >= SOD.length) {\n+                int j = 0;\n+                while (j < SOD.length && in[sp + j] == SOD[j]) { j++; }\n+                return j == SOD.length;\n+            }\n+            return false;\n+        }\n+\n+        private boolean findDesigBuf(ByteBuffer in) {\n+            if (in.remaining() >= SOD.length) {\n+                int j = 0;\n+                in.mark();\n+                while (j < SOD.length && in.get() == SOD[j]) { j++; }\n+                if (j == SOD.length)\n+                    return true;\n+                in.reset();\n+            }\n+            return false;\n+        }\n+\n+        private CoderResult decodeArrayLoop(ByteBuffer src,\n+                                            CharBuffer dst)\n+        {\n+            byte[] sa = src.array();\n+            int sp = src.arrayOffset() + src.position();\n+            int sl = src.arrayOffset() + src.limit();\n+\n+            char[] da = dst.array();\n+            int dp = dst.arrayOffset() + dst.position();\n+            int dl = dst.arrayOffset() + dst.limit();\n+\n+            int b1, b2, b3;\n+\n+            try {\n+                while (sp < sl) {\n+                    b1 = sa[sp] & 0xff;\n+                    int inputSize = 1;\n+                    switch (b1) {\n+                        case ISO_SO:\n+                            shiftout = true;\n+                            inputSize = 1;\n+                            break;\n+                        case ISO_SI:\n+                            shiftout = false;\n+                            inputSize = 1;\n+                            break;\n+                        case ISO_ESC:\n+                            if (sl - sp - 1 < minDesignatorLength)\n+                                return CoderResult.UNDERFLOW;\n+\n+                            if (findDesig(sa, sp + 1, sl)) {\n+                                inputSize = SOD.length + 1;\n+                                break;\n+                            }\n+                            if (sl - sp < 2)\n+                                return CoderResult.UNDERFLOW;\n+                            b1 = sa[sp + 1];\n+                            switch (b1) {\n+                                case ISO_SS2_7:\n+                                    if (sl - sp < 4)\n+                                        return CoderResult.UNDERFLOW;\n+                                    b2 = sa[sp +2];\n+                                    b3 = sa[sp +3];\n+                                    if (dl - dp <1)\n+                                        return CoderResult.OVERFLOW;\n+                                    da[dp] = decode((byte)b2,\n+                                            (byte)b3,\n+                                            SS2Flag);\n+                                    dp++;\n+                                    inputSize = 4;\n+                                    break;\n+                                case ISO_SS3_7:\n+                                    if (sl - sp < 4)\n+                                        return CoderResult.UNDERFLOW;\n+                                    b2 = sa[sp + 2];\n+                                    b3 = sa[sp + 3];\n+                                    if (dl - dp < 1)\n+                                        return CoderResult.OVERFLOW;\n+                                    da[dp] = decode((byte)b2,\n+                                            (byte)b3,\n+                                            SS3Flag);\n+                                    dp++;\n+                                    inputSize = 4;\n+                                    break;\n+                                default:\n+                                    return CoderResult.malformedForLength(2);\n+                            }\n+                            break;\n+                        default:\n+                            if (dl - dp < 1)\n+                                return CoderResult.OVERFLOW;\n+                            if (!shiftout) {\n+                                da[dp++]=(char)(sa[sp] & 0xff);\n+                            } else {\n+                                if (dl - dp < 1)\n+                                    return CoderResult.OVERFLOW;\n+                                if (sl - sp < 2)\n+                                    return CoderResult.UNDERFLOW;\n+                                b2 = sa[sp+1] & 0xff;\n+                                da[dp++] = decode((byte)b1,\n+                                        (byte)b2,\n+                                        SOFlag);\n+                                inputSize = 2;\n+                            }\n+                            break;\n+                    }\n+                    sp += inputSize;\n+                }\n+                return CoderResult.UNDERFLOW;\n+            } finally {\n+                src.position(sp - src.arrayOffset());\n+                dst.position(dp - dst.arrayOffset());\n+            }\n+        }\n+\n+        private CoderResult decodeBufferLoop(ByteBuffer src,\n+                                             CharBuffer dst)\n+        {\n+            int mark = src.position();\n+            int b1, b2, b3;\n@@ -78,2 +232,83 @@\n-                SODecoder[0] = Holder.ksc5601_cs.newDecoder();\n-            } catch (Exception e) {};\n+                while (src.hasRemaining()) {\n+                    b1 = src.get();\n+                    int inputSize = 1;\n+                    switch (b1) {\n+                        case ISO_SO:\n+                            shiftout = true;\n+                            break;\n+                        case ISO_SI:\n+                            shiftout = false;\n+                            break;\n+                        case ISO_ESC:\n+                            if (src.remaining() < minDesignatorLength)\n+                                return CoderResult.UNDERFLOW;\n+\n+                            if (findDesigBuf(src)) {\n+                                inputSize = SOD.length + 1;\n+                                break;\n+                            }\n+\n+                            if (src.remaining() < 1)\n+                                return CoderResult.UNDERFLOW;\n+                            b1 = src.get();\n+                            switch(b1) {\n+                                case ISO_SS2_7:\n+                                    if (src.remaining() < 2)\n+                                        return CoderResult.UNDERFLOW;\n+                                    b2 = src.get();\n+                                    b3 = src.get();\n+                                    if (dst.remaining() < 1)\n+                                        return CoderResult.OVERFLOW;\n+                                    dst.put(decode((byte)b2,\n+                                            (byte)b3,\n+                                            SS2Flag));\n+                                    inputSize = 4;\n+                                    break;\n+                                case ISO_SS3_7:\n+                                    if (src.remaining() < 2)\n+                                        return CoderResult.UNDERFLOW;\n+                                    b2 = src.get();\n+                                    b3 = src.get();\n+                                    if (dst.remaining() < 1)\n+                                        return CoderResult.OVERFLOW;\n+                                    dst.put(decode((byte)b2,\n+                                            (byte)b3,\n+                                            SS3Flag));\n+                                    inputSize = 4;\n+                                    break;\n+                                default:\n+                                    return CoderResult.malformedForLength(2);\n+                            }\n+                            break;\n+                        default:\n+                            if (dst.remaining() < 1)\n+                                return CoderResult.OVERFLOW;\n+                            if (!shiftout) {\n+                                dst.put((char)(b1 & 0xff));\n+                            } else {\n+                                if (src.remaining() < 1)\n+                                    return CoderResult.UNDERFLOW;\n+                                b2 = src.get() & 0xff;\n+                                dst.put(decode((byte)b1,\n+                                        (byte)b2,\n+                                        SOFlag));\n+                                inputSize = 2;\n+                            }\n+                            break;\n+                    }\n+                    mark += inputSize;\n+                }\n+                return CoderResult.UNDERFLOW;\n+            } catch (Exception e) { e.printStackTrace(); return CoderResult.OVERFLOW; }\n+            finally {\n+                src.position(mark);\n+            }\n+        }\n+\n+        protected CoderResult decodeLoop(ByteBuffer src,\n+                                         CharBuffer dst)\n+        {\n+            if (src.hasArray() && dst.hasArray())\n+                return decodeArrayLoop(src, dst);\n+            else\n+                return decodeBufferLoop(src, dst);\n@@ -85,0 +320,2 @@\n+        private static final byte[] SOD = new byte[] {'$', ')', 'C' };\n+\n@@ -87,1 +324,1 @@\n-            SODesig = new byte[] {'$', ')', 'C' };\n+            SODesig = SOD;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_KR.java","additions":245,"deletions":8,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,2 +101,1 @@\n-        assert (sp <= sl);\n-        sp = (sp <= sl ? sp : sl);\n+\n@@ -106,2 +105,0 @@\n-        assert (dp <= dl);\n-        dp = (dp <= dl ? dp : dl);\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/SimpleEUCEncoder.java.template","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+        @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\", \"ISO-2022-KR\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}