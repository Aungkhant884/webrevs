{"files":[{"patch":"@@ -10118,0 +10118,8 @@\n+void Assembler::gf2p8affineqb(XMMRegister dst, XMMRegister src, int imm8) {\n+  assert(VM_Version::supports_gfni(), \"\");\n+  assert(VM_Version::supports_sse(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xCE, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2804,0 +2804,1 @@\n+  void gf2p8affineqb(XMMRegister dst, XMMRegister src, int imm8);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5359,0 +5359,84 @@\n+void C2_MacroAssembler::reverseI(Register dst, Register src, XMMRegister xtmp1,\n+                                 XMMRegister xtmp2, Register rtmp) {\n+  if(VM_Version::supports_gfni()) {\n+    \/\/ Galois field instruction based bit reversal based on following algorithm.\n+    \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+    mov64(rtmp, 0x8040201008040201L);\n+    movq(xtmp1, src);\n+    movq(xtmp2, rtmp);\n+    gf2p8affineqb(xtmp1, xtmp2, 0);\n+    movq(dst, xtmp1);\n+  } else {\n+    \/\/ Swap even and odd numbered bits.\n+    movl(rtmp, src);\n+    andl(rtmp, 0x55555555);\n+    shll(rtmp, 1);\n+    movl(dst, src);\n+    andl(dst, 0xAAAAAAAA);\n+    shrl(dst, 1);\n+    orl(dst, rtmp);\n+\n+    \/\/ Swap LSB and MSB 2 bits of each nibble.\n+    movl(rtmp, dst);\n+    andl(rtmp, 0x33333333);\n+    shll(rtmp, 2);\n+    andl(dst, 0xCCCCCCCC);\n+    shrl(dst, 2);\n+    orl(dst, rtmp);\n+\n+    \/\/ Swap LSB and MSB 4 bits of each byte.\n+    movl(rtmp, dst);\n+    andl(rtmp, 0x0F0F0F0F);\n+    shll(rtmp, 4);\n+    andl(dst, 0xF0F0F0F0);\n+    shrl(dst, 4);\n+    orl(dst, rtmp);\n+  }\n+  bswapl(dst);\n+}\n+\n+void C2_MacroAssembler::reverseL(Register dst, Register src, XMMRegister xtmp1,\n+                                 XMMRegister xtmp2, Register rtmp1, Register rtmp2) {\n+  if(VM_Version::supports_gfni()) {\n+    \/\/ Galois field instruction based bit reversal based on following algorithm.\n+    \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+    mov64(rtmp1, 0x8040201008040201L);\n+    movq(xtmp1, src);\n+    movq(xtmp2, rtmp1);\n+    gf2p8affineqb(xtmp1, xtmp2, 0);\n+    movq(dst, xtmp1);\n+  } else {\n+    \/\/ Swap even and odd numbered bits.\n+    movq(rtmp1, src);\n+    mov64(rtmp2, 0x5555555555555555L);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 1);\n+    movq(dst, src);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 1);\n+    orq(dst, rtmp1);\n+\n+    \/\/ Swap LSB and MSB 2 bits of each nibble.\n+    movq(rtmp1, dst);\n+    mov64(rtmp2, 0x3333333333333333L);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 2);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 2);\n+    orq(dst, rtmp1);\n+\n+    \/\/ Swap LSB and MSB 4 bits of each byte.\n+    movq(rtmp1, dst);\n+    mov64(rtmp2, 0x0F0F0F0F0F0F0F0FL);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 4);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 4);\n+    orq(dst, rtmp1);\n+  }\n+  bswapq(dst);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -365,0 +365,4 @@\n+  void reverseI(Register dst, Register src, XMMRegister xtmp1,\n+                XMMRegister xtmp2, Register rtmp);\n+  void reverseL(Register dst, Register src, XMMRegister xtmp1,\n+                XMMRegister xtmp2, Register rtmp1, Register rtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6724,0 +6724,44 @@\n+\/\/--------------- Reverse Operation Instructions ----------------\n+instruct bytes_reversebit_int(rRegI dst, rRegI src, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, regF xtmp1, regF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long(rRegL dst, rRegL src, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp1$$Register, $rtmp2$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, regD xtmp1, regD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register, noreg);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -249,0 +249,3 @@\n+  do_intrinsic(_reverse_i,                java_lang_Integer,      reverse_name,             int_int_signature,   F_S)   \\\n+   do_name(     reverse_name,                                    \"reverse\")                                             \\\n+  do_intrinsic(_reverse_l,                java_lang_Long,         reverse_name,             long_long_signature, F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -266,0 +266,6 @@\n+  case vmIntrinsics::_reverse_i:\n+    if (!Matcher::match_rule_supported(Op_ReverseI)) return false;\n+    break;\n+  case vmIntrinsics::_reverse_l:\n+    if (!Matcher::match_rule_supported(Op_ReverseL)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -528,0 +528,2 @@\n+  case vmIntrinsics::_reverse_i:\n+  case vmIntrinsics::_reverse_l:\n@@ -2229,0 +2231,2 @@\n+  case vmIntrinsics::_reverse_i:                n = new ReverseINode(0, arg); break;\n+  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(0, arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1902,0 +1902,47 @@\n+\n+static jlong reverse_bits(jlong val) {\n+  jlong res = ((val & 0xF0F0F0F0F0F0F0F0L) >> 4) | ((val & 0x0F0F0F0F0F0F0F0F) << 4);\n+  res = ((res & 0xCCCCCCCCCCCCCCCCL) >> 2) | ((res & 0x3333333333333333L) << 2);\n+  res = ((res & 0xAAAAAAAAAAAAAAAAL) >> 1) | ((res & 0x5555555555555555L) << 1);\n+  return res;\n+}\n+\n+const Type* ReverseINode::Value(PhaseGVN* phase) const {\n+  const Type *t1 = phase->type( in(1) );\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const TypeInt* t1int = t1->isa_int();\n+  if (t1int && t1int->is_con()) {\n+    jint res  = reverse_bits(t1int->get_con());\n+    return TypeInt::make(res);\n+  }\n+  return t1int;\n+}\n+\n+const Type* ReverseLNode::Value(PhaseGVN* phase) const {\n+  const Type *t1 = phase->type( in(1) );\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const TypeLong* t1long = t1->isa_long();\n+  if (t1long->is_con()) {\n+    jint res  = reverse_bits(t1long->get_con());\n+    return TypeLong::make(res);\n+  }\n+  return t1long;\n+}\n+\n+Node* ReverseINode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseI) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+Node* ReverseLNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseL) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -583,0 +583,2 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -593,0 +595,2 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2646,0 +2646,1 @@\n+                 opc == Op_ReverseI || opc == Op_ReverseL ||\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1765,0 +1765,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1904,0 +1904,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -464,0 +464,4 @@\n+      test_reverse(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_reverse: \", i, a0[i], Integer.reverse(a1[i]));\n+      }\n@@ -937,0 +941,7 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_reverse(a0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_reverse: \" + (end - start));\n+\n@@ -1290,0 +1301,6 @@\n+  static void test_reverse(int [] a0, int [] a1) {\n+    for(int i = 0; i < a0.length; i++) {\n+      a0[i] = Integer.reverse(a1[i]);\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestIntVect.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -439,0 +439,4 @@\n+      test_reverse(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_reverse: \", i, a0[i], Long.reverse(a1[i]));\n+      }\n@@ -866,0 +870,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_reverse(a0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_reverse: \" + (end - start));\n@@ -1136,0 +1146,1 @@\n+\n@@ -1142,0 +1153,6 @@\n+  static void test_reverse(long[] a0, long[] a1) {\n+    for(int i = 0; i < a0.length; i++) {\n+      a0[i] = Long.reverse(a1[i]);\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestLongVect.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8290034\n+ * @summary Auto-vectorization of Reverse bit operation.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestReverseBitsVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+public class TestReverseBitsVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static long [] linp;\n+  private static long [] lout;\n+  private static int  [] iinp;\n+  private static int  [] iout;\n+  private static short [] sinp;\n+  private static short [] sout;\n+  private static char [] cinp;\n+  private static char [] cout;\n+\n+  public static void setup() {\n+      Random r = new Random(1024);\n+      linp = new long[ARRLEN];\n+      lout = new long[ARRLEN];\n+      iinp = new int[ARRLEN];\n+      iout = new int[ARRLEN];\n+      sinp = new short[ARRLEN];\n+      sout = new short[ARRLEN];\n+      cinp = new char[ARRLEN];\n+      cout = new char[ARRLEN];\n+      for(int i = 0; i < ARRLEN; i++) {\n+          linp[i] = r.nextLong();\n+          iinp[i] = r.nextInt();\n+          sinp[i] = (short)r.nextInt();\n+          cinp[i] = (char)r.nextInt();\n+      }\n+  }\n+\n+  public static void main(String args[]) {\n+      setup();\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {\"ReverseV\" , \" > 0 \"})\n+  public void test_reverse_long1(long[] lout, long[] linp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Long.reverse(linp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_long1\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_long1() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_long1(lout , linp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseL\"})\n+  public void test_reverse_long2(long[] lout, long[] linp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Long.reverse(Long.reverse(linp[i]));\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_long2\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_long2() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_long2(lout , linp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseL\"})\n+  public void test_reverse_long3(long[] lout, long[] linp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Long.reverse(linp[i] ^ linp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_long3\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_long3() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_long3(lout , linp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {\"ReverseV\" , \" > 0 \"})\n+  public void test_reverse_int1(int[] iout, int[] iinp) {\n+      for (int i = 0; i < iout.length; i+=1) {\n+          iout[i] = Integer.reverse(iinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_int1\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_int1() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_int1(iout , iinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseI\"})\n+  public void test_reverse_int2(int[] iout, int[] iinp) {\n+      for (int i = 0; i < iout.length; i+=1) {\n+          iout[i] = Integer.reverse(Integer.reverse(iinp[i]));\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_int2\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_int2() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_int2(iout , iinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseI\"})\n+  public void test_reverse_int3(int[] iout, int[] iinp) {\n+      for (int i = 0; i < iout.length; i+=1) {\n+          iout[i] = Integer.reverse(iinp[i] ^ iinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_reverse_int3\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_reverse_int3() {\n+      setup();\n+      for (int i = 0; i < ITERS; i++) {\n+          test_reverse_int3(iout , iinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBitsVector.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -176,0 +176,7 @@\n+\n+    @Benchmark\n+    public void reverse() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Integer.reverse(intsSmall[i]);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,0 +171,7 @@\n+\n+    @Benchmark\n+    public void reverse() {\n+        for (int i = 0; i < size; i++) {\n+            res[i] = Long.reverse(longArraySmall[i]);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}