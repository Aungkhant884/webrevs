{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,9 @@\n+     * <p> This method may be used by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">JNI code<\/a>\n+     * with no caller class on the stack to enable access to a {@link Member member}\n+     * of {@link Member#getDeclaringClass() declaring class} {@code D} if and only if:\n+     * <ul>\n+     *     <li> The member is {@code public} and {@code D} is {@code public} in\n+     *     a package that the module containing {@code D} {@link\n+     *     Module#isExported(String,Module) exports} unconditionally. <\/li>\n+     * <\/ul>\n+     *\n@@ -249,0 +258,5 @@\n+     * <p> If this method is invoked by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">JNI code<\/a>\n+     * with no caller class on the stack, the {@code accessible} flag can\n+     * only set if the member and the declaring class are public, and\n+     * the class is in a package that is exported unconditionally. <\/p>\n+     *\n@@ -307,0 +321,10 @@\n+        if (caller == null) {\n+            \/\/ No caller frame when a native thread attaches to the VM\n+            \/\/ only allow access to a public accessible member\n+            boolean canAccess = Reflection.verifyPublicMemberAccess(declaringClass, declaringClass.getModifiers());\n+            if (!canAccess && throwExceptionIfDenied) {\n+                throwInaccessibleObjectException(caller, declaringClass);\n+            }\n+            return canAccess;\n+        }\n+\n@@ -315,6 +339,1 @@\n-        int modifiers;\n-        if (this instanceof Executable) {\n-            modifiers = ((Executable) this).getModifiers();\n-        } else {\n-            modifiers = ((Field) this).getModifiers();\n-        }\n+        int modifiers = ((Member)this).getModifiers();\n@@ -344,15 +363,1 @@\n-            \/\/ not accessible\n-            String msg = \"Unable to make \";\n-            if (this instanceof Field)\n-                msg += \"field \";\n-            msg += this + \" accessible: \" + declaringModule + \" does not \\\"\";\n-            if (isClassPublic && Modifier.isPublic(modifiers))\n-                msg += \"exports\";\n-            else\n-                msg += \"opens\";\n-            msg += \" \" + pn + \"\\\" to \" + callerModule;\n-            InaccessibleObjectException e = new InaccessibleObjectException(msg);\n-            if (printStackTraceWhenAccessFails()) {\n-                e.printStackTrace(System.err);\n-            }\n-            throw e;\n+            throwInaccessibleObjectException(caller, declaringClass);\n@@ -363,0 +368,26 @@\n+    private void throwInaccessibleObjectException(Class<?> caller, Class<?> declaringClass) {\n+        boolean isClassPublic = Modifier.isPublic(declaringClass.getModifiers());\n+        String pn = declaringClass.getPackageName();\n+        int modifiers = ((Member)this).getModifiers();\n+\n+        \/\/ not accessible\n+        String msg = \"Unable to make \";\n+        if (this instanceof Field)\n+            msg += \"field \";\n+        msg += this + \" accessible\";\n+        msg += caller == null ? \" by JNI attached native thread with no caller frame: \" : \": \";\n+        msg += declaringClass.getModule() + \" does not \\\"\";\n+        if (isClassPublic && Modifier.isPublic(modifiers))\n+            msg += \"exports\";\n+        else\n+            msg += \"opens\";\n+        msg += \" \" + pn + \"\\\"\" ;\n+        if (caller != null)\n+            msg += \" to \" + caller.getModule();\n+        InaccessibleObjectException e = new InaccessibleObjectException(msg);\n+        if (printStackTraceWhenAccessFails()) {\n+            e.printStackTrace(System.err);\n+        }\n+        throw e;\n+    }\n+\n@@ -412,1 +443,5 @@\n-     * with the variation noted in the class description. <\/p>\n+     * with the variation noted in the class description.\n+     * If this method is invoked by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">JNI code<\/a>\n+     * with no caller class on the stack, this method returns {@code true}\n+     * if the member and the declaring class are public, and the class is in\n+     * a package that is exported unconditionally. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8221530\n+ * @bug 8221530 8221642\n@@ -64,1 +64,4 @@\n-        new OutputAnalyzer(pb.start()).shouldHaveExitValue(0);\n+        new OutputAnalyzer(pb.start())\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/exeCallerAccessTest\/CallerAccessTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+static jmethodID mid_Field_canAccess;\n+static jmethodID mid_Field_trySetAccessible;\n+static jmethodID mid_Field_setAccessible;\n@@ -38,0 +41,3 @@\n+int setAccessible(JNIEnv *env, char* declaringClass_name, char* field_name);\n+int trySetAccessible(JNIEnv *env, char* declaringClass_name, char* field_name, jboolean canAccess);\n+int checkAccess(JNIEnv *env, char* declaringClass_name, char* field_name, jboolean canAccess);\n@@ -68,0 +74,6 @@\n+    mid_Field_canAccess = (*env)->GetMethodID(env, fieldClass, \"canAccess\", \"(Ljava\/lang\/Object;)Z\");\n+    assert(mid_Field_canAccess != NULL);\n+    mid_Field_setAccessible = (*env)->GetMethodID(env, fieldClass, \"setAccessible\", \"(Z)V\");\n+    assert(mid_Field_setAccessible != NULL);\n+    mid_Field_trySetAccessible = (*env)->GetMethodID(env, fieldClass, \"trySetAccessible\", \"()Z\");\n+    assert(mid_Field_trySetAccessible != NULL);\n@@ -95,0 +107,26 @@\n+    \/\/ expect IAE to jdk.internal.misc.Unsafe class\n+    if ((rc = setAccessible(env, \"jdk.internal.misc.Unsafe\", \"INVALID_FIELD_OFFSET\")) == 0) {\n+        printf(\"ERROR: IAE not thrown\\n\");\n+        exit(-1);\n+    }\n+    if (checkAndClearIllegalAccessExceptionThrown(env) != JNI_TRUE) {\n+        printf(\"ERROR: exception is not an instance of IAE\\n\");\n+        exit(-1);\n+    }\n+\n+    if ((rc = trySetAccessible(env, \"java.lang.reflect.Modifier\", \"PUBLIC\", JNI_TRUE)) != 0) {\n+        printf(\"ERROR: unexpected result from trySetAccessible on Modifier::PUBLIC field\\n\");\n+        exit(-1);\n+    }\n+    if ((rc = trySetAccessible(env, \"jdk.internal.misc.Unsafe\", \"INVALID_FIELD_OFFSET\", JNI_FALSE)) != 0) {\n+        printf(\"ERROR: unexpected result from trySetAccessible on Unsafe public field\\n\");\n+        exit(-1);\n+    }\n+\n+    if ((rc = checkAccess(env, \"java.lang.reflect.Modifier\", \"PUBLIC\", JNI_TRUE)) != 0) {\n+        printf(\"ERROR: unexpected result from trySetAccessible on Modifier::PUBLIC field\\n\");\n+        exit(-1);\n+    }\n+    if ((rc = checkAccess(env, \"jdk.internal.misc.Unsafe\", \"INVALID_FIELD_OFFSET\", JNI_FALSE)) != 0) {\n+        printf(\"ERROR: unexpected result from trySetAccessible on Unsafe public field\\n\");\n+    }\n@@ -130,0 +168,71 @@\n+int setAccessible(JNIEnv *env, char* declaringClass_name, char* field_name) {\n+    jobject c = (*env)->CallStaticObjectMethod(env, classClass, mid_Class_forName,\n+                                               (*env)->NewStringUTF(env, declaringClass_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 1;\n+    }\n+\n+    jobject f = (*env)->CallObjectMethod(env, c, mid_Class_getField, (*env)->NewStringUTF(env, field_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 2;\n+    }\n+\n+    (*env)->CallVoidMethod(env, f, mid_Field_setAccessible, JNI_TRUE);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 3;\n+    }\n+    return 0;\n+}\n+\n+int trySetAccessible(JNIEnv *env, char* declaringClass_name, char* field_name, jboolean canAccess) {\n+    jobject c = (*env)->CallStaticObjectMethod(env, classClass, mid_Class_forName,\n+                                               (*env)->NewStringUTF(env, declaringClass_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 1;\n+    }\n+\n+    jobject f = (*env)->CallObjectMethod(env, c, mid_Class_getField, (*env)->NewStringUTF(env, field_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 2;\n+    }\n+\n+    jboolean rc = (*env)->CallBooleanMethod(env, f, mid_Field_trySetAccessible);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 3;\n+    }\n+    if (rc != canAccess) {\n+        return 4;\n+    }\n+    return 0;\n+}\n+\n+int checkAccess(JNIEnv *env, char* declaringClass_name, char* field_name, jboolean canAccess) {\n+    jobject c = (*env)->CallStaticObjectMethod(env, classClass, mid_Class_forName,\n+                                               (*env)->NewStringUTF(env, declaringClass_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 1;\n+    }\n+\n+    jobject f = (*env)->CallObjectMethod(env, c, mid_Class_getField, (*env)->NewStringUTF(env, field_name));\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 2;\n+    }\n+\n+    jboolean rc = (*env)->CallBooleanMethod(env, f, mid_Field_canAccess, NULL);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        (*env)->ExceptionDescribe(env);\n+        return 3;\n+    }\n+    if (rc != canAccess) {\n+        return 4;\n+    }\n+    return 0;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/exeCallerAccessTest\/exeCallerAccessTest.c","additions":110,"deletions":1,"binary":false,"changes":111,"status":"modified"}]}