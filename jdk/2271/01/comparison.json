{"files":[{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/parallel\/immutableSpace.hpp\"\n-#include \"memory\/iterator.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-void ImmutableSpace::initialize(MemRegion mr) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* end    = mr.end();\n-\n-  assert(Universe::on_page_boundary(bottom) && Universe::on_page_boundary(end),\n-         \"invalid space boundaries\");\n-\n-  _bottom = bottom;\n-  _end = end;\n-}\n-\n-void ImmutableSpace::oop_iterate(OopIterateClosure* cl) {\n-  HeapWord* obj_addr = bottom();\n-  HeapWord* t = end();\n-  \/\/ Could call objects iterate, but this is easier.\n-  while (obj_addr < t) {\n-    obj_addr += oop(obj_addr)->oop_iterate_size(cl);\n-  }\n-}\n-\n-void ImmutableSpace::object_iterate(ObjectClosure* cl) {\n-  HeapWord* p = bottom();\n-  while (p < end()) {\n-    cl->do_object(oop(p));\n-    p += oop(p)->size();\n-  }\n-}\n-\n-#ifndef PRODUCT\n-\n-void ImmutableSpace::print_short() const {\n-  tty->print(\" space \" SIZE_FORMAT \"K, 100%% used\", capacity_in_bytes() \/ K);\n-}\n-\n-void ImmutableSpace::print() const {\n-  print_short();\n-  tty->print_cr(\" [\" INTPTR_FORMAT_W(#-6) \",\" INTPTR_FORMAT_W(#-6) \")\", p2i(bottom()), p2i(end()));\n-}\n-\n-#endif\n-\n-void ImmutableSpace::verify() {\n-  HeapWord* p = bottom();\n-  HeapWord* t = end();\n-  HeapWord* prev_p = NULL;\n-  while (p < t) {\n-    oopDesc::verify(oop(p));\n-    prev_p = p;\n-    p += oop(p)->size();\n-  }\n-  guarantee(p == end(), \"end of last object must match end of space\");\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/immutableSpace.cpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_PARALLEL_IMMUTABLESPACE_HPP\n-#define SHARE_GC_PARALLEL_IMMUTABLESPACE_HPP\n-\n-#include \"memory\/iterator.hpp\"\n-\n-\/\/ An ImmutableSpace is a viewport into a contiguous range\n-\/\/ (or subrange) of previously allocated objects.\n-\n-\/\/ Invariant: bottom() and end() are on page_size boundaries and\n-\/\/ bottom() <= end()\n-\n-class ImmutableSpace: public CHeapObj<mtGC> {\n-  friend class VMStructs;\n- protected:\n-  HeapWord* _bottom;\n-  HeapWord* _end;\n-\n- public:\n-  ImmutableSpace()                   { _bottom = NULL; _end = NULL;  }\n-  HeapWord* bottom() const           { return _bottom;               }\n-  HeapWord* end() const              { return _end;                  }\n-\n-  MemRegion region() const { return MemRegion(bottom(), end()); }\n-\n-  \/\/ Initialization\n-  void initialize(MemRegion mr);\n-\n-  bool contains(const void* p) const { return _bottom <= p && p < _end; }\n-\n-  \/\/ Size computations.  Sizes are in bytes.\n-  size_t capacity_in_bytes() const            { return capacity_in_words() * HeapWordSize; }\n-\n-  \/\/ Size computations.  Sizes are in heapwords.\n-  size_t capacity_in_words() const                { return pointer_delta(end(), bottom()); }\n-  virtual size_t capacity_in_words(Thread*) const { return capacity_in_words(); }\n-\n-  \/\/ Iteration.\n-  virtual void oop_iterate(OopIterateClosure* cl);\n-  virtual void object_iterate(ObjectClosure* cl);\n-\n-  \/\/ Debugging\n-  virtual void print() const            PRODUCT_RETURN;\n-  virtual void print_short() const      PRODUCT_RETURN;\n-  virtual void verify();\n-};\n-\n-#endif \/\/ SHARE_GC_PARALLEL_IMMUTABLESPACE_HPP\n","filename":"src\/hotspot\/share\/gc\/parallel\/immutableSpace.hpp","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -38,1 +38,8 @@\n-MutableSpace::MutableSpace(size_t alignment): ImmutableSpace(), _alignment(alignment), _top(NULL) {\n+MutableSpace::MutableSpace(size_t alignment) :\n+  _mangler(NULL),\n+  _last_setup_region(),\n+  _alignment(alignment),\n+  _bottom(NULL),\n+  _top(NULL),\n+  _end(NULL)\n+{\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"gc\/parallel\/immutableSpace.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n@@ -31,0 +32,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -34,4 +37,5 @@\n-\/\/ A MutableSpace is a subtype of ImmutableSpace that supports the\n-\/\/ concept of allocation. This includes the concepts that a space may\n-\/\/ be only partially full, and the query methods that go with such\n-\/\/ an assumption. MutableSpace is also responsible for minimizing the\n+\/\/ A MutableSpace supports the concept of allocation. This includes the\n+\/\/ concepts that a space may be only partially full, and the query methods\n+\/\/ that go with such an assumption.\n+\/\/\n+\/\/ MutableSpace is also responsible for minimizing the\n@@ -42,2 +46,2 @@\n-\/\/ Invariant: (ImmutableSpace +) bottom() <= top() <= end()\n-\/\/ top() is inclusive and end() is exclusive.\n+\/\/ Invariant: bottom() <= top() <= end()\n+\/\/ top() and end() are exclusive.\n@@ -47,1 +51,1 @@\n-class MutableSpace: public ImmutableSpace {\n+class MutableSpace: public CHeapObj<mtGC> {\n@@ -55,1 +59,1 @@\n- protected:\n+  HeapWord* _bottom;\n@@ -57,0 +61,1 @@\n+  HeapWord* _end;\n@@ -70,0 +75,1 @@\n+  HeapWord* bottom() const                 { return _bottom; }\n@@ -71,0 +77,3 @@\n+  HeapWord* end() const                    { return _end; }\n+\n+  void set_bottom(HeapWord* value)         { _bottom = value; }\n@@ -72,0 +81,1 @@\n+  void set_end(HeapWord* value)            { _end = value; }\n@@ -76,3 +86,0 @@\n-  virtual void set_bottom(HeapWord* value) { _bottom = value; }\n-  virtual void set_end(HeapWord* value)    { _end = value; }\n-\n@@ -81,0 +88,6 @@\n+  MemRegion region() const { return MemRegion(bottom(), end()); }\n+\n+  size_t capacity_in_bytes() const { return capacity_in_words() * HeapWordSize; }\n+  size_t capacity_in_words() const { return pointer_delta(end(), bottom()); }\n+  virtual size_t capacity_in_words(Thread*) const { return capacity_in_words(); }\n+\n@@ -95,4 +108,0 @@\n-  \/\/ Does the usual initialization but optionally resets top to bottom.\n-#if 0  \/\/ MANGLE_SPACE\n-  void initialize(MemRegion mr, bool clear_space, bool reset_top);\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"gc\/parallel\/immutableSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/spaceCounters.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"gc\/parallel\/immutableSpace.hpp\"\n@@ -49,3 +48,2 @@\n-  nonstatic_field(ImmutableSpace,              _bottom,                                       HeapWord*)                             \\\n-  nonstatic_field(ImmutableSpace,              _end,                                          HeapWord*)                             \\\n-                                                                                                                                     \\\n+  nonstatic_field(MutableSpace,                _bottom,                                       HeapWord*)                             \\\n+  nonstatic_field(MutableSpace,                _end,                                          HeapWord*)                             \\\n@@ -84,2 +82,1 @@\n-  declare_toplevel_type(ImmutableSpace)                                   \\\n-           declare_type(MutableSpace, ImmutableSpace)                     \\\n+  declare_toplevel_type(MutableSpace)                                     \\\n@@ -94,1 +91,0 @@\n-  declare_toplevel_type(ImmutableSpace*)                                  \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/vmStructs_parallelgc.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.parallel;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.memory.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public abstract class ImmutableSpace extends VMObject {\n-   static {\n-      VM.registerVMInitializedObserver(new Observer() {\n-         public void update(Observable o, Object data) {\n-            initialize(VM.getVM().getTypeDataBase());\n-         }\n-      });\n-   }\n-\n-   private static synchronized void initialize(TypeDataBase db) {\n-      Type type = db.lookupType(\"ImmutableSpace\");\n-      bottomField = type.getAddressField(\"_bottom\");\n-      endField    = type.getAddressField(\"_end\");\n-   }\n-\n-   public ImmutableSpace(Address addr) {\n-      super(addr);\n-   }\n-\n-   \/\/ Fields\n-   private static AddressField bottomField;\n-   private static AddressField endField;\n-\n-   \/\/ Accessors\n-   public Address   bottom()       { return bottomField.getValue(addr); }\n-   public Address   end()          { return endField.getValue(addr);    }\n-\n-   \/** Returns a subregion of the space containing all the objects in\n-      the space. *\/\n-   public MemRegion usedRegion() {\n-      return new MemRegion(bottom(), end());\n-   }\n-\n-   \/** Support for iteration over heap -- not sure how this will\n-      interact with GC in reflective system, but necessary for the\n-      debugging mechanism *\/\n-   public OopHandle bottomAsOopHandle() {\n-      return bottomField.getOopHandle(addr);\n-   }\n-\n-   \/** returns all MemRegions where live objects are *\/\n-   public abstract List<MemRegion> getLiveRegions();\n-\n-   \/** Returned value is in bytes *\/\n-   public long capacity() { return end().minus(bottom()); }\n-\n-   public abstract long used();\n-\n-   \/** Testers *\/\n-   public boolean contains(Address p) {\n-      return (bottom().lessThanOrEqual(p) && end().greaterThan(p));\n-   }\n-\n-   public void print() { printOn(System.out); }\n-   public abstract void printOn(PrintStream tty);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/parallel\/ImmutableSpace.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-public class MutableSpace extends ImmutableSpace {\n+public class MutableSpace extends VMObject {\n@@ -48,0 +48,2 @@\n+      bottomField = type.getAddressField(\"_bottom\");\n+      endField    = type.getAddressField(\"_end\");\n@@ -56,0 +58,2 @@\n+   private static AddressField bottomField;\n+   private static AddressField endField;\n@@ -59,0 +63,2 @@\n+   public Address   bottom()       { return bottomField.getValue(addr); }\n+   public Address   end()          { return endField.getValue(addr);    }\n@@ -66,0 +72,16 @@\n+   \/** Returned value is in bytes *\/\n+   public long capacity() { return end().minus(bottom()); }\n+\n+   \/** Returns a subregion of the space containing all the objects in\n+      the space. *\/\n+   public MemRegion usedRegion() {\n+      return new MemRegion(bottom(), end());\n+   }\n+\n+   \/** Support for iteration over heap -- not sure how this will\n+      interact with GC in reflective system, but necessary for the\n+      debugging mechanism *\/\n+   public OopHandle bottomAsOopHandle() {\n+      return bottomField.getOopHandle(addr);\n+   }\n+\n@@ -73,0 +95,6 @@\n+   \/** Testers *\/\n+   public boolean contains(Address p) {\n+      return (bottom().lessThanOrEqual(p) && end().greaterThan(p));\n+   }\n+\n+   public void print() { printOn(System.out); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/parallel\/MutableSpace.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"}]}