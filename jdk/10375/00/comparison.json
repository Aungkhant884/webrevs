{"files":[{"patch":"@@ -3960,0 +3960,203 @@\n+\n+\/\/ The java_calling_convention describes stack locations as ideal slots on\n+\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n+\/\/ (like the placement of the register window) the slots must be biased by\n+\/\/ the following value.\n+static int reg2offset_in(VMReg r) {\n+  \/\/ Account for saved fp and ra\n+  \/\/ This should really be in_preserve_stack_slots\n+  return r->reg2stack() * VMRegImpl::stack_slot_size;\n+}\n+\n+static int reg2offset_out(VMReg r) {\n+  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n+}\n+\n+\/\/ On 64 bit we will store integer like items to the stack as\n+\/\/ 64 bits items (riscv64 abi) even though java would only store\n+\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n+\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+void MacroAssembler::move32_64(VMRegPair src, VMRegPair dst, Register tmp) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else {\n+      \/\/ stack to reg\n+      lw(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n+  } else {\n+    if (dst.first() != src.first()) {\n+      \/\/ 32bits extend sign\n+      addw(dst.first()->as_Register(), src.first()->as_Register(), zr);\n+    }\n+  }\n+}\n+\n+\/\/ An oop arg. Must pass a handle not the oop itself\n+void MacroAssembler::object_move(OopMap* map,\n+                                 int oop_handle_offset,\n+                                 int framesize_in_slots,\n+                                 VMRegPair src,\n+                                 VMRegPair dst,\n+                                 bool is_receiver,\n+                                 int* receiver_offset) {\n+  assert_cond(map != NULL && receiver_offset != NULL);\n+  \/\/ must pass a handle. First figure out the location we use as a handle\n+  Register rHandle = dst.first()->is_stack() ? t1 : dst.first()->as_Register();\n+\n+  \/\/ See if oop is NULL if it is we need no handle\n+\n+  if (src.first()->is_stack()) {\n+    \/\/ Oop is already on the stack as an argument\n+    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n+    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n+    if (is_receiver) {\n+      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n+    }\n+\n+    ld(t0, Address(fp, reg2offset_in(src.first())));\n+    la(rHandle, Address(fp, reg2offset_in(src.first())));\n+    \/\/ conditionally move a NULL\n+    Label notZero1;\n+    bnez(t0, notZero1);\n+    mv(rHandle, zr);\n+    bind(notZero1);\n+  } else {\n+\n+    \/\/ Oop is in a register we must store it to the space we reserve\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+\n+    const Register rOop = src.first()->as_Register();\n+    int oop_slot = -1;\n+    if (rOop == j_rarg0) {\n+      oop_slot = 0;\n+    } else if (rOop == j_rarg1) {\n+      oop_slot = 1;\n+    } else if (rOop == j_rarg2) {\n+      oop_slot = 2;\n+    } else if (rOop == j_rarg3) {\n+      oop_slot = 3;\n+    } else if (rOop == j_rarg4) {\n+      oop_slot = 4;\n+    } else if (rOop == j_rarg5) {\n+      oop_slot = 5;\n+    } else if (rOop == j_rarg6) {\n+      oop_slot = 6;\n+    } else {\n+      assert(rOop == j_rarg7, \"wrong register\");\n+      oop_slot = 7;\n+    }\n+\n+    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n+    int offset = oop_slot * VMRegImpl::stack_slot_size;\n+\n+    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n+    \/\/ Store oop in handle area, may be NULL\n+    sd(rOop, Address(sp, offset));\n+    if (is_receiver) {\n+      *receiver_offset = offset;\n+    }\n+\n+    \/\/rOop maybe the same as rHandle\n+    if (rOop == rHandle) {\n+      Label isZero;\n+      beqz(rOop, isZero);\n+      la(rHandle, Address(sp, offset));\n+      bind(isZero);\n+    } else {\n+      Label notZero2;\n+      la(rHandle, Address(sp, offset));\n+      bnez(rOop, notZero2);\n+      mv(rHandle, zr);\n+      bind(notZero2);\n+    }\n+  }\n+\n+  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n+  if (dst.first()->is_stack()) {\n+    sd(rHandle, Address(sp, reg2offset_out(dst.first())));\n+  }\n+}\n+\n+\/\/ A float arg may have to do float reg int reg conversion\n+void MacroAssembler::float_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n+         src.first()->is_reg() && dst.first()->is_reg() ||\n+         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      lwu(tmp, Address(fp, reg2offset_in(src.first())));\n+      sw(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else if (dst.first()->is_Register()) {\n+      lwu(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else if (src.first() != dst.first()) {\n+    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n+      fmv_s(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\/\/ A long move\n+void MacroAssembler::long_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else {\n+      \/\/ stack to reg\n+      ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n+  } else {\n+    if (dst.first() != src.first()) {\n+      mv(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+\/\/ A double move\n+void MacroAssembler::double_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n+         src.first()->is_reg() && dst.first()->is_reg() ||\n+         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else if (dst.first()-> is_Register()) {\n+      ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else if (src.first() != dst.first()) {\n+    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n+      fmv_d(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+void MacroAssembler::rt_call(address dest, Register tmp) {\n+  CodeBlob *cb = CodeCache::find_blob(dest);\n+  if (cb) {\n+    far_call(RuntimeAddress(dest));\n+  } else {\n+    int32_t offset = 0;\n+    la_patchable(tmp, RuntimeAddress(dest), offset);\n+    jalr(x1, tmp, offset);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -872,0 +873,16 @@\n+\n+  \/\/ support for argument shuffling\n+  void move32_64(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void float_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void long_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void double_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void object_move(OopMap* map,\n+                   int oop_handle_offset,\n+                   int framesize_in_slots,\n+                   VMRegPair src,\n+                   VMRegPair dst,\n+                   bool is_receiver,\n+                   int* receiver_offset);\n+\n+  void rt_call(address dest, Register tmp = t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -222,14 +222,0 @@\n-\/\/ The java_calling_convention describes stack locations as ideal slots on\n-\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n-\/\/ (like the placement of the register window) the slots must be biased by\n-\/\/ the following value.\n-static int reg2offset_in(VMReg r) {\n-  \/\/ Account for saved fp and ra\n-  \/\/ This should really be in_preserve_stack_slots\n-  return r->reg2stack() * VMRegImpl::stack_slot_size;\n-}\n-\n-static int reg2offset_out(VMReg r) {\n-  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n-}\n-\n@@ -764,177 +750,0 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else {\n-      \/\/ stack to reg\n-      __ lw(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n-  } else {\n-    if (dst.first() != src.first()) {\n-      \/\/ 32bits extend sign\n-      __ addw(dst.first()->as_Register(), src.first()->as_Register(), zr);\n-    }\n-  }\n-}\n-\n-\/\/ An oop arg. Must pass a handle not the oop itself\n-static void object_move(MacroAssembler* masm,\n-                        OopMap* map,\n-                        int oop_handle_offset,\n-                        int framesize_in_slots,\n-                        VMRegPair src,\n-                        VMRegPair dst,\n-                        bool is_receiver,\n-                        int* receiver_offset) {\n-  \/\/ must pass a handle. First figure out the location we use as a handle\n-  Register rHandle = dst.first()->is_stack() ? t1 : dst.first()->as_Register();\n-\n-  \/\/ See if oop is NULL if it is we need no handle\n-\n-  if (src.first()->is_stack()) {\n-\n-    \/\/ Oop is already on the stack as an argument\n-    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n-    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n-    if (is_receiver) {\n-      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n-    }\n-\n-    __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-    __ la(rHandle, Address(fp, reg2offset_in(src.first())));\n-    \/\/ conditionally move a NULL\n-    Label notZero1;\n-    __ bnez(t0, notZero1);\n-    __ mv(rHandle, zr);\n-    __ bind(notZero1);\n-  } else {\n-\n-    \/\/ Oop is in a register we must store it to the space we reserve\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n-\n-    const Register rOop = src.first()->as_Register();\n-    int oop_slot = -1;\n-    if (rOop == j_rarg0) {\n-      oop_slot = 0;\n-    } else if (rOop == j_rarg1) {\n-      oop_slot = 1;\n-    } else if (rOop == j_rarg2) {\n-      oop_slot = 2;\n-    } else if (rOop == j_rarg3) {\n-      oop_slot = 3;\n-    } else if (rOop == j_rarg4) {\n-      oop_slot = 4;\n-    } else if (rOop == j_rarg5) {\n-      oop_slot = 5;\n-    } else if (rOop == j_rarg6) {\n-      oop_slot = 6;\n-    } else {\n-      assert(rOop == j_rarg7, \"wrong register\");\n-      oop_slot = 7;\n-    }\n-\n-    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n-    int offset = oop_slot * VMRegImpl::stack_slot_size;\n-\n-    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n-    \/\/ Store oop in handle area, may be NULL\n-    __ sd(rOop, Address(sp, offset));\n-    if (is_receiver) {\n-      *receiver_offset = offset;\n-    }\n-\n-    \/\/rOop maybe the same as rHandle\n-    if (rOop == rHandle) {\n-      Label isZero;\n-      __ beqz(rOop, isZero);\n-      __ la(rHandle, Address(sp, offset));\n-      __ bind(isZero);\n-    } else {\n-      Label notZero2;\n-      __ la(rHandle, Address(sp, offset));\n-      __ bnez(rOop, notZero2);\n-      __ mv(rHandle, zr);\n-      __ bind(notZero2);\n-    }\n-  }\n-\n-  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n-  if (dst.first()->is_stack()) {\n-    __ sd(rHandle, Address(sp, reg2offset_out(dst.first())));\n-  }\n-}\n-\n-\/\/ A float arg may have to do float reg int reg conversion\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() || src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      __ lwu(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sw(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else if (dst.first()->is_Register()) {\n-      __ lwu(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  } else if (src.first() != dst.first()) {\n-    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n-      __ fmv_s(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n-\/\/ A long move\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else {\n-      \/\/ stack to reg\n-      __ ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n-  } else {\n-    if (dst.first() != src.first()) {\n-      __ mv(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-\/\/ A double move\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() || src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else if (dst.first()-> is_Register()) {\n-      __ ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  } else if (src.first() != dst.first()) {\n-    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n-      __ fmv_d(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n@@ -1008,11 +817,0 @@\n-static void rt_call(MacroAssembler* masm, address dest) {\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  if (cb) {\n-    __ far_call(RuntimeAddress(dest));\n-  } else {\n-    int32_t offset = 0;\n-    __ la_patchable(t0, RuntimeAddress(dest), offset);\n-    __ jalr(x1, t0, offset);\n-  }\n-}\n-\n@@ -1400,3 +1198,3 @@\n-        object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n-                    ((i == 0) && (!is_static)),\n-                    &receiver_offset);\n+        __ object_move(map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n+                       ((i == 0) && (!is_static)),\n+                       &receiver_offset);\n@@ -1409,1 +1207,1 @@\n-        float_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ float_move(in_regs[i], out_regs[c_arg]);\n@@ -1417,1 +1215,1 @@\n-        double_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ double_move(in_regs[i], out_regs[c_arg]);\n@@ -1422,1 +1220,1 @@\n-        long_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ long_move(in_regs[i], out_regs[c_arg]);\n@@ -1431,1 +1229,1 @@\n-        move32_64(masm, in_regs[i], out_regs[c_arg]);\n+        __ move32_64(in_regs[i], out_regs[c_arg]);\n@@ -1561,1 +1359,1 @@\n-  rt_call(masm, native_func);\n+  __ rt_call(native_func);\n@@ -1757,1 +1555,1 @@\n-    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));\n@@ -1784,1 +1582,1 @@\n-  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":10,"deletions":212,"binary":false,"changes":222,"status":"modified"}]}