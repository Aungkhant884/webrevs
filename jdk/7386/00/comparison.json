{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -422,1 +422,1 @@\n-                        if (iterator.hasNext()) {\n+                        while (iterator.hasNext()) {\n@@ -425,1 +425,1 @@\n-                                entryNameSeparator;\n+                                    entryNameSeparator;\n@@ -427,2 +427,5 @@\n-                        } else {\n-                            return false;\n+                            if (aliases.hasMoreElements()) {\n+                                return true;\n+                            } else {\n+                                continue;\n+                            }\n@@ -430,0 +433,1 @@\n+                        return false;\n@@ -434,2 +438,0 @@\n-\n-                return aliases.hasMoreElements();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DomainKeyStore.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265765\n+ * @summary Test DomainKeyStore with a collection of keystores that has an empty one in between\n+ *          based on the test in the bug report\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.DomainLoadStoreParameter;\n+import java.security.KeyStore;\n+import java.util.Enumeration;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.crypto.KeyGenerator;\n+\n+public class DksWithEmptyKeystore {\n+    private static void write(Path p, KeyStore keystore) throws Exception {\n+        try (OutputStream outputStream = Files.newOutputStream(p)) {\n+            keystore.store(outputStream, new char[] { 'x' });\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n+        kg.init(256);\n+\n+        \/\/ Create a keystore with one key\n+        KeyStore nonEmptyKeystore = KeyStore.getInstance(\"PKCS12\");\n+        nonEmptyKeystore.load(null, null);\n+\n+        Path nonEmptyPath = Path.of(\"non_empty.p12\");\n+        nonEmptyKeystore.setKeyEntry(\"aeskey\", kg.generateKey(), new char[] { 'a' }, null);\n+        write(nonEmptyPath, nonEmptyKeystore);\n+\n+        \/\/ Create an empty keystore\n+        KeyStore emptyKeystore = KeyStore.getInstance(\"PKCS12\");\n+        emptyKeystore.load(null, null);\n+\n+        Path emptyPath = Path.of(\"empty.p12\");\n+        write(emptyPath, emptyKeystore);\n+\n+        \/\/ Create a domain keystore with two non-empty keystores\n+        Path dksWithTwoPartsPath = Path.of(\"two-parts.dks\");\n+        var twoPartsConfiguration = \"domain Combo { keystore a keystoreURI=\\\"%s\\\";\" +\n+                \"keystore b keystoreURI=\\\"%s\\\"; };\";\n+        Files.writeString(dksWithTwoPartsPath, String.format(twoPartsConfiguration,\n+                nonEmptyPath.toUri(), nonEmptyPath.toUri()));\n+        Map<String,KeyStore.ProtectionParameter> protectionParameters = new LinkedHashMap<>();\n+\n+        KeyStore dksKeystore = KeyStore.getInstance(\"DKS\");\n+        dksKeystore.load(new DomainLoadStoreParameter(dksWithTwoPartsPath.toUri(), protectionParameters));\n+        System.out.printf(\"%s size: %d%n\", dksWithTwoPartsPath, dksKeystore.size());\n+\n+        int index = 0;\n+        for (Enumeration<String> enumeration = dksKeystore.aliases(); enumeration.hasMoreElements(); ) {\n+            System.out.printf(\"%d: %s%n\", index, enumeration.nextElement());\n+            index++;\n+        }\n+\n+        System.out.printf(\"enumerated aliases from %s: %d%n\", dksWithTwoPartsPath, index);\n+        if (index != dksKeystore.size()) {\n+            throw new Exception(\"Failed to get the number of aliases in the domain keystore \" +\n+                    \"that has two keystores.\");\n+        }\n+\n+        \/\/ Create a domain keystore with two non-empty keystores and an empty one in between\n+        Path dksWithThreePartsPath = Path.of(\"three-parts.dks\");\n+        var threePartsConfiguration = \"domain Combo { keystore a keystoreURI=\\\"%s\\\";\" +\n+                \"keystore b keystoreURI=\\\"%s\\\";\" +\n+                \"keystore c keystoreURI=\\\"%s\\\"; };\";\n+        Files.writeString(dksWithThreePartsPath, String.format(threePartsConfiguration,\n+                nonEmptyPath.toUri(), emptyPath.toUri(), nonEmptyPath.toUri()));\n+\n+        KeyStore dksKeystore1 = KeyStore.getInstance(\"DKS\");\n+        dksKeystore1.load(new DomainLoadStoreParameter(dksWithThreePartsPath.toUri(), protectionParameters));\n+        System.out.printf(\"%s size: %d%n\", dksWithThreePartsPath, dksKeystore1.size());\n+\n+        index = 0;\n+        for (Enumeration<String> enumeration = dksKeystore1.aliases(); enumeration.hasMoreElements(); ) {\n+            System.out.printf(\"%d: %s%n\", index, enumeration.nextElement());\n+            index++;\n+        }\n+\n+        System.out.printf(\"enumerated aliases from %s: %d%n\", dksWithThreePartsPath, index);\n+        if (index != dksKeystore1.size()) {\n+            throw new Exception(\"Failed to get the number of aliases in the domain keystore \" +\n+                    \"that has three keystores with an empty one in between.\");\n+        } else {\n+            System.out.printf(\"Test completed successfully\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/KeyStore\/DksWithEmptyKeystore.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}