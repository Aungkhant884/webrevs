{"files":[{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n@@ -242,0 +241,8 @@\n+\n+void ZLoadBarrierOopClosure::do_oop(oop* p) {\n+  ZBarrier::load_barrier_on_oop_field(p);\n+}\n+\n+void ZLoadBarrierOopClosure::do_oop(narrowOop* p) {\n+  ShouldNotReachHere();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -125,0 +126,6 @@\n+class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n+public:\n+  virtual void do_oop(oop* p);\n+  virtual void do_oop(narrowOop* p);\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/z\/zOopClosures.hpp\"\n@@ -56,3 +55,4 @@\n-  \/\/ Heal oops and disarm\n-  ZNMethodOopClosure cl;\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+  \/\/ Heal oops\n+  ZNMethod::nmethod_oops_barrier(nm);\n+\n+  \/\/ Disarm\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/z\/zHeap.inline.hpp\"\n@@ -35,1 +37,1 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n+#include \"gc\/z\/zOop.inline.hpp\"\n@@ -239,0 +241,20 @@\n+template <bool finalizable>\n+class ZMarkBarrierOopClosure : public ClaimMetadataVisitingOopIterateClosure {\n+public:\n+  ZMarkBarrierOopClosure() :\n+      ClaimMetadataVisitingOopIterateClosure(finalizable\n+                                                 ? ClassLoaderData::_claim_finalizable\n+                                                 : ClassLoaderData::_claim_strong,\n+                                             finalizable\n+                                                 ? NULL\n+                                                 : ZHeap::heap()->reference_discoverer()) {}\n+\n+  virtual void do_oop(oop* p) {\n+    ZBarrier::mark_barrier_on_oop_field(p, finalizable);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n@@ -44,0 +44,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -246,0 +247,20 @@\n+class ZNMethodOopClosure : public OopClosure {\n+public:\n+  virtual void do_oop(oop* p) {\n+    if (ZResurrection::is_blocked()) {\n+      ZBarrier::keep_alive_barrier_on_phantom_root_oop_field(p);\n+    } else {\n+      ZBarrier::load_barrier_on_root_oop_field(p);\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+void ZNMethod::nmethod_oops_barrier(nmethod* nm) {\n+  ZNMethodOopClosure cl;\n+  nmethod_oops_do_inner(nm, &cl);\n+}\n+\n@@ -310,2 +331,1 @@\n-      ZNMethodOopClosure cl;\n-      ZNMethod::nmethod_oops_do(nm, &cl);\n+      ZNMethod::nmethod_oops_barrier(nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  static void nmethod_oops_barrier(nmethod* nm);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZOOPCLOSURES_HPP\n-#define SHARE_GC_Z_ZOOPCLOSURES_HPP\n-\n-#include \"memory\/iterator.hpp\"\n-\n-class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n-public:\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-class ZNMethodOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-template <bool finalizable>\n-class ZMarkBarrierOopClosure : public ClaimMetadataVisitingOopIterateClosure {\n-public:\n-  ZMarkBarrierOopClosure();\n-\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-class ZPhantomIsAliveObjectClosure : public BoolObjectClosure {\n-public:\n-  virtual bool do_object_b(oop o);\n-};\n-\n-class ZPhantomCleanOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n-\n-#endif \/\/ SHARE_GC_Z_ZOOPCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZOOPCLOSURES_INLINE_HPP\n-#define SHARE_GC_Z_ZOOPCLOSURES_INLINE_HPP\n-\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n-#include \"gc\/z\/zHeap.inline.hpp\"\n-#include \"gc\/z\/zOop.inline.hpp\"\n-#include \"gc\/z\/zOopClosures.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-inline void ZLoadBarrierOopClosure::do_oop(oop* p) {\n-  ZBarrier::load_barrier_on_oop_field(p);\n-}\n-\n-inline void ZLoadBarrierOopClosure::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n-}\n-\n-inline void ZNMethodOopClosure::do_oop(oop* p) {\n-  if (ZResurrection::is_blocked()) {\n-    ZBarrier::keep_alive_barrier_on_phantom_root_oop_field(p);\n-  } else {\n-    ZBarrier::load_barrier_on_root_oop_field(p);\n-  }\n-}\n-\n-inline void ZNMethodOopClosure::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n-}\n-\n-template <bool finalizable>\n-inline ZMarkBarrierOopClosure<finalizable>::ZMarkBarrierOopClosure() :\n-    ClaimMetadataVisitingOopIterateClosure(finalizable\n-                                               ? ClassLoaderData::_claim_finalizable\n-                                               : ClassLoaderData::_claim_strong,\n-                                           finalizable\n-                                               ? NULL\n-                                               : ZHeap::heap()->reference_discoverer()) {}\n-\n-template <bool finalizable>\n-inline void ZMarkBarrierOopClosure<finalizable>::do_oop(oop* p) {\n-  ZBarrier::mark_barrier_on_oop_field(p, finalizable);\n-}\n-\n-template <bool finalizable>\n-inline void ZMarkBarrierOopClosure<finalizable>::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n-}\n-\n-inline bool ZPhantomIsAliveObjectClosure::do_object_b(oop o) {\n-  return ZBarrier::is_alive_barrier_on_phantom_oop(o);\n-}\n-\n-inline void ZPhantomCleanOopClosure::do_oop(oop* p) {\n-  \/\/ Read the oop once, to make sure the liveness check\n-  \/\/ and the later clearing uses the same value.\n-  const oop obj = Atomic::load(p);\n-  if (ZBarrier::is_alive_barrier_on_phantom_oop(obj)) {\n-    ZBarrier::keep_alive_barrier_on_phantom_oop_field(p);\n-  } else {\n-    \/\/ The destination could have been modified\/reused, in which case\n-    \/\/ we don't want to clear it. However, no one could write the same\n-    \/\/ oop here again (the object would be strongly live and we would\n-    \/\/ not consider clearing such oops), so therefore we don't have an\n-    \/\/ ABA problem here.\n-    Atomic::cmpxchg(p, obj, oop(NULL));\n-  }\n-}\n-\n-inline void ZPhantomCleanOopClosure::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZOOPCLOSURES_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.inline.hpp","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/z\/zOopClosures.hpp\"\n+#include \"gc\/z\/zBarrier.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n@@ -42,0 +42,7 @@\n+class ZPhantomIsAliveObjectClosure : public BoolObjectClosure {\n+public:\n+  virtual bool do_object_b(oop o) {\n+    return ZBarrier::is_alive_barrier_on_phantom_oop(o);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zWeakRootsProcessor.hpp\"\n@@ -30,0 +31,23 @@\n+class ZPhantomCleanOopClosure : public OopClosure {\n+public:\n+  virtual void do_oop(oop* p) {\n+    \/\/ Read the oop once, to make sure the liveness check\n+    \/\/ and the later clearing uses the same value.\n+    const oop obj = Atomic::load(p);\n+    if (ZBarrier::is_alive_barrier_on_phantom_oop(obj)) {\n+      ZBarrier::keep_alive_barrier_on_phantom_oop_field(p);\n+    } else {\n+      \/\/ The destination could have been modified\/reused, in which case\n+      \/\/ we don't want to clear it. However, no one could write the same\n+      \/\/ oop here again (the object would be strongly live and we would\n+      \/\/ not consider clearing such oops), so therefore we don't have an\n+      \/\/ ABA problem here.\n+      Atomic::cmpxchg(p, obj, oop(NULL));\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}