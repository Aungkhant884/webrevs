{"files":[{"patch":"@@ -3869,0 +3869,109 @@\n+  RuntimeStub* generate_cont_doYield() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw(bool return_barrier, bool exception) {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier_exception() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+#if INCLUDE_JFR\n+\n+  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+    Register java_thread = rdi;\n+    __ get_thread(java_thread);\n+    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc);\n+    __ movptr(Address(rsp, 0), java_thread);\n+  }\n+\n+  \/\/ The handle is dereferenced through a load barrier.\n+  static void jfr_epilogue(MacroAssembler* masm) {\n+    Register java_thread = rdi;\n+    __ get_thread(java_thread);\n+    __ reset_last_Java_frame(java_thread, true);\n+    Label null_jobject;\n+    __ testptr(rax, rax);\n+    __ jcc(Assembler::zero, null_jobject);\n+    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->load_at(masm, decorators, T_OBJECT, rax, Address(rax, 0), noreg, java_thread);\n+    __ bind(null_jobject);\n+  }\n+\n+  static RuntimeStub* generate_jfr_stub(const char* name, address entrypoint) {\n+    enum layout {\n+      FPUState_off         = 0,\n+      rbp_off              = FPUStateSizeInWords,\n+      rdi_off,\n+      rsi_off,\n+      rcx_off,\n+      rbx_off,\n+      saved_argument_off,\n+      saved_argument_off2, \/\/ 2nd half of double\n+      framesize\n+    };\n+\n+    int insts_size = 512;\n+    int locs_size = 64;\n+    CodeBuffer code(name, insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm);\n+    __ call_VM_leaf(entrypoint, 1);\n+    jfr_epilogue(_masm);\n+    __ leave();\n+    __ ret(0);\n+\n+    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  RuntimeStub* generate_jfr_write_checkpoint() {\n+    return generate_jfr_stub(\"jfr_write_checkpoint\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint));\n+  }\n+\n+  \/\/ For c1: call the corresponding runtime routine, it returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  RuntimeStub* generate_jfr_get_event_writer() {\n+    return generate_jfr_stub(\"jfr_get_event_writer\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::event_writer));\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -3956,0 +4065,15 @@\n+  void generate_phase1() {\n+    \/\/ Continuation stubs:\n+    StubRoutines::_cont_thaw          = generate_cont_thaw();\n+    StubRoutines::_cont_returnBarrier = generate_cont_returnBarrier();\n+    StubRoutines::_cont_returnBarrierExc = generate_cont_returnBarrier_exception();\n+    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n+    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n+                                                                                   : StubRoutines::_cont_doYield_stub->entry_point();\n+\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer_stub = generate_jfr_get_event_writer();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer = StubRoutines::_jfr_get_event_writer_stub->entry_point();)\n+  }\n+\n@@ -4047,4 +4171,2 @@\n-  StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {\n-    if (all) {\n-      generate_all();\n-    } else {\n+  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n+    if (phase == 0) {\n@@ -4052,0 +4174,4 @@\n+    } else if (phase == 1) {\n+      generate_phase1(); \/\/ stubs that must be available for the interpreter\n+    } else {\n+      generate_all();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":130,"deletions":4,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-#ifdef ASSERT\n@@ -141,1 +140,0 @@\n-#endif \/\/ ASSERT\n@@ -180,2 +178,1 @@\n-  _stack_arg_slots = align_up(_stack_arg_slots, 2);\n-\n+#if defined(_LP64) && !defined(ZERO)\n@@ -183,0 +180,1 @@\n+  _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -184,1 +182,0 @@\n-#if defined(_LP64) && !defined(ZERO)\n@@ -187,0 +184,3 @@\n+#else\n+  \/\/ Fallback: computed _stack_arg_slots is unreliable, compute directly.\n+  _stack_arg_slots = compute_num_stack_arg_slots(_signature, _param_size, static_flag);\n@@ -223,1 +223,4 @@\n-  \/\/ The value computed for 32-bit ports and for zero is bogus, and will need to be fixed.\n+  \/\/ TODO: SharedRuntime::java_calling_convention is the shared code that knows all details\n+  \/\/ about the platform-specific calling conventions. This method tries to compute the stack\n+  \/\/ args number... poorly, at least for 32-bit ports and for zero. Current code has the fallback\n+  \/\/ that recomputes the stack args number from SharedRuntime::java_calling_convention.\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}