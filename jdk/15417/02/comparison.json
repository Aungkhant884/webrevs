{"files":[{"patch":"@@ -50,1 +50,1 @@\n-#ifdef ABI_ELFv2\n+#ifdef LINUX\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    LINUX_PPC_64,\n@@ -77,0 +78,4 @@\n+            } else if (arch.equals(\"ppc64\")) {\n+                if (OperatingSystem.isLinux()) {\n+                    return LINUX_PPC_64;\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64Linker;\n@@ -63,1 +64,2 @@\n-                                                                      Windowsx64Linker, LinuxPPC64leLinker,\n+                                                                      Windowsx64Linker,\n+                                                                      LinuxPPC64Linker, LinuxPPC64leLinker,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,0 +279,4 @@\n+    static ShiftLeft shiftLeft(int shiftAmount, Class<?> type ) {\n+        return new ShiftLeft(shiftAmount, type);\n+    }\n+\n@@ -390,0 +394,12 @@\n+        public Binding.Builder shiftLeft(int shiftAmount, Class<?> type) {\n+            if (shiftAmount > 0 && isSubIntType(type)) {\n+                bindings.add(Binding.cast(type, int.class));\n+                type = int.class;\n+            }\n+            bindings.add(Binding.shiftLeft(shiftAmount, type));\n+            if (shiftAmount < 0 && isSubIntType(type)) {\n+                bindings.add(Binding.cast(int.class, type));\n+            }\n+            return this;\n+        }\n+\n@@ -673,0 +689,49 @@\n+    \/**\n+     * ShiftLeft([shiftAmount])\n+     *   Shifts the Bytes on the top of the operand stack (unsigned).\n+     *   Positive [shiftAmount] converts to long if needed and shifts left.\n+     *   Negative [shiftAmount] shifts right and converts to int if needed.\n+     *\/\n+    record ShiftLeft(int shiftAmount, Class<?> type) implements Binding {\n+\n+        @Override\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> last = stack.pop();\n+            if (shiftAmount > 0) {\n+                if (last != ((type == long.class) ? long.class : int.class))\n+                    throw new IllegalArgumentException(\n+                        String.format(\"Invalid operand type: %s. integral type expected\", last));\n+                stack.push(long.class);\n+            } else if (shiftAmount < 0) {\n+                if (last != long.class)\n+                    throw new IllegalArgumentException(\n+                        String.format(\"Invalid operand type: %s. long expected\", last));\n+                stack.push(type == long.class ? long.class : int.class);\n+            } else\n+                throw new IllegalArgumentException(\"shiftAmount 0 not supported\");\n+        }\n+\n+        @Override\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            if (shiftAmount > 0) {\n+                long l;\n+                if (type == long.class) {\n+                    l = (long) stack.pop();\n+                } else {\n+                    l = (long)(int) stack.pop();\n+                }\n+                l <<= (shiftAmount * Byte.SIZE);\n+                stack.push(l);\n+            } else {\n+                long l = (long) stack.pop();\n+                l >>>= (-shiftAmount * Byte.SIZE);\n+                if (type == long.class) {\n+                    stack.push(l);\n+                } else {\n+                    stack.push((int) l);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.foreign.abi.Binding.ShiftLeft;\n@@ -466,0 +467,1 @@\n+                case ShiftLeft shiftLeft     -> emitShift(shiftLeft);\n@@ -728,0 +730,22 @@\n+    private void emitShift(ShiftLeft shiftLeft) {\n+        int shiftAmount = shiftLeft.shiftAmount();\n+        Class<?> type = shiftLeft.type();\n+        if (shiftAmount > 0) {\n+            if (type != long.class) {\n+                cb.i2l();\n+                typeStack.pop();\n+                typeStack.push(long.class);\n+            }\n+            cb.constantInstruction(shiftAmount * Byte.SIZE);\n+            cb.lshl();\n+        } else {\n+            cb.constantInstruction(-shiftAmount * Byte.SIZE);\n+            cb.lushr();\n+            if (type != long.class) {\n+                cb.l2i();\n+                typeStack.pop();\n+                typeStack.push(int.class);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.Binding.ShiftLeft;\n@@ -223,0 +224,1 @@\n+            case ShiftLeft    unused -> true;\n@@ -257,0 +259,1 @@\n+            case ShiftLeft    unused -> true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64Linker;\n@@ -244,0 +245,1 @@\n+            case LINUX_PPC_64 -> LinuxPPC64Linker.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.ppc64;\n+\n+\/**\n+ * PPC64 CallArranger specialized for ABI v1.\n+ *\/\n+public class ABIv1CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean useABIv2() {\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/ABIv1CallArranger.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.abi.ppc64.CallArranger;\n-\n@@ -34,1 +32,5 @@\n-    \/\/ Currently no specific content, but CallArranger detects usage of ABIv2 for this class.\n+\n+    @Override\n+    protected boolean useABIv2() {\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/ABIv2CallArranger.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.foreign.abi.ppc64.ABIv2CallArranger;\n@@ -65,1 +64,1 @@\n-    final boolean useABIv2 = (this instanceof ABIv2CallArranger);\n+    final boolean useABIv2 = useABIv2();\n@@ -93,0 +92,1 @@\n+    public static final CallArranger ABIv1 = new ABIv1CallArranger();\n@@ -95,0 +95,5 @@\n+    \/**\n+     * Select ABI version\n+     *\/\n+    protected abstract boolean useABIv2();\n+\n@@ -219,3 +224,0 @@\n-            \/\/ TODO: Big Endian can't pass partially used slots correctly in some cases with:\n-            \/\/ !useABIv2 && layout.byteSize() > 8 && layout.byteSize() % 8 != 0\n-\n@@ -335,0 +337,1 @@\n+                    final boolean isLargeABIv1Struct = !useABIv2 && layout.byteSize() > MAX_COPY_SIZE;\n@@ -339,0 +342,1 @@\n+                        int shiftAmount = 0;\n@@ -342,0 +346,10 @@\n+                        } else if (isLargeABIv1Struct) {\n+                            \/\/ Last slot requires shift.\n+                            shiftAmount = MAX_COPY_SIZE - (int) size;\n+                        }\n+                        bindings.bufferLoad(offset, type, (int) size);\n+                        if (shiftAmount != 0) {\n+                            bindings.shiftLeft(shiftAmount, type)\n+                                    .vmStore(storage, long.class);\n+                        } else {\n+                            bindings.vmStore(storage, type);\n@@ -343,2 +357,0 @@\n-                        bindings.bufferLoad(offset, type, (int) size)\n-                                .vmStore(storage, type);\n@@ -413,0 +425,1 @@\n+                    final boolean isLargeABIv1Struct = !useABIv2 && layout.byteSize() > MAX_COPY_SIZE;\n@@ -417,0 +430,1 @@\n+                        int shiftAmount = 0;\n@@ -418,3 +432,12 @@\n-                        bindings.dup()\n-                                .vmLoad(storage, type)\n-                                .bufferStore(offset, type, (int) size);\n+                        if (isLargeABIv1Struct && offset + size >= layout.byteSize()) {\n+                            \/\/ Last slot requires shift.\n+                            shiftAmount = MAX_COPY_SIZE - (int) size;\n+                        }\n+                        bindings.dup();\n+                        if (shiftAmount != 0) {\n+                            bindings.vmLoad(storage, long.class)\n+                                    .shiftLeft(-shiftAmount, type);\n+                        } else {\n+                            bindings.vmLoad(storage, type);\n+                        }\n+                        bindings.bufferStore(offset, type, (int) size);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.ppc64.linux;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.ppc64.CallArranger;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.nio.ByteOrder;\n+\n+public final class LinuxPPC64Linker extends AbstractLinker {\n+\n+    public static LinuxPPC64Linker getInstance() {\n+        final class Holder {\n+            private static final LinuxPPC64Linker INSTANCE = new LinuxPPC64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private LinuxPPC64Linker() {\n+        \/\/ Ensure there is only one instance\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.ABIv1.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.ABIv1.arrangeUpcall(targetType, function, options);\n+    }\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.BIG_ENDIAN;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}