{"files":[{"patch":"@@ -519,3 +519,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n@@ -658,3 +655,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops()    { return false; })\n@@ -67,3 +64,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops()    { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,2 +137,0 @@\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,3 +100,0 @@\n-\n-  \/\/ Don't use the oop verification code in the oop_oop_iterate framework.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  Devirtualizer::do_oop_no_verify(_cl, p);\n+  Devirtualizer::do_oop(_cl, p);\n@@ -80,1 +80,1 @@\n-  Devirtualizer::do_oop_no_verify(_cl, p);\n+  Devirtualizer::do_oop(_cl, p);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,3 +194,0 @@\n-\n-  \/\/ This closure provides its own oop verification code.\n-  debug_only(virtual bool should_verify_oops() { return false; })\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,6 +163,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,6 +34,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n@@ -55,6 +49,0 @@\n-\n-#ifdef ASSERT\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -217,7 +217,0 @@\n-\n-#ifdef ASSERT\n-  \/\/ Verification handled by the closure itself\n-  virtual bool should_verify_oops() {\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  virtual bool should_verify_oops() { return false; }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  virtual bool should_verify_oops() { return false; }\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1740,1 +1740,1 @@\n-    return cast_from_oop<address>(CompressedOops::decode_not_null(n));\n+    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1153,3 +1153,0 @@\n-  virtual bool should_verify_oops(void) {\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,8 +105,0 @@\n-\n-#ifdef ASSERT\n-  \/\/ Default verification of each visited oop field.\n-  template <typename T> void verify(T* p);\n-\n-  \/\/ Can be used by subclasses to turn off the default verification of oop fields.\n-  virtual bool should_verify_oops() { return true; }\n-#endif\n@@ -360,1 +352,0 @@\n-  template <typename OopClosureType, typename T> static void do_oop_no_verify(OopClosureType* closure, T* p);\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -55,16 +54,0 @@\n-#ifdef ASSERT\n-\/\/ This verification is applied to all visited oops.\n-\/\/ The closures can turn is off by overriding should_verify_oops().\n-template <typename T>\n-void OopIterateClosure::verify(T* p) {\n-  if (should_verify_oops()) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop o = CompressedOops::decode_not_null(heap_oop);\n-      assert(Universe::heap()->is_in(o),\n-             \"should be in closed *p \" PTR_FORMAT \" \" PTR_FORMAT, p2i(p), p2i(o));\n-    }\n-  }\n-}\n-#endif\n-\n@@ -126,5 +109,0 @@\n-template <typename OopClosureType, typename T>\n-inline void Devirtualizer::do_oop_no_verify(OopClosureType* closure, T* p) {\n-  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n-}\n-\n@@ -133,3 +111,1 @@\n-  debug_only(closure->verify(p));\n-\n-  do_oop_no_verify(closure, p);\n+  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  static inline oop decode_raw_not_null(narrowOop v);\n@@ -129,4 +130,4 @@\n-  static oop decode_not_null(oop v)             { return v; }\n-  static oop decode(oop v)                      { return v; }\n-  static narrowOop encode_not_null(narrowOop v) { return v; }\n-  static narrowOop encode(narrowOop v)          { return v; }\n+  static inline oop decode_not_null(oop v);\n+  static inline oop decode(oop v);\n+  static inline narrowOop encode_not_null(narrowOop v);\n+  static inline narrowOop encode(narrowOop v);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,5 @@\n+inline oop CompressedOops::decode_raw_not_null(narrowOop v) {\n+  assert(!is_null(v), \"narrow oop value can never be zero\");\n+  return decode_raw(v);\n+}\n+\n@@ -52,0 +57,1 @@\n+  assert(Universe::heap()->is_in(result), \"object not in heap \" PTR_FORMAT, p2i((void*) result));\n@@ -66,1 +72,1 @@\n-  assert(decode(result) == v, \"reversibility\");\n+  assert(decode_raw(result) == v, \"reversibility\");\n@@ -74,0 +80,18 @@\n+inline oop CompressedOops::decode_not_null(oop v) {\n+  assert(Universe::heap()->is_in(v), \"object not in heap \" PTR_FORMAT, p2i((void*) v));\n+  return v;\n+}\n+\n+inline oop CompressedOops::decode(oop v) {\n+  assert(Universe::heap()->is_in_or_null(v), \"object not in heap \" PTR_FORMAT, p2i((void*) v));\n+  return v;\n+}\n+\n+inline narrowOop CompressedOops::encode_not_null(narrowOop v) {\n+  return v;\n+}\n+\n+inline narrowOop CompressedOops::encode(narrowOop v) {\n+  return v;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}