{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import jdk.internal.misc.CDS;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n@@ -29,1 +34,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -32,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,4 +40,0 @@\n-import jdk.internal.misc.CDS;\n-import jdk.internal.misc.VM;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-\n@@ -1771,0 +1772,220 @@\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int compressLeft(int i, int mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Integer.compress(i, mask) << -Integer.bitCount(m)\n+     *     return Integer.reverse(\n+     *         Integer.compress(Integer.reverse(i), Integer.reverse(mask)));\n+     * }\n+     *\n+     * int sag(int i, int mask) {\n+     *     return compressLeft(i, mask) | Integer.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static int compress(int i, int mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 5; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            int maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            int t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code int} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int select(int i, int n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     int nthBit = Integer.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Integer.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static int expand(int i, int mask) {\n+        \/\/ Save original mask\n+        int originalMask = mask;\n+        \/\/ Count 0's to right\n+        int maskCount = ~mask << 1;\n+        int maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove5 = maskPrefix & mask;\n+\n+        int t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    @ForceInline\n+    private static int parallelSuffix(int maskCount) {\n+        int maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        return maskPrefix;\n+    }\n+\n+    \/**\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":227,"deletions":6,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -1909,0 +1910,230 @@\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long compressLeft(long i, long mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Long.compress(i, mask) << -Long.bitCount(m)\n+     *     return Long.reverse(\n+     *         Long.compress(Long.reverse(i), Long.reverse(mask)));\n+     * }\n+     *\n+     * long sag(long i, long mask) {\n+     *     return compressLeft(i, mask) | Long.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static long compress(long i, long mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 6; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            long maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            long t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     long nthBit = Long.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Long.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static long expand(long i, long mask) {\n+        \/\/ Save original mask\n+        long originalMask = mask;\n+        \/\/ Count 0's to right\n+        long maskCount = ~mask << 1;\n+        long maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove5 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove6 = maskPrefix & mask;\n+\n+        long t = i << (1 << 5);\n+        i = (i & ~maskMove6) | (t & maskMove6);\n+        t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    @ForceInline\n+    private static long parallelSuffix(long maskCount) {\n+        long maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+        return maskPrefix;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":232,"deletions":1,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Supplier;\n+import java.util.random.RandomGenerator;\n+\n+public abstract class AbstractCompressExpandTest {\n+\n+    static int testCompress(int i, int mask) {\n+        int result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                rpos++; \/\/ conditional increment\n+            }\n+            i >>>= 1; \/\/ unconditional shift-out\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static int testExpand(int i, int mask) {\n+        int result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                i >>>= 1; \/\/ conditional shift-out\n+            }\n+            rpos++; \/\/ unconditional increment\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static long testCompress(long i, long mask) {\n+        long result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos++;\n+            }\n+            i >>>= 1;\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static long testExpand(long i, long mask) {\n+        long result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                i >>>= 1;\n+            }\n+            rpos++;\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    abstract int actualCompress(int i, int mask);\n+\n+    abstract int actualExpand(int i, int mask);\n+\n+    abstract int expectedCompress(int i, int mask);\n+\n+    abstract int expectedExpand(int i, int mask);\n+\n+    abstract long actualCompress(long i, long mask);\n+\n+    abstract long actualExpand(long i, long mask);\n+\n+    abstract long expectedCompress(long i, long mask);\n+\n+    abstract long expectedExpand(long i, long mask);\n+\n+    static int SIZE = 1024;\n+\n+    <T> Supplier<T> supplierWithToString(Supplier<T> s, String name) {\n+        return new Supplier<>() {\n+            @Override\n+            public T get() {\n+                return s.get();\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] maskIntProvider() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        return new Object[][]{\n+                {supplierWithToString(() -> rg.ints(SIZE).toArray(), \"random masks\")},\n+                {supplierWithToString(this::contiguousMasksInt, \"contiguous masks\")}\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] maskLongProvider() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        return new Object[][]{\n+                {supplierWithToString(() -> rg.longs(SIZE).toArray(), \"random masks\")},\n+                {supplierWithToString(this::contiguousMasksLong, \"contiguous masks\")}\n+        };\n+    }\n+\n+    int[] contiguousMasksInt() {\n+        int size = 32 * (32 + 1) \/ 2 + 1; \/\/ 528 + 1\n+        int[] masks = new int[size];\n+\n+        int i = 0;\n+        masks[i++] = 0;\n+        for (int len = 1; len < 32; len++) {\n+            for (int pos = 0; pos <= 32 - len; pos++) {\n+                masks[i++] = ((1 << len) - 1) << pos;\n+            }\n+        }\n+        masks[i++] = -1;\n+\n+        assert i == masks.length;\n+        return masks;\n+    }\n+\n+    long[] contiguousMasksLong() {\n+        int size = 64 * (64 + 1) \/ 2 + 1; \/\/ 2080 + 1\n+        long[] masks = new long[size];\n+\n+\n+        int i = 0;\n+        masks[i++] = 0L;\n+        for (int len = 1; len < 64; len++) {\n+            for (int pos = 0; pos <= 64 - len; pos++) {\n+                masks[i++] = ((1L << len) - 1) << pos;\n+            }\n+        }\n+        masks[i++] = -1L;\n+\n+        assert i == masks.length;\n+        return masks;\n+    }\n+\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testCompressInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                int actual = actualCompress(i, m);\n+                int expected = expectedCompress(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testExpandInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                int actual = actualExpand(i, m);\n+                int expected = expectedExpand(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testCompressExpandInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                {\n+                    int a = actualCompress(actualExpand(i, m), m);\n+                    Assert.assertEquals(a, normalizeCompressedValue(i, m));\n+\n+                    int b = actualCompress(actualExpand(i, ~m), ~m);\n+                    Assert.assertEquals(b, normalizeCompressedValue(i, ~m));\n+                }\n+\n+                {\n+                    int a = actualExpand(actualCompress(i, m), m);\n+                    \/\/ Clear unset mask bits\n+                    Assert.assertEquals(a, i & m);\n+\n+                    int b = actualExpand(actualCompress(i, ~m), ~m);\n+                    Assert.assertEquals(a & b, 0);\n+                    Assert.assertEquals(a | b, i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testContiguousMasksInt() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+\n+        for (int i : values) {\n+            assertContiguousMask(i, 0, 0L);\n+            for (int len = 1; len < 32; len++) {\n+                for (int pos = 0; pos <= 32 - len; pos++) {\n+                    int mask = ((1 << len) - 1) << pos;\n+\n+                    assertContiguousMask(i, pos, mask);\n+                }\n+            }\n+            assertContiguousMask(i, 0, -1L);\n+        }\n+    }\n+\n+    void assertContiguousMask(int i, int pos, int mask) {\n+        Assert.assertEquals(actualCompress(i, mask), (i & mask) >>> pos);\n+        Assert.assertEquals(actualExpand(i, mask), (i << pos) & mask);\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testCompressLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                long actual = actualCompress(i, m);\n+                long expected = expectedCompress(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testExpandLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                long actual = actualExpand(i, m);\n+                long expected = expectedExpand(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testCompressExpandLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                {\n+                    long a = actualCompress(actualExpand(i, m), m);\n+                    Assert.assertEquals(a, normalizeCompressedValue(i, m));\n+\n+                    long b = actualCompress(actualExpand(i, ~m), ~m);\n+                    Assert.assertEquals(b, normalizeCompressedValue(i, ~m));\n+                }\n+\n+                {\n+                    long a = actualExpand(actualCompress(i, m), m);\n+                    \/\/ Clear unset mask bits\n+                    Assert.assertEquals(a, i & m);\n+\n+                    long b = actualExpand(actualCompress(i, ~m), ~m);\n+                    Assert.assertEquals(a & b, 0);\n+                    Assert.assertEquals(a | b, i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testContiguousMasksLong() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+\n+        for (long i : values) {\n+            assertContiguousMask(i, 0, 0L);\n+            for (int len = 1; len < 64; len++) {\n+                for (int pos = 0; pos <= 64 - len; pos++) {\n+                    long mask = ((1L << len) - 1) << pos;\n+\n+                    assertContiguousMask(i, pos, mask);\n+                }\n+            }\n+            assertContiguousMask(i, 0, -1L);\n+        }\n+    }\n+\n+    void assertContiguousMask(long i, int pos, long mask) {\n+        Assert.assertEquals(actualCompress(i, mask), (i & mask) >>> pos);\n+        Assert.assertEquals(actualExpand(i, mask), (i << pos) & mask);\n+    }\n+\n+    static int normalizeCompressedValue(int i, int mask) {\n+        int mbc = Integer.bitCount(mask);\n+        if (mbc != 32) {\n+            return i & ((1 << mbc) - 1);\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    static long normalizeCompressedValue(long i, long mask) {\n+        int mbc = Long.bitCount(mask);\n+        if (mbc != 64) {\n+            return i & ((1L << mbc) - 1);\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    static void print(int i, int m, int actual, int expected) {\n+        System.out.println(String.format(\"i = %s\", Integer.toBinaryString(i)));\n+        System.out.println(String.format(\"m = %s\", Integer.toBinaryString(m)));\n+        System.out.println(String.format(\"a = %s\", Integer.toBinaryString(actual)));\n+        System.out.println(String.format(\"e = %s\", Integer.toBinaryString(expected)));\n+    }\n+\n+    static void print(long i, long m, long actual, long expected) {\n+        System.out.println(String.format(\"i = %s\", Long.toBinaryString(i)));\n+        System.out.println(String.format(\"m = %s\", Long.toBinaryString(m)));\n+        System.out.println(String.format(\"a = %s\", Long.toBinaryString(actual)));\n+        System.out.println(String.format(\"e = %s\", Long.toBinaryString(expected)));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/AbstractCompressExpandTest.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compress expand as if the test methods are the implementation methods\n+ * @key randomness\n+ * @run testng CompressExpandSanityTest\n+ *\/\n+\n+public final class CompressExpandSanityTest extends AbstractCompressExpandTest {\n+    @Override\n+    int actualCompress(int i, int mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    int actualExpand(int i, int mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+    @Override\n+    int expectedCompress(int i, int mask) {\n+        return Integer.compress(i, mask);\n+    }\n+\n+    @Override\n+    int expectedExpand(int i, int mask) {\n+        return Integer.expand(i, mask);\n+    }\n+\n+\n+    @Override\n+    long actualCompress(long i, long mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    long actualExpand(long i, long mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+    @Override\n+    long expectedCompress(long i, long mask) {\n+        return Long.compress(i, mask);\n+    }\n+\n+    @Override\n+    long expectedExpand(long i, long mask) {\n+        return Long.expand(i, mask);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/CompressExpandSanityTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compress expand methods\n+ * @key randomness\n+ * @run testng CompressExpandTest\n+ *\/\n+\n+public final class CompressExpandTest extends AbstractCompressExpandTest {\n+    @Override\n+    int actualCompress(int i, int mask) {\n+        return Integer.compress(i, mask);\n+    }\n+\n+    @Override\n+    int actualExpand(int i, int mask) {\n+        return Integer.expand(i, mask);\n+    }\n+\n+    @Override\n+    int expectedCompress(int i, int mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    int expectedExpand(int i, int mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+\n+    @Override\n+    long actualCompress(long i, long mask) {\n+        return Long.compress(i, mask);\n+    }\n+\n+    @Override\n+    long actualExpand(long i, long mask) {\n+        return Long.expand(i, mask);\n+    }\n+\n+    @Override\n+    long expectedCompress(long i, long mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    long expectedExpand(long i, long mask) {\n+        return testExpand(i, mask);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/CompressExpandTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -112,0 +112,16 @@\n+\n+    \/** Performs expand on small values *\/\n+    @Benchmark\n+    public void expand(Blackhole bh) {\n+        for (int i : intsSmall) {\n+            bh.consume(Integer.expand(i, 0xFF00F0F0));\n+        }\n+    }\n+\n+    \/** Performs compress on large values *\/\n+    @Benchmark\n+    public void compress(Blackhole bh) {\n+        for (int i : intsBig) {\n+            bh.consume(Integer.compress(i, 0x000F0F1F));\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -92,0 +92,16 @@\n+    \/** Performs expand on small values *\/\n+    @Benchmark\n+    public void expand(Blackhole bh) {\n+        for (long i : longArraySmall) {\n+            bh.consume(Long.expand(i, 0xFF00F0F0F0000000L));\n+        }\n+    }\n+\n+    \/** Performs compress on large values *\/\n+    @Benchmark\n+    public void compress(Blackhole bh) {\n+        for (long i : longArrayBig) {\n+            bh.consume(Long.compress(i, 0x000000000F0F0F1FL));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}