{"files":[{"patch":"@@ -1783,0 +1783,47 @@\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * The mask {@code 0xFF00FFF0} selects the 1'st, 2'nd, 3'rd, 6'th and\n+     * 7'th digits of {@code 0xCAFEBABE}. The selected digits occur in the\n+     * resulting compressed value contiguously from the 0'th digit in the\n+     * same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the n'th bit is set\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int compressLeft(int i, int mask) {\n+     *     return Integer.reverse(\n+     *         Integer.compress(Integer.reverse(i), Integer.reverse(mask)));\n+     * }\n+     *\n+     * int sag(int i, int mask) {\n+     *     return compressLeft(i, mask) | Integer.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n@@ -1825,0 +1872,46 @@\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * The mask {@code 0xFF00FFF0} selects the first five digits of\n+     * {@code 0x0000CABAB}. The selected digits occur in the resulting\n+     * expanded value in order at the 1'st, 2'nd, 3'rd, 6'th and 7'th\n+     * positions.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the first bit\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the {@code n}'th\n+     * one-bit in an {@code int} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int select(int i, int n) {\n+     *     \/\/ the n'th one-bit in i (the mask)\n+     *     int nthBit = Integer.expand(1 << n, i);\n+     *     \/\/ the position of the n'th one-bit in i\n+     *     return Integer.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The 0'th one-bit is at the 1'st bit position\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The 3'rd one-bit is at the 7'th bit position\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1922,0 +1922,47 @@\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * The mask {@code 0xFF00FFF0} selects the 1'st, 2'nd, 3'rd, 6'th and\n+     * 7'th digits of {@code 0xCAFEBABE}. The selected digits occur in the\n+     * resulting compressed value contiguously from the 0'th digit in the\n+     * same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the n'th bit is set\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long compressLeft(long i, long mask) {\n+     *     return Long.reverse(\n+     *         Long.compress(Long.reverse(i), Long.reverse(mask)));\n+     * }\n+     *\n+     * long sag(long i, long mask) {\n+     *     return compressLeft(i, mask) | Long.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n@@ -1964,0 +2011,46 @@\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * The mask {@code 0xFF00FFF0} selects the first five digits of\n+     * {@code 0x0000CABAB}. The selected digits occur in the resulting\n+     * expanded value in order at the 1'st, 2'nd, 3'rd, 6'th and 7'th\n+     * positions.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the first bit\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the {@code n}'th\n+     * one-bit in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the n'th one-bit in i (the mask)\n+     *     long nthBit = Long.expand(1 << n, i);\n+     *     \/\/ the position of the n'th one-bit in i\n+     *     return Long.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The 0'th one-bit is at the 1'st bit position\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The 3'rd one-bit is at the 7'th bit position\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"}]}