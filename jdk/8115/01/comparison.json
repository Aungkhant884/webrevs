{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import jdk.internal.misc.CDS;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n@@ -29,1 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -32,0 +35,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -35,4 +39,0 @@\n-import jdk.internal.misc.CDS;\n-import jdk.internal.misc.VM;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-\n@@ -1771,0 +1771,96 @@\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static int compress(int i, int mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 5; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            int t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static int expand(int i, int mask) {\n+        int[] array = new int[5];\n+        \/\/ Save original mask\n+        int originalMask = mask;\n+        \/\/ Count 0's to right\n+        int maskCount = ~mask << 1;\n+        for (int j = 0; j < 5; j++) {\n+            \/\/ Parallel suffix\n+            int maskPrefix = maskCount ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            array[j] = maskMove;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = 4; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = i << (1 << j);\n+            i = (i & ~maskMove) | (t & maskMove);\n+        }\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    \/**\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":102,"deletions":6,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1909,0 +1909,98 @@\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static long compress(long i, long mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 6; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            long t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static long expand(long i, long mask) {\n+        long[] array = new long[6];\n+        \/\/ Save original mask\n+        long originalMask = mask;\n+        \/\/ Count 0's to right\n+        long maskCount = ~mask << 1;\n+        for (int j = 0; j < 6; j++) {\n+            \/\/ Parallel suffix\n+            long maskPrefix = maskCount ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            array[j] = maskMove;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = 5; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = i << (1 << j);\n+            i = (i & ~maskMove) | (t & maskMove);\n+        }\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":99,"deletions":1,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Supplier;\n+import java.util.random.RandomGenerator;\n+\n+public abstract class AbstractCompressExpandTest {\n+\n+    static int testCompress(int i, int mask) {\n+        int result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                rpos++; \/\/ conditional increment\n+            }\n+            i >>>= 1; \/\/ unconditional shift-out\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static int testExpand(int i, int mask) {\n+        int result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                i >>>= 1; \/\/ conditional shift-out\n+            }\n+            rpos++; \/\/ unconditional increment\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static long testCompress(long i, long mask) {\n+        long result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos++;\n+            }\n+            i >>>= 1;\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    static long testExpand(long i, long mask) {\n+        long result = 0;\n+        int rpos = 0;\n+        while (mask != 0) {\n+            if ((mask & 1) != 0) {\n+                result |= (i & 1) << rpos;\n+                i >>>= 1;\n+            }\n+            rpos++;\n+            mask >>>= 1;\n+        }\n+        return result;\n+    }\n+\n+    abstract int actualCompress(int i, int mask);\n+\n+    abstract int actualExpand(int i, int mask);\n+\n+    abstract int expectedCompress(int i, int mask);\n+\n+    abstract int expectedExpand(int i, int mask);\n+\n+    abstract long actualCompress(long i, long mask);\n+\n+    abstract long actualExpand(long i, long mask);\n+\n+    abstract long expectedCompress(long i, long mask);\n+\n+    abstract long expectedExpand(long i, long mask);\n+\n+    static int SIZE = 1024;\n+\n+    <T> Supplier<T> supplierWithToString(Supplier<T> s, String name) {\n+        return new Supplier<>() {\n+            @Override\n+            public T get() {\n+                return s.get();\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] maskIntProvider() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        return new Object[][]{\n+                {supplierWithToString(() -> rg.ints(SIZE).toArray(), \"random masks\")},\n+                {supplierWithToString(this::contiguousMasksInt, \"contiguous masks\")}\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] maskLongProvider() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        return new Object[][]{\n+                {supplierWithToString(() -> rg.longs(SIZE).toArray(), \"random masks\")},\n+                {supplierWithToString(this::contiguousMasksLong, \"contiguous masks\")}\n+        };\n+    }\n+\n+    int[] contiguousMasksInt() {\n+        int size = 32 * (32 + 1) \/ 2 + 1; \/\/ 528 + 1\n+        int[] masks = new int[size];\n+\n+        int i = 0;\n+        masks[i++] = 0;\n+        for (int len = 1; len < 32; len++) {\n+            for (int pos = 0; pos <= 32 - len; pos++) {\n+                masks[i++] = ((1 << len) - 1) << pos;\n+            }\n+        }\n+        masks[i++] = -1;\n+\n+        assert i == masks.length;\n+        return masks;\n+    }\n+\n+    long[] contiguousMasksLong() {\n+        int size = 64 * (64 + 1) \/ 2 + 1; \/\/ 2080 + 1\n+        long[] masks = new long[size];\n+\n+\n+        int i = 0;\n+        masks[i++] = 0L;\n+        for (int len = 1; len < 64; len++) {\n+            for (int pos = 0; pos <= 64 - len; pos++) {\n+                masks[i++] = ((1L << len) - 1) << pos;\n+            }\n+        }\n+        masks[i++] = -1L;\n+\n+        assert i == masks.length;\n+        return masks;\n+    }\n+\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testCompressInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                int actual = actualCompress(i, m);\n+                int expected = expectedCompress(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testExpandInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                int actual = actualExpand(i, m);\n+                int expected = expectedExpand(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskIntProvider\")\n+    public void testCompressExpandInt(Supplier<int[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+        int[] masks = maskProvider.get();\n+\n+        for (int i : values) {\n+            for (int m : masks) {\n+                {\n+                    int a = actualCompress(actualExpand(i, m), m);\n+                    Assert.assertEquals(a, normalizeCompressedValue(i, m));\n+\n+                    int b = actualCompress(actualExpand(i, ~m), ~m);\n+                    Assert.assertEquals(b, normalizeCompressedValue(i, ~m));\n+                }\n+\n+                {\n+                    int a = actualExpand(actualCompress(i, m), m);\n+                    \/\/ Clear unset mask bits\n+                    Assert.assertEquals(a, i & m);\n+\n+                    int b = actualExpand(actualCompress(i, ~m), ~m);\n+                    Assert.assertEquals(a & b, 0);\n+                    Assert.assertEquals(a | b, i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testContiguousMasksInt() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        int[] values = rg.ints(SIZE).toArray();\n+\n+        for (int i : values) {\n+            assertContiguousMask(i, 0, 0L);\n+            for (int len = 0; len < 32; len++) {\n+                for (int pos = 0; pos < 32 - len; pos++) {\n+                    int mask = ((1 << len) - 1) << pos;\n+\n+                    assertContiguousMask(i, pos, mask);\n+                }\n+            }\n+            assertContiguousMask(i, 0, -1L);\n+        }\n+    }\n+\n+    void assertContiguousMask(int i, int pos, int mask) {\n+        Assert.assertEquals(actualCompress(i, mask), (i & mask) >>> pos);\n+        Assert.assertEquals(actualExpand(i, mask), (i << pos) & mask);\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testCompressLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                long actual = actualCompress(i, m);\n+                long expected = expectedCompress(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testExpandLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                long actual = actualExpand(i, m);\n+                long expected = expectedExpand(i, m);\n+                if (actual != expected) {\n+                    print(i, m, actual, expected);\n+                }\n+                Assert.assertEquals(actual, expected);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskLongProvider\")\n+    public void testCompressExpandLong(Supplier<long[]> maskProvider) {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+        long[] masks = maskProvider.get();\n+\n+        for (long i : values) {\n+            for (long m : masks) {\n+                {\n+                    long a = actualCompress(actualExpand(i, m), m);\n+                    Assert.assertEquals(a, normalizeCompressedValue(i, m));\n+\n+                    long b = actualCompress(actualExpand(i, ~m), ~m);\n+                    Assert.assertEquals(b, normalizeCompressedValue(i, ~m));\n+                }\n+\n+                {\n+                    long a = actualExpand(actualCompress(i, m), m);\n+                    \/\/ Clear unset mask bits\n+                    Assert.assertEquals(a, i & m);\n+\n+                    long b = actualExpand(actualCompress(i, ~m), ~m);\n+                    Assert.assertEquals(a & b, 0);\n+                    Assert.assertEquals(a | b, i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testContiguousMasksLong() {\n+        RandomGenerator rg = RandomGenerator.getDefault();\n+\n+        long[] values = rg.longs(SIZE).toArray();\n+\n+        for (long i : values) {\n+            assertContiguousMask(i, 0, 0L);\n+            for (int len = 1; len < 64; len++) {\n+                for (int pos = 0; pos <= 64 - len; pos++) {\n+                    long mask = ((1L << len) - 1) << pos;\n+\n+                    assertContiguousMask(i, pos, mask);\n+                }\n+            }\n+            assertContiguousMask(i, 0, -1L);\n+        }\n+    }\n+\n+    void assertContiguousMask(long i, int pos, long mask) {\n+        Assert.assertEquals(actualCompress(i, mask), (i & mask) >>> pos);\n+        Assert.assertEquals(actualExpand(i, mask), (i << pos) & mask);\n+    }\n+\n+    static int normalizeCompressedValue(int i, int mask) {\n+        int mbc = Integer.bitCount(mask);\n+        if (mbc != 32) {\n+            return i & ((1 << mbc) - 1);\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    static long normalizeCompressedValue(long i, long mask) {\n+        int mbc = Long.bitCount(mask);\n+        if (mbc != 64) {\n+            return i & ((1L << mbc) - 1);\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    static void print(int i, int m, int actual, int expected) {\n+        System.out.println(String.format(\"i = %s\", Integer.toBinaryString(i)));\n+        System.out.println(String.format(\"m = %s\", Integer.toBinaryString(m)));\n+        System.out.println(String.format(\"a = %s\", Integer.toBinaryString(actual)));\n+        System.out.println(String.format(\"e = %s\", Integer.toBinaryString(expected)));\n+    }\n+\n+    static void print(long i, long m, long actual, long expected) {\n+        System.out.println(String.format(\"i = %s\", Long.toBinaryString(i)));\n+        System.out.println(String.format(\"m = %s\", Long.toBinaryString(m)));\n+        System.out.println(String.format(\"a = %s\", Long.toBinaryString(actual)));\n+        System.out.println(String.format(\"e = %s\", Long.toBinaryString(expected)));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/AbstractCompressExpandTest.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compress expand as if the test methods are the implementation methods\n+ * @key randomness\n+ * @run testng CompressExpandSanityTest\n+ *\/\n+\n+public final class CompressExpandSanityTest extends AbstractCompressExpandTest {\n+    @Override\n+    int actualCompress(int i, int mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    int actualExpand(int i, int mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+    @Override\n+    int expectedCompress(int i, int mask) {\n+        return Integer.compress(i, mask);\n+    }\n+\n+    @Override\n+    int expectedExpand(int i, int mask) {\n+        return Integer.expand(i, mask);\n+    }\n+\n+\n+    @Override\n+    long actualCompress(long i, long mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    long actualExpand(long i, long mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+    @Override\n+    long expectedCompress(long i, long mask) {\n+        return Long.compress(i, mask);\n+    }\n+\n+    @Override\n+    long expectedExpand(long i, long mask) {\n+        return Long.expand(i, mask);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/CompressExpandSanityTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compress expand methods\n+ * @key randomness\n+ * @run testng CompressExpandTest\n+ *\/\n+\n+public final class CompressExpandTest extends AbstractCompressExpandTest {\n+    @Override\n+    int actualCompress(int i, int mask) {\n+        return Integer.compress(i, mask);\n+    }\n+\n+    @Override\n+    int actualExpand(int i, int mask) {\n+        return Integer.expand(i, mask);\n+    }\n+\n+    @Override\n+    int expectedCompress(int i, int mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    int expectedExpand(int i, int mask) {\n+        return testExpand(i, mask);\n+    }\n+\n+\n+    @Override\n+    long actualCompress(long i, long mask) {\n+        return Long.compress(i, mask);\n+    }\n+\n+    @Override\n+    long actualExpand(long i, long mask) {\n+        return Long.expand(i, mask);\n+    }\n+\n+    @Override\n+    long expectedCompress(long i, long mask) {\n+        return testCompress(i, mask);\n+    }\n+\n+    @Override\n+    long expectedExpand(long i, long mask) {\n+        return testExpand(i, mask);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/CompressExpandTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}