{"files":[{"patch":"@@ -571,1 +571,1 @@\n-  inline void mark_in_prev_bitmap(oop p);\n+  inline void par_mark_in_prev_bitmap(oop p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,20 +59,0 @@\n-class CMRemark : public VoidClosure {\n-  G1ConcurrentMark* _cm;\n-public:\n-  CMRemark(G1ConcurrentMark* cm) : _cm(cm) {}\n-\n-  void do_void(){\n-    _cm->remark();\n-  }\n-};\n-\n-class CMCleanup : public VoidClosure {\n-  G1ConcurrentMark* _cm;\n-public:\n-  CMCleanup(G1ConcurrentMark* cm) : _cm(cm) {}\n-\n-  void do_void(){\n-    _cm->cleanup();\n-  }\n-};\n-\n@@ -251,2 +231,1 @@\n-  CMRemark cl(_cm);\n-  VM_G1Concurrent op(&cl, \"Pause Remark\");\n+  VM_G1PauseRemark op;\n@@ -269,2 +248,1 @@\n-  CMCleanup cl(_cm);\n-  VM_G1Concurrent op(&cl, \"Pause Cleanup\");\n+  VM_G1PauseCleanup op;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -535,1 +535,1 @@\n-            dominated_by(old_new[prev->_idx], n);\n+            dominated_by(old_new[prev->_idx]->as_IfProj(), n->as_If());\n@@ -902,0 +902,2 @@\n+  bool should_unroll = true;\n+\n@@ -908,1 +910,1 @@\n-      (future_unroll_cnt - 1) * (100.0 \/ LoopPercentProfileLimit) > cl->profile_trip_cnt() &&\n+      is_residual_iters_large(future_unroll_cnt, cl) &&\n@@ -910,1 +912,11 @@\n-    return false;\n+    if ((cl->slp_max_unroll() == 0) && !is_residual_iters_large(cl->unrolled_count(), cl)) {\n+      \/\/ cl->slp_max_unroll() = 0 means that the previous slp analysis never passed.\n+      \/\/ slp analysis may fail due to the loop IR is too complicated especially during the early stage\n+      \/\/ of loop unrolling analysis. But after several rounds of loop unrolling and other optimizations,\n+      \/\/ it's possible that the loop IR becomes simple enough to pass the slp analysis.\n+      \/\/ So we don't return immediately in hoping that the next slp analysis can succeed.\n+      should_unroll = false;\n+      future_unroll_cnt = cl->unrolled_count();\n+    } else {\n+      return false;\n+    }\n@@ -988,1 +1000,1 @@\n-    if (LoopMaxUnroll > _local_loop_unroll_factor) {\n+    if (!cl->range_checks_present() && (LoopMaxUnroll > _local_loop_unroll_factor)) {\n@@ -1006,1 +1018,1 @@\n-      return phase->may_require_nodes(estimate);\n+      return should_unroll && phase->may_require_nodes(estimate);\n@@ -1014,1 +1026,1 @@\n-      return phase->may_require_nodes(estimate);\n+      return should_unroll && phase->may_require_nodes(estimate);\n@@ -1027,1 +1039,1 @@\n-  return phase->may_require_nodes(estimate);\n+  return should_unroll && phase->may_require_nodes(estimate);\n@@ -3536,0 +3548,2 @@\n+      } else {\n+        cl->clear_has_range_checks();\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"}]}