{"files":[{"patch":"@@ -197,1 +197,1 @@\n-  uint old_young_list_target_length = _young_list_target_length;\n+  uint old_young_list_target_length = young_list_target_length();\n@@ -199,3 +199,3 @@\n-  _young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n-  _young_list_target_length = calculate_young_target_length(_young_list_desired_length);\n-  _young_list_max_length = calculate_young_max_length(_young_list_target_length);\n+  uint new_young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n+  uint new_young_list_target_length = calculate_young_target_length(new_young_list_desired_length);\n+  uint new_young_list_max_length = calculate_young_max_length(new_young_list_target_length);\n@@ -207,3 +207,14 @@\n-                            _young_list_desired_length,\n-                            _young_list_target_length,\n-                            _young_list_max_length);\n+                            new_young_list_desired_length,\n+                            new_young_list_target_length,\n+                            new_young_list_max_length);\n+\n+  \/\/ Write back. This is not an attempt to control visibility order to other threads\n+  \/\/ here; all the revising of the young gen length are best effort to keep pause time.\n+  \/\/ E.g. we could be \"too late\" revising young gen upwards to avoid GC because\n+  \/\/ there is some time left, or some threads could get different values for stopping\n+  \/\/ allocation.\n+  \/\/ That is \"fine\" - at most this will schedule a GC (hopefully only a little) too\n+  \/\/ early or too late.\n+  Atomic::store(&_young_list_desired_length, new_young_list_desired_length);\n+  Atomic::store(&_young_list_target_length, new_young_list_target_length);\n+  Atomic::store(&_young_list_max_length, new_young_list_max_length);\n@@ -1091,2 +1102,1 @@\n-  uint young_list_target_length = _young_list_target_length;\n-  return young_list_length < young_list_target_length;\n+  return young_list_length < young_list_target_length();\n@@ -1097,2 +1107,1 @@\n-  uint young_list_max_length = _young_list_max_length;\n-  return young_list_length < young_list_max_length;\n+  return young_list_length < young_list_max_length();\n@@ -1128,1 +1137,1 @@\n-    double expansion_region_num_d = perc * (double) _young_list_target_length;\n+    double expansion_region_num_d = perc * (double)young_list_target_length();\n@@ -1141,1 +1150,1 @@\n-                 (double) _young_list_target_length \/ (double) SurvivorRatio;\n+                 (double)young_list_target_length() \/ (double) SurvivorRatio;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -80,3 +81,5 @@\n-  uint _young_list_desired_length;\n-  uint _young_list_target_length;\n-\n+  \/\/ Desired young gen length without taking actually available free regions into\n+  \/\/ account.\n+  volatile uint _young_list_desired_length;\n+  \/\/ Actual target length given available free memory.\n+  volatile uint _young_list_target_length;\n@@ -85,1 +88,1 @@\n-  uint _young_list_max_length;\n+  volatile uint _young_list_max_length;\n@@ -382,2 +385,3 @@\n-  uint young_list_desired_length() const { return _young_list_desired_length; }\n-  uint young_list_target_length() const { return _young_list_target_length; }\n+  uint young_list_desired_length() const { return Atomic::load(&_young_list_desired_length); }\n+  uint young_list_target_length() const { return Atomic::load(&_young_list_target_length); }\n+  uint young_list_max_length() const { return Atomic::load(&_young_list_max_length); }\n@@ -389,4 +393,0 @@\n-  uint young_list_max_length() const {\n-    return _young_list_max_length;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}