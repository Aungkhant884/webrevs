{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -36,1 +35,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -52,2 +50,1 @@\n-        \/\/ use polling implementation until we implement a BSD\/kqueue one\n-        return new PollingWatchService();\n+        return new MacOSXWatchService();\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,794 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.io.IOException;\n+import java.nio.file.ClosedWatchServiceException;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayDeque;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+class MacOSXWatchService extends AbstractWatchService {\n+    private final HashMap<Object, MacOSXWatchKey> dirKeyToWatchKey      = new HashMap<>();\n+    private final HashMap<Long, MacOSXWatchKey>   eventStreamToWatchKey = new HashMap<>();\n+    private final Object                          watchKeysLock         = new Object();\n+\n+    private final CFRunLoopThread runLoopThread;\n+\n+    MacOSXWatchService() throws IOException {\n+        runLoopThread = new CFRunLoopThread();\n+        runLoopThread.setDaemon(true);\n+        runLoopThread.start();\n+\n+        try {\n+            \/\/ In order to be able to schedule any FSEventStream's, a reference to a run loop is required.\n+            runLoopThread.waitForRunLoopRef();\n+        } catch (InterruptedException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    @Override\n+    WatchKey register(Path dir, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+        checkIsOpen();\n+\n+        final UnixPath unixDir = (UnixPath)dir;\n+        final Object dirKey    = checkPath(unixDir);\n+        final EnumSet<FSEventKind>   eventSet    = FSEventKind.setOf(events);\n+        final EnumSet<WatchModifier> modifierSet = WatchModifier.setOf(modifiers);\n+\n+        try {\n+            return AccessController.doPrivileged(new PrivilegedExceptionAction<MacOSXWatchKey>() {\n+                @Override\n+                public MacOSXWatchKey run() throws IOException {\n+                    return doPrivilegedRegister(unixDir, dirKey, eventSet, modifierSet);\n+                }\n+            });\n+        } catch (PrivilegedActionException pae) {\n+            final Throwable cause = pae.getCause();\n+            if (cause instanceof IOException ioe)\n+                throw ioe;\n+            throw new AssertionError(pae);\n+        }\n+    }\n+\n+    private MacOSXWatchKey doPrivilegedRegister(UnixPath unixDir, Object dirKey, EnumSet<FSEventKind> eventSet, EnumSet<WatchModifier> modifierSet) throws IOException {\n+        synchronized (closeLock()) {\n+            checkIsOpen();\n+\n+            synchronized (watchKeysLock) {\n+                MacOSXWatchKey watchKey = dirKeyToWatchKey.get(dirKey);\n+                final boolean keyForDirAlreadyExists = (watchKey != null);\n+                if (keyForDirAlreadyExists) {\n+                    eventStreamToWatchKey.remove(watchKey.getEventStreamRef());\n+                    watchKey.disable();\n+                } else {\n+                    watchKey = new MacOSXWatchKey(this, unixDir, dirKey);\n+                    dirKeyToWatchKey.put(dirKey, watchKey);\n+                }\n+\n+                watchKey.enable(runLoopThread, eventSet, modifierSet);\n+                eventStreamToWatchKey.put(watchKey.getEventStreamRef(), watchKey);\n+                watchKeysLock.notify(); \/\/ So that run loop gets running again if stopped due to lack of event streams\n+                return watchKey;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invoked on the CFRunLoopThread by the native code to report directories that need to be re-scanned.\n+     *\/\n+    private void callback(final long eventStreamRef, final String[] paths, final long eventFlagsPtr) {\n+        synchronized (watchKeysLock) {\n+            final MacOSXWatchKey watchKey = eventStreamToWatchKey.get(eventStreamRef);\n+            if (watchKey != null) {\n+                watchKey.handleEvents(paths, eventFlagsPtr);\n+            }\n+        }\n+    }\n+\n+    void cancel(final MacOSXWatchKey watchKey) {\n+        synchronized (watchKeysLock) {\n+            dirKeyToWatchKey.remove(watchKey.getRootPathKey());\n+            eventStreamToWatchKey.remove(watchKey.getEventStreamRef());\n+        }\n+    }\n+\n+    void waitForEventSource() {\n+        synchronized (watchKeysLock) {\n+            if (isOpen() && eventStreamToWatchKey.isEmpty()) {\n+                try {\n+                    watchKeysLock.wait();\n+                } catch (InterruptedException ignore) {}\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void implClose() {\n+        synchronized (watchKeysLock) {\n+            eventStreamToWatchKey.clear();\n+            dirKeyToWatchKey.forEach((key, watchKey) -> watchKey.invalidate());\n+            dirKeyToWatchKey.clear();\n+            watchKeysLock.notify(); \/\/ Let waitForEventSource() go if it was waiting\n+            runLoopThread.runLoopStop(); \/\/ Force exit from CFRunLoopRun()\n+        }\n+    }\n+\n+    private class CFRunLoopThread extends Thread {\n+        \/\/ Native reference to the CFRunLoop object of the watch service run loop.\n+        private long runLoopRef;\n+\n+        public CFRunLoopThread() {\n+            super(\"FileSystemWatcher\");\n+        }\n+\n+        private synchronized void waitForRunLoopRef() throws InterruptedException {\n+            if (runLoopRef == 0)\n+                runLoopThread.wait(); \/\/ ...for CFRunLoopRef to become available\n+        }\n+\n+        long getRunLoopRef() {\n+            return runLoopRef;\n+        }\n+\n+        synchronized void runLoopStop() {\n+            if (runLoopRef != 0) {\n+                \/\/ The run loop may have stuck in CFRunLoopRun() even though all of its input sources\n+                \/\/ have been removed. Need to terminate it explicitly so that it can run to completion.\n+                MacOSXWatchService.CFRunLoopStop(runLoopRef);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            synchronized (this) {\n+                runLoopRef = CFRunLoopGetCurrent();\n+                notify(); \/\/ ... of CFRunLoopRef availability\n+            }\n+\n+            while (isOpen()) {\n+                CFRunLoopRun(MacOSXWatchService.this);\n+                waitForEventSource();\n+            }\n+\n+            synchronized (this) {\n+                runLoopRef = 0; \/\/ CFRunLoopRef is no longer usable when the loop has been terminated\n+            }\n+        }\n+    }\n+\n+    private void checkIsOpen() {\n+        if (!isOpen())\n+            throw new ClosedWatchServiceException();\n+    }\n+\n+    private Object checkPath(UnixPath dir) throws IOException {\n+        if (dir == null)\n+            throw new NullPointerException(\"No path to watch\");\n+\n+        UnixFileAttributes attrs;\n+        try {\n+            attrs = UnixFileAttributes.get(dir, true);\n+        } catch (UnixException x) {\n+            throw x.asIOException(dir);\n+        }\n+\n+        if (!attrs.isDirectory())\n+            throw new NotDirectoryException(dir.getPathForExceptionMessage());\n+\n+        final Object fileKey = attrs.fileKey();\n+        if (fileKey == null)\n+            throw new AssertionError(\"File keys must be supported\");\n+\n+        return fileKey;\n+    }\n+\n+    private enum FSEventKind {\n+        CREATE, MODIFY, DELETE, OVERFLOW;\n+\n+        public static FSEventKind of(final WatchEvent.Kind<?> watchEventKind) {\n+            if (StandardWatchEventKinds.ENTRY_CREATE == watchEventKind) {\n+                return CREATE;\n+            } else if (StandardWatchEventKinds.ENTRY_MODIFY == watchEventKind) {\n+                return MODIFY;\n+            } else if (StandardWatchEventKinds.ENTRY_DELETE == watchEventKind) {\n+                return DELETE;\n+            } else if (StandardWatchEventKinds.OVERFLOW == watchEventKind) {\n+                return OVERFLOW;\n+            } else {\n+                throw new UnsupportedOperationException(watchEventKind.name());\n+            }\n+        }\n+\n+        public static EnumSet<FSEventKind> setOf(final WatchEvent.Kind<?>[] events) {\n+            final EnumSet<FSEventKind> eventSet = EnumSet.noneOf(FSEventKind.class);\n+            for (final WatchEvent.Kind<?> event: events) {\n+                if (event == null) {\n+                    throw new NullPointerException(\"An element in event set is 'null'\");\n+                } else if (event == StandardWatchEventKinds.OVERFLOW) {\n+                    continue;\n+                }\n+\n+                eventSet.add(FSEventKind.of(event));\n+            }\n+\n+            if (eventSet.isEmpty())\n+                throw new IllegalArgumentException(\"No events to register\");\n+\n+            return eventSet;\n+        }\n+\n+    }\n+\n+    private enum WatchModifier {\n+        FILE_TREE, SENSITIVITY_HIGH, SENSITIVITY_MEDIUM, SENSITIVITY_LOW;\n+\n+        public static WatchModifier of(final WatchEvent.Modifier watchEventModifier) {\n+            if (ExtendedOptions.FILE_TREE.matches(watchEventModifier)) {\n+                return FILE_TREE;\n+            } if (ExtendedOptions.SENSITIVITY_HIGH.matches(watchEventModifier)) {\n+                return SENSITIVITY_HIGH;\n+            } if (ExtendedOptions.SENSITIVITY_MEDIUM.matches(watchEventModifier)) {\n+                return SENSITIVITY_MEDIUM;\n+            } if (ExtendedOptions.SENSITIVITY_LOW.matches(watchEventModifier)) {\n+                return SENSITIVITY_LOW;\n+            } else {\n+                throw new UnsupportedOperationException(watchEventModifier.name());\n+            }\n+        }\n+\n+        public static EnumSet<WatchModifier> setOf(final WatchEvent.Modifier[] modifiers) {\n+            final EnumSet<WatchModifier> modifierSet = EnumSet.noneOf(WatchModifier.class);\n+            for (final WatchEvent.Modifier modifier : modifiers) {\n+                if (modifier == null)\n+                    throw new NullPointerException(\"An element in modifier set is 'null'\");\n+\n+                modifierSet.add(WatchModifier.of(modifier));\n+            }\n+\n+            return modifierSet;\n+        }\n+\n+        public static double sensitivityOf(final EnumSet<WatchModifier> modifiers) {\n+            if (modifiers.contains(SENSITIVITY_HIGH)) {\n+                return 0.1;\n+            } else if (modifiers.contains(SENSITIVITY_LOW)) {\n+                return 1;\n+            } else {\n+                return 0.5; \/\/ aka SENSITIVITY_MEDIUM\n+            }\n+        }\n+    }\n+\n+    private static class MacOSXWatchKey extends AbstractWatchKey {\n+        private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        private static final long kFSEventStreamEventFlagMustScanSubDirs = 0x00000001;\n+        private static final long kFSEventStreamEventFlagRootChanged     = 0x00000020;\n+\n+        private final static Path relativeRootPath = Path.of(\"\");\n+\n+        \/\/ Full path to this key's watch root directory.\n+        private final Path   realRootPath;\n+        private final int    realRootPathLength;\n+        private final Object rootPathKey;\n+\n+        \/\/ Kinds of events to be reported.\n+        private EnumSet<FSEventKind> eventsToWatch;\n+\n+        \/\/ Should events in directories below realRootPath reported?\n+        private boolean watchFileTree;\n+\n+        \/\/ Native FSEventStreamRef as returned by FSEventStreamCreate().\n+        private long         eventStreamRef;\n+        private final Object eventStreamRefLock = new Object();\n+\n+        private final DirectoryTreeSnapshot directoryTreeSnapshot = new DirectoryTreeSnapshot();\n+\n+        MacOSXWatchKey(final MacOSXWatchService watchService,\n+                       final UnixPath dir,\n+                       final Object rootPathKey) throws IOException {\n+            super(dir, watchService);\n+            this.realRootPath       = dir.toRealPath().normalize();\n+            this.realRootPathLength = realRootPath.toString().length() + 1;\n+            this.rootPathKey        = rootPathKey;\n+        }\n+\n+        synchronized void enable(final CFRunLoopThread runLoopThread,\n+                                 final EnumSet<FSEventKind> eventsToWatch,\n+                                 final EnumSet<WatchModifier> modifierSet) throws IOException {\n+            assert(!isValid());\n+\n+            this.eventsToWatch = eventsToWatch;\n+            this.watchFileTree = modifierSet.contains(WatchModifier.FILE_TREE);\n+\n+            directoryTreeSnapshot.build();\n+\n+            synchronized (eventStreamRefLock) {\n+                final int kFSEventStreamCreateFlagWatchRoot  = 0x00000004;\n+                eventStreamRef = MacOSXWatchService.eventStreamCreate(\n+                        realRootPath.toString(),\n+                        WatchModifier.sensitivityOf(modifierSet),\n+                        kFSEventStreamCreateFlagWatchRoot);\n+\n+                if (eventStreamRef == 0)\n+                    throw new IOException(\"Unable to create FSEventStream\");\n+\n+                MacOSXWatchService.eventStreamSchedule(eventStreamRef, runLoopThread.getRunLoopRef());\n+            }\n+        }\n+\n+        synchronized void disable() {\n+            invalidate();\n+            directoryTreeSnapshot.reset();\n+        }\n+\n+        synchronized void handleEvents(final String[] paths, long eventFlagsPtr) {\n+            if (paths == null) {\n+                reportOverflow(null);\n+                return;\n+            }\n+\n+            final Set<Path> dirsToScan = new LinkedHashSet<>(paths.length);\n+            final Set<Path> dirsToScanRecursively = new LinkedHashSet<>();\n+            collectDirsToScan(paths, eventFlagsPtr, dirsToScan, dirsToScanRecursively);\n+\n+            for (final Path recurseDir : dirsToScanRecursively) {\n+                dirsToScan.removeIf(dir -> dir.startsWith(recurseDir));\n+                directoryTreeSnapshot.update(recurseDir, true);\n+            }\n+\n+            for (final Path dir : dirsToScan) {\n+                directoryTreeSnapshot.update(dir, false);\n+            }\n+        }\n+\n+        private Path toRelativePath(final String absPath) {\n+            return   (absPath.length() > realRootPathLength)\n+                    ? Path.of(absPath.substring(realRootPathLength))\n+                    : relativeRootPath;\n+        }\n+\n+        private void collectDirsToScan(final String[] paths, long eventFlagsPtr,\n+                                       final Set<Path> dirsToScan,\n+                                       final Set<Path> dirsToScanRecursively) {\n+            for (final String absPath : paths) {\n+                if (absPath == null) {\n+                    reportOverflow(null);\n+                    continue;\n+                }\n+\n+                Path path = toRelativePath(absPath);\n+\n+                if (!watchFileTree && !relativeRootPath.equals(path)) {\n+                    continue;\n+                }\n+\n+                final int flags = unsafe.getInt(eventFlagsPtr);\n+                if ((flags & kFSEventStreamEventFlagRootChanged) != 0) {\n+                    cancel();\n+                    signal();\n+                    break;\n+                } else if ((flags & kFSEventStreamEventFlagMustScanSubDirs) != 0 && watchFileTree) {\n+                    dirsToScanRecursively.add(path);\n+                } else {\n+                    dirsToScan.add(path);\n+                }\n+\n+                final long SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS = 4L; \/\/ FSEventStreamEventFlags is UInt32\n+                eventFlagsPtr += SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS;\n+            }\n+        }\n+\n+        \/**\n+         * Represents a snapshot of a directory tree.\n+         * The snapshot includes subdirectories iff <code>watchFileTree<\/code> is <code>true<\/code>.\n+         *\/\n+        private class DirectoryTreeSnapshot {\n+            private final HashMap<Path, DirectorySnapshot> snapshots;\n+\n+            DirectoryTreeSnapshot() {\n+                this.snapshots = new HashMap<>(watchFileTree ? 256 : 1);\n+            }\n+\n+            void build() throws IOException {\n+                final Queue<Path> pathToDo = new ArrayDeque<>();\n+                pathToDo.offer(relativeRootPath);\n+\n+                while (!pathToDo.isEmpty()) {\n+                    final Path path = pathToDo.poll();\n+                    try {\n+                        createForOneDirectory(path, watchFileTree ? pathToDo : null);\n+                    } catch (IOException e) {\n+                        final boolean exceptionForRootPath = relativeRootPath.equals(path);\n+                        if (exceptionForRootPath)\n+                            throw e; \/\/ report to the user as the watch root may have disappeared\n+\n+                        \/\/ Ignore for sub-directories as some may have been removed during the scan.\n+                        \/\/ That's OK, those kinds of changes in the directory hierarchy is what\n+                        \/\/ WatchService is used for. However, it's impossible to catch all changes\n+                        \/\/ at this point, so we may fail to report some events that had occurred before\n+                        \/\/ FSEventStream has been created to watch for those changes.\n+                    }\n+                }\n+            }\n+\n+            private DirectorySnapshot createForOneDirectory(\n+                    final Path directory,\n+                    final Queue<Path> newDirectoriesFound) throws IOException {\n+                final DirectorySnapshot snapshot = DirectorySnapshot.create(getRealRootPath(), directory);\n+                snapshots.put(directory, snapshot);\n+                if (newDirectoriesFound != null)\n+                    snapshot.forEachDirectory(newDirectoriesFound::offer);\n+\n+                return snapshot;\n+            }\n+\n+            void reset() {\n+                snapshots.clear();\n+            }\n+\n+            void update(final Path directory, final boolean recurse) {\n+                if (!recurse) {\n+                    directoryTreeSnapshot.update(directory, null);\n+                } else {\n+                    final Queue<Path> pathToDo = new ArrayDeque<>();\n+                    pathToDo.offer(directory);\n+                    while (!pathToDo.isEmpty()) {\n+                        final Path dir = pathToDo.poll();\n+                        directoryTreeSnapshot.update(dir, pathToDo);\n+                    }\n+                }\n+            }\n+\n+            private void update(final Path directory, final Queue<Path> modifiedDirs) {\n+                final DirectorySnapshot snapshot = snapshots.get(directory);\n+                if (snapshot == null) {\n+                    \/\/ This means that we missed a notification about an update of our parent.\n+                    \/\/ Report overflow (who knows what else we weren't notified about?) and\n+                    \/\/ do our best to recover from this mess by queueing our parent for an update.\n+                    reportOverflow(directory);\n+                    if (modifiedDirs != null)\n+                        modifiedDirs.offer(getParentOf(directory));\n+\n+                    return;\n+                }\n+\n+                \/\/ FSEvents API does not generate events for directories that got moved from\/to the directory\n+                \/\/ being watched, so we have to watch for new\/deleted directories ourselves. If we still\n+                \/\/ receive an event for, say, one of the new directories, it won't be reported again as this\n+                \/\/ will count as refresh with no modifications detected.\n+                final Queue<Path> createdDirs = new ArrayDeque<>();\n+                final Queue<Path> deletedDirs = new ArrayDeque<>();\n+                snapshot.update(MacOSXWatchKey.this, createdDirs, deletedDirs, modifiedDirs);\n+\n+                handleNewDirectories(createdDirs);\n+                handleDeletedDirectories(deletedDirs);\n+            }\n+\n+            private Path getParentOf(final Path directory) {\n+                Path parent = directory.getParent();\n+                if (parent == null)\n+                    parent = relativeRootPath;\n+                return parent;\n+            }\n+\n+            private void handleDeletedDirectories(final Queue<Path> deletedDirs) {\n+                \/\/ We don't know the exact sequence in which these were deleted,\n+                \/\/ so at least maintain a sensible order, i.e. children are deleted before the parent.\n+                final LinkedList<Path> dirsToReportDeleted = new LinkedList<>();\n+                while (!deletedDirs.isEmpty()) {\n+                    final Path path = deletedDirs.poll();\n+                    dirsToReportDeleted.addFirst(path);\n+                    final DirectorySnapshot directorySnapshot = snapshots.get(path);\n+                    if (directorySnapshot != null) \/\/ May be null if we're not watching the whole file tree.\n+                        directorySnapshot.forEachDirectory(deletedDirs::offer);\n+                }\n+\n+                for(final Path path : dirsToReportDeleted) {\n+                    final DirectorySnapshot directorySnapshot = snapshots.remove(path);\n+                    if (directorySnapshot != null) {\n+                        \/\/ This is needed in case a directory tree was moved (mv -f) out of this directory.\n+                        directorySnapshot.forEachFile(MacOSXWatchKey.this::reportDeleted);\n+                    }\n+                    reportDeleted(path);\n+                }\n+            }\n+\n+            private void handleNewDirectories(final Queue<Path> createdDirs) {\n+                \/\/ We don't know the exact sequence in which these were created,\n+                \/\/ so at least maintain a sensible order, i.e. the parent created before its children.\n+                while (!createdDirs.isEmpty()) {\n+                    final Path path = createdDirs.poll();\n+                    reportCreated(path);\n+                    if (watchFileTree) {\n+                        if (!snapshots.containsKey(path)) {\n+                            \/\/ Happens when a directory tree gets moved (mv -f) into this directory.\n+                            DirectorySnapshot newSnapshot = null;\n+                            try {\n+                                newSnapshot = createForOneDirectory(path, createdDirs);\n+                            } catch(IOException ignore) { }\n+\n+                            if (newSnapshot != null)\n+                                newSnapshot.forEachFile(MacOSXWatchKey.this::reportCreated);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Represents a snapshot of a directory with a millisecond precision timestamp of the last modification.\n+         *\/\n+        private static class DirectorySnapshot {\n+            \/\/ Path to this directory relative to the watch root.\n+            private final Path directory;\n+\n+            \/\/ Maps file names to their attributes.\n+            private final Map<Path, Entry> files;\n+\n+            \/\/ A counter to keep track of files that have disappeared since the last run.\n+            private long currentTick;\n+\n+            private DirectorySnapshot(final Path directory) {\n+                this.directory = directory;\n+                this.files     = new HashMap<>();\n+            }\n+\n+            static DirectorySnapshot create(final Path realRootPath, final Path directory) throws IOException {\n+                final DirectorySnapshot snapshot = new DirectorySnapshot(directory);\n+                try (final DirectoryStream<Path> directoryStream\n+                             = Files.newDirectoryStream(realRootPath.resolve(directory))) {\n+                    for (final Path file : directoryStream) {\n+                        try {\n+                            final BasicFileAttributes attrs = Files.readAttributes(\n+                                    file, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                            final Entry entry = new Entry(\n+                                    attrs.isDirectory(), attrs.lastModifiedTime().toMillis(), 0);\n+                            snapshot.files.put(file.getFileName(), entry);\n+                        } catch (IOException ignore) {}\n+                    }\n+                } catch (DirectoryIteratorException e) {\n+                    throw e.getCause();\n+                }\n+\n+                return snapshot;\n+            }\n+\n+            void forEachDirectory(final Consumer<Path> consumer) {\n+                files.forEach((path, entry) -> { if (entry.isDirectory) consumer.accept(directory.resolve(path)); } );\n+            }\n+\n+            void forEachFile(final Consumer<Path> consumer) {\n+                files.forEach((path, entry) -> { if (!entry.isDirectory) consumer.accept(directory.resolve(path)); } );\n+            }\n+\n+            void update(final MacOSXWatchKey watchKey,\n+                        final Queue<Path> createdDirs,\n+                        final Queue<Path> deletedDirs,\n+                        final Queue<Path> modifiedDirs) {\n+                currentTick++;\n+\n+                try (final DirectoryStream<Path> directoryStream\n+                             = Files.newDirectoryStream(watchKey.getRealRootPath().resolve(directory))) {\n+                    for (final Path file : directoryStream) {\n+                        try {\n+                            final BasicFileAttributes attrs\n+                                    = Files.readAttributes(file, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                            final Path fileName     = file.getFileName();\n+                            final Entry entry       = files.get(fileName);\n+                            final boolean isNew     = (entry == null);\n+                            final long lastModified = attrs.lastModifiedTime().toMillis();\n+                            final Path relativePath = directory.resolve(fileName);\n+\n+                            if (attrs.isDirectory()) {\n+                                if (isNew) {\n+                                    files.put(fileName, new Entry(true, lastModified, currentTick));\n+                                    if (createdDirs != null) createdDirs.offer(relativePath);\n+                                } else {\n+                                    if (!entry.isDirectory) { \/\/ Used to be a file, now a directory\n+                                        if (createdDirs != null) createdDirs.offer(relativePath);\n+\n+                                        files.put(fileName, new Entry(true, lastModified, currentTick));\n+                                        watchKey.reportDeleted(relativePath);\n+                                    } else if (entry.isModified(lastModified)) {\n+                                        if (modifiedDirs != null) modifiedDirs.offer(relativePath);\n+                                        watchKey.reportModified(relativePath);\n+                                    }\n+                                    entry.update(lastModified, currentTick);\n+                                }\n+                            } else {\n+                                if (isNew) {\n+                                    files.put(fileName, new Entry(false, lastModified, currentTick));\n+                                    watchKey.reportCreated(relativePath);\n+                                } else {\n+                                    if (entry.isDirectory) { \/\/ Used to be a directory, now a file.\n+                                        if (deletedDirs != null) deletedDirs.offer(relativePath);\n+\n+                                        files.put(fileName, new Entry(false, lastModified, currentTick));\n+                                        watchKey.reportCreated(directory.resolve(fileName));\n+                                    } else if (entry.isModified(lastModified)) {\n+                                        watchKey.reportModified(relativePath);\n+                                    }\n+                                    entry.update(lastModified, currentTick);\n+                                }\n+                            }\n+                        } catch (IOException ignore) {\n+                            \/\/ Simply skip the file we couldn't read; it'll get marked as deleted later.\n+                        }\n+                    }\n+                } catch (IOException | DirectoryIteratorException ignore) {\n+                    \/\/ Most probably this directory has just been deleted; its parent will notice that.\n+                }\n+\n+                checkDeleted(watchKey, deletedDirs);\n+            }\n+\n+            private void checkDeleted(final MacOSXWatchKey watchKey, final Queue<Path> deletedDirs) {\n+                final Iterator<Map.Entry<Path, Entry>> it = files.entrySet().iterator();\n+                while (it.hasNext()) {\n+                    final Map.Entry<Path, Entry> mapEntry = it.next();\n+                    final Entry entry = mapEntry.getValue();\n+                    if (entry.lastTickCount != currentTick) {\n+                        final Path file = mapEntry.getKey();\n+                        it.remove();\n+\n+                        if (entry.isDirectory) {\n+                            if (deletedDirs != null) deletedDirs.offer(directory.resolve(file));\n+                        } else {\n+                            watchKey.reportDeleted(directory.resolve(file));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/**\n+             * Information about an entry in a directory.\n+             *\/\n+            private static class Entry {\n+                private long lastModified;\n+                private long lastTickCount;\n+                private final boolean isDirectory;\n+\n+                Entry(final boolean isDirectory, final long lastModified, final long lastTickCount) {\n+                    this.lastModified  = lastModified;\n+                    this.lastTickCount = lastTickCount;\n+                    this.isDirectory   = isDirectory;\n+                }\n+\n+                boolean isModified(final long lastModified) {\n+                    return (this.lastModified != lastModified);\n+                }\n+\n+                void update(final long lastModified, final long lastTickCount) {\n+                    this.lastModified = lastModified;\n+                    this.lastTickCount = lastTickCount;\n+                }\n+            }\n+        }\n+\n+        private void reportCreated(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.CREATE))\n+                signalEvent(StandardWatchEventKinds.ENTRY_CREATE, path);\n+        }\n+\n+        private void reportDeleted(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.DELETE))\n+                signalEvent(StandardWatchEventKinds.ENTRY_DELETE, path);\n+        }\n+\n+        private void reportModified(final Path path) {\n+           if (eventsToWatch.contains(FSEventKind.MODIFY))\n+                signalEvent(StandardWatchEventKinds.ENTRY_MODIFY, path);\n+        }\n+\n+        private void reportOverflow(final Path path) {\n+            if (eventsToWatch.contains(FSEventKind.OVERFLOW))\n+                signalEvent(StandardWatchEventKinds.OVERFLOW, path);\n+        }\n+\n+        public Object getRootPathKey() {\n+            return rootPathKey;\n+        }\n+\n+        public Path getRealRootPath() {\n+            return realRootPath;\n+        }\n+\n+        @Override\n+        public boolean isValid() {\n+            synchronized (eventStreamRefLock) {\n+                return eventStreamRef != 0;\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (!isValid()) return;\n+\n+            \/\/ First, must stop the corresponding run loop:\n+            ((MacOSXWatchService) watcher()).cancel(this);\n+\n+            \/\/ Next, invalidate the corresponding native FSEventStream.\n+            invalidate();\n+        }\n+\n+        void invalidate() {\n+            synchronized (eventStreamRefLock) {\n+                if (isValid()) {\n+                    eventStreamStop(eventStreamRef);\n+                    eventStreamRef = 0;\n+                }\n+            }\n+        }\n+\n+        long getEventStreamRef() {\n+            synchronized (eventStreamRefLock) {\n+                assert (isValid());\n+                return eventStreamRef;\n+            }\n+        }\n+    }\n+\n+    \/* native methods *\/\n+\n+    private static native long eventStreamCreate(String dir, double latencyInSeconds, int flags);\n+    private static native void eventStreamSchedule(long eventStreamRef, long runLoopRef);\n+    private static native void eventStreamStop(long eventStreamRef);\n+    private static native long CFRunLoopGetCurrent();\n+    private static native void CFRunLoopRun(final MacOSXWatchService watchService);\n+    private static native void CFRunLoopStop(long runLoopRef);\n+\n+    private static native void initIDs();\n+\n+    static {\n+        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n+        initIDs();\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXWatchService.java","additions":794,"deletions":0,"binary":false,"changes":794,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"nio_util.h\"\n+\n+#include <CoreFoundation\/CoreFoundation.h>\n+#include <CoreServices\/CoreServices.h>\n+\n+static jmethodID        callbackMID;  \/\/ MacOSXWatchService.callback()\n+static __thread jobject watchService; \/\/ The instance of MacOSXWatchService that is associated with this thread\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_initIDs(JNIEnv* env, __unused jclass clazz)\n+{\n+    callbackMID = (*env)->GetMethodID(env, clazz, \"callback\", \"(J[Ljava\/lang\/String;J)V\");\n+}\n+\n+extern CFStringRef\n+toCFString(JNIEnv *env, jstring javaString);\n+\n+static jboolean\n+convertToJavaStringArray(JNIEnv* env, char **eventPaths,\n+                         const jsize numEventsToReport, jobjectArray javaEventPathsArray)\n+{\n+    for (jsize i = 0; i < numEventsToReport; i++) {\n+        const jstring path = JNU_NewStringPlatform(env, eventPaths[i]);\n+        CHECK_NULL_RETURN(path, FALSE);\n+        (*env)->SetObjectArrayElement(env, javaEventPathsArray, i, path);\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+static void\n+callJavaCallback(JNIEnv* env, jlong streamRef, jobjectArray javaEventPathsArray, jlong eventFlags)\n+{\n+    if (callbackMID != NULL && watchService != NULL) {\n+        \/\/ We are called on the run loop thread, so it's OK to use the thread-local reference\n+        \/\/ to the watch service.\n+        (*env)->CallVoidMethod(env, watchService, callbackMID, streamRef, javaEventPathsArray, eventFlags);\n+    }\n+}\n+\n+\/**\n+ * Callback that is invoked on the run loop thread and informs of new file-system events from an FSEventStream.\n+ *\/\n+static void\n+callback(__unused ConstFSEventStreamRef streamRef,\n+         __unused void *clientCallBackInfo,\n+         size_t numEventsTotal,\n+         void *eventPaths,\n+         const FSEventStreamEventFlags eventFlags[],\n+         __unused const FSEventStreamEventId eventIds[])\n+{\n+    JNIEnv *env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);\n+    if (!env) { \/\/ Shouldn't happen as run loop starts from Java code\n+        return;\n+    }\n+\n+    \/\/ We can get more events at once than the number of Java array elements,\n+    \/\/ so report them in chunks.\n+    const size_t MAX_EVENTS_TO_REPORT_AT_ONCE = (INT_MAX - 2);\n+\n+    jboolean success = JNI_TRUE;\n+    for(size_t eventIndex = 0; success && (eventIndex < numEventsTotal); ) {\n+        const size_t numEventsRemaining = (numEventsTotal - eventIndex);\n+        const jsize  numEventsToReport  = (numEventsRemaining > MAX_EVENTS_TO_REPORT_AT_ONCE)\n+                                        ? MAX_EVENTS_TO_REPORT_AT_ONCE\n+                                        : numEventsRemaining;\n+\n+        const jboolean localFramePushed = ((*env)->PushLocalFrame(env, numEventsToReport + 5) == JNI_OK);\n+        success = localFramePushed;\n+\n+        jobjectArray javaEventPathsArray = NULL;\n+        if (success) {\n+            javaEventPathsArray = (*env)->NewObjectArray(env, (jsize)numEventsToReport, JNU_ClassString(env), NULL);\n+            success = (javaEventPathsArray != NULL);\n+        }\n+\n+        if (success) {\n+            success = convertToJavaStringArray(env, &((char**)eventPaths)[eventIndex],\n+                                               numEventsToReport, javaEventPathsArray);\n+        }\n+\n+        callJavaCallback(env, (jlong)streamRef, javaEventPathsArray, (jlong)&eventFlags[eventIndex]);\n+\n+        if ((*env)->ExceptionCheck(env)) {\n+            (*env)->ExceptionDescribe(env);\n+        }\n+\n+        if (localFramePushed) {\n+            (*env)->PopLocalFrame(env, NULL);\n+        }\n+\n+        eventIndex += numEventsToReport;\n+    }\n+}\n+\n+\/**\n+ * Creates a new FSEventStream and returns FSEventStreamRef for it.\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamCreate(JNIEnv* env, __unused jclass clazz,\n+                                                     jstring dir, jdouble latencyInSeconds, jint flags)\n+{\n+    const CFStringRef path = toCFString(env, dir);\n+    CHECK_NULL_RETURN(path, 0);\n+    const CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **) &path, 1, NULL);\n+    CHECK_NULL_RETURN(pathsToWatch, 0);\n+\n+    const FSEventStreamRef stream = FSEventStreamCreate(\n+            NULL,\n+            &callback,\n+            NULL,\n+            pathsToWatch,\n+            kFSEventStreamEventIdSinceNow,\n+            (CFAbsoluteTime) latencyInSeconds,\n+            flags);\n+\n+    return (jlong)stream;\n+}\n+\n+\n+\/**\n+ * Schedules the given FSEventStream with the given run loop. Starts the stream\n+ * so that the run loop can receive events from the stream.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamSchedule(__unused JNIEnv* env,  __unused jclass clazz,\n+                                                     jlong eventStreamRef, jlong runLoopRef)\n+{\n+    const FSEventStreamRef stream  = (FSEventStreamRef)eventStreamRef;\n+    const CFRunLoopRef     runLoop = (CFRunLoopRef)runLoopRef;\n+\n+    FSEventStreamScheduleWithRunLoop(stream, runLoop, kCFRunLoopDefaultMode);\n+    FSEventStreamStart(stream);\n+}\n+\n+\/**\n+ * Performs the steps necessary to dispose of the given FSEventStreamRef.\n+ * The stream must have been started and scheduled with a run loop.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamStop(__unused JNIEnv* env, __unused jclass clazz, jlong eventStreamRef)\n+{\n+    const FSEventStreamRef streamRef = (FSEventStreamRef)eventStreamRef;\n+\n+    FSEventStreamStop(streamRef);       \/\/ Unregister with the FS Events service. No more callbacks from this stream\n+    FSEventStreamInvalidate(streamRef); \/\/ De-schedule from any runloops\n+    FSEventStreamRelease(streamRef);    \/\/ Decrement the stream's refcount\n+}\n+\n+\/**\n+ * Returns the CFRunLoop object for the current thread.\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopGetCurrent(__unused JNIEnv* env, __unused jclass clazz)\n+{\n+    return (jlong)CFRunLoopGetCurrent();\n+}\n+\n+\/**\n+ * Simply calls CFRunLoopRun() to run current thread's run loop for as long as there are event sources\n+ * attached to it.\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopRun(__unused JNIEnv* env, __unused jclass clazz, jlong watchServiceObject)\n+{\n+    \/\/ Thread-local pointer to the WatchService instance will be used by the callback\n+    \/\/ on this thread.\n+    watchService = (*env)->NewGlobalRef(env, (jobject)watchServiceObject);\n+    CFRunLoopRun();\n+    (*env)->DeleteGlobalRef(env, (jobject)watchService);\n+    watchService = NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopStop(__unused JNIEnv* env, __unused jclass clazz, jlong runLoopRef)\n+{\n+    CFRunLoopStop((CFRunLoopRef)runLoopRef);\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/MacOSXWatchService.c","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static CFStringRef toCFString(JNIEnv *env, jstring javaString)\n+CFStringRef toCFString(JNIEnv *env, jstring javaString)\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/UTIFileTypeDetector.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+#include \"nio_util.h\"\n+\n+JavaVM *jvm;\n@@ -34,0 +37,1 @@\n+    jvm = vm;\n","filename":"src\/java.base\/share\/native\/libnio\/nio_util.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -783,0 +783,12 @@\n+    void checkRead(WatchEvent.Modifier... modifiers) {\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            final boolean watchSubtree = Arrays.stream(modifiers).anyMatch(ExtendedOptions.FILE_TREE::matches);\n+            final String path = getPathForPermissionCheck();\n+            sm.checkRead(path);\n+            if (watchSubtree)\n+                sm.checkRead(path + \"\/-\");\n+        }\n+    }\n+\n@@ -884,1 +896,2 @@\n-        checkRead();\n+\n+        checkRead(modifiers);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+extern JavaVM *jvm;\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/nio_util.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Run several WatchService tests with -Xcheck:jni to check for\n+ *          warnings.\n+ * @requires os.family == \"mac\"\n+ * @library \/test\/lib\n+ * @build UpdateInterference DeleteInterference LotsOfCancels LotsOfCloses\n+ * @run main JNIChecks\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class JNIChecks {\n+\n+    public static void main(String[] args) throws Exception {\n+        {\n+            System.out.println(\"Test 1: UpdateInterference\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", UpdateInterference.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 2: DeleteInterference\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", DeleteInterference.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 3: LotsOfCancels\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", LotsOfCancels.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+\n+        {\n+            System.out.println(\"Test 4: LotsOfCloses\");\n+            final OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-Xcheck:jni\", LotsOfCloses.class.getName());\n+            oa.shouldNotContain(\"WARNING\").shouldHaveExitValue(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/JNIChecks.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Verifies that Files.move() of a directory hierarchy is correctly\n+ *          reported by WatchService.\n+ * @requires os.family == \"mac\"\n+ * @library ..\n+ * @run main Move\n+ *\/\n+\n+import java.nio.file.*;\n+import static java.nio.file.StandardWatchEventKinds.*;\n+import java.nio.file.attribute.*;\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import com.sun.nio.file.ExtendedWatchEventModifier;\n+\n+public class Move {\n+\n+    static void checkKey(WatchKey key, Path dir) {\n+        if (!key.isValid())\n+            throw new RuntimeException(\"Key is not valid\");\n+        if (key.watchable() != dir)\n+            throw new RuntimeException(\"Unexpected watchable\");\n+    }\n+\n+    static void takeExpectedKey(WatchService watcher, WatchKey expected) {\n+        System.out.println(\"take events...\");\n+        WatchKey key;\n+        try {\n+            key = watcher.take();\n+        } catch (InterruptedException x) {\n+            \/\/ not expected\n+            throw new RuntimeException(x);\n+        }\n+        if (key != expected)\n+            throw new RuntimeException(\"removed unexpected key\");\n+    }\n+\n+    static void dumpEvents(final List<WatchEvent<?>> events) {\n+        System.out.println(\"Got events: \");\n+        for(WatchEvent<?> event : events) {\n+            System.out.println(event.kind() + \" for '\" + event.context() + \"' count = \" + event.count());\n+        }\n+    }\n+\n+    static void assertHasEvent(final List<WatchEvent<?>> events, final Path path, final WatchEvent.Kind<Path> kind) {\n+        for (final WatchEvent<?> event : events) {\n+            if (event.context().equals(path) && event.kind().equals(kind)) {\n+                if (event.count() != 1) {\n+                    throw new RuntimeException(\"Expected count 1 for event \" + event);\n+                }\n+                return;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Didn't find event \" + kind + \" for path '\" + path + \"'\");\n+    }\n+\n+    \/**\n+     * Verifies move of a directory sub-tree with and without FILE_TREE option.\n+     *\/\n+    static void testMoveSubtree(final Path dir) throws IOException {\n+        final FileSystem fs = FileSystems.getDefault();\n+        final WatchService rootWatcher = fs.newWatchService();\n+        final WatchService subtreeWatcher = fs.newWatchService();\n+        try {\n+            Path path = dir.resolve(\"root\");\n+            Files.createDirectory(path);\n+            System.out.println(\"Created \" + path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\");\n+            Files.createDirectories(path);\n+            System.out.println(\"Created \" + path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"file1\");\n+            Files.createFile(path);\n+\n+            path = dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\").resolve(\"file3\");\n+            Files.createFile(path);\n+\n+            \/\/ register with both watch services (different events)\n+            System.out.println(\"register for different events\");\n+            final WatchKey rootKey = dir.resolve(dir.resolve(\"root\")).register(rootWatcher,\n+                    new WatchEvent.Kind<?>[]{ ENTRY_CREATE, ENTRY_DELETE });\n+            final WatchKey subtreeKey = dir.resolve(dir.resolve(\"root\")).register(subtreeWatcher,\n+                    new WatchEvent.Kind<?>[]{ ENTRY_CREATE, ENTRY_DELETE },  ExtendedWatchEventModifier.FILE_TREE);\n+\n+            if (rootKey == subtreeKey)\n+                throw new RuntimeException(\"keys should be different\");\n+\n+            System.out.println(\"Move root\/subdir\/1\/2 -> root\/subdir\/2.moved\");\n+            Files.move(dir.resolve(\"root\").resolve(\"subdir\").resolve(\"1\").resolve(\"2\"),\n+                       dir.resolve(\"root\").resolve(\"subdir\").resolve(\"2.moved\"));\n+\n+            \/\/ Check that changes in a subdirectory were not noticed by the root directory watcher\n+            {\n+                final WatchKey key = rootWatcher.poll();\n+                if (key != null)\n+                    throw new RuntimeException(\"key not expected\");\n+            }\n+\n+            \/\/ Check that the moved subtree has become a series of DELETE\/CREATE events\n+            {\n+                takeExpectedKey(subtreeWatcher, subtreeKey);\n+                final List<WatchEvent<?>> events = subtreeKey.pollEvents();\n+                dumpEvents(events);\n+\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\").resolve(\"file3\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\"), ENTRY_CREATE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\"), ENTRY_CREATE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\").resolve(\"file3\"), ENTRY_CREATE);\n+                if (events.size() > 6) {\n+                    throw new RuntimeException(\"Too many events\");\n+                }\n+            }\n+            rootKey.reset();\n+            subtreeKey.reset();\n+\n+            System.out.println(\"Move root\/subdir\/2.moved -> root\/2\");\n+            Files.move(dir.resolve(\"root\").resolve(\"subdir\").resolve(\"2.moved\"),\n+                       dir.resolve(\"root\").resolve(\"2\"));\n+\n+            \/\/ Check that the root directory watcher has noticed one new directory.\n+            {\n+                takeExpectedKey(rootWatcher, rootKey);\n+                final List<WatchEvent<?>> events = rootKey.pollEvents();\n+                dumpEvents(events);\n+                assertHasEvent(events, Path.of(\"2\"), ENTRY_CREATE);\n+                if (events.size() > 1) {\n+                    throw new RuntimeException(\"Too many events\");\n+                }\n+            }\n+\n+            \/\/ Check the recursive root directory watcher\n+            {\n+                takeExpectedKey(subtreeWatcher, subtreeKey);\n+                final List<WatchEvent<?>> events = subtreeKey.pollEvents();\n+                dumpEvents(events);\n+\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\").resolve(\"file3\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\"), ENTRY_DELETE);\n+                assertHasEvent(events, Path.of(\"2\"), ENTRY_CREATE);\n+                assertHasEvent(events, Path.of(\"2\").resolve(\"3\"), ENTRY_CREATE);\n+                assertHasEvent(events, Path.of(\"2\").resolve(\"3\").resolve(\"file3\"), ENTRY_CREATE);\n+                if (events.size() > 6) {\n+                    throw new RuntimeException(\"Too many events\");\n+                }\n+            }\n+        } finally {\n+            rootWatcher.close();\n+            subtreeWatcher.close();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies quickly deleting a file and creating a directory with the same name (and back)\n+     * is recognized by WatchService.\n+     *\/\n+    static void testMoveFileToDirectory(final Path dir) throws IOException {\n+        final FileSystem fs = FileSystems.getDefault();\n+        try (final WatchService watcher = fs.newWatchService()) {\n+            Files.createDirectory(dir.resolve(\"dir\"));\n+            Files.createFile(dir.resolve(\"file\"));\n+\n+            final WatchKey key = dir.register(watcher, new WatchEvent.Kind<?>[]{ENTRY_CREATE, ENTRY_DELETE});\n+\n+            for (int i = 0; i < 4; i++) {\n+                System.out.println(\"Iteration \" + i);\n+                Files.delete(dir.resolve(\"dir\"));\n+                Files.delete(dir.resolve(\"file\"));\n+                if (i % 2 == 1) {\n+                    Files.createDirectory(dir.resolve(\"dir\"));\n+                    Files.createFile(dir.resolve(\"file\"));\n+                } else {\n+                    Files.createDirectory(dir.resolve(\"file\"));\n+                    Files.createFile(dir.resolve(\"dir\"));\n+                }\n+\n+                takeExpectedKey(watcher, key);\n+                final List<WatchEvent<?>> events = key.pollEvents();\n+                dumpEvents(events);\n+\n+                final long countDirCreated = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"dir\")) && event.kind().equals(ENTRY_CREATE)).count();\n+                final long countDirDeleted = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"dir\")) && event.kind().equals(ENTRY_DELETE)).count();\n+                final long countFileCreated = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"file\")) && event.kind().equals(ENTRY_CREATE)).count();\n+                final long countFileDeleted = events.stream().filter(\n+                        event -> event.context().equals(Path.of(\"file\")) && event.kind().equals(ENTRY_DELETE)).count();\n+                if (countDirCreated != 1) throw new RuntimeException(\"Not one CREATE for dir\");\n+                if (countDirDeleted != 1) throw new RuntimeException(\"Not one DELETE for dir\");\n+                if (countFileCreated != 1) throw new RuntimeException(\"Not one CREATE for file\");\n+                if (countFileDeleted != 1) throw new RuntimeException(\"Not one DELETE for file\");\n+\n+                key.reset();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Path dir = TestUtil.createTemporaryDirectory();\n+        try {\n+            testMoveSubtree(dir);\n+        } catch(UnsupportedOperationException e) {\n+            System.out.println(\"FILE_TREE watching is not supported; test considered passed\");\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+\n+        dir = TestUtil.createTemporaryDirectory();\n+        try {\n+            testMoveFileToDirectory(dir);\n+        } catch(UnsupportedOperationException e) {\n+            System.out.println(\"FILE_TREE watching is not supported; test considered passed\");\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/Move.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -7,0 +7,1 @@\n+    permission java.lang.RuntimePermission \"loadLibrary.nio\";\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/test.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}