{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -33,1 +34,0 @@\n-import java.nio.file.Files;\n@@ -44,1 +44,0 @@\n-import java.util.ArrayDeque;\n@@ -48,2 +47,0 @@\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n@@ -51,3 +48,1 @@\n-import java.util.Queue;\n-import java.util.Set;\n-import java.util.function.Consumer;\n+import java.util.concurrent.CountDownLatch;\n@@ -56,0 +51,3 @@\n+    private static final MacOSXFileSystemProvider theFSProvider = DefaultFileSystemProvider.instance();\n+    private static final MacOSXFileSystem theFS = (MacOSXFileSystem) theFSProvider.theFileSystem();\n+\n@@ -64,2 +62,3 @@\n-        runLoopThread.setDaemon(true);\n-        runLoopThread.start();\n+        Thread t = InnocuousThread.newThread(\"FileSystemWatcher\", runLoopThread);\n+        t.setDaemon(true);\n+        t.start();\n@@ -67,6 +66,2 @@\n-        try {\n-            \/\/ In order to be able to schedule any FSEventStream's, a reference to a run loop is required.\n-            runLoopThread.waitForRunLoopRef();\n-        } catch (InterruptedException e) {\n-            throw new IOException(e);\n-        }\n+        \/\/ In order to be able to schedule any FSEventStream's, a reference to a run loop is required.\n+        runLoopThread.waitForRunLoopRef();\n@@ -77,1 +72,3 @@\n-    WatchKey register(Path dir, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+    WatchKey register(Path dir,\n+                      WatchEvent.Kind<?>[] events,\n+                      WatchEvent.Modifier... modifiers) throws IOException {\n@@ -86,1 +83,2 @@\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<MacOSXWatchKey>() {\n+            return AccessController.doPrivileged(\n+                    new PrivilegedExceptionAction<MacOSXWatchKey>() {\n@@ -100,1 +98,4 @@\n-    private MacOSXWatchKey doPrivilegedRegister(UnixPath unixDir, Object dirKey, EnumSet<FSEventKind> eventSet, EnumSet<WatchModifier> modifierSet) throws IOException {\n+    private MacOSXWatchKey doPrivilegedRegister(UnixPath unixDir,\n+                                                Object dirKey,\n+                                                EnumSet<FSEventKind> eventSet,\n+                                                EnumSet<WatchModifier> modifierSet) throws IOException {\n@@ -117,1 +118,2 @@\n-                watchKeysLock.notify(); \/\/ So that run loop gets running again if stopped due to lack of event streams\n+                watchKeysLock.notify(); \/\/ So that run loop gets running again\n+                                        \/\/ if stopped due to lack of event streams\n@@ -124,1 +126,2 @@\n-     * Invoked on the CFRunLoopThread by the native code to report directories that need to be re-scanned.\n+     * Invoked on the CFRunLoopThread by the native code to report directories\n+     * that need to be re-scanned.\n@@ -126,1 +129,3 @@\n-    private void callback(final long eventStreamRef, final String[] paths, final long eventFlagsPtr) {\n+    private void callback(final long eventStreamRef,\n+                          final String[] paths,\n+                          final long eventFlagsPtr) {\n@@ -163,1 +168,1 @@\n-    private class CFRunLoopThread extends Thread {\n+    private class CFRunLoopThread implements Runnable {\n@@ -165,5 +170,2 @@\n-        private long runLoopRef;\n-\n-        public CFRunLoopThread() {\n-            super(\"FileSystemWatcher\");\n-        }\n+        private volatile long runLoopRef;\n+        private final CountDownLatch runLoopRefAvailabilitySignal = new CountDownLatch(1);\n@@ -171,3 +173,6 @@\n-        private synchronized void waitForRunLoopRef() throws InterruptedException {\n-            if (runLoopRef == 0)\n-                runLoopThread.wait(); \/\/ ...for CFRunLoopRef to become available\n+        private void waitForRunLoopRef() throws IOException {\n+            try {\n+                runLoopRefAvailabilitySignal.await();\n+            } catch (InterruptedException e) {\n+                throw new IOException(e);\n+            }\n@@ -180,1 +185,1 @@\n-        synchronized void runLoopStop() {\n+        void runLoopStop() {\n@@ -182,2 +187,3 @@\n-                \/\/ The run loop may have stuck in CFRunLoopRun() even though all of its input sources\n-                \/\/ have been removed. Need to terminate it explicitly so that it can run to completion.\n+                \/\/ The run loop may have stuck in CFRunLoopRun() even though\n+                \/\/ all of its input sources have been removed. Need to terminate\n+                \/\/ it explicitly so that it can run to completion.\n@@ -190,4 +196,2 @@\n-            synchronized (this) {\n-                runLoopRef = CFRunLoopGetCurrent();\n-                notify(); \/\/ ... of CFRunLoopRef availability\n-            }\n+            runLoopRef = CFRunLoopGetCurrent();\n+            runLoopRefAvailabilitySignal.countDown();\n@@ -200,3 +204,1 @@\n-            synchronized (this) {\n-                runLoopRef = 0; \/\/ CFRunLoopRef is no longer usable when the loop has been terminated\n-            }\n+            runLoopRef = 0; \/\/ CFRunLoopRef is no longer usable when the loop has been terminated\n@@ -266,1 +268,0 @@\n-\n@@ -270,1 +271,1 @@\n-        FILE_TREE, SENSITIVITY_HIGH, SENSITIVITY_MEDIUM, SENSITIVITY_LOW;\n+        SENSITIVITY_HIGH, SENSITIVITY_MEDIUM, SENSITIVITY_LOW;\n@@ -273,3 +274,1 @@\n-            if (ExtendedOptions.FILE_TREE.matches(watchEventModifier)) {\n-                return FILE_TREE;\n-            } if (ExtendedOptions.SENSITIVITY_HIGH.matches(watchEventModifier)) {\n+            if (ExtendedOptions.SENSITIVITY_HIGH.matches(watchEventModifier)) {\n@@ -312,1 +311,0 @@\n-        private static final long kFSEventStreamEventFlagMustScanSubDirs = 0x00000001;\n@@ -315,1 +313,1 @@\n-        private final static Path relativeRootPath = Path.of(\"\");\n+        private final static Path relativeRootPath = theFS.getPath(\"\");\n@@ -325,3 +323,0 @@\n-        \/\/ Should events in directories below realRootPath reported?\n-        private boolean watchFileTree;\n-\n@@ -332,1 +327,1 @@\n-        private final DirectoryTreeSnapshot directoryTreeSnapshot = new DirectoryTreeSnapshot();\n+        private DirectorySnapshot directorySnapshot;\n@@ -349,1 +344,0 @@\n-            this.watchFileTree = modifierSet.contains(WatchModifier.FILE_TREE);\n@@ -351,1 +345,1 @@\n-            directoryTreeSnapshot.build();\n+            directorySnapshot = DirectorySnapshot.create(getRealRootPath());\n@@ -363,1 +357,2 @@\n-                MacOSXWatchService.eventStreamSchedule(eventStreamRef, runLoopThread.getRunLoopRef());\n+                MacOSXWatchService.eventStreamSchedule(eventStreamRef,\n+                        runLoopThread.getRunLoopRef());\n@@ -369,1 +364,1 @@\n-            directoryTreeSnapshot.reset();\n+            directorySnapshot = null;\n@@ -378,11 +373,2 @@\n-            final Set<Path> dirsToScan = new LinkedHashSet<>(paths.length);\n-            final Set<Path> dirsToScanRecursively = new LinkedHashSet<>();\n-            collectDirsToScan(paths, eventFlagsPtr, dirsToScan, dirsToScanRecursively);\n-\n-            for (final Path recurseDir : dirsToScanRecursively) {\n-                dirsToScan.removeIf(dir -> dir.startsWith(recurseDir));\n-                directoryTreeSnapshot.update(recurseDir, true);\n-            }\n-\n-            for (final Path dir : dirsToScan) {\n-                directoryTreeSnapshot.update(dir, false);\n+            if (updateNeeded(paths, eventFlagsPtr)) {\n+                directorySnapshot.update(MacOSXWatchKey.this);\n@@ -394,1 +380,1 @@\n-                    ? Path.of(absPath.substring(realRootPathLength))\n+                    ? theFS.getPath(absPath.substring(realRootPathLength))\n@@ -398,3 +384,2 @@\n-        private void collectDirsToScan(final String[] paths, long eventFlagsPtr,\n-                                       final Set<Path> dirsToScan,\n-                                       final Set<Path> dirsToScanRecursively) {\n+        private boolean updateNeeded(String[] paths, long eventFlagsPtr) {\n+            boolean rootChanged = false;\n@@ -409,1 +394,2 @@\n-                if (!watchFileTree && !relativeRootPath.equals(path)) {\n+                if (!relativeRootPath.equals(path)) {\n+                    \/\/ Ignore events from subdirectories for now.\n@@ -417,0 +403,1 @@\n+                    rootChanged = false;\n@@ -418,2 +405,0 @@\n-                } else if ((flags & kFSEventStreamEventFlagMustScanSubDirs) != 0 && watchFileTree) {\n-                    dirsToScanRecursively.add(path);\n@@ -421,1 +406,1 @@\n-                    dirsToScan.add(path);\n+                    rootChanged = true;\n@@ -424,1 +409,2 @@\n-                final long SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS = 4L; \/\/ FSEventStreamEventFlags is UInt32\n+                \/\/ FSEventStreamEventFlags is UInt32.\n+                final long SIZEOF_FS_EVENT_STREAM_EVENT_FLAGS = 4L;\n@@ -427,8 +413,0 @@\n-        }\n-\n-        \/**\n-         * Represents a snapshot of a directory tree.\n-         * The snapshot includes subdirectories iff <code>watchFileTree<\/code> is <code>true<\/code>.\n-         *\/\n-        private class DirectoryTreeSnapshot {\n-            private final HashMap<Path, DirectorySnapshot> snapshots;\n@@ -436,128 +414,1 @@\n-            DirectoryTreeSnapshot() {\n-                this.snapshots = new HashMap<>(watchFileTree ? 256 : 1);\n-            }\n-\n-            void build() throws IOException {\n-                final Queue<Path> pathToDo = new ArrayDeque<>();\n-                pathToDo.offer(relativeRootPath);\n-\n-                while (!pathToDo.isEmpty()) {\n-                    final Path path = pathToDo.poll();\n-                    try {\n-                        createForOneDirectory(path, watchFileTree ? pathToDo : null);\n-                    } catch (IOException e) {\n-                        final boolean exceptionForRootPath = relativeRootPath.equals(path);\n-                        if (exceptionForRootPath)\n-                            throw e; \/\/ report to the user as the watch root may have disappeared\n-\n-                        \/\/ Ignore for sub-directories as some may have been removed during the scan.\n-                        \/\/ That's OK, those kinds of changes in the directory hierarchy is what\n-                        \/\/ WatchService is used for. However, it's impossible to catch all changes\n-                        \/\/ at this point, so we may fail to report some events that had occurred before\n-                        \/\/ FSEventStream has been created to watch for those changes.\n-                    }\n-                }\n-            }\n-\n-            private DirectorySnapshot createForOneDirectory(\n-                    final Path directory,\n-                    final Queue<Path> newDirectoriesFound) throws IOException {\n-                final DirectorySnapshot snapshot = DirectorySnapshot.create(getRealRootPath(), directory);\n-                snapshots.put(directory, snapshot);\n-                if (newDirectoriesFound != null)\n-                    snapshot.forEachDirectory(newDirectoriesFound::offer);\n-\n-                return snapshot;\n-            }\n-\n-            void reset() {\n-                snapshots.clear();\n-            }\n-\n-            void update(final Path directory, final boolean recurse) {\n-                if (!recurse) {\n-                    directoryTreeSnapshot.update(directory, null);\n-                } else {\n-                    final Queue<Path> pathToDo = new ArrayDeque<>();\n-                    pathToDo.offer(directory);\n-                    while (!pathToDo.isEmpty()) {\n-                        final Path dir = pathToDo.poll();\n-                        directoryTreeSnapshot.update(dir, pathToDo);\n-                    }\n-                }\n-            }\n-\n-            private void update(final Path directory, final Queue<Path> modifiedDirs) {\n-                final DirectorySnapshot snapshot = snapshots.get(directory);\n-                if (snapshot == null) {\n-                    \/\/ This means that we missed a notification about an update of our parent.\n-                    \/\/ Report overflow (who knows what else we weren't notified about?) and\n-                    \/\/ do our best to recover from this mess by queueing our parent for an update.\n-                    reportOverflow(directory);\n-                    if (modifiedDirs != null)\n-                        modifiedDirs.offer(getParentOf(directory));\n-\n-                    return;\n-                }\n-\n-                \/\/ FSEvents API does not generate events for directories that got moved from\/to the directory\n-                \/\/ being watched, so we have to watch for new\/deleted directories ourselves. If we still\n-                \/\/ receive an event for, say, one of the new directories, it won't be reported again as this\n-                \/\/ will count as refresh with no modifications detected.\n-                final Queue<Path> createdDirs = new ArrayDeque<>();\n-                final Queue<Path> deletedDirs = new ArrayDeque<>();\n-                snapshot.update(MacOSXWatchKey.this, createdDirs, deletedDirs, modifiedDirs);\n-\n-                handleNewDirectories(createdDirs);\n-                handleDeletedDirectories(deletedDirs);\n-            }\n-\n-            private Path getParentOf(final Path directory) {\n-                Path parent = directory.getParent();\n-                if (parent == null)\n-                    parent = relativeRootPath;\n-                return parent;\n-            }\n-\n-            private void handleDeletedDirectories(final Queue<Path> deletedDirs) {\n-                \/\/ We don't know the exact sequence in which these were deleted,\n-                \/\/ so at least maintain a sensible order, i.e. children are deleted before the parent.\n-                final LinkedList<Path> dirsToReportDeleted = new LinkedList<>();\n-                while (!deletedDirs.isEmpty()) {\n-                    final Path path = deletedDirs.poll();\n-                    dirsToReportDeleted.addFirst(path);\n-                    final DirectorySnapshot directorySnapshot = snapshots.get(path);\n-                    if (directorySnapshot != null) \/\/ May be null if we're not watching the whole file tree.\n-                        directorySnapshot.forEachDirectory(deletedDirs::offer);\n-                }\n-\n-                for(final Path path : dirsToReportDeleted) {\n-                    final DirectorySnapshot directorySnapshot = snapshots.remove(path);\n-                    if (directorySnapshot != null) {\n-                        \/\/ This is needed in case a directory tree was moved (mv -f) out of this directory.\n-                        directorySnapshot.forEachFile(MacOSXWatchKey.this::reportDeleted);\n-                    }\n-                    reportDeleted(path);\n-                }\n-            }\n-\n-            private void handleNewDirectories(final Queue<Path> createdDirs) {\n-                \/\/ We don't know the exact sequence in which these were created,\n-                \/\/ so at least maintain a sensible order, i.e. the parent created before its children.\n-                while (!createdDirs.isEmpty()) {\n-                    final Path path = createdDirs.poll();\n-                    reportCreated(path);\n-                    if (watchFileTree) {\n-                        if (!snapshots.containsKey(path)) {\n-                            \/\/ Happens when a directory tree gets moved (mv -f) into this directory.\n-                            DirectorySnapshot newSnapshot = null;\n-                            try {\n-                                newSnapshot = createForOneDirectory(path, createdDirs);\n-                            } catch(IOException ignore) { }\n-\n-                            if (newSnapshot != null)\n-                                newSnapshot.forEachFile(MacOSXWatchKey.this::reportCreated);\n-                        }\n-                    }\n-                }\n-            }\n+            return rootChanged;\n@@ -567,1 +418,2 @@\n-         * Represents a snapshot of a directory with a millisecond precision timestamp of the last modification.\n+         * Represents a snapshot of the watched directory with a millisecond\n+         * precision timestamp of the last modification.\n@@ -570,3 +422,0 @@\n-            \/\/ Path to this directory relative to the watch root.\n-            private final Path directory;\n-\n@@ -574,1 +423,1 @@\n-            private final Map<Path, Entry> files;\n+            private final Map<Path, Entry> files = new HashMap<>();\n@@ -579,7 +428,2 @@\n-            private DirectorySnapshot(final Path directory) {\n-                this.directory = directory;\n-                this.files     = new HashMap<>();\n-            }\n-\n-            static DirectorySnapshot create(final Path realRootPath, final Path directory) throws IOException {\n-                final DirectorySnapshot snapshot = new DirectorySnapshot(directory);\n+            static DirectorySnapshot create(final Path realRootPath) throws IOException {\n+                final DirectorySnapshot snapshot = new DirectorySnapshot();\n@@ -587,1 +431,2 @@\n-                             = Files.newDirectoryStream(realRootPath.resolve(directory))) {\n+                             = theFSProvider.newDirectoryStream(\n+                                     realRootPath, p -> true)) {\n@@ -590,2 +435,5 @@\n-                            final BasicFileAttributes attrs = Files.readAttributes(\n-                                    file, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                            final BasicFileAttributes attrs\n+                                    = theFSProvider.readAttributes(\n+                                            file,\n+                                            BasicFileAttributes.class,\n+                                            LinkOption.NOFOLLOW_LINKS);\n@@ -593,1 +441,3 @@\n-                                    attrs.isDirectory(), attrs.lastModifiedTime().toMillis(), 0);\n+                                    attrs.isDirectory(),\n+                                    attrs.lastModifiedTime().toMillis(),\n+                                    0);\n@@ -604,12 +454,1 @@\n-            void forEachDirectory(final Consumer<Path> consumer) {\n-                files.forEach((path, entry) -> { if (entry.isDirectory) consumer.accept(directory.resolve(path)); } );\n-            }\n-\n-            void forEachFile(final Consumer<Path> consumer) {\n-                files.forEach((path, entry) -> { if (!entry.isDirectory) consumer.accept(directory.resolve(path)); } );\n-            }\n-\n-            void update(final MacOSXWatchKey watchKey,\n-                        final Queue<Path> createdDirs,\n-                        final Queue<Path> deletedDirs,\n-                        final Queue<Path> modifiedDirs) {\n+            void update(final MacOSXWatchKey watchKey) {\n@@ -619,1 +458,3 @@\n-                             = Files.newDirectoryStream(watchKey.getRealRootPath().resolve(directory))) {\n+                             = theFSProvider.newDirectoryStream(\n+                                     watchKey.getRealRootPath().resolve(relativeRootPath),\n+                                     p -> true)) {\n@@ -623,1 +464,4 @@\n-                                    = Files.readAttributes(file, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+                                    = theFSProvider.readAttributes(\n+                                            file,\n+                                            BasicFileAttributes.class,\n+                                            LinkOption.NOFOLLOW_LINKS);\n@@ -628,1 +472,1 @@\n-                            final Path relativePath = directory.resolve(fileName);\n+                            final Path relativePath = relativeRootPath.resolve(fileName);\n@@ -632,2 +476,3 @@\n-                                    files.put(fileName, new Entry(true, lastModified, currentTick));\n-                                    if (createdDirs != null) createdDirs.offer(relativePath);\n+                                    files.put(fileName,\n+                                            new Entry(true, lastModified, currentTick));\n+                                    watchKey.reportCreated(relativePath);\n@@ -636,3 +481,3 @@\n-                                        if (createdDirs != null) createdDirs.offer(relativePath);\n-\n-                                        files.put(fileName, new Entry(true, lastModified, currentTick));\n+                                        watchKey.reportCreated(relativePath);\n+                                        files.put(fileName,\n+                                                new Entry(true, lastModified, currentTick));\n@@ -641,1 +486,0 @@\n-                                        if (modifiedDirs != null) modifiedDirs.offer(relativePath);\n@@ -648,1 +492,2 @@\n-                                    files.put(fileName, new Entry(false, lastModified, currentTick));\n+                                    files.put(fileName,\n+                                            new Entry(false, lastModified, currentTick));\n@@ -652,4 +497,4 @@\n-                                        if (deletedDirs != null) deletedDirs.offer(relativePath);\n-\n-                                        files.put(fileName, new Entry(false, lastModified, currentTick));\n-                                        watchKey.reportCreated(directory.resolve(fileName));\n+                                        watchKey.reportDeleted(relativePath);\n+                                        files.put(fileName,\n+                                                new Entry(false, lastModified, currentTick));\n+                                        watchKey.reportCreated(relativeRootPath.resolve(fileName));\n@@ -670,1 +515,1 @@\n-                checkDeleted(watchKey, deletedDirs);\n+                checkDeleted(watchKey);\n@@ -673,1 +518,1 @@\n-            private void checkDeleted(final MacOSXWatchKey watchKey, final Queue<Path> deletedDirs) {\n+            private void checkDeleted(final MacOSXWatchKey watchKey) {\n@@ -681,6 +526,1 @@\n-\n-                        if (entry.isDirectory) {\n-                            if (deletedDirs != null) deletedDirs.offer(directory.resolve(file));\n-                        } else {\n-                            watchKey.reportDeleted(directory.resolve(file));\n-                        }\n+                        watchKey.reportDeleted(relativeRootPath.resolve(file));\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXWatchService.java","additions":101,"deletions":261,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -32,2 +32,4 @@\n-static jmethodID        callbackMID;  \/\/ MacOSXWatchService.callback()\n-static __thread jobject watchService; \/\/ The instance of MacOSXWatchService that is associated with this thread\n+\/\/ MacOSXWatchService.callback()\n+static jmethodID        callbackMID;\n+\/\/ The instance of MacOSXWatchService that is associated with this thread\n+static __thread jobject watchService;\n@@ -38,1 +40,2 @@\n-    callbackMID = (*env)->GetMethodID(env, clazz, \"callback\", \"(J[Ljava\/lang\/String;J)V\");\n+    callbackMID = (*env)->GetMethodID(env, clazz,\n+                                      \"callback\", \"(J[Ljava\/lang\/String;J)V\");\n@@ -45,2 +48,4 @@\n-convertToJavaStringArray(JNIEnv* env, char **eventPaths,\n-                         const jsize numEventsToReport, jobjectArray javaEventPathsArray)\n+convertToJavaStringArray(JNIEnv* env,\n+                         char **eventPaths,\n+                         const jsize numEventsToReport,\n+                         jobjectArray javaEventPathsArray)\n@@ -58,1 +63,4 @@\n-callJavaCallback(JNIEnv* env, jlong streamRef, jobjectArray javaEventPathsArray, jlong eventFlags)\n+callJavaCallback(JNIEnv* env,\n+                 jlong streamRef,\n+                 jobjectArray javaEventPathsArray,\n+                 jlong eventFlags)\n@@ -61,3 +69,4 @@\n-        \/\/ We are called on the run loop thread, so it's OK to use the thread-local reference\n-        \/\/ to the watch service.\n-        (*env)->CallVoidMethod(env, watchService, callbackMID, streamRef, javaEventPathsArray, eventFlags);\n+        \/\/ We are called on the run loop thread, so it's OK to use\n+        \/\/ the thread-local reference to the watch service.\n+        (*env)->CallVoidMethod(env, watchService, callbackMID,\n+                               streamRef, javaEventPathsArray, eventFlags);\n@@ -68,1 +77,2 @@\n- * Callback that is invoked on the run loop thread and informs of new file-system events from an FSEventStream.\n+ * Callback that is invoked on the run loop thread and informs of new\n+ * file-system events from an FSEventStream.\n@@ -94,1 +104,2 @@\n-        const jboolean localFramePushed = ((*env)->PushLocalFrame(env, numEventsToReport + 5) == JNI_OK);\n+        const jboolean localFramePushed\n+            = ((*env)->PushLocalFrame(env, numEventsToReport + 5) == JNI_OK);\n@@ -99,1 +110,4 @@\n-            javaEventPathsArray = (*env)->NewObjectArray(env, (jsize)numEventsToReport, JNU_ClassString(env), NULL);\n+            javaEventPathsArray = (*env)->NewObjectArray(env,\n+                                                         (jsize)numEventsToReport,\n+                                                         JNU_ClassString(env),\n+                                                         NULL);\n@@ -104,2 +118,4 @@\n-            success = convertToJavaStringArray(env, &((char**)eventPaths)[eventIndex],\n-                                               numEventsToReport, javaEventPathsArray);\n+            success = convertToJavaStringArray(env,\n+                                               &((char**)eventPaths)[eventIndex],\n+                                               numEventsToReport,\n+                                               javaEventPathsArray);\n@@ -108,1 +124,4 @@\n-        callJavaCallback(env, (jlong)streamRef, javaEventPathsArray, (jlong)&eventFlags[eventIndex]);\n+        callJavaCallback(env,\n+                         ptr_to_jlong(streamRef),\n+                         javaEventPathsArray,\n+                         ptr_to_jlong(&eventFlags[eventIndex]));\n@@ -126,2 +145,5 @@\n-Java_sun_nio_fs_MacOSXWatchService_eventStreamCreate(JNIEnv* env, __unused jclass clazz,\n-                                                     jstring dir, jdouble latencyInSeconds, jint flags)\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamCreate(JNIEnv* env,\n+                                                     __unused jclass clazz,\n+                                                     jstring dir,\n+                                                     jdouble latencyInSeconds,\n+                                                     jint flags)\n@@ -131,1 +153,2 @@\n-    const CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **) &path, 1, NULL);\n+    const CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **) &path,\n+                                                  1, NULL);\n@@ -143,1 +166,1 @@\n-    return (jlong)stream;\n+    return ptr_to_jlong(stream);\n@@ -152,2 +175,4 @@\n-Java_sun_nio_fs_MacOSXWatchService_eventStreamSchedule(__unused JNIEnv* env,  __unused jclass clazz,\n-                                                     jlong eventStreamRef, jlong runLoopRef)\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamSchedule(__unused JNIEnv* env,\n+                                                       __unused jclass clazz,\n+                                                       jlong eventStreamRef,\n+                                                       jlong runLoopRef)\n@@ -155,2 +180,2 @@\n-    const FSEventStreamRef stream  = (FSEventStreamRef)eventStreamRef;\n-    const CFRunLoopRef     runLoop = (CFRunLoopRef)runLoopRef;\n+    const FSEventStreamRef stream  = jlong_to_ptr(eventStreamRef);\n+    const CFRunLoopRef     runLoop = jlong_to_ptr(runLoopRef);\n@@ -167,1 +192,3 @@\n-Java_sun_nio_fs_MacOSXWatchService_eventStreamStop(__unused JNIEnv* env, __unused jclass clazz, jlong eventStreamRef)\n+Java_sun_nio_fs_MacOSXWatchService_eventStreamStop(__unused JNIEnv* env,\n+                                                   __unused jclass clazz,\n+                                                   jlong eventStreamRef)\n@@ -169,1 +196,1 @@\n-    const FSEventStreamRef streamRef = (FSEventStreamRef)eventStreamRef;\n+    const FSEventStreamRef streamRef = jlong_to_ptr(eventStreamRef);\n@@ -171,3 +198,4 @@\n-    FSEventStreamStop(streamRef);       \/\/ Unregister with the FS Events service. No more callbacks from this stream\n-    FSEventStreamInvalidate(streamRef); \/\/ De-schedule from any runloops\n-    FSEventStreamRelease(streamRef);    \/\/ Decrement the stream's refcount\n+    FSEventStreamStop(streamRef);       \/\/ Unregister with the FS Events service.\n+                                        \/\/ No more callbacks from this stream.\n+    FSEventStreamInvalidate(streamRef); \/\/ De-schedule from any runloops.\n+    FSEventStreamRelease(streamRef);    \/\/ Decrement the stream's refcount.\n@@ -180,1 +208,2 @@\n-Java_sun_nio_fs_MacOSXWatchService_CFRunLoopGetCurrent(__unused JNIEnv* env, __unused jclass clazz)\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopGetCurrent(__unused JNIEnv* env,\n+                                                       __unused jclass clazz)\n@@ -182,1 +211,1 @@\n-    return (jlong)CFRunLoopGetCurrent();\n+    return ptr_to_jlong(CFRunLoopGetCurrent());\n@@ -186,2 +215,2 @@\n- * Simply calls CFRunLoopRun() to run current thread's run loop for as long as there are event sources\n- * attached to it.\n+ * Simply calls CFRunLoopRun() to run current thread's run loop for as long as\n+ * there are event sources attached to it.\n@@ -190,1 +219,3 @@\n-Java_sun_nio_fs_MacOSXWatchService_CFRunLoopRun(__unused JNIEnv* env, __unused jclass clazz, jlong watchServiceObject)\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopRun(__unused JNIEnv* env,\n+                                                __unused jclass clazz,\n+                                                jlong watchServiceObject)\n@@ -194,1 +225,1 @@\n-    watchService = (*env)->NewGlobalRef(env, (jobject)watchServiceObject);\n+    watchService = (*env)->NewGlobalRef(env, jlong_to_ptr(watchServiceObject));\n@@ -196,1 +227,1 @@\n-    (*env)->DeleteGlobalRef(env, (jobject)watchService);\n+    (*env)->DeleteGlobalRef(env, watchService);\n@@ -201,1 +232,3 @@\n-Java_sun_nio_fs_MacOSXWatchService_CFRunLoopStop(__unused JNIEnv* env, __unused jclass clazz, jlong runLoopRef)\n+Java_sun_nio_fs_MacOSXWatchService_CFRunLoopStop(__unused JNIEnv* env,\n+                                                 __unused jclass clazz,\n+                                                 jlong runLoopRef)\n@@ -203,1 +236,1 @@\n-    CFRunLoopStop((CFRunLoopRef)runLoopRef);\n+    CFRunLoopStop(jlong_to_ptr(runLoopRef));\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/MacOSXWatchService.c","additions":70,"deletions":37,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -109,5 +109,0 @@\n-            final WatchKey subtreeKey = dir.resolve(dir.resolve(\"root\")).register(subtreeWatcher,\n-                    new WatchEvent.Kind<?>[]{ ENTRY_CREATE, ENTRY_DELETE },  ExtendedWatchEventModifier.FILE_TREE);\n-\n-            if (rootKey == subtreeKey)\n-                throw new RuntimeException(\"keys should be different\");\n@@ -126,16 +121,0 @@\n-            \/\/ Check that the moved subtree has become a series of DELETE\/CREATE events\n-            {\n-                takeExpectedKey(subtreeWatcher, subtreeKey);\n-                final List<WatchEvent<?>> events = subtreeKey.pollEvents();\n-                dumpEvents(events);\n-\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\").resolve(\"file3\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\").resolve(\"3\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"1\").resolve(\"2\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\"), ENTRY_CREATE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\"), ENTRY_CREATE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\").resolve(\"file3\"), ENTRY_CREATE);\n-                if (events.size() > 6) {\n-                    throw new RuntimeException(\"Too many events\");\n-                }\n-            }\n@@ -143,1 +122,0 @@\n-            subtreeKey.reset();\n@@ -160,16 +138,0 @@\n-            \/\/ Check the recursive root directory watcher\n-            {\n-                takeExpectedKey(subtreeWatcher, subtreeKey);\n-                final List<WatchEvent<?>> events = subtreeKey.pollEvents();\n-                dumpEvents(events);\n-\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\").resolve(\"file3\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\").resolve(\"3\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"subdir\").resolve(\"2.moved\"), ENTRY_DELETE);\n-                assertHasEvent(events, Path.of(\"2\"), ENTRY_CREATE);\n-                assertHasEvent(events, Path.of(\"2\").resolve(\"3\"), ENTRY_CREATE);\n-                assertHasEvent(events, Path.of(\"2\").resolve(\"3\").resolve(\"file3\"), ENTRY_CREATE);\n-                if (events.size() > 6) {\n-                    throw new RuntimeException(\"Too many events\");\n-                }\n-            }\n@@ -178,1 +140,0 @@\n-            subtreeWatcher.close();\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/Move.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"}]}