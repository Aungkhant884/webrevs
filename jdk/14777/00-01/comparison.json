{"files":[{"patch":"@@ -162,36 +162,0 @@\n-static void check_error_reporting() {\n-  if (!VMError::is_error_reported()) {\n-    return;\n-  }\n-\n-  \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n-  \/\/ should abort JVM after creating an error log file. However in some\n-  \/\/ rare cases, the error handler itself might deadlock. Here periodically\n-  \/\/ check for error reporting timeouts, and if it happens, just proceed to\n-  \/\/ abort the VM.\n-\n-  \/\/ This code is in WatcherThread because WatcherThread wakes up\n-  \/\/ periodically so the fatal error handler doesn't need to do anything;\n-  \/\/ also because the WatcherThread is less likely to crash than other\n-  \/\/ threads.\n-\n-  for (;;) {\n-    \/\/ Note: we use naked sleep in this loop because we want to avoid using\n-    \/\/ any kind of VM infrastructure which may be broken at this point.\n-    if (VMError::check_timeout()) {\n-      \/\/ We hit error reporting timeout. Error reporting was interrupted and\n-      \/\/ will be wrapping things up now (closing files etc). Give it some more\n-      \/\/ time, then quit the VM.\n-      os::naked_short_sleep(200);\n-      \/\/ Print a message to stderr.\n-      fdStream err(defaultStream::output_fd());\n-      err.print_raw_cr(\"# [ timer expired, abort... ]\");\n-      \/\/ skip atexit\/vm_exit\/vm_abort hooks\n-      os::die();\n-    }\n-\n-    \/\/ Wait a bit, then recheck for timeout.\n-    os::naked_short_sleep(250);\n-  }\n-}\n-\n@@ -224,0 +188,5 @@\n+  if (!_run_all_tasks) {\n+    ml.wait(100);\n+    return 0;\n+  }\n+\n@@ -274,14 +243,0 @@\n-  while (true) {\n-    \/\/ Just check for error reporting hangs until either VM is fully\n-    \/\/ initialized or we are notified to stop running.\n-    check_error_reporting();\n-    MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n-    if (_should_terminate || _run_all_tasks) break;\n-    ml.wait(100);\n-  }\n-\n-  if (_should_terminate) {\n-    notify_exit();\n-    return;\n-  }\n-\n@@ -296,1 +251,31 @@\n-    check_error_reporting();\n+    if (VMError::is_error_reported()) {\n+      \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n+      \/\/ should abort JVM after creating an error log file. However in some\n+      \/\/ rare cases, the error handler itself might deadlock. Here periodically\n+      \/\/ check for error reporting timeouts, and if it happens, just proceed to\n+      \/\/ abort the VM.\n+\n+      \/\/ This code is in WatcherThread because WatcherThread wakes up\n+      \/\/ periodically so the fatal error handler doesn't need to do anything;\n+      \/\/ also because the WatcherThread is less likely to crash than other\n+      \/\/ threads.\n+\n+      for (;;) {\n+        \/\/ Note: we use naked sleep in this loop because we want to avoid using\n+        \/\/ any kind of VM infrastructure which may be broken at this point.\n+        if (VMError::check_timeout()) {\n+          \/\/ We hit error reporting timeout. Error reporting was interrupted and\n+          \/\/ will be wrapping things up now (closing files etc). Give it some more\n+          \/\/ time, then quit the VM.\n+          os::naked_short_sleep(200);\n+          \/\/ Print a message to stderr.\n+          fdStream err(defaultStream::output_fd());\n+          err.print_raw_cr(\"# [ timer expired, abort... ]\");\n+          \/\/ skip atexit\/vm_exit\/vm_abort hooks\n+          os::die();\n+        }\n+\n+        \/\/ Wait a bit, then recheck for timeout.\n+        os::naked_short_sleep(250);\n+      }\n+    }\n@@ -299,2 +284,2 @@\n-      notify_exit();\n-      return;\n+      \/\/ check for termination before posting the next tick\n+      break;\n@@ -303,1 +288,12 @@\n-    PeriodicTask::real_time_tick(time_waited);\n+    \/\/ Don't process enrolled tasks until VM is fully initialized.\n+    if (_run_all_tasks) {\n+      PeriodicTask::real_time_tick(time_waited);\n+    }\n+  }\n+\n+  \/\/ Signal that it is terminated\n+  {\n+    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+    LSAN_IGNORE_OBJECT(_watcher_thread);\n+    _watcher_thread = nullptr;\n+    Terminator_lock->notify_all();\n@@ -342,7 +338,0 @@\n-void WatcherThread::notify_exit() {\n-  MonitorLocker ml(Terminator_lock, Mutex::_no_safepoint_check_flag);\n-  LSAN_IGNORE_OBJECT(_watcher_thread);\n-  _watcher_thread = nullptr;\n-  ml.notify_all();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":50,"deletions":61,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-  void notify_exit();\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}