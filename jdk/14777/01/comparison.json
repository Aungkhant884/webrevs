{"files":[{"patch":"@@ -474,3 +474,1 @@\n-  if (PeriodicTask::num_tasks() > 0) {\n-    WatcherThread::stop();\n-  }\n+  WatcherThread::stop();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-bool WatcherThread::_startable = false;\n+bool WatcherThread::_run_all_tasks = false;\n@@ -188,0 +188,5 @@\n+  if (!_run_all_tasks) {\n+    ml.wait(100);\n+    return 0;\n+  }\n+\n@@ -283,1 +288,4 @@\n-    PeriodicTask::real_time_tick(time_waited);\n+    \/\/ Don't process enrolled tasks until VM is fully initialized.\n+    if (_run_all_tasks) {\n+      PeriodicTask::real_time_tick(time_waited);\n+    }\n@@ -296,7 +304,4 @@\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-\n-  if (watcher_thread() == nullptr && _startable) {\n-    _should_terminate = false;\n-    \/\/ Create the single instance of WatcherThread\n-    new WatcherThread();\n-  }\n+  MonitorLocker ml(PeriodicTask_lock);\n+  _should_terminate = false;\n+  \/\/ Create the single instance of WatcherThread\n+  new WatcherThread();\n@@ -305,3 +310,4 @@\n-void WatcherThread::make_startable() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  _startable = true;\n+void WatcherThread::run_all_tasks() {\n+  MonitorLocker ml(PeriodicTask_lock);\n+  _run_all_tasks = true;\n+  ml.notify();\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  static bool _startable;\n+  static bool _run_all_tasks;\n@@ -140,3 +140,3 @@\n-  \/\/ Only allow start once the VM is sufficiently initialized\n-  \/\/ Otherwise the first task to enroll will trigger the start\n-  static void make_startable();\n+  \/\/ Allow executing registered tasks once the VM is sufficiently\n+  \/\/ initialized. Meanwhile only error reporting will be checked.\n+  static void run_all_tasks();\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -98,0 +99,1 @@\n+  assert(thread != nullptr || !Threads::is_vm_complete(), \"vm created but no WatcherThread\");\n@@ -100,2 +102,0 @@\n-  } else {\n-    WatcherThread::start();\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -556,0 +556,4 @@\n+  \/\/ Create WatcherThread as soon as we can since we need it in case\n+  \/\/ of hangs during error reporting.\n+  WatcherThread::start();\n+\n@@ -795,13 +799,5 @@\n-  {\n-    MutexLocker ml(PeriodicTask_lock);\n-    \/\/ Make sure the WatcherThread can be started by WatcherThread::start()\n-    \/\/ or by dynamic enrollment.\n-    WatcherThread::make_startable();\n-    \/\/ Start up the WatcherThread if there are any periodic tasks\n-    \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n-    \/\/   aren't, late joiners might appear to start slowly (we might\n-    \/\/   take a while to process their first tick).\n-    if (PeriodicTask::num_tasks() > 0) {\n-      WatcherThread::start();\n-    }\n-  }\n+  \/\/ Let WatcherThread run all registered periodic tasks now.\n+  \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n+  \/\/   aren't, late joiners might appear to start slowly (we might\n+  \/\/   take a while to process their first tick).\n+  WatcherThread::run_all_tasks();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"}]}