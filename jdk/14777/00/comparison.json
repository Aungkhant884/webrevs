{"files":[{"patch":"@@ -474,3 +474,1 @@\n-  if (PeriodicTask::num_tasks() > 0) {\n-    WatcherThread::stop();\n-  }\n+  WatcherThread::stop();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-bool WatcherThread::_startable = false;\n+bool WatcherThread::_run_all_tasks = false;\n@@ -162,0 +162,36 @@\n+static void check_error_reporting() {\n+  if (!VMError::is_error_reported()) {\n+    return;\n+  }\n+\n+  \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n+  \/\/ should abort JVM after creating an error log file. However in some\n+  \/\/ rare cases, the error handler itself might deadlock. Here periodically\n+  \/\/ check for error reporting timeouts, and if it happens, just proceed to\n+  \/\/ abort the VM.\n+\n+  \/\/ This code is in WatcherThread because WatcherThread wakes up\n+  \/\/ periodically so the fatal error handler doesn't need to do anything;\n+  \/\/ also because the WatcherThread is less likely to crash than other\n+  \/\/ threads.\n+\n+  for (;;) {\n+    \/\/ Note: we use naked sleep in this loop because we want to avoid using\n+    \/\/ any kind of VM infrastructure which may be broken at this point.\n+    if (VMError::check_timeout()) {\n+      \/\/ We hit error reporting timeout. Error reporting was interrupted and\n+      \/\/ will be wrapping things up now (closing files etc). Give it some more\n+      \/\/ time, then quit the VM.\n+      os::naked_short_sleep(200);\n+      \/\/ Print a message to stderr.\n+      fdStream err(defaultStream::output_fd());\n+      err.print_raw_cr(\"# [ timer expired, abort... ]\");\n+      \/\/ skip atexit\/vm_exit\/vm_abort hooks\n+      os::die();\n+    }\n+\n+    \/\/ Wait a bit, then recheck for timeout.\n+    os::naked_short_sleep(250);\n+  }\n+}\n+\n@@ -238,0 +274,14 @@\n+  while (true) {\n+    \/\/ Just check for error reporting hangs until either VM is fully\n+    \/\/ initialized or we are notified to stop running.\n+    check_error_reporting();\n+    MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n+    if (_should_terminate || _run_all_tasks) break;\n+    ml.wait(100);\n+  }\n+\n+  if (_should_terminate) {\n+    notify_exit();\n+    return;\n+  }\n+\n@@ -246,31 +296,1 @@\n-    if (VMError::is_error_reported()) {\n-      \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n-      \/\/ should abort JVM after creating an error log file. However in some\n-      \/\/ rare cases, the error handler itself might deadlock. Here periodically\n-      \/\/ check for error reporting timeouts, and if it happens, just proceed to\n-      \/\/ abort the VM.\n-\n-      \/\/ This code is in WatcherThread because WatcherThread wakes up\n-      \/\/ periodically so the fatal error handler doesn't need to do anything;\n-      \/\/ also because the WatcherThread is less likely to crash than other\n-      \/\/ threads.\n-\n-      for (;;) {\n-        \/\/ Note: we use naked sleep in this loop because we want to avoid using\n-        \/\/ any kind of VM infrastructure which may be broken at this point.\n-        if (VMError::check_timeout()) {\n-          \/\/ We hit error reporting timeout. Error reporting was interrupted and\n-          \/\/ will be wrapping things up now (closing files etc). Give it some more\n-          \/\/ time, then quit the VM.\n-          os::naked_short_sleep(200);\n-          \/\/ Print a message to stderr.\n-          fdStream err(defaultStream::output_fd());\n-          err.print_raw_cr(\"# [ timer expired, abort... ]\");\n-          \/\/ skip atexit\/vm_exit\/vm_abort hooks\n-          os::die();\n-        }\n-\n-        \/\/ Wait a bit, then recheck for timeout.\n-        os::naked_short_sleep(250);\n-      }\n-    }\n+    check_error_reporting();\n@@ -279,2 +299,2 @@\n-      \/\/ check for termination before posting the next tick\n-      break;\n+      notify_exit();\n+      return;\n@@ -285,8 +305,0 @@\n-\n-  \/\/ Signal that it is terminated\n-  {\n-    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n-    LSAN_IGNORE_OBJECT(_watcher_thread);\n-    _watcher_thread = nullptr;\n-    Terminator_lock->notify_all();\n-  }\n@@ -296,7 +308,4 @@\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-\n-  if (watcher_thread() == nullptr && _startable) {\n-    _should_terminate = false;\n-    \/\/ Create the single instance of WatcherThread\n-    new WatcherThread();\n-  }\n+  MonitorLocker ml(PeriodicTask_lock);\n+  _should_terminate = false;\n+  \/\/ Create the single instance of WatcherThread\n+  new WatcherThread();\n@@ -305,3 +314,4 @@\n-void WatcherThread::make_startable() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  _startable = true;\n+void WatcherThread::run_all_tasks() {\n+  MonitorLocker ml(PeriodicTask_lock);\n+  _run_all_tasks = true;\n+  ml.notify();\n@@ -332,0 +342,7 @@\n+void WatcherThread::notify_exit() {\n+  MonitorLocker ml(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+  LSAN_IGNORE_OBJECT(_watcher_thread);\n+  _watcher_thread = nullptr;\n+  ml.notify_all();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":69,"deletions":52,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  static bool _startable;\n+  static bool _run_all_tasks;\n@@ -140,3 +140,3 @@\n-  \/\/ Only allow start once the VM is sufficiently initialized\n-  \/\/ Otherwise the first task to enroll will trigger the start\n-  static void make_startable();\n+  \/\/ Allow executing registered tasks once the VM is sufficiently\n+  \/\/ initialized. Meanwhile only error reporting will be checked.\n+  static void run_all_tasks();\n@@ -144,0 +144,1 @@\n+  void notify_exit();\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -98,0 +99,1 @@\n+  assert(thread != nullptr || !Threads::is_vm_complete(), \"vm created but no WatcherThread\");\n@@ -100,2 +102,0 @@\n-  } else {\n-    WatcherThread::start();\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -556,0 +556,4 @@\n+  \/\/ Create WatcherThread as soon as we can since we need it in case\n+  \/\/ of hangs during error reporting.\n+  WatcherThread::start();\n+\n@@ -795,13 +799,5 @@\n-  {\n-    MutexLocker ml(PeriodicTask_lock);\n-    \/\/ Make sure the WatcherThread can be started by WatcherThread::start()\n-    \/\/ or by dynamic enrollment.\n-    WatcherThread::make_startable();\n-    \/\/ Start up the WatcherThread if there are any periodic tasks\n-    \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n-    \/\/   aren't, late joiners might appear to start slowly (we might\n-    \/\/   take a while to process their first tick).\n-    if (PeriodicTask::num_tasks() > 0) {\n-      WatcherThread::start();\n-    }\n-  }\n+  \/\/ Let WatcherThread run all registered periodic tasks now.\n+  \/\/ NOTE:  All PeriodicTasks should be registered by now. If they\n+  \/\/   aren't, late joiners might appear to start slowly (we might\n+  \/\/   take a while to process their first tick).\n+  WatcherThread::run_all_tasks();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"}]}