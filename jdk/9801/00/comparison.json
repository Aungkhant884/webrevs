{"files":[{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"services\/mallocHeader.inline.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocSiteTable.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+  assert(bad_address >= (address)this, \"sanity\");\n+\n+  \/\/ This function prints block information, including hex dump, in case of a detected\n+  \/\/ corruption. The hex dump should show both block header and corruption site\n+  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n+  \/\/\n+  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n+  \/\/ memory (it uses SafeFetch).\n+\n+  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n+               p2i(this), p2i(bad_address));\n+  static const size_t min_dump_length = 256;\n+  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to1 = from1 + min_dump_length;\n+  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to2 = from2 + min_dump_length;\n+  if (from2 > to1) {\n+    \/\/ Dump gets too large, split up in two sections.\n+    os::print_hex_dump(st, from1, to1, 1);\n+    st->print_cr(\"...\");\n+    os::print_hex_dump(st, from2, to2, 1);\n+  } else {\n+    \/\/ print one hex dump\n+    os::print_hex_dump(st, from1, to2, 1);\n+  }\n+}\n+\n+bool MallocHeader::get_stack(NativeCallStack& stack) const {\n+  return MallocSiteTable::access_stack(stack, _mst_marker);\n+}\n","filename":"src\/hotspot\/share\/services\/mallocHeader.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCHEADER_HPP\n+#define SHARE_SERVICES_MALLOCHEADER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+class outputStream;\n+\n+\/*\n+ * Malloc tracking header.\n+ *\n+ * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n+ * do this is by using malloc headers.\n+ *\n+ * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n+ *  footer canary:\n+ *\n+ * +--------------+-------------  ....  ------------------+-----+\n+ * |    header    |               user                    | can |\n+ * |              |             allocation                | ary |\n+ * +--------------+-------------  ....  ------------------+-----+\n+ *     16 bytes              user size                      2 byte\n+ *\n+ * Alignment:\n+ *\n+ * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n+ * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n+ * 32-bit and 64-bit.\n+ *\n+ * Layout on 64-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |                            64-bit size                                |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Layout on 32-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |            alt. canary            |           32-bit size             |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Notes:\n+ * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n+ *   catch negative buffer overflows.\n+ * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n+ *   canary at the very start of the malloc header (generously sized 32 bits).\n+ * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n+ *   the bytes are stored individually.\n+ *\/\n+\n+class MallocHeader {\n+\n+  NOT_LP64(uint32_t _alt_canary);\n+  const size_t _size;\n+  const uint32_t _mst_marker;\n+  const uint8_t _flags;\n+  const uint8_t _unused;\n+  uint16_t _canary;\n+\n+  static const uint16_t _header_canary_life_mark = 0xE99E;\n+  static const uint16_t _header_canary_dead_mark = 0xD99D;\n+  static const uint16_t _footer_canary_life_mark = 0xE88E;\n+  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n+  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n+\n+  \/\/ We discount sizes larger than these\n+  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n+\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n+\n+  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n+\n+  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n+  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n+  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n+\n+ public:\n+\n+  inline MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker);\n+\n+  inline size_t   size()  const { return _size; }\n+  inline MEMFLAGS flags() const { return (MEMFLAGS)_flags; }\n+  inline uint32_t mst_marker() const { return _mst_marker; }\n+  bool get_stack(NativeCallStack& stack) const;\n+\n+  inline void mark_block_as_dead();\n+\n+  \/\/ If block is broken, fill in a short descriptive text in out,\n+  \/\/ an option pointer to the corruption in p_corruption, and return false.\n+  \/\/ Return true if block is fine.\n+  inline bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n+\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  inline void assert_block_integrity() const;\n+};\n+\n+\/\/ This needs to be true on both 64-bit and 32-bit platforms\n+STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n+\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCHEADER_HPP\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n+#define SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n+\n+#include \"services\/mallocHeader.hpp\"\n+\n+#include \"jvm_io.h\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+\n+inline MallocHeader::MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n+  : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n+    _unused(0), _canary(_header_canary_life_mark)\n+{\n+  assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n+  \/\/ On 32-bit we have some bits more, use them for a second canary\n+  \/\/ guarding the start of the header.\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+  set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n+}\n+\n+inline void MallocHeader::mark_block_as_dead() {\n+  _canary = _header_canary_dead_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_footer(_footer_canary_dead_mark);\n+}\n+\n+inline void MallocHeader::assert_block_integrity() const {\n+  char msg[256];\n+  address corruption = NULL;\n+  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n+    if (corruption != NULL) {\n+      print_block_on_error(tty, (address)this);\n+    }\n+    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n+  }\n+}\n+\n+inline bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n+  \/\/ Note: if you modify the error messages here, make sure you\n+  \/\/ adapt the associated gtests too.\n+\n+  \/\/ Weed out obviously wrong block addresses of NULL or very low\n+  \/\/ values. Note that we should not call this for ::free(NULL),\n+  \/\/ which should be handled by os::free() above us.\n+  if (((size_t)p2i(this)) < K) {\n+    jio_snprintf(msg, msglen, \"invalid block address\");\n+    return false;\n+  }\n+\n+  \/\/ From here on we assume the block pointer to be valid. We could\n+  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/ wrong, we will crash when accessing the canary, which hopefully\n+  \/\/ generates distinct crash report.\n+\n+  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n+  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n+  \/\/ specified by the standard by this requirement:\n+  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n+  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n+  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n+  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n+  \/\/ we test the smallest alignment we know.\n+  \/\/ Should we ever start using std::max_align_t, this would be one place to\n+  \/\/ fix up.\n+  if (!is_aligned(this, sizeof(uint64_t))) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"block address is unaligned\");\n+    return false;\n+  }\n+\n+  \/\/ Check header canary\n+  if (_canary != _header_canary_life_mark) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n+  }\n+\n+#ifndef _LP64\n+  \/\/ On 32-bit we have a second canary, check that one too.\n+  if (_alt_canary != _header_alt_canary_life_mark) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n+  }\n+#endif\n+\n+  \/\/ Does block size seems reasonable?\n+  if (_size >= max_reasonable_malloc_size) {\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n+    return false;\n+  }\n+\n+  \/\/ Check footer canary\n+  if (get_footer() != _footer_canary_life_mark) {\n+    *p_corruption = footer_address();\n+    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+                p2i(footer_address()));\n+    return false;\n+  }\n+  return true;\n+}\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCHEADER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -104,1 +105,0 @@\n-\n@@ -111,114 +111,0 @@\n-void MallocHeader::mark_block_as_dead() {\n-  _canary = _header_canary_dead_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n-  set_footer(_footer_canary_dead_mark);\n-}\n-\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n-  assert(bad_address >= (address)this, \"sanity\");\n-\n-  \/\/ This function prints block information, including hex dump, in case of a detected\n-  \/\/ corruption. The hex dump should show both block header and corruption site\n-  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n-  \/\/\n-  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n-  \/\/ memory (it uses SafeFetch).\n-\n-  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n-               p2i(this), p2i(bad_address));\n-  static const size_t min_dump_length = 256;\n-  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n-  address to1 = from1 + min_dump_length;\n-  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n-  address to2 = from2 + min_dump_length;\n-  if (from2 > to1) {\n-    \/\/ Dump gets too large, split up in two sections.\n-    os::print_hex_dump(st, from1, to1, 1);\n-    st->print_cr(\"...\");\n-    os::print_hex_dump(st, from2, to2, 1);\n-  } else {\n-    \/\/ print one hex dump\n-    os::print_hex_dump(st, from1, to2, 1);\n-  }\n-}\n-void MallocHeader::assert_block_integrity() const {\n-  char msg[256];\n-  address corruption = NULL;\n-  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n-    if (corruption != NULL) {\n-      print_block_on_error(tty, (address)this);\n-    }\n-    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n-  }\n-}\n-\n-bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n-  \/\/ Note: if you modify the error messages here, make sure you\n-  \/\/ adapt the associated gtests too.\n-\n-  \/\/ Weed out obviously wrong block addresses of NULL or very low\n-  \/\/ values. Note that we should not call this for ::free(NULL),\n-  \/\/ which should be handled by os::free() above us.\n-  if (((size_t)p2i(this)) < K) {\n-    jio_snprintf(msg, msglen, \"invalid block address\");\n-    return false;\n-  }\n-\n-  \/\/ From here on we assume the block pointer to be valid. We could\n-  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n-  \/\/ wrong, we will crash when accessing the canary, which hopefully\n-  \/\/ generates distinct crash report.\n-\n-  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n-  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n-  \/\/ specified by the standard by this requirement:\n-  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n-  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n-  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n-  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n-  \/\/ we test the smallest alignment we know.\n-  \/\/ Should we ever start using std::max_align_t, this would be one place to\n-  \/\/ fix up.\n-  if (!is_aligned(this, sizeof(uint64_t))) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"block address is unaligned\");\n-    return false;\n-  }\n-\n-  \/\/ Check header canary\n-  if (_canary != _header_canary_life_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-\n-#ifndef _LP64\n-  \/\/ On 32-bit we have a second canary, check that one too.\n-  if (_alt_canary != _header_alt_canary_life_mark) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header canary broken\");\n-    return false;\n-  }\n-#endif\n-\n-  \/\/ Does block size seems reasonable?\n-  if (_size >= max_reasonable_malloc_size) {\n-    *p_corruption = (address)this;\n-    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n-    return false;\n-  }\n-\n-  \/\/ Check footer canary\n-  if (get_footer() != _footer_canary_life_mark) {\n-    *p_corruption = footer_address();\n-    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n-                p2i(footer_address()));\n-    return false;\n-  }\n-  return true;\n-}\n-\n-bool MallocHeader::get_stack(NativeCallStack& stack) const {\n-  return MallocSiteTable::access_stack(stack, _mst_marker);\n-}\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":1,"deletions":115,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"services\/mallocHeader.hpp\"\n@@ -239,116 +240,0 @@\n-\n-\/*\n- * Malloc tracking header.\n- *\n- * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n- * do this is by using malloc headers.\n- *\n- * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n- *  footer canary:\n- *\n- * +--------------+-------------  ....  ------------------+-----+\n- * |    header    |               user                    | can |\n- * |              |             allocation                | ary |\n- * +--------------+-------------  ....  ------------------+-----+\n- *     16 bytes              user size                      2 byte\n- *\n- * Alignment:\n- *\n- * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n- * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n- * 32-bit and 64-bit.\n- *\n- * Layout on 64-bit:\n- *\n- *     0        1        2        3        4        5        6        7\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- * |                            64-bit size                                |  ...\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- *\n- *           8        9        10       11       12       13       14       15          16 ++\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *\n- * Layout on 32-bit:\n- *\n- *     0        1        2        3        4        5        6        7\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- * |            alt. canary            |           32-bit size             |  ...\n- * +--------+--------+--------+--------+--------+--------+--------+--------+\n- *\n- *           8        9        10       11       12       13       14       15          16 ++\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n- *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n- *\n- * Notes:\n- * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n- *   catch negative buffer overflows.\n- * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n- *   canary at the very start of the malloc header (generously sized 32 bits).\n- * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n- *   the bytes are stored individually.\n- *\/\n-\n-class MallocHeader {\n-\n-  NOT_LP64(uint32_t _alt_canary);\n-  const size_t _size;\n-  const uint32_t _mst_marker;\n-  const uint8_t _flags;\n-  const uint8_t _unused;\n-  uint16_t _canary;\n-\n-  static const uint16_t _header_canary_life_mark = 0xE99E;\n-  static const uint16_t _header_canary_dead_mark = 0xD99D;\n-  static const uint16_t _footer_canary_life_mark = 0xE88E;\n-  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n-  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n-  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n-\n-  \/\/ We discount sizes larger than these\n-  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n-\n-  void print_block_on_error(outputStream* st, address bad_address) const;\n-\n-  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n-\n-  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n-  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n-  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n-\n- public:\n-\n-  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n-    : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n-      _unused(0), _canary(_header_canary_life_mark)\n-  {\n-    assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n-    \/\/ On 32-bit we have some bits more, use them for a second canary\n-    \/\/ guarding the start of the header.\n-    NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n-    set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n-  }\n-\n-  inline size_t   size()  const { return _size; }\n-  inline MEMFLAGS flags() const { return (MEMFLAGS)_flags; }\n-  inline uint32_t mst_marker() const { return _mst_marker; }\n-  bool get_stack(NativeCallStack& stack) const;\n-\n-  void mark_block_as_dead();\n-\n-  \/\/ If block is broken, fill in a short descriptive text in out,\n-  \/\/ an option pointer to the corruption in p_corruption, and return false.\n-  \/\/ Return true if block is fine.\n-  bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n-\n-  \/\/ If block is broken, print out a report to tty (optionally with\n-  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n-  void assert_block_integrity() const;\n-};\n-\n-\/\/ This needs to be true on both 64-bit and 32-bit platforms\n-STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n-\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":1,"deletions":116,"binary":false,"changes":117,"status":"modified"}]}