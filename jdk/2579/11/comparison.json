{"files":[{"patch":"@@ -80,0 +80,1 @@\n+  virtual size_t live()         const { return _space->used(); }\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1406,0 +1406,1 @@\n+  _live(0),\n@@ -1844,0 +1845,4 @@\n+size_t G1CollectedHeap::live() const {\n+  return Atomic::load(&_live);\n+}\n+\n@@ -4568,0 +4573,4 @@\n+void G1CollectedHeap::set_live(size_t bytes) {\n+  Atomic::store(&_live, bytes);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  friend class G1ConcurrentMark;\n@@ -181,0 +182,2 @@\n+  volatile size_t _live;\n+\n@@ -214,0 +217,1 @@\n+  void set_live(size_t bytes);\n@@ -1057,0 +1061,1 @@\n+  virtual size_t live() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -975,0 +975,1 @@\n+  size_t volatile _live;\n@@ -985,0 +986,1 @@\n+    size_t _live; \/\/ Cumulative live set size over iterated regions\n@@ -1057,1 +1059,1 @@\n-      _g1h(g1h), _cm(cm), _cl(cl), _num_regions_selected_for_rebuild(0) { }\n+      _g1h(g1h), _cm(cm), _cl(cl), _num_regions_selected_for_rebuild(0), _live(0) { }\n@@ -1063,0 +1065,1 @@\n+      _live += r->live_bytes();\n@@ -1067,0 +1070,1 @@\n+    size_t live_estimate() const { return _live; }\n@@ -1072,1 +1076,1 @@\n-    _g1h(g1h), _cm(cm), _hrclaimer(num_workers), _total_selected_for_rebuild(0), _cl(\"Post-Marking\") { }\n+    _g1h(g1h), _cm(cm), _hrclaimer(num_workers), _total_selected_for_rebuild(0), _live(0), _cl(\"Post-Marking\") { }\n@@ -1078,0 +1082,1 @@\n+    Atomic::add(&_live, update_cl.live_estimate());\n@@ -1081,0 +1086,1 @@\n+  size_t live_estimate() const { return _live; }\n@@ -1150,0 +1156,1 @@\n+      _g1h->set_live(cl.live_estimate());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -200,0 +200,4 @@\n+size_t ParallelScavengeHeap::live() const {\n+  return _live;\n+}\n+\n@@ -436,0 +440,1 @@\n+  update_live_estimate();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  size_t _live;\n+\n@@ -84,0 +86,3 @@\n+  \/\/ In order to provide accurate estimate this method must be called only when the heap has just been collected and compacted.\n+  inline void update_live_estimate();\n+\n@@ -86,0 +91,1 @@\n+  size_t live() const;\n@@ -104,1 +110,2 @@\n-             false \/* are_ConcurrentGC_threads *\/) { }\n+             false \/* are_ConcurrentGC_threads *\/),\n+    _live(0) { }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+  update_live_estimate();\n+}\n+\n+inline void ParallelScavengeHeap::update_live_estimate() {\n+  _live = young_gen()->used_in_bytes() + old_gen()->used_in_bytes();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -436,0 +436,5 @@\n+size_t DefNewGeneration::live() const {\n+  return eden()->live()\n+       + from()->live();      \/\/ to() is only used during scavenge\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  size_t live() const;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  size_t live() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+inline size_t CardGeneration::live() const {\n+  return space()->live();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,0 +219,6 @@\n+  \/\/ Returns the estimate of live set size. Because live set changes over time,\n+  \/\/ this is a best-effort estimate by each of the implementations. These usually\n+  \/\/ are most precise right after the GC cycle. If no GC cycle has happened yet\n+  \/\/ the reported value will be 0.\n+  virtual size_t live() const = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  _live(0),\n@@ -246,0 +247,4 @@\n+size_t GenCollectedHeap::live() const {\n+  return _live;\n+}\n+\n@@ -1257,0 +1262,3 @@\n+\n+  \/\/ update the live size after last GC\n+  _live = _young_gen->live() + _old_gen->live();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+  size_t _live;\n+\n@@ -178,0 +180,1 @@\n+  size_t live() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  virtual size_t live() const = 0;      \/\/ The estimate of live bytes in the gen.\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+  virtual size_t live() const = 0;\n@@ -447,0 +448,4 @@\n+  size_t    _live_estimate;\n+\n+  \/\/ Update the cached '_live_estimate' value to current usage decreased by the given dead space.\n+  inline void update_live_estimate(size_t dead_space);\n@@ -551,0 +556,1 @@\n+  size_t live() const            { return _live_estimate;             }\n@@ -553,0 +559,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -85,0 +85,3 @@\n+  friend class CompactibleSpace;\n+\n+  size_t _max_deadspace_words;\n@@ -90,1 +93,1 @@\n-  DeadSpacer(CompactibleSpace* space) : _allowed_deadspace_words(0), _space(space) {\n+  DeadSpacer(CompactibleSpace* space) : _max_deadspace_words(0), _allowed_deadspace_words(0), _space(space) {\n@@ -102,1 +105,2 @@\n-        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n+        _max_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n+        _allowed_deadspace_words = _max_deadspace_words;\n@@ -133,0 +137,5 @@\n+private:\n+  size_t get_dead_space() {\n+    return (_max_deadspace_words - _allowed_deadspace_words) * HeapWordSize;\n+  }\n+\n@@ -215,0 +224,3 @@\n+\n+  \/\/ Update the live size estimate using the known dead space size.\n+  space->update_live_estimate(dead_spacer.get_dead_space());\n@@ -348,0 +360,3 @@\n+\n+  \/\/ Update the live size estimate - this happens after compaction so there is no dead space to subtract.\n+  space->update_live_estimate(0);\n@@ -376,0 +391,4 @@\n+inline void CompactibleSpace::update_live_estimate(size_t dead_space) {\n+  _live_estimate = used() - dead_space;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+  size_t total_live = 0;\n+\n@@ -100,1 +102,4 @@\n-    size_t garbage = region->garbage();\n+    size_t live = region->get_live_data_bytes();\n+    size_t garbage = region->used() - live;\n+    assert(region->garbage() == garbage, \"Garbage calculation should agree\");\n+\n@@ -117,0 +122,3 @@\n+\n+        \/\/ This region has live data, add up to estimate.\n+        total_live += live;\n@@ -119,1 +127,0 @@\n-      \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n@@ -127,1 +134,5 @@\n-      if (!region->has_live()) {\n+      if (region->has_live()) {\n+        \/\/ Humongous region is live, count the entire chain as live.\n+        total_live += oop(region->bottom())->size() * HeapWordSize;\n+      } else {\n+        \/\/ Reclaim humongous regions here, and count them as the immediate garbage\n@@ -144,0 +155,3 @@\n+  \/\/ Update the live data estimate\n+  heap->set_live(total_live);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1060,0 +1060,1 @@\n+    heap->set_live(post_compact.get_live());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -627,0 +627,4 @@\n+size_t ShenandoahHeap::live() const {\n+  return Atomic::load(&_live);\n+}\n+\n@@ -649,0 +653,4 @@\n+void ShenandoahHeap::set_live(size_t bytes) {\n+  Atomic::store(&_live, bytes);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+  volatile size_t _live;\n@@ -186,0 +187,1 @@\n+  void set_live(size_t bytes);\n@@ -200,0 +202,1 @@\n+  size_t live()              const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,0 +111,4 @@\n+size_t ZCollectedHeap::live() const {\n+  return ZStatHeap::live_at_mark_end();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+protected:\n+  virtual size_t live() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1356,0 +1356,4 @@\n+size_t ZStatHeap::live_at_mark_end() {\n+  return _at_mark_end.live;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -549,0 +549,1 @@\n+  static size_t live_at_mark_end();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -201,0 +201,6 @@\n+  <Event name=\"HeapUsageSummary\" category=\"Java Virtual Machine, GC, Heap\" label=\"Heap Usage Summary\" startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"capacity\" label=\"Heap Capacity\" description=\"Maximum number of bytes to be allocated by objects in the heap\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"used\" label=\"Heap Used\" description=\"Bytes allocated by objects in the heap\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"live\" label=\"Heap Live\" description=\"Estimate of live bytes allocated by objects in the heap or '0' if that estimate is not avaialable\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -638,1 +638,0 @@\n-\n@@ -647,0 +646,9 @@\n+\n+TRACE_REQUEST_FUNC(HeapUsageSummary) {\n+  EventHeapUsageSummary event;\n+  CollectedHeap* heap = Universe::heap();\n+  event.set_capacity(heap->capacity());\n+  event.set_used(heap->used());\n+  event.set_live(heap->live());\n+  event.commit();\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -310,0 +310,5 @@\n+    <event name=\"jdk.HeapUsageSummary\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">everyChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -310,0 +310,5 @@\n+    <event name=\"jdk.HeapUsageSummary\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+      <setting name=\"period\">5 s<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,20 @@\n+    public static void testPeriodicUsage(boolean assertLiveSize) throws Exception {\n+        Recording recording = new Recording();\n+        recording.enable(EventNames.HeapUsageSummary);\n+\n+        recording.start();\n+        GCHelper.callSystemGc(1, true);\n+        recording.stop();\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Asserts.assertFalse(events.isEmpty(), \"Expected at least one event\");\n+        for (RecordedEvent event : events) {\n+            long minUsedSize = 1L;\n+            if (assertLiveSize) {\n+                \/\/ make sure that the estimated live set size is present\n+                minUsedSize = Events.assertField(event, \"live\").atLeast(1L).getValue();\n+            }\n+            \/\/ make sure the used value is valid - it must be at least as big as the reported live set size\n+            Events.assertField(event, \"used\").atLeast(minUsedSize);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/heapsummary\/HeapSummaryEventAllGcs.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        HeapSummaryEventAllGcs.testPeriodicUsage(true);\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/heapsummary\/TestHeapSummaryEventDefNewSerial.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+        HeapSummaryEventAllGcs.testPeriodicUsage(false); \/\/ do not validate the live set size as provoking G1 to compute it is not easy\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/heapsummary\/TestHeapSummaryEventG1.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        HeapSummaryEventAllGcs.testPeriodicUsage(true);\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/heapsummary\/TestHeapSummaryEventPSParOld.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    public final static String HeapUsageSummary = PREFIX + \"HeapUsageSummary\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}