{"files":[{"patch":"@@ -53,0 +53,5 @@\n+\/*\n+ * The test verifies that after interleaved RedefineClasses\/RetransformClasses calls\n+ * JVMTI passes correct class bytes to ClassFileLoadHook (as per JVMTI spec).\n+ * To distinguish class version the test instruments test class overriding runtime-visible annotation.\n+ *\/\n@@ -63,1 +68,1 @@\n-    \/\/ Use runtime-visible annotation to specify class version\n+    \/\/ Use runtime-visible annotation to specify class version.\n@@ -69,1 +74,2 @@\n-    \/\/ redefines testClass with classBytes, instrument with classLoadHookBytes (is != null)\n+    \/\/ Redefines testClass with classBytes, instruments with classLoadHookBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n@@ -71,1 +77,2 @@\n-    \/\/ retransforms testClass with classBytes (if != null)\n+    \/\/ Retransforms testClass, instruments with classBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n@@ -74,0 +81,1 @@\n+    \/\/ Class bytes for initial TestClass (ClassVersion == 0).\n@@ -120,0 +128,1 @@\n+    \/\/ Generates TestClass class bytes with the specified ClassVersion value.\n@@ -130,0 +139,1 @@\n+    \/\/ Extracts ClassVersion values from the provided class bytes.\n@@ -148,0 +158,1 @@\n+    \/\/ Redefines TestClass to the version specified.\n@@ -152,0 +163,3 @@\n+    \/\/ Redefines TestClass to the version specified\n+    \/\/ instrumenting (from ClassFileLoadHook) with 'classLoadHookVer' class bytes (if >= 0).\n+    \/\/ Also verifies that class bytes passed to ClassFileLoadHook have correct version (ver).\n@@ -168,0 +182,2 @@\n+    \/\/ Retransforms TestClass instrumenting (from ClassFileLoadHook) with 'ver' class bytes (if >= 0).\n+    \/\/ Verifies that class bytes passed to ClassFileLoadHook have correct version (expectedVer).\n@@ -189,3 +205,3 @@\n-                redefine(1);\n-                retransform(2, 1);\n-                retransform(3, 1);\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                retransform(3, 1);  \/\/ uses existing cache\n@@ -197,4 +213,4 @@\n-                redefine(1);\n-                retransform(2, 1);\n-                redefine(3);\n-                redefine(4);\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes\n+                redefine(4);        \/\/ cached class bytes are not set\n@@ -206,4 +222,4 @@\n-                redefine(1);\n-                retransform(2, 1);    \/\/ sets cached class bytes\n-                redefine(3);                    \/\/ resets cached class bytes\n-                retransform(4, 3);\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes\n+                retransform(4, 3);  \/\/ sets cached class bytes to ver 3\n@@ -215,4 +231,4 @@\n-                retransform(1, 0);    \/\/ sets cached class bytes\n-                redefine(2);                    \/\/ reset cached class bytes\n-                retransform(3, 2);    \/\/ sets cached class bytes\n-                retransform(4, 2);\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2);        \/\/ resets cached class bytes\n+                retransform(3, 2);  \/\/ sets cached class bytes to ver 2\n+                retransform(4, 2);  \/\/ uses existing cache\n@@ -224,4 +240,5 @@\n-                redefine(1, 5);    \/\/ sets cached class bytes\n-                retransform(2, 1);\n-                redefine(3, 6);    \/\/ updates cached class bytes\n-                retransform(4, 3);\n+                redefine(1, 5);     \/\/ CFLH sets cached class bytes to ver 1\n+                retransform(2, 1);  \/\/ uses existing cache\n+                redefine(3, 6);     \/\/ resets cached class bytes,\n+                                    \/\/ CFLH sets cached class bytes to ver 3\n+                retransform(4, 3);  \/\/ uses existing cache\n@@ -233,4 +250,5 @@\n-                retransform(1, 0);    \/\/ sets cached class bytes\n-                redefine(2, 5);    \/\/ updates cached class bytes\n-                retransform(3, 2);\n-                retransform(4, 2);\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2, 5);     \/\/ resets cached class bytes,\n+                                    \/\/ CFLH sets cached class bytes to ver 2\n+                retransform(3, 2);  \/\/ uses existing cache\n+                retransform(4, 2);  \/\/ uses existing cache\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":44,"deletions":26,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n@@ -34,7 +34,0 @@\n-\/\/ to redefine from ClassFileLoadHock callback\n-\/\/ set by caller:\n-static jbyteArray classLoadHookNewClassBytes = nullptr;\n-\/\/ set by ClassFileLoadHock callback:\n-static unsigned char* classLoadHookSavedClassBytes = nullptr;\n-static jint classLoadHookSavedClassBytesLen = 0;\n-\n@@ -55,13 +48,21 @@\n-JNIEXPORT void JNICALL\n-callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n-        JNIEnv* jni_env,\n-        jclass class_being_redefined,\n-        jobject loader,\n-        const char* name,\n-        jobject protection_domain,\n-        jint class_data_len,\n-        const unsigned char* class_data,\n-        jint* new_class_data_len,\n-        unsigned char** new_class_data) {\n-    if (isTestClass(name)) {\n-        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+class ClassFileLoadHookHelper {\n+    const char* mode;   \/\/ for logging only\n+    bool eventEnabled;\n+    JNIEnv* env;\n+    jbyteArray classBytes = nullptr;\n+\n+    unsigned char* savedClassBytes = nullptr;\n+    jint savedClassBytesLen = 0;\n+\n+    \/\/ single instance\n+    static ClassFileLoadHookHelper *instance;\n+public:\n+    ClassFileLoadHookHelper(const char* mode, JNIEnv* jni_env, jbyteArray hookClassBytes)\n+        : mode(mode), eventEnabled(false), env(jni_env), classBytes(nullptr),\n+        savedClassBytes(nullptr), savedClassBytesLen(0)\n+    {\n+        _log(\">>%s\\n\", mode);\n+        if (hookClassBytes != nullptr) {\n+            classBytes = (jbyteArray)env->NewGlobalRef(hookClassBytes);\n+        }\n+    }\n@@ -69,2 +70,15 @@\n-        \/\/ save class bytes\n-        jvmtiError err = jvmti->Allocate(class_data_len, &classLoadHookSavedClassBytes);\n+    ~ClassFileLoadHookHelper() {\n+        \/\/ cleanup on error\n+        stop();\n+        if (classBytes != nullptr) {\n+            env->DeleteGlobalRef(classBytes);\n+        }\n+        if (savedClassBytes != nullptr) {\n+            jvmti->Deallocate(savedClassBytes);\n+        }\n+        _log(\"<<%s\\n\", mode);\n+    }\n+\n+    bool start() {\n+        instance = this;\n+        jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n@@ -72,2 +86,3 @@\n-            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", class_data_len, err);\n-            return;\n+            _log(\"%s: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", mode, err);\n+            eventEnabled = true;\n+            return false;\n@@ -75,2 +90,2 @@\n-        memcpy(classLoadHookSavedClassBytes, class_data, class_data_len);\n-        classLoadHookSavedClassBytesLen = class_data_len;\n+        return true;\n+    }\n@@ -78,3 +93,20 @@\n-        \/\/ set new class bytes\n-        if (classLoadHookNewClassBytes != nullptr) {\n-            jsize len = jni_env->GetArrayLength(classLoadHookNewClassBytes);\n+    void stop() {\n+        instance = nullptr;\n+        if (eventEnabled) {\n+            jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"%s: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", mode, err);\n+                return;\n+            }\n+            eventEnabled = false;\n+        }\n+    }\n+\n+    \/\/ valid only between start() and stop()\n+    static ClassFileLoadHookHelper* getInstance() {\n+        return instance;\n+    }\n+\n+    bool getHookClassBytes(unsigned char** newClassBytes, jint* newLen) {\n+        if (classBytes != nullptr) {\n+            jsize len = env->GetArrayLength(classBytes);\n@@ -82,1 +114,1 @@\n-            err = jvmti->Allocate(len, &buf);\n+            jvmtiError err = jvmti->Allocate(len, &buf);\n@@ -85,1 +117,1 @@\n-                return;\n+                return false;\n@@ -88,1 +120,1 @@\n-            jbyte* arrayPtr = jni_env->GetByteArrayElements(classLoadHookNewClassBytes, nullptr);\n+            jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n@@ -92,1 +124,1 @@\n-                return;\n+                return false;\n@@ -97,1 +129,1 @@\n-            jni_env->ReleaseByteArrayElements(classLoadHookNewClassBytes, arrayPtr, JNI_ABORT);\n+            env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n@@ -99,2 +131,2 @@\n-            *new_class_data = buf;\n-            *new_class_data_len = len;\n+            *newClassBytes = buf;\n+            *newLen = len;\n@@ -104,0 +136,63 @@\n+        return true;\n+    }\n+\n+    void setSavedHookClassBytes(const unsigned char* bytes, jint len) {\n+        jvmtiError err = jvmti->Allocate(len, &savedClassBytes);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", len, err);\n+            return;\n+        }\n+        memcpy(savedClassBytes, bytes, len);\n+        savedClassBytesLen = len;\n+    }\n+\n+    jbyteArray getSavedHookClassBytes() {\n+        if (savedClassBytes == nullptr) {\n+            _log(\"%s: savedClassBytes is NULL\\n\", mode);\n+            return nullptr;\n+        }\n+\n+        jbyteArray result = env->NewByteArray(savedClassBytesLen);\n+        if (result == nullptr) {\n+            _log(\"%s: NewByteArray(%ld) failed\\n\", mode, savedClassBytesLen);\n+        } else {\n+            jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"%s: Failed to get array elements\\n\", mode);\n+                result = nullptr;\n+            } else {\n+                memcpy(arrayPtr, savedClassBytes, savedClassBytesLen);\n+                env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+            }\n+        }\n+        return result;\n+    }\n+};\n+\n+ClassFileLoadHookHelper* ClassFileLoadHookHelper::instance = nullptr;\n+\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    if (isTestClass(name)) {\n+        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+\n+        ClassFileLoadHookHelper* helper = ClassFileLoadHookHelper::getInstance();\n+        if (helper == nullptr) {\n+            _log(\"ClassFileLoadHook ERROR: helper instance is not initialized\\n\");\n+            return;\n+        }\n+        \/\/ save class bytes\n+        helper->setSavedHookClassBytes(class_data, class_data_len);\n+        \/\/ set new class bytes\n+        helper->getHookClassBytes(new_class_data, new_class_data_len);\n+\n@@ -144,1 +239,2 @@\n-    _log(\">>nRedefine\\n\");\n+    ClassFileLoadHookHelper helper(\"nRedefine\", env, classLoadHookBytes);\n+\n@@ -151,3 +247,0 @@\n-    if (classLoadHookBytes != nullptr) {\n-        classLoadHookNewClassBytes = (jbyteArray)env->NewGlobalRef(classLoadHookBytes);\n-    }\n@@ -155,0 +248,6 @@\n+    if (helper.start()) {\n+        jvmtiClassDefinition classDef;\n+        memset(&classDef, 0, sizeof(classDef));\n+        classDef.klass = testClass;\n+        classDef.class_byte_count = len;\n+        classDef.class_bytes = (unsigned char*)arrayPtr;\n@@ -156,26 +255,1 @@\n-    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n-        _log(\"nRedefine: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n-        return nullptr;\n-    }\n-\n-    jvmtiClassDefinition classDef;\n-    memset(&classDef, 0, sizeof(classDef));\n-    classDef.klass = testClass;\n-    classDef.class_byte_count = len;\n-    classDef.class_bytes = (unsigned char *)arrayPtr;\n-\n-    jvmtiError err2 = jvmti->RedefineClasses(1, &classDef);\n-\n-    if (err2 != JVMTI_ERROR_NONE) {\n-        _log(\"nRedefine: RedefineClasses error %d\", err2);\n-        \/\/ don't exit here, need to cleanup\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        _log(\"nRedefine: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", err);\n-    }\n-\n-    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+        jvmtiError err = jvmti->RedefineClasses(1, &classDef);\n@@ -183,25 +257,3 @@\n-    if (classLoadHookBytes != nullptr) {\n-        env->DeleteGlobalRef(classLoadHookNewClassBytes);\n-        classLoadHookNewClassBytes = nullptr;\n-    }\n-\n-    if (err != JVMTI_ERROR_NONE || err2 != JVMTI_ERROR_NONE) {\n-        return nullptr;\n-    }\n-\n-    if (classLoadHookSavedClassBytes == nullptr) {\n-        _log(\"nRedefine: classLoadHookSavedClassBytes is NULL\\n\");\n-        return nullptr;\n-    }\n-\n-    jbyteArray result = env->NewByteArray(classLoadHookSavedClassBytesLen);\n-    if (result == nullptr) {\n-        _log(\"nRedefine: NewByteArray(%ld) failed\\n\", classLoadHookSavedClassBytesLen);\n-    } else {\n-        jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n-        if (arrayPtr == nullptr) {\n-            _log(\"nRedefine: Failed to get array elements\\n\");\n-            result = nullptr;\n-        } else {\n-            memcpy(arrayPtr, classLoadHookSavedClassBytes, classLoadHookSavedClassBytesLen);\n-            env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRedefine: RedefineClasses error %d\", err);\n+            \/\/ don't exit here, need to cleanup\n@@ -209,0 +261,1 @@\n+        helper.stop();\n@@ -211,2 +264,1 @@\n-    jvmti->Deallocate(classLoadHookSavedClassBytes);\n-    classLoadHookSavedClassBytes = nullptr;\n+    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n@@ -214,1 +266,1 @@\n-    return result;\n+    return helper.getSavedHookClassBytes();\n@@ -220,48 +272,6 @@\n-    _log(\">>nRetransform\\n\");\n-    if (classBytes != nullptr) {\n-        classLoadHookNewClassBytes = (jbyteArray)env->NewGlobalRef(classBytes);\n-    }\n-\n-    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        _log(\"nRetransform: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n-        return nullptr;\n-    }\n-\n-    jvmtiError err2 = jvmti->RetransformClasses(1, &testClass);\n-    if (err2 != JVMTI_ERROR_NONE) {\n-        _log(\"nRetransform: RetransformClasses error %d\\n\", err2);\n-        \/\/ don't exit here, disable CFLH event\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        _log(\"nRetransform: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", err);\n-    }\n-\n-    if (classBytes != nullptr) {\n-        env->DeleteGlobalRef(classLoadHookNewClassBytes);\n-        classLoadHookNewClassBytes = nullptr;\n-    }\n-\n-    if (err != JVMTI_ERROR_NONE || err2 != JVMTI_ERROR_NONE) {\n-        return nullptr;\n-    }\n-\n-    if (classLoadHookSavedClassBytes == nullptr) {\n-        _log(\"nRetransform: classLoadHookSavedClassBytes is NULL\\n\");\n-        return nullptr;\n-    }\n-\n-    jbyteArray result = env->NewByteArray(classLoadHookSavedClassBytesLen);\n-    if (result == nullptr) {\n-        _log(\"nRetransform: NewByteArray(%ld) failed\\n\", classLoadHookSavedClassBytesLen);\n-    } else {\n-        jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n-        if (arrayPtr == nullptr) {\n-            _log(\"nRetransform: Failed to get array elements\\n\");\n-            result = nullptr;\n-        }\n-        else {\n-            memcpy(arrayPtr, classLoadHookSavedClassBytes, classLoadHookSavedClassBytesLen);\n-            env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+    ClassFileLoadHookHelper helper(\"nRetransform\", env, classBytes);\n+    if (helper.start()) {\n+        jvmtiError err = jvmti->RetransformClasses(1, &testClass);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRetransform: RetransformClasses error %d\\n\", err);\n+            \/\/ don't exit here, disable CFLH event\n@@ -269,0 +279,1 @@\n+        helper.stop();\n@@ -270,5 +281,1 @@\n-\n-    jvmti->Deallocate(classLoadHookSavedClassBytes);\n-    classLoadHookSavedClassBytes = nullptr;\n-\n-    return result;\n+    return helper.getSavedHookClassBytes();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":155,"deletions":148,"binary":false,"changes":303,"status":"modified"}]}