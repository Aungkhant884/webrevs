{"files":[{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-    \/\/ is being redefined or retransformed. We use jvmti_thread_state()\n+    \/\/ is being retransformed. If class file load hook provides\n+    \/\/ modified class data during class loading or redefinition,\n+    \/\/ new cached class file buffer should be allocated.\n+    \/\/ We use jvmti_thread_state()\n@@ -135,2 +138,1 @@\n-\n-      if (k != NULL) {\n+      if (k != NULL && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4332,11 +4332,3 @@\n-  \/\/ The class file bytes from before any retransformable agents mucked\n-  \/\/ with them was cached on the scratch class, move to the_class.\n-  \/\/ Note: we still want to do this if nothing needed caching since it\n-  \/\/ should get cleared in the_class too.\n-  if (the_class->get_cached_class_file() == 0) {\n-    \/\/ the_class doesn't have a cache yet so copy it\n-    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n-  }\n-  else if (scratch_class->get_cached_class_file() !=\n-           the_class->get_cached_class_file()) {\n-    \/\/ The same class can be present twice in the scratch classes list or there\n+  if (scratch_class->get_cached_class_file() != the_class->get_cached_class_file()) {\n+    \/\/ 1. the_class doesn't have a cache yet, scratch_class does have a cache.\n+    \/\/ 2. The same class can be present twice in the scratch classes list or there\n@@ -4344,2 +4336,8 @@\n-    \/\/ In such cases we have to deallocate scratch_class cached_class_file.\n-    os::free(scratch_class->get_cached_class_file());\n+    \/\/ the_class and scratch_class have the same cached bytes, but different buffers.\n+    \/\/ In such cases we need to deallocate one of the buffers.\n+    \/\/ 3. RedefineClasses and the_class has cached bytes from a previous transformation.\n+    \/\/ In the case we need to use class bytes from scratch_class.\n+    if (the_class->get_cached_class_file() != nullptr) {\n+      os::free(the_class->get_cached_class_file());\n+    }\n+    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 7124710\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @comment main\/othervm\/native -Xlog:redefine*=trace -agentlib:RedefineRetransform RedefineRetransform\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 1\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 2\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 3\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 4\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 5\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 6\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+\/*\n+ * The test verifies that after interleaved RedefineClasses\/RetransformClasses calls\n+ * JVMTI passes correct class bytes to ClassFileLoadHook (as per JVMTI spec).\n+ * To distinguish class version the test instruments test class overriding runtime-visible annotation.\n+ *\/\n+public class RedefineRetransform {\n+    static {\n+        System.loadLibrary(\"RedefineRetransform\");\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassVersion {\n+        int value();\n+    }\n+\n+    \/\/ Use runtime-visible annotation to specify class version.\n+    @ClassVersion(0)\n+    static class TestClass {\n+        public TestClass() { }\n+    }\n+\n+    \/\/ Redefines testClass with classBytes, instruments with classLoadHookBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRedefine(Class testClass, byte[] classBytes, byte[] classLoadHookBytes);\n+    \/\/ Retransforms testClass, instruments with classBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRetransform(Class testClass, byte[] classBytes);\n+\n+    \/\/ Class bytes for initial TestClass (ClassVersion == 0).\n+    private static byte[] initialClassBytes;\n+\n+    private static class VersionScanner extends ClassVisitor {\n+        private Integer detectedVersion;\n+        private Integer versionToSet;\n+        \/\/ to get version\n+        public VersionScanner() {\n+            super(Opcodes.ASM7);\n+        }\n+        \/\/ to set version\n+        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n+            super(Opcodes.ASM7, classVisitor);\n+            versionToSet = verToSet;\n+        }\n+\n+        public int detectedVersion() {\n+            if (detectedVersion == null) {\n+                throw new RuntimeException(\"Version not detected\");\n+            }\n+            return detectedVersion;\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n+            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n+                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n+                    @Override\n+                    public void visit(String name, Object value) {\n+                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n+                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n+                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n+                            detectedVersion = intValue;\n+                            if (versionToSet != null) {\n+                                \/\/log(\"replace with \" + versionToSet);\n+                                value = versionToSet;\n+                            }\n+                        }\n+                        super.visit(name, value);\n+                    }\n+                };\n+            }\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+    }\n+\n+    \/\/ Generates TestClass class bytes with the specified ClassVersion value.\n+    private static byte[] getClassBytes(int ver) {\n+        if (ver < 0) {\n+            return null;\n+        }\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(initialClassBytes);\n+        cr.accept(new VersionScanner(ver, cw), 0);\n+        return cw.toByteArray();\n+    }\n+\n+    \/\/ Extracts ClassVersion values from the provided class bytes.\n+    private static int getClassBytesVersion(byte[] classBytes) {\n+        ClassReader cr = new ClassReader(classBytes);\n+        VersionScanner scanner = new VersionScanner();\n+        cr.accept(scanner, 0);\n+        return scanner.detectedVersion();\n+    }\n+\n+    static void init() {\n+        try {\n+            initialClassBytes = TestClass.class.getClassLoader()\n+                    .getResourceAsStream(\"RedefineRetransform$TestClass.class\")\n+                    .readAllBytes();\n+            log(\"Read TestClass bytes: \" + initialClassBytes.length);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"Failed to read class bytes\", ex);\n+        }\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified.\n+    static void redefine(int ver) {\n+        redefine(ver, -1);\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified\n+    \/\/ instrumenting (from ClassFileLoadHook) with 'classLoadHookVer' class bytes (if >= 0).\n+    \/\/ Also verifies that class bytes passed to ClassFileLoadHook have correct version (ver).\n+    static void redefine(int ver, int classLoadHookVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] classLoadHookBytes = getClassBytes(classLoadHookVer);\n+\n+        byte[] hookClassBytes = nRedefine(TestClass.class, classBytes, classLoadHookBytes);\n+        if (hookClassBytes == null) {\n+            throw new RuntimeException(\"Redefine error (ver = \" + ver + \")\");\n+        }\n+        \/\/ verify ClassFileLoadHook gets the expected class bytes\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != ver) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + ver + \")\");\n+        }\n+    }\n+\n+    \/\/ Retransforms TestClass instrumenting (from ClassFileLoadHook) with 'ver' class bytes (if >= 0).\n+    \/\/ Verifies that class bytes passed to ClassFileLoadHook have correct version (expectedVer).\n+    static void retransform(int ver, int expectedVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] hookClassBytes = nRetransform(TestClass.class, classBytes);\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != expectedVer) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + expectedVer + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int testCase;\n+        try {\n+            testCase = Integer.valueOf(args[0]);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Single numeric argument expected\", ex);\n+        }\n+        init();\n+        switch (testCase) {\n+        case 1:\n+            test(\"Redefine-Retransform-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                retransform(3, 1);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 2:\n+            test(\"Redefine-Retransform-Redefine-Redefine\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                redefine(4);        \/\/ cached class bytes are not set\n+            });\n+            break;\n+\n+        case 3:\n+            test(\"Redefine-Retransform-Redefine-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                retransform(4, 3);  \/\/ sets cached class bytes to ver 3\n+            });\n+            break;\n+\n+        case 4:\n+            test(\"Retransform-Redefine-Retransform-Retransform\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2);        \/\/ resets cached class bytes to nullptr\n+                retransform(3, 2);  \/\/ sets cached class bytes to ver 2\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 5:\n+            test(\"Redefine-Retransform-Redefine-Retransform with CFLH\", () -> {\n+                redefine(1, 5);     \/\/ CFLH sets cached class bytes to ver 1\n+                retransform(2, 1);  \/\/ uses existing cache\n+                redefine(3, 6);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 3\n+                retransform(4, 3);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 6:\n+            test(\"Retransform-Redefine-Retransform-Retransform with CFLH\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2, 5);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 2\n+                retransform(3, 2);  \/\/ uses existing cache\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private interface Test {\n+        void test();\n+    }\n+\n+    private static void test(String name, Test theTest) {\n+        log(\">>Test: \" + name);\n+        theTest.test();\n+        log(\"<<Test: \" + name + \" - OK\");\n+        log(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static const char testClassName[] = \"RedefineRetransform$TestClass\";\n+\n+extern \"C\" {\n+\n+static void _log(const char* format, ...) {\n+    va_list args;\n+    va_start(args, format);\n+    vprintf(format, args);\n+    va_end(args);\n+    fflush(0);\n+}\n+\n+static bool isTestClass(const char* name) {\n+    return name != nullptr && strcmp(name, testClassName) == 0;\n+}\n+\n+\/*\n+ * Helper class for data exchange between RedefineClasses\/RetransformClasses and\n+ * ClassFileLoadHook callback (saves class bytes passed to CFLH,\n+ * allows to set new class bytes to return from CFLH).\n+ * Callers create an instance on the stack, ClassFileLoadHook handler uses getInstance().\n+ *\/\n+class ClassFileLoadHookHelper {\n+    const char* mode;   \/\/ for logging only\n+    bool eventEnabled;\n+    JNIEnv* env;\n+    jbyteArray classBytes = nullptr;\n+\n+    unsigned char* savedClassBytes = nullptr;\n+    jint savedClassBytesLen = 0;\n+\n+    \/\/ single instance\n+    static ClassFileLoadHookHelper *instance;\n+public:\n+    ClassFileLoadHookHelper(const char* mode, JNIEnv* jni_env, jbyteArray hookClassBytes)\n+        : mode(mode), eventEnabled(false), env(jni_env), classBytes(nullptr),\n+        savedClassBytes(nullptr), savedClassBytesLen(0)\n+    {\n+        _log(\">>%s\\n\", mode);\n+        if (hookClassBytes != nullptr) {\n+            classBytes = (jbyteArray)env->NewGlobalRef(hookClassBytes);\n+        }\n+    }\n+\n+    ~ClassFileLoadHookHelper() {\n+        \/\/ cleanup on error\n+        stop();\n+        if (classBytes != nullptr) {\n+            env->DeleteGlobalRef(classBytes);\n+        }\n+        if (savedClassBytes != nullptr) {\n+            jvmti->Deallocate(savedClassBytes);\n+        }\n+        _log(\"<<%s\\n\", mode);\n+    }\n+\n+    bool start() {\n+        instance = this;\n+        jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"%s: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", mode, err);\n+            eventEnabled = true;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void stop() {\n+        instance = nullptr;\n+        if (eventEnabled) {\n+            jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"%s: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", mode, err);\n+                return;\n+            }\n+            eventEnabled = false;\n+        }\n+    }\n+\n+    \/\/ valid only between start() and stop()\n+    static ClassFileLoadHookHelper* getInstance() {\n+        return instance;\n+    }\n+\n+    bool getHookClassBytes(unsigned char** newClassBytes, jint* newLen) {\n+        if (classBytes != nullptr) {\n+            jsize len = env->GetArrayLength(classBytes);\n+            unsigned char* buf = nullptr;\n+            jvmtiError err = jvmti->Allocate(len, &buf);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"ClassFileLoadHook: failed to allocate %ld bytes for new class bytes: %d\", len, err);\n+                return false;\n+            }\n+\n+            jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"ClassFileLoadHook: failed to get array elements\\n\");\n+                jvmti->Deallocate(buf);\n+                return false;\n+            }\n+\n+            memcpy(buf, arrayPtr, len);\n+\n+            env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+            *newClassBytes = buf;\n+            *newLen = len;\n+\n+            _log(\"  ClassFileLoadHook: set new class bytes\\n\");\n+        }\n+        return true;\n+    }\n+\n+    void setSavedHookClassBytes(const unsigned char* bytes, jint len) {\n+        jvmtiError err = jvmti->Allocate(len, &savedClassBytes);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", len, err);\n+            return;\n+        }\n+        memcpy(savedClassBytes, bytes, len);\n+        savedClassBytesLen = len;\n+    }\n+\n+    jbyteArray getSavedHookClassBytes() {\n+        if (savedClassBytes == nullptr) {\n+            _log(\"%s: savedClassBytes is NULL\\n\", mode);\n+            return nullptr;\n+        }\n+\n+        jbyteArray result = env->NewByteArray(savedClassBytesLen);\n+        if (result == nullptr) {\n+            _log(\"%s: NewByteArray(%ld) failed\\n\", mode, savedClassBytesLen);\n+        } else {\n+            jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"%s: Failed to get array elements\\n\", mode);\n+                result = nullptr;\n+            } else {\n+                memcpy(arrayPtr, savedClassBytes, savedClassBytesLen);\n+                env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+            }\n+        }\n+        return result;\n+    }\n+};\n+\n+ClassFileLoadHookHelper* ClassFileLoadHookHelper::instance = nullptr;\n+\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    if (isTestClass(name)) {\n+        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+\n+        ClassFileLoadHookHelper* helper = ClassFileLoadHookHelper::getInstance();\n+        if (helper == nullptr) {\n+            _log(\"ClassFileLoadHook ERROR: helper instance is not initialized\\n\");\n+            return;\n+        }\n+        \/\/ save class bytes\n+        helper->setSavedHookClassBytes(class_data, class_data_len);\n+        \/\/ set new class bytes\n+        helper->getHookClassBytes(new_class_data, new_class_data_len);\n+\n+        _log(\"<<ClassFileLoadHook\\n\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK) {\n+        _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+\n+    caps.can_redefine_classes = 1;\n+    caps.can_retransform_classes = 1;\n+    res = jvmti->AddCapabilities(&caps);\n+    if (res != JVMTI_ERROR_NONE) {\n+        _log(\"Failed to add capabilities: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+    res = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (res != JVMTI_ERROR_NONE) {\n+        _log(\"Error setting event callbacks: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+    return;\n+}\n+\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRedefine(JNIEnv* env, jclass klass,\n+                                   jclass testClass, jbyteArray classBytes, jbyteArray classLoadHookBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRedefine\", env, classLoadHookBytes);\n+\n+    jsize len = env->GetArrayLength(classBytes);\n+    jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+    if (arrayPtr == nullptr) {\n+        _log(\"nRedefine: Failed to get array elements\\n\");\n+        return nullptr;\n+    }\n+\n+    if (helper.start()) {\n+        jvmtiClassDefinition classDef;\n+        memset(&classDef, 0, sizeof(classDef));\n+        classDef.klass = testClass;\n+        classDef.class_byte_count = len;\n+        classDef.class_bytes = (unsigned char*)arrayPtr;\n+\n+        jvmtiError err = jvmti->RedefineClasses(1, &classDef);\n+\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRedefine: RedefineClasses error %d\", err);\n+            \/\/ don't exit here, need to cleanup\n+        }\n+        helper.stop();\n+    }\n+\n+    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRetransform(JNIEnv* env, jclass klass, jclass testClass, jbyteArray classBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRetransform\", env, classBytes);\n+    if (helper.start()) {\n+        jvmtiError err = jvmti->RetransformClasses(1, &testClass);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRetransform: RetransformClasses error %d\\n\", err);\n+            \/\/ don't exit here, disable CFLH event\n+        }\n+        helper.stop();\n+    }\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"}]}