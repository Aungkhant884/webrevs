{"files":[{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-    \/\/ is being redefined or retransformed. We use jvmti_thread_state()\n+    \/\/ is being retransformed. If class file load hook provides\n+    \/\/ modified class data during class loading or redefinition,\n+    \/\/ new cached class file buffer should be allocated.\n+    \/\/ We use jvmti_thread_state()\n@@ -135,2 +138,1 @@\n-\n-      if (k != NULL) {\n+      if (k != NULL && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4332,11 +4332,3 @@\n-  \/\/ The class file bytes from before any retransformable agents mucked\n-  \/\/ with them was cached on the scratch class, move to the_class.\n-  \/\/ Note: we still want to do this if nothing needed caching since it\n-  \/\/ should get cleared in the_class too.\n-  if (the_class->get_cached_class_file() == 0) {\n-    \/\/ the_class doesn't have a cache yet so copy it\n-    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n-  }\n-  else if (scratch_class->get_cached_class_file() !=\n-           the_class->get_cached_class_file()) {\n-    \/\/ The same class can be present twice in the scratch classes list or there\n+  if (scratch_class->get_cached_class_file() != the_class->get_cached_class_file()) {\n+    \/\/ 1. the_class doesn't have a cache yet, scratch_class does have.\n+    \/\/ 2. The same class can be present twice in the scratch classes list or there\n@@ -4344,2 +4336,8 @@\n-    \/\/ In such cases we have to deallocate scratch_class cached_class_file.\n-    os::free(scratch_class->get_cached_class_file());\n+    \/\/ the_class and scratch_class have the same cached bytes, but different buffers.\n+    \/\/ In such cases we need to deallocate one of the buffer.\n+    \/\/ 3. RedefineClasses and the_class has cached bytes from previous transformation.\n+    \/\/ In the case we need to use class bytes from scratch_class.\n+    if (the_class->get_cached_class_file() != 0) {\n+      os::free(the_class->get_cached_class_file());\n+    }\n+    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 7124710\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @comment main\/othervm\/native -Xlog:redefine*=trace -agentlib:RedefineRetransform RedefineRetransform\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 1\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 2\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 3\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 4\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 5\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 6\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+public class RedefineRetransform {\n+    static {\n+        System.loadLibrary(\"RedefineRetransform\");\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassVersion {\n+        int value();\n+    }\n+\n+    \/\/ Use runtime-visible annotation to specify class version\n+    @ClassVersion(0)\n+    static class TestClass {\n+        public TestClass() { }\n+    }\n+\n+    \/\/ redefines testClass with classBytes, instrument with classLoadHookBytes (is != null)\n+    private static native byte[] nRedefine(Class testClass, byte[] classBytes, byte[] classLoadHookBytes);\n+    \/\/ retransforms testClass with classBytes (if != null)\n+    private static native byte[] nRetransform(Class testClass, byte[] classBytes);\n+\n+    private static byte[] initialClassBytes;\n+\n+    private static class VersionScanner extends ClassVisitor {\n+        private Integer detectedVersion;\n+        private Integer versionToSet;\n+        \/\/ to get version\n+        public VersionScanner() {\n+            super(Opcodes.ASM7);\n+        }\n+        \/\/ to set version\n+        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n+            super(Opcodes.ASM7, classVisitor);\n+            versionToSet = verToSet;\n+        }\n+\n+        public int detectedVersion() {\n+            if (detectedVersion == null) {\n+                throw new RuntimeException(\"Version not detected\");\n+            }\n+            return detectedVersion;\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n+            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n+                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n+                    @Override\n+                    public void visit(String name, Object value) {\n+                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n+                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n+                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n+                            detectedVersion = intValue;\n+                            if (versionToSet != null) {\n+                                \/\/log(\"replace with \" + versionToSet);\n+                                value = versionToSet;\n+                            }\n+                        }\n+                        super.visit(name, value);\n+                    }\n+                };\n+            }\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+    }\n+\n+    private static byte[] getClassBytes(int ver) {\n+        if (ver < 0) {\n+            return null;\n+        }\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(initialClassBytes);\n+        cr.accept(new VersionScanner(ver, cw), 0);\n+        return cw.toByteArray();\n+    }\n+\n+    private static int getClassBytesVersion(byte[] classBytes) {\n+        ClassReader cr = new ClassReader(classBytes);\n+        VersionScanner scanner = new VersionScanner();\n+        cr.accept(scanner, 0);\n+        return scanner.detectedVersion();\n+    }\n+\n+    static void init() {\n+        try {\n+            initialClassBytes = TestClass.class.getClassLoader()\n+                    .getResourceAsStream(\"RedefineRetransform$TestClass.class\")\n+                    .readAllBytes();\n+            log(\"Read TestClass bytes: \" + initialClassBytes.length);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"Failed to read class bytes\", ex);\n+        }\n+    }\n+\n+    static void redefine(int ver) {\n+        redefine(ver, -1);\n+    }\n+\n+    static void redefine(int ver, int classLoadHookVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] classLoadHookBytes = getClassBytes(classLoadHookVer);\n+\n+        byte[] hookClassBytes = nRedefine(TestClass.class, classBytes, classLoadHookBytes);\n+        if (hookClassBytes == null) {\n+            throw new RuntimeException(\"Redefine error (ver = \" + ver + \")\");\n+        }\n+        \/\/ verity ClassFileLoadHook get expected class bytes\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != ver) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + ver + \")\");\n+        }\n+    }\n+\n+    static void retransform(int ver, int expectedVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] hookClassBytes = nRetransform(TestClass.class, classBytes);\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != expectedVer) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + expectedVer + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int testCase;\n+        try {\n+            testCase= Integer.valueOf(args[0]);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Single numeric argument expected\", ex);\n+        }\n+        init();\n+        switch (testCase) {\n+        case 1:\n+            test(\"Redefine-Retransform-Retransform\", () -> {\n+                redefine(1);\n+                retransform(2, 1);\n+                retransform(3, 1);\n+            });\n+            break;\n+\n+        case 2:\n+            test(\"Redefine-Retransform-Redefine-Redefine\", () -> {\n+                redefine(1);\n+                retransform(2, 1);\n+                redefine(3);\n+                redefine(4);\n+            });\n+            break;\n+\n+        case 3:\n+            test(\"Redefine-Retransform-Redefine-Retransform\", () -> {\n+                redefine(1);\n+                retransform(2, 1);    \/\/ sets cached class bytes\n+                redefine(3);                    \/\/ resets cached class bytes\n+                retransform(4, 3);\n+            });\n+            break;\n+\n+        case 4:\n+            test(\"Retransform-Redefine-Retransform-Retransform\", () -> {\n+                retransform(1, 0);    \/\/ sets cached class bytes\n+                redefine(2);                    \/\/ reset cached class bytes\n+                retransform(3, 2);    \/\/ sets cached class bytes\n+                retransform(4, 2);\n+            });\n+            break;\n+\n+        case 5:\n+            test(\"Redefine-Retransform-Redefine-Retransform with CFLH\", () -> {\n+                redefine(1, 5);    \/\/ sets cached class bytes\n+                retransform(2, 1);\n+                redefine(3, 6);    \/\/ updates cached class bytes\n+                retransform(4, 3);\n+            });\n+            break;\n+\n+        case 6:\n+            test(\"Retransform-Redefine-Retransform-Retransform with CFLH\", () -> {\n+                retransform(1, 0);    \/\/ sets cached class bytes\n+                redefine(2, 5);    \/\/ updates cached class bytes\n+                retransform(3, 2);\n+                retransform(4, 2);\n+            });\n+            break;\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private interface Test {\n+        void test();\n+    }\n+\n+    private static void test(String name, Test theTest) {\n+        log(\">>Test: \" + name);\n+        theTest.test();\n+        log(\"<<Test: \" + name + \" - OK\");\n+        log(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <jvmti.h>\n+#include <jni.h>\n+#include <string.h>\n+\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = NULL;\n+\n+static const char testClassName[] = \"RedefineRetransform$TestClass\";\n+\n+\/\/ to redefine from ClassFileLoadHock callback\n+\/\/ set by caller:\n+static jbyteArray classLoadHookNewClassBytes = nullptr;\n+\/\/ set by ClassFileLoadHock callback:\n+static unsigned char* classLoadHookSavedClassBytes = nullptr;\n+static jint classLoadHookSavedClassBytesLen = 0;\n+\n+extern \"C\" {\n+\n+static void _log(const char* format, ...) {\n+    va_list args;\n+    va_start(args, format);\n+    vprintf(format, args);\n+    va_end(args);\n+    fflush(0);\n+}\n+\n+static bool isTestClass(const char* name) {\n+    return name != nullptr && strcmp(name, testClassName) == 0;\n+}\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    if (isTestClass(name)) {\n+        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+\n+        \/\/ save class bytes\n+        jvmtiError err = jvmti->Allocate(class_data_len, &classLoadHookSavedClassBytes);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", class_data_len, err);\n+            return;\n+        }\n+        memcpy(classLoadHookSavedClassBytes, class_data, class_data_len);\n+        classLoadHookSavedClassBytesLen = class_data_len;\n+\n+        \/\/ set new class bytes\n+        if (classLoadHookNewClassBytes != nullptr) {\n+            jsize len = jni_env->GetArrayLength(classLoadHookNewClassBytes);\n+            unsigned char* buf = nullptr;\n+            err = jvmti->Allocate(len, &buf);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"ClassFileLoadHook: failed to allocate %ld bytes for new class bytes: %d\", len, err);\n+                return;\n+            }\n+\n+            jbyte* arrayPtr = jni_env->GetByteArrayElements(classLoadHookNewClassBytes, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"ClassFileLoadHook: failed to get array elements\\n\");\n+                jvmti->Deallocate(buf);\n+                return;\n+            }\n+\n+            memcpy(buf, arrayPtr, len);\n+\n+            jni_env->ReleaseByteArrayElements(classLoadHookNewClassBytes, arrayPtr, JNI_ABORT);\n+\n+            *new_class_data = buf;\n+            *new_class_data_len = len;\n+\n+            _log(\"  ClassFileLoadHook: set new class bytes\\n\");\n+        }\n+        _log(\"<<ClassFileLoadHook\\n\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK) {\n+        _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+\n+    caps.can_redefine_classes = 1;\n+    caps.can_retransform_classes = 1;\n+    jvmti->AddCapabilities(&caps);\n+\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+    res = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (res != JVMTI_ERROR_NONE) {\n+        _log(\"Error setting event callbacks: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+    return;\n+}\n+\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRedefine(JNIEnv* env, jclass klass,\n+                                   jclass testClass, jbyteArray classBytes, jbyteArray classLoadHookBytes) {\n+\n+    _log(\">>nRedefine\\n\");\n+    jsize len = env->GetArrayLength(classBytes);\n+    jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+    if (arrayPtr == nullptr) {\n+        _log(\"nRedefine: Failed to get array elements\\n\");\n+        return nullptr;\n+    }\n+    if (classLoadHookBytes != nullptr) {\n+        classLoadHookNewClassBytes = (jbyteArray)env->NewGlobalRef(classLoadHookBytes);\n+    }\n+\n+\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+        _log(\"nRedefine: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n+        return nullptr;\n+    }\n+\n+    jvmtiClassDefinition classDef;\n+    memset(&classDef, 0, sizeof(classDef));\n+    classDef.klass = testClass;\n+    classDef.class_byte_count = len;\n+    classDef.class_bytes = (unsigned char *)arrayPtr;\n+\n+    jvmtiError err2 = jvmti->RedefineClasses(1, &classDef);\n+\n+    if (err2 != JVMTI_ERROR_NONE) {\n+        _log(\"nRedefine: RedefineClasses error %d\", err2);\n+        \/\/ don't exit here, need to cleanup\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"nRedefine: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", err);\n+    }\n+\n+    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+    if (classLoadHookBytes != nullptr) {\n+        env->DeleteGlobalRef(classLoadHookNewClassBytes);\n+        classLoadHookNewClassBytes = nullptr;\n+    }\n+\n+    if (err != JVMTI_ERROR_NONE || err2 != JVMTI_ERROR_NONE) {\n+        return nullptr;\n+    }\n+\n+    if (classLoadHookSavedClassBytes == nullptr) {\n+        _log(\"nRedefine: classLoadHookSavedClassBytes is NULL\\n\");\n+        return nullptr;\n+    }\n+\n+    jbyteArray result = env->NewByteArray(classLoadHookSavedClassBytesLen);\n+    if (result == nullptr) {\n+        _log(\"nRedefine: NewByteArray(%ld) failed\\n\", classLoadHookSavedClassBytesLen);\n+    } else {\n+        jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+        if (arrayPtr == nullptr) {\n+            _log(\"nRedefine: Failed to get array elements\\n\");\n+            result = nullptr;\n+        } else {\n+            memcpy(arrayPtr, classLoadHookSavedClassBytes, classLoadHookSavedClassBytesLen);\n+            env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+        }\n+    }\n+\n+    jvmti->Deallocate(classLoadHookSavedClassBytes);\n+    classLoadHookSavedClassBytes = nullptr;\n+\n+    return result;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRetransform(JNIEnv* env, jclass klass, jclass testClass, jbyteArray classBytes) {\n+\n+    _log(\">>nRetransform\\n\");\n+    if (classBytes != nullptr) {\n+        classLoadHookNewClassBytes = (jbyteArray)env->NewGlobalRef(classBytes);\n+    }\n+\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"nRetransform: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n+        return nullptr;\n+    }\n+\n+    jvmtiError err2 = jvmti->RetransformClasses(1, &testClass);\n+    if (err2 != JVMTI_ERROR_NONE) {\n+        _log(\"nRetransform: RetransformClasses error %d\\n\", err2);\n+        \/\/ don't exit here, disable CFLH event\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"nRetransform: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", err);\n+    }\n+\n+    if (classBytes != nullptr) {\n+        env->DeleteGlobalRef(classLoadHookNewClassBytes);\n+        classLoadHookNewClassBytes = nullptr;\n+    }\n+\n+    if (err != JVMTI_ERROR_NONE || err2 != JVMTI_ERROR_NONE) {\n+        return nullptr;\n+    }\n+\n+    if (classLoadHookSavedClassBytes == nullptr) {\n+        _log(\"nRetransform: classLoadHookSavedClassBytes is NULL\\n\");\n+        return nullptr;\n+    }\n+\n+    jbyteArray result = env->NewByteArray(classLoadHookSavedClassBytesLen);\n+    if (result == nullptr) {\n+        _log(\"nRetransform: NewByteArray(%ld) failed\\n\", classLoadHookSavedClassBytesLen);\n+    } else {\n+        jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+        if (arrayPtr == nullptr) {\n+            _log(\"nRetransform: Failed to get array elements\\n\");\n+            result = nullptr;\n+        }\n+        else {\n+            memcpy(arrayPtr, classLoadHookSavedClassBytes, classLoadHookSavedClassBytesLen);\n+            env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+        }\n+    }\n+\n+    jvmti->Deallocate(classLoadHookSavedClassBytes);\n+    classLoadHookSavedClassBytes = nullptr;\n+\n+    return result;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}