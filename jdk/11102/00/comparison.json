{"files":[{"patch":"@@ -627,0 +627,2 @@\n+  static E* reallocate_malloc(E* addr, size_t new_length, MEMFLAGS flags);\n+\n@@ -656,0 +658,1 @@\n+  static E* reallocate(E* addr, size_t new_length, MEMFLAGS flags);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,6 @@\n-template<class E>\n+template <class E>\n+E* MallocArrayAllocator<E>::reallocate(E* addr, size_t new_length, MEMFLAGS flags) {\n+  return (E*)ReallocateHeap((char*)addr, size_for(new_length), flags);\n+}\n+\n+template <class E>\n@@ -133,0 +138,5 @@\n+template <class E>\n+E* ArrayAllocator<E>::reallocate_malloc(E* addr, size_t new_length, MEMFLAGS flags) {\n+  return MallocArrayAllocator<E>::reallocate(addr, new_length, flags);\n+}\n+\n@@ -135,0 +145,4 @@\n+  if (should_use_malloc(old_length) && should_use_malloc(new_length)) {\n+    return reallocate_malloc(old_addr, new_length, flags);\n+  }\n+\n@@ -150,1 +164,1 @@\n-template<class E>\n+template <class E>\n@@ -155,1 +169,1 @@\n-template<class E>\n+template <class E>\n@@ -160,1 +174,1 @@\n-template<class E>\n+template <class E>\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\/\/ For the BitMaps with allocators that don't support reallocate\n@@ -40,3 +41,37 @@\n-bm_word_t* GrowableBitMap<BitMapWithAllocator>::reallocate(bm_word_t* old_map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear) {\n-  size_t old_size_in_words = calc_size_in_words(old_size_in_bits);\n-  size_t new_size_in_words = calc_size_in_words(new_size_in_bits);\n+static bm_word_t* pseudo_reallocate(const BitMapWithAllocator& derived, bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) {\n+  assert(new_size_in_words > 0, \"precondition\");\n+\n+  bm_word_t* map = derived.allocate(new_size_in_words);\n+  if (old_map != NULL) {\n+    Copy::disjoint_words((HeapWord*)old_map, (HeapWord*) map,\n+        MIN2(old_size_in_words, new_size_in_words));\n+  }\n+\n+  derived.free(old_map, old_size_in_words);\n+\n+  return map;\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::initialize(idx_t size_in_bits, bool clear) {\n+  assert(map() == NULL, \"precondition\");\n+  assert(size() == 0,   \"precondition\");\n+\n+  resize(size_in_bits, clear);\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::reinitialize(idx_t new_size_in_bits, bool clear) {\n+  \/\/ Remove previous bits - no need to clear\n+  resize(0, false \/* clear *\/);\n+\n+  initialize(new_size_in_bits, clear);\n+}\n+\n+template <class BitMapWithAllocator>\n+void GrowableBitMap<BitMapWithAllocator>::resize(idx_t new_size_in_bits, bool clear) {\n+  const size_t old_size_in_bits = size();\n+  bm_word_t* const old_map = map();\n+\n+  const size_t old_size_in_words = calc_size_in_words(size());\n+  const size_t new_size_in_words = calc_size_in_words(new_size_in_bits);\n@@ -44,1 +79,0 @@\n-  bm_word_t* map = NULL;\n@@ -47,17 +81,4 @@\n-  if (new_size_in_words > 0) {\n-    map = derived->allocate(new_size_in_words);\n-\n-    if (old_map != NULL) {\n-      Copy::disjoint_words((HeapWord*)old_map, (HeapWord*) map,\n-                           MIN2(old_size_in_words, new_size_in_words));\n-    }\n-\n-    if (clear && (new_size_in_bits > old_size_in_bits)) {\n-      \/\/ If old_size_in_bits is not word-aligned, then the preceding\n-      \/\/ copy can include some trailing bits in the final copied word\n-      \/\/ that also need to be cleared.  See clear_range_within_word.\n-      bm_word_t mask = bit_mask(old_size_in_bits) - 1;\n-      map[raw_to_words_align_down(old_size_in_bits)] &= mask;\n-      \/\/ Clear the remaining full words.\n-      clear_range_of_words(map, old_size_in_words, new_size_in_words);\n-    }\n+  if (new_size_in_words == 0) {\n+    derived->free(old_map, old_size_in_words);\n+    update(NULL, 0);\n+    return;\n@@ -66,2 +87,10 @@\n-  if (old_map != NULL) {\n-    derived->free(old_map, old_size_in_words);\n+\n+  bm_word_t* map = derived->reallocate(old_map, old_size_in_words, new_size_in_words);\n+  if (clear && (new_size_in_bits > old_size_in_bits)) {\n+    \/\/ If old_size_in_bits is not word-aligned, then the preceding\n+    \/\/ copy can include some trailing bits in the final copied word\n+    \/\/ that also need to be cleared.  See clear_range_within_word.\n+    bm_word_t mask = bit_mask(old_size_in_bits) - 1;\n+    map[raw_to_words_align_down(old_size_in_bits)] &= mask;\n+    \/\/ Clear the remaining full words.\n+    clear_range_of_words(map, old_size_in_words, new_size_in_words);\n@@ -70,1 +99,1 @@\n-  return map;\n+  update(map, new_size_in_bits);\n@@ -82,0 +111,4 @@\n+bm_word_t* ArenaBitMap::reallocate(bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) const {\n+  return pseudo_reallocate(*this, old_map, old_size_in_words, new_size_in_words);\n+}\n+\n@@ -91,0 +124,4 @@\n+bm_word_t* ResourceBitMap::reallocate(bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) const {\n+  return pseudo_reallocate(*this, old_map, old_size_in_words, new_size_in_words);\n+}\n+\n@@ -108,0 +145,4 @@\n+bm_word_t* CHeapBitMap::reallocate(bm_word_t* map, size_t old_size_in_words, size_t new_size_in_words) const {\n+  return ArrayAllocator<bm_word_t>::reallocate(map, old_size_in_words, new_size_in_words, _flags);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":65,"deletions":24,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -329,2 +329,0 @@\n-  bm_word_t* reallocate(bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear);\n-\n@@ -335,1 +333,1 @@\n-  \/\/ Set up and clear the bitmap memory.\n+  \/\/ Set up and optionally clear the bitmap memory.\n@@ -339,6 +337,1 @@\n-  void initialize(idx_t size_in_bits, bool clear = true) {\n-    assert(map() == NULL, \"precondition\");\n-    assert(size() == 0,   \"precondition\");\n-\n-    resize(size_in_bits, clear);\n-  }\n+  void initialize(idx_t size_in_bits, bool clear = true);\n@@ -346,1 +339,1 @@\n-  \/\/ Set up and clear the bitmap memory.\n+  \/\/ Set up and optionally clear the bitmap memory.\n@@ -349,6 +342,1 @@\n-  void reinitialize(idx_t new_size_in_bits, bool clear = true) {\n-    \/\/ Remove previous bits - no need to clear\n-    resize(0, false \/* clear *\/);\n-\n-    initialize(new_size_in_bits, clear);\n-  }\n+  void reinitialize(idx_t new_size_in_bits, bool clear = true);\n@@ -361,5 +349,2 @@\n-  \/\/ and the extended memory is cleared.\n-  void resize(idx_t new_size_in_bits, bool clear = true) {\n-    bm_word_t* new_map = reallocate(map(), size(), new_size_in_bits, clear);\n-    update(new_map, new_size_in_bits);\n-  }\n+  \/\/ and the extended memory is optionally cleared.\n+  void resize(idx_t new_size_in_bits, bool clear = true);\n@@ -384,1 +369,0 @@\n-  \/\/ Clears the bitmap memory.\n@@ -388,0 +372,1 @@\n+  bm_word_t* reallocate(bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) const;\n@@ -389,1 +374,1 @@\n-    \/\/ ArenaBitMaps currently don't free memory.\n+    \/\/ ArenaBitMaps don't free memory.\n@@ -400,0 +385,1 @@\n+  bm_word_t* reallocate(bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) const;\n@@ -401,1 +387,1 @@\n-    \/\/ ArenaBitMaps currently don't free memory.\n+    \/\/ ResourceBitMaps don't free memory.\n@@ -416,1 +402,0 @@\n-  \/\/ Clears the bitmap memory.\n@@ -421,0 +406,1 @@\n+  bm_word_t* reallocate(bm_word_t* old_map, size_t old_size_in_words, size_t new_size_in_words) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+using Element = struct TestArrayAllocatorElement {\n+  double a;\n+  int b;\n+};\n+\n+static void fill(Element* elements, int start, int size) {\n+  for (int i = 0; i < size; i++) {\n+    new (&elements[start + i]) Element{0.0, start + i};\n+  }\n+}\n+\n+static Element* allocate_and_fill(int size) {\n+  Element* const elements = MallocArrayAllocator<Element>::allocate(size, mtTest);\n+\n+  fill(elements, 0, size);\n+\n+  return elements;\n+}\n+\n+TEST_VM(ArrayAllocator, allocate) {\n+  const int size = 10;\n+\n+  Element* const elements = allocate_and_fill(size);\n+\n+  for (int i = 0; i < size; i++) {\n+    ASSERT_EQ(elements[i].b, i);\n+  }\n+\n+  MallocArrayAllocator<Element>::free(elements);\n+}\n+\n+TEST_VM(ArrayAllocator, reallocate_0) {\n+  const int size = 10;\n+\n+  Element* const elements = allocate_and_fill(size);\n+\n+  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, 0, mtTest);\n+  ASSERT_NE(ret, nullptr) << \"We've chosen to NOT return nullptr when reallcting with 0\";\n+\n+  MallocArrayAllocator<Element>::free(ret);\n+}\n+\n+TEST_VM(ArrayAllocator, reallocate_shrink) {\n+  const int size = 10;\n+\n+  Element* const elements = allocate_and_fill(size);\n+\n+  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, size \/ 2, mtTest);\n+\n+  for (int i = 0; i < size \/ 2; i++) {\n+    ASSERT_EQ(ret[i].b, i);\n+  }\n+\n+  MallocArrayAllocator<Element>::free(ret);\n+}\n+\n+TEST_VM(ArrayAllocator, reallocate_grow) {\n+  const int size = 10;\n+\n+  Element* const elements = allocate_and_fill(size);\n+\n+  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, size * 2, mtTest);\n+\n+  fill(ret, size, size);\n+\n+  for (int i = 0; i < size * 2; i++) {\n+    ASSERT_EQ(ret[i].b, i);\n+  }\n+\n+  MallocArrayAllocator<Element>::free(ret);\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_arrayAllocator.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}