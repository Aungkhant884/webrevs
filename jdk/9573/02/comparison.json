{"files":[{"patch":"@@ -229,1 +229,5 @@\n-  return predict_zero_bounded(_alloc_rate_ms_seq);\n+  if (enough_samples_available(_alloc_rate_ms_seq)) {\n+    return predict_zero_bounded(_alloc_rate_ms_seq);\n+  } else {\n+    return 0.0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  _young_list_desired_length(0),\n@@ -65,1 +66,0 @@\n-  _young_list_fixed_length(0),\n@@ -103,3 +103,0 @@\n-  if (!use_adaptive_young_list_length()) {\n-    _young_list_fixed_length = _young_gen_sizer.min_desired_young_length();\n-  }\n@@ -110,1 +107,1 @@\n-  update_young_list_max_and_target_length();\n+  update_young_length_bounds();\n@@ -185,1 +182,4 @@\n-uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {\n+uint G1Policy::calculate_desired_eden_length_by_mmu() const {\n+  \/\/ One could argue that any useful eden length to keep any MMU wouldn't be zero, but\n+  \/\/ in theory this is possible. Other constraints enforce a minimum eden size of one\n+  \/\/ region anyway.\n@@ -188,8 +188,4 @@\n-    if (_analytics->num_alloc_rate_ms() > 3) {\n-      double now_sec = os::elapsedTime();\n-      double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n-      double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n-      desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);\n-    } else {\n-      \/\/ otherwise we don't have enough info to make the prediction\n-    }\n+    double now_sec = os::elapsedTime();\n+    double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n+    double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n+    desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);\n@@ -197,4 +193,43 @@\n-  desired_min_length += base_min_length;\n-  \/\/ make sure we don't go below any user-defined minimum bound\n-  return MAX2(_young_gen_sizer.min_desired_young_length(), desired_min_length);\n-}\n+  return desired_min_length;\n+}\n+\n+void G1Policy::update_young_length_bounds() {\n+  update_young_length_bounds(_analytics->predict_rs_length());\n+}\n+\n+void G1Policy::update_young_length_bounds(size_t rs_length) {\n+  _young_list_desired_length = calculate_young_desired_length(rs_length);\n+  _young_list_target_length = calculate_young_target_length(_young_list_desired_length);\n+  _young_list_max_length = calculate_young_max_length(_young_list_target_length);\n+\n+  log_debug(gc, ergo, heap)(\"Young list lengths: desired: %u, target: %u, max: %u\",\n+                            _young_list_desired_length,\n+                            _young_list_target_length,\n+                            _young_list_max_length);\n+}\n+\n+\/\/ Calculates desired young gen length. It is calculated from:\n+\/\/\n+\/\/ - sizer min\/max bounds on young gen\n+\/\/ - pause time goal for whole young gen evacuation\n+\/\/ - MMU goal influencing eden to make GCs spaced apart.\n+\/\/ - a minimum one eden region length.\n+\/\/\n+\/\/ We may enter with already allocated eden and survivor regions, that may be\n+\/\/ higher than the maximum, or the above goals may result in a desired value\n+\/\/ smaller than are already allocated.\n+\/\/ The main reason is revising young length, with or without the GCLocker being\n+\/\/ active.\n+\/\/\n+uint G1Policy::calculate_young_desired_length(size_t rs_length) const {\n+  uint min_young_length_by_sizer = _young_gen_sizer.min_desired_young_length();\n+  uint max_young_length_by_sizer = _young_gen_sizer.max_desired_young_length();\n+\n+  assert(min_young_length_by_sizer >= 1, \"invariant\");\n+  assert(max_young_length_by_sizer >= min_young_length_by_sizer, \"invariant\");\n+\n+  \/\/ Absolute minimum eden length.\n+  \/\/ Enforcing a minimum eden length helps at startup when the predictors are not\n+  \/\/ yet trained on the application to avoid unnecessary (but very short) full gcs\n+  \/\/ on very small (initial) heaps.\n+  uint const MinDesiredEdenLength = 1;\n@@ -202,23 +237,1 @@\n-uint G1Policy::calculate_young_list_desired_max_length() const {\n-  \/\/ Here, we might want to also take into account any additional\n-  \/\/ constraints (i.e., user-defined minimum bound). Currently, we\n-  \/\/ effectively don't set this bound.\n-  return _young_gen_sizer.max_desired_young_length();\n-}\n-\n-uint G1Policy::update_young_list_max_and_target_length() {\n-  return update_young_list_max_and_target_length(_analytics->predict_rs_length());\n-}\n-\n-uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {\n-  uint unbounded_target_length = update_young_list_target_length(rs_length);\n-  update_max_gc_locker_expansion();\n-  return unbounded_target_length;\n-}\n-\n-uint G1Policy::update_young_list_target_length(size_t rs_length) {\n-  YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);\n-  _young_list_target_length = young_lengths.first;\n-\n-  return young_lengths.second;\n-}\n+  \/\/ Calculate the absolute and desired min bounds first.\n@@ -226,2 +239,19 @@\n-G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {\n-  YoungTargetLengths result;\n+  \/\/ This is how many survivor regions we already have.\n+  const uint survivor_length = _g1h->survivor_regions_count();\n+  \/\/ Size of the already allocated young gen.\n+  const uint allocated_young_length = _g1h->young_regions_count();\n+  \/\/ This is the absolute minimum young length that we can return. Ensure that we\n+  \/\/ don't go below any user-defined minimum bound; but we might have already\n+  \/\/ allocated more than that for various reasons. In this case, use that.\n+  uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);\n+  \/\/ Calculate the absolute max bounds. After evac failure or when revising the\n+  \/\/ young length we might have exceeded absolute min length or absolute_max_length,\n+  \/\/ so adjust the result accordingly.\n+  uint absolute_max_young_length = MAX2(max_young_length_by_sizer, absolute_min_young_length);\n+\n+  uint desired_eden_length_by_mmu = 0;\n+  uint desired_eden_length_by_pause = 0;\n+\n+  uint desired_young_length = 0;\n+  if (use_adaptive_young_list_length()) {\n+    desired_eden_length_by_mmu = calculate_desired_eden_length_by_mmu();\n@@ -229,1 +259,2 @@\n-  \/\/ Calculate the absolute and desired min bounds first.\n+    const size_t pending_cards = _analytics->predict_pending_cards();\n+    double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n@@ -231,9 +262,4 @@\n-  \/\/ This is how many young regions we already have (currently: the survivors).\n-  const uint base_min_length = _g1h->survivor_regions_count();\n-  uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);\n-  \/\/ This is the absolute minimum young length. Ensure that we\n-  \/\/ will at least have one eden region available for allocation.\n-  uint absolute_min_length = base_min_length + MAX2(_g1h->eden_regions_count(), (uint)1);\n-  \/\/ If we shrank the young list target it should not shrink below the current size.\n-  desired_min_length = MAX2(desired_min_length, absolute_min_length);\n-  \/\/ Calculate the absolute and desired max bounds.\n+    desired_eden_length_by_pause =\n+      calculate_desired_eden_length_by_pause(survivor_base_time_ms,\n+                                             absolute_min_young_length - survivor_length,\n+                                             absolute_max_young_length - survivor_length);\n@@ -241,1 +267,6 @@\n-  uint desired_max_length = calculate_young_list_desired_max_length();\n+    \/\/ Incorporate MMU concerns; assume that it overrides the pause time\n+    \/\/ goal, as the default value has been chosen to effectively disable it.\n+    \/\/ Also request at least one eden region, see above for reasons.\n+    uint desired_eden_length = MAX3(desired_eden_length_by_pause,\n+                                    desired_eden_length_by_mmu,\n+                                    MinDesiredEdenLength);\n@@ -243,13 +274,1 @@\n-  uint young_list_target_length = 0;\n-  if (use_adaptive_young_list_length()) {\n-    if (collector_state()->in_young_only_phase()) {\n-      young_list_target_length =\n-                        calculate_young_list_target_length(rs_length,\n-                                                           base_min_length,\n-                                                           desired_min_length,\n-                                                           desired_max_length);\n-    } else {\n-      \/\/ Don't calculate anything and let the code below bound it to\n-      \/\/ the desired_min_length, i.e., do the next GC as soon as\n-      \/\/ possible to maximize how many old regions we can add to it.\n-    }\n+    desired_young_length = desired_eden_length + survivor_length;\n@@ -259,9 +278,1 @@\n-    young_list_target_length = _young_list_fixed_length;\n-  }\n-\n-  result.second = young_list_target_length;\n-\n-  \/\/ We will try our best not to \"eat\" into the reserve.\n-  uint absolute_max_length = 0;\n-  if (_free_regions_at_end_of_collection > _reserve_regions) {\n-    absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;\n+    desired_young_length = min_young_length_by_sizer;\n@@ -269,2 +280,97 @@\n-  if (desired_max_length > absolute_max_length) {\n-    desired_max_length = absolute_max_length;\n+  \/\/ Clamp to absolute min\/max after we determined desired lengths.\n+  desired_young_length = clamp(desired_young_length, absolute_min_young_length, absolute_max_young_length);\n+\n+  log_trace(gc, ergo, heap)(\"Young desired length %u \"\n+                            \"survivor length %u \"\n+                            \"allocated young length %u \"\n+                            \"absolute min young length %u \"\n+                            \"absolute max young length %u \"\n+                            \"desired eden length by mmu %u \"\n+                            \"desired eden length by pause %u \"\n+                            \"desired eden length by default %u\",\n+                            desired_young_length, survivor_length,\n+                            allocated_young_length, absolute_min_young_length,\n+                            absolute_max_young_length, desired_eden_length_by_mmu,\n+                            desired_eden_length_by_pause,\n+                            MinDesiredEdenLength);\n+\n+  assert(desired_young_length >= allocated_young_length, \"must be\");\n+  return desired_young_length;\n+}\n+\n+\/\/ Limit the desired (wished) young length by current free regions. If the request\n+\/\/ can be satisfied without using up reserve regions, do so, otherwise eat into\n+\/\/ the reserve, giving away at most what the heap sizer allows.\n+uint G1Policy::calculate_young_target_length(uint desired_young_length) const {\n+  uint allocated_young_length = _g1h->young_regions_count();\n+\n+  uint receiving_additional_eden;\n+  if (allocated_young_length >= desired_young_length) {\n+    \/\/ Already used up all we actually want (may happen as G1 revises the\n+    \/\/ young list length concurrently, or caused by gclocker). Do not allow more,\n+    \/\/ potentially resulting in GC.\n+    receiving_additional_eden = 0;\n+    log_trace(gc, ergo, heap)(\"Young target length: Already used up desired young %u allocated %u\",\n+                              desired_young_length,\n+                              allocated_young_length);\n+  } else {\n+    \/\/ Now look at how many free regions are there currently, and the heap reserve.\n+    \/\/ We will try our best not to \"eat\" into the reserve as long as we can. If we\n+    \/\/ do, we at most eat the sizer's minimum regions into the reserve or half the\n+    \/\/ reserve rounded up (if possible; this is an arbitrary value).\n+\n+    uint max_to_eat_into_reserve = MIN2(_young_gen_sizer.min_desired_young_length(),\n+                                        (_reserve_regions + 1) \/ 2);\n+\n+    log_trace(gc, ergo, heap)(\"Young target length: Common \"\n+                              \"free regions at end of collection %u \"\n+                              \"desired young length %u \"\n+                              \"reserve region %u \"\n+                              \"max to eat into reserve %u\",\n+                              _free_regions_at_end_of_collection,\n+                              desired_young_length,\n+                              _reserve_regions,\n+                              max_to_eat_into_reserve);\n+\n+    if (_free_regions_at_end_of_collection <= _reserve_regions) {\n+      \/\/ Fully eat (or already eating) into the reserve, hand back at most absolute_min_length regions.\n+      uint receiving_young = MIN3(_free_regions_at_end_of_collection,\n+                                  desired_young_length,\n+                                  max_to_eat_into_reserve);\n+      \/\/ We could already have allocated more regions than what we could get\n+      \/\/ above.\n+      receiving_additional_eden = allocated_young_length < receiving_young ?\n+                                  receiving_young - allocated_young_length : 0;\n+\n+      log_trace(gc, ergo, heap)(\"Young target length: Fully eat into reserve \"\n+                                \"receiving young %u receiving additional eden %u\",\n+                                receiving_young,\n+                                receiving_additional_eden);\n+    } else if (_free_regions_at_end_of_collection < (desired_young_length + _reserve_regions)) {\n+      \/\/ Partially eat into the reserve, at most max_to_eat_into_reserve regions.\n+      uint free_outside_reserve = _free_regions_at_end_of_collection - _reserve_regions;\n+      assert(free_outside_reserve < desired_young_length,\n+             \"must be %u %u\",\n+             free_outside_reserve, desired_young_length);\n+\n+      uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,\n+                                           max_to_eat_into_reserve);\n+      uint receiving_young = free_outside_reserve + receiving_within_reserve;\n+      \/\/ Again, we could have already allocated more than we could get.\n+      receiving_additional_eden = allocated_young_length < receiving_young ?\n+                                  receiving_young - allocated_young_length : 0;\n+\n+      log_trace(gc, ergo, heap)(\"Young target length: Partially eat into reserve \"\n+                                \"free outside reserve %u \"\n+                                \"receiving within reserve %u \"\n+                                \"receiving young %u \"\n+                                \"receiving additional eden %u\",\n+                                free_outside_reserve, receiving_within_reserve,\n+                                receiving_young, receiving_additional_eden);\n+    } else {\n+      \/\/ No need to use the reserve.\n+      receiving_additional_eden = desired_young_length - allocated_young_length;\n+      log_trace(gc, ergo, heap)(\"Young target length: No need to use reserve \"\n+                                \"receiving additional eden %u\",\n+                                receiving_additional_eden);\n+    }\n@@ -273,9 +379,1 @@\n-  \/\/ Make sure we don't go over the desired max length, nor under the\n-  \/\/ desired min length. In case they clash, desired_min_length wins\n-  \/\/ which is why that test is second.\n-  if (young_list_target_length > desired_max_length) {\n-    young_list_target_length = desired_max_length;\n-  }\n-  if (young_list_target_length < desired_min_length) {\n-    young_list_target_length = desired_min_length;\n-  }\n+  uint target_young_length = allocated_young_length + receiving_additional_eden;\n@@ -283,3 +381,1 @@\n-  assert(young_list_target_length > base_min_length,\n-         \"we should be able to allocate at least one eden region\");\n-  assert(young_list_target_length >= absolute_min_length, \"post-condition\");\n+  assert(target_young_length >= allocated_young_length, \"must be\");\n@@ -287,2 +383,7 @@\n-  result.first = young_list_target_length;\n-  return result;\n+  log_trace(gc, ergo, heap)(\"Young target length: \"\n+                            \"young target length %u \"\n+                            \"allocated young length %u \"\n+                            \"received additional eden %u\",\n+                            target_young_length, allocated_young_length,\n+                            receiving_additional_eden);\n+  return target_young_length;\n@@ -291,10 +392,11 @@\n-uint G1Policy::calculate_young_list_target_length(size_t rs_length,\n-                                                  uint base_min_length,\n-                                                  uint desired_min_length,\n-                                                  uint desired_max_length) const {\n-  assert(use_adaptive_young_list_length(), \"pre-condition\");\n-  assert(collector_state()->in_young_only_phase(), \"only call this for young GCs\");\n-\n-  \/\/ In case some edge-condition makes the desired max length too small...\n-  if (desired_max_length <= desired_min_length) {\n-    return desired_min_length;\n+uint G1Policy::calculate_desired_eden_length_by_pause(double base_time_ms,\n+                                                      uint min_eden_length,\n+                                                      uint max_eden_length) const {\n+  if (!next_gc_should_be_mixed(nullptr)) {\n+    return calculate_desired_eden_length_before_young_only(base_time_ms,\n+                                                           min_eden_length,\n+                                                           max_eden_length);\n+  } else {\n+    return calculate_desired_eden_length_before_mixed(base_time_ms,\n+                                                      min_eden_length,\n+                                                      max_eden_length);\n@@ -302,0 +404,1 @@\n+}\n@@ -303,16 +406,6 @@\n-  \/\/ We'll adjust min_young_length and max_young_length not to include\n-  \/\/ the already allocated young regions (i.e., so they reflect the\n-  \/\/ min and max eden regions we'll allocate). The base_min_length\n-  \/\/ will be reflected in the predictions by the\n-  \/\/ survivor_regions_evac_time prediction.\n-  assert(desired_min_length > base_min_length, \"invariant\");\n-  uint min_young_length = desired_min_length - base_min_length;\n-  assert(desired_max_length > base_min_length, \"invariant\");\n-  uint max_young_length = desired_max_length - base_min_length;\n-\n-  const double target_pause_time_ms = _mmu_tracker->max_gc_time() * 1000.0;\n-  const size_t pending_cards = _analytics->predict_pending_cards();\n-  const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n-  const uint available_free_regions = _free_regions_at_end_of_collection;\n-  const uint base_free_regions =\n-    available_free_regions > _reserve_regions ? available_free_regions - _reserve_regions : 0;\n+uint G1Policy::calculate_desired_eden_length_before_young_only(double base_time_ms,\n+                                                               uint min_eden_length,\n+                                                               uint max_eden_length) const {\n+  assert(use_adaptive_young_list_length(), \"pre-condition\");\n+\n+  assert(min_eden_length <= max_eden_length, \"must be %u %u\", min_eden_length, max_eden_length);\n@@ -324,2 +417,2 @@\n-                           base_free_regions,\n-                           target_pause_time_ms,\n+                           _free_regions_at_end_of_collection,\n+                           _mmu_tracker->max_gc_time() * 1000.0,\n@@ -327,1 +420,1 @@\n-  if (p.will_fit(min_young_length)) {\n+  if (p.will_fit(min_eden_length)) {\n@@ -332,1 +425,1 @@\n-    if (p.will_fit(max_young_length)) {\n+    if (p.will_fit(max_eden_length)) {\n@@ -336,1 +429,1 @@\n-      min_young_length = max_young_length;\n+      min_eden_length = max_eden_length;\n@@ -353,2 +446,2 @@\n-      assert(min_young_length < max_young_length, \"invariant\");\n-      uint diff = (max_young_length - min_young_length) \/ 2;\n+      assert(min_eden_length < max_eden_length, \"invariant\");\n+      uint diff = (max_eden_length - min_eden_length) \/ 2;\n@@ -356,3 +449,3 @@\n-        uint young_length = min_young_length + diff;\n-        if (p.will_fit(young_length)) {\n-          min_young_length = young_length;\n+        uint eden_length = min_eden_length + diff;\n+        if (p.will_fit(eden_length)) {\n+          min_eden_length = eden_length;\n@@ -360,1 +453,1 @@\n-          max_young_length = young_length;\n+          max_eden_length = eden_length;\n@@ -362,2 +455,2 @@\n-        assert(min_young_length <  max_young_length, \"invariant\");\n-        diff = (max_young_length - min_young_length) \/ 2;\n+        assert(min_eden_length <  max_eden_length, \"invariant\");\n+        diff = (max_eden_length - min_eden_length) \/ 2;\n@@ -369,2 +462,2 @@\n-      assert(min_young_length < max_young_length,\n-             \"otherwise we should have discovered that max_young_length \"\n+      assert(min_eden_length < max_eden_length,\n+             \"otherwise we should have discovered that max_eden_length \"\n@@ -372,2 +465,2 @@\n-      assert(p.will_fit(min_young_length),\n-             \"min_young_length, the result of the binary search, should \"\n+      assert(p.will_fit(min_eden_length),\n+             \"min_eden_length, the result of the binary search, should \"\n@@ -375,2 +468,2 @@\n-      assert(!p.will_fit(min_young_length + 1),\n-             \"min_young_length, the result of the binary search, should be \"\n+      assert(!p.will_fit(min_eden_length + 1),\n+             \"min_eden_length, the result of the binary search, should be \"\n@@ -383,1 +476,21 @@\n-  return base_min_length + min_young_length;\n+  return min_eden_length;\n+}\n+\n+uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+                                                          uint min_eden_length,\n+                                                          uint max_eden_length) const {\n+  G1CollectionSetCandidates* candidates = _collection_set->candidates();\n+\n+  uint min_old_regions_end = MIN2(candidates->cur_idx() + calc_min_old_cset_length(candidates),\n+                                  candidates->num_regions());\n+  double predicted_region_evac_time_ms = survivor_base_time_ms;\n+  for (uint i = candidates->cur_idx(); i < min_old_regions_end; i++) {\n+    HeapRegion* r = candidates->at(i);\n+    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);\n+  }\n+  uint desired_eden_length_by_min_cset_length =\n+     calculate_desired_eden_length_before_young_only(predicted_region_evac_time_ms,\n+                                                     min_eden_length,\n+                                                     max_eden_length);\n+\n+  return desired_eden_length_by_min_cset_length;\n@@ -413,2 +526,1 @@\n-\n-    update_young_list_max_and_target_length(rs_length_prediction);\n+    update_young_length_bounds(rs_length_prediction);\n@@ -459,1 +571,1 @@\n-  update_young_list_max_and_target_length();\n+  update_young_length_bounds();\n@@ -795,5 +907,1 @@\n-    \/\/ IHOP control wants to know the expected young gen length if it were not\n-    \/\/ restrained by the heap reserve. Using the actual length would make the\n-    \/\/ prediction too small and the limit the young gen every time we get to the\n-    \/\/ predicted target occupancy.\n-    size_t last_unrestrained_young_length = update_young_list_max_and_target_length();\n+    update_young_length_bounds();\n@@ -803,1 +911,0 @@\n-                           last_unrestrained_young_length * HeapRegion::GrainBytes,\n@@ -854,1 +961,0 @@\n-                                      size_t young_gen_size,\n@@ -882,0 +988,5 @@\n+    \/\/ IHOP control wants to know the expected young gen length if it were not\n+    \/\/ restrained by the heap reserve. Using the actual length would make the\n+    \/\/ prediction too small and the limit the young gen every time we get to the\n+    \/\/ predicted target occupancy.\n+    size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;\n@@ -989,1 +1100,1 @@\n-void G1Policy::update_max_gc_locker_expansion() {\n+uint G1Policy::calculate_young_max_length(uint target_young_length) const {\n@@ -997,2 +1108,0 @@\n-  } else {\n-    assert(expansion_region_num == 0, \"sanity\");\n@@ -1000,2 +1109,3 @@\n-  _young_list_max_length = _young_list_target_length + expansion_region_num;\n-  assert(_young_list_target_length <= _young_list_max_length, \"post-condition\");\n+  uint max_length = target_young_length + expansion_region_num;\n+  assert(target_young_length <= max_length, \"overflow\");\n+  return max_length;\n@@ -1255,1 +1365,3 @@\n-    log_debug(gc, ergo)(\"%s (candidate old regions not available)\", no_candidates_str);\n+    if (no_candidates_str != nullptr) {\n+      log_debug(gc, ergo)(\"%s (candidate old regions not available)\", no_candidates_str);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":266,"deletions":154,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-                              size_t young_gen_size,\n@@ -80,0 +79,1 @@\n+  uint _young_list_desired_length;\n@@ -81,1 +81,0 @@\n-  uint _young_list_fixed_length;\n@@ -175,0 +174,1 @@\n+\n@@ -196,38 +196,38 @@\n-  \/\/ Updates the internal young list maximum and target lengths. Returns the\n-  \/\/ unbounded young list target length. If no rs_length parameter is passed,\n-  \/\/ predict the RS length using the prediction model, otherwise use the\n-  \/\/ given rs_length as the prediction.\n-  uint update_young_list_max_and_target_length();\n-  uint update_young_list_max_and_target_length(size_t rs_length);\n-\n-  \/\/ Update the young list target length either by setting it to the\n-  \/\/ desired fixed value or by calculating it using G1's pause\n-  \/\/ prediction model.\n-  \/\/ Returns the unbounded young list target length.\n-  uint update_young_list_target_length(size_t rs_length);\n-\n-  \/\/ Calculate and return the minimum desired young list target\n-  \/\/ length. This is the minimum desired young list length according\n-  \/\/ to the user's inputs.\n-  uint calculate_young_list_desired_min_length(uint base_min_length) const;\n-\n-  \/\/ Calculate and return the maximum desired young list target\n-  \/\/ length. This is the maximum desired young list length according\n-  \/\/ to the user's inputs.\n-  uint calculate_young_list_desired_max_length() const;\n-\n-  \/\/ Calculate and return the maximum young list target length that\n-  \/\/ can fit into the pause time goal. The parameters are: rs_length\n-  \/\/ represent the prediction of how large the young RSet lengths will\n-  \/\/ be, base_min_length is the already existing number of regions in\n-  \/\/ the young list, min_length and max_length are the desired min and\n-  \/\/ max young list length according to the user's inputs.\n-  uint calculate_young_list_target_length(size_t rs_length,\n-                                          uint base_min_length,\n-                                          uint desired_min_length,\n-                                          uint desired_max_length) const;\n-\n-  \/\/ Result of the bounded_young_list_target_length() method, containing both the\n-  \/\/ bounded as well as the unbounded young list target lengths in this order.\n-  typedef Pair<uint, uint, StackObj> YoungTargetLengths;\n-  YoungTargetLengths young_list_target_lengths(size_t rs_length) const;\n+  \/\/ Updates the internal young gen maximum and target and desired lengths.\n+  \/\/ If no rs_length parameter is passed, predict the RS length using the\n+  \/\/ prediction model, otherwise use the given rs_length as the prediction.\n+  void update_young_length_bounds();\n+  void update_young_length_bounds(size_t rs_length);\n+\n+  \/\/ Calculate and return the minimum desired eden length based on the MMU target.\n+  uint calculate_desired_eden_length_by_mmu() const;\n+\n+  \/\/ Calculate the desired eden length meeting the pause time goal.\n+  \/\/ The parameters are: rs_length represents the prediction of how large the\n+  \/\/ young RSet lengths will be, min_eden_length and max_eden_length are the bounds\n+  \/\/ (inclusive) within eden can grow.\n+  uint calculate_desired_eden_length_by_pause(double base_time_ms,\n+                                              uint min_eden_length,\n+                                              uint max_eden_length) const;\n+\n+  \/\/ Calculate the desired eden length that can fit into the pause time\n+  \/\/ goal before young only gcs.\n+  uint calculate_desired_eden_length_before_young_only(double base_time_ms,\n+                                                       uint min_eden_length,\n+                                                       uint max_eden_length) const;\n+\n+  \/\/ Calculates the desired eden length before mixed gc so that after adding the\n+  \/\/ minimum amount of old gen regions from the collection set, the eden fits into\n+  \/\/ the pause time goal.\n+  uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+                                                  uint min_eden_length,\n+                                                  uint max_eden_length) const;\n+\n+  \/\/ Calculate desired young length based on current situation without taking actually\n+  \/\/ available free regions into account.\n+  uint calculate_young_desired_length(size_t rs_length) const;\n+  \/\/ Limit the given desired young length to available free regions.\n+  uint calculate_young_target_length(uint desired_young_length) const;\n+  \/\/ The GCLocker might cause us to need more regions than the target. Calculate\n+  \/\/ the maximum number of regions to use in that case.\n+  uint calculate_young_max_length(uint target_young_length) const;\n@@ -384,0 +384,1 @@\n+  uint young_list_desired_length() const { return _young_list_desired_length; }\n@@ -444,2 +445,0 @@\n-  void update_max_gc_locker_expansion();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"}]}