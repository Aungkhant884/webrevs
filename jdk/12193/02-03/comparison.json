{"files":[{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -116,2 +117,4 @@\n-    \/\/ Accessing this variable is mostly done under synchronization as\n-    \/\/ constructs like VarHandle and AtomicBoolean are not available at this stage.\n+    \/\/ Accessing this variable is made through Unsafe in order to use the\n+    \/\/ memory semantics that preserves ordering and visibility across threads.\n+    \/\/\n+    \/\/ Used reflectively via Unsafe\n@@ -129,2 +132,1 @@\n-           URI uri)\n-    {\n+           URI uri) {\n@@ -181,2 +183,0 @@\n-     *\n-     * @see ClassLoader#getUnnamedModule()\n@@ -184,0 +184,1 @@\n+     * @see ClassLoader#getUnnamedModule()\n@@ -208,3 +209,1 @@\n-     *\n-     * @throws SecurityException\n-     *         If denied by the security manager\n+     * @throws SecurityException If denied by the security manager\n@@ -234,1 +233,1 @@\n-     *\n+     * <p>\n@@ -243,1 +242,0 @@\n-     *\n@@ -264,1 +262,1 @@\n-        trySetEnableNativeAccess(this);\n+        AccessHolder.trySetEnableNativeAccess(this);\n@@ -272,2 +270,0 @@\n-     * @since 20\n-     *\n@@ -275,0 +271,1 @@\n+     * @since 20\n@@ -276,1 +273,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -279,1 +276,1 @@\n-        return isNativeAccessEnabled(target);\n+        return AccessHolder.isNativeAccessEnabled(target);\n@@ -282,5 +279,17 @@\n-    private static boolean isNativeAccessEnabled(Module target) {\n-        if (target.enableNativeAccess)\n-            return true;\n-        synchronized(target) {\n-            return target.enableNativeAccess;\n+    \/\/ This class is used to be able to bootstrap without using Unsafe\n+    \/\/ in the outer Module class as that would create a circular initializer dependency\n+    private static final class AccessHolder {\n+\n+        private AccessHolder() {}\n+\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+        private static final long FIELD_OFFSET = UNSAFE.objectFieldOffset(Module.class, \"enableNativeAccess\");\n+\n+        private static boolean isNativeAccessEnabled(Module target) {\n+            return UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n+        }\n+\n+        \/\/ Atomically sets enableNativeAccess if not already set\n+        \/\/ returning if the value was updated\n+        private static boolean trySetEnableNativeAccess(Module target) {\n+            return UNSAFE.compareAndSetBoolean(target, FIELD_OFFSET, false, true);\n@@ -300,1 +309,1 @@\n-        if (!isNativeAccessEnabled(target)) {\n+        if (!AccessHolder.isNativeAccessEnabled(target)) {\n@@ -303,13 +312,0 @@\n-            } else {\n-                if (trySetEnableNativeAccess(target)) {\n-                    \/\/ warn and set flag, so that only one warning is reported per module\n-                    String cls = owner.getName();\n-                    String mtd = cls + \"::\" + methodName;\n-                    String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n-                    String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n-                    System.err.printf(\"\"\"\n-                            WARNING: A restricted method in %s has been called\n-                            WARNING: %s has been called by %s\n-                            WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                            %n\"\"\", cls, mtd, mod, modflag);\n-                }\n@@ -317,10 +313,11 @@\n-        }\n-    }\n-\n-    \/\/ Atomically sets enableNativeAccess if not already set\n-    \/\/ returning if the value was updated\n-    private static boolean trySetEnableNativeAccess(Module target) {\n-        synchronized (target) {\n-            if (!target.enableNativeAccess) {\n-                target.enableNativeAccess = true;\n-                return true;\n+            if (AccessHolder.trySetEnableNativeAccess(target)) {\n+                \/\/ warn and set flag, so that only one warning is reported per module\n+                String cls = owner.getName();\n+                String mtd = cls + \"::\" + methodName;\n+                String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+                System.err.printf(\"\"\"\n+                        WARNING: A restricted method in %s has been called\n+                        WARNING: %s has been called by %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n+                        %n\"\"\", cls, mtd, mod, modflag);\n@@ -329,1 +326,0 @@\n-        return false;\n@@ -336,1 +332,1 @@\n-        trySetEnableNativeAccess(ALL_UNNAMED_MODULE);\n+        AccessHolder.trySetEnableNativeAccess(ALL_UNNAMED_MODULE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":43,"deletions":47,"binary":false,"changes":90,"status":"modified"}]}