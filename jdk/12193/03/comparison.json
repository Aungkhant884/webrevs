{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -116,0 +117,4 @@\n+    \/\/ Accessing this variable is made through Unsafe in order to use the\n+    \/\/ memory semantics that preserves ordering and visibility across threads.\n+    \/\/\n+    \/\/ Used reflectively via Unsafe\n@@ -127,2 +132,1 @@\n-           URI uri)\n-    {\n+           URI uri) {\n@@ -179,2 +183,0 @@\n-     *\n-     * @see ClassLoader#getUnnamedModule()\n@@ -182,0 +184,1 @@\n+     * @see ClassLoader#getUnnamedModule()\n@@ -206,3 +209,1 @@\n-     *\n-     * @throws SecurityException\n-     *         If denied by the security manager\n+     * @throws SecurityException If denied by the security manager\n@@ -232,1 +233,1 @@\n-     *\n+     * <p>\n@@ -241,1 +242,0 @@\n-     *\n@@ -261,2 +261,2 @@\n-    synchronized Module implAddEnableNativeAccess() {\n-        enableNativeAccess = true;\n+    Module implAddEnableNativeAccess() {\n+        AccessHolder.trySetEnableNativeAccess(this);\n@@ -270,2 +270,0 @@\n-     * @since 20\n-     *\n@@ -273,0 +271,1 @@\n+     * @since 20\n@@ -274,1 +273,1 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -277,2 +276,20 @@\n-        synchronized(target) {\n-            return target.enableNativeAccess;\n+        return AccessHolder.isNativeAccessEnabled(target);\n+    }\n+\n+    \/\/ This class is used to be able to bootstrap without using Unsafe\n+    \/\/ in the outer Module class as that would create a circular initializer dependency\n+    private static final class AccessHolder {\n+\n+        private AccessHolder() {}\n+\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+        private static final long FIELD_OFFSET = UNSAFE.objectFieldOffset(Module.class, \"enableNativeAccess\");\n+\n+        private static boolean isNativeAccessEnabled(Module target) {\n+            return UNSAFE.getBooleanVolatile(target, FIELD_OFFSET);\n+        }\n+\n+        \/\/ Atomically sets enableNativeAccess if not already set\n+        \/\/ returning if the value was updated\n+        private static boolean trySetEnableNativeAccess(Module target) {\n+            return UNSAFE.compareAndSetBoolean(target, FIELD_OFFSET, false, true);\n@@ -292,20 +309,11 @@\n-        \/\/ racy read of the enable native access flag\n-        boolean isNativeAccessEnabled = target.enableNativeAccess;\n-        if (!isNativeAccessEnabled) {\n-            synchronized (target) {\n-                \/\/ safe read of the enableNativeAccess of the target module\n-                isNativeAccessEnabled = target.enableNativeAccess;\n-\n-                \/\/ check again with the safely read flag\n-                if (isNativeAccessEnabled) {\n-                    \/\/ another thread beat us to it - nothing to do\n-                    return;\n-                } else if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                    throw new IllegalCallerException(\"Illegal native access from: \" + this);\n-                } else {\n-                    \/\/ warn and set flag, so that only one warning is reported per module\n-                    String cls = owner.getName();\n-                    String mtd = cls + \"::\" + methodName;\n-                    String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n-                    String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n-                    System.err.printf(\"\"\"\n+        if (!AccessHolder.isNativeAccessEnabled(target)) {\n+            if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n+                throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+            }\n+            if (AccessHolder.trySetEnableNativeAccess(target)) {\n+                \/\/ warn and set flag, so that only one warning is reported per module\n+                String cls = owner.getName();\n+                String mtd = cls + \"::\" + methodName;\n+                String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                String modflag = isNamed() ? getName() : \"ALL-UNNAMED\";\n+                System.err.printf(\"\"\"\n@@ -316,4 +324,0 @@\n-\n-                    \/\/ set the flag\n-                    target.enableNativeAccess = true;\n-                }\n@@ -324,1 +328,0 @@\n-\n@@ -329,3 +332,1 @@\n-        synchronized (ALL_UNNAMED_MODULE) {\n-            ALL_UNNAMED_MODULE.enableNativeAccess = true;\n-        }\n+        AccessHolder.trySetEnableNativeAccess(ALL_UNNAMED_MODULE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":46,"deletions":45,"binary":false,"changes":91,"status":"modified"}]}