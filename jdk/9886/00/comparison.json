{"files":[{"patch":"@@ -378,1 +378,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(THREAD, name, Handle(), Handle());\n@@ -531,1 +531,1 @@\n-      kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain);\n+      kls = SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -575,12 +575,0 @@\n-int ClassLoaderDataGraph::resize_dictionaries() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint!\");\n-  int resized = 0;\n-  assert (Dictionary::does_any_dictionary_needs_resizing(), \"some dictionary should need resizing\");\n-  FOR_ALL_DICTIONARY(cld) {\n-    if (cld->dictionary()->resize_if_needed()) {\n-      resized++;\n-    }\n-  }\n-  return resized;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -107,2 +107,0 @@\n-  static int resize_dictionaries();\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n@@ -48,1 +49,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/tableStatistics.hpp\"\n@@ -50,4 +51,4 @@\n-\/\/ Optimization: if any dictionary needs resizing, we set this flag,\n-\/\/ so that we don't have to walk all dictionaries to check if any actually\n-\/\/ needs resizing, which is costly to do at Safepoint.\n-bool Dictionary::_some_dictionary_needs_resizing = false;\n+\/\/ 2^24 is max size, like StringTable.\n+const size_t END_SIZE = 24;\n+\/\/ If a chain gets to 100 something might be wrong\n+const size_t REHASH_LEN = 100;\n@@ -56,4 +57,1 @@\n-  : Hashtable<InstanceKlass*, mtClass>(table_size, (int)sizeof(DictionaryEntry)),\n-    _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {\n-};\n-\n+  : _resizable(resizable), _number_of_entries(0), _loader_data(loader_data) {\n@@ -61,6 +59,6 @@\n-Dictionary::Dictionary(ClassLoaderData* loader_data,\n-                       int table_size, HashtableBucket<mtClass>* t,\n-                       int number_of_entries, bool resizable)\n-  : Hashtable<InstanceKlass*, mtClass>(table_size, (int)sizeof(DictionaryEntry), t, number_of_entries),\n-    _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {\n-};\n+  size_t start_size_log_2 = MAX2(ceil_log2(table_size), (size_t)2); \/\/ 2 is minimum size even though some dictionaries only have one entry\n+  size_t current_size = ((size_t)1) << start_size_log_2;\n+  log_info(class, loader, data)(\"Dictionary start size: \" SIZE_FORMAT \" (\" SIZE_FORMAT \")\",\n+                                current_size, start_size_log_2);\n+  _table = new ConcurrentTable(start_size_log_2, END_SIZE, REHASH_LEN);\n+}\n@@ -69,9 +67,6 @@\n-  DictionaryEntry* probe = NULL;\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry** p = bucket_addr(index); *p != NULL; ) {\n-      probe = *p;\n-      *p = probe->next();\n-      free_entry(probe);\n-    }\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  \/\/ This deletes the table and all the nodes, by calling free_node in Config.\n+  delete _table;\n+}\n+\n+uintx Dictionary::Config::get_hash(Value const& value, bool* is_dead) {\n+  return value->instance_klass()->name()->identity_hash();\n@@ -80,5 +75,2 @@\n-DictionaryEntry* Dictionary::new_entry(unsigned int hash, InstanceKlass* klass) {\n-  DictionaryEntry* entry = (DictionaryEntry*)Hashtable<InstanceKlass*, mtClass>::new_entry(hash, klass);\n-  entry->release_set_pd_set(NULL);\n-  assert(klass->is_instance_klass(), \"Must be\");\n-  return entry;\n+void* Dictionary::Config::allocate_node(void* context, size_t size, Value const& value) {\n+  return AllocateHeap(size, mtClass);\n@@ -87,1 +79,10 @@\n-void Dictionary::free_entry(DictionaryEntry* entry) {\n+void Dictionary::Config::free_node(void* context, void* memory, Value const& value) {\n+  delete value; \/\/ Call DictionaryEntry destructor\n+  FreeHeap(memory);\n+}\n+\n+DictionaryEntry::DictionaryEntry(InstanceKlass* klass) : _instance_klass(klass) {\n+  release_set_pd_set(nullptr);\n+}\n+\n+DictionaryEntry::~DictionaryEntry() {\n@@ -92,3 +93,3 @@\n-  while (entry->pd_set_acquire() != NULL) {\n-    ProtectionDomainEntry* to_delete = entry->pd_set_acquire();\n-    entry->release_set_pd_set(to_delete->next_acquire());\n+  while (pd_set_acquire() != NULL) {\n+    ProtectionDomainEntry* to_delete = pd_set_acquire();\n+    release_set_pd_set(to_delete->next_acquire());\n@@ -97,1 +98,0 @@\n-  BasicHashtable<mtClass>::free_entry(entry);\n@@ -102,2 +102,2 @@\n-bool Dictionary::does_any_dictionary_needs_resizing() {\n-  return Dictionary::_some_dictionary_needs_resizing;\n+int Dictionary::table_size() const {\n+  return 1 << _table->get_size_log2(Thread::current());\n@@ -106,29 +106,4 @@\n-void Dictionary::check_if_needs_resize() {\n-  if (_resizable == true) {\n-    if (number_of_entries() > (_resize_load_trigger*table_size())) {\n-      _needs_resizing = true;\n-      Dictionary::_some_dictionary_needs_resizing = true;\n-    }\n-  }\n-}\n-\n-bool Dictionary::resize_if_needed() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n-  int desired_size = 0;\n-  if (_needs_resizing == true) {\n-    desired_size = calculate_resize(false);\n-    assert(desired_size != 0, \"bug in calculate_resize\");\n-    if (desired_size == table_size()) {\n-      _resizable = false; \/\/ hit max\n-    } else {\n-      if (!resize(desired_size)) {\n-        \/\/ Something went wrong, turn resizing off\n-        _resizable = false;\n-      }\n-    }\n-  }\n-\n-  _needs_resizing = false;\n-  Dictionary::_some_dictionary_needs_resizing = false;\n-\n-  return (desired_size != 0);\n+bool Dictionary::check_if_needs_resize() {\n+  return (_resizable &&\n+         (_number_of_entries > (_resize_load_trigger * table_size())) &&\n+         !_table->is_max_size_reached());\n@@ -216,8 +191,4 @@\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n-      InstanceKlass* k = probe->instance_klass();\n-      if (loader_data() == k->class_loader_data()) {\n-        f(k);\n-      }\n+  auto doit = [&] (DictionaryEntry** value) {\n+    InstanceKlass* k = (*value)->instance_klass();\n+    if (loader_data() == k->class_loader_data()) {\n+      f(k);\n@@ -225,2 +196,2 @@\n-  }\n-}\n+    return true;\n+  };\n@@ -228,13 +199,1 @@\n-\/\/ Added for initialize_itable_for_klass to handle exceptions\n-\/\/   Just the classes from defining class loaders\n-void Dictionary::classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n-      InstanceKlass* k = probe->instance_klass();\n-      if (loader_data() == k->class_loader_data()) {\n-        f(k, CHECK);\n-      }\n-    }\n-  }\n+  _table->do_scan(Thread::current(), doit);\n@@ -245,8 +204,7 @@\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n-      InstanceKlass* k = probe->instance_klass();\n-      closure->do_klass(k);\n-    }\n-  }\n+  auto all_doit = [&] (DictionaryEntry** value) {\n+    InstanceKlass* k = (*value)->instance_klass();\n+    closure->do_klass(k);\n+    return true;\n+  };\n+\n+  _table->do_scan(Thread::current(), all_doit);\n@@ -258,8 +216,0 @@\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n-      it->push(probe->klass_addr());\n-    }\n-  }\n-}\n@@ -267,0 +217,7 @@\n+  auto push = [&] (DictionaryEntry** value) {\n+    InstanceKlass** k = (*value)->instance_klass_addr();\n+    it->push(k);\n+    return true;\n+  };\n+  _table->do_scan(Thread::current(), push);\n+}\n@@ -268,0 +225,14 @@\n+class DictionaryLookup : StackObj {\n+private:\n+  Symbol* _name;\n+public:\n+  DictionaryLookup(Symbol* name) : _name(name) { }\n+  uintx get_hash() const {\n+    return _name->identity_hash();\n+  }\n+  bool equals(DictionaryEntry** value, bool* is_dead) {\n+    DictionaryEntry *entry = *value;\n+    *is_dead = false;\n+    return (entry->instance_klass()->name() == _name);\n+  }\n+};\n@@ -270,6 +241,1 @@\n-\/\/ Readers of the SystemDictionary aren't always locked, so _buckets\n-\/\/ is volatile. The store of the next field in the constructor is\n-\/\/ also cast to volatile;  we do this to ensure store order is maintained\n-\/\/ by the compilers.\n-\n-void Dictionary::add_klass(unsigned int hash, Symbol* class_name,\n+void Dictionary::add_klass(JavaThread* current, Symbol* class_name,\n@@ -277,1 +243,1 @@\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n+  assert_locked_or_safepoint(SystemDictionary_lock); \/\/ doesn't matter now\n@@ -281,4 +247,21 @@\n-  DictionaryEntry* entry = new_entry(hash, obj);\n-  int index = hash_to_index(hash);\n-  add_entry(index, entry);\n-  check_if_needs_resize();\n+  DictionaryEntry* entry = new DictionaryEntry(obj);\n+  DictionaryLookup lookup(class_name);\n+  bool needs_rehashing, clean_hint;\n+  bool created = _table->insert(current, lookup, entry, &needs_rehashing, &clean_hint);\n+  assert(created, \"should be because we have a lock\");\n+  assert (!needs_rehashing, \"should never need rehashing\");\n+  assert(!clean_hint, \"no class should be unloaded\");\n+  _number_of_entries++;  \/\/ still locked\n+  \/\/ This table can be resized while another thread is reading it.\n+  if (check_if_needs_resize()) {\n+    _table->grow(current);\n+\n+    \/\/ It would be nice to have a JFR event here, add some logging.\n+    LogTarget(Info, class, loader, data) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(&lt);\n+      ls.print(\"Dictionary resized to %d entries %d for \", table_size(), _number_of_entries);\n+      loader_data()->print_value_on(&ls);\n+    }\n+  }\n@@ -287,1 +270,0 @@\n-\n@@ -296,2 +278,3 @@\n-\/\/ _buckets[index] is read here, so the caller will not see the new entry.\n-DictionaryEntry* Dictionary::get_entry(int index, unsigned int hash,\n+\/\/ the table is read here, so the caller will not see the new entry.\n+\/\/ The entry may be accessed by the VM thread in verification.\n+DictionaryEntry* Dictionary::get_entry(Thread* current,\n@@ -299,8 +282,10 @@\n-  for (DictionaryEntry* entry = bucket(index);\n-                        entry != NULL;\n-                        entry = entry->next()) {\n-    if (entry->hash() == hash && entry->instance_klass()->name() == class_name) {\n-      return entry;\n-    }\n-  }\n-  return NULL;\n+  DictionaryLookup lookup(class_name);\n+  DictionaryEntry* result = nullptr;\n+  auto get = [&] (DictionaryEntry** value) {\n+    \/\/ function called if value is found so is never null\n+    result = (*value);\n+  };\n+  bool needs_rehashing = false;\n+  _table->get(current, lookup, get, &needs_rehashing);\n+  assert (!needs_rehashing, \"should never need rehashing\");\n+  return result;\n@@ -310,2 +295,1 @@\n-\n-InstanceKlass* Dictionary::find(unsigned int hash, Symbol* name,\n+InstanceKlass* Dictionary::find(Thread* current, Symbol* name,\n@@ -315,2 +299,1 @@\n-  int index = hash_to_index(hash);\n-  DictionaryEntry* entry = get_entry(index, hash, name);\n+  DictionaryEntry* entry = get_entry(current, name);\n@@ -324,1 +307,1 @@\n-InstanceKlass* Dictionary::find_class(unsigned int hash,\n+InstanceKlass* Dictionary::find_class(Thread* current,\n@@ -327,5 +310,1 @@\n-\n-  int index = hash_to_index(hash);\n-  assert (index == index_for(name), \"incorrect index?\");\n-\n-  DictionaryEntry* entry = get_entry(index, hash, name);\n+  DictionaryEntry* entry = get_entry(current, name);\n@@ -335,1 +314,1 @@\n-void Dictionary::add_protection_domain(int index, unsigned int hash,\n+void Dictionary::add_protection_domain(JavaThread* current,\n@@ -340,1 +319,1 @@\n-  DictionaryEntry* entry = get_entry(index, hash, klass_name);\n+  DictionaryEntry* entry = get_entry(current, klass_name);\n@@ -357,1 +336,1 @@\n-inline bool Dictionary::is_valid_protection_domain(unsigned int hash,\n+inline bool Dictionary::is_valid_protection_domain(JavaThread* current,\n@@ -360,2 +339,1 @@\n-  int index = hash_to_index(hash);\n-  DictionaryEntry* entry = get_entry(index, hash, name);\n+  DictionaryEntry* entry = get_entry(current, name);\n@@ -365,2 +343,1 @@\n-void Dictionary::validate_protection_domain(unsigned int name_hash,\n-                                            InstanceKlass* klass,\n+void Dictionary::validate_protection_domain(InstanceKlass* klass,\n@@ -375,1 +352,1 @@\n-      is_valid_protection_domain(name_hash, klass->name(), protection_domain)) {\n+      is_valid_protection_domain(THREAD, klass->name(), protection_domain)) {\n@@ -427,2 +404,1 @@\n-    int d_index = hash_to_index(name_hash);\n-    add_protection_domain(d_index, name_hash, klass,\n+    add_protection_domain(THREAD, klass,\n@@ -436,1 +412,1 @@\n-  assert(Thread::current()->is_Java_thread(), \"only called by JavaThread\");\n+  assert(JavaThread::current()->is_Java_thread(), \"only called by JavaThread\");\n@@ -445,4 +421,2 @@\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n+  auto clean_entries = [&] (DictionaryEntry** value) {\n+      DictionaryEntry* probe = *value;\n@@ -461,1 +435,1 @@\n-            ls.print(\"class loader: \"); loader_data()->class_loader()->print_value_on(&ls);\n+            ls.print(\"class loader: \"); _loader_data->class_loader()->print_value_on(&ls);\n@@ -480,2 +454,4 @@\n-    }\n-  }\n+      return true;\n+  };\n+\n+  _table->do_scan(Thread::current(), clean_entries);\n@@ -508,1 +484,1 @@\n-               table_size(), number_of_entries(), BOOL_TO_STR(_resizable));\n+               table_size(), _number_of_entries, BOOL_TO_STR(_resizable));\n@@ -519,18 +495,14 @@\n-  for (int index = 0; index < table_size(); index++) {\n-    for (DictionaryEntry* probe = bucket(index);\n-                          probe != NULL;\n-                          probe = probe->next()) {\n-      Klass* e = probe->instance_klass();\n-      bool is_defining_class =\n-         (loader_data() == e->class_loader_data());\n-      st->print(\"%4d: %s%s\", index, is_defining_class ? \" \" : \"^\", e->external_name());\n-      ClassLoaderData* cld = e->class_loader_data();\n-      if (!loader_data()->is_the_null_class_loader_data()) {\n-        \/\/ Class loader output for the dictionary for the null class loader data is\n-        \/\/ redundant and obvious.\n-        st->print(\", \");\n-        cld->print_value_on(st);\n-        st->print(\", \");\n-        probe->print_count(st);\n-      }\n-      st->cr();\n+  auto printer = [&] (DictionaryEntry** entry) {\n+    DictionaryEntry* probe = *entry;\n+    Klass* e = probe->instance_klass();\n+    bool is_defining_class =\n+       (_loader_data == e->class_loader_data());\n+    st->print(\" %s%s\", is_defining_class ? \" \" : \"^\", e->external_name());\n+    ClassLoaderData* cld = e->class_loader_data();\n+    if (!_loader_data->is_the_null_class_loader_data()) {\n+      \/\/ Class loader output for the dictionary for the null class loader data is\n+      \/\/ redundant and obvious.\n+      st->print(\", \");\n+      cld->print_value_on(st);\n+      st->print(\", \");\n+      probe->print_count(st);\n@@ -538,1 +510,5 @@\n-  }\n+    st->cr();\n+    return true;\n+  };\n+\n+  _table->do_scan(Thread::current(), printer);\n@@ -551,1 +527,1 @@\n-  guarantee(number_of_entries() >= 0, \"Verify of dictionary failed\");\n+  guarantee(_number_of_entries >= 0, \"Verify of dictionary failed\");\n@@ -560,4 +536,15 @@\n-  ResourceMark rm;\n-  stringStream tempst;\n-  tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n-  verify_table<DictionaryEntry>(tempst.as_string());\n+  auto verifier = [&] (DictionaryEntry** val) {\n+    (*val)->verify();\n+    return true;\n+  };\n+\n+  _table->do_safepoint_scan(verifier);\n+}\n+\n+void Dictionary::print_table_statistics(outputStream* st, const char* table_name) {\n+  static TableStatistics ts;\n+  auto sz = [&] (DictionaryEntry** val) {\n+    return sizeof(**val);\n+  };\n+  ts = _table->statistics_get(Thread::current(), sz, ts);\n+  ts.print(st, table_name);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":166,"deletions":179,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/concurrentHashTable.hpp\"\n@@ -41,2 +41,1 @@\n-class Dictionary : public Hashtable<InstanceKlass*, mtClass> {\n-  friend class VMStructs;\n+class DictionaryEntry;\n@@ -44,1 +43,1 @@\n-  static bool _some_dictionary_needs_resizing;\n+class Dictionary : public CHeapObj<mtClass> {\n@@ -46,2 +45,12 @@\n-  bool _needs_resizing;\n-  void check_if_needs_resize();\n+  int _number_of_entries;\n+\n+  class Config {\n+   public:\n+    typedef DictionaryEntry* Value;\n+    static uintx get_hash(Value const& value, bool* is_dead);\n+    static void* allocate_node(void* context, size_t size, Value const& value);\n+    static void free_node(void* context, void* memory, Value const& value);\n+  };\n+\n+  using ConcurrentTable = ConcurrentHashTable<Config, mtClass>;\n+  ConcurrentTable* _table;\n@@ -52,1 +61,3 @@\n-  DictionaryEntry* get_entry(int index, unsigned int hash, Symbol* name);\n+  DictionaryEntry* get_entry(Thread* current, Symbol* name);\n+  bool check_if_needs_resize();\n+  int table_size() const;\n@@ -56,1 +67,0 @@\n-  Dictionary(ClassLoaderData* loader_data, int table_size, HashtableBucket<mtClass>* t, int number_of_entries, bool resizable = false);\n@@ -59,2 +69,1 @@\n-  static bool does_any_dictionary_needs_resizing();\n-  bool resize_if_needed();\n+  void add_klass(JavaThread* current, Symbol* class_name, InstanceKlass* obj);\n@@ -62,3 +71,1 @@\n-  void add_klass(unsigned int hash, Symbol* class_name, InstanceKlass* obj);\n-\n-  InstanceKlass* find_class(unsigned int hash, Symbol* name);\n+  InstanceKlass* find_class(Thread* current, Symbol* name);\n@@ -67,1 +74,0 @@\n-  void classes_do(void f(InstanceKlass*, TRAPS), TRAPS);\n@@ -74,3 +80,2 @@\n-  InstanceKlass* find(unsigned int hash, Symbol* name, Handle protection_domain);\n-  void validate_protection_domain(unsigned int name_hash,\n-                                  InstanceKlass* klass,\n+  InstanceKlass* find(Thread* current, Symbol* name, Handle protection_domain);\n+  void validate_protection_domain(InstanceKlass* klass,\n@@ -81,0 +86,2 @@\n+  void print_table_statistics(outputStream* st, const char* table_name);\n+\n@@ -86,15 +93,1 @@\n-  DictionaryEntry* new_entry(unsigned int hash, InstanceKlass* klass);\n-\n-  DictionaryEntry* bucket(int i) const {\n-    return (DictionaryEntry*)Hashtable<InstanceKlass*, mtClass>::bucket(i);\n-  }\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  DictionaryEntry** bucket_addr(int i) {\n-    return (DictionaryEntry**)Hashtable<InstanceKlass*, mtClass>::bucket_addr(i);\n-  }\n-\n-  void free_entry(DictionaryEntry* entry);\n-\n-  bool is_valid_protection_domain(unsigned int hash,\n-                                  Symbol* name,\n+  bool is_valid_protection_domain(JavaThread* current, Symbol* name,\n@@ -102,2 +95,1 @@\n-  void add_protection_domain(int index, unsigned int hash,\n-                             InstanceKlass* klass,\n+  void add_protection_domain(JavaThread* current, InstanceKlass* klass,\n@@ -108,1 +100,1 @@\n-\/\/ { InstanceKlass*, protection_domain }.\n+\/\/ { InstanceKlass*, protection_domain_set }.\n@@ -110,2 +102,1 @@\n-class DictionaryEntry : public HashtableEntry<InstanceKlass*, mtClass> {\n-  friend class VMStructs;\n+class DictionaryEntry : public CHeapObj<mtClass> {\n@@ -126,0 +117,1 @@\n+  InstanceKlass*                  _instance_klass;\n@@ -129,0 +121,3 @@\n+  DictionaryEntry(InstanceKlass* instance_klass);\n+  ~DictionaryEntry();\n+\n@@ -134,10 +129,2 @@\n-  InstanceKlass* instance_klass() const { return literal(); }\n-  InstanceKlass** klass_addr() { return (InstanceKlass**)literal_addr(); }\n-\n-  DictionaryEntry* next() const {\n-    return (DictionaryEntry*)HashtableEntry<InstanceKlass*, mtClass>::next();\n-  }\n-\n-  DictionaryEntry** next_addr() {\n-    return (DictionaryEntry**)HashtableEntry<InstanceKlass*, mtClass>::next_addr();\n-  }\n+  InstanceKlass* instance_klass() const { return _instance_klass; }\n+  InstanceKlass** instance_klass_addr() { return &_instance_klass; }\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":34,"deletions":47,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -444,2 +444,1 @@\n-        unsigned int name_hash = dictionary->compute_hash(name);\n-        InstanceKlass* k = dictionary->find_class(name_hash, name);\n+        InstanceKlass* k = dictionary->find_class(thread, name);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -215,6 +215,0 @@\n-static size_t ceil_log2(size_t val) {\n-  size_t ret;\n-  for (ret = 1; ((size_t)1 << ret) < val; ++ret);\n-  return ret;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,6 +164,0 @@\n-static size_t ceil_log2(size_t value) {\n-  size_t ret;\n-  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n-  return ret;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -293,2 +293,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  InstanceKlass* kk = dictionary->find_class(name_hash, class_name);\n+  InstanceKlass* kk = dictionary->find_class(JavaThread::current(), class_name);\n@@ -440,1 +439,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n@@ -446,1 +444,1 @@\n-    InstanceKlass* klassk = dictionary->find_class(name_hash, class_name);\n+    InstanceKlass* klassk = dictionary->find_class(THREAD, class_name);\n@@ -571,1 +569,0 @@\n-                                                         unsigned int name_hash,\n@@ -611,1 +608,1 @@\n-        InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+        InstanceKlass* check = loader_data->dictionary()->find_class(current, name);\n@@ -655,1 +652,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(name);\n@@ -662,1 +658,1 @@\n-  InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n+  InstanceKlass* probe = dictionary->find(THREAD, name, protection_domain);\n@@ -689,1 +685,1 @@\n-    InstanceKlass* check = dictionary->find_class(name_hash, name);\n+    InstanceKlass* check = dictionary->find_class(THREAD, name);\n@@ -737,1 +733,0 @@\n-                                               name_hash,\n@@ -747,1 +742,1 @@\n-        InstanceKlass* check = dictionary->find_class(name_hash, name);\n+        InstanceKlass* check = dictionary->find_class(THREAD, name);\n@@ -775,1 +770,1 @@\n-      loaded_class = load_instance_class(name_hash, name, class_loader, THREAD);\n+      loaded_class = load_instance_class(name, class_loader, THREAD);\n@@ -802,1 +797,1 @@\n-    dictionary->validate_protection_domain(name_hash, loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    dictionary->validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -817,1 +812,1 @@\n-\/\/ _dictionary->bucket(index) is read here, so the caller will not see\n+\/\/ Dictionary is read here, so the caller will not see\n@@ -820,1 +815,2 @@\n-InstanceKlass* SystemDictionary::find_instance_klass(Symbol* class_name,\n+InstanceKlass* SystemDictionary::find_instance_klass(Thread* current,\n+                                                     Symbol* class_name,\n@@ -837,2 +833,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  return dictionary->find(name_hash, class_name, protection_domain);\n+  return dictionary->find(current, class_name, protection_domain);\n@@ -843,1 +838,2 @@\n-Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,\n+Klass* SystemDictionary::find_instance_or_array_klass(Thread* current,\n+                                                      Symbol* class_name,\n@@ -859,1 +855,1 @@\n-      k = SystemDictionary::find_instance_klass(ss.as_symbol(), class_loader, protection_domain);\n+      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader, protection_domain);\n@@ -865,1 +861,1 @@\n-    k = find_instance_klass(class_name, class_loader, protection_domain);\n+    k = find_instance_klass(current, class_name, class_loader, protection_domain);\n@@ -1119,1 +1115,1 @@\n-    InstanceKlass* check = find_instance_klass(name, class_loader, protection_domain);\n+    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader, protection_domain);\n@@ -1410,2 +1406,1 @@\n-InstanceKlass* SystemDictionary::load_instance_class(unsigned int name_hash,\n-                                                     Symbol* name,\n+InstanceKlass* SystemDictionary::load_instance_class(Symbol* name,\n@@ -1422,1 +1417,1 @@\n-    check_constraints(name_hash, loaded_class, class_loader, false, CHECK_NULL);\n+    check_constraints(loaded_class, class_loader, false, CHECK_NULL);\n@@ -1435,1 +1430,1 @@\n-      update_dictionary(name_hash, loaded_class, class_loader);\n+      update_dictionary(THREAD, loaded_class, class_loader);\n@@ -1481,2 +1476,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(name_h);\n-  check_constraints(name_hash, k, class_loader, true, CHECK);\n+  check_constraints(k, class_loader, true, CHECK);\n@@ -1506,1 +1500,1 @@\n-    update_dictionary(name_hash, k, class_loader);\n+    update_dictionary(THREAD, k, class_loader);\n@@ -1543,2 +1537,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(name_h);\n-\n@@ -1550,1 +1542,1 @@\n-      InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n+      InstanceKlass* check = dictionary->find_class(THREAD, name_h);\n@@ -1574,1 +1566,1 @@\n-      InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n+      InstanceKlass* check = dictionary->find_class(THREAD, name_h);\n@@ -1741,2 +1733,1 @@\n-void SystemDictionary::check_constraints(unsigned int name_hash,\n-                                         InstanceKlass* k,\n+void SystemDictionary::check_constraints(InstanceKlass* k,\n@@ -1756,1 +1747,1 @@\n-    InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+    InstanceKlass* check = loader_data->dictionary()->find_class(THREAD, name);\n@@ -1800,1 +1791,1 @@\n-void SystemDictionary::update_dictionary(unsigned int hash,\n+void SystemDictionary::update_dictionary(JavaThread* current,\n@@ -1813,1 +1804,1 @@\n-    InstanceKlass* sd_check = dictionary->find_class(hash, name);\n+    InstanceKlass* sd_check = dictionary->find_class(current, name);\n@@ -1815,1 +1806,1 @@\n-      dictionary->add_klass(hash, name, k);\n+      dictionary->add_klass(current, name, k);\n@@ -1831,1 +1822,1 @@\n-  Klass* klass = find_instance_or_array_klass(class_name, class_loader,\n+  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader,\n@@ -1891,2 +1882,0 @@\n-  unsigned int name_hash1 = dictionary1->compute_hash(constraint_name);\n-\n@@ -1894,1 +1883,0 @@\n-  unsigned int name_hash2 = dictionary2->compute_hash(constraint_name);\n@@ -1896,0 +1884,1 @@\n+  JavaThread* current = JavaThread::current();\n@@ -1898,2 +1887,2 @@\n-    InstanceKlass* klass1 = dictionary1->find_class(name_hash1, constraint_name);\n-    InstanceKlass* klass2 = dictionary2->find_class(name_hash2, constraint_name);\n+    InstanceKlass* klass1 = dictionary1->find_class(current, constraint_name);\n+    InstanceKlass* klass2 = dictionary2->find_class(current, constraint_name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":33,"deletions":44,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -147,1 +147,2 @@\n-  static InstanceKlass* find_instance_klass(Symbol* class_name, Handle class_loader, Handle protection_domain);\n+  static InstanceKlass* find_instance_klass(Thread* current, Symbol* class_name,\n+                                            Handle class_loader, Handle protection_domain);\n@@ -152,1 +153,1 @@\n-  static Klass* find_instance_or_array_klass(Symbol* class_name,\n+  static Klass* find_instance_or_array_klass(Thread* current, Symbol* class_name,\n@@ -327,1 +328,0 @@\n-                                                unsigned int name_hash,\n@@ -338,2 +338,1 @@\n-  static InstanceKlass* load_instance_class(unsigned int name_hash,\n-                                            Symbol* class_name,\n+  static InstanceKlass* load_instance_class(Symbol* class_name,\n@@ -403,2 +402,1 @@\n-  static void check_constraints(unsigned int hash,\n-                                InstanceKlass* k, Handle loader,\n+  static void check_constraints(InstanceKlass* k, Handle loader,\n@@ -406,2 +404,1 @@\n-  static void update_dictionary(unsigned int hash,\n-                                InstanceKlass* k, Handle loader);\n+  static void update_dictionary(JavaThread* current, InstanceKlass* k, Handle loader);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -405,1 +405,0 @@\n-      unsigned int d_hash = dictionary->compute_hash(name);\n@@ -413,1 +412,1 @@\n-        InstanceKlass* check = dictionary->find_class(d_hash, name);\n+        InstanceKlass* check = dictionary->find_class(THREAD, name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,2 +250,1 @@\n-  unsigned int hash = dictionary->compute_hash(klass->name());\n-  dictionary->add_klass(hash, klass->name(), klass);\n+  dictionary->add_klass(THREAD, klass->name(), klass);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-      resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+      resolved_klass = SystemDictionary::find_instance_klass(THREAD, strippedsym,\n@@ -527,1 +527,1 @@\n-        resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+        resolved_klass = SystemDictionary::find_instance_klass(THREAD, strippedsym,\n@@ -537,1 +537,1 @@\n-      resolved_klass = SystemDictionary::find_instance_klass(class_name,\n+      resolved_klass = SystemDictionary::find_instance_klass(THREAD, class_name,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1666,1 +1666,1 @@\n-      found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain);\n+      found_klass = SystemDictionary::find_instance_or_array_klass(THREAD, sym, loader, domain);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-    Klass* k = SystemDictionary::find_instance_klass(name, h_loader, h_prot);\n+    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader, h_prot);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-    return SystemDictionary::find_instance_klass(klass_name, loader, prot) != NULL;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != NULL;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1098,3 +1098,3 @@\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,\n-                                                              h_loader,\n-                                                              Handle());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name,\n+                                                            h_loader,\n+                                                            Handle());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-  static InstanceKlass* find_cache_klass(Symbol* klass_name) {\n+  static InstanceKlass* find_cache_klass(Thread* thread, Symbol* klass_name) {\n@@ -964,1 +964,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle(), Handle());\n@@ -979,1 +979,1 @@\n-    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(CacheType::symbol());\n+    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(thread, CacheType::symbol());\n@@ -1035,1 +1035,1 @@\n-    InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol());\n+    InstanceKlass* ik = find_cache_klass(thread, java_lang_Boolean::symbol());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/dictionary.hpp\"\n@@ -563,7 +562,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE)) {\n-      if (Dictionary::does_any_dictionary_needs_resizing()) {\n-        Tracer t(\"resizing system dictionaries\");\n-        ClassLoaderDataGraph::resize_dictionaries();\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-    k = SystemDictionary::find_instance_klass(name, class_loader, protection_domain);\n+    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader, protection_domain);\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-  InstanceKlass* ik = SystemDictionary::find_instance_klass(vmSymbols::java_lang_VersionProps(),\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(THREAD, vmSymbols::java_lang_VersionProps(),\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,6 +169,0 @@\n-static size_t ceil_log2(size_t value) {\n-  size_t ret;\n-  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n-  return ret;\n-}\n-\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-static size_t ceil_log2(size_t val) {\n-  size_t ret;\n-  for (ret = 1; ((size_t)1 << ret) < val; ++ret);\n-  return ret;\n-}\n-\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1232,1 +1232,5 @@\n-  return TableStatistics(*_stats_rate, summary, literal_bytes, sizeof(Bucket), sizeof(Node));\n+  if (_stats_rate == nullptr) {\n+    return TableStatistics(summary, literal_bytes, sizeof(Bucket), sizeof(Node));\n+  } else {\n+    return TableStatistics(*_stats_rate, summary, literal_bytes, sizeof(Bucket), sizeof(Node));\n+  }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1136,0 +1136,6 @@\n+\/\/ Find log2 value greater than this input\n+inline size_t ceil_log2(size_t value) {\n+  size_t ret;\n+  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n+  return ret;\n+}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -266,1 +266,0 @@\n-template void BasicHashtable<mtClass>::verify_table<DictionaryEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-                                                              \"-Xlog:safepoint+cleanup\",\n+                                                              \"-Xlog:safepoint+cleanup,class+loader+data\",\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestResize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command VM.systemdictionary which prints dictionary stats\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          jdk.compiler\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng DictionaryStatsTest\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.lang.ref.Reference;\n+\n+public class DictionaryStatsTest {\n+\n+    \/\/ Expecting some output like:\n+\n+    \/\/ System Dictionary for 'TestClassLoader' @10ba88b9 class loader statistics:\n+    \/\/ Number of buckets       :       128 =      1024 bytes, each 8\n+    \/\/ Number of entries       :         6 =        96 bytes, each 16\n+    \/\/ Number of literals      :         6 =        96 bytes, avg  16.000\n+    \/\/ Total footprint         :           =      1216 bytes\n+    \/\/ Average bucket size     :     0.047\n+    \/\/ Variance of bucket size :     0.045\n+    \/\/ Std. dev. of bucket size:     0.211\n+    \/\/ Maximum bucket size     :         1\n+\n+    public void run(CommandExecutor executor) throws ClassNotFoundException {\n+\n+        ClassLoader named_cl = new TestClassLoader(\"TestClassLoader\", null);\n+        Class<?> c2 = Class.forName(\"TestClass2\", true, named_cl);\n+        if (c2.getClassLoader() != named_cl) {\n+            Assert.fail(\"TestClass defined by wrong classloader: \" + c2.getClassLoader());\n+        }\n+\n+        \/\/ First test: simple output, no classes displayed\n+        OutputAnalyzer output = executor.execute(\"VM.systemdictionary\");\n+        output.shouldContain(\"System Dictionary for 'bootstrap'\");\n+        output.shouldMatch(\"System Dictionary for 'TestClassLoader'\");\n+        output.shouldContain(\"class loader statistics:\");\n+        output.shouldContain(\"Number of buckets\");\n+        output.shouldContain(\"Number of entries\");\n+        output.shouldContain(\"Number of literals\");\n+        output.shouldContain(\"Total footprint\");\n+        output.shouldContain(\"Average bucket size\");\n+        output.shouldContain(\"Variance of bucket size\");\n+        output.shouldContain(\"Std. dev. of bucket size\");\n+        output.shouldContain(\"Maximum bucket size\");\n+\n+        \/\/ what is this?\n+        Reference.reachabilityFence(named_cl);\n+    }\n+\n+    static class TestClassLoader extends ClassLoader {\n+\n+        public TestClassLoader() {\n+            super();\n+        }\n+\n+        public TestClassLoader(String name, ClassLoader parent) {\n+            super(name, parent);\n+        }\n+\n+        public static final String CLASS_NAME = \"TestClass2\";\n+\n+        static ByteBuffer readClassFile(String name)\n+        {\n+            File f = new File(System.getProperty(\"test.classes\", \".\"),\n+                              name);\n+            try (FileInputStream fin = new FileInputStream(f);\n+                 FileChannel fc = fin.getChannel())\n+            {\n+                return fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());\n+            } catch (IOException e) {\n+                Assert.fail(\"Can't open file: \" + name, e);\n+            }\n+\n+            \/* Will not reach here as Assert.fail() throws exception *\/\n+            return null;\n+        }\n+\n+        protected Class<?> loadClass(String name, boolean resolve)\n+            throws ClassNotFoundException\n+        {\n+            Class<?> c;\n+            if (!CLASS_NAME.equals(name)) {\n+                c = super.loadClass(name, resolve);\n+            } else {\n+                \/\/ should not delegate to the system class loader\n+                c = findClass(name);\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+            }\n+            return c;\n+        }\n+\n+        protected Class<?> findClass(String name)\n+            throws ClassNotFoundException\n+        {\n+            if (!CLASS_NAME.equals(name)) {\n+                throw new ClassNotFoundException(\"Unexpected class: \" + name);\n+            }\n+            return defineClass(name, readClassFile(name + \".class\"), null);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void jmx() throws ClassNotFoundException {\n+        run(new JMXExecutor());\n+    }\n+\n+}\n+\n+class TestClass2 {\n+    static {\n+        Runnable r = () -> System.out.println(\"Hello\");\n+        r.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/DictionaryStatsTest.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}