{"files":[{"patch":"@@ -85,0 +85,2 @@\n+TOOL_GENERATEZIP = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+    build.tools.generatezip.GenerateZip\n","filename":"make\/ToolsJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+include ..\/ToolsJdk.gmk\n+\n@@ -137,0 +139,2 @@\n+  # For reproducible builds the zip does not support SOURCE_DATE_EPOCH and will not\n+  # produce determinsitic output, instead use GenerateZip jdk tool to create final zip.\n@@ -159,0 +163,1 @@\n+\t$(RM) -r $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1 && $(MKDIR) -p $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/files\n@@ -161,1 +166,1 @@\n-\t    (cd $$s && $(ZIPEXE) -qru $$($1_ZIP_OPTIONS) $$@ . \\\n+\t    (cd $$s && $(ZIPEXE) -qru $$($1_ZIP_OPTIONS) $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip . \\\n@@ -166,1 +171,8 @@\n-\t) true \\\n+\t) true\n+\t$$(call ExecuteWithLog, \\\n+\t    $$(SUPPORT_OUTPUTDIR)\/generatezip\/$$(patsubst $$(OUTPUTDIR)\/%,%, $$@), \\\n+\t    (cd $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/files && \\\n+\t        $(RM) $$@ && \\\n+\t        $(UNZIP) -q $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip && \\\n+\t        $(TOOL_GENERATEZIP) -f $$@ . \\\n+\t))$$(NEWLINE) \\\n","filename":"make\/common\/ZipArchive.gmk","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.generatezip;\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+\/**\n+ * Generate a zip file in a \"reproducible\" manner from the input files or directory.\n+ * Standard zip tools rely on OS file list querying whose ordering varies by platform architecture,\n+ * this class ensures the zip entries are sorted and also supports SOURCE_DATE_EPOCH timestamps.\n+ *\/\n+public class GenerateZip {\n+    String fname = null;\n+    String zname = \"\";\n+    List<String> files = new ArrayList<>();;\n+    boolean verbose = false;\n+\n+    Set<File> entries = new LinkedHashSet<>();\n+\n+    private boolean ok;\n+\n+    \/* Cache SOURCE_DATE_EPOCH if set for reproducible Jar content *\/\n+    private static long sourceDateEpochMillis = -1;\n+    static {\n+        String env = System.getenv(\"SOURCE_DATE_EPOCH\");\n+        if (env != null) {\n+            try {\n+                long value = Long.parseLong(env);\n+                \/\/ SOURCE_DATE_EPOCH is in seconds\n+                sourceDateEpochMillis = value*1000;\n+            } catch(NumberFormatException e) {\n+                sourceDateEpochMillis = -1;\n+            }\n+        }\n+    }\n+\n+    public GenerateZip() {\n+    }\n+\n+    public synchronized boolean run(String args[]) {\n+        ok = true;\n+        if (!parseArgs(args)) {\n+            return false;\n+        }\n+        try {\n+            zname = fname.replace(File.separatorChar, '\/');\n+            if (zname.startsWith(\".\/\")) {\n+                zname = zname.substring(2);\n+            }\n+\n+            if (verbose) System.out.println(\"Files or directories to zip: \"+files);\n+\n+            File zipFile = new File(fname);\n+            \/\/ Check archive to create does not exist\n+            if (!zipFile.exists()) {\n+                \/\/ Process Files\n+                for(String file : files) {\n+                    Path filepath = Paths.get(file);\n+                    processFiles(filepath);\n+                }\n+\n+                FileOutputStream out = new FileOutputStream(fname);\n+                boolean createOk = create(new BufferedOutputStream(out, 4096));\n+                if (ok) {\n+                    ok = createOk;\n+                }\n+                out.close();\n+            } else {\n+                error(\"Target zip file \"+fname+\" already exists.\");\n+                ok = false;\n+            }\n+        } catch (IOException e) {\n+            fatalError(e);\n+            ok = false;\n+        } catch (Error ee) {\n+            ee.printStackTrace();\n+            ok = false;\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            ok = false;\n+        }\n+        return ok;\n+    }\n+\n+    boolean parseArgs(String args[]) {\n+        try {\n+            boolean parsingIncludes = false;\n+            boolean parsingExcludes = false;\n+            int count = 0;\n+            while(count < args.length) {\n+                if (args[count].startsWith(\"-\")) {\n+                    String flag = args[count].substring(1);\n+                    switch (flag.charAt(0)) {\n+                    case 'f':\n+                        fname = args[++count];\n+                        break;\n+                    case 'v':\n+                        verbose = true;\n+                        break;\n+                    default:\n+                        error(String.format(\"Illegal option -%s\", String.valueOf(flag.charAt(0))));\n+                        usageError();\n+                        return false;\n+                    }\n+                } else {\n+                    \/\/ file or dir to zip\n+                    files.add(args[count]);\n+                }\n+                count++;\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            usageError();\n+            return false;\n+        }\n+        if (fname == null) {\n+            error(String.format(\"-f <archiveName> must be specified\"));\n+            usageError();\n+            return false;\n+        }\n+        \/\/ If no files specified then default to current directory\n+        if (files.size() == 0) {\n+            error(\"No input directory or files were specified\");\n+            usageError();\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Walk tree matching files and adding to entries list\n+    void processFiles(Path path) throws IOException {\n+        File fpath = path.toFile();\n+        boolean pathIsDir = fpath.isDirectory();\n+\n+        \/\/ Keep a sorted Set of files to be processed, so that the Jmod is reproducible\n+        \/\/ as Files.walkFileTree order is not defined\n+        SortedMap<String, Path> filesToProcess  = new TreeMap<String, Path>();\n+\n+        Files.walkFileTree(path, Set.of(FileVisitOption.FOLLOW_LINKS),\n+            Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                    throws IOException\n+                {\n+                    Path relPath;\n+                    String name;\n+                    if (pathIsDir) {\n+                        relPath = path.relativize(file);\n+                        name = relPath.toString();\n+                    } else {\n+                        relPath = file;\n+                        name = file.toString();\n+                    }\n+                    filesToProcess.put(name, file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+        });\n+\n+        \/\/ Process files in sorted order\n+        Iterator<Map.Entry<String, Path>> itr = filesToProcess.entrySet().iterator();\n+        while(itr.hasNext()) {\n+            Map.Entry<String, Path> entry = itr.next();\n+            String name = entry.getKey();\n+            Path   filepath = entry.getValue();\n+\n+            File f = filepath.toFile();\n+            entries.add(f);\n+        }\n+    }\n+\n+    \/\/ Create new zip from entries\n+    boolean create(OutputStream out) throws IOException\n+    {\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n+            for (File file: entries) {\n+                addFile(zos, file);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ Ensure a consistent entry name format\n+    String entryName(String name) {\n+        name = name.replace(File.separatorChar, '\/');\n+\n+        if (name.startsWith(\"\/\")) {\n+            name = name.substring(1);\n+        } else if (name.startsWith(\".\/\")) {\n+            name = name.substring(2);\n+        }\n+        return name;\n+    }\n+\n+    \/\/ Add File to Zip\n+    void addFile(ZipOutputStream zos, File file) throws IOException {\n+        String name = file.getPath();\n+        boolean isDir = file.isDirectory();\n+        if (isDir) {\n+            name = name.endsWith(File.separator) ? name : (name + File.separator);\n+        }\n+        name = entryName(name);\n+\n+        if (name.equals(\"\") || name.equals(\".\") || name.equals(zname)) {\n+            return;\n+        }\n+\n+        long size = isDir ? 0 : file.length();\n+\n+        if (verbose) {\n+            System.out.println(\"Adding: \"+name);\n+        }\n+\n+        ZipEntry e = new ZipEntry(name);\n+        \/\/ If we are adding a new entry and SOURCE_DATE_EPOCH is set then use that time\n+        if (sourceDateEpochMillis != -1) {\n+            e.setTime(sourceDateEpochMillis);\n+        } else {\n+            e.setTime(file.lastModified());\n+        }\n+        if (size == 0) {\n+            e.setMethod(ZipEntry.STORED);\n+            e.setSize(0);\n+            e.setCrc(0);\n+        }\n+        zos.putNextEntry(e);\n+        if (!isDir) {\n+            byte[] buf = new byte[8192];\n+            int len;\n+            InputStream is = new BufferedInputStream(new FileInputStream(file));\n+            while ((len = is.read(buf, 0, buf.length)) != -1) {\n+                zos.write(buf, 0, len);\n+            }\n+            is.close();\n+        }\n+        zos.closeEntry();\n+    }\n+\n+    void usageError() {\n+        error(\n+        \"Usage: GenerateZip [-v] -f <zip_file> <files_or_directories>\\n\" +\n+        \"Options:\\n\" +\n+        \"   -v  verbose output\\n\" +\n+        \"   -f  specify archive file name to create\\n\" +\n+        \"If any file is a directory then it is processed recursively.\\n\");\n+    }\n+\n+    void fatalError(Exception e) {\n+        e.printStackTrace();\n+    }\n+\n+    protected void error(String s) {\n+        System.err.println(s);\n+    }\n+\n+    public static String[] parse(String[] args)\n+    {\n+        ArrayList<String> newArgs = new ArrayList<String>(args.length);\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i];\n+            newArgs.add(arg);\n+        }\n+        return newArgs.toArray(new String[newArgs.size()]);\n+    }\n+\n+    public static void main(String args[]) {\n+        GenerateZip z = new GenerateZip();\n+        System.exit(z.run(args) ? 0 : 1);\n+    }\n+}\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatezip\/GenerateZip.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -37,0 +37,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -83,0 +85,27 @@\n+    \/* Cache SOURCE_DATE_EPOCH if set for reproducible Zip content *\/\n+    private static final long sourceDateEpochMillis = getSourceDateEpochMillis();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static long getSourceDateEpochMillis() {\n+        long sourceDateEpoch = AccessController.doPrivileged(\n+            new PrivilegedAction<Long> () {\n+                public Long run() {\n+                    long value;\n+                    String env = System.getenv(\"SOURCE_DATE_EPOCH\");\n+                    if (env != null) {\n+                        try {\n+                            value = Long.parseLong(env);\n+                            \/\/ SOURCE_DATE_EPOCH is in seconds\n+                            value *= 1000;\n+                        } catch(NumberFormatException e) {\n+                            value = -1;\n+                        }\n+                    } else {\n+                        value = -1;\n+                    }\n+                    return new Long(value);\n+                }\n+            }).longValue();\n+        return sourceDateEpoch;\n+    }\n+\n@@ -203,1 +232,7 @@\n-            e.setTime(System.currentTimeMillis());\n+            if (sourceDateEpochMillis != -1) {\n+                \/\/ sourceDateEpochMillis is set so use as new entry time\n+                e.setTime(sourceDateEpochMillis);\n+            } else {\n+                \/\/ set ZipEntry time to current time\n+                e.setTime(System.currentTimeMillis());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,15 @@\n+    \/* Cache SOURCE_DATE_EPOCH if set for reproducible Jar content *\/\n+    private static long sourceDateEpochMillis = -1;\n+    static {\n+        String env = System.getenv(\"SOURCE_DATE_EPOCH\");\n+        if (env != null) {\n+            try {\n+                long value = Long.parseLong(env);\n+                \/\/ SOURCE_DATE_EPOCH is in seconds\n+                sourceDateEpochMillis = value*1000;\n+            } catch(NumberFormatException e) {\n+                sourceDateEpochMillis = -1;\n+            }\n+        }\n+    }\n+\n@@ -778,0 +793,3 @@\n+        \/\/ Ensure files list is sorted for reproducible jar content\n+        Arrays.sort(files);\n+\n@@ -849,1 +867,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                e.setTime(getCurrentTimeMillis());\n@@ -854,1 +872,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                e.setTime(getCurrentTimeMillis());\n@@ -1020,1 +1038,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        e.setTime(getCurrentTimeMillis());\n@@ -1039,1 +1057,1 @@\n-            e.setTime(System.currentTimeMillis());\n+            e.setTime(getCurrentTimeMillis());\n@@ -1064,1 +1082,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        e.setTime(getCurrentTimeMillis());\n@@ -1185,1 +1203,6 @@\n-        e.setTime(file.lastModified());\n+        \/\/ If we are adding a new entry and SOURCE_DATE_EPOCH is set then use that time\n+        if (sourceDateEpochMillis != -1) {\n+            e.setTime(sourceDateEpochMillis);\n+        } else {\n+            e.setTime(file.lastModified());\n+        }\n@@ -2264,0 +2287,8 @@\n+    \/\/ Support SOURCE_DATE_EPOCH env for new entry times\n+    private static long getCurrentTimeMillis() {\n+        if (sourceDateEpochMillis != -1) {\n+          return sourceDateEpochMillis;\n+        } else {\n+          return System.currentTimeMillis();\n+        }\n+    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -770,0 +770,4 @@\n+            \/\/ Keep a sorted Set of files to be processed, so that the Jmod is reproducible\n+            \/\/ as Files.walkFileTree order is not defined\n+            SortedMap<String, Path> filesToProcess  = new TreeMap<String, Path>();\n+\n@@ -785,3 +789,1 @@\n-                                try (InputStream in = Files.newInputStream(file)) {\n-                                    out.writeEntry(in, section, name);\n-                                }\n+                                filesToProcess.put(name, file);\n@@ -793,0 +795,11 @@\n+\n+            \/\/ Process files in sorted order\n+            Iterator<Map.Entry<String, Path>> itr = filesToProcess.entrySet().iterator();\n+            while(itr.hasNext()) {\n+                Map.Entry<String, Path> entry = itr.next();\n+                String name = entry.getKey();\n+                Path   file = entry.getValue();\n+                try (InputStream in = Files.newInputStream(file)) {\n+                    out.writeEntry(in, section, name);\n+                }\n+            }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+#!\/bin\/sh\n+\n+# Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 8276400 \n+# @summary Test ZipOutputStream support for SOURCE_DATE_EPOCH \n+# @build ZipSourceDateEpoch \n+# @run shell\/timeout=600 TestZipSourceDateEpoch.sh\n+\n+if [ \"${TESTJAVA}\" = \"\" ]\n+then\n+  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+echo \"TESTJAVA=${TESTJAVA}\"\n+if [ \"${TESTCLASSES}\" = \"\" ]\n+then\n+  echo \"TESTCLASSES not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+echo \"TESTCLASSES=${TESTCLASSES}\"\n+echo \"CLASSPATH=${CLASSPATH}\"\n+\n+# set platform-dependent variables\n+OS=`uname -s`\n+case \"$OS\" in\n+  Linux | Darwin | AIX )\n+    PS=\":\"\n+    FS=\"\/\"\n+    ;;\n+  Windows* )\n+    PS=\";\"\n+    FS=\"\/\"\n+    ;;\n+  CYGWIN* )\n+    PS=\";\"\n+    FS=\"\/\"\n+    TESTJAVA=`cygpath -u ${TESTJAVA}`\n+    ;;\n+  * )\n+    echo \"Unrecognized system!\"\n+    exit 1;\n+    ;;\n+esac\n+\n+failures=0\n+\n+run() {\n+    echo ''\n+    ${TESTJAVA}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} $* 2>&1\n+    if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n+}\n+\n+# Run with source date epoch set to 15\/03\/2022 \n+export SOURCE_DATE_EPOCH=1647302400\n+run ZipSourceDateEpoch \n+\n+# Run with no source date epoch set \n+unset SOURCE_DATE_EPOCH\n+run ZipSourceDateEpoch\n+\n+# Results\n+echo ''\n+if [ $failures -gt 0 ];\n+  then echo \"$failures tests failed\";\n+  else echo \"All tests passed\"; fi\n+exit $failures\n+\n","filename":"test\/jdk\/java\/util\/zip\/TestZipSourceDateEpoch.sh","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Driven by: TestZipSourceDateEpoch.sh\n+ *\/\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.util.jar.*;\n+import java.io.*;\n+\n+public class ZipSourceDateEpoch {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        String TEST_DATA = \"Test data string\";\n+\n+        String env = System.getenv(\"SOURCE_DATE_EPOCH\");\n+\n+        long sourceDateEpochMillis = -1;\n+        if (env != null) {\n+            try {\n+                long value = Long.parseLong(env);\n+                \/\/ SOURCE_DATE_EPOCH is in seconds\n+                sourceDateEpochMillis = value*1000;\n+            } catch(NumberFormatException e) {\n+                throw new AssertionError(\"Invalid SOURCE_DATE_EPOCH long value\");\n+            }\n+        }\n+\n+        \/\/ Write test zip\n+        File f = new File(\"epoch.zip\");\n+        f.deleteOnExit();\n+\n+        OutputStream os = new FileOutputStream(f);\n+        ZipOutputStream zos = new ZipOutputStream(os);\n+        try {\n+            zos.putNextEntry(new ZipEntry(\"Entry1.txt\"));\n+            zos.write(TEST_DATA.getBytes());\n+            zos.closeEntry();\n+            zos.putNextEntry(new ZipEntry(\"Entry2.txt\"));\n+            zos.write(TEST_DATA.getBytes());\n+            zos.closeEntry();\n+            zos.putNextEntry(new ZipEntry(\"Entry3.txt\"));\n+            zos.write(TEST_DATA.getBytes());\n+            zos.closeEntry();\n+        } finally {\n+            zos.close();\n+            os.close();\n+        }\n+\n+        \/\/----------------------------------------------------------------\n+        \/\/ Verify zip file entries all have SOURCE_DATE_EPOCH time if set\n+        \/\/----------------------------------------------------------------\n+        FileInputStream fis = new FileInputStream(f);\n+        ZipInputStream zis = new ZipInputStream(fis);\n+        try {\n+            long now = System.currentTimeMillis();\n+            ZipEntry entry;\n+            while ((entry = zis.getNextEntry()) != null) {\n+                if (sourceDateEpochMillis != -1) {\n+                    \/\/ SOURCE_DATE_EPOCH set, check time correct\n+                    if (entry.getTime() != sourceDateEpochMillis) {\n+                        throw new AssertionError(\"ZipEntry getTime() \"+entry.getTime()+\" not equal to SOURCE_DATE_EPOCH \"+sourceDateEpochMillis);\n+                    }\n+                } else {\n+                    \/\/ SOURCE_DATE_EPOCH not set, check time is current created within the last 60 seconds\n+                    if (entry.getTime() < (now-60000) || entry.getTime() > now) {\n+                        throw new AssertionError(\"ZipEntry getTime() \"+entry.getTime()+\" is not the current time \"+now);\n+                    }\n+                }\n+            }\n+        } finally {\n+            zis.close();\n+            fis.close();\n+        }\n+\n+        if (sourceDateEpochMillis != -1) {\n+            System.out.println(\"ZipOutputStream SOURCE_DATE_EPOCH test passed\");\n+        } else {\n+            System.out.println(\"ZipOutputStream current time test passed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipSourceDateEpoch.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4225317 6969651\n+ * @bug 4225317 6969651 8276400\n@@ -37,0 +37,3 @@\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n@@ -51,0 +54,1 @@\n+    static final long SOURCE_DATE_EPOCH = 1647302400; \/\/ 15\/03\/2022\n@@ -63,0 +67,23 @@\n+    static void createJar(File jarFile, File dir, boolean useSourceDateEpoch) throws Throwable {\n+        String javahome = System.getProperty(\"java.home\");\n+        String jarcmd = javahome + File.separator + \"bin\" + File.separator + \"jar\";\n+        String[] args = new String[] {\n+                jarcmd,\n+                \"cf\",\n+                jarFile.getName(),\n+                dir.getName() };\n+\n+        List<String> envList = new ArrayList<String>();\n+        for (Map.Entry<String,String> env : (new ProcessBuilder().environment()).entrySet()) {\n+            envList.add(env.getKey()+\"=\"+env.getValue());\n+        }\n+\n+        if (useSourceDateEpoch) {\n+            envList.add(\"SOURCE_DATE_EPOCH=\"+SOURCE_DATE_EPOCH);\n+        }\n+\n+        String[] env = envList.toArray(new String[0]);\n+        Process p = Runtime.getRuntime().exec(args, env);\n+        check(p != null && (p.waitFor() == 0));\n+    }\n+\n@@ -88,0 +115,1 @@\n+        File jarFileSourceDateEpoch = new File(\"JarEntryTimeSourceDateEpoch.jar\");\n@@ -122,2 +150,1 @@\n-        check(JAR_TOOL.run(System.out, System.err,\n-                           \"cf\", jarFile.getName(), dirOuter.getName()) == 0);\n+        createJar(jarFile, dirOuter, false);\n@@ -126,0 +153,4 @@\n+        \/\/ Make a jar file from that directory structure with SOURCE_DATE_EPOCH set\n+        createJar(jarFileSourceDateEpoch, dirOuter, true);\n+        check(jarFileSourceDateEpoch.exists());\n+\n@@ -165,0 +196,13 @@\n+        \/\/ Extract jarFileSourceDateEpoch and check last modified values are the epoch value\n+        long epochMillis = SOURCE_DATE_EPOCH * 1000L;\n+        extractJar(jarFileSourceDateEpoch, false);\n+        check(dirOuter.exists());\n+        check(dirInner.exists());\n+        check(fileInner.exists());\n+        checkFileTime(dirOuter.lastModified(), epochMillis);\n+        checkFileTime(dirInner.lastModified(), epochMillis);\n+        checkFileTime(fileInner.lastModified(), epochMillis);\n+\n+        check(cleanup(dirInner));\n+        check(cleanup(dirOuter));\n+\n@@ -166,0 +210,1 @@\n+        check(jarFileSourceDateEpoch.delete());\n","filename":"test\/jdk\/tools\/jar\/JarEntryTime.java","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+#!\/bin\/sh\n+\n+# Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# @test\n+# @bug 8276400 \n+# @summary Test two jars created with SOURCE_DATE_EPOCH set are identicakl \n+# @run shell\/timeout=600 TestReproducibleJar.sh \n+\n+if [ \"${TESTJAVA}\" = \"\" ]\n+then\n+  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n+  exit 1\n+fi\n+echo \"TESTJAVA=${TESTJAVA}\"\n+\n+# set platform-dependent variables\n+OS=`uname -s`\n+case \"$OS\" in\n+  Linux | Darwin | AIX )\n+    PS=\":\"\n+    FS=\"\/\"\n+    ;;\n+  Windows* )\n+    PS=\";\"\n+    FS=\"\/\"\n+    ;;\n+  CYGWIN* )\n+    PS=\";\"\n+    FS=\"\/\"\n+    TESTJAVA=`cygpath -u ${TESTJAVA}`\n+    ;;\n+  * )\n+    echo \"Unrecognized system!\"\n+    exit 1;\n+    ;;\n+esac\n+\n+TESTJAR=\"${TESTJAVA}${FS}bin${FS}jar\"\n+echo \"TESTJAR=${TESTJAR}\"\n+\n+failures=0\n+\n+run() {\n+    echo \"Creating $*\" \n+    rm -rf reproJarTmp\n+    mkdir -p reproJarTmp${FS}inner1\n+    mkdir -p reproJarTmp${FS}inner2\n+    echo \"foo\" > reproJarTmp${FS}inner1${FS}foo1.txt\n+    echo \"bar\" > reproJarTmp${FS}inner2${FS}bar1.txt\n+ \n+    SOURCE_DATE_EPOCH=1647302400 && ${TESTJAR} -cf $* reproJarTmp\n+    if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n+\n+    rm -rf reproJarTmp\n+}\n+\n+# Create test jar twice and test for reproducibility\n+export SOURCE_DATE_EPOCH=1647302400\n+run reproJar1.jar\n+# sleep 5 seconds to ensure jar timestamps would be different\n+sleep 5\n+run reproJar2.jar \n+unset SOURCE_DATE_EPOCH\n+\n+diff reproJar1.jar reproJar2.jar\n+if [ $? != 0 ]; then failures=`expr $failures + 1`; else echo \"reproJar1.jar and reproJar2.jar are identical\"; fi\n+\n+rm reproJar1.jar\n+rm reproJar2.jar\n+\n+# Results\n+echo ''\n+if [ $failures -gt 0 ];\n+  then echo \"$failures tests failed\";\n+  else echo \"All tests passed\"; fi\n+exit $failures\n+\n","filename":"test\/jdk\/tools\/jar\/TestReproducibleJar.sh","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276400\n@@ -78,0 +78,2 @@\n+    static final long SOURCE_DATE_EPOCH = 1647302400; \/\/ 15\/03\/2022\n+\n@@ -200,0 +202,11 @@\n+\n+                \/\/ JDK-8276400: Ensure the sort order is deterministic for reproducible jmod content\n+                \/\/ module-info, followed by <sorted classes>\n+                int mod_info_i = r.output.indexOf(CLASSES_PREFIX + \"module-info.class\");\n+                int foo_cls_i  = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/Foo.class\");\n+                int msg_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/internal\/Message.class\");\n+                int res_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/resources\/foo.properties\");\n+                System.out.println(\"jmod classes sort order check:\\n\"+r.output);\n+                assertTrue(mod_info_i < foo_cls_i);\n+                assertTrue(foo_cls_i < msg_i);\n+                assertTrue(msg_i < res_i);\n@@ -203,0 +216,27 @@\n+    \/\/ JDK-8276400: Ensure deterministic reproducible identical jmods\n+    @Test\n+    public void testReproducible() throws IOException {\n+        String cp = EXPLODED_DIR.resolve(\"foo\").resolve(\"classes\").toString();\n+        Path jmod1 = MODS_DIR.resolve(\"foo1.jmod\");\n+        Path jmod2 = MODS_DIR.resolve(\"foo2.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod1);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod2);\n+\n+        assertEquals(reproducibleJmod(\"create\", \"--class-path\", cp, jmod1.toString()), 0);\n+        assertTrue(Files.exists(jmod1));\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        assertEquals(reproducibleJmod(\"create\", \"--class-path\", cp, jmod2.toString()), 0);\n+        assertTrue(Files.exists(jmod2));\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod1, jmod2);\n+\n+        Files.delete(jmod1);\n+        Files.delete(jmod2);\n+    }\n+\n@@ -765,0 +805,25 @@\n+    static int reproducibleJmod(String... args) throws IOException {\n+        String javaHome = System.getProperty(\"java.home\");\n+        String jmodCmd = javaHome + File.separator + \"bin\" + File.separator + \"jmod\";\n+\n+        List<String> argsList = new ArrayList<String>();\n+        argsList.add(jmodCmd);\n+        argsList.addAll(Arrays.asList(args));\n+\n+        List<String> envList = new ArrayList<String>();\n+        for (Map.Entry<String,String> env : (new ProcessBuilder().environment()).entrySet()) {\n+            envList.add(env.getKey()+\"=\"+env.getValue());\n+        }\n+        envList.add(\"SOURCE_DATE_EPOCH=\"+SOURCE_DATE_EPOCH);\n+\n+        Process p = Runtime.getRuntime().exec(argsList.toArray(new String[0]), envList.toArray(new String[0]));\n+        int ec = -1;\n+        if (p != null) {\n+            try {\n+                ec = p.waitFor();\n+            } catch(InterruptedException ex) {}\n+        }\n+\n+        return ec;\n+    }\n+\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"}]}