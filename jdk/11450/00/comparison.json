{"files":[{"patch":"@@ -29,2 +29,1 @@\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n@@ -107,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  _transitive_interfaces = NULL;\n@@ -733,25 +732,0 @@\n-GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n-  if (_transitive_interfaces == NULL) {\n-    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n-  }\n-  return _transitive_interfaces;\n-}\n-\n-void ciInstanceKlass::compute_transitive_interfaces() {\n-  GUARDED_VM_ENTRY(\n-          InstanceKlass* ik = get_instanceKlass();\n-          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n-          Arena* arena = CURRENT_ENV->arena();\n-          int len = interfaces->length() + (is_interface() ? 1 : 0);\n-          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, len,\n-                                                                                                             0, NULL);\n-          for (int i = 0; i < interfaces->length(); i++) {\n-            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n-          }\n-          if (is_interface()) {\n-            transitive_interfaces->append(this);\n-          }\n-          _transitive_interfaces = transitive_interfaces;\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -83,1 +82,0 @@\n-  void compute_transitive_interfaces();\n@@ -297,1 +295,0 @@\n-  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -406,6 +406,2 @@\n-  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n-    return ConstraintCastNode::Value(phase);\n-  }\n-\n-  const TypePtr *in_type = inn->isa_ptr();\n-  const TypePtr *my_type = _type->isa_ptr();\n+  const TypePtr *in_type   = inn->isa_ptr();\n+  const TypePtr *my_type   = _type->isa_ptr();\n@@ -413,2 +409,2 @@\n-  if (in_type != NULL && my_type != NULL) {\n-    TypePtr::PTR in_ptr = in_type->ptr();\n+  if( in_type != NULL && my_type != NULL ) {\n+    TypePtr::PTR   in_ptr    = in_type->ptr();\n@@ -417,0 +413,10 @@\n+    } else if (in_ptr == TypePtr::Constant) {\n+      if (my_type->isa_rawptr()) {\n+        result = my_type;\n+      } else {\n+        const TypeOopPtr *jptr = my_type->isa_oopptr();\n+        assert(jptr, \"\");\n+        result = !in_type->higher_equal(_type)\n+          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n+          : in_type;\n+      }\n@@ -418,1 +424,1 @@\n-      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n+      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n@@ -422,1 +428,55 @@\n-  return result;\n+  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n+  \/\/ having 2 ways to represent the same type. We have to replicate it\n+  \/\/ here because we don't go through meet\/join.\n+  if (result->remove_speculative() == result->speculative()) {\n+    result = result->remove_speculative();\n+  }\n+\n+  \/\/ Same as above: because we don't go through meet\/join, remove the\n+  \/\/ speculative type if we know we won't use it.\n+  return result->cleanup_speculative();\n+\n+  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n+  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n+\n+  \/\/\n+  \/\/ Remove this code after overnight run indicates no performance\n+  \/\/ loss from not performing JOIN at CheckCastPPNode\n+  \/\/\n+  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n+  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n+  \/\/ \/\/ If either input is an 'interface', return destination type\n+  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n+  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n+  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n+  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n+  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n+  \/\/   \/\/ Preserve cast away nullness for interfaces\n+  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n+  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n+  \/\/   }\n+  \/\/   return _type;\n+  \/\/ }\n+  \/\/\n+  \/\/ \/\/ Neither the input nor the destination type is an interface,\n+  \/\/\n+  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n+  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n+  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n+  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n+  \/\/ const Type *join = in->join(_type);\n+  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n+  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n+  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n+  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n+  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n+  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n+  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n+  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n+  \/\/     return join;\n+  \/\/   }\n+  \/\/   \/\/ ELSE return same old type as before\n+  \/\/   return _type;\n+  \/\/ }\n+  \/\/ \/\/ Not joining two pointers\n+  \/\/ return join;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":70,"deletions":10,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1183,0 +1183,16 @@\n+  \/\/ Until we have harmony between classes and interfaces in the type\n+  \/\/ lattice, we must tread carefully around phis which implicitly\n+  \/\/ convert the one to the other.\n+  const TypePtr* ttp = _type->make_ptr();\n+  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n+  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n+  bool is_intf = false;\n+  if (ttip != NULL) {\n+    if (ttip->is_interface())\n+      is_intf = true;\n+  }\n+  if (ttkp != NULL) {\n+    if (ttkp->is_interface())\n+      is_intf = true;\n+  }\n+\n@@ -1189,0 +1205,14 @@\n+      \/\/ We assume that each input of an interface-valued Phi is a true\n+      \/\/ subtype of that interface.  This might not be true of the meet\n+      \/\/ of all the input types.  The lattice is not distributive in\n+      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n+      \/\/ meets between interfaces and proper classes.\n+      const TypePtr* tip = ti->make_ptr();\n+      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n+      if (tiip) {\n+        bool ti_is_intf = false;\n+        if (tiip->is_interface())\n+          ti_is_intf = true;\n+        if (is_intf != ti_is_intf)\n+          { t = _type; break; }\n+      }\n@@ -1212,3 +1242,25 @@\n-    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-    \/\/ found on dying counted loops.\n-    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n+\n+    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n+    \/\/ interface.  This can happen because the bytecodes do not contain\n+    \/\/ enough type info to distinguish a Java-level interface variable\n+    \/\/ from a Java-level object variable.  If we meet 2 classes which\n+    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n+    \/\/ doesn't implement I, we have no way to tell if the result should\n+    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n+    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n+    \/\/ uplift the type.\n+    if (!t->empty() && ttip && ttip->is_interface()) {\n+      assert(ft == _type, \"\"); \/\/ Uplift to interface\n+    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n+      assert(ft == _type, \"\"); \/\/ Uplift to interface\n+    } else {\n+      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n+      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n+      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n+          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n+      } else {\n+        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+        \/\/ found on dying counted loops.\n+        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n+      }\n+    }\n@@ -1219,0 +1271,25 @@\n+    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n+    \/\/ should report back the class.  However, if we have a J\/L\/Object\n+    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n+    \/\/ join report an interface back out.  This isn't possible but happens\n+    \/\/ because the type system doesn't interact well with interfaces.\n+    const TypePtr *jtp = jt->make_ptr();\n+    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n+    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n+    if (jtip && ttip) {\n+      if (jtip->is_interface() &&\n+          !ttip->is_interface()) {\n+        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n+               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n+        jt = ft;\n+      }\n+    }\n+    if (jtkp && ttkp) {\n+      if (jtkp->is_interface() &&\n+          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n+          ttkp->is_loaded() && !ttkp->is_interface()) {\n+        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n+               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n+        jt = ft;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":80,"deletions":3,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2185,1 +2185,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n@@ -2639,1 +2639,1 @@\n-  cmp = gvn.transform(cmp);\n+  gvn.transform(cmp);\n@@ -2847,1 +2847,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n@@ -2876,1 +2876,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n@@ -2999,1 +2999,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n@@ -3185,2 +3185,2 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n-  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n+  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,1 +503,3 @@\n-      if (toop) {\n+      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n+        s2.print(\"  Interface:\");\n+      } else if (toop) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3666,1 +3666,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n@@ -7234,1 +7234,1 @@\n-  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2035,1 +2035,1 @@\n-        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n@@ -2066,1 +2066,1 @@\n-          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n@@ -2326,1 +2326,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n+          return TypeKlassPtr::make(ciArrayKlass::make(t));\n@@ -2333,1 +2333,1 @@\n-        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n+        return TypeKlassPtr::make(t->as_klass());\n@@ -2371,1 +2371,1 @@\n-      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2557,1 +2557,4 @@\n-    if (toop) {\n+    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n+    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n+      st->print(\"  Interface:\");\n+    } else if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1202,1 +1202,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n@@ -1215,1 +1215,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n@@ -2135,1 +2135,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n@@ -2214,0 +2214,21 @@\n+    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n+    if (tr && tr->is_loaded() &&\n+        tr->is_interface()) {\n+      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n+      if (tp && tp->is_loaded() &&\n+          !tp->is_interface()) {\n+        \/\/ sharpen the type eagerly; this eases certain assert checking\n+        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n+          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n+        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n+      }\n+    } else {\n+      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n+      const TypeInstPtr* phi_tip;\n+      const TypeInstPtr* val_tip;\n+      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n+      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n+          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n+        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n@@ -302,1 +302,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n@@ -388,1 +388,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n+                          makecon(TypeKlassPtr::make(array_klass)),\n@@ -410,1 +410,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n+                          makecon(TypeKlassPtr::make(array_klass)),\n@@ -417,1 +417,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n@@ -132,1 +132,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n-const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -139,1 +137,1 @@\n-const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n+const Type* Type::get_const_type(ciType* type) {\n@@ -145,1 +143,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n+    return TypeOopPtr::make_from_klass(type->as_klass());\n@@ -571,6 +569,0 @@\n-  GrowableArray<ciInstanceKlass*> array_interfaces;\n-  array_interfaces.push(current->env()->Cloneable_klass());\n-  array_interfaces.push(current->env()->Serializable_klass());\n-  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n-  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n-\n@@ -789,0 +781,45 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool Type::interface_vs_oop_helper(const Type *t) const {\n+  bool result = false;\n+\n+  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n+  const TypePtr*    t_ptr =    t->make_ptr();\n+  if( this_ptr == NULL || t_ptr == NULL )\n+    return result;\n+\n+  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n+  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n+  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n+    bool this_interface = this_inst->is_interface();\n+    bool    t_interface =    t_inst->is_interface();\n+    result = this_interface ^ t_interface;\n+  }\n+\n+  return result;\n+}\n+\n+bool Type::interface_vs_oop(const Type *t) const {\n+  if (interface_vs_oop_helper(t)) {\n+    return true;\n+  }\n+  \/\/ Now check the speculative parts as well\n+  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n+  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n+  if (this_spec != NULL && t_spec != NULL) {\n+    if (this_spec->interface_vs_oop_helper(t_spec)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n+    return true;\n+  }\n+  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+#endif\n+\n@@ -808,1 +845,1 @@\n-  if (t2t != t->_dual || t2this != this->_dual) {\n+  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n@@ -1986,1 +2023,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n@@ -2007,1 +2044,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type);\n@@ -2018,1 +2055,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n@@ -2027,1 +2064,1 @@\n-    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n@@ -2049,1 +2086,1 @@\n-      field_array[pos++] = get_const_type(type, interface_handling);\n+      field_array[pos++] = get_const_type(type);\n@@ -2280,0 +2317,15 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool TypeAry::interface_vs_oop(const Type *t) const {\n+  const TypeAry* t_ary = t->is_ary();\n+  if (t_ary) {\n+    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n+    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n+    if(this_ptr != NULL && t_ptr != NULL) {\n+      return this_ptr->interface_vs_oop(t_ptr);\n+    }\n+  }\n+  return false;\n+}\n+#endif\n+\n@@ -2317,1 +2369,3 @@\n-  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n+  ciKlass* tklass = toop->klass();\n+  if (tklass == NULL)       return false;  \/\/ unloaded class\n+  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n@@ -2324,1 +2378,1 @@\n-    return tinst->instance_klass()->is_final();\n+    return tklass->as_instance_klass()->is_final();\n@@ -3116,229 +3170,0 @@\n-TypePtr::InterfaceSet::InterfaceSet()\n-        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n-          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n-}\n-\n-TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n-        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n-          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n-  for (int i = 0; i < interfaces->length(); i++) {\n-    add(interfaces->at(i));\n-  }\n-}\n-\n-\n-int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n-  if ((intptr_t)k1 < (intptr_t)k2) {\n-    return -1;\n-  } else if ((intptr_t)k1 > (intptr_t)k2) {\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n-void TypePtr::InterfaceSet::add(ciKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.insert_sorted<compare>(interface);\n-  verify();\n-}\n-\n-void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.push(interface);\n-}\n-\n-bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n-  if (_list.length() != other._list.length()) {\n-    return false;\n-  }\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i);\n-    ciKlass* k2 = other._list.at(i);\n-    if (!k1->equals(k2)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-int TypePtr::InterfaceSet::hash() const {\n-  if (_hash_computed) {\n-    return _hash;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_hash();\n-  assert(_hash_computed, \"should be computed now\");\n-  return _hash;\n-}\n-\n-void TypePtr::InterfaceSet::compute_hash() {\n-  int hash = 0;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k = _list.at(i);\n-    hash += (jint)k->hash();\n-  }\n-  _hash_computed = 1;\n-  _hash = hash;\n-}\n-\n-static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n-  return (int)((*k1)->ident() - (*k2)->ident());\n-}\n-\n-void TypePtr::InterfaceSet::dump(outputStream *st) const {\n-  if (_list.length() == 0) {\n-    return;\n-  }\n-  ResourceMark rm;\n-  st->print(\" (\");\n-  GrowableArray<ciKlass*> interfaces;\n-  interfaces.appendAll(&_list);\n-  \/\/ Sort the interfaces so they are listed in the same order from one run to the other of the same compilation\n-  interfaces.sort(compare_interfaces);\n-  for (int i = 0; i < interfaces.length(); i++) {\n-    if (i > 0) {\n-      st->print(\",\");\n-    }\n-    ciKlass* k = interfaces.at(i);\n-    k->print_name_on(st);\n-  }\n-  st->print(\")\");\n-}\n-\n-void TypePtr::InterfaceSet::verify() const {\n-#ifdef DEBUG\n-  for (int i = 1; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i-1);\n-    ciKlass* k2 = _list.at(i);\n-    assert(compare(k2, k1) > 0, \"should be ordered\");\n-    assert(k1 != k2, \"no duplicate\");\n-  }\n-#endif\n-}\n-\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n-  int i = 0;\n-  int j = 0;\n-  while (i < _list.length() || j < other._list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-    }\n-    while (j < other._list.length() &&\n-           (i >= _list.length() ||\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n-      result.raw_add(other._list.at(j));\n-      j++;\n-    }\n-    if (i < _list.length() &&\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-      j++;\n-    }\n-  }\n-  result.verify();\n-#ifdef DEBUG\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(result.contains(_list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(result.contains(other._list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n-  }\n-#endif\n-  return result;\n-}\n-\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n-  int i = 0;\n-  int j = 0;\n-  while (i < _list.length() || j < other._list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n-      i++;\n-    }\n-    while (j < other._list.length() &&\n-           (i >= _list.length() ||\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n-      j++;\n-    }\n-    if (i < _list.length() &&\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-      j++;\n-    }\n-  }\n-  result.verify();\n-#ifdef DEBUG\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n-  }\n-#endif\n-  return result;\n-}\n-\n-\/\/ Is there a single ciKlass* that can represent the interface set?\n-ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n-  if (_exact_klass_computed) {\n-    return _exact_klass;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n-  assert(_exact_klass_computed, \"should be computed now\");\n-  return _exact_klass;\n-}\n-\n-void TypePtr::InterfaceSet::compute_exact_klass() {\n-  if (_list.length() == 0) {\n-    _exact_klass_computed = 1;\n-    _exact_klass = NULL;\n-    return;\n-  }\n-  ciKlass* res = NULL;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n-    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n-      assert(res == NULL, \"\");\n-      res = _list.at(i);\n-    }\n-  }\n-  _exact_klass_computed = 1;\n-  _exact_klass = res;\n-}\n-\n-bool TypePtr::InterfaceSet::is_loaded() const {\n-  if (_is_loaded_computed) {\n-    return _is_loaded;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n-  assert(_is_loaded_computed, \"should be computed now\");\n-  return _is_loaded;\n-}\n-\n-void TypePtr::InterfaceSet::compute_is_loaded() {\n-  _is_loaded_computed = 1;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n-    if (!interface->is_loaded()) {\n-      _is_loaded = false;\n-      return;\n-    }\n-  }\n-  _is_loaded = true;\n-}\n-\n@@ -3346,1 +3171,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n@@ -3350,1 +3175,0 @@\n-    _interfaces(interfaces),\n@@ -3398,1 +3222,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n@@ -3408,1 +3232,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n@@ -3431,1 +3255,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3544,1 +3368,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3549,1 +3373,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n@@ -3576,2 +3400,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n@@ -3580,2 +3403,1 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, try_for_exact, false, interface_handling);\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n@@ -3587,1 +3409,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n@@ -3621,1 +3443,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n@@ -3679,0 +3501,21 @@\n+    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n+    \/\/ interface.  This can happen because the bytecodes do not contain\n+    \/\/ enough type info to distinguish a Java-level interface variable\n+    \/\/ from a Java-level object variable.  If we meet 2 classes which\n+    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n+    \/\/ doesn't implement I, we have no way to tell if the result should\n+    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n+    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n+    \/\/ uplift the type.\n+    if (!empty()) {\n+      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+        return kills;           \/\/ Uplift to interface\n+      }\n+      \/\/ Also check for evil cases of 'this' being a class array\n+      \/\/ and 'kills' expecting an array of interfaces.\n+      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n+      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+        return kills;           \/\/ Uplift to array of interface\n+      }\n+    }\n+\n@@ -3682,0 +3525,12 @@\n+  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n+  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n+  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n+  \/\/ join report an interface back out.  This isn't possible but happens\n+  \/\/ because the type system doesn't interact well with interfaces.\n+  if (ftip != NULL && ktip != NULL &&\n+      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n+      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n+    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n+    return ktip->cast_to_ptr_type(ftip->ptr());\n+  }\n+\n@@ -3740,1 +3595,1 @@\n-const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3807,12 +3662,0 @@\n-\n-TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces.union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n-  }\n-  return _interfaces.intersection_with(other->_interfaces);\n-}\n-\n@@ -3843,1 +3686,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3845,12 +3687,1 @@\n-  if (_interfaces.empty()) {\n-    return _klass;\n-  }\n-  if (_klass != ciEnv::current()->Object_klass()) {\n-    ciKlass* k = _klass;\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    if (_interfaces.eq(interfaces)) {\n-      return _klass;\n-    }\n-    return NULL;\n-  }\n-  return _interfaces.exact_klass();\n+  return _klass;\n@@ -3860,1 +3691,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n@@ -3862,5 +3693,4 @@\n-  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n-  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n-  assert(k != NULL &&\n-         (k->is_loaded() || o == NULL),\n-         \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n+   assert(k != NULL &&\n+          (k->is_loaded() || o == NULL),\n+          \"cannot have constants with non-loaded klass\");\n@@ -3872,1 +3702,0 @@\n-                                     const InterfaceSet& interfaces,\n@@ -3893,1 +3722,0 @@\n-    assert(!ik->is_interface(), \"no interface here\");\n@@ -3899,1 +3727,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3904,33 +3732,0 @@\n-TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n-  if (k->is_instance_klass()) {\n-    if (k->is_loaded()) {\n-      if (k->is_interface() && interface_handling == ignore_interfaces) {\n-        assert(interface, \"no interface expected\");\n-        k = ciEnv::current()->Object_klass();\n-        InterfaceSet interfaces;\n-        return interfaces;\n-      }\n-      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n-      InterfaceSet interfaces(k_interfaces);\n-      if (k->is_interface()) {\n-        assert(interface, \"no interface expected\");\n-        k = ciEnv::current()->Object_klass();\n-      } else {\n-        assert(klass, \"no instance klass expected\");\n-      }\n-      return interfaces;\n-    }\n-    InterfaceSet interfaces;\n-    return interfaces;\n-  }\n-  assert(array, \"no array expected\");\n-  assert(k->is_array_klass(), \"Not an array?\");\n-  ciType* e = k->as_array_klass()->base_element_type();\n-  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n-    if (interface_handling == ignore_interfaces) {\n-      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n-    }\n-  }\n-  return *TypeAryPtr::_array_interfaces;\n-}\n-\n@@ -3965,1 +3760,1 @@\n-  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3975,2 +3770,2 @@\n-  assert(!ik->is_interface(), \"no interface here\");\n-  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n+  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3982,1 +3777,1 @@\n-  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3988,33 +3783,6 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n-  int off = meet_offset(tinst->offset());\n-  PTR ptr = meet_ptr(tinst->ptr());\n-  int instance_id = meet_instance_id(tinst->instance_id());\n-  const TypePtr* speculative = xmeet_speculative(tinst);\n-  int depth = meet_inline_depth(tinst->inline_depth());\n-\n-  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-    \/\/\n-    \/\/ Meet unloaded class with java\/lang\/Object\n-    \/\/\n-    \/\/ Meet\n-    \/\/          |                     Unloaded Class\n-    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-    \/\/  ===================================================================\n-    \/\/   TOP    | ..........................Unloaded......................|\n-    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-    \/\/\n-    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-    \/\/\n-    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n-    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n-    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n-    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n-      else                                       { return TypeInstPtr::NOTNULL; }\n-    }\n-    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n+    int off = meet_offset(tinst->offset());\n+    PTR ptr = meet_ptr(tinst->ptr());\n+    int instance_id = meet_instance_id(tinst->instance_id());\n+    const TypePtr* speculative = xmeet_speculative(tinst);\n+    int depth = meet_inline_depth(tinst->inline_depth());\n@@ -4022,2 +3790,26 @@\n-    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n-  }\n+    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+      \/\/\n+      \/\/ Meet unloaded class with java\/lang\/Object\n+      \/\/\n+      \/\/ Meet\n+      \/\/          |                     Unloaded Class\n+      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+      \/\/  ===================================================================\n+      \/\/   TOP    | ..........................Unloaded......................|\n+      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+      \/\/\n+      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+      \/\/\n+      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n+      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n+      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n+      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n+        else                                      { return TypeInstPtr::NOTNULL; }\n+      }\n+      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n@@ -4025,6 +3817,9 @@\n-  \/\/ Both are unloaded, not the same class, not Object\n-  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-  if (ptr != TypePtr::BotPTR) {\n-    return TypeInstPtr::NOTNULL;\n-  }\n-  return TypeInstPtr::BOTTOM;\n+      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+    }\n+\n+    \/\/ Both are unloaded, not the same class, not Object\n+    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+    if( ptr != TypePtr::BotPTR ) {\n+      return TypeInstPtr::NOTNULL;\n+    }\n+    return TypeInstPtr::BOTTOM;\n@@ -4083,1 +3878,1 @@\n-      return make(ptr, klass(), _interfaces, klass_is_exact(),\n+      return make(ptr, klass(), klass_is_exact(),\n@@ -4111,1 +3906,1 @@\n-      return make(ptr, klass(), _interfaces, klass_is_exact(),\n+      return make(ptr, klass(), klass_is_exact(),\n@@ -4145,2 +3940,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tinst);\n-\n@@ -4149,0 +3942,2 @@\n+    bool tinst_xk = tinst->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n@@ -4153,2 +3948,1 @@\n-    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n-\n+    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n@@ -4157,1 +3951,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n@@ -4194,1 +3988,1 @@\n-      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n@@ -4205,10 +3999,4 @@\n-template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n-                      ciKlass*& res_klass, bool& res_xk) {\n-  ciKlass* this_klass = this_type->klass();\n-  ciKlass* other_klass = other_type->klass();\n-  bool this_xk = this_type->klass_is_exact();\n-  bool other_xk = other_type->klass_is_exact();\n-  PTR this_ptr = this_type->ptr();\n-  PTR other_ptr = other_type->ptr();\n-  InterfaceSet this_interfaces = this_type->interfaces();\n-  InterfaceSet other_interfaces = other_type->interfaces();\n+TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n+                                          PTR this_ptr,\n+                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n+\n@@ -4219,1 +4007,1 @@\n-  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n+  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n@@ -4226,1 +4014,1 @@\n-  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4230,0 +4018,41 @@\n+  \/\/ Handle mixing oops and interfaces first.\n+  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n+                                      tinst_klass == ciEnv::current()->Object_klass())) {\n+    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n+    tinst_klass = this_klass;\n+    this_klass = tmp;\n+    bool tmp2 = tinst_xk;\n+    tinst_xk = this_xk;\n+    this_xk = tmp2;\n+  }\n+  if (tinst_klass->is_interface() &&\n+      !(this_klass->is_interface() ||\n+        \/\/ Treat java\/lang\/Object as an honorary interface,\n+        \/\/ because we need a bottom for the interface hierarchy.\n+        this_klass == ciEnv::current()->Object_klass())) {\n+    \/\/ Oop meets interface!\n+\n+    \/\/ See if the oop subtypes (implements) interface.\n+    if (this_klass->is_subtype_of(tinst_klass)) {\n+      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n+      \/\/ on whether we are both above the centerline or either is\n+      \/\/ below the centerline.  If we are on the centerline\n+      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n+      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n+      \/\/ If we are keeping this_klass, keep its exactness too.\n+      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n+      return SUBTYPE;\n+    } else {                  \/\/ Does not implement, fall to Object\n+      \/\/ Oop does not implement interface, so mixing falls to Object\n+      \/\/ just like the verifier does (if both are above the\n+      \/\/ centerline fall to interface)\n+      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n+      res_xk = above_centerline(ptr) ? tinst_xk : false;\n+      \/\/ Watch out for Constant vs. AnyNull interface.\n+      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n+      return NOT_SUBTYPE;\n+    }\n+  }\n+\n+  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n+\n@@ -4255,1 +4084,1 @@\n-  const T* subtype = NULL;\n+  ciKlass *subtype = NULL;\n@@ -4257,7 +4086,5 @@\n-  InterfaceSet subtype_interfaces;\n-\n-  if (this_type->is_same_java_type_as(other_type)) {\n-    subtype = this_type;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n-  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n-    subtype = this_type;     \/\/ Pick subtyping class\n+  if (tinst_klass->equals(this_klass)) {\n+    subtype = this_klass;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n+  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n+    subtype = this_klass;     \/\/ Pick subtyping class\n@@ -4265,3 +4092,3 @@\n-  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n-    subtype = other_type;    \/\/ Pick subtyping class\n-    subtype_exact = other_xk;\n+  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n+    subtype = tinst_klass;    \/\/ Pick subtyping class\n+    subtype_exact = tinst_xk;\n@@ -4272,8 +4099,8 @@\n-      this_type = other_type = subtype;\n-      this_xk = other_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n-      this_type = other_type; \/\/ tinst is down; keep down man\n-      this_xk = other_xk;\n-    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n-      other_type = this_type; \/\/ this is down; keep down man\n-      other_xk = this_xk;\n+      this_klass = tinst_klass = subtype;\n+      this_xk = tinst_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n+      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n+      this_xk = tinst_xk;\n+    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n+      tinst_klass = this_klass; \/\/ this is down; keep down man\n+      tinst_xk = this_xk;\n@@ -4286,1 +4113,1 @@\n-  if (this_type->is_same_java_type_as(other_type)) {\n+  if (tinst_klass->equals(this_klass)) {\n@@ -4290,1 +4117,1 @@\n-    res_klass = this_type->klass();\n+    res_klass = this_klass;\n@@ -4301,2 +4128,0 @@\n-  interfaces = this_interfaces.intersection_with(other_interfaces);\n-\n@@ -4304,1 +4129,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n@@ -4312,0 +4137,1 @@\n+\n@@ -4328,1 +4154,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4337,1 +4163,0 @@\n-    _interfaces.eq(p->_interfaces) &&\n@@ -4344,1 +4169,1 @@\n-  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n+  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n@@ -4349,2 +4174,10 @@\n-  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n-}\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+\n+  if (!other_exact) {\n+    return false;\n+  }\n@@ -4352,0 +4185,3 @@\n+  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n+    return true;\n+  }\n@@ -4353,2 +4189,15 @@\n-bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n+\n+  return _klass->is_subtype_of(other->klass());\n+}\n+\n+bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+  return _klass->equals(other->_klass);\n@@ -4358,1 +4207,27 @@\n-  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return true;\n+  }\n+\n+  if (other->isa_aryptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n+  }\n+\n+  assert(other->isa_instptr(), \"unsupported\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+    return false;\n+  }\n+\n+  if (this_exact) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return true;\n@@ -4368,1 +4243,0 @@\n-  _interfaces.dump(st);\n@@ -4418,1 +4292,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4423,1 +4297,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n@@ -4432,1 +4306,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n@@ -4436,1 +4310,1 @@\n-const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4440,1 +4314,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4443,1 +4317,1 @@\n-const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4445,1 +4319,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4451,59 +4325,5 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n-    ciKlass* k = ik;\n-    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    assert(k == ik, \"\");\n-    if (interfaces.eq(_interfaces)) {\n-      Compile *C = Compile::current();\n-      Dependencies* deps = C->dependencies();\n-      deps->assert_leaf_type(ik);\n-      xk = true;\n-    }\n-  }\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n-}\n-\n-template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  if (!this_one->is_instance_type(other)) {\n-    return false;\n-  }\n-\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n-    return true;\n-  }\n-\n-  return this_one->klass()->is_subtype_of(other->klass()) &&\n-         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n-}\n-\n-\n-bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n-}\n-\n-template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n-    return true;\n-  }\n-\n-  if (this_one->is_instance_type(other)) {\n-    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n-  }\n-\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (this_top_or_bottom) {\n-    return false;\n-  }\n-\n-  const T1* other_ary = this_one->is_array_type(other);\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n-  }\n-\n-  if (other_elem == NULL && this_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n+    Compile* C = Compile::current();\n+    Dependencies* deps = C->dependencies();\n+    deps->assert_leaf_type(ik);\n+    xk = true;\n@@ -4511,14 +4331,1 @@\n-\n-  return false;\n-}\n-\n-bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n-}\n-\n-bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n-}\n-\n-bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n@@ -4547,4 +4354,0 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n-      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n-    k = NULL;\n-  }\n@@ -4563,4 +4366,0 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n-      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n-    k = NULL;\n-  }\n@@ -4594,1 +4393,1 @@\n-  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n@@ -4702,1 +4501,22 @@\n-  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+    return false;\n+  }\n+  if (other->isa_instptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n+  }\n+  if (klass() == NULL) {\n+    return false;\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n@@ -4705,2 +4525,13 @@\n-bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!other->isa_aryptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return false;\n+  }\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->equals(other->_klass);\n+  }\n+  return false;\n@@ -4710,1 +4541,25 @@\n-  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return true;\n+  }\n+  if (other->isa_instptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n+                                                               other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n@@ -4805,1 +4660,1 @@\n-    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4835,4 +4690,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n-\n@@ -4845,2 +4696,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n-        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4851,2 +4702,1 @@\n-        interfaces = this_interfaces.intersection_with(tp_interfaces);\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n@@ -4864,1 +4714,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -4878,2 +4728,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n@@ -4888,8 +4737,1 @@\n-template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n-                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n-  ciKlass* this_klass = this_ary->klass();\n-  ciKlass* other_klass = other_ary->klass();\n-  bool this_xk = this_ary->klass_is_exact();\n-  bool other_xk = other_ary->klass_is_exact();\n-  PTR this_ptr = this_ary->ptr();\n-  PTR other_ptr = other_ary->ptr();\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n@@ -4902,2 +4744,2 @@\n-      res_klass = other_klass;\n-    else if (other_klass == NULL || other_klass == this_klass) {\n+      res_klass = tap_klass;\n+    else if (tap_klass == NULL || tap_klass == this_klass) {\n@@ -4912,1 +4754,1 @@\n-  } else {\/\/ Non integral arrays.\n+  } else \/\/ Non integral arrays.\n@@ -4915,4 +4757,1 @@\n-    int dummy;\n-    bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n-    bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n+    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n@@ -4920,1 +4759,1 @@\n-        !this_top_or_bottom && !other_top_or_bottom &&\n+        tap_klass != NULL  && this_klass != NULL   &&\n@@ -4922,1 +4761,1 @@\n-        ((other_xk && this_xk) ||\n+        ((tap_xk && this_xk) ||\n@@ -4924,1 +4763,1 @@\n-         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n+         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n@@ -4926,1 +4765,1 @@\n-         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n+         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n@@ -4934,1 +4773,0 @@\n-  }\n@@ -4937,1 +4775,1 @@\n-  switch (other_ptr) {\n+  switch (tap_ptr) {\n@@ -4944,1 +4782,1 @@\n-        res_xk = (other_xk || this_xk);\n+        res_xk = (tap_xk || this_xk);\n@@ -4954,1 +4792,1 @@\n-        res_xk = this_xk && this_ary->is_same_java_type_as(other_ary);\n+        res_xk = this_xk && (this_klass == tap_klass);\n@@ -4962,1 +4800,1 @@\n-        res_xk = other_xk;\n+        res_xk = tap_xk;\n@@ -4964,2 +4802,2 @@\n-        res_xk = (other_xk && this_xk) &&\n-                 (this_ary->is_same_java_type_as(other_ary)); \/\/ Only precise for identical arrays\n+        res_xk = (tap_xk && this_xk) &&\n+          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n@@ -4983,0 +4821,11 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n+  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n+  if (t_aryptr) {\n+    return _ary->interface_vs_oop(t_aryptr->_ary);\n+  }\n+  return false;\n+}\n+#endif\n+\n@@ -4987,2 +4836,0 @@\n-  _interfaces.dump(st);\n-\n@@ -5041,1 +4888,1 @@\n-const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -5061,1 +4908,1 @@\n-const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n@@ -5068,1 +4915,1 @@\n-const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5253,1 +5100,1 @@\n-const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5428,1 +5275,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n@@ -5430,1 +5277,1 @@\n-    return TypeInstKlassPtr::make(klass, interface_handling);\n+    return TypeInstKlassPtr::make(klass);\n@@ -5432,1 +5279,1 @@\n-  return TypeAryKlassPtr::make(klass, interface_handling);\n+  return TypeAryKlassPtr::make(klass);\n@@ -5435,1 +5282,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n@@ -5437,2 +5284,1 @@\n-    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n+    return TypeInstKlassPtr::make(ptr, klass, offset);\n@@ -5440,1 +5286,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n+  return TypeAryKlassPtr::make(ptr, klass, offset);\n@@ -5445,4 +5291,2 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n-  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n-         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass) {\n@@ -5451,1 +5295,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5453,12 +5296,1 @@\n-  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n-  if (_interfaces.empty()) {\n-    return _klass;\n-  }\n-  if (_klass != ciEnv::current()->Object_klass()) {\n-    ciKlass* k = _klass;\n-    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n-      return _klass;\n-    }\n-    return NULL;\n-  }\n-  return _interfaces.exact_klass();\n+  return _klass;\n@@ -5472,1 +5304,0 @@\n-    _interfaces.eq(p->_interfaces) &&\n@@ -5479,1 +5310,1 @@\n-  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n+  return TypePtr::hash();\n@@ -5500,0 +5331,3 @@\n+    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n+      return kills;             \/\/ Uplift to interface\n+\n@@ -5503,10 +5337,7 @@\n-  return ft;\n-}\n-\n-TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces.union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n+  \/\/ Interface klass type could be exact in opposite to interface type,\n+  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n+  if (ftkp != NULL && ktkp != NULL &&\n+      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n+      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n+      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n+    return ktkp->cast_to_ptr_type(ftkp->ptr());\n@@ -5514,1 +5345,2 @@\n-  return _interfaces.intersection_with(other->_interfaces);\n+\n+  return ft;\n@@ -5554,1 +5386,0 @@\n-      _interfaces.dump(st);\n@@ -5595,1 +5426,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n@@ -5597,1 +5428,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n@@ -5604,2 +5435,2 @@\n-const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n+const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), xadd_offset(offset) );\n@@ -5609,1 +5440,1 @@\n-  return make(_ptr, klass(), _interfaces, offset);\n+  return make(_ptr, klass(), offset);\n@@ -5616,1 +5447,1 @@\n-  return make(ptr, _klass, _interfaces, _offset);\n+  return make(ptr, _klass, _offset);\n@@ -5632,1 +5463,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n@@ -5647,1 +5478,0 @@\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5656,8 +5486,3 @@\n-        ciKlass* sub_k = sub;\n-        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n-        assert(sub_k == sub, \"\");\n-        if (sub_interfaces.eq(_interfaces)) {\n-          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-          k = ik = sub;\n-          xk = sub->is_final();\n-        }\n+        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+        k = ik = sub;\n+        xk = sub->is_final();\n@@ -5667,1 +5492,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n@@ -5708,1 +5533,1 @@\n-      return make( ptr, klass(), _interfaces, offset );\n+      return make( ptr, klass(), offset );\n@@ -5743,1 +5568,4 @@\n-    InterfaceSet interfaces = meet_interfaces(tkls);\n+    ciKlass* tkls_klass = tkls->klass();\n+    ciKlass* this_klass  = klass();\n+    bool tkls_xk = tkls->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n@@ -5747,1 +5575,1 @@\n-    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n@@ -5755,2 +5583,2 @@\n-        const Type* res = make(ptr, res_klass, interfaces, off);\n-        return res;\n+        const Type* res1 = make(ptr, res_klass, off);\n+        return res1;\n@@ -5766,3 +5594,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n@@ -5776,1 +5601,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n@@ -5781,2 +5606,1 @@\n-        interfaces = _interfaces.intersection_with(tp->_interfaces);\n-        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+        return make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5794,1 +5618,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+        if (klass()->equals(ciEnv::current()->Object_klass())) {\n@@ -5804,2 +5628,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+      return make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5817,1 +5640,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n@@ -5820,3 +5643,2 @@\n-template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5825,1 +5647,1 @@\n-  if (!this_one->is_instance_type(other)) {\n+  if (!other->isa_instklassptr()) {\n@@ -5833,1 +5655,1 @@\n-  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n+  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n@@ -5837,2 +5659,3 @@\n-  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n-}\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n@@ -5840,2 +5663,1 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+  return _klass->is_subtype_of(other->_klass);\n@@ -5844,3 +5666,2 @@\n-template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5849,1 +5670,1 @@\n-  if (!this_one->is_instance_type(other)) {\n+  if (!other->isa_instklassptr()) {\n@@ -5852,5 +5673,1 @@\n-  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n-}\n-\n-bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+  return _klass->equals(other->_klass);\n@@ -5859,3 +5676,2 @@\n-template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5865,2 +5681,6 @@\n-  if (this_one->is_array_type(other)) {\n-    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n+  if (other->isa_aryklassptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n@@ -5869,1 +5689,1 @@\n-  assert(this_one->is_instance_type(other), \"unsupported\");\n+  assert(other->isa_instklassptr(), \"unsupported\");\n@@ -5872,1 +5692,1 @@\n-    return this_one->is_java_subtype_of(other);\n+    return is_java_subtype_of(other);\n@@ -5875,1 +5695,1 @@\n-  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n@@ -5880,1 +5700,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+    return _klass->is_subtype_of(other->_klass);\n@@ -5886,36 +5706,0 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n-}\n-\n-const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n-  if (!UseUniqueSubclasses) {\n-    return this;\n-  }\n-  ciKlass* k = klass();\n-  Compile* C = Compile::current();\n-  Dependencies* deps = C->dependencies();\n-  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n-  if (k->is_loaded()) {\n-    ciInstanceKlass* ik = k->as_instance_klass();\n-    bool klass_is_exact = ik->is_final();\n-    if (!klass_is_exact &&\n-        deps != NULL) {\n-      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n-      if (sub != NULL) {\n-        ciKlass *sub_k = sub;\n-        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n-        assert(sub_k == sub, \"\");\n-        if (sub_interfaces.eq(_interfaces)) {\n-          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-          k = ik = sub;\n-          klass_is_exact = sub->is_final();\n-          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n-        }\n-      }\n-    }\n-  }\n-  return this;\n-}\n-\n-\n@@ -5926,2 +5710,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n-  if (k->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_obj_array_klass()) {\n@@ -5929,2 +5713,2 @@\n-    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n@@ -5932,1 +5716,1 @@\n-  } else if (k->is_type_array_klass()) {\n+  } else if (klass->is_type_array_klass()) {\n@@ -5934,2 +5718,2 @@\n-    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n+    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n@@ -5942,2 +5726,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0);\n@@ -5975,1 +5759,2 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Compute array klass from element klass\n+    k_ary = ciObjArrayKlass::make(tinst->klass());\n@@ -5977,1 +5762,5 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Compute array klass from element klass\n+    ciKlass* k_elem = tary->klass();\n+    \/\/ If element type is something like bottom[], k_elem will be null.\n+    if (k_elem != NULL)\n+      k_ary = ciObjArrayKlass::make(k_elem);\n@@ -6035,0 +5824,5 @@\n+    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n+    }\n@@ -6039,1 +5833,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6065,1 +5858,1 @@\n-const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -6195,1 +5988,1 @@\n-    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n@@ -6203,3 +5996,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n@@ -6213,1 +6003,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -6218,2 +6008,1 @@\n-        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -6231,1 +6020,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -6240,2 +6029,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -6250,4 +6038,2 @@\n-template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n@@ -6257,4 +6043,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n@@ -6263,3 +6046,2 @@\n-\n-  if (this_one->is_instance_type(other)) {\n-    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n+  if (other->isa_instklassptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n@@ -6267,5 +6049,1 @@\n-\n-  assert(this_one->is_array_type(other), \"\");\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-  if (other_top_or_bottom) {\n+  if (klass() == NULL) {\n@@ -6274,5 +6052,4 @@\n-\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (this_elem != NULL && other_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n+  assert(other->isa_aryklassptr(), \"\");\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n@@ -6280,2 +6057,2 @@\n-  if (this_elem == NULL && other_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n@@ -6286,18 +6063,3 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n-}\n-\n-template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (!this_one->is_array_type(other) ||\n-      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n-    return false;\n-  }\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (other_top_or_bottom) {\n+bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!other->isa_aryklassptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n@@ -6306,5 +6068,3 @@\n-\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n@@ -6312,3 +6072,2 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n-    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n-    return this_one->_klass->equals(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->equals(other->_klass);\n@@ -6319,7 +6078,2 @@\n-bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n-}\n-\n-template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n@@ -6328,3 +6082,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n@@ -6333,2 +6085,2 @@\n-  if (this_one->is_instance_type(other)) {\n-    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n+  if (other->isa_instklassptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n@@ -6336,1 +6088,1 @@\n-  assert(this_one->is_array_type(other), \"\");\n+  assert(other->isa_aryklassptr(), \"\");\n@@ -6338,5 +6090,0 @@\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-  if (other_top_or_bottom) {\n-    return true;\n-  }\n@@ -6344,1 +6091,1 @@\n-    return this_one->is_java_subtype_of(other);\n+    return is_java_subtype_of(other);\n@@ -6347,4 +6094,3 @@\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n@@ -6352,2 +6098,2 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n@@ -6358,4 +6104,0 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n-}\n-\n@@ -6368,1 +6110,1 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n+\/\/------------------------------get_con----------------------------------------\n@@ -6388,1 +6130,5 @@\n-    \/\/ leave NULL\n+    k = elem()->is_klassptr()->klass();\n+    if (k != NULL) {\n+      k = ciObjArrayKlass::make(k);\n+      ((TypeAryKlassPtr*)this)->_klass = k;\n+    }\n@@ -6393,1 +6139,0 @@\n-    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6409,1 +6154,0 @@\n-      _interfaces.dump(st);\n@@ -6458,1 +6202,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n+    domain = TypeTuple::make_domain(NULL, method->signature());\n@@ -6460,1 +6204,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n+    domain = TypeTuple::make_domain(method->holder(), method->signature());\n@@ -6462,1 +6206,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":548,"deletions":804,"binary":false,"changes":1352,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop_helper(const Type *t) const;\n+#endif\n@@ -259,0 +263,1 @@\n+  \/\/ Currently, it also works around limitations involving interface types.\n@@ -268,0 +273,5 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n+\n@@ -397,4 +407,0 @@\n-  enum InterfaceHandling {\n-      trust_interfaces,\n-      ignore_interfaces\n-  };\n@@ -402,1 +408,1 @@\n-  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const Type* get_const_type(ciType* type);\n@@ -721,2 +727,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig, InterfaceHandling interface_handling = ignore_interfaces);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig, InterfaceHandling interface_handling);\n+  static const TypeTuple *make_range(ciSignature *sig);\n+  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n@@ -773,0 +779,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n@@ -878,46 +888,0 @@\n-  friend class Type;\n-protected:\n-  class InterfaceSet {\n-  private:\n-    GrowableArray<ciKlass*> _list;\n-    void raw_add(ciKlass* interface);\n-    void add(ciKlass* interface);\n-    void verify() const;\n-    int _hash_computed:1;\n-    int _exact_klass_computed:1;\n-    int _is_loaded_computed:1;\n-    int _hash;\n-    ciKlass* _exact_klass;\n-    bool _is_loaded;\n-    void compute_hash();\n-    void compute_exact_klass();\n-  public:\n-    InterfaceSet();\n-    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n-    bool eq(const InterfaceSet& other) const;\n-    int hash() const;\n-    void dump(outputStream *st) const;\n-    InterfaceSet union_with(const InterfaceSet& other) const;\n-    InterfaceSet intersection_with(const InterfaceSet& other) const;\n-    bool contains(const InterfaceSet& other) const {\n-      return intersection_with(other).eq(other);\n-    }\n-    bool empty() const { return _list.length() == 0; }\n-\n-    inline void* operator new(size_t x) throw() {\n-      Compile* compile = Compile::current();\n-      return compile->type_arena()->AmallocWords(x);\n-    }\n-    inline void operator delete( void* ptr ) {\n-      ShouldNotReachHere();\n-    }\n-    ciKlass* exact_klass() const;\n-    bool is_loaded() const;\n-\n-    static int compare(ciKlass* const &, ciKlass* const & k2);\n-\n-    void compute_is_loaded();\n-  };\n-\n-  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n-\n@@ -982,14 +946,6 @@\n-  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type,\n-                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n-\n-  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n-                                                  ciKlass*& res_klass, bool& res_xk);\n-\n-  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n-  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n-  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n-  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  static MeetResult\n+  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n+               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n+  static MeetResult\n+  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n+\n@@ -1104,1 +1060,1 @@\n- TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1120,3 +1076,0 @@\n-\n-  const InterfaceSet _interfaces;\n-\n@@ -1134,1 +1087,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n@@ -1139,2 +1092,0 @@\n-  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n-\n@@ -1152,9 +1103,1 @@\n-\n-  bool is_same_java_type_as(const TypePtr* other) const {\n-    return is_same_java_type_as_helper(other->is_oopptr());\n-  }\n-\n-  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n+  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1171,2 +1114,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    return make_from_klass_common(klass, true, false, interface_handling);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n+    return make_from_klass_common(klass, true, false);\n@@ -1176,2 +1119,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n-    return make_from_klass_common(klass, true, true, interface_handling);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n+    return make_from_klass_common(klass, true, true);\n@@ -1181,2 +1124,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    return make_from_klass_common(klass, false, false, interface_handling);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n+    return make_from_klass_common(klass, false, false);\n@@ -1201,2 +1144,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n-  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n+  bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1244,24 +1187,0 @@\n-private:\n-  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n-    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n-  }\n-\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n-  virtual const InterfaceSet interfaces() const {\n-    return _interfaces;\n-  };\n-\n-  const TypeOopPtr* is_reference_type(const Type* other) const {\n-    return other->isa_oopptr();\n-  }\n-\n-  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n-    return other->isa_aryptr();\n-  }\n-\n-  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n-    return other->isa_instptr();\n-  }\n@@ -1274,1 +1193,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1285,1 +1204,3 @@\n-    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n+    if (klass()->is_loaded() && klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n@@ -1289,1 +1210,1 @@\n-  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n@@ -1295,3 +1216,1 @@\n-    ciKlass* k = o->klass();\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(TypePtr::Constant, k, interfaces, true, o, 0, InstanceBot);\n+    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n@@ -1301,3 +1220,1 @@\n-    ciKlass* k = o->klass();\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(TypePtr::Constant, k, interfaces, true, o, offset, InstanceBot);\n+    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n@@ -1307,3 +1224,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return make(ptr, klass, interfaces, false, NULL, 0, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n+    return make(ptr, klass, false, NULL, 0, InstanceBot);\n@@ -1314,2 +1230,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n-    return make(ptr, klass, interfaces, true, NULL, 0, InstanceBot);\n+    return make(ptr, klass, true, NULL, 0, InstanceBot);\n@@ -1320,2 +1235,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n-    return make(ptr, klass, interfaces, false, NULL, offset, InstanceBot);\n+    return make(ptr, klass, false, NULL, offset, InstanceBot);\n@@ -1324,1 +1238,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n+  \/\/ Make a pointer to an oop.\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n@@ -1329,5 +1244,0 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id = InstanceBot) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(ptr, k, interfaces, xk, o, offset, instance_id);\n-  }\n-\n@@ -1358,1 +1268,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n+  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n@@ -1363,0 +1273,2 @@\n+  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n+\n@@ -1372,8 +1284,0 @@\n-\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n-\n-  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n-    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n-  }\n-\n@@ -1385,3 +1289,0 @@\n-  friend class Type;\n-  friend class TypePtr;\n-\n@@ -1391,1 +1292,1 @@\n-    : TypeOopPtr(AryPtr,ptr,k,*_array_interfaces,xk,o,offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n@@ -1395,7 +1296,14 @@\n-    int dummy;\n-    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n-\n-    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      _is_ptr_to_narrowoop = true;\n+#ifdef ASSERT\n+    if (k != NULL) {\n+      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n+      ciKlass* ck = compute_klass(true);\n+      if (k != ck) {\n+        this->dump(); tty->cr();\n+        tty->print(\" k: \");\n+        k->print(); tty->cr();\n+        tty->print(\"ck: \");\n+        if (ck != NULL) ck->print();\n+        else tty->print(\"<NULL>\");\n+        tty->cr();\n+        assert(false, \"unexpected TypeAryPtr::_klass\");\n+      }\n@@ -1403,1 +1311,1 @@\n-\n+#endif\n@@ -1412,3 +1320,0 @@\n-  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n-\n-  static const InterfaceSet* _array_interfaces;\n@@ -1416,1 +1321,0 @@\n-  \/\/ Only guaranteed non null for array of basic types\n@@ -1421,1 +1325,1 @@\n-  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n@@ -1498,0 +1402,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n@@ -1501,2 +1409,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1550,1 +1456,0 @@\n-  friend class TypePtr;\n@@ -1552,1 +1457,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n@@ -1564,2 +1469,1 @@\n-  const InterfaceSet _interfaces;\n-  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n+\n@@ -1575,4 +1479,0 @@\n-  bool is_same_java_type_as(const TypePtr* other) const {\n-    return is_same_java_type_as_helper(other->is_klassptr());\n-  }\n-\n@@ -1582,1 +1482,1 @@\n-  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1588,1 +1488,0 @@\n-  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1590,2 +1489,4 @@\n-  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling = ignore_interfaces);\n+  bool klass_is_exact()    const { return _ptr == Constant; }\n+\n+  static const TypeKlassPtr* make(ciKlass* klass);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n@@ -1610,2 +1511,0 @@\n-  virtual const TypeKlassPtr* try_improve() const { return this; }\n-\n@@ -1615,24 +1514,0 @@\n-private:\n-  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n-    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n-  }\n-\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n-  virtual const InterfaceSet interfaces() const {\n-    return _interfaces;\n-  };\n-\n-  const TypeKlassPtr* is_reference_type(const Type* other) const {\n-    return other->isa_klassptr();\n-  }\n-\n-  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n-    return other->isa_aryklassptr();\n-  }\n-\n-  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n-    return other->isa_instklassptr();\n-  }\n@@ -1644,3 +1519,2 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset) {\n-    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n@@ -1654,1 +1528,3 @@\n-    assert(!klass()->is_interface(), \"\");\n+    if (klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n@@ -1658,1 +1534,1 @@\n-  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n@@ -1662,9 +1538,2 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n-    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n-    return make(TypePtr::Constant, k, interfaces, 0);\n-  }\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset);\n-\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, int offset) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(ptr, k, interfaces, offset);\n+  static const TypeInstKlassPtr *make(ciKlass* k) {\n+    return make(TypePtr::Constant, k, 0);\n@@ -1672,0 +1541,1 @@\n+  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1687,1 +1557,1 @@\n-  virtual const TypeKlassPtr* try_improve() const;\n+  bool is_interface() const { return klass()->is_interface(); }\n@@ -1692,2 +1562,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1699,3 +1567,0 @@\n-  friend class Type;\n-  friend class TypePtr;\n-\n@@ -1704,1 +1569,0 @@\n-  static const InterfaceSet* _array_interfaces;\n@@ -1706,2 +1570,1 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem) {\n-    assert(klass == NULL || klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n@@ -1711,1 +1574,0 @@\n-  \/\/ Only guaranteed non null for array of basic types\n@@ -1721,1 +1583,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1723,1 +1585,1 @@\n-  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n@@ -1730,1 +1592,1 @@\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr* make(ciKlass* klass);\n@@ -1757,2 +1619,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":92,"deletions":232,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+compiler\/debug\/TestStressCM.java 8297343 generic-all\n+compiler\/debug\/TestStressIGVNAndCCP.java 8297343 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  false,  svalue);\n+        t.runTest(methodObjClassCast,  true,  svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8297556\n- * @summary Parse::check_interpreter_type fails with assert \"must constrain OSR typestate\"\n- *\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileOnly=TestExactArrayOfBasicType::test TestExactArrayOfBasicType\n- *\n- *\/\n-\n-\n-public class TestExactArrayOfBasicType {\n-    public static void test() {\n-        int[][][][][] array = new int[1][2][3][4][5];\n-\n-        for (int i = 0; i < 50_000; ++i) {\n-            array[0] = new int[0][1][2][3];\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestExactArrayOfBasicType.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"}]}