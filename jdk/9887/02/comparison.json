{"files":[{"patch":"@@ -83,1 +83,0 @@\n-SystemDictionaryShared::SavedCpCacheEntriesTable* SystemDictionaryShared::_saved_cpcache_entries_table = NULL;\n@@ -508,1 +507,0 @@\n-    _saved_cpcache_entries_table = new (ResourceObj::C_HEAP, mtClass) SavedCpCacheEntriesTable;\n@@ -521,5 +519,0 @@\n-\n-  ConstantPoolCache* cpc = k->constants()->cache();\n-  if (cpc != NULL) {\n-    remove_saved_cpcache_entries_locked(cpc);\n-  }\n@@ -1339,30 +1332,0 @@\n-void SystemDictionaryShared::set_saved_cpcache_entries(ConstantPoolCache* cpc, ConstantPoolCacheEntry* entries) {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  bool is_new = _saved_cpcache_entries_table->put(cpc, entries);\n-  assert(is_new, \"saved entries must never changed\");\n-}\n-\n-ConstantPoolCacheEntry* SystemDictionaryShared::get_saved_cpcache_entries_locked(ConstantPoolCache* cpc) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  ConstantPoolCacheEntry** p = _saved_cpcache_entries_table->get(cpc);\n-  if (p != nullptr) {\n-    return *p;\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-void SystemDictionaryShared::remove_saved_cpcache_entries(ConstantPoolCache* cpc) {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  remove_saved_cpcache_entries_locked(cpc);\n-}\n-\n-void SystemDictionaryShared::remove_saved_cpcache_entries_locked(ConstantPoolCache* cpc) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  ConstantPoolCacheEntry** p = _saved_cpcache_entries_table->get(cpc);\n-  if (p != nullptr) {\n-    _saved_cpcache_entries_table->remove(cpc);\n-    FREE_C_HEAP_ARRAY(ConstantPoolCacheEntry, *p);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -171,9 +171,0 @@\n-  \/\/ Doesn't need to be cloned as it's not modified during dump time.\n-  using SavedCpCacheEntriesTable = ResourceHashtable<\n-    ConstantPoolCache*,\n-    ConstantPoolCacheEntry*,\n-    15889, \/\/ prime number\n-    ResourceObj::C_HEAP,\n-    mtClassShared>;\n-  static SavedCpCacheEntriesTable* _saved_cpcache_entries_table;\n-\n@@ -251,5 +242,0 @@\n-  static void set_saved_cpcache_entries(ConstantPoolCache* cpc, ConstantPoolCacheEntry* entries);\n-  static ConstantPoolCacheEntry* get_saved_cpcache_entries_locked(ConstantPoolCache* k);\n-  static void remove_saved_cpcache_entries(ConstantPoolCache* cpc);\n-  static void remove_saved_cpcache_entries_locked(ConstantPoolCache* cpc);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -115,0 +115,11 @@\n+  if (!HAS_PENDING_EXCEPTION && Arguments::is_dumping_archive()) {\n+    if (_pool->pool_holder()->is_shared()) {\n+      assert(DynamicDumpSharedSpaces, \"must be\");\n+      \/\/ We are linking a shared class from the base archive. This\n+      \/\/ class won't be written into the dynamic archive, so there's no\n+      \/\/ need to save its CpCaches.\n+    } else {\n+      cache->save_for_archive(THREAD);\n+    }\n+  }\n+\n@@ -119,11 +130,0 @@\n-  } else {\n-    if (Arguments::is_dumping_archive()) {\n-      if (_pool->pool_holder()->is_shared()) {\n-        assert(DynamicDumpSharedSpaces, \"must be\");\n-        \/\/ We are linking a shared class from the base archive. This\n-        \/\/ class won't be written into the dynamic archive, so there's no\n-        \/\/ need to save its CpCaches.\n-      } else {\n-        cache->save_for_archive();\n-      }\n-    }\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -686,1 +687,1 @@\n-void ConstantPoolCache::save_for_archive() {\n+void ConstantPoolCache::save_for_archive(TRAPS) {\n@@ -688,1 +689,2 @@\n-  ConstantPoolCacheEntry* copy = NEW_C_HEAP_ARRAY(ConstantPoolCacheEntry, length(), mtClassShared);\n+  ClassLoaderData* loader_data = constant_pool()->pool_holder()->class_loader_data();\n+  _initial_entries = MetadataFactory::new_array<ConstantPoolCacheEntry>(loader_data, length(), CHECK);\n@@ -690,1 +692,1 @@\n-    copy[i] = *entry_at(i);\n+    _initial_entries->at_put(i, *entry_at(i));\n@@ -692,2 +694,0 @@\n-\n-  SystemDictionaryShared::set_saved_cpcache_entries(this, copy);\n@@ -700,5 +700,5 @@\n-  \/\/ <this> is the copy to be written into the archive. It's in\n-  \/\/ the ArchiveBuilder's \"buffer space\". However, the saved_cpcache_entries\n-  \/\/ are recorded with the original ConstantPoolCache object.\n-  ConstantPoolCache* orig_cpc = ArchiveBuilder::current()->get_src_obj(this);\n-  ConstantPoolCacheEntry* saved = SystemDictionaryShared::get_saved_cpcache_entries_locked(orig_cpc);\n+  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n+  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n+  \/\/ still pointing to the array allocated inside save_for_archive().\n+  assert(_initial_entries != NULL, \"archived cpcache must have been initialized\");\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(_initial_entries), \"must be\");\n@@ -708,1 +708,1 @@\n-    *entry_at(i) = saved[i];\n+    *entry_at(i) = _initial_entries->at(i);\n@@ -710,0 +710,1 @@\n+  _initial_entries = NULL;\n@@ -719,1 +720,0 @@\n-\n@@ -721,2 +721,4 @@\n-  if (Arguments::is_dumping_archive()) {\n-    SystemDictionaryShared::remove_saved_cpcache_entries(this);\n+  if (_initial_entries != NULL) {\n+    Arguments::assert_is_dumping_archive();\n+    MetadataFactory::free_array<ConstantPoolCacheEntry>(data, _initial_entries);\n+    _initial_entries = NULL;\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -404,0 +404,5 @@\n+\n+  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n+  \/\/ time when caching java heap object is supported.\n+  CDS_JAVA_HEAP_ONLY(int _archived_references_index;) \/\/ Gap on LP64\n+\n@@ -416,3 +421,1 @@\n-  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n-  \/\/ time when caching java heap object is supported.\n-  CDS_JAVA_HEAP_ONLY(int _archived_references_index;)\n+  CDS_ONLY(Array<ConstantPoolCacheEntry>* _initial_entries;)\n@@ -457,1 +460,1 @@\n-  void save_for_archive();\n+  void save_for_archive(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -579,2 +579,0 @@\n-  SystemDictionaryShared::handle_class_unloading(this);\n-\n@@ -695,0 +693,2 @@\n+\n+  SystemDictionaryShared::handle_class_unloading(this);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    String msg = \"OutOfMemoryError: Metaspace\";\n+    String msg = \"OutOfMemoryError: ((Metaspace)|(Compressed class space))\";\n@@ -56,1 +56,1 @@\n-    CDSTestUtils.executeAndLog(pb, \"dump\").shouldContain(msg).shouldHaveExitValue(1);\n+    CDSTestUtils.executeAndLog(pb, \"dump\").shouldMatch(msg).shouldHaveExitValue(1);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/MaxMetaspaceSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}