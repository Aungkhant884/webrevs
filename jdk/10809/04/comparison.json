{"files":[{"patch":"@@ -122,0 +122,1 @@\n+        qualifiedSymbolCache = new HashMap<>();\n@@ -3620,0 +3621,50 @@\n+    \/** Cache the symbol to reflect the qualifying type.\n+     *  key: corresponding type\n+     *  value: qualified symbol\n+     *\/\n+    private Map<Type, Symbol> qualifiedSymbolCache;\n+\n+    public void clearQualifiedSymbolCache() {\n+        qualifiedSymbolCache.clear();\n+    }\n+\n+    \/** Construct a symbol to reflect the qualifying type that should\n+     *  appear in the byte code as per JLS 13.1.\n+     *\n+     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n+     *  for those cases where we need to work around VM bugs).\n+     *\n+     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n+     *  non-accessible class, clone it with the qualifier class as owner.\n+     *\n+     *  @param sym    The accessed symbol\n+     *  @param site   The qualifier's type.\n+     *\/\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n+\n+        if (site.hasTag(ARRAY)) {\n+            if (sym == syms.lengthVar ||\n+                    sym.owner != syms.arrayClass)\n+                return sym;\n+            \/\/ array clone can be qualified by the array type in later targets\n+            Symbol qualifier;\n+            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n+                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n+                qualifiedSymbolCache.put(site, qualifier);\n+            }\n+            return sym.clone(qualifier);\n+        }\n+\n+        if (sym.owner == site.tsym ||\n+                (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n+            return sym;\n+        }\n+\n+        \/\/ leave alone methods inherited from Object\n+        \/\/ JLS 13.1.\n+        if (sym.owner == syms.objectType.tsym)\n+            return sym;\n+\n+        return sym.clone(site.tsym);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -521,0 +521,3 @@\n+        if (init != null) {\n+            refSym = (MethodSymbol) types.binaryQualifier(refSym, init.type);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-        qualifiedSymbolCache = new HashMap<>();\n@@ -175,6 +174,0 @@\n-    \/** Cache the symbol to reflect the qualifying type.\n-     *  key: corresponding type\n-     *  value: qualified symbol\n-     *\/\n-    Map<Type, Symbol> qualifiedSymbolCache;\n-\n@@ -224,40 +217,0 @@\n-    \/** Construct a symbol to reflect the qualifying type that should\n-     *  appear in the byte code as per JLS 13.1.\n-     *\n-     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n-     *  for those cases where we need to work around VM bugs).\n-     *\n-     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n-     *  non-accessible class, clone it with the qualifier class as owner.\n-     *\n-     *  @param sym    The accessed symbol\n-     *  @param site   The qualifier's type.\n-     *\/\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n-\n-        if (site.hasTag(ARRAY)) {\n-            if (sym == syms.lengthVar ||\n-                sym.owner != syms.arrayClass)\n-                return sym;\n-            \/\/ array clone can be qualified by the array type in later targets\n-            Symbol qualifier;\n-            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n-                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n-                qualifiedSymbolCache.put(site, qualifier);\n-            }\n-            return sym.clone(qualifier);\n-        }\n-\n-        if (sym.owner == site.tsym ||\n-            (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n-            return sym;\n-        }\n-\n-        \/\/ leave alone methods inherited from Object\n-        \/\/ JLS 13.1.\n-        if (sym.owner == syms.objectType.tsym)\n-            return sym;\n-\n-        return sym.clone(site.tsym);\n-    }\n-\n@@ -2283,1 +2236,1 @@\n-                sym = binaryQualifier(sym, env.enclClass.type);\n+                sym = types.binaryQualifier(sym, env.enclClass.type);\n@@ -2287,1 +2240,1 @@\n-            sym = binaryQualifier(sym, env.enclClass.type);\n+            sym = types.binaryQualifier(sym, env.enclClass.type);\n@@ -2340,1 +2293,1 @@\n-                sym = binaryQualifier(sym, tree.selected.type);\n+                sym = types.binaryQualifier(sym, tree.selected.type);\n@@ -2446,1 +2399,1 @@\n-            qualifiedSymbolCache.clear();\n+            types.clearQualifiedSymbolCache();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":51,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8059632\n+ * @summary Method reference compilation uses incorrect qualifying type\n+ * @compile MethodRefQualifyingTypeTest.java\n+ * @compile MethodSupplierImpl.java\n+ * @run main MethodRefQualifyingTypeTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+\n+public class MethodRefQualifyingTypeTest {\n+\n+    static abstract class MethodSupplierImpl implements MethodSupplier {\n+        class Inner {\n+            MethodRefQualifyingTypeTest.MyFunctionalInterface createMethodReference() {\n+                return MethodSupplierImpl.this::<Integer>m;\n+            }\n+        }\n+    }\n+\n+    interface MethodSupplier {\n+        int m(int a);\n+    }\n+\n+    interface MyFunctionalInterface {\n+        int invokeMethodReference(int a);\n+    }\n+\n+    static class MethodInvoker {\n+        public static void invoke() {\n+            MyFunctionalInterface instance = null;\n+            MethodSupplierImpl ms = new MethodSupplierImpl() {\n+                    public int m(int a) {\n+                        return a;\n+                    }\n+                };\n+            instance = ms.new Inner().createMethodReference();\n+            instance.invokeMethodReference(1);\n+        }\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+\n+        \/\/ Without the fix for JDK-8059632, the invocation below will fail with\n+        \/\/ java.lang.invoke.LambdaConversionException: Invalid receiver type class MethodRefQualifyingTypeTest$MethodSupplierImpl; not a subtype of implementation type interface MethodRefQualifyingTypeTest$MethodSupplier\n+\n+        \/\/ With the fix for JDK-8059632, the invocation would succeed since the bootstrap section\n+        \/\/ would refer to the type of the receiver and not the type of the declaring interface,\n+        \/\/ per JLS 13.1 (see \"the qualifying type of the method invocation\").\n+\n+        Class.forName(\"MethodRefQualifyingTypeTest$MethodInvoker\").getMethod(\"invoke\").invoke(null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/8059632\/MethodRefQualifyingTypeTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class MethodRefQualifyingTypeTest$MethodSupplierImpl {\n+    int m(int a) { return a; }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/8059632\/MethodSupplierImpl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8059632\n+ * @summary Method reference compilation uses incorrect qualifying type\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *\/\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.BootstrapMethods_attribute;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import static com.sun.tools.javac.jvm.ClassFile.*;\n+import com.sun.tools.classfile.ConstantPool.*;\n+\n+public class TestBootstrapInvocation {\n+\n+    public static void main(String... args) throws Exception {\n+        JavaCompiler comp = ToolProvider.getSystemJavaCompiler();\n+        new TestBootstrapInvocation().run(comp);\n+    }\n+\n+    DiagChecker dc;\n+\n+    TestBootstrapInvocation() {\n+        dc = new DiagChecker();\n+    }\n+\n+    public void run(JavaCompiler comp) {\n+        JavaSource source = new JavaSource();\n+        JavacTaskImpl ct = (JavacTaskImpl)comp.getTask(null, null, dc,\n+                Arrays.asList(\"-g\"), null, Arrays.asList(source));\n+        try {\n+            ct.generate();\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new AssertionError(\n+                    String.format(\"Error thrown when compiling following code\\n%s\",\n+                            source.source));\n+        }\n+        if (dc.diagFound) {\n+            throw new AssertionError(\n+                    String.format(\"Diags found when compiling following code\\n%s\\n\\n%s\",\n+                            source.source, dc.printDiags()));\n+        }\n+        verifyBytecode();\n+    }\n+\n+    void verifyBytecode() {\n+        File compiledTest = new File(\"Test.class\");\n+        try {\n+            ClassFile cf = ClassFile.read(compiledTest);\n+            BootstrapMethods_attribute bsm_attr =\n+                    (BootstrapMethods_attribute)cf\n+                            .getAttribute(Attribute.BootstrapMethods);\n+            int length = bsm_attr.bootstrap_method_specifiers.length;\n+            if (length != 1) {\n+                throw new Error(\"Bad number of method specifiers \" +\n+                        \"in BootstrapMethods attribute: \" + length);\n+            }\n+            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =\n+                    bsm_attr.bootstrap_method_specifiers[0];\n+\n+            if (bsm_spec.bootstrap_arguments.length != 3) {\n+                throw new Error(\"Bad number of static invokedynamic args \" +\n+                        \"in BootstrapMethod attribute\");\n+            }\n+            CONSTANT_MethodHandle_info mh =\n+                    (CONSTANT_MethodHandle_info)cf.constant_pool.get(bsm_spec.bootstrap_arguments[1]);\n+\n+            if (mh.reference_kind != RefKind.REF_invokeVirtual) {\n+                throw new Error(\"Bad invoke kind in implementation method handle: \" + mh.reference_kind);\n+            }\n+            if (!mh.getCPRefInfo().getClassName().equals(\"Test$C\")) {\n+                throw new Error(\"Unexpected class name: \" + mh.getCPRefInfo().getClassName());\n+            }\n+            if (!mh.getCPRefInfo().getNameAndTypeInfo().getName().equals(\"m\")) {\n+                throw new Error(\"Unexpected method referenced in method handle in bootstrap section: \" +\n+                                     mh.getCPRefInfo().getNameAndTypeInfo().getName());\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new Error(\"error reading \" + compiledTest +\": \" + e);\n+        }\n+    }\n+\n+    class JavaSource extends SimpleJavaFileObject {\n+\n+        static final String source =\n+\n+            \"\"\"\n+            class Test {\n+                interface I { void m(); }\n+                abstract class C implements I {}\n+                public void test(C arg) {\n+                    Runnable r = arg::m;\n+                }\n+            }\n+            \"\"\";\n+\n+        JavaSource() {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return source;\n+        }\n+    }\n+\n+    static class DiagChecker\n+            implements javax.tools.DiagnosticListener<JavaFileObject> {\n+\n+        boolean diagFound;\n+        ArrayList<String> diags = new ArrayList<>();\n+\n+        public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n+            diags.add(diagnostic.getMessage(Locale.getDefault()));\n+            diagFound = true;\n+        }\n+\n+        String printDiags() {\n+            StringBuilder buf = new StringBuilder();\n+            for (String s : diags) {\n+                buf.append(s);\n+                buf.append(\"\\n\");\n+            }\n+            return buf.toString();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/8059632\/TestBootstrapInvocation.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"}]}