{"files":[{"patch":"@@ -51,0 +51,1 @@\n+        private final HotSpotJVMCIRuntime runtime;\n@@ -52,1 +53,1 @@\n-        DummyCompilerFactory(String reason) {\n+        DummyCompilerFactory(String reason, HotSpotJVMCIRuntime runtime) {\n@@ -54,0 +55,1 @@\n+            this.runtime = runtime;\n@@ -58,1 +60,1 @@\n-            throw new JVMCIError(\"no JVMCI compiler selected: \" + reason);\n+            throw runtime.exitHotSpotWithMessage(1, \"Cannot use JVMCI compiler: \" + reason);\n@@ -67,1 +69,1 @@\n-        public JVMCICompiler createCompiler(JVMCIRuntime runtime) {\n+        public JVMCICompiler createCompiler(JVMCIRuntime rt) {\n@@ -84,1 +86,1 @@\n-    static JVMCICompilerFactory getCompilerFactory() {\n+    static JVMCICompilerFactory getCompilerFactory(HotSpotJVMCIRuntime runtime) {\n@@ -90,1 +92,1 @@\n-                    factory = new DummyCompilerFactory(\" empty \\\"\\\" is specified\");\n+                    factory = new DummyCompilerFactory(\" empty \\\"\\\" is specified\", runtime);\n@@ -92,1 +94,1 @@\n-                    factory = new DummyCompilerFactory(\"\\\"null\\\" is specified\");\n+                    factory = new DummyCompilerFactory(\"\\\"null\\\" is specified\", runtime);\n@@ -101,1 +103,1 @@\n-                            throw new JVMCIError(\"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n+                            throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n@@ -105,1 +107,1 @@\n-                        throw new JVMCIError(\"JVMCI compiler '%s' not found\", compilerName);\n+                        throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' not found\", compilerName);\n@@ -110,1 +112,1 @@\n-                String reason = \"default compiler is not found\";\n+                String reason = \"No JVMCI compiler found\";\n@@ -117,1 +119,1 @@\n-                        reason = \"multiple factories seen: \\\"\" + factory.getCompilerName() + \"\\\" and \\\"\" + f.getCompilerName() + \"\\\"\";\n+                        reason = \"Multiple JVMCI compilers found: \\\"\" + factory.getCompilerName() + \"\\\" and \\\"\" + f.getCompilerName() + \"\\\"\";\n@@ -123,1 +125,1 @@\n-                    factory = new DummyCompilerFactory(reason);\n+                    factory = new DummyCompilerFactory(reason, runtime);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import jdk.vm.ci.services.Services;\n@@ -383,1 +382,1 @@\n-         * @param compilerToVm\n+         * @param runtime\n@@ -385,1 +384,1 @@\n-        static void parse(CompilerToVM compilerToVm) {\n+        static void parse(HotSpotJVMCIRuntime runtime) {\n@@ -408,3 +407,1 @@\n-                        byte[] msgBytes = msg.toString().getBytes();\n-                        compilerToVm.writeDebugOutput(msgBytes, 0, msgBytes.length, true, true);\n-                        compilerToVm.callSystemExit(1);\n+                        runtime.exitHotSpotWithMessage(1, msg.toString());\n@@ -539,1 +536,1 @@\n-        Option.parse(compilerToVm);\n+        Option.parse(this);\n@@ -552,1 +549,1 @@\n-        compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();\n+        compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory(this);\n@@ -1164,2 +1161,2 @@\n-     * Informs HotSpot that no method whose module is in {@code modules} is to be compiled\n-     * with {@link #compileMethod}.\n+     * Informs HotSpot that no method whose module is in {@code modules} is to be compiled with\n+     * {@link #compileMethod}.\n@@ -1169,1 +1166,1 @@\n-    public void excludeFromJVMCICompilation(Module...modules) {\n+    public void excludeFromJVMCICompilation(Module... modules) {\n@@ -1182,0 +1179,11 @@\n+\n+    \/**\n+     * Writes a message to HotSpot's log stream and then calls {@link System#exit(int)} in HotSpot's\n+     * runtime.\n+     *\/\n+    JVMCIError exitHotSpotWithMessage(int status, String format, Object... args) {\n+        byte[] messageBytes = String.format(format, args).getBytes();\n+        compilerToVm.writeDebugOutput(messageBytes, 0, messageBytes.length, true, true);\n+        exitHotSpot(status);\n+        throw JVMCIError.shouldNotReachHere();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -83,1 +83,5 @@\n-        output.shouldHaveExitValue(0);\n+        if (output.getExitValue() != 0) {\n+            \/\/ This should only happen when JVMCI compilation is requested and the VM has no\n+            \/\/ JVMCI compiler (e.g. Graal is not included in the build)\n+            output.stdoutShouldMatch(\"No JVMCI compiler found\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestEnableJVMCIProduct.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}