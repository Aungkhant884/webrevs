{"files":[{"patch":"@@ -1695,21 +1695,0 @@\n-  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n-\n-  Thread* thread = Thread::current();\n-  if (thread->is_VM_thread()) {\n-    post_object_free_on_vm_thread(env, objects);\n-  } else {\n-    post_object_free_on_java_thread(env, objects);\n-  }\n-}\n-\n-void JvmtiExport::post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n-  EVT_TRIG_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Trg Object Free triggered\" ));\n-  EVT_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Evt Object Free sent\"));\n-\n-  jvmtiEventObjectFree callback = env->callbacks()->ObjectFree;\n-  if (callback != NULL) {\n-    for (int index = 0; index < objects->length(); index++) {\n-      (*callback)(env->jvmti_external(), objects->at(index));\n-    }\n-  }\n-}\n@@ -1717,1 +1696,0 @@\n-void JvmtiExport::post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n@@ -1719,1 +1697,0 @@\n-\n@@ -1723,0 +1700,1 @@\n+  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -439,3 +439,0 @@\n-private:\n-  static void post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n-  static void post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,4 +139,2 @@\n-\/\/ this tagmap table.  The calls from a JavaThread only rehash, posting is\n-\/\/ only done before heap walks.\n-void JvmtiTagMap::check_hashmap(bool post_events) {\n-  assert(!post_events || SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+\/\/ this tagmap table.\n+void JvmtiTagMap::check_hashmap(GrowableArray<jlong>* objects) {\n@@ -148,1 +146,1 @@\n-      post_events &&\n+      objects != NULL &&\n@@ -150,1 +148,1 @@\n-    remove_and_post_dead_objects(true \/* locked *\/);\n+    remove_dead_entries_locked(objects);\n@@ -160,1 +158,1 @@\n-void JvmtiTagMap::check_hashmaps_for_heapwalk() {\n+void JvmtiTagMap::check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects) {\n@@ -171,1 +169,1 @@\n-      tag_map->check_hashmap(\/*post_events*\/ true);\n+      tag_map->check_hashmap(objects);\n@@ -362,1 +360,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL);  \/* don't collect dead objects *\/\n@@ -397,1 +395,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL); \/* don't collect dead objects *\/\n@@ -892,0 +890,1 @@\n+  GrowableArray<jlong>* const _dead_objects;\n@@ -893,1 +892,2 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }\n+  VM_HeapIterateOperation(ObjectClosure* blk, GrowableArray<jlong>* objects) :\n+    _blk(blk), _dead_objects(objects) { }\n@@ -900,1 +900,1 @@\n-    JvmtiTagMap::check_hashmaps_for_heapwalk();\n+    JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -914,1 +914,0 @@\n-\n@@ -1145,1 +1144,3 @@\n-  VM_HeapIterateOperation op(&blk);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  VM_HeapIterateOperation op(&blk, &dead_objects);\n@@ -1147,0 +1148,1 @@\n+  post_dead_objects(&dead_objects);\n@@ -1160,8 +1162,15 @@\n-  MutexLocker ml(Heap_lock);\n-  IterateThroughHeapObjectClosure blk(this,\n-                                      klass,\n-                                      heap_filter,\n-                                      callbacks,\n-                                      user_data);\n-  VM_HeapIterateOperation op(&blk);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    IterateThroughHeapObjectClosure blk(this,\n+                                        klass,\n+                                        heap_filter,\n+                                        callbacks,\n+                                        user_data);\n+    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -1189,1 +1198,9 @@\n-void JvmtiTagMap::remove_and_post_dead_objects(bool locked) {\n+void JvmtiTagMap::post_dead_objects(GrowableArray<jlong>* const objects) {\n+  assert(Thread::current()->is_Java_thread(), \"Must post from JavaThread\");\n+  if (objects != NULL && objects->length() > 0) {\n+    JvmtiExport::post_object_free(env(), objects);\n+    log_info(jvmti)(\"%d free object posted\", objects->length());\n+  }\n+}\n+\n+void JvmtiTagMap::remove_and_post_dead_objects() {\n@@ -1192,8 +1209,2 @@\n-  if (locked) {\n-    assert(lock()->owned_by_self(), \"Already locked\");\n-    remove_dead_entries_locked(&objects);\n-  } else {\n-    remove_dead_entries(&objects);\n-  }\n-  JvmtiExport::post_object_free(env(), &objects);\n-  log_info(jvmti)(\"%d free object posted\", objects.length());\n+  remove_dead_entries(&objects);\n+  post_dead_objects(&objects);\n@@ -1214,1 +1225,1 @@\n-    remove_and_post_dead_objects(false \/* locked *\/);\n+    remove_and_post_dead_objects();\n@@ -1329,1 +1340,1 @@\n-    remove_and_post_dead_objects(false \/* locked *\/);\n+    remove_and_post_dead_objects();\n@@ -2251,0 +2262,3 @@\n+  \/\/ Dead object tags in JvmtiTagMap\n+  GrowableArray<jlong>* _dead_objects;\n+\n@@ -2292,1 +2306,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2297,1 +2312,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2309,1 +2325,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2318,0 +2335,1 @@\n+  _dead_objects = objects;\n@@ -2325,1 +2343,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2334,0 +2353,1 @@\n+  _dead_objects = objects;\n@@ -2802,1 +2822,1 @@\n-  JvmtiTagMap::check_hashmaps_for_heapwalk();\n+  JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -2841,4 +2861,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n-  VM_HeapWalkOperation op(this, Handle(), context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n+    VM_HeapWalkOperation op(this, Handle(), context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -2854,4 +2880,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -2875,4 +2907,11 @@\n-  MutexLocker ml(Heap_lock);\n-  AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":89,"deletions":50,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  void check_hashmap(bool post_events);\n+  void check_hashmap(GrowableArray<jlong>* objects);\n@@ -57,1 +57,0 @@\n-  void remove_and_post_dead_objects(bool locked);\n@@ -112,1 +111,1 @@\n-\n+  void remove_and_post_dead_objects();\n@@ -115,0 +114,1 @@\n+  void post_dead_objects(GrowableArray<jlong>* const objects);\n@@ -116,1 +116,1 @@\n-  static void check_hashmaps_for_heapwalk();\n+  static void check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-        \/\/ collect object tag for posting JVMTI event later\n+        \/\/ collect object tags for posting JVMTI events later\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  \/\/ Cleanup cleared entries and store dead objects in objects array\n+  \/\/ Cleanup cleared entries and store dead object tags in objects array\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-extern void JNICALL\n-cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag);\n+extern jboolean synthesizeUnloadEvent(char *signature, JNIEnv *env);\n@@ -52,1 +51,1 @@\n- * Add a class to the prepared class table.\n+ * Invoke the callback when classes are freed.\n@@ -54,0 +53,6 @@\n+void JNICALL\n+cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n+{\n+  synthesizeUnloadEvent((char*)jlong_to_ptr(tag), getEnv());\n+}\n+\n@@ -150,16 +155,0 @@\n-\n-\/*\n- * Called to activate class-tracking when a listener registers for EI_GC_FINISH.\n- *\/\n-void\n-classTrack_activate(JNIEnv *env)\n-{ }\n-\n-\/*\n- *\n- * Called when agent detaches.\n- *\/\n-void\n-classTrack_reset(void)\n-{}\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -798,1 +798,0 @@\n-    classTrack_reset();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -460,5 +460,2 @@\n-\/* Create a synthetic class unload event for every class no longer present.\n- * Analogous to event_callback combined with a handler in a unload specific\n- * (no event structure) kind of way.\n- *\/\n-static jboolean\n+\/* Create a synthetic class unload event for the specified signature. *\/\n+jboolean\n@@ -626,4 +623,0 @@\n-    if (evinfo->ei == EI_CLASS_UNLOAD) {\n-        synthesizeUnloadEvent((char*)jlong_to_ptr(evinfo->tag), env);\n-    }\n-\n@@ -962,21 +955,0 @@\n-\/*\n- * Invoke the callback when classes are freed.\n- *\/\n-void JNICALL\n-cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n-{\n-    EventInfo info;\n-\n-    LOG_CB((\"cbTrackingObjectFree\"));\n-\n-    BEGIN_CALLBACK() {\n-    (void)memset(&info,0,sizeof(info));\n-    info.ei         = EI_CLASS_UNLOAD;\n-    info.tag        = tag;\n-    event_callback(getEnv(), &info);\n-    } END_CALLBACK();\n-\n-    LOG_MISC((\"END cbTrackingObjectFree\"));\n-\n-}\n-\n@@ -1705,3 +1677,0 @@\n-    if (node->ei == EI_GC_FINISH) {\n-        classTrack_activate(getEnv());\n-    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -165,16 +165,15 @@\n-        EI_CLASS_UNLOAD         = 10,\n-        EI_FIELD_ACCESS         = 11,\n-        EI_FIELD_MODIFICATION   = 12,\n-        EI_EXCEPTION_CATCH      = 13,\n-        EI_METHOD_ENTRY         = 14,\n-        EI_METHOD_EXIT          = 15,\n-        EI_MONITOR_CONTENDED_ENTER = 16,\n-        EI_MONITOR_CONTENDED_ENTERED = 17,\n-        EI_MONITOR_WAIT         = 18,\n-        EI_MONITOR_WAITED       = 19,\n-        EI_VM_INIT              = 20,\n-        EI_VM_DEATH             = 21,\n-        EI_VIRTUAL_THREAD_START = 22,\n-        EI_VIRTUAL_THREAD_END   = 23,\n-\n-        EI_max                  = 23\n+        EI_FIELD_ACCESS         = 10,\n+        EI_FIELD_MODIFICATION   = 11,\n+        EI_EXCEPTION_CATCH      = 12,\n+        EI_METHOD_ENTRY         = 13,\n+        EI_METHOD_EXIT          = 14,\n+        EI_MONITOR_CONTENDED_ENTER = 15,\n+        EI_MONITOR_CONTENDED_ENTERED = 16,\n+        EI_MONITOR_WAIT         = 17,\n+        EI_MONITOR_WAITED       = 18,\n+        EI_VM_INIT              = 19,\n+        EI_VM_DEATH             = 20,\n+        EI_VIRTUAL_THREAD_START = 21,\n+        EI_VIRTUAL_THREAD_END   = 22,\n+\n+        EI_max                  = 22\n@@ -226,1 +225,0 @@\n-    jlong       tag;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"}]}