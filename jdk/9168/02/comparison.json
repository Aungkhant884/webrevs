{"files":[{"patch":"@@ -1693,2 +1693,11 @@\n-void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {\n-  Thread *thread = Thread::current();\n+void JvmtiExport::post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  assert(objects != NULL, \"Nothing to post\");\n+  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n+\n+  Thread* thread = Thread::current();\n+  if (thread->is_VM_thread()) {\n+    post_object_free_on_vm_thread(env, objects);\n+  } else {\n+    post_object_free_on_java_thread(env, objects);\n+  }\n+}\n@@ -1696,1 +1705,16 @@\n-  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMS_transition()) {\n+void JvmtiExport::post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  EVT_TRIG_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Trg Object Free triggered\" ));\n+  EVT_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Evt Object Free sent\"));\n+\n+  jvmtiEventObjectFree callback = env->callbacks()->ObjectFree;\n+  if (callback != NULL) {\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n+  }\n+}\n+\n+void JvmtiExport::post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  JavaThread *javaThread = JavaThread::current();\n+\n+  if (javaThread->is_in_VTMS_transition()) {\n@@ -1699,1 +1723,0 @@\n-  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n@@ -1704,0 +1727,2 @@\n+  JvmtiThreadEventMark jem(javaThread);\n+  JvmtiJavaThreadEventTransition jet(javaThread);\n@@ -1706,1 +1731,3 @@\n-    (*callback)(env->jvmti_external(), tag);\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-  static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;\n+  static void post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n@@ -439,0 +439,3 @@\n+private:\n+  static void post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n+  static void post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-    remove_dead_entries_locked(true \/* post_object_free *\/);\n+    remove_and_post_dead_objects(true \/* locked *\/);\n@@ -1170,1 +1170,1 @@\n-void JvmtiTagMap::remove_dead_entries_locked(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries_locked(GrowableArray<jlong>* objects) {\n@@ -1174,1 +1174,3 @@\n-    post_object_free = post_object_free && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n+    if (!env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+      objects = NULL;\n+    }\n@@ -1176,2 +1178,2 @@\n-                           (post_object_free ? \" and posting\" : \"\"));\n-    hashmap()->remove_dead_entries(env(), post_object_free);\n+                           ((objects != NULL) ? \" and posting\" : \"\"));\n+    hashmap()->remove_dead_entries(objects);\n@@ -1182,1 +1184,1 @@\n-void JvmtiTagMap::remove_dead_entries(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -1184,1 +1186,1 @@\n-  remove_dead_entries_locked(post_object_free);\n+  remove_dead_entries_locked(objects);\n@@ -1187,7 +1189,8 @@\n-class VM_JvmtiPostObjectFree: public VM_Operation {\n-  JvmtiTagMap* _tag_map;\n- public:\n-  VM_JvmtiPostObjectFree(JvmtiTagMap* tag_map) : _tag_map(tag_map) {}\n-  VMOp_Type type() const { return VMOp_Cleanup; }\n-  void doit() {\n-    _tag_map->remove_dead_entries(true \/* post_object_free *\/);\n+void JvmtiTagMap::remove_and_post_dead_objects(bool locked) {\n+  ResourceMark rm;\n+  GrowableArray<jlong> objects;\n+  if (locked) {\n+    assert(lock()->owned_by_self(), \"Already locked\");\n+    remove_dead_entries_locked(&objects);\n+  } else {\n+    remove_dead_entries(&objects);\n@@ -1195,9 +1198,2 @@\n-\n-  \/\/ Doesn't need a safepoint, just the VM thread\n-  virtual bool evaluate_at_safepoint() const { return false; }\n-};\n-\n-\/\/ PostObjectFree can't be called by JavaThread, so call it from the VM thread.\n-void JvmtiTagMap::post_dead_objects_on_vm_thread() {\n-  VM_JvmtiPostObjectFree op(this);\n-  VMThread::execute(&op);\n+  JvmtiExport::post_object_free(env(), &objects);\n+  log_info(jvmti)(\"%d free object posted\", objects.length());\n@@ -1218,1 +1214,1 @@\n-    post_dead_objects_on_vm_thread();\n+    remove_and_post_dead_objects(false \/* locked *\/);\n@@ -1220,1 +1216,1 @@\n-    remove_dead_entries(false);\n+    remove_dead_entries(NULL);\n@@ -1333,1 +1329,1 @@\n-    post_dead_objects_on_vm_thread();\n+    remove_and_post_dead_objects(false \/* locked *\/);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  void post_dead_objects_on_vm_thread();\n+  void remove_and_post_dead_objects(bool locked);\n@@ -113,2 +113,2 @@\n-  void remove_dead_entries(bool post_object_free);\n-  void remove_dead_entries_locked(bool post_object_free);\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n+  void remove_dead_entries_locked(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,2 +189,3 @@\n-\/\/ Serially remove entries for dead oops from the table, and notify jvmti.\n-void JvmtiTagMapTable::remove_dead_entries(JvmtiEnv* env, bool post_object_free) {\n+\/\/ Serially remove entries for dead oops from the table and store dead oops'\n+\/\/ tag in objects array if provided.\n+void JvmtiTagMapTable::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -209,3 +210,3 @@\n-        \/\/ post the event to the profiler\n-        if (post_object_free) {\n-          JvmtiExport::post_object_free(env, tag);\n+        \/\/ collect object tag for posting JVMTI event later\n+        if (objects != NULL) {\n+          objects->append(tag);\n@@ -213,1 +214,0 @@\n-\n@@ -220,2 +220,2 @@\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d; %s\",\n-                          oops_counted, oops_removed, post_object_free ? \"free object posted\" : \"no posting\");\n+  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n+                          oops_counted, oops_removed);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,2 @@\n-  \/\/ Cleanup cleared entries and post\n-  void remove_dead_entries(JvmtiEnv* env, bool post_object_free);\n+  \/\/ Cleanup cleared entries and store dead objects in objects array\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,55 +48,2 @@\n-\/*\n- * A bag containing all the deleted classes' signatures. Must be accessed under\n- * classTrackLock.\n- *\/\n-struct bag* deletedSignatures;\n-\n-\/*\n- * Lock to keep integrity of deletedSignatures.\n- *\/\n-static jrawMonitorID classTrackLock;\n-\n-\/*\n- * Invoke the callback when classes are freed, find and record the signature\n- * in deletedSignatures. Those are only used in addPreparedClass() by the\n- * same thread.\n- *\/\n-static void JNICALL\n-cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n-{\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-      debugMonitorExit(classTrackLock);\n-      return;\n-    }\n-    *(char**)bagAdd(deletedSignatures) = (char*)jlong_to_ptr(tag);\n-\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-\/*\n- * Called after class unloads have occurred.\n- * The signatures of classes which were unloaded are returned.\n- *\/\n-struct bag *\n-classTrack_processUnloads(JNIEnv *env)\n-{\n-    if (deletedSignatures == NULL) {\n-      return NULL;\n-    }\n-\n-    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n-     *\n-     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n-     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n-     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n-     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n-     * which can lead to deadlock.\n-     *\/\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-    return deleted;\n-}\n+extern void JNICALL\n+cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag);\n@@ -172,2 +119,0 @@\n-    deletedSignatures = NULL;\n-    classTrackLock = debugMonitorCreate(\"Deleted class tag lock\");\n@@ -211,16 +156,1 @@\n-{\n-    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n-    debugMonitorEnter(classTrackLock);\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-static jboolean\n-cleanDeleted(void *signatureVoid, void *arg)\n-{\n-    char* sig = *(char**)signatureVoid;\n-    jvmtiDeallocate(sig);\n-    return JNI_TRUE;\n-}\n+{ }\n@@ -229,0 +159,1 @@\n+ *\n@@ -233,13 +164,2 @@\n-{\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* to_delete = deletedSignatures;\n-    deletedSignatures = NULL;\n-    debugMonitorExit(classTrackLock);\n-\n-    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    if (to_delete != NULL) {\n-      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n-      bagDestroyBag(to_delete);\n-    }\n-}\n+{}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":6,"deletions":86,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -460,4 +460,3 @@\n-\/* A bagEnumerateFunction.  Create a synthetic class unload event\n- * for every class no longer present.  Analogous to event_callback\n- * combined with a handler in a unload specific (no event\n- * structure) kind of way.\n+\/* Create a synthetic class unload event for every class no longer present.\n+ * Analogous to event_callback combined with a handler in a unload specific\n+ * (no event structure) kind of way.\n@@ -466,1 +465,1 @@\n-synthesizeUnloadEvent(void *signatureVoid, void *envVoid)\n+synthesizeUnloadEvent(char *signature, JNIEnv *env)\n@@ -468,2 +467,0 @@\n-    JNIEnv *env = (JNIEnv *)envVoid;\n-    char *signature = *(char **)signatureVoid;\n@@ -623,13 +620,2 @@\n-    \/* See if a garbage collection finish event happened earlier.\n-     *\n-     * Note: The \"if\" is an optimization to avoid entering the lock on every\n-     *       event; garbageCollected may be zapped before we enter\n-     *       the lock but then this just becomes one big no-op.\n-     *\/\n-    if ( garbageCollected > 0 ) {\n-        struct bag *unloadedSignatures = NULL;\n-\n-        \/* We want to compact the hash table of all\n-         * objects sent to the front end by removing objects that have\n-         * been collected.\n-         *\/\n+    \/* See if a garbage collection finish event happened earlier. *\/\n+    if ( garbageCollected > 0) {\n@@ -637,6 +623,0 @@\n-\n-        \/* We also need to simulate the class unload events. *\/\n-\n-        debugMonitorEnter(handlerLock);\n-\n-        \/* Clear garbage collection counter *\/\n@@ -644,0 +624,1 @@\n+    }\n@@ -645,11 +626,2 @@\n-        \/* Analyze which class unloads occurred *\/\n-        unloadedSignatures = classTrack_processUnloads(env);\n-\n-        debugMonitorExit(handlerLock);\n-\n-        \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n-        if ( unloadedSignatures != NULL ) {\n-            (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n-                             (void *)env);\n-            bagDestroyBag(unloadedSignatures);\n-        }\n+    if (evinfo->ei == EI_CLASS_UNLOAD) {\n+        synthesizeUnloadEvent((char*)jlong_to_ptr(evinfo->tag), env);\n@@ -990,0 +962,21 @@\n+\/*\n+ * Invoke the callback when classes are freed.\n+ *\/\n+void JNICALL\n+cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n+{\n+    EventInfo info;\n+\n+    LOG_CB((\"cbTrackingObjectFree\"));\n+\n+    BEGIN_CALLBACK() {\n+    (void)memset(&info,0,sizeof(info));\n+    info.ei         = EI_CLASS_UNLOAD;\n+    info.tag        = tag;\n+    event_callback(getEnv(), &info);\n+    } END_CALLBACK();\n+\n+    LOG_MISC((\"END cbTrackingObjectFree\"));\n+\n+}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -165,15 +165,16 @@\n-        EI_FIELD_ACCESS         = 10,\n-        EI_FIELD_MODIFICATION   = 11,\n-        EI_EXCEPTION_CATCH      = 12,\n-        EI_METHOD_ENTRY         = 13,\n-        EI_METHOD_EXIT          = 14,\n-        EI_MONITOR_CONTENDED_ENTER = 15,\n-        EI_MONITOR_CONTENDED_ENTERED = 16,\n-        EI_MONITOR_WAIT         = 17,\n-        EI_MONITOR_WAITED       = 18,\n-        EI_VM_INIT              = 19,\n-        EI_VM_DEATH             = 20,\n-        EI_VIRTUAL_THREAD_START = 21,\n-        EI_VIRTUAL_THREAD_END   = 22,\n-\n-        EI_max                  = 22\n+        EI_CLASS_UNLOAD         = 10,\n+        EI_FIELD_ACCESS         = 11,\n+        EI_FIELD_MODIFICATION   = 12,\n+        EI_EXCEPTION_CATCH      = 13,\n+        EI_METHOD_ENTRY         = 14,\n+        EI_METHOD_EXIT          = 15,\n+        EI_MONITOR_CONTENDED_ENTER = 16,\n+        EI_MONITOR_CONTENDED_ENTERED = 17,\n+        EI_MONITOR_WAIT         = 18,\n+        EI_MONITOR_WAITED       = 19,\n+        EI_VM_INIT              = 20,\n+        EI_VM_DEATH             = 21,\n+        EI_VIRTUAL_THREAD_START = 22,\n+        EI_VIRTUAL_THREAD_END   = 23,\n+\n+        EI_max                  = 23\n@@ -225,0 +226,1 @@\n+    jlong       tag;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256811\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestClassUnloadEvents run\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.connect.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+import java.io.*;\n+\n+public class TestClassUnloadEvents {\n+  static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n+  static final int NUM_CLASSES = 10;\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length == 0) {\n+        runDebuggee();\n+    } else {\n+        runDebugger();\n+    }\n+  }\n+\n+  private static class TestClassLoader extends ClassLoader implements Opcodes {\n+    private static byte[] generateSampleClass(String name) {\n+      ClassWriter cw = new ClassWriter(0);\n+\n+      cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n+      MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n+      mv.visitCode();\n+      mv.visitInsn(RETURN);\n+      mv.visitMaxs(0, 0);\n+      mv.visitEnd();\n+      cw.visitEnd();\n+      return cw.toByteArray();\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+      if (name.startsWith(CLASS_NAME_PREFIX)) {\n+        byte[] bytecode = generateSampleClass(name);\n+        return defineClass(name, bytecode, 0, bytecode.length);\n+      } else {\n+        return super.findClass(name);\n+      }\n+    }\n+  }\n+\n+  private static void runDebuggee() {\n+      System.out.println(\"Running debuggee\");\n+      ClassLoader loader = new TestClassLoader();\n+      for (int index = 0; index < NUM_CLASSES; index++) {\n+          try {\n+            Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create Sample class\");\n+          }\n+      }\n+      loader = null;\n+      System.gc();\n+  }\n+\n+  private static void runDebugger() {\n+    System.out.println(\"Running debugger\");\n+    HashSet<String> unloadedSampleClasses = new HashSet<>();\n+    VirtualMachine vm = null;\n+    try {\n+        vm = connectAndLaunchVM();\n+        ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n+        classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n+        classUnloadRequest.enable();\n+\n+        EventSet eventSet = null;\n+        boolean exited = false;\n+        while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n+            for (Event event : eventSet) {\n+            System.out.println(\"Event: \" + event);\n+                if (event instanceof ClassUnloadEvent) {\n+                    String className = ((ClassUnloadEvent)event).className();\n+                    unloadedSampleClasses.add(className);\n+                }\n+\n+                if (event instanceof VMDeathEvent) {\n+                    exited = true;\n+                    break;\n+                }\n+            }\n+            vm.resume();\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    } finally {\n+        try {\n+            InputStreamReader reader = new InputStreamReader(vm.process().getInputStream());\n+            OutputStreamWriter writer = new OutputStreamWriter(System.out);\n+            char[] buf = new char[512];\n+\n+            while (reader.read(buf) > 0) {\n+                writer.write(buf);\n+            }\n+            writer.flush();\n+        } catch (Exception e) {\n+        }\n+    }\n+    if (unloadedSampleClasses.size() != NUM_CLASSES) {\n+        throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n+    }\n+  }\n+\n+  private static VirtualMachine connectAndLaunchVM() throws Exception {\n+    LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n+    Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n+    arguments.get(\"main\").setValue(TestClassUnloadEvents.class.getName());\n+    arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\");\n+    return launchingConnector.launch(arguments);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdi\/TestClassUnloadEvents.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}