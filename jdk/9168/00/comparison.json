{"files":[{"patch":"@@ -534,3 +534,0 @@\n-\/* Garbage Collection Happened *\/\n-static unsigned int garbageCollected = 0;\n-\n@@ -623,8 +620,10 @@\n-    \/* See if a garbage collection finish event happened earlier.\n-     *\n-     * Note: The \"if\" is an optimization to avoid entering the lock on every\n-     *       event; garbageCollected may be zapped before we enter\n-     *       the lock but then this just becomes one big no-op.\n-     *\/\n-    if ( garbageCollected > 0 ) {\n-        struct bag *unloadedSignatures = NULL;\n+    \/* check and process class unloading events *\/\n+    struct bag *unloadedSignatures = NULL;\n+\n+    \/* We also need to simulate the class unload events. *\/\n+    debugMonitorEnter(handlerLock);\n+\n+    \/* Analyze which class unloads occurred *\/\n+    unloadedSignatures = classTrack_processUnloads(env);\n+\n+    debugMonitorExit(handlerLock);\n@@ -632,0 +631,2 @@\n+    \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n+    if ( unloadedSignatures != NULL ) {\n@@ -638,18 +639,3 @@\n-        \/* We also need to simulate the class unload events. *\/\n-\n-        debugMonitorEnter(handlerLock);\n-\n-        \/* Clear garbage collection counter *\/\n-        garbageCollected = 0;\n-\n-        \/* Analyze which class unloads occurred *\/\n-        unloadedSignatures = classTrack_processUnloads(env);\n-\n-        debugMonitorExit(handlerLock);\n-\n-        \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n-        if ( unloadedSignatures != NULL ) {\n-            (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n-                             (void *)env);\n-            bagDestroyBag(unloadedSignatures);\n-        }\n+        (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n+                         (void *)env);\n+        bagDestroyBag(unloadedSignatures);\n@@ -966,1 +952,0 @@\n-    ++garbageCollected;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256811\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestClassUnloadEvents run\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.connect.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+import java.io.*;\n+\n+public class TestClassUnloadEvents {\n+  static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n+  static final int NUM_CLASSES = 10;\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length == 0) {\n+        runDebuggee();\n+    } else {\n+        runDebugger();\n+    }\n+  }\n+\n+  private static class TestClassLoader extends ClassLoader implements Opcodes {\n+    private static byte[] generateSampleClass(String name) {\n+      ClassWriter cw = new ClassWriter(0);\n+\n+      cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n+      MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n+      mv.visitCode();\n+      mv.visitInsn(RETURN);\n+      mv.visitMaxs(0, 0);\n+      mv.visitEnd();\n+      cw.visitEnd();\n+      return cw.toByteArray();\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+      if (name.startsWith(CLASS_NAME_PREFIX)) {\n+        byte[] bytecode = generateSampleClass(name);\n+        return defineClass(name, bytecode, 0, bytecode.length);\n+      } else {\n+        return super.findClass(name);\n+      }\n+    }\n+  }\n+\n+  private static void runDebuggee() {\n+      System.out.println(\"Running debuggee\");\n+      ClassLoader loader = new TestClassLoader();\n+      for (int index = 0; index < NUM_CLASSES; index++) {\n+          try {\n+            Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create Sample class\");\n+          }\n+      }\n+      loader = null;\n+      System.gc();\n+  }\n+\n+  private static void runDebugger() {\n+    System.out.println(\"Running debugger\");\n+    HashSet<String> unloadedSampleClasses = new HashSet<>();\n+    VirtualMachine vm = null;\n+    try {\n+        vm = connectAndLaunchVM();\n+        ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n+        classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n+        classUnloadRequest.enable();\n+\n+        EventSet eventSet = null;\n+        boolean exited = false;\n+        while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n+            for (Event event : eventSet) {\n+                if (event instanceof ClassUnloadEvent) {\n+                    String className = ((ClassUnloadEvent)event).className();\n+                    unloadedSampleClasses.add(className);\n+                }\n+\n+                if (event instanceof VMDeathEvent) {\n+                    exited = true;\n+                    break;\n+                }\n+            }\n+            vm.resume();\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    }\n+    if (unloadedSampleClasses.size() != NUM_CLASSES) {\n+        throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n+    }\n+  }\n+\n+  private static VirtualMachine connectAndLaunchVM() throws Exception {\n+    LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n+    Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n+    arguments.get(\"main\").setValue(TestClassUnloadEvents.class.getName());\n+    arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\");\n+    return launchingConnector.launch(arguments);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdi\/TestClassUnloadEvents.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}