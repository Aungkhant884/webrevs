{"files":[{"patch":"@@ -47,23 +47,15 @@\n-  static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n-  static final int NUM_CLASSES = 10;\n-\n-  public static void main(String[] args) throws Exception {\n-    if (args.length == 0) {\n-        runDebuggee();\n-    } else {\n-        runDebugger();\n-    }\n-  }\n-\n-  private static class TestClassLoader extends ClassLoader implements Opcodes {\n-    private static byte[] generateSampleClass(String name) {\n-      ClassWriter cw = new ClassWriter(0);\n-\n-      cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n-      MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n-      mv.visitCode();\n-      mv.visitInsn(RETURN);\n-      mv.visitMaxs(0, 0);\n-      mv.visitEnd();\n-      cw.visitEnd();\n-      return cw.toByteArray();\n+    static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n+    static final int NUM_CLASSES = 10;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            runDebuggee();\n+        } else {\n+            for (int index = 0; index < 5; index ++) {\n+                if(runDebugger()) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"No class unloading detected, result is inconclusive\");\n@@ -72,8 +64,23 @@\n-    @Override\n-    protected Class<?> findClass(String name) throws ClassNotFoundException {\n-      if (name.startsWith(CLASS_NAME_PREFIX)) {\n-        byte[] bytecode = generateSampleClass(name);\n-        return defineClass(name, bytecode, 0, bytecode.length);\n-      } else {\n-        return super.findClass(name);\n-      }\n+    private static class TestClassLoader extends ClassLoader implements Opcodes {\n+        private static byte[] generateSampleClass(String name) {\n+            ClassWriter cw = new ClassWriter(0);\n+\n+            cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+            cw.visitEnd();\n+            return cw.toByteArray();\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.startsWith(CLASS_NAME_PREFIX)) {\n+                byte[] bytecode = generateSampleClass(name);\n+                return defineClass(name, bytecode, 0, bytecode.length);\n+            } else {\n+                return super.findClass(name);\n+            }\n+        }\n@@ -81,35 +88,0 @@\n-  }\n-\n-  private static void runDebuggee() {\n-      System.out.println(\"Running debuggee\");\n-      ClassLoader loader = new TestClassLoader();\n-      for (int index = 0; index < NUM_CLASSES; index++) {\n-          try {\n-            Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n-          } catch (Exception e) {\n-            throw new RuntimeException(\"Failed to create Sample class\");\n-          }\n-      }\n-      loader = null;\n-      System.gc();\n-  }\n-\n-  private static void runDebugger() {\n-    System.out.println(\"Running debugger\");\n-    HashSet<String> unloadedSampleClasses = new HashSet<>();\n-    VirtualMachine vm = null;\n-    try {\n-        vm = connectAndLaunchVM();\n-        ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n-        classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n-        classUnloadRequest.enable();\n-\n-        EventSet eventSet = null;\n-        boolean exited = false;\n-        while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n-            for (Event event : eventSet) {\n-            System.out.println(\"Event: \" + event);\n-                if (event instanceof ClassUnloadEvent) {\n-                    String className = ((ClassUnloadEvent)event).className();\n-                    unloadedSampleClasses.add(className);\n-                }\n@@ -117,4 +89,8 @@\n-                if (event instanceof VMDeathEvent) {\n-                    exited = true;\n-                    break;\n-                }\n+    private static void runDebuggee() {\n+        System.out.println(\"Running debuggee\");\n+        ClassLoader loader = new TestClassLoader();\n+        for (int index = 0; index < NUM_CLASSES; index++) {\n+            try {\n+                Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Failed to create Sample class\");\n@@ -122,1 +98,0 @@\n-            vm.resume();\n@@ -124,3 +99,22 @@\n-    } catch (Exception e) {\n-        e.printStackTrace();\n-    } finally {\n+        loader = null;\n+        System.gc();\n+    }\n+\n+    \/\/ Check debuggee's output, see if class unloading actually\n+    \/\/ happened\n+    private static boolean classUnloadingOccurred(Process p) throws IOException {\n+        final String infoClassUnloaded = \"unloading class SampleClass__\";\n+        InputStreamReader reader = new InputStreamReader(p.getInputStream());\n+        StringBuffer sb = new StringBuffer();\n+        char[] buf = new char[1024];\n+        int n;\n+        while ((n = reader.read(buf)) > 0) {\n+            sb.append(buf, 0, n);\n+        }\n+        return sb.toString().indexOf(infoClassUnloaded) != -1;\n+    }\n+\n+    private static boolean runDebugger() {\n+        System.out.println(\"Running debugger\");\n+        HashSet<String> unloadedSampleClasses = new HashSet<>();\n+        VirtualMachine vm = null;\n@@ -128,7 +122,20 @@\n-            Process p = vm.process();\n-            InputStreamReader reader = new InputStreamReader(p.getInputStream());\n-            OutputStreamWriter writer = new OutputStreamWriter(System.out);\n-            char[] buf = new char[512];\n-            int n;\n-            while ((n = reader.read(buf)) > 0) {\n-                writer.write(buf, 0, n);\n+            vm = connectAndLaunchVM();\n+            ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n+            classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n+            classUnloadRequest.enable();\n+\n+            EventSet eventSet = null;\n+            boolean exited = false;\n+            while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n+                for (Event event : eventSet) {\n+                    if (event instanceof ClassUnloadEvent) {\n+                        String className = ((ClassUnloadEvent)event).className();\n+                        unloadedSampleClasses.add(className);\n+                    }\n+\n+                    if (event instanceof VMDeathEvent) {\n+                        exited = true;\n+                        break;\n+                    }\n+                }\n+                vm.resume();\n@@ -136,1 +143,0 @@\n-            writer.flush();\n@@ -138,0 +144,14 @@\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                Process p = vm.process();\n+                \/\/ If debuggee did not unload the classes, we can not expect ClassUnloadEvent\n+                if (!classUnloadingOccurred(p)) {\n+                    return false;\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Test failed: \" + e.getMessage());\n+            }\n+        }\n+        if (unloadedSampleClasses.size() != NUM_CLASSES) {\n+            throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n@@ -139,0 +159,1 @@\n+        return true;\n@@ -140,2 +161,7 @@\n-    if (unloadedSampleClasses.size() != NUM_CLASSES) {\n-        throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n+\n+    private static VirtualMachine connectAndLaunchVM() throws Exception {\n+        LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n+        Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n+        arguments.get(\"main\").setValue(TestClassUnloadEvents.class.getName());\n+        arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED -Xlog:class+unload\");\n+        return launchingConnector.launch(arguments);\n@@ -143,9 +169,0 @@\n-  }\n-\n-  private static VirtualMachine connectAndLaunchVM() throws Exception {\n-    LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n-    Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n-    arguments.get(\"main\").setValue(TestClassUnloadEvents.class.getName());\n-    arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED -XX:+UseShenandoahGC -Xlog:class+unload -Xlog:gc*=debug\");\n-    return launchingConnector.launch(arguments);\n-  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdi\/TestClassUnloadEvents.java","additions":110,"deletions":93,"binary":false,"changes":203,"status":"modified"}]}