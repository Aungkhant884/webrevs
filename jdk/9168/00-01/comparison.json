{"files":[{"patch":"@@ -1693,2 +1693,11 @@\n-void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {\n-  Thread *thread = Thread::current();\n+void JvmtiExport::post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  assert(objects != NULL, \"Nothing to post\");\n+  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n+\n+  Thread* thread = Thread::current();\n+  if (thread->is_VM_thread()) {\n+    post_object_free_on_vm_thread(env, objects);\n+  } else {\n+    post_object_free_on_java_thread(env, objects);\n+  }\n+}\n@@ -1696,1 +1705,16 @@\n-  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMS_transition()) {\n+void JvmtiExport::post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  EVT_TRIG_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Trg Object Free triggered\" ));\n+  EVT_TRACE(JVMTI_EVENT_OBJECT_FREE, (\"[?] Evt Object Free sent\"));\n+\n+  jvmtiEventObjectFree callback = env->callbacks()->ObjectFree;\n+  if (callback != NULL) {\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n+  }\n+}\n+\n+void JvmtiExport::post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  JavaThread *javaThread = JavaThread::current();\n+\n+  if (javaThread->is_in_VTMS_transition()) {\n@@ -1699,1 +1723,0 @@\n-  assert(env->is_enabled(JVMTI_EVENT_OBJECT_FREE), \"checking\");\n@@ -1704,0 +1727,2 @@\n+  JvmtiThreadEventMark jem(javaThread);\n+  JvmtiJavaThreadEventTransition jet(javaThread);\n@@ -1706,1 +1731,3 @@\n-    (*callback)(env->jvmti_external(), tag);\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-  static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;\n+  static void post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n@@ -439,0 +439,3 @@\n+private:\n+  static void post_object_free_on_vm_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n+  static void post_object_free_on_java_thread(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-    remove_dead_entries_locked(true \/* post_object_free *\/);\n+    post_dead_objects(true \/* locked *\/);\n@@ -1170,1 +1170,1 @@\n-void JvmtiTagMap::remove_dead_entries_locked(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries_locked(GrowableArray<jlong>* objects) {\n@@ -1174,1 +1174,3 @@\n-    post_object_free = post_object_free && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n+    if (!env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+      objects = NULL;\n+    }\n@@ -1176,2 +1178,2 @@\n-                           (post_object_free ? \" and posting\" : \"\"));\n-    hashmap()->remove_dead_entries(env(), post_object_free);\n+                           ((objects != NULL) ? \" and posting\" : \"\"));\n+    hashmap()->remove_dead_entries(objects);\n@@ -1182,1 +1184,1 @@\n-void JvmtiTagMap::remove_dead_entries(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -1184,1 +1186,1 @@\n-  remove_dead_entries_locked(post_object_free);\n+  remove_dead_entries_locked(objects);\n@@ -1187,7 +1189,8 @@\n-class VM_JvmtiPostObjectFree: public VM_Operation {\n-  JvmtiTagMap* _tag_map;\n- public:\n-  VM_JvmtiPostObjectFree(JvmtiTagMap* tag_map) : _tag_map(tag_map) {}\n-  VMOp_Type type() const { return VMOp_Cleanup; }\n-  void doit() {\n-    _tag_map->remove_dead_entries(true \/* post_object_free *\/);\n+void JvmtiTagMap::post_dead_objects(bool locked) {\n+  ResourceMark rm;\n+  GrowableArray<jlong> objects;\n+  if (locked) {\n+    assert(lock()->owned_by_self(), \"Already locked\");\n+    remove_dead_entries_locked(&objects);\n+  } else {\n+    remove_dead_entries(&objects);\n@@ -1195,9 +1198,2 @@\n-\n-  \/\/ Doesn't need a safepoint, just the VM thread\n-  virtual bool evaluate_at_safepoint() const { return false; }\n-};\n-\n-\/\/ PostObjectFree can't be called by JavaThread, so call it from the VM thread.\n-void JvmtiTagMap::post_dead_objects_on_vm_thread() {\n-  VM_JvmtiPostObjectFree op(this);\n-  VMThread::execute(&op);\n+  JvmtiExport::post_object_free(env(), &objects);\n+  log_info(jvmti)(\"%d free object posted\", objects.length());\n@@ -1218,1 +1214,1 @@\n-    post_dead_objects_on_vm_thread();\n+    post_dead_objects(false \/* locked *\/);\n@@ -1220,1 +1216,1 @@\n-    remove_dead_entries(false);\n+    remove_dead_entries(NULL);\n@@ -1333,1 +1329,1 @@\n-    post_dead_objects_on_vm_thread();\n+    post_dead_objects(false \/* locked *\/);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  void post_dead_objects_on_vm_thread();\n+  void post_dead_objects(bool locked);\n@@ -113,2 +113,2 @@\n-  void remove_dead_entries(bool post_object_free);\n-  void remove_dead_entries_locked(bool post_object_free);\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n+  void remove_dead_entries_locked(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,2 +189,3 @@\n-\/\/ Serially remove entries for dead oops from the table, and notify jvmti.\n-void JvmtiTagMapTable::remove_dead_entries(JvmtiEnv* env, bool post_object_free) {\n+\/\/ Serially remove entries for dead oops from the table and store dead oops'\n+\/\/ tag in objects array if provided.\n+void JvmtiTagMapTable::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -209,3 +210,3 @@\n-        \/\/ post the event to the profiler\n-        if (post_object_free) {\n-          JvmtiExport::post_object_free(env, tag);\n+        \/\/ collect object tag for posting JVMTI event later\n+        if (objects != NULL) {\n+          objects->append(tag);\n@@ -213,1 +214,0 @@\n-\n@@ -220,2 +220,2 @@\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d; %s\",\n-                          oops_counted, oops_removed, post_object_free ? \"free object posted\" : \"no posting\");\n+  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n+                          oops_counted, oops_removed);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,2 @@\n-  \/\/ Cleanup cleared entries and post\n-  void remove_dead_entries(JvmtiEnv* env, bool post_object_free);\n+  \/\/ Cleanup cleared entries and store dead objects in objects array\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,55 +48,2 @@\n-\/*\n- * A bag containing all the deleted classes' signatures. Must be accessed under\n- * classTrackLock.\n- *\/\n-struct bag* deletedSignatures;\n-\n-\/*\n- * Lock to keep integrity of deletedSignatures.\n- *\/\n-static jrawMonitorID classTrackLock;\n-\n-\/*\n- * Invoke the callback when classes are freed, find and record the signature\n- * in deletedSignatures. Those are only used in addPreparedClass() by the\n- * same thread.\n- *\/\n-static void JNICALL\n-cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n-{\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-      debugMonitorExit(classTrackLock);\n-      return;\n-    }\n-    *(char**)bagAdd(deletedSignatures) = (char*)jlong_to_ptr(tag);\n-\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-\/*\n- * Called after class unloads have occurred.\n- * The signatures of classes which were unloaded are returned.\n- *\/\n-struct bag *\n-classTrack_processUnloads(JNIEnv *env)\n-{\n-    if (deletedSignatures == NULL) {\n-      return NULL;\n-    }\n-\n-    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n-     *\n-     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n-     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n-     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n-     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n-     * which can lead to deadlock.\n-     *\/\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-    return deleted;\n-}\n+extern void JNICALL\n+cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag);\n@@ -172,2 +119,0 @@\n-    deletedSignatures = NULL;\n-    classTrackLock = debugMonitorCreate(\"Deleted class tag lock\");\n@@ -211,16 +156,1 @@\n-{\n-    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n-    debugMonitorEnter(classTrackLock);\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-static jboolean\n-cleanDeleted(void *signatureVoid, void *arg)\n-{\n-    char* sig = *(char**)signatureVoid;\n-    jvmtiDeallocate(sig);\n-    return JNI_TRUE;\n-}\n+{ }\n@@ -229,0 +159,1 @@\n+ *\n@@ -233,13 +164,2 @@\n-{\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* to_delete = deletedSignatures;\n-    deletedSignatures = NULL;\n-    debugMonitorExit(classTrackLock);\n-\n-    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    if (to_delete != NULL) {\n-      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n-      bagDestroyBag(to_delete);\n-    }\n-}\n+{}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":6,"deletions":86,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -460,4 +460,3 @@\n-\/* A bagEnumerateFunction.  Create a synthetic class unload event\n- * for every class no longer present.  Analogous to event_callback\n- * combined with a handler in a unload specific (no event\n- * structure) kind of way.\n+\/* Create a synthetic class unload event for every class no longer present.\n+ * Analogous to event_callback combined with a handler in a unload specific\n+ * (no event structure) kind of way.\n@@ -466,1 +465,1 @@\n-synthesizeUnloadEvent(void *signatureVoid, void *envVoid)\n+synthesizeUnloadEvent(char *signature, JNIEnv *env)\n@@ -468,2 +467,0 @@\n-    JNIEnv *env = (JNIEnv *)envVoid;\n-    char *signature = *(char **)signatureVoid;\n@@ -534,0 +531,3 @@\n+\/* Garbage Collection Happened *\/\n+static unsigned int garbageCollected = 0;\n+\n@@ -620,17 +620,2 @@\n-    \/* check and process class unloading events *\/\n-    struct bag *unloadedSignatures = NULL;\n-\n-    \/* We also need to simulate the class unload events. *\/\n-    debugMonitorEnter(handlerLock);\n-\n-    \/* Analyze which class unloads occurred *\/\n-    unloadedSignatures = classTrack_processUnloads(env);\n-\n-    debugMonitorExit(handlerLock);\n-\n-    \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n-    if ( unloadedSignatures != NULL ) {\n-        \/* We want to compact the hash table of all\n-         * objects sent to the front end by removing objects that have\n-         * been collected.\n-         *\/\n+    \/* See if a garbage collection finish event happened earlier. *\/\n+    if ( garbageCollected > 0) {\n@@ -638,0 +623,2 @@\n+        garbageCollected = 0;\n+    }\n@@ -639,3 +626,2 @@\n-        (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n-                         (void *)env);\n-        bagDestroyBag(unloadedSignatures);\n+    if (evinfo->ei == EI_CLASS_UNLOAD) {\n+        synthesizeUnloadEvent((char*)jlong_to_ptr(evinfo->tag), env);\n@@ -952,0 +938,1 @@\n+    ++garbageCollected;\n@@ -975,0 +962,23 @@\n+\/*\n+ * Invoke the callback when classes are freed, find and record the signature\n+ * in deletedSignatures. Those are only used in addPreparedClass() by the\n+ * same thread.\n+ *\/\n+void JNICALL\n+cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)\n+{\n+    EventInfo info;\n+\n+    LOG_CB((\"cbTrackingObjectFree\"));\n+\n+    BEGIN_CALLBACK() {\n+    (void)memset(&info,0,sizeof(info));\n+    info.ei         = EI_CLASS_UNLOAD;\n+    info.tag        = tag;\n+    event_callback(getEnv(), &info);\n+    } END_CALLBACK();\n+\n+    LOG_MISC((\"END cbTrackingObjectFree\"));\n+\n+}\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1963,0 +1963,1 @@\n+    index2jdwp[EI_CLASS_UNLOAD        -EI_min] = JDWP_EVENT(CLASS_UNLOAD);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,15 +165,16 @@\n-        EI_FIELD_ACCESS         = 10,\n-        EI_FIELD_MODIFICATION   = 11,\n-        EI_EXCEPTION_CATCH      = 12,\n-        EI_METHOD_ENTRY         = 13,\n-        EI_METHOD_EXIT          = 14,\n-        EI_MONITOR_CONTENDED_ENTER = 15,\n-        EI_MONITOR_CONTENDED_ENTERED = 16,\n-        EI_MONITOR_WAIT         = 17,\n-        EI_MONITOR_WAITED       = 18,\n-        EI_VM_INIT              = 19,\n-        EI_VM_DEATH             = 20,\n-        EI_VIRTUAL_THREAD_START = 21,\n-        EI_VIRTUAL_THREAD_END   = 22,\n-\n-        EI_max                  = 22\n+        EI_CLASS_UNLOAD         = 10,\n+        EI_FIELD_ACCESS         = 11,\n+        EI_FIELD_MODIFICATION   = 12,\n+        EI_EXCEPTION_CATCH      = 13,\n+        EI_METHOD_ENTRY         = 14,\n+        EI_METHOD_EXIT          = 15,\n+        EI_MONITOR_CONTENDED_ENTER = 16,\n+        EI_MONITOR_CONTENDED_ENTERED = 17,\n+        EI_MONITOR_WAIT         = 18,\n+        EI_MONITOR_WAITED       = 19,\n+        EI_VM_INIT              = 20,\n+        EI_VM_DEATH             = 21,\n+        EI_VIRTUAL_THREAD_START = 22,\n+        EI_VIRTUAL_THREAD_END   = 23,\n+\n+        EI_max                  = 23\n@@ -225,0 +226,1 @@\n+    jlong       tag;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+            System.out.println(\"Event: \" + event);\n@@ -125,0 +126,12 @@\n+    } finally {\n+        try {\n+            InputStreamReader reader = new InputStreamReader(vm.process().getInputStream());\n+            OutputStreamWriter writer = new OutputStreamWriter(System.out);\n+            char[] buf = new char[512];\n+\n+            while (reader.read(buf) > 0) {\n+                writer.write(buf);\n+            }\n+            writer.flush();\n+        } catch (Exception e) {\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdi\/TestClassUnloadEvents.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}