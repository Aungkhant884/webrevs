{"files":[{"patch":"@@ -1693,2 +1693,2 @@\n-void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {\n-  Thread *thread = Thread::current();\n+void JvmtiExport::post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  assert(objects != NULL, \"Nothing to post\");\n@@ -1696,1 +1696,2 @@\n-  if (thread->is_Java_thread() && JavaThread::cast(thread)->is_in_VTMS_transition()) {\n+  JavaThread *javaThread = JavaThread::current();\n+  if (javaThread->is_in_VTMS_transition()) {\n@@ -1704,0 +1705,2 @@\n+  JvmtiThreadEventMark jem(javaThread);\n+  JvmtiJavaThreadEventTransition jet(javaThread);\n@@ -1706,1 +1709,3 @@\n-    (*callback)(env->jvmti_external(), tag);\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-  static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;\n+  static void post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,4 +139,2 @@\n-\/\/ this tagmap table.  The calls from a JavaThread only rehash, posting is\n-\/\/ only done before heap walks.\n-void JvmtiTagMap::check_hashmap(bool post_events) {\n-  assert(!post_events || SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+\/\/ this tagmap table.\n+void JvmtiTagMap::check_hashmap(GrowableArray<jlong>* objects) {\n@@ -148,1 +146,1 @@\n-      post_events &&\n+      objects != NULL &&\n@@ -150,1 +148,1 @@\n-    remove_dead_entries_locked(true \/* post_object_free *\/);\n+    remove_dead_entries_locked(objects);\n@@ -160,1 +158,1 @@\n-void JvmtiTagMap::check_hashmaps_for_heapwalk() {\n+void JvmtiTagMap::check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects) {\n@@ -171,1 +169,1 @@\n-      tag_map->check_hashmap(\/*post_events*\/ true);\n+      tag_map->check_hashmap(objects);\n@@ -362,1 +360,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL);  \/* don't collect dead objects *\/\n@@ -397,1 +395,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL); \/* don't collect dead objects *\/\n@@ -892,0 +890,1 @@\n+  GrowableArray<jlong>* const _dead_objects;\n@@ -893,1 +892,2 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }\n+  VM_HeapIterateOperation(ObjectClosure* blk, GrowableArray<jlong>* objects) :\n+    _blk(blk), _dead_objects(objects) { }\n@@ -900,1 +900,1 @@\n-    JvmtiTagMap::check_hashmaps_for_heapwalk();\n+    JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -914,1 +914,0 @@\n-\n@@ -1145,1 +1144,3 @@\n-  VM_HeapIterateOperation op(&blk);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  VM_HeapIterateOperation op(&blk, &dead_objects);\n@@ -1147,0 +1148,1 @@\n+  post_dead_objects(&dead_objects);\n@@ -1160,8 +1162,15 @@\n-  MutexLocker ml(Heap_lock);\n-  IterateThroughHeapObjectClosure blk(this,\n-                                      klass,\n-                                      heap_filter,\n-                                      callbacks,\n-                                      user_data);\n-  VM_HeapIterateOperation op(&blk);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    IterateThroughHeapObjectClosure blk(this,\n+                                        klass,\n+                                        heap_filter,\n+                                        callbacks,\n+                                        user_data);\n+    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -1170,1 +1179,1 @@\n-void JvmtiTagMap::remove_dead_entries_locked(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries_locked(GrowableArray<jlong>* objects) {\n@@ -1174,1 +1183,3 @@\n-    post_object_free = post_object_free && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n+    if (!env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+      objects = NULL;\n+    }\n@@ -1176,2 +1187,2 @@\n-                           (post_object_free ? \" and posting\" : \"\"));\n-    hashmap()->remove_dead_entries(env(), post_object_free);\n+                           ((objects != NULL) ? \" and posting\" : \"\"));\n+    hashmap()->remove_dead_entries(objects);\n@@ -1182,1 +1193,1 @@\n-void JvmtiTagMap::remove_dead_entries(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -1184,1 +1195,1 @@\n-  remove_dead_entries_locked(post_object_free);\n+  remove_dead_entries_locked(objects);\n@@ -1187,7 +1198,5 @@\n-class VM_JvmtiPostObjectFree: public VM_Operation {\n-  JvmtiTagMap* _tag_map;\n- public:\n-  VM_JvmtiPostObjectFree(JvmtiTagMap* tag_map) : _tag_map(tag_map) {}\n-  VMOp_Type type() const { return VMOp_Cleanup; }\n-  void doit() {\n-    _tag_map->remove_dead_entries(true \/* post_object_free *\/);\n+void JvmtiTagMap::post_dead_objects(GrowableArray<jlong>* const objects) {\n+  assert(Thread::current()->is_Java_thread(), \"Must post from JavaThread\");\n+  if (objects != NULL && objects->length() > 0) {\n+    JvmtiExport::post_object_free(env(), objects);\n+    log_info(jvmti)(\"%d free object posted\", objects->length());\n@@ -1195,0 +1204,1 @@\n+}\n@@ -1196,8 +1206,5 @@\n-  \/\/ Doesn't need a safepoint, just the VM thread\n-  virtual bool evaluate_at_safepoint() const { return false; }\n-};\n-\n-\/\/ PostObjectFree can't be called by JavaThread, so call it from the VM thread.\n-void JvmtiTagMap::post_dead_objects_on_vm_thread() {\n-  VM_JvmtiPostObjectFree op(this);\n-  VMThread::execute(&op);\n+void JvmtiTagMap::remove_and_post_dead_objects() {\n+  ResourceMark rm;\n+  GrowableArray<jlong> objects;\n+  remove_dead_entries(&objects);\n+  post_dead_objects(&objects);\n@@ -1218,1 +1225,1 @@\n-    post_dead_objects_on_vm_thread();\n+    remove_and_post_dead_objects();\n@@ -1220,1 +1227,1 @@\n-    remove_dead_entries(false);\n+    remove_dead_entries(NULL);\n@@ -1333,1 +1340,1 @@\n-    post_dead_objects_on_vm_thread();\n+    remove_and_post_dead_objects();\n@@ -2255,0 +2262,3 @@\n+  \/\/ Dead object tags in JvmtiTagMap\n+  GrowableArray<jlong>* _dead_objects;\n+\n@@ -2296,1 +2306,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2301,1 +2312,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2313,1 +2325,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2322,0 +2335,1 @@\n+  _dead_objects = objects;\n@@ -2329,1 +2343,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2338,0 +2353,1 @@\n+  _dead_objects = objects;\n@@ -2806,1 +2822,1 @@\n-  JvmtiTagMap::check_hashmaps_for_heapwalk();\n+  JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -2845,4 +2861,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n-  VM_HeapWalkOperation op(this, Handle(), context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n+    VM_HeapWalkOperation op(this, Handle(), context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -2858,4 +2880,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -2879,4 +2907,11 @@\n-  MutexLocker ml(Heap_lock);\n-  AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtInternal);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":98,"deletions":63,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-  void check_hashmap(bool post_events);\n+  void check_hashmap(GrowableArray<jlong>* objects);\n@@ -57,1 +57,0 @@\n-  void post_dead_objects_on_vm_thread();\n@@ -112,0 +111,4 @@\n+  void remove_and_post_dead_objects();\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n+  void remove_dead_entries_locked(GrowableArray<jlong>* objects);\n+  void post_dead_objects(GrowableArray<jlong>* const objects);\n@@ -113,4 +116,1 @@\n-  void remove_dead_entries(bool post_object_free);\n-  void remove_dead_entries_locked(bool post_object_free);\n-\n-  static void check_hashmaps_for_heapwalk();\n+  static void check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,2 +189,3 @@\n-\/\/ Serially remove entries for dead oops from the table, and notify jvmti.\n-void JvmtiTagMapTable::remove_dead_entries(JvmtiEnv* env, bool post_object_free) {\n+\/\/ Serially remove entries for dead oops from the table and store dead oops'\n+\/\/ tag in objects array if provided.\n+void JvmtiTagMapTable::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -209,3 +210,3 @@\n-        \/\/ post the event to the profiler\n-        if (post_object_free) {\n-          JvmtiExport::post_object_free(env, tag);\n+        \/\/ collect object tags for posting JVMTI events later\n+        if (objects != NULL) {\n+          objects->append(tag);\n@@ -213,1 +214,0 @@\n-\n@@ -220,2 +220,2 @@\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d; %s\",\n-                          oops_counted, oops_removed, post_object_free ? \"free object posted\" : \"no posting\");\n+  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n+                          oops_counted, oops_removed);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,2 @@\n-  \/\/ Cleanup cleared entries and post\n-  void remove_dead_entries(JvmtiEnv* env, bool post_object_free);\n+  \/\/ Cleanup cleared entries and store dead object tags in objects array\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"eventHandler.h\"\n@@ -49,2 +50,1 @@\n- * A bag containing all the deleted classes' signatures. Must be accessed under\n- * classTrackLock.\n+ * Invoke the callback when classes are freed.\n@@ -52,13 +52,1 @@\n-struct bag* deletedSignatures;\n-\n-\/*\n- * Lock to keep integrity of deletedSignatures.\n- *\/\n-static jrawMonitorID classTrackLock;\n-\n-\/*\n- * Invoke the callback when classes are freed, find and record the signature\n- * in deletedSignatures. Those are only used in addPreparedClass() by the\n- * same thread.\n- *\/\n-static void JNICALL\n+void JNICALL\n@@ -67,35 +55,1 @@\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-      debugMonitorExit(classTrackLock);\n-      return;\n-    }\n-    *(char**)bagAdd(deletedSignatures) = (char*)jlong_to_ptr(tag);\n-\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-\/*\n- * Called after class unloads have occurred.\n- * The signatures of classes which were unloaded are returned.\n- *\/\n-struct bag *\n-classTrack_processUnloads(JNIEnv *env)\n-{\n-    if (deletedSignatures == NULL) {\n-      return NULL;\n-    }\n-\n-    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n-     *\n-     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n-     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n-     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n-     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n-     * which can lead to deadlock.\n-     *\/\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-    return deleted;\n+    eventHandler_synthesizeUnloadEvent((char*)jlong_to_ptr(tag), getEnv());\n@@ -104,3 +58,0 @@\n-\/*\n- * Add a class to the prepared class table.\n- *\/\n@@ -172,2 +123,0 @@\n-    deletedSignatures = NULL;\n-    classTrackLock = debugMonitorCreate(\"Deleted class tag lock\");\n@@ -205,41 +154,0 @@\n-\n-\/*\n- * Called to activate class-tracking when a listener registers for EI_GC_FINISH.\n- *\/\n-void\n-classTrack_activate(JNIEnv *env)\n-{\n-    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n-    debugMonitorEnter(classTrackLock);\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-static jboolean\n-cleanDeleted(void *signatureVoid, void *arg)\n-{\n-    char* sig = *(char**)signatureVoid;\n-    jvmtiDeallocate(sig);\n-    return JNI_TRUE;\n-}\n-\n-\/*\n- * Called when agent detaches.\n- *\/\n-void\n-classTrack_reset(void)\n-{\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* to_delete = deletedSignatures;\n-    deletedSignatures = NULL;\n-    debugMonitorExit(classTrackLock);\n-\n-    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    if (to_delete != NULL) {\n-      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n-      bagDestroyBag(to_delete);\n-    }\n-}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":4,"deletions":96,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -798,1 +798,0 @@\n-    classTrack_reset();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -460,7 +460,3 @@\n-\/* A bagEnumerateFunction.  Create a synthetic class unload event\n- * for every class no longer present.  Analogous to event_callback\n- * combined with a handler in a unload specific (no event\n- * structure) kind of way.\n- *\/\n-static jboolean\n-synthesizeUnloadEvent(void *signatureVoid, void *envVoid)\n+\/* Create a synthetic class unload event for the specified signature. *\/\n+jboolean\n+eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env)\n@@ -468,2 +464,0 @@\n-    JNIEnv *env = (JNIEnv *)envVoid;\n-    char *signature = *(char **)signatureVoid;\n@@ -623,13 +617,2 @@\n-    \/* See if a garbage collection finish event happened earlier.\n-     *\n-     * Note: The \"if\" is an optimization to avoid entering the lock on every\n-     *       event; garbageCollected may be zapped before we enter\n-     *       the lock but then this just becomes one big no-op.\n-     *\/\n-    if ( garbageCollected > 0 ) {\n-        struct bag *unloadedSignatures = NULL;\n-\n-        \/* We want to compact the hash table of all\n-         * objects sent to the front end by removing objects that have\n-         * been collected.\n-         *\/\n+    \/* See if a garbage collection finish event happened earlier. *\/\n+    if ( garbageCollected > 0) {\n@@ -637,6 +620,0 @@\n-\n-        \/* We also need to simulate the class unload events. *\/\n-\n-        debugMonitorEnter(handlerLock);\n-\n-        \/* Clear garbage collection counter *\/\n@@ -644,12 +621,0 @@\n-\n-        \/* Analyze which class unloads occurred *\/\n-        unloadedSignatures = classTrack_processUnloads(env);\n-\n-        debugMonitorExit(handlerLock);\n-\n-        \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n-        if ( unloadedSignatures != NULL ) {\n-            (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n-                             (void *)env);\n-            bagDestroyBag(unloadedSignatures);\n-        }\n@@ -1712,3 +1677,0 @@\n-    if (node->ei == EI_GC_FINISH) {\n-        classTrack_activate(getEnv());\n-    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":5,"deletions":43,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+jboolean eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256811\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestClassUnloadEvents run\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.connect.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+import java.io.*;\n+\n+public class TestClassUnloadEvents {\n+  static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n+  static final int NUM_CLASSES = 10;\n+\n+  public static void main(String[] args) throws Exception {\n+    if (args.length == 0) {\n+        runDebuggee();\n+    } else {\n+        runDebugger();\n+    }\n+  }\n+\n+  private static class TestClassLoader extends ClassLoader implements Opcodes {\n+    private static byte[] generateSampleClass(String name) {\n+      ClassWriter cw = new ClassWriter(0);\n+\n+      cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n+      MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n+      mv.visitCode();\n+      mv.visitInsn(RETURN);\n+      mv.visitMaxs(0, 0);\n+      mv.visitEnd();\n+      cw.visitEnd();\n+      return cw.toByteArray();\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+      if (name.startsWith(CLASS_NAME_PREFIX)) {\n+        byte[] bytecode = generateSampleClass(name);\n+        return defineClass(name, bytecode, 0, bytecode.length);\n+      } else {\n+        return super.findClass(name);\n+      }\n+    }\n+  }\n+\n+  private static void runDebuggee() {\n+      System.out.println(\"Running debuggee\");\n+      ClassLoader loader = new TestClassLoader();\n+      for (int index = 0; index < NUM_CLASSES; index++) {\n+          try {\n+            Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create Sample class\");\n+          }\n+      }\n+      loader = null;\n+      System.gc();\n+  }\n+\n+  private static void runDebugger() {\n+    System.out.println(\"Running debugger\");\n+    HashSet<String> unloadedSampleClasses = new HashSet<>();\n+    VirtualMachine vm = null;\n+    try {\n+        vm = connectAndLaunchVM();\n+        ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n+        classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n+        classUnloadRequest.enable();\n+\n+        EventSet eventSet = null;\n+        boolean exited = false;\n+        while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n+            for (Event event : eventSet) {\n+            System.out.println(\"Event: \" + event);\n+                if (event instanceof ClassUnloadEvent) {\n+                    String className = ((ClassUnloadEvent)event).className();\n+                    unloadedSampleClasses.add(className);\n+                }\n+\n+                if (event instanceof VMDeathEvent) {\n+                    exited = true;\n+                    break;\n+                }\n+            }\n+            vm.resume();\n+        }\n+    } catch (Exception e) {\n+        e.printStackTrace();\n+    } finally {\n+        try {\n+            InputStreamReader reader = new InputStreamReader(vm.process().getInputStream());\n+            OutputStreamWriter writer = new OutputStreamWriter(System.out);\n+            char[] buf = new char[512];\n+\n+            while (reader.read(buf) > 0) {\n+                writer.write(buf);\n+            }\n+            writer.flush();\n+        } catch (Exception e) {\n+        }\n+    }\n+    if (unloadedSampleClasses.size() != NUM_CLASSES) {\n+        throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n+    }\n+  }\n+\n+  private static VirtualMachine connectAndLaunchVM() throws Exception {\n+    LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n+    Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n+    arguments.get(\"main\").setValue(TestClassUnloadEvents.class.getName());\n+    arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\");\n+    return launchingConnector.launch(arguments);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdi\/TestClassUnloadEvents.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}