{"files":[{"patch":"@@ -4535,1 +4535,8 @@\n-          sw.transform_loop(lpt, true);\n+          if (!sw.transform_loop(lpt, true)) {\n+            \/\/ Instigate more unrolling for optimization when vectorization fails.\n+            if (cl->has_passed_slp()) {\n+              C->set_major_progress();\n+              cl->set_notpassed_slp();\n+              cl->mark_do_unroll_only();\n+            }\n+          }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n+bool SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {\n@@ -103,1 +103,1 @@\n-    return;\n+    return false;\n@@ -109,1 +109,1 @@\n-  if (!cl->is_valid_counted_loop(T_INT)) return; \/\/ skip malformed counted loop\n+  if (!cl->is_valid_counted_loop(T_INT)) return false; \/\/ skip malformed counted loop\n@@ -113,1 +113,1 @@\n-    if (cl->is_reduction_loop()) return; \/\/ no predication mapping\n+    if (cl->is_reduction_loop()) return false; \/\/ no predication mapping\n@@ -115,1 +115,1 @@\n-    if (limit->is_Con()) return; \/\/ non constant limits only\n+    if (limit->is_Con()) return false; \/\/ non constant limits only\n@@ -122,1 +122,1 @@\n-        if (val < 0) return;\n+        if (val < 0) return false;\n@@ -129,1 +129,1 @@\n-    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) return;\n+    if (SuperWordLoopUnrollAnalysis && cl->slp_max_unroll() == 0) return false;\n@@ -144,1 +144,1 @@\n-    return;\n+    return false;\n@@ -149,1 +149,1 @@\n-    return;\n+    return false;\n@@ -153,1 +153,1 @@\n-  if (cl->is_vectorized_loop()) return;\n+  if (cl->is_vectorized_loop()) return false;\n@@ -155,1 +155,1 @@\n-  if (cl->is_unroll_only()) return;\n+  if (cl->is_unroll_only()) return false;\n@@ -161,1 +161,1 @@\n-      return;\n+      return false;\n@@ -165,1 +165,1 @@\n-      return;\n+      return false;\n@@ -178,0 +178,1 @@\n+  bool success = true;\n@@ -180,1 +181,1 @@\n-    SLP_extract();\n+    success = SLP_extract();\n@@ -195,0 +196,1 @@\n+  return success;\n@@ -454,1 +456,1 @@\n-void SuperWord::SLP_extract() {\n+bool SuperWord::SLP_extract() {\n@@ -469,1 +471,1 @@\n-    return; \/\/ Exit if no interesting nodes or complex graph.\n+    return false; \/\/ Exit if no interesting nodes or complex graph.\n@@ -486,1 +488,1 @@\n-          return; \/\/ Exit if no interesting nodes or complex graph.\n+          return false; \/\/ Exit if no interesting nodes or complex graph.\n@@ -514,1 +516,1 @@\n-      return; \/\/ Did not find memory reference to align vectors\n+      return false; \/\/ Did not find memory reference to align vectors\n@@ -566,1 +568,1 @@\n-        return;\n+        return false;\n@@ -570,1 +572,1 @@\n-      return;\n+      return false;\n@@ -574,1 +576,1 @@\n-  output();\n+  return output();\n@@ -2388,1 +2390,1 @@\n-void SuperWord::output() {\n+bool SuperWord::output() {\n@@ -2392,7 +2394,1 @@\n-    if (cl->is_main_loop()) {\n-      \/\/ Instigate more unrolling for optimization when vectorization fails.\n-      C->set_major_progress();\n-      cl->set_notpassed_slp();\n-      cl->mark_do_unroll_only();\n-    }\n-    return;\n+    return false;\n@@ -2432,1 +2428,1 @@\n-    return;\n+    return false;\n@@ -2477,1 +2473,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2521,1 +2517,1 @@\n-              return; \/\/and reverse to backup IG\n+              return false; \/\/and reverse to backup IG\n@@ -2530,1 +2526,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2572,1 +2568,1 @@\n-          return;\n+          return false;\n@@ -2589,1 +2585,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2605,1 +2601,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2613,1 +2609,1 @@\n-            return; \/\/and reverse to backup IG\n+            return false; \/\/and reverse to backup IG\n@@ -2637,1 +2633,1 @@\n-          return; \/\/and reverse to backup IG\n+          return false; \/\/and reverse to backup IG\n@@ -2646,1 +2642,1 @@\n-          return; \/\/and reverse to backup IG\n+          return false; \/\/and reverse to backup IG\n@@ -2664,1 +2660,1 @@\n-          return;\n+          return false;\n@@ -2737,1 +2733,1 @@\n-  return;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":37,"deletions":41,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-  void transform_loop(IdealLoopTree* lpt, bool do_optimization);\n+  bool transform_loop(IdealLoopTree* lpt, bool do_optimization);\n@@ -425,1 +425,1 @@\n-  void SLP_extract();\n+  bool SLP_extract();\n@@ -512,1 +512,1 @@\n-  void output();\n+  bool output();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @bug 8283187\n+ * @summary C2: loop candidate for superword not always unrolled fully if superword fails\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.TestSuperwordFailsUnrolling\n+ *\/\n+\n+public class TestSuperwordFailsUnrolling {\n+    private static int v = 0;\n+    private final static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        Object avx = wb.getVMFlag(\"UseAVX\");\n+        if (avx != null && ((Long)avx) > 2) {\n+            TestFramework.runWithFlags(\"-XX:UseAVX=2\");\n+        }\n+        TestFramework.run();\n+\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"UsePopCountInstruction\", \"true\" }, counts = { IRNode.POPCOUNT_L, \"10\" })\n+    private static int test(long[] array1, long[] array2) {\n+        v = 0;\n+        for (int i = 0; i < array1.length; i++) {\n+            v += Long.bitCount(array1[i]);\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test\")\n+    void test_runner() {\n+        long[] array = new long[1000];\n+        test(array, array);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSuperwordFailsUnrolling.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -176,0 +176,1 @@\n+    public static final String POPCOUNT_L = START + \"PopCountL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}