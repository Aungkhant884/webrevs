{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Intel Corporation. All rights reserved.\n+ * Copyright (c) 2022, 2023, Intel Corporation. All rights reserved.\n@@ -40,4 +40,4 @@\n-\/\/    ( a×2^130 + b ) mod 2^130-5     \/\/i.e. number split along the 130-bit boundary\n-\/\/                                 = ( a×2^130 - 5×a + 5×a + b ) mod 2^130-5\n-\/\/                                 = ( a×(2^130 - 5) + 5×a + b ) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                                 = ( 5×a + b ) mod 2^130-5\n+\/\/    ( ax2^130 + b ) mod 2^130-5     \/\/i.e. number split along the 130-bit boundary\n+\/\/                                 = ( ax2^130 - 5xa + 5xa + b ) mod 2^130-5\n+\/\/                                 = ( ax(2^130 - 5) + 5xa + b ) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                                 = ( 5xa + b ) mod 2^130-5\n@@ -50,3 +50,3 @@\n-\/\/    × used for poly1305_multiply8_avx512\n-\/\/    lower-case variables are scalar numbers in 3×44-bit limbs (in gprs)\n-\/\/    upper-case variables are 8-element vector numbers in 3×44-bit limbs (in zmm registers)\n+\/\/    x used for poly1305_multiply8_avx512\n+\/\/    lower-case variables are scalar numbers in 3x44-bit limbs (in gprs)\n+\/\/    upper-case variables are 8-element vector numbers in 3x44-bit limbs (in zmm registers)\n@@ -87,1 +87,1 @@\n-\/\/ i.e. For each block, compute [a2 a1 a0] = [a2 a1 a0] × [r2 r1 r0]\n+\/\/ i.e. For each block, compute [a2 a1 a0] = [a2 a1 a0] x [r2 r1 r0]\n@@ -92,1 +92,1 @@\n-\/\/ ×    r2       r1       r0\n+\/\/ x    r2       r1       r0\n@@ -94,3 +94,3 @@\n-\/\/     a2×r0    a1×r0    a0×r0\n-\/\/ +   a1×r1    a0×r1  5×a2×r1'     (r1' = r1<<2)\n-\/\/ +   a0×r2  5×a2×r2' 5×a1×r2'     (r2' = r2<<2)\n+\/\/     a2xr0    a1xr0    a0xr0\n+\/\/ +   a1xr1    a0xr1  5xa2xr1'     (r1' = r1<<2)\n+\/\/ +   a0xr2  5xa2xr2' 5xa1xr2'     (r2' = r2<<2)\n@@ -104,5 +104,5 @@\n-\/\/    ( p2×2^88 ) mod 2^130-5\n-\/\/                             = ( p2'×2^88 + p2''×2^130) mod 2^130-5 \/\/ Split on 130-bit boudary\n-\/\/                             = ( p2'×2^88 + p2''×2^130 - 5×p2'' + 5×p2'') mod 2^130-5\n-\/\/                             = ( p2'×2^88 + p2''×(2^130 - 5) + 5×p2'') mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                             = ( p2'×2^88 + 5×p2'') mod 2^130-5\n+\/\/    ( p2x2^88 ) mod 2^130-5\n+\/\/                             = ( p2'x2^88 + p2''x2^130) mod 2^130-5 \/\/ Split on 130-bit boudary\n+\/\/                             = ( p2'x2^88 + p2''x2^130 - 5xp2'' + 5xp2'') mod 2^130-5\n+\/\/                             = ( p2'x2^88 + p2''x(2^130 - 5) + 5xp2'') mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                             = ( p2'x2^88 + 5xp2'') mod 2^130-5\n@@ -112,10 +112,10 @@\n-\/\/ For example, partial product (a2×r2):\n-\/\/    (a2×2^88)×(r2×2^88) mod 2^130-5\n-\/\/                                    = (a2×r2 × 2^176) mod 2^130-5\n-\/\/                                    = (a2×r2 × 2^46×2^130) mod 2^130-5\n-\/\/                                    = (a2×r2×2^46 × 2^130- 5×a2×r2×2^46 + 5×a2×r2×2^46) mod 2^130-5\n-\/\/                                    = (a2×r2×2^46 × (2^130- 5) + 5×a2×r2×2^46) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n-\/\/                                    = (5×a2×r2×2^46) mod 2^130-5\n-\/\/                                    = (a2×5×r2×2^2 × 2^44) mod 2^130-5 \/\/ Align to limb boudary\n-\/\/                                    = (a2×[5×r2×4] × 2^44) mod 2^130-5\n-\/\/                                    = (a2×R2P × 2^44) mod 2^130-5 \/\/ i.e. R2P = 4*5*R2\n+\/\/ For example, partial product (a2xr2):\n+\/\/    (a2x2^88)x(r2x2^88) mod 2^130-5\n+\/\/                                    = (a2xr2 x 2^176) mod 2^130-5\n+\/\/                                    = (a2xr2 x 2^46x2^130) mod 2^130-5\n+\/\/                                    = (a2xr2x2^46 x 2^130- 5xa2xr2x2^46 + 5xa2xr2x2^46) mod 2^130-5\n+\/\/                                    = (a2xr2x2^46 x (2^130- 5) + 5xa2xr2x2^46) mod 2^130-5 \/\/ i.e. adding multiples of modulus is a noop\n+\/\/                                    = (5xa2xr2x2^46) mod 2^130-5\n+\/\/                                    = (a2x5xr2x2^2 x 2^44) mod 2^130-5 \/\/ Align to limb boudary\n+\/\/                                    = (a2x[5xr2x4] x 2^44) mod 2^130-5\n+\/\/                                    = (a2xR2P x 2^44) mod 2^130-5 \/\/ i.e. R2P = 4*5*R2\n@@ -139,3 +139,3 @@\n-  \/\/ p0 = a2×r1'\n-  \/\/ p1 = a2×r2'\n-  \/\/ p2 = a2×r0\n+  \/\/ p0 = a2xr1'\n+  \/\/ p1 = a2xr2'\n+  \/\/ p2 = a2xr0\n@@ -149,3 +149,3 @@\n-  \/\/ p0 += a0×r0\n-  \/\/ p1 += a0×r1\n-  \/\/ p2 += a0×r2\n+  \/\/ p0 += a0xr0\n+  \/\/ p1 += a0xr1\n+  \/\/ p2 += a0xr2\n@@ -159,3 +159,3 @@\n-  \/\/ p0 += a1×r2'\n-  \/\/ p1 += a1×r0\n-  \/\/ p2 += a1×r1\n+  \/\/ p0 += a1xr2'\n+  \/\/ p1 += a1xr0\n+  \/\/ p2 += a1xr1\n@@ -171,2 +171,2 @@\n-  \/\/         P2L   P1L   P0L                     |                 P2L×2^88 + P1L×2^44 + P0L×2^0\n-  \/\/ + P2H   P1H   P0H                           |   + P2H×2^140 + P1H×2^96 + P0H×2^52\n+  \/\/         P2L   P1L   P0L                     |                 P2Lx2^88 + P1Lx2^44 + P0Lx2^0\n+  \/\/ + P2H   P1H   P0H                           |   + P2Hx2^140 + P1Hx2^96 + P0Hx2^52\n@@ -174,1 +174,1 @@\n-  \/\/ = P2H    A2    A1    A0                     |   = P2H×2^130 + A2×2^88 +   A1×2^44 +  A0×2^0\n+  \/\/ = P2H    A2    A1    A0                     |   = P2Hx2^130 + A2x2^88 +   A1x2^44 +  A0x2^0\n@@ -217,2 +217,2 @@\n-\/\/       a2×r0     a1×r0     a0×r0\n-\/\/   +             a0×r1\n+\/\/       a2xr0     a1xr0     a0xr0\n+\/\/   +             a0xr1\n@@ -350,1 +350,1 @@\n- * Copy 5×26-bit (unreduced) limbs stored at Register limbs into  a2:a1:a0 (3×64-bit limbs)\n+ * Copy 5x26-bit (unreduced) limbs stored at Register limbs into  a2:a1:a0 (3x64-bit limbs)\n@@ -396,1 +396,1 @@\n- * Break 3×64-bit a2:a1:a0 limbs into 5×26-bit limbs and store out into 5 quadwords at address `limbs`\n+ * Break 3x64-bit a2:a1:a0 limbs into 5x26-bit limbs and store out into 5 quadwords at address `limbs`\n@@ -477,3 +477,3 @@\n-\/\/  × used for poly1305_multiply8_avx512\n-\/\/  lower-case variables are scalar numbers in 3×44-bit limbs (in gprs)\n-\/\/  upper-case variables are 8&16-element vector numbers in 3×44-bit limbs (in zmm registers)\n+\/\/  x used for poly1305_multiply8_avx512\n+\/\/  lower-case variables are scalar numbers in 3x44-bit limbs (in gprs)\n+\/\/  upper-case variables are 8&16-element vector numbers in 3x44-bit limbs (in zmm registers)\n@@ -499,1 +499,1 @@\n-\/\/    B  = B×R                \/\/ [r^8  0  r^7  0  r^6  0  r^5  0 ]\n+\/\/    B  = BxR                \/\/ [r^8  0  r^7  0  r^6  0  r^5  0 ]\n@@ -503,1 +503,1 @@\n-\/\/    B  = B × R              \/\/ [r^16 r^12 r^15 r^11 r^14 r^10 r^13 r^9]\n+\/\/    B  = B x R              \/\/ [r^16 r^12 r^15 r^11 r^14 r^10 r^13 r^9]\n@@ -510,2 +510,2 @@\n-\/\/     AL = AL × R\n-\/\/     AH = AH × R\n+\/\/     AL = AL x R\n+\/\/     AH = AH x R\n@@ -515,2 +515,2 @@\n-\/\/  AL = AL × CL\n-\/\/  AH = AH × CH\n+\/\/  AL = AL x CL\n+\/\/  AH = AH x CH\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-      \/\/ that a statement begins at the “left edge” of the line.\n+      \/\/ that a statement begins at the \"left edge\" of the line.\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}