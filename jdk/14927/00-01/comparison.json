{"files":[{"patch":"@@ -1589,3 +1589,3 @@\n-C2V_VMENTRY_0(int, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n-  if (!ConstantPool::is_invokedynamic_index(index)) {\n-    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", index));\n+C2V_VMENTRY_0(int, invokeDynamicOperandToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint operand, jboolean resolve))\n+  if (!ConstantPool::is_invokedynamic_index(operand)) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", operand));\n@@ -1596,3 +1596,5 @@\n-  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK_0);\n-  int indy_index = cp->decode_invokedynamic_index(index);\n-  cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  int indy_index = cp->decode_invokedynamic_index(operand);\n+  if (resolve) {\n+    LinkResolver::resolve_invoke(callInfo, Handle(), cp, operand, Bytecodes::_invokedynamic, CHECK_0);\n+    cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  }\n@@ -3123,1 +3125,1 @@\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"invokeDynamicOperandToCPIndex\",                CC \"(\" HS_CONSTANT_POOL2 \"IZ)I\",                                                      FN_PTR(invokeDynamicOperandToCPIndex)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -390,2 +390,2 @@\n-     * Ensures that the type referenced by the specified {@code JVM_CONSTANT_InvokeDynamic} entry at\n-     * index {@code cpi} in {@code constantPool} is loaded and initialized.\n+     * Converts the operand of an invokedynamic instruction in {@code operand}\n+     * to an index directly into {@code constantPool}.\n@@ -393,2 +393,3 @@\n-     * @throws IllegalArgumentException if {@code cpi} is not an invokedynamic index\n-     * @return the invokedynamic index\n+     * @param resolve if {@true}, then resolve the entry (which may call the bootstrap method)\n+     * @throws IllegalArgumentException if {@code operand} is not a valid invokedynamic operand\n+     * @return {@code JVM_CONSTANT_InvokeDynamic} constant pool entry index for the invokedynamic\n@@ -396,2 +397,2 @@\n-    int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return resolveInvokeDynamicInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int invokeDynamicOperandToCPIndex(HotSpotConstantPool constantPool, int operand, boolean resolve) {\n+        return invokeDynamicOperandToCPIndex(constantPool, constantPool.getConstantPoolPointer(), operand, resolve);\n@@ -400,1 +401,1 @@\n-    private native int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int invokeDynamicOperandToCPIndex(HotSpotConstantPool constantPool, long constantPoolPointer, int operand, boolean resolve);\n@@ -443,1 +444,1 @@\n-     * {@link #resolveInvokeDynamicInPool} and {@link #resolveInvokeHandleInPool}), return the\n+     * {@link #invokeDynamicOperandToCPIndex} and {@link #resolveInvokeHandleInPool}), return the\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-            return compilerToVM().resolveInvokeDynamicInPool(this, rawIndex);\n+            return compilerToVM().invokeDynamicOperandToCPIndex(this, rawIndex, false);\n@@ -865,1 +865,1 @@\n-                index = compilerToVM().resolveInvokeDynamicInPool(this, cpi);\n+                index = compilerToVM().invokeDynamicOperandToCPIndex(this, cpi, true);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,5 +135,0 @@\n-    public static void resolveInvokeDynamicInPool(\n-            ConstantPool constantPool, int cpi) {\n-        CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.invoke.CallSite;\n@@ -43,0 +44,1 @@\n+import java.lang.invoke.MethodType;\n@@ -47,0 +49,1 @@\n+import java.util.Set;\n@@ -204,0 +207,8 @@\n+            MethodVisitor shouldNotBeCalled = cw.visitMethod(PUBLIC_STATIC, \"shouldNotBeCalled\", \"()V\", null, null);\n+            sig = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\";\n+            handle = new Handle(H_INVOKESTATIC, testClassInternalName, \"shouldNotBeCalledBSM\", sig, false);\n+            shouldNotBeCalled.visitInvokeDynamicInsn(\"do_shouldNotBeCalled\", \"()V\", handle);\n+            shouldNotBeCalled.visitInsn(RETURN);\n+            shouldNotBeCalled.visitMaxs(0, 0);\n+            shouldNotBeCalled.visitEnd();\n+\n@@ -238,0 +249,31 @@\n+    \/**\n+     * Asserts that {@link ConstantPool#lookupConstant(int, boolean)} with {@code resolve == false}\n+     * returns null for all resolvable constant entries.\n+     *\/\n+    private static void assertNoEagerConstantResolution(Class<?> testClass, ConstantPool cp, Method getTagAt) throws Exception {\n+        for (int cpi = 1; cpi < cp.length(); cpi++) {\n+            String tag = String.valueOf(getTagAt.invoke(cp, cpi));\n+            switch (tag) {\n+                case \"MethodHandle\":\n+                case \"MethodType\":\n+                case \"Dynamic\": {\n+                    Object con = cp.lookupConstant(cpi, false);\n+                    Assert.assertNull(con, \"Unexpected eager resolution in \" + testClass + \" at cpi \" + cpi + \" (tag: \" + tag + \")\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures {@link ConstantPool#lookupBootstrapMethodInvocation} does not invoke the associated bootstrap method.\n+     *\/\n+    private static void assertLookupBMIDoesNotInvokeBM(MetaAccessProvider metaAccess, Class<?> testClass) throws Exception {\n+        ResolvedJavaMethod shouldNotBeCalled = metaAccess.lookupJavaMethod(testClass.getDeclaredMethod(\"shouldNotBeCalled\"));\n+        ConstantPool cp = shouldNotBeCalled.getConstantPool();\n+        int cpi = getFirstInvokedynamicOperand(shouldNotBeCalled);\n+        BootstrapMethodInvocation bmi = cp.lookupBootstrapMethodInvocation(cpi, INVOKEDYNAMIC);\n+        Assert.assertEquals(bmi.getName(), \"do_shouldNotBeCalled\");\n+        Assert.assertEquals(bmi.getMethod().getName(), \"shouldNotBeCalledBSM\");\n+    }\n+\n@@ -266,0 +308,4 @@\n+\n+                assertNoEagerConstantResolution(testClass, cp, getTagAt);\n+                assertLookupBMIDoesNotInvokeBM(metaAccess, testClass);\n+\n@@ -269,16 +315,2 @@\n-                    switch (tag) {\n-                        case \"MethodHandle\":\n-                        case \"MethodType\":\n-                        case \"Dynamic\": {\n-                            Object con = cp.lookupConstant(cpi, false);\n-                            Assert.assertNull(con, \"Unexpected eager resolution\");\n-\n-                            con = cp.lookupConstant(cpi, true);\n-                            Assert.assertNotNull(con, \"Eager resolution failed\");\n-\n-                            if (tag.equals(\"Dynamic\")) {\n-                                lastConstant = cp.lookupConstant(cpi);\n-                                Assert.assertEquals(con, lastConstant);\n-                            }\n-                            break;\n-                        }\n+                    if (tag.equals(\"Dynamic\")) {\n+                        lastConstant = cp.lookupConstant(cpi);\n@@ -318,1 +350,6 @@\n-        Object lastConstant = null;\n+\n+        Set<String> expectedBSMs = Set.of(\n+            \"jdk.vm.ci.hotspot.test.TestDynamicConstant.shouldNotBeCalledBSM\",\n+            \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\"\n+        );\n+\n@@ -327,1 +364,1 @@\n-                    Assert.assertEquals(bsm, \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\");\n+                    Assert.assertTrue(expectedBSMs.contains(bsm), expectedBSMs.toString());\n@@ -341,1 +378,1 @@\n-        testLoadReferencedType(concat);\n+        testLoadReferencedType(concat, cp);\n@@ -348,0 +385,3 @@\n+    private static int beU1(byte[] data, int bci) {\n+        return data[bci] & 0xff;\n+    }\n@@ -349,2 +389,7 @@\n-    private static void testLoadReferencedType(ResolvedJavaMethod method) {\n-        \/\/ Make sure that loadReferencedType for an invokedynamic call site works.\n+\n+    \/**\n+     * Gets the operand of the first invokedynamic in {@code method}. This\n+     * assumes that the bytecode of {@code method} is an INVOKEDYNAMIC instruction,\n+     * possibly preceded by an LDC instruction.\n+     *\/\n+    private static int getFirstInvokedynamicOperand(ResolvedJavaMethod method) {\n@@ -352,7 +397,16 @@\n-        Assert.assertTrue(code[0] == LDC || code[0] == LDC2_W, \"unexpected ldc sequence\");\n-        int bci = code[0] == LDC ? 2 : 3;\n-        Assert.assertTrue((code[bci] & 0xff) == INVOKEDYNAMIC, \"unexpected bytecode\");\n-        int cpi = beS4(code, bci + 1);\n-        method.getConstantPool().loadReferencedType(cpi, INVOKEDYNAMIC, false);\n-        BootstrapMethodInvocation bmi = method.getConstantPool().lookupBootstrapMethodInvocation(cpi, INVOKEDYNAMIC);\n-        Assert.assertEquals(bmi.getName(), \"do_concat\");\n+        int opcode = beU1(code, 0);\n+        if (opcode == INVOKEDYNAMIC) {\n+            return beS4(code, 1);\n+        }\n+        Assert.assertTrue(opcode == LDC || opcode == LDC2_W, String.valueOf(opcode));\n+        int bci = opcode == LDC ? 2 : 3;\n+        Assert.assertEquals(beU1(code, bci), INVOKEDYNAMIC);\n+        return beS4(code, bci + 1);\n+    }\n+\n+    \/**\n+     * Ensures that loadReferencedType for an invokedynamic call site does not throw an exception.\n+     *\/\n+    private static void testLoadReferencedType(ResolvedJavaMethod method, ConstantPool cp) {\n+        int cpi = getFirstInvokedynamicOperand(method);\n+        cp.loadReferencedType(cpi, INVOKEDYNAMIC, false);\n@@ -399,0 +453,5 @@\n+\n+    \/\/ A bootstrap method that should never be called\n+    public static CallSite shouldNotBeCalledBSM(MethodHandles.Lookup caller, String name, MethodType type) throws Exception {\n+        throw new RuntimeException(\"should not be called\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":87,"deletions":28,"binary":false,"changes":115,"status":"modified"}]}