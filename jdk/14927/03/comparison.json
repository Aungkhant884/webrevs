{"files":[{"patch":"@@ -700,1 +700,1 @@\n-C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_NULL(jobject, lookupConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint cp_index, bool resolve))\n@@ -702,2 +702,11 @@\n-  oop obj = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n-  constantTag tag = cp->tag_at(index);\n+  oop obj;\n+  if (!resolve) {\n+    bool found_it;\n+    obj = cp->find_cached_constant_at(cp_index, found_it, CHECK_NULL);\n+    if (!found_it) {\n+      return nullptr;\n+    }\n+  } else {\n+    obj = cp->resolve_possibly_cached_constant_at(cp_index, CHECK_NULL);\n+  }\n+  constantTag tag = cp->tag_at(cp_index);\n@@ -708,1 +717,1 @@\n-    BasicType bt = Signature::basic_type(cp->uncached_signature_ref_at(index));\n+    BasicType bt = Signature::basic_type(cp->uncached_signature_ref_at(cp_index));\n@@ -1581,3 +1590,3 @@\n-C2V_VMENTRY_0(int, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n-  if (!ConstantPool::is_invokedynamic_index(index)) {\n-    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", index));\n+C2V_VMENTRY_0(int, decodeIndyIndexToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint encoded_indy_index, jboolean resolve))\n+  if (!ConstantPool::is_invokedynamic_index(encoded_indy_index)) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an encoded indy index %d\", encoded_indy_index));\n@@ -1588,3 +1597,5 @@\n-  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK_0);\n-  int indy_index = cp->decode_invokedynamic_index(index);\n-  cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  int indy_index = cp->decode_invokedynamic_index(encoded_indy_index);\n+  if (resolve) {\n+    LinkResolver::resolve_invoke(callInfo, Handle(), cp, encoded_indy_index, Bytecodes::_invokedynamic, CHECK_0);\n+    cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  }\n@@ -3111,0 +3122,1 @@\n+  {CC \"lookupConstantInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"IZ)\" JAVACONSTANT,                                          FN_PTR(lookupConstantInPool)},\n@@ -3114,1 +3126,0 @@\n-  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(resolvePossiblyCachedConstantInPool)},\n@@ -3117,1 +3128,1 @@\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"decodeIndyIndexToCPIndex\",                     CC \"(\" HS_CONSTANT_POOL2 \"IZ)I\",                                                      FN_PTR(decodeIndyIndexToCPIndex)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-     * Resolves the entry at index {@code cpi} in {@code constantPool} to an object, looking in the\n+     * Gets the entry at index {@code cpi} in {@code constantPool}, looking in the\n@@ -281,0 +281,3 @@\n+     *\n+     * @param resolve specifies if a resolved entry is expected. If {@code false},\n+     *                {@code null} is returned for an unresolved entry.\n@@ -282,2 +285,2 @@\n-    JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return resolvePossiblyCachedConstantInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    JavaConstant lookupConstantInPool(HotSpotConstantPool constantPool, int cpi, boolean resolve) {\n+        return lookupConstantInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, resolve);\n@@ -286,1 +289,1 @@\n-    private native JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native JavaConstant lookupConstantInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, boolean resolve);\n@@ -390,2 +393,2 @@\n-     * Ensures that the type referenced by the specified {@code JVM_CONSTANT_InvokeDynamic} entry at\n-     * index {@code cpi} in {@code constantPool} is loaded and initialized.\n+     * Converts the encoded indy index operand of an invokedynamic instruction\n+     * to an index directly into {@code constantPool}.\n@@ -393,2 +396,3 @@\n-     * @throws IllegalArgumentException if {@code cpi} is not an invokedynamic index\n-     * @return the invokedynamic index\n+     * @param resolve if {@true}, then resolve the entry (which may call a bootstrap method)\n+     * @throws IllegalArgumentException if {@code encoded_indy_index} is not an encoded indy index\n+     * @return {@code JVM_CONSTANT_InvokeDynamic} constant pool entry index for the invokedynamic\n@@ -396,2 +400,2 @@\n-    int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return resolveInvokeDynamicInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int decodeIndyIndexToCPIndex(HotSpotConstantPool constantPool, int encoded_indy_index, boolean resolve) {\n+        return decodeIndyIndexToCPIndex(constantPool, constantPool.getConstantPoolPointer(), encoded_indy_index, resolve);\n@@ -400,1 +404,1 @@\n-    private native int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int decodeIndyIndexToCPIndex(HotSpotConstantPool constantPool, long constantPoolPointer, int encoded_indy_index, boolean resolve);\n@@ -443,1 +447,1 @@\n-     * {@link #resolveInvokeDynamicInPool} and {@link #resolveInvokeHandleInPool}), return the\n+     * {@link #decodeIndyIndexToCPIndex} and {@link #resolveInvokeHandleInPool}), return the\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -640,0 +640,5 @@\n+        return lookupConstant(cpi, true);\n+    }\n+\n+    @Override\n+    public Object lookupConstant(int cpi, boolean resolve) {\n@@ -661,1 +666,1 @@\n-                return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);\n+                return compilerToVM().lookupConstantInPool(this, cpi, true);\n@@ -668,1 +673,1 @@\n-                return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);\n+                return compilerToVM().lookupConstantInPool(this, cpi, resolve);\n@@ -672,0 +677,1 @@\n+\n@@ -825,1 +831,1 @@\n-            return compilerToVM().resolveInvokeDynamicInPool(this, rawIndex);\n+            return compilerToVM().decodeIndyIndexToCPIndex(this, rawIndex, false);\n@@ -859,1 +865,1 @@\n-                index = compilerToVM().resolveInvokeDynamicInPool(this, cpi);\n+                index = compilerToVM().decodeIndyIndexToCPIndex(this, cpi, true);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -223,0 +223,14 @@\n+    \/**\n+     * Looks up a constant at the specified index.\n+     *\n+     * If {@code resolve == false} and the denoted constant is of type\n+     * {@code JVM_CONSTANT_Dynamic}, {@code JVM_CONSTANT_MethodHandle} or\n+     * {@code JVM_CONSTANT_MethodType} and it's not yet resolved then\n+     * {@code null} is returned.\n+     *\n+     * @param cpi the constant pool index\n+     * @return the {@code Constant} or {@code JavaType} instance representing the constant pool\n+     *         entry\n+     *\/\n+    Object lookupConstant(int cpi, boolean resolve);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-    public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {\n-        DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static Object lookupConstantInPool(ConstantPool constantPool, int cpi, boolean resolve) {\n+        DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.lookupConstantInPool((HotSpotConstantPool) constantPool, cpi, resolve);\n@@ -135,5 +135,0 @@\n-    public static void resolveInvokeDynamicInPool(\n-            ConstantPool constantPool, int cpi) {\n-        CTVM.resolveInvokeDynamicInPool((HotSpotConstantPool) constantPool, cpi);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8138708\n+ * @bug 8136421\n+ * @requires vm.jvmci\n+ * @library \/test\/lib \/\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.reflect\n+ *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:-UseJVMCICompiler\n+ *                   compiler.jvmci.compilerToVM.LookupConstantInPoolTest\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.TestedCPEntry;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.Validator;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestsHelper.DummyClasses;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.meta.ConstantPool;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODHANDLE;\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODTYPE;\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_STRING;\n+\n+\/**\n+ * Test for {@code jdk.vm.ci.hotspot.CompilerToVM.lookupConstantInPool} method\n+ *\/\n+public class LookupConstantInPoolTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        Map<ConstantTypes, Validator> typeTests = new HashMap<>();\n+        typeTests.put(CONSTANT_STRING, LookupConstantInPoolTest::validateString);\n+        typeTests.put(CONSTANT_METHODHANDLE, LookupConstantInPoolTest::validateMethodHandle);\n+        typeTests.put(CONSTANT_METHODTYPE, LookupConstantInPoolTest::validateMethodType);\n+        ConstantPoolTestCase testCase = new ConstantPoolTestCase(typeTests);\n+        testCase.test();\n+        \/\/ The next \"Class.forName\" and repeating \"testCase.test()\"\n+        \/\/ are here for the following reason.\n+        \/\/ The first test run is without dummy class initialization,\n+        \/\/ which means no constant pool cache exists.\n+        \/\/ The second run is with initialized class (with constant pool cache available).\n+        \/\/ Some CompilerToVM methods require different input\n+        \/\/ depending on whether CP cache exists or not.\n+        for (DummyClasses dummy : DummyClasses.values()) {\n+            Class.forName(dummy.klass.getName());\n+        }\n+        testCase.test();\n+    }\n+\n+    private static void validateString(ConstantPool constantPoolCTVM,\n+                                       ConstantTypes cpType,\n+                                       DummyClasses dummyClass,\n+                                       int cpi) {\n+        TestedCPEntry entry = cpType.getTestedCPEntry(dummyClass, cpi);\n+        if (entry == null) {\n+            return;\n+        }\n+        int index = cpi;\n+        String cached = \"\";\n+        int cpci = dummyClass.getCPCacheIndex(cpi);\n+        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n+            index = cpci;\n+            cached = \"cached \";\n+        }\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String stringToVerify = (String) constantInPool;\n+        String stringToRefer = entry.name;\n+        if (stringToRefer.equals(\"\") && cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n+            stringToRefer = null; \/\/ tested method returns null for cached empty strings\n+        }\n+        String msg = String.format(\"Wrong string accessed by %sconstant pool index %d\", cached, index);\n+        Asserts.assertEQ(stringToRefer, stringToVerify, msg);\n+    }\n+\n+    private static final String NOT_NULL_MSG\n+            = \"Object returned by lookupConstantInPool method should not be null\";\n+\n+\n+    private static void validateMethodHandle(ConstantPool constantPoolCTVM,\n+                                             ConstantTypes cpType,\n+                                             DummyClasses dummyClass,\n+                                             int index) {\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n+        Asserts.assertNotNull(constantInPool, msg);\n+        if (!(constantInPool instanceof MethodHandle)) {\n+            msg = String.format(\"Wrong constant pool entry accessed by index\"\n+                                        + \" %d: %s, but should be subclass of %s\",\n+                                index,\n+                                constantInPool.getClass(),\n+                                MethodHandle.class.getName());\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    private static void validateMethodType(ConstantPool constantPoolCTVM,\n+                                           ConstantTypes cpType,\n+                                           DummyClasses dummyClass,\n+                                           int index) {\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n+        Asserts.assertNotNull(constantInPool, msg);\n+        Class mtToVerify = constantInPool.getClass();\n+        Class mtToRefer = MethodType.class;\n+        msg = String.format(\"Wrong method type class accessed by\"\n+                                    + \" constant pool index %d\",\n+                            index);\n+        Asserts.assertEQ(mtToRefer, mtToVerify, msg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupConstantInPoolTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8138708\n- * @bug 8136421\n- * @requires vm.jvmci\n- * @library \/test\/lib \/\n- * @library ..\/common\/patches\n- * @modules java.base\/jdk.internal.access\n- *          java.base\/jdk.internal.reflect\n- *          java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.org.objectweb.asm.tree\n- *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n- *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n- *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n- *\n- * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n- *                   -XX:-UseJVMCICompiler\n- *                   compiler.jvmci.compilerToVM.ResolvePossiblyCachedConstantInPoolTest\n- *\/\n-\n-package compiler.jvmci.compilerToVM;\n-\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.TestedCPEntry;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.Validator;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestsHelper.DummyClasses;\n-import jdk.test.lib.Asserts;\n-import jdk.vm.ci.hotspot.CompilerToVMHelper;\n-import jdk.vm.ci.meta.ConstantPool;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODHANDLE;\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODTYPE;\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_STRING;\n-\n-\/**\n- * Test for {@code jdk.vm.ci.hotspot.CompilerToVM.resolvePossiblyCachedConstantInPool} method\n- *\/\n-public class ResolvePossiblyCachedConstantInPoolTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        Map<ConstantTypes, Validator> typeTests = new HashMap<>();\n-        typeTests.put(CONSTANT_STRING, ResolvePossiblyCachedConstantInPoolTest::validateString);\n-        typeTests.put(CONSTANT_METHODHANDLE, ResolvePossiblyCachedConstantInPoolTest::validateMethodHandle);\n-        typeTests.put(CONSTANT_METHODTYPE, ResolvePossiblyCachedConstantInPoolTest::validateMethodType);\n-        ConstantPoolTestCase testCase = new ConstantPoolTestCase(typeTests);\n-        testCase.test();\n-        \/\/ The next \"Class.forName\" and repeating \"testCase.test()\"\n-        \/\/ are here for the following reason.\n-        \/\/ The first test run is without dummy class initialization,\n-        \/\/ which means no constant pool cache exists.\n-        \/\/ The second run is with initialized class (with constant pool cache available).\n-        \/\/ Some CompilerToVM methods require different input\n-        \/\/ depending on whether CP cache exists or not.\n-        for (DummyClasses dummy : DummyClasses.values()) {\n-            Class.forName(dummy.klass.getName());\n-        }\n-        testCase.test();\n-    }\n-\n-    private static void validateString(ConstantPool constantPoolCTVM,\n-                                       ConstantTypes cpType,\n-                                       DummyClasses dummyClass,\n-                                       int cpi) {\n-        TestedCPEntry entry = cpType.getTestedCPEntry(dummyClass, cpi);\n-        if (entry == null) {\n-            return;\n-        }\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String stringToVerify = (String) constantInPool;\n-        String stringToRefer = entry.name;\n-        if (stringToRefer.equals(\"\") && cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            stringToRefer = null; \/\/ tested method returns null for cached empty strings\n-        }\n-        String msg = String.format(\"Wrong string accessed by %sconstant pool index %d\", cached, index);\n-        Asserts.assertEQ(stringToRefer, stringToVerify, msg);\n-    }\n-\n-    private static final String NOT_NULL_MSG\n-            = \"Object returned by resolvePossiblyCachedConstantInPool method should not be null\";\n-\n-\n-    private static void validateMethodHandle(ConstantPool constantPoolCTVM,\n-                                             ConstantTypes cpType,\n-                                             DummyClasses dummyClass,\n-                                             int index) {\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n-        Asserts.assertNotNull(constantInPool, msg);\n-        if (!(constantInPool instanceof MethodHandle)) {\n-            msg = String.format(\"Wrong constant pool entry accessed by index\"\n-                                        + \" %d: %s, but should be subclass of %s\",\n-                                index,\n-                                constantInPool.getClass(),\n-                                MethodHandle.class.getName());\n-            throw new AssertionError(msg);\n-        }\n-    }\n-\n-    private static void validateMethodType(ConstantPool constantPoolCTVM,\n-                                           ConstantTypes cpType,\n-                                           DummyClasses dummyClass,\n-                                           int index) {\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n-        Asserts.assertNotNull(constantInPool, msg);\n-        Class mtToVerify = constantInPool.getClass();\n-        Class mtToRefer = MethodType.class;\n-        msg = String.format(\"Wrong method type class accessed by\"\n-                                    + \" constant pool index %d\",\n-                            index);\n-        Asserts.assertEQ(mtToRefer, mtToVerify, msg);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ResolvePossiblyCachedConstantInPoolTest.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.invoke.CallSite;\n@@ -43,0 +44,1 @@\n+import java.lang.invoke.MethodType;\n@@ -47,0 +49,1 @@\n+import java.util.Set;\n@@ -204,0 +207,8 @@\n+            MethodVisitor shouldNotBeCalled = cw.visitMethod(PUBLIC_STATIC, \"shouldNotBeCalled\", \"()V\", null, null);\n+            sig = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\";\n+            handle = new Handle(H_INVOKESTATIC, testClassInternalName, \"shouldNotBeCalledBSM\", sig, false);\n+            shouldNotBeCalled.visitInvokeDynamicInsn(\"do_shouldNotBeCalled\", \"()V\", handle);\n+            shouldNotBeCalled.visitInsn(RETURN);\n+            shouldNotBeCalled.visitMaxs(0, 0);\n+            shouldNotBeCalled.visitEnd();\n+\n@@ -238,0 +249,31 @@\n+    \/**\n+     * Asserts that {@link ConstantPool#lookupConstant(int, boolean)} with {@code resolve == false}\n+     * returns null for all resolvable constant entries.\n+     *\/\n+    private static void assertNoEagerConstantResolution(Class<?> testClass, ConstantPool cp, Method getTagAt) throws Exception {\n+        for (int cpi = 1; cpi < cp.length(); cpi++) {\n+            String tag = String.valueOf(getTagAt.invoke(cp, cpi));\n+            switch (tag) {\n+                case \"MethodHandle\":\n+                case \"MethodType\":\n+                case \"Dynamic\": {\n+                    Object con = cp.lookupConstant(cpi, false);\n+                    Assert.assertNull(con, \"Unexpected eager resolution in \" + testClass + \" at cpi \" + cpi + \" (tag: \" + tag + \")\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures {@link ConstantPool#lookupBootstrapMethodInvocation} does not invoke the associated bootstrap method.\n+     *\/\n+    private static void assertLookupBMIDoesNotInvokeBM(MetaAccessProvider metaAccess, Class<?> testClass) throws Exception {\n+        ResolvedJavaMethod shouldNotBeCalled = metaAccess.lookupJavaMethod(testClass.getDeclaredMethod(\"shouldNotBeCalled\"));\n+        ConstantPool cp = shouldNotBeCalled.getConstantPool();\n+        int cpi = getFirstInvokedynamicOperand(shouldNotBeCalled);\n+        BootstrapMethodInvocation bmi = cp.lookupBootstrapMethodInvocation(cpi, INVOKEDYNAMIC);\n+        Assert.assertEquals(bmi.getName(), \"do_shouldNotBeCalled\");\n+        Assert.assertEquals(bmi.getMethod().getName(), \"shouldNotBeCalledBSM\");\n+    }\n+\n@@ -266,0 +308,4 @@\n+\n+                assertNoEagerConstantResolution(testClass, cp, getTagAt);\n+                assertLookupBMIDoesNotInvokeBM(metaAccess, testClass);\n+\n@@ -304,1 +350,6 @@\n-        Object lastConstant = null;\n+\n+        Set<String> expectedBSMs = Set.of(\n+            \"jdk.vm.ci.hotspot.test.TestDynamicConstant.shouldNotBeCalledBSM\",\n+            \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\"\n+        );\n+\n@@ -313,1 +364,1 @@\n-                    Assert.assertEquals(bsm, \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\");\n+                    Assert.assertTrue(expectedBSMs.contains(bsm), expectedBSMs.toString());\n@@ -327,1 +378,1 @@\n-        testLoadReferencedType(concat);\n+        testLoadReferencedType(concat, cp);\n@@ -334,0 +385,3 @@\n+    private static int beU1(byte[] data, int bci) {\n+        return data[bci] & 0xff;\n+    }\n@@ -335,2 +389,7 @@\n-    private static void testLoadReferencedType(ResolvedJavaMethod method) {\n-        \/\/ Make sure that loadReferencedType for an invokedynamic call site works.\n+\n+    \/**\n+     * Gets the operand of the first invokedynamic in {@code method}. This\n+     * assumes that the bytecode of {@code method} is an INVOKEDYNAMIC instruction,\n+     * possibly preceded by an LDC instruction.\n+     *\/\n+    private static int getFirstInvokedynamicOperand(ResolvedJavaMethod method) {\n@@ -338,7 +397,16 @@\n-        Assert.assertTrue(code[0] == LDC || code[0] == LDC2_W, \"unexpected ldc sequence\");\n-        int bci = code[0] == LDC ? 2 : 3;\n-        Assert.assertTrue((code[bci] & 0xff) == INVOKEDYNAMIC, \"unexpected bytecode\");\n-        int cpi = beS4(code, bci + 1);\n-        method.getConstantPool().loadReferencedType(cpi, INVOKEDYNAMIC, false);\n-        BootstrapMethodInvocation bmi = method.getConstantPool().lookupBootstrapMethodInvocation(cpi, INVOKEDYNAMIC);\n-        Assert.assertEquals(bmi.getName(), \"do_concat\");\n+        int opcode = beU1(code, 0);\n+        if (opcode == INVOKEDYNAMIC) {\n+            return beS4(code, 1);\n+        }\n+        Assert.assertTrue(opcode == LDC || opcode == LDC2_W, String.valueOf(opcode));\n+        int bci = opcode == LDC ? 2 : 3;\n+        Assert.assertEquals(beU1(code, bci), INVOKEDYNAMIC);\n+        return beS4(code, bci + 1);\n+    }\n+\n+    \/**\n+     * Ensures that loadReferencedType for an invokedynamic call site does not throw an exception.\n+     *\/\n+    private static void testLoadReferencedType(ResolvedJavaMethod method, ConstantPool cp) {\n+        int cpi = getFirstInvokedynamicOperand(method);\n+        cp.loadReferencedType(cpi, INVOKEDYNAMIC, false);\n@@ -385,0 +453,5 @@\n+\n+    \/\/ A bootstrap method that should never be called\n+    public static CallSite shouldNotBeCalledBSM(MethodHandles.Lookup caller, String name, MethodType type) throws Exception {\n+        throw new RuntimeException(\"should not be called\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":85,"deletions":12,"binary":false,"changes":97,"status":"modified"}]}