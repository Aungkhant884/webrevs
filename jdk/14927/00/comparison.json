{"files":[{"patch":"@@ -700,1 +700,1 @@\n-C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_NULL(jobject, lookupConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, bool resolve))\n@@ -702,1 +702,10 @@\n-  oop obj = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n+  oop obj;\n+  if (!resolve) {\n+    bool found_it;\n+    obj = cp->find_cached_constant_at(index, found_it, CHECK_NULL);\n+    if (!found_it) {\n+      return nullptr;\n+    }\n+  } else {\n+    obj = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n+  }\n@@ -3108,0 +3117,1 @@\n+  {CC \"lookupConstantInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"IZ)\" JAVACONSTANT,                                          FN_PTR(lookupConstantInPool)},\n@@ -3111,1 +3121,0 @@\n-  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(resolvePossiblyCachedConstantInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -282,2 +282,2 @@\n-    JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return resolvePossiblyCachedConstantInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    JavaConstant lookupConstantInPool(HotSpotConstantPool constantPool, int cpi, boolean resolve) {\n+        return lookupConstantInPool(constantPool, constantPool.getConstantPoolPointer(), cpi, resolve);\n@@ -286,1 +286,1 @@\n-    private native JavaConstant resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native JavaConstant lookupConstantInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi, boolean resolve);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -640,0 +640,5 @@\n+        return lookupConstant(cpi, true);\n+    }\n+\n+    @Override\n+    public Object lookupConstant(int cpi, boolean resolve) {\n@@ -661,1 +666,1 @@\n-                return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);\n+                return compilerToVM().lookupConstantInPool(this, cpi, true);\n@@ -668,1 +673,1 @@\n-                return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);\n+                return compilerToVM().lookupConstantInPool(this, cpi, resolve);\n@@ -672,0 +677,1 @@\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -223,0 +223,14 @@\n+    \/**\n+     * Looks up a constant at the specified index.\n+     *\n+     * If {@code resolve == false} and the denoted constant is of type\n+     * {@code JVM_CONSTANT_Dynamic}, {@code JVM_CONSTANT_MethodHandle} or\n+     * {@code JVM_CONSTANT_MethodType} and it's not yet resolved then\n+     * {@code null} is returned.\n+     *\n+     * @param cpi the constant pool index\n+     * @return the {@code Constant} or {@code JavaType} instance representing the constant pool\n+     *         entry\n+     *\/\n+    Object lookupConstant(int cpi, boolean resolve);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-    public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {\n-        DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static Object lookupConstantInPool(ConstantPool constantPool, int cpi, boolean resolve) {\n+        DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.lookupConstantInPool((HotSpotConstantPool) constantPool, cpi, resolve);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8138708\n+ * @bug 8136421\n+ * @requires vm.jvmci\n+ * @library \/test\/lib \/\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.reflect\n+ *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:-UseJVMCICompiler\n+ *                   compiler.jvmci.compilerToVM.LookupConstantInPoolTest\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.TestedCPEntry;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestCase.Validator;\n+import compiler.jvmci.compilerToVM.ConstantPoolTestsHelper.DummyClasses;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.meta.ConstantPool;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODHANDLE;\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODTYPE;\n+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_STRING;\n+\n+\/**\n+ * Test for {@code jdk.vm.ci.hotspot.CompilerToVM.lookupConstantInPool} method\n+ *\/\n+public class LookupConstantInPoolTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        Map<ConstantTypes, Validator> typeTests = new HashMap<>();\n+        typeTests.put(CONSTANT_STRING, LookupConstantInPoolTest::validateString);\n+        typeTests.put(CONSTANT_METHODHANDLE, LookupConstantInPoolTest::validateMethodHandle);\n+        typeTests.put(CONSTANT_METHODTYPE, LookupConstantInPoolTest::validateMethodType);\n+        ConstantPoolTestCase testCase = new ConstantPoolTestCase(typeTests);\n+        testCase.test();\n+        \/\/ The next \"Class.forName\" and repeating \"testCase.test()\"\n+        \/\/ are here for the following reason.\n+        \/\/ The first test run is without dummy class initialization,\n+        \/\/ which means no constant pool cache exists.\n+        \/\/ The second run is with initialized class (with constant pool cache available).\n+        \/\/ Some CompilerToVM methods require different input\n+        \/\/ depending on whether CP cache exists or not.\n+        for (DummyClasses dummy : DummyClasses.values()) {\n+            Class.forName(dummy.klass.getName());\n+        }\n+        testCase.test();\n+    }\n+\n+    private static void validateString(ConstantPool constantPoolCTVM,\n+                                       ConstantTypes cpType,\n+                                       DummyClasses dummyClass,\n+                                       int cpi) {\n+        TestedCPEntry entry = cpType.getTestedCPEntry(dummyClass, cpi);\n+        if (entry == null) {\n+            return;\n+        }\n+        int index = cpi;\n+        String cached = \"\";\n+        int cpci = dummyClass.getCPCacheIndex(cpi);\n+        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n+            index = cpci;\n+            cached = \"cached \";\n+        }\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String stringToVerify = (String) constantInPool;\n+        String stringToRefer = entry.name;\n+        if (stringToRefer.equals(\"\") && cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n+            stringToRefer = null; \/\/ tested method returns null for cached empty strings\n+        }\n+        String msg = String.format(\"Wrong string accessed by %sconstant pool index %d\", cached, index);\n+        Asserts.assertEQ(stringToRefer, stringToVerify, msg);\n+    }\n+\n+    private static final String NOT_NULL_MSG\n+            = \"Object returned by lookupConstantInPool method should not be null\";\n+\n+\n+    private static void validateMethodHandle(ConstantPool constantPoolCTVM,\n+                                             ConstantTypes cpType,\n+                                             DummyClasses dummyClass,\n+                                             int index) {\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n+        Asserts.assertNotNull(constantInPool, msg);\n+        if (!(constantInPool instanceof MethodHandle)) {\n+            msg = String.format(\"Wrong constant pool entry accessed by index\"\n+                                        + \" %d: %s, but should be subclass of %s\",\n+                                index,\n+                                constantInPool.getClass(),\n+                                MethodHandle.class.getName());\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    private static void validateMethodType(ConstantPool constantPoolCTVM,\n+                                           ConstantTypes cpType,\n+                                           DummyClasses dummyClass,\n+                                           int index) {\n+        Object constantInPool = CompilerToVMHelper.lookupConstantInPool(constantPoolCTVM, index, true);\n+        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n+        Asserts.assertNotNull(constantInPool, msg);\n+        Class mtToVerify = constantInPool.getClass();\n+        Class mtToRefer = MethodType.class;\n+        msg = String.format(\"Wrong method type class accessed by\"\n+                                    + \" constant pool index %d\",\n+                            index);\n+        Asserts.assertEQ(mtToRefer, mtToVerify, msg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupConstantInPoolTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8138708\n- * @bug 8136421\n- * @requires vm.jvmci\n- * @library \/test\/lib \/\n- * @library ..\/common\/patches\n- * @modules java.base\/jdk.internal.access\n- *          java.base\/jdk.internal.reflect\n- *          java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.org.objectweb.asm.tree\n- *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n- *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n- *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n- *\n- * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n- *                   -XX:-UseJVMCICompiler\n- *                   compiler.jvmci.compilerToVM.ResolvePossiblyCachedConstantInPoolTest\n- *\/\n-\n-package compiler.jvmci.compilerToVM;\n-\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.TestedCPEntry;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestCase.Validator;\n-import compiler.jvmci.compilerToVM.ConstantPoolTestsHelper.DummyClasses;\n-import jdk.test.lib.Asserts;\n-import jdk.vm.ci.hotspot.CompilerToVMHelper;\n-import jdk.vm.ci.meta.ConstantPool;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODHANDLE;\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODTYPE;\n-import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_STRING;\n-\n-\/**\n- * Test for {@code jdk.vm.ci.hotspot.CompilerToVM.resolvePossiblyCachedConstantInPool} method\n- *\/\n-public class ResolvePossiblyCachedConstantInPoolTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        Map<ConstantTypes, Validator> typeTests = new HashMap<>();\n-        typeTests.put(CONSTANT_STRING, ResolvePossiblyCachedConstantInPoolTest::validateString);\n-        typeTests.put(CONSTANT_METHODHANDLE, ResolvePossiblyCachedConstantInPoolTest::validateMethodHandle);\n-        typeTests.put(CONSTANT_METHODTYPE, ResolvePossiblyCachedConstantInPoolTest::validateMethodType);\n-        ConstantPoolTestCase testCase = new ConstantPoolTestCase(typeTests);\n-        testCase.test();\n-        \/\/ The next \"Class.forName\" and repeating \"testCase.test()\"\n-        \/\/ are here for the following reason.\n-        \/\/ The first test run is without dummy class initialization,\n-        \/\/ which means no constant pool cache exists.\n-        \/\/ The second run is with initialized class (with constant pool cache available).\n-        \/\/ Some CompilerToVM methods require different input\n-        \/\/ depending on whether CP cache exists or not.\n-        for (DummyClasses dummy : DummyClasses.values()) {\n-            Class.forName(dummy.klass.getName());\n-        }\n-        testCase.test();\n-    }\n-\n-    private static void validateString(ConstantPool constantPoolCTVM,\n-                                       ConstantTypes cpType,\n-                                       DummyClasses dummyClass,\n-                                       int cpi) {\n-        TestedCPEntry entry = cpType.getTestedCPEntry(dummyClass, cpi);\n-        if (entry == null) {\n-            return;\n-        }\n-        int index = cpi;\n-        String cached = \"\";\n-        int cpci = dummyClass.getCPCacheIndex(cpi);\n-        if (cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            index = cpci;\n-            cached = \"cached \";\n-        }\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String stringToVerify = (String) constantInPool;\n-        String stringToRefer = entry.name;\n-        if (stringToRefer.equals(\"\") && cpci != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT) {\n-            stringToRefer = null; \/\/ tested method returns null for cached empty strings\n-        }\n-        String msg = String.format(\"Wrong string accessed by %sconstant pool index %d\", cached, index);\n-        Asserts.assertEQ(stringToRefer, stringToVerify, msg);\n-    }\n-\n-    private static final String NOT_NULL_MSG\n-            = \"Object returned by resolvePossiblyCachedConstantInPool method should not be null\";\n-\n-\n-    private static void validateMethodHandle(ConstantPool constantPoolCTVM,\n-                                             ConstantTypes cpType,\n-                                             DummyClasses dummyClass,\n-                                             int index) {\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n-        Asserts.assertNotNull(constantInPool, msg);\n-        if (!(constantInPool instanceof MethodHandle)) {\n-            msg = String.format(\"Wrong constant pool entry accessed by index\"\n-                                        + \" %d: %s, but should be subclass of %s\",\n-                                index,\n-                                constantInPool.getClass(),\n-                                MethodHandle.class.getName());\n-            throw new AssertionError(msg);\n-        }\n-    }\n-\n-    private static void validateMethodType(ConstantPool constantPoolCTVM,\n-                                           ConstantTypes cpType,\n-                                           DummyClasses dummyClass,\n-                                           int index) {\n-        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);\n-        String msg = String.format(\"%s for index %d\", NOT_NULL_MSG, index);\n-        Asserts.assertNotNull(constantInPool, msg);\n-        Class mtToVerify = constantInPool.getClass();\n-        Class mtToRefer = MethodType.class;\n-        msg = String.format(\"Wrong method type class accessed by\"\n-                                    + \" constant pool index %d\",\n-                            index);\n-        Asserts.assertEQ(mtToRefer, mtToVerify, msg);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ResolvePossiblyCachedConstantInPoolTest.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -269,2 +269,16 @@\n-                    if (tag.equals(\"Dynamic\")) {\n-                        lastConstant = cp.lookupConstant(cpi);\n+                    switch (tag) {\n+                        case \"MethodHandle\":\n+                        case \"MethodType\":\n+                        case \"Dynamic\": {\n+                            Object con = cp.lookupConstant(cpi, false);\n+                            Assert.assertNull(con, \"Unexpected eager resolution\");\n+\n+                            con = cp.lookupConstant(cpi, true);\n+                            Assert.assertNotNull(con, \"Eager resolution failed\");\n+\n+                            if (tag.equals(\"Dynamic\")) {\n+                                lastConstant = cp.lookupConstant(cpi);\n+                                Assert.assertEquals(con, lastConstant);\n+                            }\n+                            break;\n+                        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}