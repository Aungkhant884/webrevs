{"files":[{"patch":"@@ -398,4 +398,6 @@\n-      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\\n\"\n-                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\",\n-                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->flag(),\n-                    p2i(base_addr), p2i(base_addr + size), (unsigned)flag);\n+      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag \\'%s\\'.\\n\"\n+                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag \\'%s\\'.\",\n+                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()),\n+                    reserved_rgn->flag_name(),\n+                    p2i(base_addr), p2i(base_addr + size),\n+                    NMTUtil::flag_to_name(flag));\n@@ -418,1 +420,1 @@\n-      assert(reserved_rgn->flag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\\"%s\\\")\",\n+      assert(reserved_rgn->flag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\'%s\\')\",\n@@ -526,1 +528,1 @@\n-  if (size <= reserved_rgn->size()) {\n+  if (size <= reserved_rgn->size() && reserved_rgn->contain_region(addr, size)) {\n@@ -529,2 +531,1 @@\n-    if (reserved_rgn->base() == addr ||\n-        reserved_rgn->end() == addr + size) {\n+    if (reserved_rgn->base() == addr || reserved_rgn->end() == addr + size) {\n@@ -539,1 +540,1 @@\n-      \/\/ use original region for lower region\n+      \/\/ Use original region for lower region\n@@ -553,0 +554,1 @@\n+    \/\/ Segment the region into stripes to be further processed recursively\n@@ -555,1 +557,1 @@\n-      assert(remove_rgn!=nullptr, \"NULL region\");\n+      assert(remove_rgn != nullptr, \"NULL region\");\n@@ -558,1 +560,13 @@\n-      assert(remove_rgn->base()<node_rgn->data()->base(), \"not ascending bases\");\n+      assert(remove_rgn->base() < node_rgn->data()->base(), \"not ascending bases\");\n+\n+      \/\/ Allow for the segment to be partially released\n+      long offset = remove_rgn->base() - addr;\n+      long remove_size = 0;\n+      if (offset < 0) {\n+        remove_size = MIN(remove_rgn->size()+offset, remaining);\n+      } else {\n+        remove_size = MIN(remove_rgn->size(), remaining);\n+      }\n+      assert(remove_size > 0, \"negative size\");\n+      assert(addr+remove_size <= end, \"not contained\");\n+      remove_released_region(addr, remove_size);\n@@ -560,4 +574,0 @@\n-      \/\/ Allow for the last segment to be partially released\n-      size_t remove_size = MIN(remove_rgn->size(), remaining);\n-      assert(remove_rgn->base()+remove_size<=end, \"not contained\");\n-      assert(remove_released_region(remove_rgn->base(), remove_size), \"error in remove_released_region\");\n@@ -565,0 +575,1 @@\n+      addr += remove_size;\n@@ -568,0 +579,1 @@\n+  return false;\n@@ -701,1 +713,1 @@\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag \\'%s\\'\",\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -459,1 +459,0 @@\n-TEST_VM(os, release_multi_mappings) {\n@@ -461,1 +460,5 @@\n-  \/\/ Test that we can release an area created with multiple reservation calls\n+static void test_release(double start_left, double length_left,\n+                         double start_right, double length_right) {\n+\n+  \/\/ Test that we can release a contigous area created with multiple reservation calls\n+  \/\/\n@@ -463,1 +466,1 @@\n-  \/\/ A) we reserve 6 small segments (stripes) adjacent to each other. We commit\n+  \/\/ A) we reserve 4 segments (stripes) adjacent to each other. We commit\n@@ -466,2 +469,1 @@\n-  \/\/    -stripe-stripe-stripe-stripe-stripe-stripe-\n-  \/\/ B) we release the middle four stripes with a single os::release_memory call. This\n+  \/\/ B) we release the inside stripe(s) with a single os::release_memory call. This\n@@ -470,2 +472,1 @@\n-  \/\/    -stripe-___________________________-stripe-\n-  \/\/ C) Into the now vacated address range between the first and the last stripe, we\n+  \/\/ C) into the now vacated address range between the first and the last stripe, we\n@@ -474,0 +475,1 @@\n+  \/\/ D) we cleanup and release all memory in one go\n@@ -480,2 +482,5 @@\n-  const size_t stripe_len = os::vm_allocation_granularity();\n-  const int num_stripes = 6;\n+  ASSERT_TRUE(start_left + length_left <= 1.0);\n+  ASSERT_TRUE(start_right + length_right <= 1.0);\n+\n+  const size_t stripe_len = 1 * M;\n+  const size_t num_stripes = 4;\n@@ -491,1 +496,9 @@\n-  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n+  size_t len_middle_stripes = 0;\n+  if (length_left > 0.0) {\n+    p_middle_stripes += (size_t)(start_left * stripe_len);\n+    len_middle_stripes = (size_t)(length_left * stripe_len) + (size_t)(length_right * stripe_len);\n+  } else {\n+    p_middle_stripes += (size_t)(stripe_len + (start_right * stripe_len));\n+    len_middle_stripes = (size_t)(length_right * stripe_len);\n+  }\n+\n@@ -496,1 +509,1 @@\n-    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n+    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, len_middle_stripes));\n@@ -501,1 +514,1 @@\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, len_middle_stripes);\n@@ -505,0 +518,5 @@\n+  \/\/ Use memory to make sure it's available\n+  int success = os::commit_memory((char*)p_middle_stripes, len_middle_stripes, false);\n+  ASSERT_TRUE(success);\n+  memset((char*)p_middle_stripes, 0b1, len_middle_stripes);\n+\n@@ -510,0 +528,1 @@\n+  PRINT_MAPPINGS(\"D\");\n@@ -511,1 +530,0 @@\n-#endif \/\/ !AIX\n@@ -513,2 +531,1 @@\n-#ifndef _AIX \/\/ JDK-8257041\n-TEST_VM(os, partial_release_multi_mappings) {\n+\/\/ test_release(start_left, length_left, start_right, length_right)\n@@ -516,1 +533,7 @@\n-  \/\/  see \"release_multi_mappings\" test comment for general explanation\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xx..][....][....]\n+\/\/ C reserve [....][xx..][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case1) {\n+  test_release(0.00, 0.50, 0.00, 0.00);\n+}\n@@ -518,1 +541,7 @@\n-  \/\/  thread grabbing that memory.\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][.xx.][....][....]\n+\/\/ C reserve [....][.xx.][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case2) {\n+  test_release(0.25, 0.50, 0.00, 0.00);\n+}\n@@ -520,4 +549,7 @@\n-  const size_t stripe_len = os::vm_allocation_granularity();\n-  const int num_stripes = 4;\n-  const size_t total_range_len = stripe_len * num_stripes;\n-  const size_t partial_release_len = total_range_len - (stripe_len\/2); \/\/ partially release the last stripe\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][....][....]\n+\/\/ C reserve [....][..xx][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case3) {\n+  test_release(0.50, 0.50, 0.00, 0.00);\n+}\n@@ -525,4 +557,7 @@\n-  \/\/ reserve address space...\n-  address p = reserve_multiple(num_stripes, stripe_len);\n-  ASSERT_NE(p, (address)NULL);\n-  PRINT_MAPPINGS(\"A\");\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xxxx][xxxx][....]\n+\/\/ C reserve [....][xxxx][xxxx][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case1) {\n+  test_release(0.00, 1.00, 0.00, 1.00);\n+}\n@@ -530,10 +565,7 @@\n-  \/\/ .. release the middle stripe...\n-  address p_middle_stripes = p + stripe_len;\n-  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n-  {\n-    \/\/ On Windows, temporarily switch on UseNUMAInterleaving to allow release_memory to release\n-    \/\/  multiple mappings in one go (otherwise we assert, which we test too, see death test below).\n-    WINDOWS_ONLY(NUMASwitcher b(true);)\n-    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n-  }\n-  PRINT_MAPPINGS(\"B\");\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xxxx][xx..][....]\n+\/\/ C reserve [....][xxxx][xx..][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case2) {\n+  test_release(0.00, 1.00, 0.00, 0.50);\n+}\n@@ -541,4 +573,7 @@\n-  \/\/ ...re-reserve the middle stripes. This should work unless release silently failed.\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n-  ASSERT_EQ(p2, p_middle_stripes);\n-  PRINT_MAPPINGS(\"C\");\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][xxxx][....]\n+\/\/ C reserve [....][..xx][xxxx][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case3) {\n+  test_release(0.50, 0.50, 0.00, 1.00);\n+}\n@@ -546,5 +581,6 @@\n-  \/\/ Clean up. Release all mappings except a 1\/2 stripe sized portion at the very end.\n-  {\n-    WINDOWS_ONLY(NUMASwitcher b(true);) \/\/ allow release_memory to release multiple regions\n-    ASSERT_TRUE(os::release_memory((char*)p, partial_release_len));\n-  }\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][xx..][....]\n+\/\/ C reserve [....][..xx][xx..][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case4) {\n+  test_release(0.50, 0.50, 0.00, 0.50);\n@@ -552,0 +588,1 @@\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":81,"deletions":44,"binary":false,"changes":125,"status":"modified"}]}