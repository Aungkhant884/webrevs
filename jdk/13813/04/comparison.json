{"files":[{"patch":"@@ -398,4 +398,6 @@\n-      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\\n\"\n-                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag %u.\",\n-                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->flag(),\n-                    p2i(base_addr), p2i(base_addr + size), (unsigned)flag);\n+      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag \\'%s\\'.\\n\"\n+                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), flag \\'%s\\'.\",\n+                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()),\n+                    reserved_rgn->flag_name(),\n+                    p2i(base_addr), p2i(base_addr + size),\n+                    NMTUtil::flag_to_name(flag));\n@@ -418,1 +420,1 @@\n-      assert(reserved_rgn->flag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\\"%s\\\")\",\n+      assert(reserved_rgn->flag() == mtNone, \"Overwrite memory type (should be mtNone, is: \\'%s\\')\",\n@@ -526,5 +528,4 @@\n-  VirtualMemorySummary::record_released_memory(size, reserved_rgn->flag());\n-\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  if (reserved_rgn->base() == addr ||\n-      reserved_rgn->end() == addr + size) {\n+  if (size <= reserved_rgn->size() && reserved_rgn->contain_region(addr, size)) {\n+    VirtualMemorySummary::record_released_memory(size, reserved_rgn->flag());\n+    assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n+    if (reserved_rgn->base() == addr || reserved_rgn->end() == addr + size) {\n@@ -532,1 +533,17 @@\n-    return true;\n+      return true;\n+    } else {\n+      address top = reserved_rgn->end();\n+      address high_base = addr + size;\n+      ReservedMemoryRegion high_rgn(high_base, top - high_base,\n+                                    *reserved_rgn->call_stack(), reserved_rgn->flag());\n+\n+      \/\/ Use original region for lower region\n+      reserved_rgn->exclude_region(addr, top - addr);\n+      LinkedListNode<ReservedMemoryRegion>* new_rgn = _reserved_regions->add(high_rgn);\n+      if (new_rgn == nullptr) {\n+        return false;\n+      } else {\n+        reserved_rgn->move_committed_regions(addr, *new_rgn->data());\n+        return true;\n+      }\n+    }\n@@ -534,4 +551,21 @@\n-    address top = reserved_rgn->end();\n-    address high_base = addr + size;\n-    ReservedMemoryRegion high_rgn(high_base, top - high_base,\n-      *reserved_rgn->call_stack(), reserved_rgn->flag());\n+    address end = addr+size;\n+    size_t remaining = size;\n+    LinkedListNode<ReservedMemoryRegion>* node_rgn = _reserved_regions->find_node(rgn);\n+    \/\/ Segment the region into stripes to be further processed recursively\n+    while (remaining > 0) {\n+      ReservedMemoryRegion* remove_rgn = node_rgn->data();\n+      assert(remove_rgn != nullptr, \"NULL region\");\n+\n+      node_rgn = node_rgn->next();\n+      assert(remove_rgn->base() < node_rgn->data()->base(), \"not ascending bases\");\n+\n+      \/\/ Allow for the segment to be partially released\n+      long remove_size = 0;\n+      if (addr > remove_rgn->base()) {\n+        remove_size = MIN(remove_rgn->size()-pointer_delta(addr, remove_rgn->base(), 1), remaining);\n+      } else {\n+        remove_size = MIN(remove_rgn->size(), remaining);\n+      }\n+      assert(remove_size > 0, \"negative size\");\n+      assert(addr+remove_size <= end, \"not contained\");\n+      remove_released_region(addr, remove_size);\n@@ -539,8 +573,2 @@\n-    \/\/ use original region for lower region\n-    reserved_rgn->exclude_region(addr, top - addr);\n-    LinkedListNode<ReservedMemoryRegion>* new_rgn = _reserved_regions->add(high_rgn);\n-    if (new_rgn == nullptr) {\n-      return false;\n-    } else {\n-      reserved_rgn->move_committed_regions(addr, *new_rgn->data());\n-      return true;\n+      remaining -= remove_size;\n+      addr += remove_size;\n@@ -548,0 +576,1 @@\n+    return true;\n@@ -549,0 +578,1 @@\n+  return false;\n@@ -682,1 +712,1 @@\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag \\'%s\\'\",\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":54,"deletions":24,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -459,1 +459,0 @@\n-TEST_VM(os, release_multi_mappings) {\n@@ -461,4 +460,2 @@\n-  \/\/ With NMT enabled, this will trigger JDK-8263464. For now disable the test if NMT=on.\n-  if (MemTracker::tracking_level() > NMT_off) {\n-    return;\n-  }\n+static void test_release(double start_left, double length_left,\n+                         double start_right, double length_right) {\n@@ -466,1 +463,2 @@\n-  \/\/ Test that we can release an area created with multiple reservation calls\n+  \/\/ Test that we can release a contigous area created with multiple reservation calls\n+  \/\/\n@@ -468,1 +466,1 @@\n-  \/\/ A) we reserve 6 small segments (stripes) adjacent to each other. We commit\n+  \/\/ A) we reserve 4 segments (stripes) adjacent to each other. We commit\n@@ -471,2 +469,1 @@\n-  \/\/    -stripe-stripe-stripe-stripe-stripe-stripe-\n-  \/\/ B) we release the middle four stripes with a single os::release_memory call. This\n+  \/\/ B) we release the inside stripe(s) with a single os::release_memory call. This\n@@ -475,2 +472,1 @@\n-  \/\/    -stripe-___________________________-stripe-\n-  \/\/ C) Into the now vacated address range between the first and the last stripe, we\n+  \/\/ C) into the now vacated address range between the first and the last stripe, we\n@@ -479,0 +475,1 @@\n+  \/\/ D) we cleanup and release all memory in one go\n@@ -485,2 +482,5 @@\n-  const size_t stripe_len = os::vm_allocation_granularity();\n-  const int num_stripes = 6;\n+  ASSERT_TRUE(start_left + length_left <= 1.0);\n+  ASSERT_TRUE(start_right + length_right <= 1.0);\n+\n+  const size_t stripe_len = 1 * M;\n+  const size_t num_stripes = 4;\n@@ -496,1 +496,9 @@\n-  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n+  size_t len_middle_stripes = 0;\n+  if (length_left > 0.0) {\n+    p_middle_stripes += (size_t)(start_left * stripe_len);\n+    len_middle_stripes = (size_t)(length_left * stripe_len) + (size_t)(length_right * stripe_len);\n+  } else {\n+    p_middle_stripes += (size_t)(stripe_len + (start_right * stripe_len));\n+    len_middle_stripes = (size_t)(length_right * stripe_len);\n+  }\n+\n@@ -501,1 +509,1 @@\n-    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n+    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, len_middle_stripes));\n@@ -506,1 +514,1 @@\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, len_middle_stripes);\n@@ -510,0 +518,5 @@\n+  \/\/ Use memory to make sure it's available\n+  int success = os::commit_memory((char*)p_middle_stripes, len_middle_stripes, false);\n+  ASSERT_TRUE(success);\n+  memset((char*)p_middle_stripes, 0b1, len_middle_stripes);\n+\n@@ -515,0 +528,19 @@\n+  PRINT_MAPPINGS(\"D\");\n+}\n+\n+\/\/ test_release(start_left, length_left, start_right, length_right)\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xx..][....][....]\n+\/\/ C reserve [....][xx..][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case1) {\n+  test_release(0.00, 0.50, 0.00, 0.00);\n+}\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][.xx.][....][....]\n+\/\/ C reserve [....][.xx.][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case2) {\n+  test_release(0.25, 0.50, 0.00, 0.00);\n@@ -516,0 +548,41 @@\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][....][....]\n+\/\/ C reserve [....][..xx][....][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_single_region_case3) {\n+  test_release(0.50, 0.50, 0.00, 0.00);\n+}\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xxxx][xxxx][....]\n+\/\/ C reserve [....][xxxx][xxxx][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case1) {\n+  test_release(0.00, 1.00, 0.00, 1.00);\n+}\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][xxxx][xx..][....]\n+\/\/ C reserve [....][xxxx][xx..][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case2) {\n+  test_release(0.00, 1.00, 0.00, 0.50);\n+}\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][xxxx][....]\n+\/\/ C reserve [....][..xx][xxxx][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case3) {\n+  test_release(0.50, 0.50, 0.00, 1.00);\n+}\n+\n+\/\/ A reserve [aaaa][bbbb][cccc][dddd]\n+\/\/ B release [....][..xx][xx..][....]\n+\/\/ C reserve [....][..xx][xx..][....]\n+\/\/ D release [xxxx][xxxx][xxxx][xxxx]\n+TEST_VM(os, release_multi_mappings_partial_multi_regions_case4) {\n+  test_release(0.50, 0.50, 0.00, 0.50);\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":89,"deletions":16,"binary":false,"changes":105,"status":"modified"}]}