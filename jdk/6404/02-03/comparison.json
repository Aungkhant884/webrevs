{"files":[{"patch":"@@ -35,1 +35,1 @@\n-import java.util.HashMap;\n+import java.util.Collections;\n@@ -37,1 +37,0 @@\n-import java.util.LinkedHashMap;\n@@ -70,1 +69,4 @@\n-    private final Map<Predicate<JavaFileObject>, Map<Method, BiFunction<JavaFileObject, Object[], Throwable>>> fileObjectHandlers;\n+\n+    private record FileObjectHandlers(Predicate<JavaFileObject> filter,\n+                                      Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) { }\n+    private final List<FileObjectHandlers> fileObjectHandlers;\n@@ -74,2 +76,2 @@\n-        fileManagerHandlers = new LinkedHashMap<>();\n-        fileObjectHandlers = new LinkedHashMap<>();\n+        fileManagerHandlers = Collections.emptyMap();\n+        fileObjectHandlers = new ArrayList<>();\n@@ -79,1 +81,1 @@\n-     * Provides a function to be called when a given file manager method is called.\n+     * Provides functions to be called when given file manager methods are called.\n@@ -83,1 +85,1 @@\n-     * It is an error for the function to return a checked exception that is not\n+     * It is an error for any function to return a checked exception that is not\n@@ -87,2 +89,1 @@\n-     * @param method  the method for which to invoke the handler\n-     * @param handler the handler\n+     * @param handlers  a map giving the function to be called before a file manager method is invoked\n@@ -91,2 +92,1 @@\n-     * @throws IllegalArgumentException if the method is not declared in {@code JavaFileManager}\n-     * @throws IllegalStateException if a handler is already registered for this method\n+     * @throws IllegalArgumentException if any key in the map is a method that is not declared in {@code JavaFileManager}\n@@ -94,5 +94,6 @@\n-    public TestJavaFileManagerBuilder handle(Method method,\n-                                             BiFunction<JavaFileManager, Object[], Throwable> handler) {\n-        if (!JavaFileManager.class.isAssignableFrom(method.getDeclaringClass())) {\n-            throw new IllegalArgumentException((\"not a method on JavaFileManager: \" + method));\n-        }\n+    public TestJavaFileManagerBuilder handle(Map<Method, BiFunction<JavaFileManager, Object[], Throwable>> handlers) {\n+        handlers.forEach((m, h) -> {\n+            if (!JavaFileManager.class.isAssignableFrom(m.getDeclaringClass())) {\n+                throw new IllegalArgumentException((\"not a method on JavaFileManager: \" + m));\n+            }\n+        });\n@@ -100,4 +101,1 @@\n-        var prev = fileManagerHandlers.put(method, handler);\n-        if (prev != null) {\n-            throw new IllegalStateException(\"handler already registered for method \" + method);\n-        }\n+        fileManagerHandlers = handlers;\n@@ -108,1 +106,1 @@\n-     * Provides a function to be called when a given file object method is called,\n+     * Provides functions to be called when given file object methods are called,\n@@ -117,0 +115,4 @@\n+     * When subsequently finding the handlers to be used for a particular file object, the various\n+     * predicates passed to this method will be tested in the order that they were registered.\n+     * The handlers associated with the first matching predicate will be used.\n+     *\n@@ -125,3 +127,2 @@\n-     * @param filter  the predicate used to identify file objects for this handler\n-     * @param method  the method for which to invoke the handler\n-     * @param handler the handler\n+     * @param filter    the predicate used to identify file objects for which the handlers are applicable\n+     * @param handlers  a map giving the function to be called before a file object method is invoked\n@@ -132,1 +133,0 @@\n-     * @throws IllegalStateException if a handler is already registered for this predicate and method\n@@ -135,5 +135,6 @@\n-                                             Method method,\n-                                             BiFunction<JavaFileObject, Object[], Throwable> handler) {\n-        if (!FileObject.class.isAssignableFrom(method.getDeclaringClass())) {\n-            throw new IllegalArgumentException((\"not a method on FileObject: \" + method));\n-        }\n+                                             Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) {\n+        handlers.forEach((m, h) -> {\n+            if (!FileObject.class.isAssignableFrom(m.getDeclaringClass())) {\n+                throw new IllegalArgumentException((\"not a method on FileObject: \" + m));\n+            }\n+        });\n@@ -141,5 +142,1 @@\n-        var map = fileObjectHandlers.computeIfAbsent(filter, p_ -> new HashMap<>());\n-        var prev = map.put(method, handler);\n-        if (prev != null) {\n-            throw new IllegalStateException(\"handler already registered for '\" + filter + \"' method \" + method);\n-        }\n+        fileObjectHandlers.add(new FileObjectHandlers(filter, handlers));\n@@ -204,2 +201,2 @@\n-            return fileObjectHandlers.entrySet().stream()\n-                    .filter(e -> e.getKey().test(jfo))\n+            return fileObjectHandlers.stream()\n+                    .filter(e -> e.filter().test(jfo))\n@@ -207,1 +204,1 @@\n-                    .map(e -> cache.computeIfAbsent(jfo, jfo_ -> createProxyFileObject(jfo_, e.getValue())))\n+                    .map(e -> cache.computeIfAbsent(jfo, jfo_ -> createProxyFileObject(jfo_, e.handlers())))\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/TestJavaFileManagerBuilder.java","additions":35,"deletions":38,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.Map;\n@@ -108,2 +109,2 @@\n-                            JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n-                            (fo, args) -> new TestException(fo.getName()))\n+                            Map.of(JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n+                                (fo, args) -> new TestException(fo.getName())))\n@@ -152,7 +153,7 @@\n-                    .handle(getFileForInput_method,\n-                            (fm_, args) -> {\n-                                var relativeName = (String) args[2];\n-                                return (relativeName.endsWith(\"C.properties\"))\n-                                    ? new TestException(\"getFileForInput: \" + Arrays.asList(args))\n-                                    :  null;\n-                            })\n+                    .handle(Map.of(getFileForInput_method,\n+                                (fm_, args) -> {\n+                                    var relativeName = (String) args[2];\n+                                    return (relativeName.endsWith(\"C.properties\"))\n+                                            ? new TestException(\"getFileForInput: \" + Arrays.asList(args))\n+                                            : null;\n+                                }))\n@@ -186,2 +187,2 @@\n-                            JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n-                            (fo, args) -> new TestException(fo.getName()))\n+                            Map.of(JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n+                                (fo, args) -> new TestException(fo.getName())))\n@@ -218,2 +219,2 @@\n-                            JavaFileObject.class.getMethod(\"openOutputStream\"),\n-                            (fo, args) -> new TestException(fo.getName()))\n+                            Map.of(JavaFileObject.class.getMethod(\"openOutputStream\"),\n+                                (fo, args) -> new TestException(fo.getName())))\n","filename":"test\/langtools\/jdk\/javadoc\/testTFMBuilder\/TestTFMBuilder.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"}]}