{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import javax.tools.JavaFileManager;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.UndeclaredThrowableException;\n@@ -43,2 +45,4 @@\n- * A builder to create \"test file managers\" that can return \"test file objects\"\n- * that can call user-provided functions in place of the normal methods for the file object.\n+ * A builder to create \"test file managers\" that can return \"test file objects\".\n+ * All such objects can throw user-provided exceptions when specified methods\n+ * are called. This is done by registering \"handlers\" to be associated with individual\n+ * methods.\n@@ -47,5 +51,1 @@\n- * on the file object. For these file objects, functions can be specified that are called\n- * in place of individual methods on the file object.\n- *\n- * A common use case is to throw an exception when a specific method is called on a\n- * given file object, that might otherwise be difficult to cause to occur.\n+ * on the file object.\n@@ -58,1 +58,1 @@\n- * file manager will not use the replacement functions.\n+ * file manager will not throw any user-provided exceptions.\n@@ -60,2 +60,2 @@\n- * For now, the functions are simply grouped by predicate and then by method,\n- * and the group of methods used for a \"test file object\" is determined by the\n+ * For now, the handlers for a file object are simply grouped by predicate and then by\n+ * method, and the group of methods used for a \"test file object\" is determined by the\n@@ -63,1 +63,1 @@\n- * An alternative, more expensive, implementation would be to group the functions\n+ * An alternative, more expensive, implementation would be to group the handlers\n@@ -69,1 +69,2 @@\n-    private final Map<Predicate<JavaFileObject>, Map<Method, BiFunction<Object, Object[], Object>>> handlers;\n+    private Map<Method, BiFunction<JavaFileManager, Object[], Throwable>> fileManagerHandlers;\n+    private final Map<Predicate<JavaFileObject>, Map<Method, BiFunction<JavaFileObject, Object[], Throwable>>> fileObjectHandlers;\n@@ -73,1 +74,2 @@\n-        handlers = new LinkedHashMap<>();\n+        fileManagerHandlers = new LinkedHashMap<>();\n+        fileObjectHandlers = new LinkedHashMap<>();\n@@ -77,1 +79,37 @@\n-     * Provides a function to handle a given method on file objects that match a given predicate.\n+     * Provides a function to be called when a given file manager method is called.\n+     * The function should either return an exception to be thrown, or {@code null}\n+     * to indicate that no exception should be thrown.\n+     *\n+     * It is an error for the function to return a checked exception that is not\n+     * declared by the method. This error will result in {@link UndeclaredThrowableException}\n+     * being thrown when the method is called.\n+     *\n+     * @param method  the method for which to invoke the handler\n+     * @param handler the handler\n+     *\n+     * @return this object\n+     * @throws IllegalArgumentException if the method is not declared in {@code JavaFileManager}\n+     * @throws IllegalStateException if a handler is already registered for this method\n+     *\/\n+    public TestJavaFileManagerBuilder handle(Method method,\n+                                             BiFunction<JavaFileManager, Object[], Throwable> handler) {\n+        if (!JavaFileManager.class.isAssignableFrom(method.getDeclaringClass())) {\n+            throw new IllegalArgumentException((\"not a method on JavaFileManager: \" + method));\n+        }\n+\n+        var prev = fileManagerHandlers.put(method, handler);\n+        if (prev != null) {\n+            throw new IllegalStateException(\"handler already registered for method \" + method);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Provides a function to be called when a given file object method is called,\n+     * for file objects that match a given predicate.\n+     * The function should either return an exception to be thrown, or {@code null}\n+     * to indicate that no exception should be thrown.\n+     *\n+     * It is an error for the function to return a checked exception that is not\n+     * declared by the method. This error will result in {@link UndeclaredThrowableException}\n+     * being thrown when the method is called.\n@@ -92,0 +130,2 @@\n+     * @throws IllegalArgumentException if the method is not declared in a class that is assignable\n+     *          to {@code FileObject}\n@@ -94,2 +134,8 @@\n-    public TestJavaFileManagerBuilder handle(Predicate<JavaFileObject> filter, Method method, BiFunction<Object, Object[], Object> handler) {\n-        var map = handlers.computeIfAbsent(filter, p_ -> new HashMap<>());\n+    public TestJavaFileManagerBuilder handle(Predicate<JavaFileObject> filter,\n+                                             Method method,\n+                                             BiFunction<JavaFileObject, Object[], Throwable> handler) {\n+        if (!FileObject.class.isAssignableFrom(method.getDeclaringClass())) {\n+            throw new IllegalArgumentException((\"not a method on FileObject: \" + method));\n+        }\n+\n+        var map = fileObjectHandlers.computeIfAbsent(filter, p_ -> new HashMap<>());\n@@ -122,1 +168,1 @@\n-            Object result = method.invoke(fm, unwrap(args));\n+            Object result = handleMethod(fm, method, unwrap(args));\n@@ -130,0 +176,2 @@\n+                \/\/ Note 1: this assumes that no methods return a mixture of FileObject and JavaFileObject.\n+                \/\/ Note 2: all file objects returned by the standard file manager are instances of javaFileObject\n@@ -156,1 +204,1 @@\n-            return handlers.entrySet().stream()\n+            return fileObjectHandlers.entrySet().stream()\n@@ -173,1 +221,1 @@\n-                                                     Map<Method, BiFunction<Object, Object[], Object>> handlers) {\n+                                                     Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) {\n@@ -218,0 +266,12 @@\n+\n+        private Object handleMethod(JavaFileManager fm, Method method, Object[] args) throws Throwable {\n+            var handler = fileManagerHandlers.get(method);\n+            if (handler != null) {\n+                Throwable t = handler.apply(fm, args);\n+                if (t != null) {\n+                    throw t;\n+                }\n+            }\n+\n+            return method.invoke(fm, args);\n+        }\n@@ -227,1 +287,1 @@\n-                                                    Map<Method, BiFunction<Object, Object[], Object>> handlers)\n+                                                    Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers)\n@@ -232,0 +292,4 @@\n+            return handleMethod(jfo, method, args);\n+        }\n+\n+        private Object handleMethod(JavaFileObject jfo, Method method, Object[] args) throws Throwable {\n@@ -234,3 +298,4 @@\n-                return handler.apply(jfo, args);\n-            } else {\n-                return method.invoke(jfo, args);\n+                Throwable t =  handler.apply(jfo, args);\n+                if (t != null) {\n+                    throw t;\n+                }\n@@ -238,0 +303,1 @@\n+            return method.invoke(jfo, args);\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/TestJavaFileManagerBuilder.java","additions":89,"deletions":23,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import javax.tools.JavaFileManager;\n@@ -41,0 +42,1 @@\n+import java.lang.reflect.Method;\n@@ -42,0 +44,1 @@\n+import java.util.Arrays;\n@@ -78,1 +81,1 @@\n-                \/** Dummy class, to be read by javadoc. *\/\n+                \/** Dummy class, to be read by javadoc. {@snippet file=\"C.properties\" } *\/\n@@ -82,0 +85,3 @@\n+        tb.writeFile(srcDir.resolve(\"p\").resolve(\"snippet-files\").resolve(\"C.properties\"), \"\"\"\n+                dummy content\n+                \"\"\");\n@@ -103,3 +109,1 @@\n-                            (fo, args) -> {\n-                                throw new TestException((JavaFileObject) fo);\n-                            })\n+                            (fo, args) -> new TestException(fo.getName()))\n@@ -141,1 +145,36 @@\n-    public void testFileManagerRead(Path base) throws Exception {\n+    public void testFileManagerAccess(Path base) throws Exception {\n+        try (StandardJavaFileManager fm = getFileManager()) {\n+\n+            \/\/ build a file manager that throws an exception when a specific source file is accessed\n+            Method getFileForInput_method = JavaFileManager.class.getMethod(\"getFileForInput\",\n+                    JavaFileManager.Location.class, String.class, String.class);\n+            StandardJavaFileManager tfm = new TestJavaFileManagerBuilder(fm)\n+                    .handle(getFileForInput_method,\n+                            (fm_, args) -> {\n+                                var relativeName = (String) args[2];\n+                                return (relativeName.endsWith(\"C.properties\"))\n+                                    ? new TestException(\"getFileForInput: \" + Arrays.asList(args))\n+                                    :  null;\n+                            })\n+                    .build();\n+\n+            try {\n+                setFileManager(tfm);\n+                javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                        \"-sourcepath\", srcDir.toString(),\n+                        \"p\");\n+                checkExit((Exit.ERROR)); \/\/ Ideally, this should be ABNORMAL, but right now, the doclet has no way to indicate that\n+                checkOutput(Output.OUT, true,\n+                        \"\"\"\n+                                error: An internal exception has occurred.\n+                                  \\t(##EXC##: getFileForInput: [SOURCE_PATH, p, snippet-files\/C.properties])\n+                                1 error\"\"\"\n+                                .replace(\"##EXC##\", TestException.class.getName()));\n+            } finally {\n+                setFileManager(null);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testFileObjectRead(Path base) throws Exception {\n@@ -148,3 +187,1 @@\n-                            (fo, args) -> {\n-                                throw new TestException((JavaFileObject) fo);\n-                            })\n+                            (fo, args) -> new TestException(fo.getName()))\n@@ -173,1 +210,1 @@\n-    public void testFileManagerWrite(Path base) throws Exception {\n+    public void testFileObjectWrite(Path base) throws Exception {\n@@ -182,3 +219,1 @@\n-                            (fo, args) -> {\n-                                throw new TestException((JavaFileObject) fo);\n-                            })\n+                            (fo, args) -> new TestException(fo.getName()))\n","filename":"test\/langtools\/jdk\/javadoc\/testTFMBuilder\/TestTFMBuilder.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"}]}