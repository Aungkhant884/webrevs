{"files":[{"patch":"@@ -48,1 +48,1 @@\n-doclet.internal.exception=An internal exception has occurred. \\n\\\n+doclet.internal.exception=An internal exception has occurred.\\n\\\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardJavaFileManager;\n@@ -28,0 +30,3 @@\n+import java.util.Objects;\n+\n+import com.sun.tools.javac.util.Context;\n@@ -40,5 +45,0 @@\n-    \/**\n-     * This constructor should never be called.\n-     *\/\n-    private Main() { throw new AssertionError(); }\n-\n@@ -91,0 +91,59 @@\n+\n+    \/\/ builder-style API to run javadoc\n+\n+    private PrintWriter outWriter;\n+    private PrintWriter errWriter;\n+    private StandardJavaFileManager fileManager;\n+\n+    \/**\n+     * Creates a default builder to run javadoc.\n+     *\/\n+    public Main() { }\n+\n+    \/**\n+     * Sets the output and error streams to be used when running javadoc.\n+     * The streams may be the same; they must not be {@code null}.\n+     *\n+     * @param outWriter the output stream\n+     * @param errWriter the error stream\n+     *\n+     * @return this object\n+     *\/\n+    public Main setStreams(PrintWriter outWriter, PrintWriter errWriter) {\n+        this.outWriter = Objects.requireNonNull(outWriter);\n+        this.errWriter = Objects.requireNonNull(errWriter);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the file manager to be used when running javadoc.\n+     * A value of {@code null} means to use the default file manager.\n+     *\n+     * @param fileManager the file manager to use\n+     *\n+     * @return this object\n+     *\/\n+    public Main setFileManager(StandardJavaFileManager fileManager) {\n+        this.fileManager = fileManager;\n+        return this;\n+    }\n+\n+    \/**\n+     * Runs javadoc with preconfigured values and a given set of arguments.\n+     * Any errors will be reported to the error stream, or to {@link System#err}\n+     * if no error stream has been specified with {@code setStreams}.\n+     *\n+     * @param args the arguments\n+     *\n+     * @return a value indicating the success or otherwise of the run\n+     *\/\n+    public Result run(String... args) {\n+        Context context = null;\n+        if (fileManager != null) {\n+            context = new Context();\n+            context.put(JavaFileManager.class, fileManager);\n+        }\n+        Start jdoc = new Start(context, null, outWriter, errWriter, null, null);\n+        return jdoc.begin(args);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Main.java","additions":64,"deletions":5,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Map;\n@@ -523,0 +524,1 @@\n+            \/\/ standard file manager: use direct support for handling options\n@@ -524,0 +526,13 @@\n+        } else {\n+            \/\/ unrecognized file manager:\n+            for (Map.Entry<com.sun.tools.javac.main.Option, String> e: options.fileManagerOptions().entrySet()) {\n+                String optName = e.getKey().getPrimaryName();\n+                String optValue = e.getValue();\n+                try {\n+                    if (!fileManager.handleOption(optName, List.of(optValue).iterator())) {\n+                        log.error(\"main.unknown.option.for.filemanager\", optName);\n+                    }\n+                } catch (IllegalArgumentException ex) {\n+                    log.error(\"main.bad.arg.for.filemanager.option\", optName, ex.getMessage());\n+                }\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -305,0 +305,2 @@\n+main.unknown.option.for.filemanager=option not supported by file manager: {0}\n+main.bad.arg.for.filemanager.option=bad value for file manager option {0}: \"{1}\"\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import javax.tools.StandardJavaFileManager;\n@@ -248,0 +249,1 @@\n+    private StandardJavaFileManager fileManager = null;\n@@ -374,3 +376,11 @@\n-            exitCode = useStandardStreams\n-                    ? jdk.javadoc.internal.tool.Main.execute(args)              \/\/ use sysOut, sysErr\n-                    : jdk.javadoc.internal.tool.Main.execute(args, outOut.pw);  \/\/ default\n+            jdk.javadoc.internal.tool.Main main = new jdk.javadoc.internal.tool.Main();\n+            if (useStandardStreams) {\n+                \/\/ use sysOut, sysErr\n+            } else {\n+                \/\/ default: use single explicit stream\n+                main.setStreams(outOut.pw, outOut.pw);\n+            }\n+            if (fileManager != null) {\n+                main.setFileManager(fileManager);\n+            }\n+            exitCode = main.run(args).exitCode;\n@@ -445,0 +455,9 @@\n+    \/**\n+     * Sets the file manager to use for subsequent invocations of javadoc.\n+     * If {@code null}, a default file manager will be created and used\n+     * for each invocation.\n+     *\/\n+    public void setFileManager(StandardJavaFileManager fm) {\n+        fileManager = fm;\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javadoc.tester;\n+\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A builder to create \"test file managers\" that can return \"test file objects\".\n+ * All such objects can throw user-provided exceptions when specified methods\n+ * are called. This is done by registering \"handlers\" to be associated with individual\n+ * methods.\n+ *\n+ * The file objects that are returned as \"test file objects\" are filtered by a predicate\n+ * on the file object.\n+ *\n+ * Note that \"test file objects\" passed as arguments to methods on the \"test file manager\"\n+ * that created them are unwrapped, and replaced by the original file object.\n+ * This ensures that the underlying file manager sees the underlying file objects,\n+ * for cases when the identity of the file objects is important.\n+ * However, it does mean that methods on file objects called internally by a\n+ * file manager will not throw any user-provided exceptions.\n+ *\n+ * For now, the handlers for a file object are simply grouped by predicate and then by\n+ * method, and the group of methods used for a \"test file object\" is determined by the\n+ * first predicate that matches.\n+ * An alternative, more expensive, implementation would be to group the handlers\n+ * by method and predicate and then dynamically build the set of methods to be used for\n+ * a file object by filtering the methods by their applicable predicate.\n+ *\/\n+public class TestJavaFileManagerBuilder {\n+    private final StandardJavaFileManager fm;\n+    private Map<Method, BiFunction<JavaFileManager, Object[], Throwable>> fileManagerHandlers;\n+\n+    private record FileObjectHandlers(Predicate<JavaFileObject> filter,\n+                                      Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) { }\n+    private final List<FileObjectHandlers> fileObjectHandlers;\n+\n+    public TestJavaFileManagerBuilder(StandardJavaFileManager fm) {\n+        this.fm = fm;\n+        fileManagerHandlers = Collections.emptyMap();\n+        fileObjectHandlers = new ArrayList<>();\n+    }\n+\n+    \/**\n+     * Provides functions to be called when given file manager methods are called.\n+     * The function should either return an exception to be thrown, or {@code null}\n+     * to indicate that no exception should be thrown.\n+     *\n+     * It is an error for any function to return a checked exception that is not\n+     * declared by the method. This error will result in {@link UndeclaredThrowableException}\n+     * being thrown when the method is called.\n+     *\n+     * @param handlers  a map giving the function to be called before a file manager method is invoked\n+     *\n+     * @return this object\n+     * @throws IllegalArgumentException if any key in the map is a method that is not declared in {@code JavaFileManager}\n+     *\/\n+    public TestJavaFileManagerBuilder handle(Map<Method, BiFunction<JavaFileManager, Object[], Throwable>> handlers) {\n+        handlers.forEach((m, h) -> {\n+            if (!JavaFileManager.class.isAssignableFrom(m.getDeclaringClass())) {\n+                throw new IllegalArgumentException((\"not a method on JavaFileManager: \" + m));\n+            }\n+        });\n+\n+        fileManagerHandlers = handlers;\n+        return this;\n+    }\n+\n+    \/**\n+     * Provides functions to be called when given file object methods are called,\n+     * for file objects that match a given predicate.\n+     * The function should either return an exception to be thrown, or {@code null}\n+     * to indicate that no exception should be thrown.\n+     *\n+     * It is an error for the function to return a checked exception that is not\n+     * declared by the method. This error will result in {@link UndeclaredThrowableException}\n+     * being thrown when the method is called.\n+     *\n+     * When subsequently finding the handlers to be used for a particular file object, the various\n+     * predicates passed to this method will be tested in the order that they were registered.\n+     * The handlers associated with the first matching predicate will be used.\n+     *\n+     * @apiNote Examples of predicates include:\n+     * <ul>\n+     * <li>using {@code .equals} or {@link JavaFileObject#isNameCompatible(String, JavaFileObject.Kind)}\n+     *     to match a specific file object,\n+     * <li>using string or regular expression operations on the name or URI of the file object,\n+     * <li>using {@code Path} operations on the file object's {@link StandardJavaFileManager#asPath(FileObject) path}.\n+     * <\/ul>\n+     *\n+     * @param filter    the predicate used to identify file objects for which the handlers are applicable\n+     * @param handlers  a map giving the function to be called before a file object method is invoked\n+     *\n+     * @return this object\n+     * @throws IllegalArgumentException if the method is not declared in a class that is assignable\n+     *          to {@code FileObject}\n+     *\/\n+    public TestJavaFileManagerBuilder handle(Predicate<JavaFileObject> filter,\n+                                             Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) {\n+        handlers.forEach((m, h) -> {\n+            if (!FileObject.class.isAssignableFrom(m.getDeclaringClass())) {\n+                throw new IllegalArgumentException((\"not a method on FileObject: \" + m));\n+            }\n+        });\n+\n+        fileObjectHandlers.add(new FileObjectHandlers(filter, handlers));\n+        return this;\n+    }\n+\n+    \/**\n+     * {@return a file manager configured with the given handlers}\n+     *\/\n+    public StandardJavaFileManager build() {\n+        return (StandardJavaFileManager) Proxy.newProxyInstance(getClass().getClassLoader(),\n+                new Class<?>[] { StandardJavaFileManager.class },\n+                new JavaFileManager_InvocationHandler());\n+    }\n+\n+    \/**\n+     * An invocation handler for \"test file managers\", which provides \"test file objects\"\n+     * that may be configured to invoke functions to handle selected methods.\n+     *\/\n+    private class JavaFileManager_InvocationHandler implements InvocationHandler {\n+        \/\/ a cache of \"real file object\" -> \"proxy file object\".\n+        Map<JavaFileObject, JavaFileObject> cache = new WeakHashMap<>();\n+\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            Object result = handleMethod(fm, method, unwrap(args));\n+\n+            if (result instanceof Iterable iterable) {\n+                \/\/ All methods on StandardJavaFileManager that return Iterable<T> for some T\n+                \/\/ are such that T is one of ? extends [Java]FileObject, ? extends File, ? extends Path.\n+                \/\/ If the result is empty, return it unchanged; otherwise check the first\n+                \/\/ element to determine the type of the iterable, and if it is an iterable of\n+                \/\/ file objects, post-process the result to use proxy file objects where appropriate.\n+                \/\/ Note 1: this assumes that no methods return a mixture of FileObject and JavaFileObject.\n+                \/\/ Note 2: all file objects returned by the standard file manager are instances of javaFileObject\n+                Iterator<?> iter = iterable.iterator();\n+                if (iter.hasNext() && iter.next() instanceof JavaFileObject) {\n+                    List<JavaFileObject> list = new ArrayList<>();\n+                    for (JavaFileObject jfo : (Iterable<JavaFileObject>) iterable) {\n+                        list.add(wrap(jfo));\n+                    }\n+                    return list;\n+                } else {\n+                    return result;\n+                }\n+            } else if (result instanceof JavaFileObject jfo) {\n+                return wrap(jfo);\n+            } else {\n+                return result;\n+            }\n+        }\n+\n+        \/**\n+         * Returns a proxy file object that either calls handler functions for specific methods\n+         * or delegates to an underlying file object.\n+         *\n+         * @param jfo the underlying file object\n+         *\n+         * @return the proxy file object\n+         *\/\n+        private JavaFileObject wrap(JavaFileObject jfo) {\n+            return fileObjectHandlers.stream()\n+                    .filter(e -> e.filter().test(jfo))\n+                    .findFirst()\n+                    .map(e -> cache.computeIfAbsent(jfo, jfo_ -> createProxyFileObject(jfo_, e.handlers())))\n+                    .orElse(jfo);\n+        }\n+\n+        \/**\n+         * Creates a proxy file object that either calls handler functions for specific methods\n+         * or delegates to an underlying file object.\n+         *\n+         * @param jfo      the underlying file object\n+         * @param handlers the handlers\n+         *\n+         * @return the proxy file object\n+         *\/\n+        private JavaFileObject createProxyFileObject(JavaFileObject jfo,\n+                                                     Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers) {\n+            return (JavaFileObject) Proxy.newProxyInstance(getClass().getClassLoader(),\n+                    new Class<?>[] { JavaFileObject.class },\n+                    new JavaFileObject_InvocationHandler(jfo, handlers));\n+        }\n+\n+        \/**\n+         * {@return an array of objects with any proxy file objects replaced by their underlying\n+         * delegate value}\n+         *\n+         * If there are no proxy objects in the array, the original array is returned.\n+         *\n+         * @param args the array of values\n+         *\/\n+        private Object[] unwrap(Object[] args) {\n+            if (!containsProxyFileObject(args)) {\n+                return args;\n+            }\n+\n+            Object[] uArgs = new Object[args.length];\n+            for (int i = 0; i < args.length; i++) {\n+                Object arg = args[i];\n+                uArgs[i] = (Proxy.isProxyClass(arg.getClass())\n+                        && Proxy.getInvocationHandler(arg) instanceof JavaFileObject_InvocationHandler ih)\n+                        ? ih.jfo\n+                        : arg;\n+            }\n+            return uArgs;\n+        }\n+\n+        \/**\n+         * {@return {@code true} if an array of objects contains any proxy file objects,\n+         *          and {@code false} otherwise}\n+         *\n+         * @param args the array of objects\n+         *\/\n+        private boolean containsProxyFileObject(Object[] args) {\n+            for (Object arg : args) {\n+                if (arg != null && Proxy.isProxyClass(arg.getClass())\n+                        && Proxy.getInvocationHandler(arg) instanceof JavaFileObject_InvocationHandler) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Object handleMethod(JavaFileManager fm, Method method, Object[] args) throws Throwable {\n+            var handler = fileManagerHandlers.get(method);\n+            if (handler != null) {\n+                Throwable t = handler.apply(fm, args);\n+                if (t != null) {\n+                    throw t;\n+                }\n+            }\n+\n+            return method.invoke(fm, args);\n+        }\n+    }\n+\n+    \/**\n+     * An invocation handler for \"test file objects\" which can be configured to call functions\n+     * to handle the calls for individual methods.\n+     * It is expected that a common use case is to throw an exception in circumstances that\n+     * would otherwise be hard to create.\n+     *\/\n+    private record JavaFileObject_InvocationHandler(JavaFileObject jfo,\n+                                                    Map<Method, BiFunction<JavaFileObject, Object[], Throwable>> handlers)\n+            implements InvocationHandler {\n+\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return handleMethod(jfo, method, args);\n+        }\n+\n+        private Object handleMethod(JavaFileObject jfo, Method method, Object[] args) throws Throwable {\n+            var handler = handlers.get(method);\n+            if (handler != null) {\n+                Throwable t =  handler.apply(jfo, args);\n+                if (t != null) {\n+                    throw t;\n+                }\n+            }\n+            return method.invoke(jfo, args);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/TestJavaFileManagerBuilder.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8276892\n+ * @summary Provide a way to emulate exceptional situations in FileManager when using JavadocTester\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestTFMBuilder\n+ *\/\n+\n+\n+import javax.tools.DocumentationTool;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javadoc.tester.JavadocTester;\n+import javadoc.tester.TestJavaFileManagerBuilder;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests the {@link TestJavaFileManagerBuilder class}.\n+ *\n+ *\/\n+\/\/ The use of the contraction TFMBuilder is deliberate, to avoid using\n+\/\/ the confusing but otherwise logical name of TestTestJavaFileManagerBuilder\n+public class TestTFMBuilder extends JavadocTester {\n+    public static class TestException extends RuntimeException {\n+        TestException(JavaFileObject jfo) {\n+            this(jfo.getName());\n+        }\n+\n+        TestException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        TestTFMBuilder tester = new TestTFMBuilder();\n+        tester.setup().runTests(m -> new Object[] { Path.of(m.getName()) });\n+    }\n+\n+    private Path srcDir = Path.of(\"src\");\n+    private Class<?> thisClass = TestTFMBuilder.class;\n+    private String thisClassName = thisClass.getName();\n+\n+    TestTFMBuilder setup() throws Exception {\n+        ToolBox tb = new ToolBox();\n+        tb.writeJavaFiles(srcDir, \"\"\"\n+                package p;\n+                \/** Dummy class, to be read by javadoc. {@snippet file=\"C.properties\" } *\/\n+                public class C {\n+                    private C() { }\n+                }\"\"\");\n+        tb.writeFile(srcDir.resolve(\"p\").resolve(\"snippet-files\").resolve(\"C.properties\"), \"\"\"\n+                dummy content\n+                \"\"\");\n+        return this;\n+    }\n+\n+    StandardJavaFileManager getFileManager() {\n+        DocumentationTool dt = ToolProvider.getSystemDocumentationTool();\n+        return dt.getStandardFileManager(null, null, null);\n+    }\n+\n+    @Test\n+    public void testSimpleDirectUse(Path base) throws Exception {\n+        try (StandardJavaFileManager fm = getFileManager()) {\n+            fm.setLocation(StandardLocation.SOURCE_PATH, List.of(Path.of(testSrc).toFile()));\n+\n+            \/\/ obtain a normal file object from the standard file manager\n+            JavaFileObject someFileObject =\n+                    fm.getJavaFileForInput(StandardLocation.SOURCE_PATH, thisClassName, JavaFileObject.Kind.SOURCE);\n+\n+            \/\/ build a file manager that throws an exception when someFileObject is read\n+            StandardJavaFileManager tfm = new TestJavaFileManagerBuilder(fm)\n+                    .handle(jfo -> jfo.equals(someFileObject),\n+                            Map.of(JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n+                                (fo, args) -> new TestException(fo.getName())))\n+                    .build();\n+\n+            \/\/ access the \"same\" file object via the test file manager\n+            JavaFileObject someTestFileObject =\n+                    tfm.getJavaFileForInput(StandardLocation.SOURCE_PATH, thisClassName, JavaFileObject.Kind.SOURCE);\n+\n+            checking(\"non-trapped method\");\n+            try {\n+                out.println(\"someTestFileObject.getName: \" + someTestFileObject.getName());\n+                passed(\"method returned normally, as expected\");\n+            } catch (Throwable t) {\n+                failed(\"method threw unexpected exception: \" + t);\n+            }\n+\n+            checking (\"trapped method\");\n+            try {\n+                someTestFileObject.getCharContent(true);\n+                failed(\"method returned normally, without throwing an exception\");\n+            } catch (TestException e) {\n+                String expect = someFileObject.getName();\n+                String found = e.getMessage();\n+                if (found.equals(expect)) {\n+                    passed(\"method threw exception as expected\");\n+                } else {\n+                    failed(\"method throw exception with unexpected message:\\n\"\n+                            + \"expected: \" + expect + \"\\n\"\n+                            + \"   found: \" + found);\n+                }\n+            } catch (Throwable t) {\n+                failed(\"method threw unexpected exception: \" + t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testFileManagerAccess(Path base) throws Exception {\n+        try (StandardJavaFileManager fm = getFileManager()) {\n+\n+            \/\/ build a file manager that throws an exception when a specific source file is accessed\n+            Method getFileForInput_method = JavaFileManager.class.getMethod(\"getFileForInput\",\n+                    JavaFileManager.Location.class, String.class, String.class);\n+            StandardJavaFileManager tfm = new TestJavaFileManagerBuilder(fm)\n+                    .handle(Map.of(getFileForInput_method,\n+                                (fm_, args) -> {\n+                                    var relativeName = (String) args[2];\n+                                    return (relativeName.endsWith(\"C.properties\"))\n+                                            ? new TestException(\"getFileForInput: \" + Arrays.asList(args))\n+                                            : null;\n+                                }))\n+                    .build();\n+\n+            try {\n+                setFileManager(tfm);\n+                javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                        \"-sourcepath\", srcDir.toString(),\n+                        \"p\");\n+                checkExit((Exit.ERROR)); \/\/ Ideally, this should be ABNORMAL, but right now, the doclet has no way to indicate that\n+                checkOutput(Output.OUT, true,\n+                        \"\"\"\n+                                error: An internal exception has occurred.\n+                                  \\t(##EXC##: getFileForInput: [SOURCE_PATH, p, snippet-files\/C.properties])\n+                                1 error\"\"\"\n+                                .replace(\"##EXC##\", TestException.class.getName()));\n+            } finally {\n+                setFileManager(null);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testFileObjectRead(Path base) throws Exception {\n+        try (StandardJavaFileManager fm = getFileManager()) {\n+\n+            \/\/ build a file manager that throws an exception when any *.java is read\n+            StandardJavaFileManager tfm = new TestJavaFileManagerBuilder(fm)\n+                    .handle(jfo -> jfo.getName().endsWith(\".java\"),\n+                            Map.of(JavaFileObject.class.getMethod(\"getCharContent\", boolean.class),\n+                                (fo, args) -> new TestException(fo.getName())))\n+                    .build();\n+\n+            try {\n+                setFileManager(tfm);\n+                javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                        \"-sourcepath\", srcDir.toString(),\n+                        \"p\");\n+                checkExit((Exit.ABNORMAL));\n+                checkOutput(Output.OUT, true,\n+                        \"\"\"\n+                            Loading source files for package p...\n+                            error: fatal error encountered: ##EXC##: ##FILE##\n+                            error: Please file a bug against the javadoc tool via the Java bug reporting page\"\"\"\n+                                .replace(\"##EXC##\", TestException.class.getName())\n+                                .replace(\"##FILE##\", srcDir.resolve(\"p\").resolve(\"C.java\").toString()));\n+            } finally {\n+                setFileManager(null);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testFileObjectWrite(Path base) throws Exception {\n+        try (StandardJavaFileManager fm = getFileManager()) {\n+            Path outDir = base.resolve(\"api\");\n+\n+            \/\/ build a file manager that throws an exception when any file is generated\n+            StandardJavaFileManager tfm = new TestJavaFileManagerBuilder(fm)\n+                    .handle(jfo -> fm.asPath(jfo).startsWith(outDir.toAbsolutePath())\n+                                    && jfo.getName().endsWith(\".html\"),\n+                            Map.of(JavaFileObject.class.getMethod(\"openOutputStream\"),\n+                                (fo, args) -> new TestException(fo.getName())))\n+                    .build();\n+\n+            try {\n+                setFileManager(tfm);\n+                javadoc(\"-d\", outDir.toString(),\n+                        \"-sourcepath\", srcDir.toString(),\n+                        \"p\");\n+                checkExit((Exit.ERROR));\n+                checkOutput(Output.OUT, true,\n+                        \"\"\"\n+                            Generating ##FILE##...\n+                            error: An internal exception has occurred.\n+                              \\t(##EXC##: ##FILE##)\n+                            1 error\"\"\"\n+                                .replace(\"##EXC##\", TestException.class.getName())\n+                                .replace(\"##FILE##\", outDir.resolve(\"p\").resolve(\"C.html\").toString()));\n+            } finally {\n+                setFileManager(null);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/testTFMBuilder\/TestTFMBuilder.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"}]}