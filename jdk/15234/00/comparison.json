{"files":[{"patch":"@@ -46,0 +46,1 @@\n+ *        jdk.test.lib.compiler.CompilerUtils\n","filename":"test\/jdk\/tools\/jlink\/JLink100Modules.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.JImageGenerator;\n+import tests.Result;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that modules can be linked using jlink and deduplication works correctly when creating sub methods\n+ * @bug 8311591\n+ * @library \/test\/lib\n+ *          ..\/lib\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.* JLinkDedupTestBatchSizeOne jdk.test.lib.compiler.CompilerUtils\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne\n+ *\/\n+public class JLinkDedupTestBatchSizeOne {\n+\n+    private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"dedup\", \"src\");\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+\n+    private static final String MODULE_PATH =\n+            Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                    File.pathSeparator + MODS_DIR.toString();\n+\n+    \/\/ the names of the modules in this test\n+    private static String[] modules = new String[]{\"m1\", \"m2\", \"m3\", \"m4\"};\n+\n+    private static boolean hasJmods() {\n+        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n+            System.err.println(\"Test skipped. No jmods directory\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static void compileAll() throws Throwable {\n+        if (!hasJmods()) return;\n+\n+        for (String mn : modules) {\n+            Path msrc = SRC_DIR.resolve(mn);\n+            CompilerUtils.compile(msrc, MODS_DIR,\n+                    \"--module-source-path\", SRC_DIR.toString());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        compileAll();\n+        Path src = Paths.get(\"bug8311591\");\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(MODULE_PATH)\n+                .output(src.resolve(\"out-jlink-dedup\"))\n+                .addMods(\"m1\")\n+                .addMods(\"m2\")\n+                .addMods(\"m2\")\n+                .addMods(\"m3\")\n+                .addMods(\"m4\")\n+                .option(\"--system-modules=batchSize=1\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink-dedup\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"m4\/p4.Main\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+            throw new AssertionError(\"JLinkDedupTest100Modules failed to launch\");\n+\n+        extractJImage(src);\n+        decompileWitJavap(src);\n+    }\n+\n+    static void extractJImage(Path src) {\n+        Path binDir = src.resolve(\"out-jlink-dedup\").toAbsolutePath();\n+        Path outputDir = src.resolve(\"dir\");\n+        Path jimageDir = binDir.resolve(\"lib\", \"modules\");\n+\n+        Result result = JImageGenerator.getJImageTask()\n+                .dir(outputDir)\n+                .image(jimageDir)\n+                .extract();\n+\n+        System.out.println(\"jimage extracted dir \" + result.getFile());\n+        result.assertSuccess();\n+    }\n+\n+    static void decompileWitJavap(Path srcDir) throws Exception {\n+        Path systemModuleClass = srcDir.resolve(\"dir\", \"java.base\", \"jdk\", \"internal\", \"module\", \"SystemModules$all.class\");\n+        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n+                .addToolArg(\"-verbose\")\n+                .addToolArg(\"-p\")       \/\/ Shows all classes and members.\n+                .addToolArg(\"-c\")       \/\/ Prints out disassembled code\n+                .addToolArg(systemModuleClass.toString());\n+        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n+        pb.inheritIO();\n+        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkDedupTestBatchSizeOne.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+import p1.AInterface;\n+import p3.ServiceInterface;\n+\n+module m1 {\n+    exports p1 to m4;\n+\n+    opens p1 to m4;\n+\n+    requires transitive java.desktop;\n+    requires m3;\n+\n+    provides ServiceInterface\n+            with AInterface;\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m1\/module-info.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+package p1;\n+import p3.ServiceInterface;\n+\n+public class AInterface implements ServiceInterface {\n+\n+    public String getString() {\n+        return \"A1_A2\";\n+    }\n+\n+    public String getServiceName() {\n+        return \"AService\";\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m1\/p1\/AInterface.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+import p2.BInterface;\n+import p3.ServiceInterface;\n+\n+module m2 {\n+    exports p2 to m3,m4;\n+\n+    opens p2 to m4;\n+\n+    requires transitive java.desktop;\n+    requires m3;\n+\n+    provides p3.ServiceInterface\n+            with BInterface;\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m2\/module-info.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+package p2;\n+import p3.ServiceInterface;\n+public class BInterface implements ServiceInterface {\n+\n+    public String getString() {\n+        return \"B1_B2\";\n+    }\n+\n+    public String getServiceName() {\n+        return \"BService\";\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m2\/p2\/BInterface.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+module m3 {\n+    exports p3;\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m3\/module-info.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+package p3;\n+public interface ServiceInterface {\n+\n+    String getString();\n+\n+    String getServiceName();\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m3\/p3\/ServiceInterface.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+import p3.ServiceInterface;\n+\n+module m4 {\n+    requires m3;\n+    uses ServiceInterface;\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m4\/module-info.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+package p4;\n+\n+import p3.ServiceInterface;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+public class Main {\n+    public static void main(String[]args) {\n+\n+        List<ServiceInterface> services=getServices();\n+\n+        for (var service:services) {\n+            System.out.println(\"Service name  \"+service.getServiceName());\n+            System.out.println(\"Service string\"+service.getString());\n+        }\n+    }\n+\n+    private static List<ServiceInterface> getServices(){\n+        List<ServiceInterface> services = new ArrayList<>();\n+        ServiceLoader.load(ServiceInterface.class).forEach(services::add);\n+        return services;\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/dedup\/src\/m4\/p4\/Main.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"}]}