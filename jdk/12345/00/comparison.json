{"files":[{"patch":"@@ -178,2 +178,2 @@\n-  virtual void* find_start(void* p)     const;   \/\/ returns the block containing p or null\n-  virtual CodeBlob* find_blob(void* start) const;\n+  void* find_start(void* p)     const;   \/\/ returns the block containing p or null\n+  CodeBlob* find_blob(void* start) const;\n@@ -195,1 +195,1 @@\n-  virtual void* first() const                    { return next_used(first_block()); }\n+  void* first() const                    { return next_used(first_block()); }\n@@ -197,1 +197,1 @@\n-  virtual void* next(void* p) const              { return next_used(next_block(block_start(p))); }\n+  void* next(void* p) const              { return next_used(next_block(block_start(p))); }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,5 +52,0 @@\n-    \/\/ Note: CodeHeap may be subclassed with optional private heap mechanisms.\n-    Type codeHeapType = db.lookupType(\"CodeHeap\");\n-    VirtualBaseConstructor<CodeHeap> heapConstructor =\n-        new VirtualBaseConstructor<>(db, codeHeapType, \"sun.jvm.hotspot.memory\", CodeHeap.class);\n-\n@@ -58,1 +53,1 @@\n-    heapArray = GrowableArray.create(heapsField.getValue(), heapConstructor);\n+    heapArray = GrowableArray.create(heapsField.getValue(), new StaticBaseConstructor<>(CodeHeap.class));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}