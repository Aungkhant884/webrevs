{"files":[{"patch":"@@ -52,0 +52,1 @@\n+ * IPV6_MULTICAST_ALL supported since 4.20\n@@ -57,0 +58,3 @@\n+  #ifndef IPV6_MULTICAST_ALL\n+    #define IPV6_MULTICAST_ALL    29\n+  #endif\n@@ -300,1 +304,0 @@\n-    \/* By default, Linux uses the route default *\/\n@@ -302,0 +305,1 @@\n+        \/* By default, Linux uses the route default *\/\n@@ -311,0 +315,11 @@\n+\n+        \/* Disable IPV6_MULTICAST_ALL if option supported *\/\n+        arg = 0;\n+        if ((setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_ALL, (char*)&arg, sizeof(arg)) < 0) &&\n+            (errno != ENOPROTOOPT)) {\n+            JNU_ThrowByNameWithLastError(env,\n+                                     JNU_JAVANETPKG \"SocketException\",\n+                                     \"Unable to set IPV6_MULTICAST_ALL\");\n+            close(fd);\n+            return -1;\n+        }\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8241800\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ * @run main\/othervm DisableMulticastAllOpt\n+ * @summary Disable IPV6_MULTICAST_ALL to prevent interference from all multicast groups\n+ *\/\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.charset.StandardCharsets;\n+import jdk.test.lib.NetworkConfiguration;\n+\n+public class DisableMulticastAllOpt {\n+\n+    \/\/ Check if the kernel is 4.20 or greater\n+\n+    static boolean is_4_20_orGreater() {\n+        try {\n+            Process p = new ProcessBuilder(\"uname\", \"-r\").start();\n+            InputStream is = p.getInputStream();\n+            byte[] output = is.readAllBytes();\n+            is.close();\n+            String verstring = new String(output, StandardCharsets.UTF_8);\n+            System.out.println(\"Uname -r: \" + verstring);\n+            String[] vernumbers = verstring.split(\"\\\\.\");\n+            if (vernumbers.length == 0)\n+                return false;\n+            int first;\n+            if ((first = Integer.parseInt(vernumbers[0])) >= 5)\n+                return true;\n+            if (first < 4)\n+                return false;\n+            if (vernumbers.length < 2)\n+                return false;\n+            if (Integer.parseInt(vernumbers[1]) >= 20)\n+                return true;\n+            else\n+                return false;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static InetAddress getInetAddress(String name) {\n+        try {\n+            return InetAddress.getByName(name);\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static final InetAddress all = getInetAddress(\"::0\");\n+\n+    private static final NetworkInterface nif;\n+\n+    static {\n+        try {\n+            nif = NetworkConfiguration.probe()\n+                .ip6MulticastInterfaces()\n+                .findFirst()\n+                .orElse(null);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ Join this group\n+    private static final InetAddress mc1 = getInetAddress(\"FF12::100\");\n+\n+    \/\/ Send to this group without joining\n+    private static final InetAddress mc2 = getInetAddress(\"FF12::101\");\n+\n+    static int getPortFromChannel(DatagramChannel channel) throws IOException {\n+        InetSocketAddress addr = (InetSocketAddress) channel.getLocalAddress();\n+        return addr.getPort();\n+    }\n+\n+    static DatagramChannel getChannel(int port) throws IOException {\n+        DatagramChannel chan = DatagramChannel.open(StandardProtocolFamily.INET6);\n+        chan.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n+        chan.bind(new InetSocketAddress(all, port));\n+        return chan;\n+    }\n+\n+   \/**\n+    * Creates one sending channel and two receiving channels which join\n+    * two different multicast groups on the same port.\n+    * A packet is then sent to each destination\n+    *\n+    * We then attempt to read two packets off the first channel\n+    * The first packet should always be received and without this change\n+    * the second packet will also be received, which should not happen\n+    * going forward on a 4.20+ kernel\n+    *\/\n+    public static void main(String[] args) throws Exception {\n+        if (nif == null) {\n+            System.out.println(\"Suitable multicast interface not available\");\n+            return;\n+        }\n+        if (!is_4_20_orGreater()) {\n+            System.out.println(\"Kernel < 4.20. Not running test\");\n+            \/* Just check that attempting to create a socket\n+             * does not throw an exception. The setsockopt()\n+             * should fail silently\n+             *\/\n+            var ch1 = getChannel(0);\n+            ch1.close();\n+            return;\n+        }\n+        System.out.println(\"Kernel >= 4.20. Running test\");\n+        System.out.println(\"Using interface: \" + nif.getName());\n+        var ch1 = getChannel(0);\n+        int port = getPortFromChannel(ch1);\n+        var ch2 = getChannel(port);\n+        InetSocketAddress dest1 = new InetSocketAddress(mc1, port);\n+        InetSocketAddress dest2 = new InetSocketAddress(mc2, port);\n+        ch1.join(mc1, nif);\n+        ch2.join(mc2, nif);\n+        var sender = getChannel(0);\n+        sender.setOption(StandardSocketOptions.IP_MULTICAST_IF, nif);\n+        ByteBuffer txbuf = ByteBuffer.wrap(\"Hello world\".getBytes(StandardCharsets.US_ASCII));\n+        ByteBuffer rxbuf = ByteBuffer.allocate(64);\n+        sender.send(txbuf, dest1);\n+        var addr = ch1.receive(rxbuf);\n+        System.out.printf(\"First read from %s\\n\", addr.toString());\n+        rxbuf.flip();\n+        System.out.printf(\"First read received %d bytes\\n\", rxbuf.remaining());\n+        txbuf = ByteBuffer.wrap(\"Goodbye world\".getBytes(StandardCharsets.US_ASCII));\n+        rxbuf.clear();\n+        sender.send(txbuf, dest2);\n+        Selector selector = Selector.open();\n+        ch1.configureBlocking(false);\n+        ch1.register(selector, SelectionKey.OP_READ);\n+        int ret = selector.select(2000);\n+        if (ret == 0) {\n+            System.out.println(\"No packet received. Test succeeded\");\n+        } else {\n+            throw new RuntimeException(\"Packet received. Test failed\");\n+        }\n+        ch1.close();\n+        ch2.close();\n+        sender.close();\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/DisableMulticastAllOpt.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}