{"files":[{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8241800\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build jdk.test.lib.NetworkConfiguration\n- *        jdk.test.lib.Platform\n- * @run main\/othervm DisableMulticastAllOpt\n- * @summary Disable IPV6_MULTICAST_ALL to prevent interference from all multicast groups\n- *\/\n-\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.net.*;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.DatagramChannel;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.charset.StandardCharsets;\n-import jdk.test.lib.NetworkConfiguration;\n-\n-public class DisableMulticastAllOpt {\n-\n-    \/\/ Check if the kernel is 4.20 or greater\n-\n-    static boolean is_4_20_orGreater() {\n-        try {\n-            Process p = new ProcessBuilder(\"uname\", \"-r\").start();\n-            InputStream is = p.getInputStream();\n-            byte[] output = is.readAllBytes();\n-            is.close();\n-            String verstring = new String(output, StandardCharsets.UTF_8);\n-            System.out.println(\"Uname -r: \" + verstring);\n-            String[] vernumbers = verstring.split(\"\\\\.\");\n-            if (vernumbers.length == 0)\n-                return false;\n-            int first;\n-            if ((first = Integer.parseInt(vernumbers[0])) >= 5)\n-                return true;\n-            if (first < 4)\n-                return false;\n-            if (vernumbers.length < 2)\n-                return false;\n-            if (Integer.parseInt(vernumbers[1]) >= 20)\n-                return true;\n-            else\n-                return false;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static InetAddress getInetAddress(String name) {\n-        try {\n-            return InetAddress.getByName(name);\n-        } catch (UnknownHostException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static final InetAddress all = getInetAddress(\"::0\");\n-\n-    private static final NetworkInterface nif;\n-\n-    static {\n-        try {\n-            nif = NetworkConfiguration.probe()\n-                .ip6MulticastInterfaces()\n-                .findFirst()\n-                .orElse(null);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/\/ Join this group\n-    private static final InetAddress mc1 = getInetAddress(\"FF12::100\");\n-\n-    \/\/ Send to this group without joining\n-    private static final InetAddress mc2 = getInetAddress(\"FF12::101\");\n-\n-    static int getPortFromChannel(DatagramChannel channel) throws IOException {\n-        InetSocketAddress addr = (InetSocketAddress) channel.getLocalAddress();\n-        return addr.getPort();\n-    }\n-\n-    static DatagramChannel getChannel(int port) throws IOException {\n-        DatagramChannel chan = DatagramChannel.open(StandardProtocolFamily.INET6);\n-        chan.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n-        chan.bind(new InetSocketAddress(all, port));\n-        return chan;\n-    }\n-\n-   \/**\n-    * Creates one sending channel and two receiving channels which join\n-    * two different multicast groups on the same port.\n-    * A packet is then sent to each destination\n-    *\n-    * We then attempt to read two packets off the first channel\n-    * The first packet should always be received and without this change\n-    * the second packet will also be received, which should not happen\n-    * going forward on a 4.20+ kernel\n-    *\/\n-    public static void main(String[] args) throws Exception {\n-        if (nif == null) {\n-            System.out.println(\"Suitable multicast interface not available\");\n-            return;\n-        }\n-        if (!is_4_20_orGreater()) {\n-            System.out.println(\"Kernel < 4.20. Not running test\");\n-            \/* Just check that attempting to create a socket\n-             * does not throw an exception. The setsockopt()\n-             * should fail silently\n-             *\/\n-            var ch1 = getChannel(0);\n-            ch1.close();\n-            return;\n-        }\n-        System.out.println(\"Kernel >= 4.20. Running test\");\n-        System.out.println(\"Using interface: \" + nif.getName());\n-        var ch1 = getChannel(0);\n-        int port = getPortFromChannel(ch1);\n-        var ch2 = getChannel(port);\n-        InetSocketAddress dest1 = new InetSocketAddress(mc1, port);\n-        InetSocketAddress dest2 = new InetSocketAddress(mc2, port);\n-        ch1.join(mc1, nif);\n-        ch2.join(mc2, nif);\n-        var sender = getChannel(0);\n-        sender.setOption(StandardSocketOptions.IP_MULTICAST_IF, nif);\n-        ByteBuffer txbuf = ByteBuffer.wrap(\"Hello world\".getBytes(StandardCharsets.US_ASCII));\n-        ByteBuffer rxbuf = ByteBuffer.allocate(64);\n-        sender.send(txbuf, dest1);\n-        var addr = ch1.receive(rxbuf);\n-        System.out.printf(\"First read from %s\\n\", addr.toString());\n-        rxbuf.flip();\n-        System.out.printf(\"First read received %d bytes\\n\", rxbuf.remaining());\n-        txbuf = ByteBuffer.wrap(\"Goodbye world\".getBytes(StandardCharsets.US_ASCII));\n-        rxbuf.clear();\n-        sender.send(txbuf, dest2);\n-        Selector selector = Selector.open();\n-        ch1.configureBlocking(false);\n-        ch1.register(selector, SelectionKey.OP_READ);\n-        int ret = selector.select(2000);\n-        if (ret == 0) {\n-            System.out.println(\"No packet received. Test succeeded\");\n-        } else {\n-            throw new RuntimeException(\"Packet received. Test failed\");\n-        }\n-        ch1.close();\n-        ch2.close();\n-        sender.close();\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/DisableMulticastAllOpt.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import jdk.test.lib.Platform;\n@@ -198,15 +199,0 @@\n-        String os = System.getProperty(\"os.name\");\n-\n-        \/\/ Requires IP_MULTICAST_ALL on Linux (new since 2.6.31) so skip\n-        \/\/ on older kernels. Note that we skip on <= version 3 to keep the\n-        \/\/ parsing simple\n-        if (os.equals(\"Linux\")) {\n-            String osversion = System.getProperty(\"os.version\");\n-            String[] vers = osversion.split(\"\\\\.\", 0);\n-            int major = Integer.parseInt(vers[0]);\n-            if (major < 3) {\n-                System.out.format(\"Kernel version is %s, test skipped%n\", osversion);\n-                return;\n-            }\n-        }\n-\n@@ -225,2 +211,2 @@\n-            \/\/ Solaris and Linux allow IPv6 sockets join IPv4 multicast groups\n-            if (os.equals(\"Linux\"))\n+            \/\/ Linux allows IPv6 sockets join IPv4 multicast groups\n+            if (Platform.isLinux())\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ *        jdk.test.lib.Platform\n@@ -41,0 +42,1 @@\n+import jdk.test.lib.Platform;\n@@ -148,0 +150,1 @@\n+                     boolean bindToWildCard,\n@@ -157,2 +160,7 @@\n-        InetAddress bindAddr1 = Inet6Address.getByAddress(null, group1.getAddress(), nif);\n-        InetAddress bindAddr2 = Inet6Address.getByAddress(null, group2.getAddress(), nif);\n+        InetAddress bindAddr1 = bindToWildCard \n+                ? InetAddress.getByName(\"::0\")\n+                : Inet6Address.getByAddress(null, group1.getAddress(), nif);\n+\n+        InetAddress bindAddr2 = bindToWildCard\n+                ? InetAddress.getByName(\"::0\")\n+                : Inet6Address.getByAddress(null, group2.getAddress(), nif);\n@@ -199,1 +207,1 @@\n-        String os = System.getProperty(\"os.name\");\n+        boolean hasIPV6MulticastAll;\n@@ -201,1 +209,1 @@\n-        if (!os.equals(\"Linux\")) {\n+        if (!Platform.isLinux()) {\n@@ -204,6 +212,3 @@\n-            String osVersion = System.getProperty(\"os.version\");\n-            String prefix = \"3.10.0\";\n-            if (osVersion.startsWith(prefix)) {\n-                throw new SkippedException(\n-                        String.format(\"The behavior under test is known NOT to work on '%s' kernels\", prefix));\n-            }\n+            int major = Platform.getOsVersionMajor();\n+            int minor = Platform.getOsVersionMinor();\n+            hasIPV6MulticastAll = (major > 4) || ((major == 4 && minor >= 20));\n@@ -229,2 +234,6 @@\n-            test(INET6, nif, interfaceLocal1, interfaceLocal2);\n-            test(INET6, nif, linkLocal1, linkLocal2);\n+            test(INET6, nif, false, interfaceLocal1, interfaceLocal2);\n+            test(INET6, nif, false, linkLocal1, linkLocal2);\n+            if (hasIPV6MulticastAll) {\n+                test(INET6, nif, true, interfaceLocal1, interfaceLocal2);\n+                test(INET6, nif, true, linkLocal1, linkLocal2);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/PromiscuousIPv6.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"}]}