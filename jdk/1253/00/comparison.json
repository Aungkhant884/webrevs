{"files":[{"patch":"@@ -32,8 +32,0 @@\n-\/\/---------------------------Access to internals of class State----------------\n-static const char *sLeft   = \"_kids[0]\";\n-static const char *sRight  = \"_kids[1]\";\n-\n-\/\/---------------------------DFA productions-----------------------------------\n-static const char *dfa_production           = \"DFA_PRODUCTION\";\n-static const char *dfa_production_set_valid = \"DFA_PRODUCTION__SET_VALID\";\n-\n@@ -114,1 +106,1 @@\n-\/\/ 2)        DFA_PRODUCTION__SET_VALID(EBXREGI, cmovI_memu_rule, c)\n+\/\/ 2)        DFA_PRODUCTION(EBXREGI, cmovI_memu_rule, c)\n@@ -165,7 +157,7 @@\n-  \/\/ no need to set State vector if our state is knownValid\n-  const char *production = (validity_check == knownValid) ? dfa_production : dfa_production_set_valid;\n-  fprintf(fp, \"%s  %s(%s, %s_rule, %s)\", spaces, production, arrayIdx, rule, cost->as_string() );\n-  if( validity_check == knownValid ) {\n-    if( cost_is_below_lower_bound ) { fprintf(fp, \"\\t  \/\/ overwrites higher cost rule\"); }\n-   }\n-   fprintf(fp, \"\\n\");\n+  fprintf(fp, \"%s  DFA_PRODUCTION(%s, %s_rule, %s)\", spaces, arrayIdx, rule, cost->as_string() );\n+  if (validity_check == knownValid) {\n+    if (cost_is_below_lower_bound) {\n+      fprintf(fp, \"\\t  \/\/ overwrites higher cost rule\");\n+    }\n+  }\n+  fprintf(fp, \"\\n\");\n@@ -279,1 +271,1 @@\n-    strcmp(mList._opcode,mList._resultStr) ? mList._opcode : \"Invalid\";\n+    strcmp(mList._opcode, mList._resultStr) ? mList._opcode : \"Invalid\";\n@@ -399,10 +391,2 @@\n-  \/\/ #define DFA_PRODUCTION(result, rule, cost)\\\n-  \/\/   _cost[ (result) ] = cost; _rule[ (result) ] = rule;\n-  fprintf(fp, \"#define %s(result, rule, cost)\\\\\\n\", dfa_production);\n-  fprintf(fp, \"  _cost[ (result) ] = cost; _rule[ (result) ] = rule;\\n\");\n-  fprintf(fp, \"\\n\");\n-\n-  \/\/ #define DFA_PRODUCTION__SET_VALID(result, rule, cost)\\\n-  \/\/     DFA_PRODUCTION( (result), (rule), (cost) ); STATE__SET_VALID( (result) );\n-  fprintf(fp, \"#define %s(result, rule, cost)\\\\\\n\", dfa_production_set_valid);\n-  fprintf(fp, \"  %s( (result), (rule), (cost) ); STATE__SET_VALID( (result) );\\n\", dfa_production);\n+  fprintf(fp, \"#define DFA_PRODUCTION(result, rule, cost)\\\\\\n\");\n+  fprintf(fp, \"  assert(rule < (1 << 15), \\\"too many rules\\\"); _cost[ (result) ] = cost; _rule[ (result) ] = (rule << 1) | 0x1;\\n\");\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":11,"deletions":27,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2015,2 +2015,1 @@\n-  static const char *state__valid    = \"_valid[((uint)index) >> 5] &  (0x1 << (((uint)index) & 0x0001F))\";\n-  static const char *state__set_valid= \"_valid[((uint)index) >> 5] |= (0x1 << (((uint)index) & 0x0001F))\";\n+  static const char *state__valid    = \"_rule[index] & 0x1\";\n@@ -2021,5 +2020,0 @@\n-  fprintf(fp,\"\/\/   uint word   = index >> 5;       \/\/ Shift out bit position\\n\");\n-  fprintf(fp,\"\/\/   uint bitpos = index & 0x0001F;  \/\/ Mask off word bits\\n\");\n-  fprintf(fp,\"#define STATE__VALID(index) \");\n-  fprintf(fp,\"    (%s)\\n\", state__valid);\n-  fprintf(fp,\"\\n\");\n@@ -2032,3 +2026,0 @@\n-  fprintf(fp,\"#define STATE__SET_VALID(index) \");\n-  fprintf(fp,\"  (%s)\\n\", state__set_valid);\n-  fprintf(fp,\"\\n\");\n@@ -2043,0 +2034,5 @@\n+  fprintf(fp,\"private:\\n\");\n+  fprintf(fp,\"  unsigned int _cost[_LAST_MACH_OPER];  \/\/ Costs, indexed by operand opcodes\\n\");\n+  fprintf(fp,\"  uint16_t     _rule[_LAST_MACH_OPER];  \/\/ Rule and validity, indexed by operand opcodes\\n\");\n+  fprintf(fp,\"                                        \/\/ Lowest bit encodes validity\\n\");\n+\n@@ -2044,6 +2040,3 @@\n-  fprintf(fp,\"  int    _id;         \/\/ State identifier\\n\");\n-  fprintf(fp,\"  Node  *_leaf;       \/\/ Ideal (non-machine-node) leaf of match tree\\n\");\n-  fprintf(fp,\"  State *_kids[2];       \/\/ Children of state node in label tree\\n\");\n-  fprintf(fp,\"  unsigned int _cost[_LAST_MACH_OPER];  \/\/ Cost vector, indexed by operand opcodes\\n\");\n-  fprintf(fp,\"  unsigned int _rule[_LAST_MACH_OPER];  \/\/ Rule vector, indexed by operand opcodes\\n\");\n-  fprintf(fp,\"  unsigned int _valid[(_LAST_MACH_OPER\/32)+1]; \/\/ Bit Map of valid Cost\/Rule entries\\n\");\n+  fprintf(fp,\"  int    _id;                           \/\/ State identifier\\n\");\n+  fprintf(fp,\"  Node  *_leaf;                         \/\/ Ideal (non-machine-node) leaf of match tree\\n\");\n+  fprintf(fp,\"  State *_kids[2];                      \/\/ Children of state node in label tree\\n\");\n@@ -2051,2 +2044,2 @@\n-  fprintf(fp,\"  State(void);                      \/\/ Constructor\\n\");\n-  fprintf(fp,\"  DEBUG_ONLY( ~State(void); )       \/\/ Destructor\\n\");\n+  fprintf(fp,\"  State(void);\\n\");\n+  fprintf(fp,\"  DEBUG_ONLY( ~State(void); )\\n\");\n@@ -2061,1 +2054,0 @@\n-  fprintf(fp,\"  \/\/ Access function for _valid bit vector\\n\");\n@@ -2063,1 +2055,1 @@\n-  fprintf(fp,\"    return( STATE__VALID(index) != 0 );\\n\");\n+  fprintf(fp,\"    return %s;\\n\", state__valid);\n@@ -2065,4 +2057,5 @@\n-  fprintf(fp,\"\\n\");\n-  fprintf(fp,\"  \/\/ Set function for _valid bit vector\\n\");\n-  fprintf(fp,\"  void set_valid(uint index) {\\n\");\n-  fprintf(fp,\"    STATE__SET_VALID(index);\\n\");\n+  fprintf(fp,\"  unsigned int rule(uint index) {\\n\");\n+  fprintf(fp,\"    return _rule[index] >> 1;\\n\");\n+  fprintf(fp,\"  }\\n\");\n+  fprintf(fp,\"  unsigned int cost(uint index) {\\n\");\n+  fprintf(fp,\"    return _cost[index];\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1456,5 +1456,7 @@\n-  for( i = 0; i < NUM_OPERANDS; i++ ) {\n-    if( s->valid(i) &&                \/\/ valid entry and\n-        s->_cost[i] < cost &&         \/\/ low cost and\n-        s->_rule[i] >= NUM_OPERANDS ) \/\/ not an operand\n-      cost = s->_cost[mincost=i];\n+  for (i = 0; i < NUM_OPERANDS; i++) {\n+    if (s->valid(i) &&               \/\/ valid entry and\n+        s->cost(i) < cost &&         \/\/ low cost and\n+        s->rule(i) >= NUM_OPERANDS) {\/\/ not an operand\n+      mincost = i;\n+      cost = s->cost(i);\n+    }\n@@ -1471,1 +1473,1 @@\n-  MachNode *m = ReduceInst( s, s->_rule[mincost], mem );\n+  MachNode *m = ReduceInst(s, s->rule(mincost), mem);\n@@ -1839,1 +1841,1 @@\n-void Matcher::ReduceInst_Chain_Rule( State *s, int rule, Node *&mem, MachNode *mach ) {\n+void Matcher::ReduceInst_Chain_Rule(State* s, int rule, Node* &mem, MachNode* mach) {\n@@ -1844,1 +1846,1 @@\n-  int opnd_class_instance = s->_rule[op];\n+  unsigned int opnd_class_instance = s->rule(op);\n@@ -1849,1 +1851,1 @@\n-  int newrule = s->_rule[catch_op];\n+  unsigned int newrule = s->rule(catch_op);\n@@ -1851,1 +1853,1 @@\n-  if( newrule < NUM_OPERANDS ) {\n+  if (newrule < NUM_OPERANDS) {\n@@ -1853,2 +1855,1 @@\n-    assert( 0 <= opnd_class_instance && opnd_class_instance < NUM_OPERANDS,\n-            \"Bad AD file: Instruction chain rule must chain from operand\");\n+    assert(opnd_class_instance < NUM_OPERANDS, \"Bad AD file: Instruction chain rule must chain from operand\");\n@@ -1858,1 +1859,1 @@\n-    ReduceOper( s, newrule, mem, mach );\n+    ReduceOper(s, newrule, mem, mach);\n@@ -1861,1 +1862,1 @@\n-    assert( newrule >= _LAST_MACH_OPER, \"Do NOT chain from internal operand\");\n+    assert(newrule >= _LAST_MACH_OPER, \"Do NOT chain from internal operand\");\n@@ -1899,1 +1900,1 @@\n-    int opnd_class_instance = newstate->_rule[op];\n+    int opnd_class_instance = newstate->rule(op);\n@@ -1904,1 +1905,1 @@\n-    int newrule = newstate->_rule[catch_op];\n+    int newrule = newstate->rule(catch_op);\n@@ -1906,1 +1907,1 @@\n-    if( newrule < NUM_OPERANDS ) { \/\/ Operand\/operandClass or internalOp\/instruction?\n+    if (newrule < NUM_OPERANDS) { \/\/ Operand\/operandClass or internalOp\/instruction?\n@@ -1910,1 +1911,1 @@\n-      ReduceOper( newstate, newrule, mem, mach );\n+      ReduceOper(newstate, newrule, mem, mach);\n@@ -1913,1 +1914,1 @@\n-      if( newrule < _LAST_MACH_OPER ) { \/\/ internal operand or instruction?\n+      if (newrule < _LAST_MACH_OPER) { \/\/ internal operand or instruction?\n@@ -1916,1 +1917,1 @@\n-        num_opnds = ReduceInst_Interior( newstate, newrule, mem, mach, num_opnds );\n+        num_opnds = ReduceInst_Interior(newstate, newrule, mem, mach, num_opnds);\n@@ -1968,1 +1969,1 @@\n-  for( uint i=0; kid != NULL && i<2; kid = s->_kids[1], i++ ) {   \/\/ binary tree\n+  for (uint i = 0; kid != NULL && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n@@ -1970,4 +1971,5 @@\n-    if( i == 0)\n-      newrule = kid->_rule[_leftOp[rule]];\n-    else\n-      newrule = kid->_rule[_rightOp[rule]];\n+    if( i == 0) {\n+      newrule = kid->rule(_leftOp[rule]);\n+    } else {\n+      newrule = kid->rule(_rightOp[rule]);\n+    }\n@@ -1975,1 +1977,1 @@\n-    if( newrule < _LAST_MACH_OPER ) { \/\/ Operand or instruction?\n+    if (newrule < _LAST_MACH_OPER) { \/\/ Operand or instruction?\n@@ -1977,1 +1979,1 @@\n-      ReduceOper( kid, newrule, mem, mach );\n+      ReduceOper(kid, newrule, mem, mach);\n@@ -2811,1 +2813,1 @@\n-State::State(void) {\n+State::State(void) : _rule() {\n@@ -2816,2 +2818,0 @@\n-  \/\/memset(_cost, -1, sizeof(_cost));\n-  \/\/memset(_rule, -1, sizeof(_rule));\n@@ -2819,1 +2819,0 @@\n-  memset(_valid, 0, sizeof(_valid));\n@@ -2840,1 +2839,1 @@\n-  for( int j = 0; j < depth; j++ )\n+  for (int j = 0; j < depth; j++) {\n@@ -2842,0 +2841,1 @@\n+  }\n@@ -2845,1 +2845,1 @@\n-  for( i = 0; i < _LAST_MACH_OPER; i++ )\n+  for (i = 0; i < _LAST_MACH_OPER; i++) {\n@@ -2847,2 +2847,2 @@\n-    if( valid(i) ) {\n-      for( int j = 0; j < depth; j++ )\n+    if (valid(i)) {\n+      for (int j = 0; j < depth; j++) {\n@@ -2850,4 +2850,0 @@\n-        assert(_cost[i] != max_juint, \"cost must be a valid value\");\n-        assert(_rule[i] < _last_Mach_Node, \"rule[i] must be valid rule\");\n-        tty->print_cr(\"%s  %d  %s\",\n-                      ruleName[i], _cost[i], ruleName[_rule[i]] );\n@@ -2855,0 +2851,6 @@\n+      assert(cost(i) != max_juint, \"cost must be a valid value\");\n+      assert(rule(i) < _last_Mach_Node, \"rule[i] must be valid rule\");\n+      tty->print_cr(\"%s  %d  %s\",\n+                    ruleName[i], cost(i), ruleName[rule(i)] );\n+    }\n+  }\n@@ -2857,3 +2859,5 @@\n-  for( i=0; i<2; i++ )\n-    if( _kids[i] )\n-      _kids[i]->dump(depth+1);\n+  for (i = 0; i < 2; i++) {\n+    if (_kids[i]) {\n+      _kids[i]->dump(depth + 1);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":46,"deletions":42,"binary":false,"changes":88,"status":"modified"}]}