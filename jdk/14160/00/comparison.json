{"files":[{"patch":"@@ -38,1 +38,0 @@\n-import java.nio.file.Path;\n@@ -96,1 +95,1 @@\n-        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\"));\n+        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, \"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.file.Path;\n@@ -101,1 +100,1 @@\n-                Path.of(\"DUMP_METHOD_HANDLE_INTERNALS\"));\n+                \"DUMP_METHOD_HANDLE_INTERNALS\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import java.nio.file.Path;\n@@ -2255,1 +2254,1 @@\n-                \"jdk.invoke.MethodHandle.dumpClassFiles\", Path.of(\"DUMP_CLASS_FILES\"));\n+                \"jdk.invoke.MethodHandle.dumpClassFiles\", \"DUMP_CLASS_FILES\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,5 +30,2 @@\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n+import java.io.File;\n+import java.io.FileOutputStream;\n@@ -39,1 +36,0 @@\n-import java.util.PropertyPermission;\n@@ -55,30 +51,0 @@\n-    \/**\n-     * Returns a ClassFileDumper instance for the given key.  To enable\n-     * dumping of the generated classes, set the system property via\n-     * -D<key>=<path>.\n-     *\n-     * The system property is read only once when it is the first time\n-     * the dumper instance for the given key is created.\n-     *\n-     * If not enabled, this method returns ClassFileDumper with null\n-     * dump path.\n-     *\/\n-    public static ClassFileDumper getInstance(String key) {\n-        Objects.requireNonNull(key);\n-\n-        var dumper = DUMPER_MAP.get(key);\n-        if (dumper == null) {\n-            String path = GetPropertyAction.privilegedGetProperty(key);\n-            Path dir;\n-            if (path == null || path.trim().isEmpty()) {\n-                dir = null;\n-            } else {\n-                dir = validateDumpDir(Path.of(path.trim()));\n-            }\n-            var newDumper = new ClassFileDumper(key, dir);\n-            var v = DUMPER_MAP.putIfAbsent(key, newDumper);\n-            dumper = v != null ? v : newDumper;\n-        }\n-        return dumper;\n-    }\n-\n@@ -92,3 +58,0 @@\n-     *\n-     * If not enabled, this method returns ClassFileDumper with null\n-     * dump path.\n@@ -96,1 +59,1 @@\n-    public static ClassFileDumper getInstance(String key, Path path) {\n+    public static ClassFileDumper getInstance(String key, String path) {\n@@ -102,5 +65,1 @@\n-            String value = GetPropertyAction.privilegedGetProperty(key);\n-            boolean enabled = value != null && value.isEmpty()\n-                                    ? true : Boolean.parseBoolean(value);\n-            Path dir = enabled ? validateDumpDir(path) : null;\n-            var newDumper = new ClassFileDumper(key, dir);\n+            var newDumper = new ClassFileDumper(key, path);\n@@ -111,1 +70,1 @@\n-        if (dumper.isEnabled() && !path.equals(dumper.dumpPath())) {\n+        if (dumper.isEnabled() && !path.equals(dumper.dumpDir)) {\n@@ -118,1 +77,2 @@\n-    private final Path dumpDir;\n+    private final String dumpDir;\n+    private final boolean enabled;\n@@ -121,1 +81,2 @@\n-    private ClassFileDumper(String key, Path path) {\n+    private ClassFileDumper(String key, String path) {\n+        String value = GetPropertyAction.privilegedGetProperty(key);\n@@ -123,0 +84,4 @@\n+        boolean enabled = value != null && value.isEmpty() ? true : Boolean.parseBoolean(value);\n+        if (enabled) {\n+            validateDumpDir(path);\n+        }\n@@ -124,0 +89,1 @@\n+        this.enabled = enabled;\n@@ -130,1 +96,1 @@\n-        return dumpDir != null;\n+        return enabled;\n@@ -133,6 +99,2 @@\n-    public Path dumpPath() {\n-        return dumpDir;\n-    }\n-\n-    public Path pathname(String internalName) {\n-        return dumpDir.resolve(encodeForFilename(internalName) + \".class\");\n+    private File pathname(String name) {\n+        return new File(dumpDir, encodeForFilename(name) + \".class\");\n@@ -170,1 +132,5 @@\n-    private void write(Path path, byte[] bytes) {\n+    private void write(File file, byte[] bytes) {\n+        \/\/ use java.io.File instead of java.nio.file.Path to avoid\n+        \/\/ recursive initialization during early startup. e.g.\n+        \/\/ Enum::valueOf causes method handle to be invoked which\n+        \/\/ may cause classes to be spinned and dumped\n@@ -172,13 +138,15 @@\n-                @Override public Void run() {\n-                    try {\n-                        Path dir = path.getParent();\n-                        Files.createDirectories(dir);\n-                        Files.write(path, bytes);\n-                    } catch (Exception ex) {\n-                        if (VM.isModuleSystemInited()) {\n-                            \/\/ log only when lambda is ready to use\n-                            System.getLogger(ClassFileDumper.class.getName())\n-                                  .log(System.Logger.Level.WARNING, \"Exception writing to \" +\n-                                          path.toString() + \" \" + ex.getMessage());\n-                        }\n-                        \/\/ simply don't care if this operation failed\n+            @Override public Void run() {\n+                try {\n+                    \/\/ use absolute file to workaround writing to $CWD\/file if\n+                    \/\/ -Duser.dir is set\n+                    File path = file.getAbsoluteFile();\n+                    path.getParentFile().mkdirs();\n+                    FileOutputStream fos = new FileOutputStream(path);\n+                    fos.write(bytes);\n+                    fos.close();\n+                } catch (Exception ex) {\n+                    if (VM.isModuleSystemInited()) {\n+                        \/\/ log only when lambda is ready to use\n+                        System.getLogger(ClassFileDumper.class.getName())\n+                              .log(System.Logger.Level.WARNING, \"Exception writing to \" +\n+                                        file + \" \" + ex.getMessage());\n@@ -186,6 +154,4 @@\n-                    return null;\n-                }},\n-                null,\n-                new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-                \/\/ createDirectories may need it\n-                new PropertyPermission(\"user.dir\", \"read\"));\n+                    \/\/ simply don't care if this operation failed\n+                }\n+                return null;\n+            }});\n@@ -194,0 +160,3 @@\n+    \/*\n+     * Validate if the given dir is a writeable directory if exists.\n+     *\/\n@@ -195,8 +164,14 @@\n-    private static Path validateDumpDir(Path path) {\n-            return AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Path run() {\n-                    try {\n-                        Files.createDirectories(path);\n-                    } catch (IOException ex) {\n-                        throw new UncheckedIOException(\"Fail to create \" + path, ex);\n+    private static File validateDumpDir(String dir) {\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public File run() {\n+                \/\/ use java.io.File instead of java.nio.file.Path to avoid\n+                \/\/ recursive initialization during early startup.\n+\n+                \/\/ use absolute file to workaround an issue using the file relative\n+                \/\/ to CWD if -Duser.dir is set\n+                File path = new File(dir).getAbsoluteFile();\n+                if (!path.exists()) {\n+                    boolean rc = path.mkdirs();\n+                    if (!rc) {\n+                        throw new IllegalArgumentException(\"Fail to create \" + path);\n@@ -204,6 +179,0 @@\n-                    if (!Files.isDirectory(path)) {\n-                        throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n-                    } else if (!Files.isWritable(path)) {\n-                        throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n-                    }\n-                    return path;\n@@ -211,1 +180,8 @@\n-            });\n+                if (!path.isDirectory()) {\n+                    throw new IllegalArgumentException(\"Path \" + path + \" is not a directory\");\n+                } else if (!path.canWrite()) {\n+                    throw new IllegalArgumentException(\"Directory \" + path + \" is not writable\");\n+                }\n+                return path;\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":66,"deletions":90,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307944\n+ * @library \/test\/lib\n+ * @build DumpMethodHandleInternals\n+ * @run main DumpMethodHandleInternals\n+\n+ * @summary Test startup with -Djdk.invoke.MethodHandle.dumpMethodHandleInternals\n+ *          to work properly\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DumpMethodHandleInternals {\n+\n+    private static final Path DUMP_DIR = Path.of(\"DUMP_METHOD_HANDLE_INTERNALS\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (ProcessTools.executeTestJava(\"-Djdk.invoke.MethodHandle.dumpMethodHandleInternals\",\n+                                         \"-version\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue() != 0)\n+            throw new RuntimeException(\"Test failed - see output\");\n+\n+        if (Files.notExists(DUMP_DIR))\n+            throw new RuntimeException(DUMP_DIR + \" not created\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/DumpMethodHandleInternals.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -178,1 +178,1 @@\n-                                  .filter(s -> s.contains(\"java.nio.file.FileAlreadyExistsException\"))\n+                                  .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not a directory\"))\n@@ -181,1 +181,1 @@\n-        assertTrue(tr.exitValue !=0);\n+        assertTrue(tr.exitValue != 0);\n@@ -240,1 +240,1 @@\n-                                      .filter(s -> s.contains(\"is not writable\"))\n+                                      .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not writable\"))\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}