{"files":[{"patch":"@@ -29,2 +29,5 @@\n-\/\/ First VMReg value that could refer to a stack slot\n-VMReg VMRegImpl::stack0 = (VMReg)(intptr_t)((ConcreteRegisterImpl::number_of_registers + 7) & ~7);\n+\/\/ First VMReg value that could refer to a stack slot.  This is only\n+\/\/ used by SA and jvmti, but it's a leaky abstraction: SA and jvmti\n+\/\/ \"know\" that stack0 is an integer masquerading as a pointer. For the\n+\/\/ sake of those clients, we preserve this interface.\n+VMReg VMRegImpl::stack0 = (VMReg)VMRegImpl::stack_0()->value();\n@@ -52,0 +55,2 @@\n+VMRegImpl all_VMRegs[ConcreteRegisterImpl::number_of_registers + 1];\n+\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-\n-\n+  \/\/ Despite being private, this field is exported to the\n+  \/\/ serviceability agent and our friends. It's not really a pointer,\n+  \/\/ but that's fine and dandy as long as no-one tries to dereference\n+  \/\/ it.\n@@ -62,0 +64,2 @@\n+\n+  static constexpr VMReg first();\n@@ -66,1 +70,0 @@\n-\n@@ -69,1 +72,8 @@\n-  static VMReg  as_VMReg(int val, bool bad_ok = false) { assert(val > BAD_REG || bad_ok, \"invalid\"); return (VMReg) (intptr_t) val; }\n+  static constexpr VMReg stack_0() {\n+    return first() + ((ConcreteRegisterImpl::number_of_registers + 7) & ~7);\n+  }\n+\n+  static VMReg  as_VMReg(int val, bool bad_ok = false) {\n+    assert(val > BAD_REG || bad_ok, \"invalid\");\n+    return val + first();\n+  }\n@@ -81,3 +91,4 @@\n-  static VMReg Bad() { return (VMReg) (intptr_t) BAD_REG; }\n-  bool is_valid() const { return ((intptr_t) this) != BAD_REG; }\n-  bool is_stack() const { return (intptr_t) this >= (intptr_t) stack0; }\n+  intptr_t value() const { return this - first(); }\n+  static VMReg Bad() { return BAD_REG+first(); }\n+  bool is_valid() const { return value() != BAD_REG; }\n+  bool is_stack() const { return this >= stack_0(); }\n@@ -101,2 +112,2 @@\n-    assert((is_reg() && value() < stack0->value() - 1) || is_stack(), \"must be\");\n-    return (VMReg)(intptr_t)(value() + 1);\n+    assert((is_reg() && this < stack_0() - 1) || is_stack(), \"must be\");\n+    return this + 1;\n@@ -105,2 +116,2 @@\n-    assert((is_reg() && value() < stack0->value() - i) || is_stack(), \"must be\");\n-    return (VMReg)(intptr_t)(value() + i);\n+    assert((is_reg() && this < stack_0() - i) || is_stack(), \"must be\");\n+    return this + i;\n@@ -109,2 +120,2 @@\n-    assert((is_stack() && value() > stack0->value()) || (is_reg() && value() != 0), \"must be\");\n-    return (VMReg)(intptr_t)(value() - 1);\n+    assert((is_stack() && this > stack_0()) || (is_reg() && value() != 0), \"must be\");\n+    return this - 1;\n@@ -114,2 +125,0 @@\n-  intptr_t value() const         {return (intptr_t) this; }\n-\n@@ -134,1 +143,1 @@\n-    return (VMReg) (intptr_t) (stack0->value() + idx);\n+    return stack_0() + idx;\n@@ -139,1 +148,1 @@\n-    return value() - stack0->value();\n+    return this - stack_0();\n@@ -148,0 +157,3 @@\n+extern VMRegImpl all_VMRegs[ConcreteRegisterImpl::number_of_registers + 1] INTERNAL_VISIBILITY;\n+inline constexpr VMReg VMRegImpl::first() { return all_VMRegs + 1; }\n+\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    return VMRegImpl::stack0->value();\n+    return VMRegImpl::stack_0()->value();\n","filename":"src\/hotspot\/share\/opto\/optoreg.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}