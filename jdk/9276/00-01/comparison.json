{"files":[{"patch":"@@ -29,4 +29,5 @@\n-VMRegImpl all_VMRegs[ConcreteRegisterImpl::number_of_registers + 1];\n-\n-\/\/ First VMReg value that could refer to a stack slot\n-VMReg VMRegImpl::stack0 = VMRegImpl::stack_0();\n+\/\/ First VMReg value that could refer to a stack slot.  This is only\n+\/\/ used by SA and jvmti, but it's a leaky abstraction: SA and jvmti\n+\/\/ \"know\" that stack0 is an integer masquerading as a pointer. For the\n+\/\/ sake of those clients, we preserve this interface.\n+VMReg SharedInfo::stack0 = (VMReg)VMRegImpl::stack_0()->value();\n@@ -54,0 +55,2 @@\n+VMRegImpl all_VMRegs[ConcreteRegisterImpl::number_of_registers + 1];\n+\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,3 @@\n-  \/\/ serviceability agent and our friends.\n+  \/\/ serviceability agent and our friends. It's not really a pointer,\n+  \/\/ but that's fine and dandy as long as no-one tries to dereference\n+  \/\/ it.\n@@ -68,0 +70,2 @@\n+public:\n+\n@@ -72,2 +76,0 @@\n-public:\n-\n@@ -110,1 +112,1 @@\n-    assert((is_reg() && value() < stack0->value() - 1) || is_stack(), \"must be\");\n+    assert((is_reg() && this < stack_0() - 1) || is_stack(), \"must be\");\n@@ -114,1 +116,1 @@\n-    assert((is_reg() && value() < stack0->value() - i) || is_stack(), \"must be\");\n+    assert((is_reg() && this < stack_0() - i) || is_stack(), \"must be\");\n@@ -118,1 +120,1 @@\n-    assert((is_stack() && value() > stack0->value()) || (is_reg() && value() != 0), \"must be\");\n+    assert((is_stack() && this > stack_0()) || (is_reg() && value() != 0), \"must be\");\n@@ -161,1 +163,1 @@\n-\/\/ the calling convention's registers.  VMRegImpl::Bad is returned for any\n+ \/\/ the calling convention's registers.  VMRegImpl::Bad is returned for any\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-    \/\/ slots beyond OptoReg::stack0()\/VMRegImpl::stack0.  We need to convert this to\n+    \/\/ slots beyond OptoReg::stack0()\/SharedInfo::stack0.  We need to convert this to\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    return VMRegImpl::stack0->value();\n+    return VMRegImpl::stack_0()->value();\n","filename":"src\/hotspot\/share\/opto\/optoreg.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}