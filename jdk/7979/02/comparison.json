{"files":[{"patch":"@@ -2007,0 +2007,7 @@\n+      \/\/ Vector unsigned right shift for signed subword types behaves differently\n+      \/\/ from Java Spec. But when the shift amount is a constant not greater than\n+      \/\/ the number of sign extended bits, the unsigned right shift can be\n+      \/\/ vectorized to a signed right shift.\n+      if (VectorNode::can_transform_shift_op(p0, velt_basic_type(p0))) {\n+        opc = Op_RShiftI;\n+      }\n@@ -2559,0 +2566,7 @@\n+          \/\/ Vector unsigned right shift for signed subword types behaves differently\n+          \/\/ from Java Spec. But when the shift amount is a constant not greater than\n+          \/\/ the number of sign extended bits, the unsigned right shift can be\n+          \/\/ vectorized to a signed right shift.\n+          if (VectorNode::can_transform_shift_op(n, velt_basic_type(n))) {\n+            opc = Op_RShiftI;\n+          }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -414,0 +414,18 @@\n+bool VectorNode::can_transform_shift_op(Node* n, BasicType bt) {\n+  if (n->Opcode() != Op_URShiftI) {\n+    return false;\n+  }\n+  Node* in2 = n->in(2);\n+  if (!in2->is_Con()) {\n+    return false;\n+  }\n+  jint cnt = in2->get_int();\n+  \/\/ Only when shift amount is not greater than number of sign extended\n+  \/\/ bits (16 for short and 24 for byte), unsigned shift right on signed\n+  \/\/ subword types can be vectorized as vector signed shift.\n+  if ((bt == T_BYTE && cnt <= 24) || (bt == T_SHORT && cnt <= 16)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  static bool can_transform_shift_op(Node* n, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8283307\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement for unsigned shift right on signed subword types\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorizeURShiftSubword\n+ *\/\n+\n+public class TestVectorizeURShiftSubword {\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    final private static int NUM = 3000;\n+\n+    private short[] shorta = new short[NUM];\n+    private short[] shortb = new short[NUM];\n+    private byte[] bytea = new byte[NUM];\n+    private byte[] byteb = new byte[NUM];\n+\n+    private static final int[] SPECIALS = {\n+        0, 0x1, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x80, 0x81, 0x8F, 0xF3, 0xF8, 0xFF,\n+        0x38FF, 0x3FFF, 0x8F8F, 0x8FFF, 0x7FF3, 0x7FFF, 0xFF33, 0xFFF8, 0xFFFF, 0xFFFFFF,\n+        Integer.MAX_VALUE, Integer.MIN_VALUE\n+    };\n+\n+    public byte urshift(byte input, int amount) {\n+        return (byte) (input >>> amount);\n+    }\n+\n+    public short urshift(short input, int amount) {\n+        return (short) (input >>> amount);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=exclude,*.urshift\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.RSHIFT_VB, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    public void testByte0() {\n+        for(int i = 0; i < NUM; i++) {\n+            byteb[i] = (byte) (bytea[i] >>> 3);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.RSHIFT_VB, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    public void testByte1() {\n+        for(int i = 0; i < NUM; i++) {\n+            byteb[i] = (byte) (bytea[i] >>> 24);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.RSHIFT_VB, IRNode.STORE_VECTOR})\n+    public void testByte2() {\n+        for(int i = 0; i < NUM; i++) {\n+            byteb[i] = (byte) (bytea[i] >>> 25);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.RSHIFT_VS, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    public void testShort0() {\n+        for(int i = 0; i < NUM; i++) {\n+            shortb[i] = (short) (shorta[i] >>> 10);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.RSHIFT_VS, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    public void testShort1() {\n+        for(int i = 0; i < NUM; i++) {\n+            shortb[i] = (short) (shorta[i] >>> 16);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.RSHIFT_VS, IRNode.STORE_VECTOR})\n+    public void testShort2() {\n+        for(int i = 0; i < NUM; i++) {\n+            shortb[i] = (short) (shorta[i] >>> 17);\n+        }\n+    }\n+\n+    @Test\n+    public void checkTest() {\n+        testByte0();\n+        for (int i = 0; i < bytea.length; i++) {\n+            Asserts.assertEquals(byteb[i], urshift(bytea[i], 3));\n+        }\n+        testByte1();\n+        for (int i = 0; i < bytea.length; i++) {\n+            Asserts.assertEquals(byteb[i], urshift(bytea[i], 24));\n+        }\n+        testByte2();\n+        for (int i = 0; i < bytea.length; i++) {\n+            Asserts.assertEquals(byteb[i], urshift(bytea[i], 25));\n+        }\n+        testShort0();\n+        for (int i = 0; i < shorta.length; i++) {\n+            Asserts.assertEquals(shortb[i], urshift(shorta[i], 10));\n+        }\n+        testShort1();\n+        for (int i = 0; i < shorta.length; i++) {\n+            Asserts.assertEquals(shortb[i], urshift(shorta[i], 16));\n+        }\n+        testShort2();\n+        for (int i = 0; i < shorta.length; i++) {\n+            Asserts.assertEquals(shortb[i], urshift(shorta[i], 17));\n+        }\n+\n+    }\n+\n+    @Run(test = \"checkTest\")\n+    public void checkTest_runner() {\n+        for (int i = 0; i < SPECIALS.length; i++) {\n+            for (int j = 0; j < shorta.length; j++) {\n+                shorta[j] = (short) SPECIALS[i];\n+                bytea[j] = (byte) SPECIALS[i];\n+            }\n+            checkTest();\n+        }\n+        for (int j = 0; j < shorta.length; j++) {\n+            shorta[j] = (short) RANDOM.nextInt();;\n+            bytea[j] = (byte) RANDOM.nextInt();\n+        }\n+        checkTest();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizeURShiftSubword.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -157,0 +157,2 @@\n+    public static final String RSHIFT_VB = START + \"RShiftVB\" + MID + END;\n+    public static final String RSHIFT_VS = START + \"RShiftVS\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,2 +136,0 @@\n-    \/\/ Note that unsigned shift right on subword signed integer types can't\n-    \/\/ be vectorized since the sign extension bits would be lost.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,2 +183,0 @@\n-    \/\/ Note that unsigned shift right on subword signed integer types can\n-    \/\/ not be vectorized since the sign extension bit would be lost.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,2 +183,0 @@\n-    \/\/ Note that unsigned shift right on subword signed integer types can\n-    \/\/ not be vectorized since the sign extension bits would be lost.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,7 @@\n+    @Benchmark\n+    public void urShiftImmByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytesB[i] = (byte) (bytesA[i] >>> 3);\n+        }\n+    }\n+\n@@ -95,0 +102,7 @@\n+    @Benchmark\n+    public void urShiftImmShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shortsB[i] = (short) (shortsA[i] >>> 3);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorShiftRight.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}