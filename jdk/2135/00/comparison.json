{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.nio.file.*;\n-import java.io.IOException;\n-import java.util.*;\n@@ -50,2 +47,4 @@\n-    char[] normalizeNativePath(char[] path) {\n-        for (char c : path) {\n+    @Override\n+    String normalizeNativePath(String path) {\n+        for (int i = 0; i < path.length(); i++) {\n+            char c = path.charAt(i);\n@@ -53,1 +52,2 @@\n-                return normalizepath(path, kCFStringNormalizationFormD);\n+                return new String(normalizepath(path.toCharArray(),\n+                                  kCFStringNormalizationFormD));\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXNativeDispatcher.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -346,1 +346,1 @@\n-    char[] normalizeNativePath(char[] path) {\n+    String normalizeNativePath(String path) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.*;\n@@ -34,1 +33,0 @@\n-import java.lang.ref.SoftReference;\n@@ -40,1 +38,1 @@\n- * Solaris\/Linux implementation of java.nio.file.Path\n+ * Linux\/Mac implementation of java.nio.file.Path\n@@ -42,1 +40,0 @@\n-\n@@ -44,2 +41,0 @@\n-    private static ThreadLocal<SoftReference<CharsetEncoder>> encoder =\n-        new ThreadLocal<SoftReference<CharsetEncoder>>();\n@@ -47,1 +42,0 @@\n-    \/\/ FIXME - eliminate this reference to reduce space\n@@ -116,0 +110,3 @@\n+    private static final jdk.internal.access.JavaLangAccess JLA =\n+            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n+\n@@ -118,27 +115,4 @@\n-        SoftReference<CharsetEncoder> ref = encoder.get();\n-        CharsetEncoder ce = (ref != null) ? ref.get() : null;\n-        if (ce == null) {\n-            ce = Util.jnuEncoding().newEncoder()\n-                .onMalformedInput(CodingErrorAction.REPORT)\n-                .onUnmappableCharacter(CodingErrorAction.REPORT);\n-            encoder.set(new SoftReference<>(ce));\n-        }\n-\n-        char[] ca = fs.normalizeNativePath(input.toCharArray());\n-\n-        \/\/ size output buffer for worse-case size\n-        byte[] ba = new byte[(int)(ca.length * (double)ce.maxBytesPerChar())];\n-\n-        \/\/ encode\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        ce.reset();\n-        CoderResult cr = ce.encode(cb, bb, true);\n-        boolean error;\n-        if (!cr.isUnderflow()) {\n-            error = true;\n-        } else {\n-            cr = ce.flush(bb);\n-            error = !cr.isUnderflow();\n-        }\n-        if (error) {\n+        input = fs.normalizeNativePath(input);\n+        try {\n+            return JLA.getBytesNoRepl(input, Util.jnuEncoding());\n+        } catch (CharacterCodingException cce) {\n@@ -148,7 +122,0 @@\n-\n-        \/\/ trim result to actual length if required\n-        int len = bb.position();\n-        if (len != ba.length)\n-            ba = Arrays.copyOf(ba, len);\n-\n-        return ba;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":9,"deletions":42,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests the overheads of creating Paths from a File.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(time=2, iterations=5)\n+@Measurement(time=3, iterations=5)\n+@Fork(value=3, jvmArgs=\"-Xmx1g\")\n+public class FileToPath {\n+\n+    public String normalFile = \"\/test\/dir\/file\/name.txt\";\n+    public String root = \"\/\";\n+    public String trailingSlash = \"\/test\/dir\/file\/name.txt\/\";\n+    public String notNormalizedFile = \"\/test\/dir\/file\/\/name.txt\";\n+\n+\n+    @Benchmark\n+    public void mix(Blackhole bh)  {\n+        bh.consume(new File(normalFile).toPath());\n+        bh.consume(new File(trailingSlash).toPath());\n+        bh.consume(new File(root).toPath());\n+        bh.consume(new File(notNormalizedFile).toPath());\n+    }\n+\n+    @Benchmark\n+    public Path normalized() {\n+        return new File(normalFile).toPath();\n+    }\n+\n+    @Benchmark\n+    public Path trailingSlash() {\n+        return new File(trailingSlash).toPath();\n+    }\n+\n+    @Benchmark\n+    public Path notNormalized() {\n+        return new File(notNormalizedFile).toPath();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/FileToPath.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}