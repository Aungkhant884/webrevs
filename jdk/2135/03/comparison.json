{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.nio.file.*;\n-import java.io.IOException;\n-import java.util.*;\n@@ -50,2 +47,4 @@\n-    char[] normalizeNativePath(char[] path) {\n-        for (char c : path) {\n+    @Override\n+    String normalizeNativePath(String path) {\n+        for (int i = 0; i < path.length(); i++) {\n+            char c = path.charAt(i);\n@@ -53,1 +52,2 @@\n-                return normalizepath(path, kCFStringNormalizationFormD);\n+                return new String(normalizepath(path.toCharArray(),\n+                                  kCFStringNormalizationFormD));\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXNativeDispatcher.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -346,1 +346,1 @@\n-    char[] normalizeNativePath(char[] path) {\n+    String normalizeNativePath(String path) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.*;\n@@ -34,1 +33,3 @@\n-import java.lang.ref.SoftReference;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -40,1 +41,1 @@\n- * Solaris\/Linux implementation of java.nio.file.Path\n+ * Linux\/Mac implementation of java.nio.file.Path\n@@ -42,1 +43,0 @@\n-\n@@ -44,2 +44,0 @@\n-    private static ThreadLocal<SoftReference<CharsetEncoder>> encoder =\n-        new ThreadLocal<SoftReference<CharsetEncoder>>();\n@@ -47,1 +45,2 @@\n-    \/\/ FIXME - eliminate this reference to reduce space\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -118,27 +117,4 @@\n-        SoftReference<CharsetEncoder> ref = encoder.get();\n-        CharsetEncoder ce = (ref != null) ? ref.get() : null;\n-        if (ce == null) {\n-            ce = Util.jnuEncoding().newEncoder()\n-                .onMalformedInput(CodingErrorAction.REPORT)\n-                .onUnmappableCharacter(CodingErrorAction.REPORT);\n-            encoder.set(new SoftReference<>(ce));\n-        }\n-\n-        char[] ca = fs.normalizeNativePath(input.toCharArray());\n-\n-        \/\/ size output buffer for worse-case size\n-        byte[] ba = new byte[(int)(ca.length * (double)ce.maxBytesPerChar())];\n-\n-        \/\/ encode\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca);\n-        ce.reset();\n-        CoderResult cr = ce.encode(cb, bb, true);\n-        boolean error;\n-        if (!cr.isUnderflow()) {\n-            error = true;\n-        } else {\n-            cr = ce.flush(bb);\n-            error = !cr.isUnderflow();\n-        }\n-        if (error) {\n+        input = fs.normalizeNativePath(input);\n+        try {\n+            return JLA.getBytesNoRepl(input, Util.jnuEncoding());\n+        } catch (CharacterCodingException cce) {\n@@ -148,7 +124,0 @@\n-\n-        \/\/ trim result to actual length if required\n-        int len = bb.position();\n-        if (len != ba.length)\n-            ba = Arrays.copyOf(ba, len);\n-\n-        return ba;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":11,"deletions":42,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,1 +34,1 @@\n- * Tests the overheads of I\/O API.\n+ * Tests the overheads of creating File objects, and converting such objects to Paths.\n@@ -37,1 +37,1 @@\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@@ -44,4 +44,4 @@\n-    public String normalFile = \"\/test\/dir\/file\/name.txt\";\n-    public String root = \"\/\";\n-    public String trailingSlash = \"\/test\/dir\/file\/name.txt\/\";\n-    public String notNormalizedFile = \"\/test\/dir\/file\/\/name.txt\";\n+    private String normalFile = \"\/test\/dir\/file\/name.txt\";\n+    private String root = \"\/\";\n+    private String trailingSlash = \"\/test\/dir\/file\/name.txt\/\";\n+    private String notNormalizedFile = \"\/test\/dir\/file\/\/name.txt\";\n@@ -71,0 +71,5 @@\n+    @Benchmark\n+    public File root() {\n+        return new File(root);\n+    }\n+\n@@ -88,0 +93,28 @@\n+\n+    @Benchmark\n+    public void mixToPath(Blackhole bh)  {\n+        bh.consume(new File(normalFile).toPath());\n+        bh.consume(new File(root).toPath());\n+        bh.consume(new File(trailingSlash).toPath());\n+        bh.consume(new File(notNormalizedFile).toPath());\n+    }\n+\n+    @Benchmark\n+    public Path normalizedToPath() {\n+        return new File(normalFile).toPath();\n+    }\n+\n+    @Benchmark\n+    public Path rootToPath() {\n+        return new File(root).toPath();\n+    }\n+\n+    @Benchmark\n+    public Path trailingSlashToPath() {\n+        return new File(trailingSlash).toPath();\n+    }\n+\n+    @Benchmark\n+    public Path notNormalizedToPath() {\n+        return new File(notNormalizedFile).toPath();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/FileOpen.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"}]}