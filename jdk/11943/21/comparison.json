{"files":[{"patch":"@@ -67,1 +67,0 @@\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -148,1 +147,1 @@\n-    private Platform platform;\n+    private final Platform platform;\n@@ -154,0 +153,2 @@\n+     * @param launchers mapping of launcher command name to their module\/main class\n+     * @param targetPlatform target platform of the image\n@@ -155,0 +156,1 @@\n+     * @throws NullPointerException If any of the params is null\n@@ -156,1 +158,2 @@\n-    public DefaultImageBuilder(Path root, Map<String, String> launchers) throws IOException {\n+    public DefaultImageBuilder(Path root, Map<String, String> launchers, Platform targetPlatform)\n+            throws IOException {\n@@ -158,0 +161,1 @@\n+        this.platform = Objects.requireNonNull(targetPlatform);\n@@ -171,13 +175,0 @@\n-            String value = files.moduleView()\n-                                .findModule(\"java.base\")\n-                                .map(ResourcePoolModule::targetPlatform)\n-                                .orElse(null);\n-            if (value == null) {\n-                throw new PluginException(\"ModuleTarget attribute is missing for java.base module\");\n-            }\n-            try {\n-                this.platform = Platform.parsePlatform(value);\n-            } catch (IllegalArgumentException iae) {\n-                throw new PluginException(\"ModuleTarget is malformed: \" + iae.getMessage());\n-            }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-        private final ByteOrder endian;\n@@ -158,1 +157,0 @@\n-         * @param endian Jimage byte order. Native order by default\n@@ -163,1 +161,0 @@\n-                                  ByteOrder endian,\n@@ -167,1 +164,0 @@\n-            this.endian = Objects.requireNonNull(endian);\n@@ -171,7 +167,0 @@\n-        \/**\n-         * @return the byte ordering\n-         *\/\n-        public ByteOrder getByteOrder() {\n-            return endian;\n-        }\n-\n@@ -232,1 +221,0 @@\n-            builder.append(\"endian=\").append(endian).append(\"\\n\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -71,2 +72,0 @@\n-import jdk.tools.jlink.builder.DefaultImageBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -222,1 +221,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -358,0 +357,1 @@\n+                                    null,\n@@ -397,1 +397,0 @@\n-                                      options.endian,\n@@ -411,6 +410,7 @@\n-        ImageProvider imageProvider = createImageProvider(config,\n-                                                          options.packagedModulesPath,\n-                                                          options.ignoreSigning,\n-                                                          options.bindServices,\n-                                                          options.verbose,\n-                                                          log);\n+        ImageHelper imageProvider = createImageProvider(config,\n+                                                        options.packagedModulesPath,\n+                                                        options.ignoreSigning,\n+                                                        options.bindServices,\n+                                                        options.endian,\n+                                                        options.verbose,\n+                                                        log);\n@@ -420,1 +420,2 @@\n-            taskHelper.getPluginsConfig(options.output, options.launchers));\n+            taskHelper.getPluginsConfig(options.output, options.launchers,\n+                    imageProvider.targetPlatform));\n@@ -514,6 +515,7 @@\n-    private static ImageProvider createImageProvider(JlinkConfiguration config,\n-                                                     Path retainModulesPath,\n-                                                     boolean ignoreSigning,\n-                                                     boolean bindService,\n-                                                     boolean verbose,\n-                                                     PrintWriter log)\n+    private static ImageHelper createImageProvider(JlinkConfiguration config,\n+                                                   Path retainModulesPath,\n+                                                   boolean ignoreSigning,\n+                                                   boolean bindService,\n+                                                   ByteOrder endian,\n+                                                   boolean verbose,\n+                                                   PrintWriter log)\n@@ -566,1 +568,16 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        \/\/ determine the target platform of the image being created\n+        Platform targetPlatform = targetPlatform(cf, mods);\n+        \/\/ if the user specified any --endian, then it must match the target platform's native\n+        \/\/ endianness\n+        if (endian != null && endian != targetPlatform.arch().byteOrder()) {\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.target.endianness.mismatch\", endian, targetPlatform));\n+        }\n+        if (verbose && log != null) {\n+            Platform runtime = Platform.runtime();\n+            if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n+                log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n+                        targetPlatform.arch().byteOrder(), targetPlatform);\n+            }\n+        }\n+        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n@@ -612,0 +629,57 @@\n+    private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+        Path javaBasePath = modsPaths.get(\"java.base\");\n+        assert javaBasePath != null : \"java.base module path is missing\";\n+        if (isJavaBaseFromDefaultModulePath(javaBasePath)) {\n+            \/\/ this implies that the java.base module used for the target image\n+            \/\/ will correspond to the current platform. So this isn't an attempt to\n+            \/\/ build a cross-platform image. We use the current platform's endianness\n+            \/\/ in this case\n+            return Platform.runtime();\n+        } else {\n+            \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+            \/\/ find the target platform's arch and thus its endianness from the java.base\n+            \/\/ module's ModuleTarget attribute\n+            String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+            try {\n+                return Platform.parsePlatform(targetPlatformVal);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.unknown.target.platform\", targetPlatformVal));\n+            }\n+        }\n+    }\n+\n+    \/\/ returns true if the default module-path is the parent of the passed javaBasePath\n+    private static boolean isJavaBaseFromDefaultModulePath(Path javaBasePath) throws IOException {\n+        Path defaultModulePath = getDefaultModulePath();\n+        if (defaultModulePath == null) {\n+            return false;\n+        }\n+        \/\/ resolve, against the default module-path dir, the java.base module file used\n+        \/\/ for image creation\n+        Path javaBaseInDefaultPath = defaultModulePath.resolve(javaBasePath.getFileName());\n+        if (Files.notExists(javaBaseInDefaultPath)) {\n+            \/\/ the java.base module used for image creation doesn't exist in the default\n+            \/\/ module path\n+            return false;\n+        }\n+        return javaBasePath.toRealPath().equals(javaBaseInDefaultPath.toRealPath()) ;\n+    }\n+\n+    \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+    \/\/ throws IOException if the targetPlatform cannot be determined.\n+    private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+        Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+        assert javaBase.isPresent() : \"java.base module is missing\";\n+        ModuleReference ref = javaBase.get().reference();\n+        if (ref instanceof ModuleReferenceImpl modRefImpl\n+                && modRefImpl.moduleTarget() != null) {\n+            return modRefImpl.moduleTarget().targetPlatform();\n+        }\n+        \/\/ could not determine target platform\n+        throw new IOException(\n+                taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                        ref.location().map(URI::toString)\n+                                .orElse(\"java.base module\")));\n+    }\n+\n@@ -775,1 +849,1 @@\n-        final ByteOrder order;\n+        final Platform targetPlatform;\n@@ -783,1 +857,1 @@\n-                    ByteOrder order,\n+                    Platform targetPlatform,\n@@ -786,1 +860,2 @@\n-            this.order = order;\n+            Objects.requireNonNull(targetPlatform);\n+            this.targetPlatform = targetPlatform;\n@@ -860,1 +935,2 @@\n-            ExecutableImage image = ImageFileCreator.create(archives, order, stack);\n+            ExecutableImage image = ImageFileCreator.create(archives,\n+                    targetPlatform.arch().byteOrder(), stack);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":98,"deletions":22,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -53,4 +53,1 @@\n-        \/\/ Alias architecture names, if needed\n-        archName = archName.replace(\"amd64\", \"X64\");\n-        archName = archName.replace(\"s390x\", \"S390\");\n-        Architecture arch = Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n+        Architecture arch = Architecture.lookupByName(archName);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -412,2 +412,3 @@\n-        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers\n-                    ) throws IOException, BadArgs {\n+        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                      Platform targetPlatform)\n+                throws IOException, BadArgs {\n@@ -460,1 +461,1 @@\n-                builder = new DefaultImageBuilder(output, launchers);\n+                builder = new DefaultImageBuilder(output, launchers, targetPlatform);\n@@ -711,1 +712,2 @@\n-    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers)\n+    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                 Platform targetPlatform)\n@@ -713,1 +715,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,4 @@\n+err.cannot.determine.target.platform=cannot determine target platform from {0}\n+err.unknown.target.platform=unknown target platform {0}\n+err.target.endianness.mismatch=specified --endian {0} does not match endianness of target \\\n+platform {1}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -163,1 +164,1 @@\n-                mods, ByteOrder.nativeOrder(),\n+                mods,\n@@ -192,1 +193,2 @@\n-        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap());\n+        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.internal.util.OperatingSystem;\n+\n+\/*\n+ * @test\n+ * @bug 8206890\n+ * @summary verify that the image created through jlink uses the byte order of the target platform\n+ * @modules java.base\/jdk.internal.util\n+ * @comment the test asserts the presence of locale specific error message in the test's output,\n+ *          so we explicitly use en_US locale\n+ * @run main\/othervm -Duser.language=en -Duser.country=US JLinkEndianTest\n+ *\/\n+public class JLinkEndianTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+            .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n+\n+\n+    public static void main(final String[] args) throws Exception {\n+        testEndianMismatch();\n+        testCorrectEndian();\n+    }\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value doesn't match the target platform.\n+     * Asserts that the jlink process fails with an error.\n+     *\/\n+    private static void testEndianMismatch() throws Exception {\n+        \/\/ we use a --endian value which doesn't match the current platform's endianness.\n+        \/\/ this should cause the jlink image generation against the current platform to fail\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"big\" : \"little\";\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", \"image-should-not-have-been-created\"\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode == 0) {\n+            throw new AssertionError(\"jlink command was expected to fail but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ verify the failure was due to the expected error (message)\n+        if (!jlinkStdout.toString().contains(\"does not match endianness of target platform\")) {\n+            throw new AssertionError(\"jlink process' stderr didn't contain the expected\" +\n+                    \" error message\");\n+        }\n+    }\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value matches the target platform's endianness.\n+     * Asserts that the jlink process successfully creates the image.\n+     *\/\n+    private static void testCorrectEndian() throws Exception {\n+        \/\/ we use a --endian value which matches the current platform\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"little\" : \"big\";\n+        final Path imageOutDir = Path.of(\"correct-endian-image\");\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", imageOutDir.toString()\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode != 0) {\n+            throw new AssertionError(\"jlink command was expected to succeed but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ trivially verify <image-dir>\/bin\/java exists\n+        final Path javaBinary = OperatingSystem.isWindows()\n+                ? Path.of(imageOutDir.toString(), \"bin\", \"java.exe\")\n+                : Path.of(imageOutDir.toString(), \"bin\", \"java\");\n+        if (!Files.exists(javaBinary)) {\n+            throw new AssertionError(\"jlink image generation was expected to create \"\n+                    + javaBinary + \", but that file is missing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -64,1 +65,2 @@\n-        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap());\n+        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/ResourceDuplicateCheckTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}