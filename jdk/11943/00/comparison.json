{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -29,0 +31,1 @@\n+import java.nio.ByteOrder;\n@@ -30,0 +33,4 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -183,0 +190,44 @@\n+\n+    \/**\n+     * Tries to determine the {@link ByteOrder} of a image file present at {@code imageFile}.\n+     * The implementation reads the first few relevant bytes of the image file and compares it to\n+     * the expected magic bytes of a jimage. If those bytes correspond to the magic bytes, then\n+     * this method returns the ByteOrder of the image file, else it returns null.\n+     *\n+     * @param imageFile The path to the image file\n+     * @return The ByteOrder if one could be determined. Else null.\n+     *\/\n+    static ByteOrder tryDetectByteOrder(Path imageFile) {\n+        byte[] bytes = new byte[Integer.SIZE]; \/\/ read only as much as the size of magic bytes\n+        @SuppressWarnings(\"removal\")\n+        int numRead = AccessController.doPrivileged(\n+                new PrivilegedAction<Integer>() {\n+                    @Override\n+                    public Integer run() {\n+                        try (InputStream is = Files.newInputStream(imageFile)) {\n+                            return is.read(bytes);\n+                        } catch (IOException e) {\n+                            \/\/ ignore\n+                            return -1;\n+                        }\n+                    }\n+                });\n+        if (numRead != bytes.length) {\n+            \/\/ not enough bytes to ascertain if this is a jimage\n+            return null;\n+        }\n+        ByteBuffer bb = ByteBuffer.wrap(bytes);\n+        if (bb.getInt() == MAGIC) {\n+            return bb.order();\n+        }\n+        \/\/ try with the other byte order\n+        ByteOrder altByteOrder = bb.order() == ByteOrder.BIG_ENDIAN\n+                ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n+        bb.flip();\n+        bb.order(altByteOrder);\n+        if (bb.getInt() == MAGIC) {\n+            return bb.order();\n+        }\n+        \/\/ doesn't match the magic bytes\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,4 @@\n-        return open(imagePath, ByteOrder.nativeOrder());\n+        \/\/ try to determine the byte order of the image file\n+        ByteOrder detectedOrder = ImageHeader.tryDetectByteOrder(imagePath);\n+        ByteOrder byteOrder = detectedOrder != null ? detectedOrder : ByteOrder.nativeOrder();\n+        return open(imagePath, byteOrder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,2 +284,14 @@\n-        delete reader;\n-        return NULL;\n+        if (reader != NULL && reader->_invalid_magic) {\n+            \/\/ failed due to invalid magic bytes. now attempt with the other byte order\n+            delete reader;\n+            reader = new ImageFileReader(name, !big_endian);\n+            if (reader == NULL || !reader->open()) {\n+                \/\/ still failed to open.\n+                delete reader;\n+                return NULL;\n+            }\n+        } else {\n+            \/\/ failed to open for some other reason than invalid magic bytes in header\n+            delete reader;\n+            return NULL;\n+        }\n@@ -351,0 +363,1 @@\n+    _invalid_magic = false;\n@@ -380,3 +393,10 @@\n-        !read_at((u1*)&_header, header_size, 0) ||\n-        _header.magic(_endian) != IMAGE_MAGIC ||\n-        _header.major_version(_endian) != MAJOR_VERSION ||\n+        !read_at((u1*)&_header, header_size, 0)) {\n+        close();\n+        return false;\n+    }\n+    if (_header.magic(_endian) != IMAGE_MAGIC) {\n+        _invalid_magic = true;\n+        close();\n+        return false;\n+    }\n+    if (_header.major_version(_endian) != MAJOR_VERSION ||\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,0 +432,2 @@\n+    bool _invalid_magic; \/\/ true, if opening the image file failed due to the header having\n+                         \/\/ an invalid magic\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8206890\n+ * @summary Tests that a jlink image created using --endian option works fine when used to\n+ *          launch applications\n+ * @library \/test\/lib\n+ *\n+ * @run main JLinkEndianTest little\n+ * @run main JLinkEndianTest big\n+ * @run main JLinkEndianTest\n+ *\/\n+public class JLinkEndianTest {\n+\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+            .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n+\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    private static final String HELLO_WORLD_APP = \"\"\"\n+            public class Hello {\n+                public static void main(final String[] args) throws Exception {\n+                    System.out.print(\"Hello world\");\n+                }\n+            }\n+            \"\"\";\n+\n+    \/**\n+     * Launches {@code jlink} command with different {@code --endian} options and then launches\n+     * the {@code java} command from the newly created image and verifies that the launched\n+     * java process works fine without running into errors.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final String endian = args.length > 0 ? args[0] : \"\";\n+        final Path imageDir = Path.of(\".\", \"8206890\", System.currentTimeMillis() + endian);\n+        \/\/ invoke jlink:\n+        \/\/ jlink --add-modules java.base --add-modules jdk.compiler --output <path> --endian <endian>\n+        System.out.println(\"Creating image at \" + imageDir + \" with --endian=\" + endian);\n+        final String[] commonArgs = new String[]{\n+                \"--add-modules\", \"java.base\",\n+                \"--add-modules\", \"jdk.compiler\",\n+                \"--output\", imageDir.toAbsolutePath().toString()\n+        };\n+        final String[] jlinkArgs;\n+        if (!endian.isEmpty()) {\n+            jlinkArgs = Arrays.copyOf(commonArgs, commonArgs.length + 2);\n+            jlinkArgs[jlinkArgs.length - 2] = \"--endian\";\n+            jlinkArgs[jlinkArgs.length - 1] = endian;\n+        } else {\n+            jlinkArgs = commonArgs;\n+        }\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(jlinkArgs));\n+        final int jlinkExitCode = JLINK_TOOL.run(System.out, System.err, jlinkArgs);\n+        if (jlinkExitCode != 0) {\n+            throw new AssertionError(\"jlink execution failed with exit code \" + jlinkExitCode);\n+        }\n+        \/\/ verify the newly created image file is present\n+        final Path imageFile = Path.of(imageDir.toAbsolutePath().toString(), \"lib\", \"modules\");\n+        if (!Files.exists(imageFile)) {\n+            throw new AssertionError(imageFile + \" is missing\");\n+        }\n+        if (!Files.isRegularFile(imageFile)) {\n+            throw new AssertionError(imageFile + \" is not a file\");\n+        }\n+        \/\/ compile a trivial Java class which we will then launch using the newly generated image\n+        final Path helloWorldClassFile = compileApp();\n+        \/\/ now launch java from the created image and verify it launches correctly.\n+        launchJava(imageDir, helloWorldClassFile, false); \/\/ launch without security manager\n+        launchJava(imageDir, helloWorldClassFile, true); \/\/ launch with security manager\n+    }\n+\n+    private static Path compileApp() throws Exception {\n+        final Path tmpDir = Files.createTempDirectory(\"8206890\");\n+        final Path helloWorldJavaFile = Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.java\");\n+        \/\/ write out the .java file\n+        Files.writeString(helloWorldJavaFile, HELLO_WORLD_APP);\n+        \/\/ now compile it\n+        final String[] javacArgs = new String[]{\"-d\", tmpDir.toAbsolutePath().toString(),\n+                helloWorldJavaFile.toAbsolutePath().toString()};\n+        final int exitCode = JAVAC_TOOL.run(System.out, System.err, javacArgs);\n+        if (exitCode != 0) {\n+            throw new AssertionError(\"Failed to compile hello world app\");\n+        }\n+        final Path helloClassFile = Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.class\");\n+        if (!Files.exists(helloClassFile)) {\n+            throw new AssertionError(\"Compiled class file is missing at \" + helloClassFile);\n+        }\n+        System.out.println(\"Compiled Hello.class to \" + helloClassFile);\n+        \/\/ return the Path to the Hello.class file\n+        return Path.of(tmpDir.toAbsolutePath().toString(), \"Hello.class\");\n+    }\n+\n+    private static void launchJava(final Path imageDir, final Path helloWorldClassFile,\n+                                   final boolean withSecurityManager)\n+            throws Exception {\n+        \/\/ first try \"java --version\" from that created image\n+        final Path java = Path.of(imageDir.toAbsolutePath().toString(), \"bin\", \"java\");\n+        final String[] javaVersionCmd = new String[]{java.toAbsolutePath().toString(), \"-version\"};\n+        final String versionOutput = runProcess(javaVersionCmd, null).getStderr();\n+        System.out.println(\"java --version from newly created image returned: \" + versionOutput);\n+\n+        \/\/ now try launching a Java application from the newly created image\n+        final String[] helloWorldProcessCmd;\n+        if (withSecurityManager) {\n+            helloWorldProcessCmd = new String[]{\n+                    java.toAbsolutePath().toString(),\n+                    \"-cp\", \".\",\n+                    \"-Djava.security.manager=default\",\n+                    \"Hello\"\n+            };\n+        } else {\n+            helloWorldProcessCmd = new String[]{\n+                    java.toAbsolutePath().toString(),\n+                    \"-cp\", \".\",\n+                    \"Hello\"\n+            };\n+        }\n+        final String helloWorldOutput = runProcess(helloWorldProcessCmd,\n+                helloWorldClassFile.getParent().toFile()).getStdout();\n+        if (helloWorldOutput == null || !helloWorldOutput.equals(\"Hello world\")) {\n+            throw new AssertionError(\"Unexpected output from hello world application: \"\n+                    + helloWorldOutput);\n+        }\n+    }\n+\n+    \/\/ launches a process and asserts that the process exits with exit code 0.\n+    \/\/ returns the OutputAnalyzer instance of the completed process\n+    private static OutputAnalyzer runProcess(final String[] processCmd, final File workingDir)\n+            throws Exception {\n+        System.out.println(\"Launching process: \" + Arrays.toString(processCmd));\n+        final ProcessBuilder pb = new ProcessBuilder(processCmd).directory(workingDir);\n+        final OutputAnalyzer oa = ProcessTools.executeProcess(pb);\n+        final int exitCode = oa.getExitValue();\n+        if (exitCode != 0) {\n+            \/\/ dump the stdout and err of the completed process, for debugging\n+            oa.reportDiagnosticSummary();\n+            throw new AssertionError(\"Process execution failed with exit code: \" + exitCode);\n+        }\n+        return oa;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"}]}