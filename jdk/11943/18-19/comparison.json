{"files":[{"patch":"@@ -150,1 +150,0 @@\n-        private final ByteOrder endian;\n@@ -158,2 +157,0 @@\n-         * @param endian Jimage byte order. Can be null, which implies the byte order for\n-         *               the generated image will be determined during image generation\n@@ -164,1 +161,0 @@\n-                                  ByteOrder endian,\n@@ -168,1 +164,0 @@\n-            this.endian = endian;\n@@ -172,8 +167,0 @@\n-        \/**\n-         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n-         * explicitly set\n-         *\/\n-        public ByteOrder getByteOrder() {\n-            return endian;\n-        }\n-\n@@ -234,1 +221,0 @@\n-            builder.append(\"endian=\").append(endian).append(\"\\n\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-import jdk.tools.jlink.builder.DefaultImageBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -359,0 +357,1 @@\n+                                    null,\n@@ -398,1 +397,0 @@\n-                                      options.endian,\n@@ -413,5 +411,6 @@\n-                                                          options.packagedModulesPath,\n-                                                          options.ignoreSigning,\n-                                                          options.bindServices,\n-                                                          options.verbose,\n-                                                          log);\n+                                                        options.packagedModulesPath,\n+                                                        options.ignoreSigning,\n+                                                        options.bindServices,\n+                                                        options.endian,\n+                                                        options.verbose,\n+                                                        log);\n@@ -520,0 +519,1 @@\n+                                                   ByteOrder endian,\n@@ -568,2 +568,18 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning,\n-                verbose, log);\n+        \/\/ determine the target platform of the image being created\n+        Platform targetPlatform = targetPlatform(cf, mods);\n+        \/\/ if the user specified any --endian, then it must match the target platform's native\n+        \/\/ endianness\n+        if (endian != null && endian != targetPlatform.arch().byteOrder()) {\n+            \/\/ explicitly specified endianness doesn't match the determined endianness\n+            \/\/ of the target platform\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.target.endianness.mismatch\", endian, targetPlatform));\n+        }\n+        if (verbose && log != null) {\n+            Platform runtime = Platform.runtime();\n+            if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n+                log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n+                        targetPlatform.arch().byteOrder(), targetPlatform);\n+            }\n+        }\n+        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n@@ -615,0 +631,57 @@\n+    private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+        Path javaBasePath = modsPaths.get(\"java.base\");\n+        assert javaBasePath != null : \"java.base module path is missing\";\n+        if (isJavaBaseFromDefaultModulePath(javaBasePath)) {\n+            \/\/ this implies that the java.base module used for the target image\n+            \/\/ will correspond to the current platform. So this isn't an attempt to\n+            \/\/ build a cross-platform image. We use the current platform's endianness\n+            \/\/ in this case\n+            return Platform.runtime();\n+        } else {\n+            \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+            \/\/ find the target platform's arch and thus its endianness from the java.base\n+            \/\/ module's ModuleTarget attribute\n+            String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+            try {\n+                return Platform.parsePlatform(targetPlatformVal);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.unknown.target.platform\", targetPlatformVal));\n+            }\n+        }\n+    }\n+\n+    \/\/ returns true if the default module-path is the parent of the passed javaBasePath\n+    private static boolean isJavaBaseFromDefaultModulePath(Path javaBasePath) throws IOException {\n+        Path defaultModulePath = getDefaultModulePath();\n+        if (defaultModulePath == null) {\n+            return false;\n+        }\n+        \/\/ resolve, against the default module-path dir, the java.base module file used\n+        \/\/ for image creation\n+        Path javaBaseInDefaultPath = defaultModulePath.resolve(javaBasePath.getFileName());\n+        if (!Files.exists(javaBaseInDefaultPath)) {\n+            \/\/ the java.base module used for image creation doesn't exist in the default\n+            \/\/ module path\n+            return false;\n+        }\n+        return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n+    }\n+\n+    \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+    \/\/ throws IOException if the targetPlatform cannot be determined.\n+    private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+        Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+        assert javaBase.isPresent() : \"java.base module is missing\";\n+        ModuleReference ref = javaBase.get().reference();\n+        if (ref instanceof ModuleReferenceImpl modRefImpl\n+                && modRefImpl.moduleTarget() != null) {\n+            return modRefImpl.moduleTarget().targetPlatform();\n+        }\n+        \/\/ could not determine target platform\n+        throw new IOException(\n+                taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                        ref.location().map(URI::toString)\n+                                .orElse(\"java.base module\")));\n+    }\n+\n@@ -778,1 +851,1 @@\n-        final ByteOrder order;\n+        final Platform targetPlatform;\n@@ -783,1 +856,0 @@\n-        final Platform targetPlatform;\n@@ -787,1 +859,1 @@\n-                    ByteOrder order,\n+                    Platform targetPlatform,\n@@ -789,24 +861,3 @@\n-                    boolean ignoreSigning,\n-                    boolean verbose,\n-                    PrintWriter log) throws IOException {\n-            this.targetPlatform = targetPlatform(cf, modsPaths);\n-            ByteOrder targetPlatformEndianness = targetPlatform.arch().byteOrder();\n-            this.order = order != null ? order : targetPlatformEndianness;\n-            if (this.order == null) {\n-                throw new IOException(\n-                        taskHelper.getMessage(\"err.unknown.target.endianness\", targetPlatform));\n-            }\n-\n-            if (this.order != targetPlatformEndianness && targetPlatformEndianness != null) {\n-                \/\/ explicitly specified endianness doesn't match the determined endianness\n-                \/\/ of the target platform\n-                throw new IOException(\n-                        taskHelper.getMessage(\"err.target.endianness.mismatch\", order, targetPlatform));\n-            }\n-            if (verbose && log != null) {\n-                Platform runtime = Platform.runtime();\n-                if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n-                    log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n-                            this.order, targetPlatform);\n-                }\n-            }\n+                    boolean ignoreSigning) throws IOException {\n+            Objects.requireNonNull(targetPlatform);\n+            this.targetPlatform = targetPlatform;\n@@ -831,58 +882,0 @@\n-        private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n-            Path javaBasePath = modsPaths.get(\"java.base\");\n-            assert javaBasePath != null : \"java.base module path is missing\";\n-            if (isJavaBaseFromCurrentPlatform(javaBasePath)) {\n-                \/\/ this implies that the java.base module used for the target image\n-                \/\/ will correspond to the current platform. So this isn't an attempt to\n-                \/\/ build a cross-platform image. We use the current platform's endianness\n-                \/\/ in this case\n-                return Platform.runtime();\n-            } else {\n-                \/\/ this is an attempt to build a cross-platform image. We now attempt to\n-                \/\/ find the target platform's arch and thus its endianness from the java.base\n-                \/\/ module's ModuleTarget attribute\n-                String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n-                try {\n-                    return Platform.parsePlatform(targetPlatformVal);\n-                } catch (IllegalArgumentException iae) {\n-                    throw new IOException(\n-                            taskHelper.getMessage(\"err.unknown.target.platform\", targetPlatformVal));\n-                }\n-            }\n-        }\n-\n-        \/\/ returns true if the current platform's \"jmods\" directory is the parent of the\n-        \/\/ passed javaBasePath\n-        private static boolean isJavaBaseFromCurrentPlatform(Path javaBasePath) throws IOException {\n-            Path currentPlatformJmods = getDefaultModulePath();\n-            if (currentPlatformJmods == null) {\n-                return false;\n-            }\n-            \/\/ resolve, against the current platform's jmods dir, the java.base module file used\n-            \/\/ for image creation\n-            Path javaBaseInDefaultPath = currentPlatformJmods.resolve(javaBasePath.getFileName());\n-            if (!Files.exists(javaBaseInDefaultPath)) {\n-                \/\/ the java.base module used for image creation doesn't exist in the default\n-                \/\/ module path of current platform\n-                return false;\n-            }\n-            return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n-        }\n-\n-        \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n-        \/\/ throws IOException if the targetPlatform cannot be determined.\n-        private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n-            Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n-            assert javaBase.isPresent() : \"java.base module is missing\";\n-            ModuleReference ref = javaBase.get().reference();\n-            if (ref instanceof ModuleReferenceImpl modRefImpl\n-                    && modRefImpl.moduleTarget() != null) {\n-                return modRefImpl.moduleTarget().targetPlatform();\n-            }\n-            \/\/ could not determine target platform\n-            throw new IOException(\n-                    taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n-                            ref.location().map(URI::toString)\n-                                    .orElse(\"java.base module\")));\n-        }\n-\n@@ -944,1 +937,2 @@\n-            ExecutableImage image = ImageFileCreator.create(archives, order, stack);\n+            ExecutableImage image = ImageFileCreator.create(archives,\n+                    targetPlatform.arch().byteOrder(), stack);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":90,"deletions":96,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -53,4 +53,1 @@\n-        \/\/ Alias architecture names, if needed\n-        archName = archName.replace(\"amd64\", \"X64\");\n-        archName = archName.replace(\"s390x\", \"S390\");\n-        Architecture arch = Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n+        Architecture arch = Architecture.lookupByName(archName);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-err.unknown.target.endianness=Unknown native byte order for target platform {0}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-                mods, ByteOrder.nativeOrder(),\n+                mods,\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -30,0 +32,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -34,0 +38,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -45,0 +50,1 @@\n+        testCorrectEndian();\n@@ -79,0 +85,36 @@\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value matches the target platform's endianness.\n+     * Asserts that the jlink process successfully creates the image.\n+     *\/\n+    private static void testCorrectEndian() throws Exception {\n+        \/\/ we use a --endian value which matches the current platform\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"little\" : \"big\";\n+        final Path imageOutDir = Path.of(\"correct-endian-image\");\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", imageOutDir.toString()\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode != 0) {\n+            throw new AssertionError(\"jlink command was expected to succeed but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ trivially verify <image-dir>\/bin\/java exists\n+        final Path javaBinary = OperatingSystem.isWindows()\n+                ? Path.of(imageOutDir.toString(), \"bin\", \"java.exe\")\n+                : Path.of(imageOutDir.toString(), \"bin\", \"java\");\n+        if (!Files.exists(javaBinary)) {\n+            throw new AssertionError(\"jlink image generation was expected to create \"\n+                    + javaBinary + \", but that file is missing\");\n+        }\n+    }\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"}]}