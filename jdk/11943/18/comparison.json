{"files":[{"patch":"@@ -67,1 +67,0 @@\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -148,1 +147,1 @@\n-    private Platform platform;\n+    private final Platform platform;\n@@ -154,0 +153,2 @@\n+     * @param launchers mapping of launcher command name to their module\/main class\n+     * @param targetPlatform target platform of the image\n@@ -155,0 +156,1 @@\n+     * @throws NullPointerException If any of the params is null\n@@ -156,1 +158,2 @@\n-    public DefaultImageBuilder(Path root, Map<String, String> launchers) throws IOException {\n+    public DefaultImageBuilder(Path root, Map<String, String> launchers, Platform targetPlatform)\n+            throws IOException {\n@@ -158,0 +161,1 @@\n+        this.platform = Objects.requireNonNull(targetPlatform);\n@@ -171,13 +175,0 @@\n-            String value = files.moduleView()\n-                                .findModule(\"java.base\")\n-                                .map(ResourcePoolModule::targetPlatform)\n-                                .orElse(null);\n-            if (value == null) {\n-                throw new PluginException(\"ModuleTarget attribute is missing for java.base module\");\n-            }\n-            try {\n-                this.platform = Platform.parsePlatform(value);\n-            } catch (IllegalArgumentException iae) {\n-                throw new PluginException(\"ModuleTarget is malformed: \" + iae.getMessage());\n-            }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -158,1 +158,2 @@\n-         * @param endian Jimage byte order. Native order by default\n+         * @param endian Jimage byte order. Can be null, which implies the byte order for\n+         *               the generated image will be determined during image generation\n@@ -167,1 +168,1 @@\n-            this.endian = Objects.requireNonNull(endian);\n+            this.endian = endian;\n@@ -172,1 +173,2 @@\n-         * @return the byte ordering\n+         * @return the byte ordering, can be null which implies no specific ByteOrder has been\n+         * explicitly set\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -222,1 +223,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -411,1 +412,1 @@\n-        ImageProvider imageProvider = createImageProvider(config,\n+        ImageHelper imageProvider = createImageProvider(config,\n@@ -420,1 +421,2 @@\n-            taskHelper.getPluginsConfig(options.output, options.launchers));\n+            taskHelper.getPluginsConfig(options.output, options.launchers,\n+                    imageProvider.targetPlatform));\n@@ -514,6 +516,6 @@\n-    private static ImageProvider createImageProvider(JlinkConfiguration config,\n-                                                     Path retainModulesPath,\n-                                                     boolean ignoreSigning,\n-                                                     boolean bindService,\n-                                                     boolean verbose,\n-                                                     PrintWriter log)\n+    private static ImageHelper createImageProvider(JlinkConfiguration config,\n+                                                   Path retainModulesPath,\n+                                                   boolean ignoreSigning,\n+                                                   boolean bindService,\n+                                                   boolean verbose,\n+                                                   PrintWriter log)\n@@ -566,1 +568,2 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning,\n+                verbose, log);\n@@ -780,0 +783,1 @@\n+        final Platform targetPlatform;\n@@ -785,2 +789,24 @@\n-                    boolean ignoreSigning) throws IOException {\n-            this.order = order;\n+                    boolean ignoreSigning,\n+                    boolean verbose,\n+                    PrintWriter log) throws IOException {\n+            this.targetPlatform = targetPlatform(cf, modsPaths);\n+            ByteOrder targetPlatformEndianness = targetPlatform.arch().byteOrder();\n+            this.order = order != null ? order : targetPlatformEndianness;\n+            if (this.order == null) {\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.unknown.target.endianness\", targetPlatform));\n+            }\n+\n+            if (this.order != targetPlatformEndianness && targetPlatformEndianness != null) {\n+                \/\/ explicitly specified endianness doesn't match the determined endianness\n+                \/\/ of the target platform\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.target.endianness.mismatch\", order, targetPlatform));\n+            }\n+            if (verbose && log != null) {\n+                Platform runtime = Platform.runtime();\n+                if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n+                    log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n+                            this.order, targetPlatform);\n+                }\n+            }\n@@ -805,0 +831,58 @@\n+        private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+            Path javaBasePath = modsPaths.get(\"java.base\");\n+            assert javaBasePath != null : \"java.base module path is missing\";\n+            if (isJavaBaseFromCurrentPlatform(javaBasePath)) {\n+                \/\/ this implies that the java.base module used for the target image\n+                \/\/ will correspond to the current platform. So this isn't an attempt to\n+                \/\/ build a cross-platform image. We use the current platform's endianness\n+                \/\/ in this case\n+                return Platform.runtime();\n+            } else {\n+                \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+                \/\/ find the target platform's arch and thus its endianness from the java.base\n+                \/\/ module's ModuleTarget attribute\n+                String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+                try {\n+                    return Platform.parsePlatform(targetPlatformVal);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new IOException(\n+                            taskHelper.getMessage(\"err.unknown.target.platform\", targetPlatformVal));\n+                }\n+            }\n+        }\n+\n+        \/\/ returns true if the current platform's \"jmods\" directory is the parent of the\n+        \/\/ passed javaBasePath\n+        private static boolean isJavaBaseFromCurrentPlatform(Path javaBasePath) throws IOException {\n+            Path currentPlatformJmods = getDefaultModulePath();\n+            if (currentPlatformJmods == null) {\n+                return false;\n+            }\n+            \/\/ resolve, against the current platform's jmods dir, the java.base module file used\n+            \/\/ for image creation\n+            Path javaBaseInDefaultPath = currentPlatformJmods.resolve(javaBasePath.getFileName());\n+            if (!Files.exists(javaBaseInDefaultPath)) {\n+                \/\/ the java.base module used for image creation doesn't exist in the default\n+                \/\/ module path of current platform\n+                return false;\n+            }\n+            return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n+        }\n+\n+        \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+        \/\/ throws IOException if the targetPlatform cannot be determined.\n+        private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+            Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+            assert javaBase.isPresent() : \"java.base module is missing\";\n+            ModuleReference ref = javaBase.get().reference();\n+            if (ref instanceof ModuleReferenceImpl modRefImpl\n+                    && modRefImpl.moduleTarget() != null) {\n+                return modRefImpl.moduleTarget().targetPlatform();\n+            }\n+            \/\/ could not determine target platform\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                            ref.location().map(URI::toString)\n+                                    .orElse(\"java.base module\")));\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":96,"deletions":12,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -412,2 +412,3 @@\n-        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers\n-                    ) throws IOException, BadArgs {\n+        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                      Platform targetPlatform)\n+                throws IOException, BadArgs {\n@@ -460,1 +461,1 @@\n-                builder = new DefaultImageBuilder(output, launchers);\n+                builder = new DefaultImageBuilder(output, launchers, targetPlatform);\n@@ -711,1 +712,2 @@\n-    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers)\n+    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                 Platform targetPlatform)\n@@ -713,1 +715,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,5 @@\n+err.cannot.determine.target.platform=cannot determine target platform from {0}\n+err.unknown.target.platform=unknown target platform {0}\n+err.target.endianness.mismatch=specified --endian {0} does not match endianness of target \\\n+platform {1}\n+err.unknown.target.endianness=Unknown native byte order for target platform {0}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -192,1 +193,2 @@\n-        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap());\n+        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+\n+\/*\n+ * @test\n+ * @bug 8206890\n+ * @summary verify that the image created through jlink uses the byte order of the target platform\n+ * @comment the test asserts the presence of locale specific error message in the test's output,\n+ *          so we explicitly use en_US locale\n+ * @run main\/othervm -Duser.language=en -Duser.country=US JLinkEndianTest\n+ *\/\n+public class JLinkEndianTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+            .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n+\n+\n+    public static void main(final String[] args) throws Exception {\n+        testEndianMismatch();\n+    }\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value doesn't match the target platform.\n+     * Asserts that the jlink process fails with an error.\n+     *\/\n+    private static void testEndianMismatch() throws Exception {\n+        \/\/ we use a --endian value which doesn't match the current platform's endianness.\n+        \/\/ this should cause the jlink image generation against the current platform to fail\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"big\" : \"little\";\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", \"image-should-not-have-been-created\"\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode == 0) {\n+            throw new AssertionError(\"jlink command was expected to fail but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ verify the failure was due to the expected error (message)\n+        if (!jlinkStdout.toString().contains(\"does not match endianness of target platform\")) {\n+            throw new AssertionError(\"jlink process' stderr didn't contain the expected\" +\n+                    \" error message\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -64,1 +65,2 @@\n-        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap());\n+        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/ResourceDuplicateCheckTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}