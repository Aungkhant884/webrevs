{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import sun.net.www.protocol.http.AuthenticatorKeys;\n-\n@@ -75,1 +73,0 @@\n-    private final String key = AuthenticatorKeys.computeKey(this);\n@@ -579,7 +576,0 @@\n-\n-    static String getKey(Authenticator a) {\n-        return a.key;\n-    }\n-    static {\n-        AuthenticatorKeys.setAuthenticatorKeyAccess(Authenticator::getKey);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Authenticator.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import sun.net.www.protocol.http.AuthenticatorKeys;\n+import sun.net.www.protocol.http.AuthCacheImpl;\n@@ -119,0 +119,2 @@\n+    protected volatile AuthCacheImpl authcache;\n+\n@@ -170,2 +172,0 @@\n-    protected volatile String authenticatorKey;\n-\n@@ -352,2 +352,3 @@\n-                String ak = httpuc == null ? AuthenticatorKeys.DEFAULT\n-                     : httpuc.getAuthenticatorKey();\n+                AuthCacheImpl ak = httpuc == null\n+                    ? AuthCacheImpl.getDefault()\n+                    : httpuc.getAuthCache();\n@@ -355,1 +356,1 @@\n-                     && Objects.equals(ret.getAuthenticatorKey(), ak);\n+                     && Objects.equals(ret.getAuthCache(), ak);\n@@ -387,1 +388,1 @@\n-                ret.authenticatorKey = httpuc.getAuthenticatorKey();\n+                ret.authcache = httpuc.getAuthCache();\n@@ -425,4 +426,2 @@\n-    public final String getAuthenticatorKey() {\n-        String k = authenticatorKey;\n-        if (k == null) return AuthenticatorKeys.DEFAULT;\n-        return k;\n+    public final AuthCacheImpl getAuthCache() {\n+        return authcache == null ? AuthCacheImpl.getDefault() : authcache;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-     * A:[B:]C:D:E[:F][;key=value]   Between 4 and 6 fields separated by \":\",\n-     *          and an optional semicolon-separated key=value list postfix,\n+     * A:[B:]C:D:E[:F]  Between 4 and 6 fields separated by \":\",\n@@ -51,5 +50,0 @@\n-     * The semi-colon separated key=value list postfix can be used to\n-     * provide additional contextual information, thus allowing\n-     * to separate AuthCacheValue instances obtained from different\n-     * contexts.\n-     *\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthCache.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.net.Authenticator;\n+import java.util.Collections;\n@@ -31,0 +33,2 @@\n+import java.util.Map;\n+import java.util.WeakHashMap;\n@@ -108,0 +112,19 @@\n+\n+    private static final Map<Authenticator,AuthCacheImpl> caches =\n+        Collections.synchronizedMap(new WeakHashMap<>());\n+\n+    \/**\n+     * The default cache is stored under null key which is never garbage\n+     * collected.\n+     *\/\n+    public static AuthCacheImpl getDefault() {\n+        return getAuthCacheFor(null);\n+    }\n+\n+    \/**\n+     * Atomically check if a cache exists for given Authenticator and return it\n+     * or create one and return it\n+     *\/\n+    public static AuthCacheImpl getAuthCacheFor(Authenticator auth) {\n+        return caches.computeIfAbsent(auth, (k) -> new AuthCacheImpl());\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthCacheImpl.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.Serializable;\n@@ -38,4 +37,1 @@\n-public abstract class AuthCacheValue implements Serializable {\n-\n-    @java.io.Serial\n-    static final long serialVersionUID = 735249334068211611L;\n+public abstract class AuthCacheValue {\n@@ -49,1 +45,1 @@\n-     * Caches authentication info entered by user.  See cacheKey()\n+     * The default authentication cache\n@@ -51,5 +47,1 @@\n-    protected static AuthCache cache = new AuthCacheImpl();\n-\n-    public static void setAuthCache (AuthCache map) {\n-        cache = map;\n-    }\n+    protected static final AuthCacheImpl defCache = new AuthCacheImpl();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthCacheValue.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.util.function.Function;\n+import java.util.function.BiFunction;\n@@ -58,3 +58,0 @@\n-    @java.io.Serial\n-    static final long serialVersionUID = -2588378268010453259L;\n-\n@@ -79,1 +76,1 @@\n-    protected transient PasswordAuthentication pw;\n+    protected PasswordAuthentication pw;\n@@ -138,2 +135,4 @@\n-    private static AuthenticationInfo requestAuthentication(String key, Function<String, AuthenticationInfo> cache) {\n-        AuthenticationInfo cached = cache.apply(key);\n+    private static AuthenticationInfo requestAuthentication(\n+        String key, AuthCacheImpl acache, BiFunction<String, AuthCacheImpl, AuthenticationInfo> cachefunc)\n+    {\n+        AuthenticationInfo cached = cachefunc.apply(key, acache);\n@@ -150,1 +149,1 @@\n-            cached = cache.apply(key);\n+            cached = cachefunc.apply(key, acache);\n@@ -169,1 +168,1 @@\n-        return cache.apply(key);\n+        return cachefunc.apply(key, acache);\n@@ -189,4 +188,0 @@\n-    \/\/public String toString () {\n-        \/\/return (\"{\"+type+\":\"+authScheme+\":\"+protocol+\":\"+host+\":\"+port+\":\"+realm+\":\"+path+\"}\");\n-    \/\/}\n-\n@@ -221,9 +216,0 @@\n-    \/**\n-     * A key identifying the authenticator from which the credentials\n-     * were obtained.\n-     * {@link AuthenticatorKeys#DEFAULT} identifies the {@linkplain\n-     * java.net.Authenticator#setDefault(java.net.Authenticator) default}\n-     * authenticator.\n-     *\/\n-     String authenticatorKey;\n-\n@@ -232,1 +218,1 @@\n-                              int port, String realm, String authenticatorKey) {\n+                              int port, String realm) {\n@@ -240,1 +226,0 @@\n-        this.authenticatorKey = Objects.requireNonNull(authenticatorKey);\n@@ -256,2 +241,1 @@\n-    public AuthenticationInfo(char type, AuthScheme authScheme, URL url, String realm,\n-                              String authenticatorKey) {\n+    public AuthenticationInfo(char type, AuthScheme authScheme, URL url, String realm) {\n@@ -274,10 +258,0 @@\n-        this.authenticatorKey = Objects.requireNonNull(authenticatorKey);\n-    }\n-\n-    \/**\n-     * The {@linkplain java.net.Authenticator#getKey(java.net.Authenticator) key}\n-     * of the authenticator that was used to obtain the credentials.\n-     * @return The authenticator's key.\n-     *\/\n-    public final String getAuthenticatorKey() {\n-        return authenticatorKey;\n@@ -308,1 +282,1 @@\n-    static AuthenticationInfo getServerAuth(URL url, String authenticatorKey) {\n+    static AuthenticationInfo getServerAuth(URL url, AuthCacheImpl cache) {\n@@ -314,3 +288,2 @@\n-                + \":\" + url.getHost().toLowerCase() + \":\" + port\n-                + \";auth=\" + authenticatorKey;\n-        return getAuth(key, url);\n+                + \":\" + url.getHost().toLowerCase() + \":\" + port;\n+        return getAuth(key, url, cache);\n@@ -325,2 +298,1 @@\n-    static String getServerAuthKey(URL url, String realm, AuthScheme scheme,\n-                                   String authenticatorKey) {\n+    static String getServerAuthKey(URL url, String realm, AuthScheme scheme) {\n@@ -334,2 +306,1 @@\n-                     + \":\" + port + \":\" + realm\n-                     + \";auth=\" + authenticatorKey;\n+                     + \":\" + port + \":\" + realm;\n@@ -339,2 +310,2 @@\n-    private static AuthenticationInfo getCachedServerAuth(String key) {\n-        return getAuth(key, null);\n+    private static AuthenticationInfo getCachedServerAuth(String key, AuthCacheImpl cache) {\n+        return getAuth(key, null, cache);\n@@ -343,3 +314,3 @@\n-    static AuthenticationInfo getServerAuth(String key) {\n-        if (!serializeAuth) return getCachedServerAuth(key);\n-        return requestAuthentication(key, AuthenticationInfo::getCachedServerAuth);\n+    static AuthenticationInfo getServerAuth(String key, AuthCacheImpl cache) {\n+        if (!serializeAuth) return getCachedServerAuth(key, cache);\n+        return requestAuthentication(key, cache, AuthenticationInfo::getCachedServerAuth);\n@@ -348,1 +319,0 @@\n-\n@@ -353,1 +323,2 @@\n-    static AuthenticationInfo getAuth(String key, URL url) {\n+    static AuthenticationInfo getAuth(String key, URL url, AuthCacheImpl acache) {\n+        Objects.requireNonNull(acache);\n@@ -355,1 +326,1 @@\n-            return (AuthenticationInfo)cache.get (key, null);\n+            return (AuthenticationInfo)acache.get (key, null);\n@@ -357,1 +328,1 @@\n-            return (AuthenticationInfo)cache.get (key, url.getPath());\n+            return (AuthenticationInfo)acache.get (key, url.getPath());\n@@ -366,5 +337,4 @@\n-    static AuthenticationInfo getProxyAuth(String host, int port,\n-                                           String authenticatorKey) {\n-        String key = PROXY_AUTHENTICATION + \"::\" + host.toLowerCase() + \":\" + port\n-                     + \";auth=\" + authenticatorKey;\n-        AuthenticationInfo result = (AuthenticationInfo) cache.get(key, null);\n+    static AuthenticationInfo getProxyAuth(String host, int port, AuthCacheImpl acache) {\n+        Objects.requireNonNull(acache);\n+        String key = PROXY_AUTHENTICATION + \"::\" + host.toLowerCase() + \":\" + port;\n+        AuthenticationInfo result = (AuthenticationInfo) acache.get(key, null);\n@@ -379,2 +349,1 @@\n-    static String getProxyAuthKey(String host, int port, String realm,\n-                                  AuthScheme scheme, String authenticatorKey) {\n+    static String getProxyAuthKey(String host, int port, String realm, AuthScheme scheme) {\n@@ -383,2 +352,1 @@\n-                        + \":\" + port + \":\" + realm\n-                        + \";auth=\" + authenticatorKey;\n+                        + \":\" + port + \":\" + realm;\n@@ -388,2 +356,3 @@\n-    private static AuthenticationInfo getCachedProxyAuth(String key) {\n-        return (AuthenticationInfo) cache.get(key, null);\n+    private static AuthenticationInfo getCachedProxyAuth(String key, AuthCacheImpl acache) {\n+        Objects.requireNonNull(acache);\n+        return (AuthenticationInfo) acache.get(key, null);\n@@ -392,3 +361,3 @@\n-    static AuthenticationInfo getProxyAuth(String key) {\n-        if (!serializeAuth) return getCachedProxyAuth(key);\n-        return requestAuthentication(key, AuthenticationInfo::getCachedProxyAuth);\n+    static AuthenticationInfo getProxyAuth(String key, AuthCacheImpl acache) {\n+        if (!serializeAuth) return getCachedProxyAuth(key, acache);\n+        return requestAuthentication(key, acache, AuthenticationInfo::getCachedProxyAuth);\n@@ -401,1 +370,2 @@\n-    void addToCache() {\n+    void addToCache(AuthCacheImpl authcache) {\n+        Objects.requireNonNull(authcache);\n@@ -404,1 +374,1 @@\n-            cache.put(key, this);\n+            authcache.put(key, this);\n@@ -406,1 +376,1 @@\n-                cache.put(cacheKey(false), this);\n+                authcache.put(cacheKey(false), this);\n@@ -422,2 +392,3 @@\n-    void removeFromCache() {\n-        cache.remove(cacheKey(true), this);\n+    void removeFromCache(AuthCacheImpl authcache) {\n+        Objects.requireNonNull(authcache);\n+        authcache.remove(cacheKey(true), this);\n@@ -425,1 +396,1 @@\n-            cache.remove(cacheKey(false), this);\n+            authcache.remove(cacheKey(false), this);\n@@ -486,1 +457,0 @@\n-        String authenticatorKey = getAuthenticatorKey();\n@@ -489,2 +459,1 @@\n-                        + host + \":\" + port + \":\" + realm\n-                     + \";auth=\" + authenticatorKey;\n+                        + host + \":\" + port + \":\" + realm;\n@@ -492,2 +461,1 @@\n-            return type + \":\" + protocol + \":\" + host + \":\" + port\n-                     + \";auth=\" + authenticatorKey;\n+            return type + \":\" + protocol + \":\" + host + \":\" + port;\n@@ -497,26 +465,0 @@\n-    String s1, s2;  \/* used for serialization of pw *\/\n-\n-    @java.io.Serial\n-    \/\/ should be safe to keep synchronized here\n-    private synchronized void readObject(ObjectInputStream s)\n-        throws IOException, ClassNotFoundException\n-    {\n-        s.defaultReadObject ();\n-        pw = new PasswordAuthentication (s1, s2.toCharArray());\n-        s1 = null; s2= null;\n-        if (authenticatorKey == null) {\n-            authenticatorKey = AuthenticatorKeys.DEFAULT;\n-        }\n-    }\n-\n-    @java.io.Serial\n-    \/\/ should be safe to keep synchronized here\n-    private synchronized void writeObject(java.io.ObjectOutputStream s)\n-        throws IOException\n-    {\n-        Objects.requireNonNull(authenticatorKey);\n-        s1 = pw.getUserName();\n-        s2 = new String (pw.getPassword());\n-        s.defaultWriteObject ();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":46,"deletions":104,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.www.protocol.http;\n-\n-import java.net.Authenticator;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-\/**\n- *  A class used to tie a key to an authenticator instance.\n- *\/\n-public final class AuthenticatorKeys {\n-    private AuthenticatorKeys() {\n-        throw new InternalError(\"Trying to instantiate static class\");\n-    }\n-\n-    public static final String DEFAULT = \"default\";\n-    private static final AtomicLong IDS = new AtomicLong();\n-\n-    public static String computeKey(Authenticator a) {\n-        return System.identityHashCode(a) + \"-\" + IDS.incrementAndGet()\n-               + \"@\" + a.getClass().getName();\n-    }\n-\n-    \/**\n-     * Returns a key for the given authenticator.\n-     *\n-     * @param authenticator The authenticator; {@code null} should be\n-     *        passed when the {@linkplain\n-     *        Authenticator#setDefault(java.net.Authenticator) default}\n-     *        authenticator is meant.\n-     * @return A key for the given authenticator, {@link #DEFAULT} for\n-     *         {@code null}.\n-     *\/\n-    public static String getKey(Authenticator authenticator) {\n-        if (authenticator == null) {\n-            return DEFAULT;\n-        }\n-        return authenticatorKeyAccess.getKey(authenticator);\n-    }\n-\n-    @FunctionalInterface\n-    public interface AuthenticatorKeyAccess {\n-        public String getKey(Authenticator a);\n-    }\n-\n-    private static AuthenticatorKeyAccess authenticatorKeyAccess;\n-    public static void setAuthenticatorKeyAccess(AuthenticatorKeyAccess access) {\n-        if (authenticatorKeyAccess == null && access != null) {\n-            authenticatorKeyAccess = access;\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticatorKeys.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -66,1 +66,1 @@\n-                               boolean isUTF8, String authenticatorKey) {\n+                               boolean isUTF8) {\n@@ -68,2 +68,1 @@\n-              AuthScheme.BASIC, host, port, realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              AuthScheme.BASIC, host, port, realm);\n@@ -78,2 +77,1 @@\n-                               String realm, String auth,\n-                               String authenticatorKey) {\n+                               String realm, String auth) {\n@@ -81,2 +79,1 @@\n-              AuthScheme.BASIC, host, port, realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              AuthScheme.BASIC, host, port, realm);\n@@ -90,2 +87,1 @@\n-                               PasswordAuthentication pw, boolean isUTF8,\n-                               String authenticatorKey) {\n+                               PasswordAuthentication pw, boolean isUTF8) {\n@@ -93,2 +89,1 @@\n-              AuthScheme.BASIC, url, realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              AuthScheme.BASIC, url, realm);\n@@ -119,1 +114,1 @@\n-                               String auth, String authenticatorKey) {\n+                               String auth) {\n@@ -121,2 +116,1 @@\n-              AuthScheme.BASIC, url, realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              AuthScheme.BASIC, url, realm);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/BasicAuthentication.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-                                Parameters params, String authenticatorKey) {\n+                                Parameters params){\n@@ -303,2 +303,1 @@\n-              realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              realm);\n@@ -312,1 +311,1 @@\n-                                Parameters params, String authenticatorKey) {\n+                                Parameters params) {\n@@ -317,2 +316,1 @@\n-              realm,\n-              Objects.requireNonNull(authenticatorKey));\n+              realm);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/DigestAuthentication.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-    protected volatile String authenticatorKey;\n+    protected volatile AuthCacheImpl authCache = AuthCacheImpl.getDefault();\n@@ -450,1 +450,0 @@\n-\n@@ -542,1 +541,1 @@\n-            authenticatorKey = AuthenticatorKeys.getKey(authenticator);\n+            authCache = AuthCacheImpl.getAuthCacheFor(authenticator);\n@@ -548,4 +547,2 @@\n-    public String getAuthenticatorKey() {\n-        String k = authenticatorKey;\n-        if (k == null) return AuthenticatorKeys.getKey(authenticator);\n-        return k;\n+    public AuthCacheImpl getAuthCache() {\n+        return authCache;\n@@ -687,2 +684,1 @@\n-            AuthenticationInfo sauth = AuthenticationInfo.getServerAuth(url,\n-                                             getAuthenticatorKey());\n+            AuthenticationInfo sauth = AuthenticationInfo.getServerAuth(url, authCache);\n@@ -1772,1 +1768,1 @@\n-                    proxyAuthentication.addToCache();\n+                    proxyAuthentication.addToCache(authCache);\n@@ -1820,1 +1816,1 @@\n-                                serverAuthentication.removeFromCache();\n+                                serverAuthentication.removeFromCache(authCache);\n@@ -1861,1 +1857,1 @@\n-                            serverAuthentication.removeFromCache();\n+                            serverAuthentication.removeFromCache(authCache);\n@@ -1865,1 +1861,1 @@\n-                        serverAuthentication.addToCache();\n+                        serverAuthentication.addToCache(authCache);\n@@ -1881,2 +1877,2 @@\n-                                                   digestparams, srv.authenticatorKey);\n-                                d.addToCache ();\n+                                                   digestparams);\n+                                d.addToCache (authCache);\n@@ -2093,1 +2089,1 @@\n-                proxyAuthentication.removeFromCache();\n+                proxyAuthentication.removeFromCache(authCache);\n@@ -2234,1 +2230,1 @@\n-                    proxyAuthentication.addToCache();\n+                    proxyAuthentication.addToCache(authCache);\n@@ -2336,1 +2332,1 @@\n-                                              getAuthenticatorKey());\n+                                              authCache);\n@@ -2396,3 +2392,2 @@\n-            proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm,\n-                                authScheme, getAuthenticatorKey());\n-            ret = AuthenticationInfo.getProxyAuth(proxyAuthKey);\n+            proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm, authScheme);\n+            ret = AuthenticationInfo.getProxyAuth(proxyAuthKey, authCache);\n@@ -2421,2 +2416,1 @@\n-                        ret = new BasicAuthentication(true, host, port, realm, a,\n-                                             isUTF8, getAuthenticatorKey());\n+                        ret = new BasicAuthentication(true, host, port, realm, a, isUTF8);\n@@ -2434,2 +2428,1 @@\n-                                             scheme, a, params,\n-                                             getAuthenticatorKey());\n+                                             scheme, a, params);\n@@ -2474,2 +2467,1 @@\n-                            ret = NTLMAuthenticationProxy.proxy.create(true, host,\n-                                    port, a, getAuthenticatorKey());\n+                            ret = NTLMAuthenticationProxy.proxy.create(true, host, port, a);\n@@ -2507,2 +2499,1 @@\n-                        ret = new BasicAuthentication (true, host, port, realm, a,\n-                                  getAuthenticatorKey());\n+                        ret = new BasicAuthentication (true, host, port, realm, a);\n@@ -2569,3 +2560,2 @@\n-            serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme,\n-                                               getAuthenticatorKey());\n-            ret = AuthenticationInfo.getServerAuth(serverAuthKey);\n+            serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme);\n+            ret = AuthenticationInfo.getServerAuth(serverAuthKey, authCache);\n@@ -2600,2 +2590,1 @@\n-                        ret = new BasicAuthentication(false, url, realm, a,\n-                                    isUTF8, getAuthenticatorKey());\n+                        ret = new BasicAuthentication(false, url, realm, a, isUTF8);\n@@ -2612,2 +2601,1 @@\n-                                    a, digestparams,\n-                                    getAuthenticatorKey());\n+                                    a, digestparams);\n@@ -2658,2 +2646,1 @@\n-                            ret = NTLMAuthenticationProxy.proxy.create(false,\n-                                     url1, a, getAuthenticatorKey());\n+                            ret = NTLMAuthenticationProxy.proxy.create(false, url1, a);\n@@ -2683,2 +2670,1 @@\n-                    ret = new BasicAuthentication (false, url, realm, a,\n-                                    getAuthenticatorKey());\n+                    ret = new BasicAuthentication (false, url, realm, a);\n@@ -2935,1 +2921,1 @@\n-                            AuthenticationInfo.getServerAuth(url, getAuthenticatorKey());\n+                            AuthenticationInfo.getServerAuth(url, authCache);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":27,"deletions":41,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    private final Constructor<? extends AuthenticationInfo> threeArgCtr;\n@@ -49,1 +50,0 @@\n-    private final Constructor<? extends AuthenticationInfo> sixArgCtr;\n@@ -51,2 +51,3 @@\n-    private NTLMAuthenticationProxy(Constructor<? extends AuthenticationInfo> fourArgCtr,\n-                                    Constructor<? extends AuthenticationInfo> sixArgCtr) {\n+    private NTLMAuthenticationProxy(Constructor<? extends AuthenticationInfo> threeArgCtr,\n+                                    Constructor<? extends AuthenticationInfo> fourArgCtr) {\n+        this.threeArgCtr = threeArgCtr;\n@@ -54,1 +55,0 @@\n-        this.sixArgCtr = sixArgCtr;\n@@ -60,2 +60,1 @@\n-                              PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+                              PasswordAuthentication pw) {\n@@ -63,1 +62,1 @@\n-            return fourArgCtr.newInstance(isProxy, url, pw, authenticatorKey);\n+            return threeArgCtr.newInstance(isProxy, url, pw);\n@@ -74,2 +73,1 @@\n-                              PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+                              PasswordAuthentication pw) {\n@@ -77,1 +75,1 @@\n-            return sixArgCtr.newInstance(isProxy, host, port, pw, authenticatorKey);\n+            return fourArgCtr.newInstance(isProxy, host, port, pw);\n@@ -120,1 +118,1 @@\n-        Constructor<? extends AuthenticationInfo> fourArg, sixArg;\n+        Constructor<? extends AuthenticationInfo> fourArg, fiveArg;\n@@ -126,3 +124,2 @@\n-                                             PasswordAuthentication.class,\n-                                             String.class);\n-                sixArg = cl.getConstructor(boolean.class,\n+                                             PasswordAuthentication.class);\n+                fiveArg = cl.getConstructor(boolean.class,\n@@ -131,2 +128,1 @@\n-                                            PasswordAuthentication.class,\n-                                            String.class);\n+                                            PasswordAuthentication.class);\n@@ -136,1 +132,1 @@\n-                                                   sixArg);\n+                                                   fiveArg);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NTLMAuthenticationProxy.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -83,3 +83,1 @@\n-              hci.url,\n-              \"\",\n-              AuthenticatorKeys.getKey(hci.authenticator));\n+              hci.url, \"\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import sun.net.www.protocol.http.AuthenticatorKeys;\n+import sun.net.www.protocol.http.AuthCacheImpl;\n@@ -338,2 +338,1 @@\n-                String ak = httpuc == null ? AuthenticatorKeys.DEFAULT\n-                     : httpuc.getAuthenticatorKey();\n+                AuthCacheImpl ak = httpuc == null ? null : httpuc.getAuthCache();\n@@ -342,1 +341,1 @@\n-                     && Objects.equals(ret.getAuthenticatorKey(), ak);\n+                     && Objects.equals(ret.getAuthCache(), ak);\n@@ -380,1 +379,1 @@\n-                ret.authenticatorKey = httpuc.getAuthenticatorKey();\n+                ret.authcache = httpuc.getAuthCache();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -134,2 +134,1 @@\n-    public NTLMAuthentication(boolean isProxy, URL url, PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+    public NTLMAuthentication(boolean isProxy, URL url, PasswordAuthentication pw) {\n@@ -138,3 +137,1 @@\n-                url,\n-                \"\",\n-                Objects.requireNonNull(authenticatorKey));\n+                url, \"\");\n@@ -177,2 +174,1 @@\n-                              PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+                              PasswordAuthentication pw) {\n@@ -183,2 +179,1 @@\n-                \"\",\n-                Objects.requireNonNull(authenticatorKey));\n+                \"\");\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -122,2 +122,1 @@\n-    public NTLMAuthentication(boolean isProxy, URL url, PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+    public NTLMAuthentication(boolean isProxy, URL url, PasswordAuthentication pw) {\n@@ -127,2 +126,1 @@\n-              \"\",\n-              Objects.requireNonNull(authenticatorKey));\n+              \"\");\n@@ -158,2 +156,1 @@\n-                              PasswordAuthentication pw,\n-                              String authenticatorKey) {\n+                              PasswordAuthentication pw) {\n@@ -164,2 +161,1 @@\n-              \"\",\n-              Objects.requireNonNull(authenticatorKey));\n+              \"\");\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/http\/ntlm\/NTLMAuthentication.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,337 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Note: this test saves a cache.ser file in the scratch directory,\n-\/\/       which the cache implementation will load its configuration\n-\/\/       from. Therefore adding several @run lines does not work.\n-\n-\/*\n- * @test\n- * @bug 4933582\n- * @key intermittent\n- * @library \/test\/lib\n- * @modules java.base\/sun.net.www\n- *          java.base\/sun.net.www.protocol.http\n- *\n- * @run main\/othervm B4933582\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.PrintWriter;\n-import java.net.Authenticator;\n-import java.net.BindException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.PasswordAuthentication;\n-import java.net.ProxySelector;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.concurrent.Executors;\n-\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-import jdk.test.lib.net.URIBuilder;\n-import sun.net.www.protocol.http.AuthCacheImpl;\n-import sun.net.www.protocol.http.AuthCacheValue;\n-\n-public class B4933582 implements HttpHandler {\n-\n-    static int count = 0;\n-    static String authstring;\n-\n-    void errorReply (HttpExchange req, String reply) throws IOException {\n-        req.getResponseHeaders().set(\"Connection\", \"close\");\n-        req.getResponseHeaders().set(\"WWW-Authenticate\", reply);\n-        req.sendResponseHeaders(401, -1);\n-    }\n-\n-    void okReply (HttpExchange req) throws IOException {\n-        req.sendResponseHeaders(200, 0);\n-        try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n-            pw.print(\"Hello .\");\n-        }\n-    }\n-\n-    static volatile boolean firstTime = true;\n-\n-    public void handle (HttpExchange req) {\n-        try {\n-            if(req.getRequestHeaders().get(\"Authorization\") != null) {\n-                authstring = req.getRequestHeaders().get(\"Authorization\").get(0);\n-                System.out.println(authstring);\n-            }\n-            if (firstTime) {\n-                switch (count) {\n-                case 0:\n-                    errorReply (req, \"Basic realm=\\\"wallyworld\\\"\");\n-                    break;\n-                case 1:\n-                    \/* client stores a username\/pw for wallyworld\n-                     *\/\n-                    save (authstring);\n-                    okReply (req);\n-                    break;\n-                }\n-            } else {\n-                \/* check the auth string is premptively set from last time *\/\n-                String savedauth = retrieve();\n-                if (savedauth.equals (authstring)) {\n-                    okReply (req);\n-                } else {\n-                    System.out.println (\"savedauth = \" + savedauth);\n-                    System.out.println (\"authstring = \" + authstring);\n-                    errorReply (req, \"Basic realm=\\\"wallyworld\\\"\");\n-                }\n-            }\n-            count ++;\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    void save (String s) {\n-        try {\n-            FileOutputStream f = new FileOutputStream (\"auth.save\");\n-            ObjectOutputStream os = new ObjectOutputStream (f);\n-            os.writeObject (s);\n-        } catch (IOException e) {\n-            assert false;\n-        }\n-    }\n-\n-    String retrieve () {\n-        String s = null;\n-        try {\n-            FileInputStream f = new FileInputStream (\"auth.save\");\n-            ObjectInputStream is = new ObjectInputStream (f);\n-            s = (String) is.readObject();\n-        } catch (Exception e) {\n-            assert false;\n-        }\n-        return s;\n-    }\n-\n-    static void read (InputStream is) throws IOException {\n-        int c;\n-        System.out.println (\"reading\");\n-        while ((c=is.read()) != -1) {\n-            System.out.write (c);\n-        }\n-        System.out.println (\"\");\n-        System.out.println (\"finished reading\");\n-    }\n-\n-    static void client (String u) throws Exception {\n-        URL url = new URL (u);\n-        System.out.println (\"client opening connection to: \" + u);\n-        URLConnection urlc = url.openConnection ();\n-        try(InputStream is = urlc.getInputStream ()) {\n-            read (is);\n-        }\n-    }\n-\n-    static HttpServer server;\n-\n-    public static void main (String[] args) throws Exception {\n-        B4933582 b4933582 = new B4933582();\n-        MyAuthenticator auth = new MyAuthenticator ();\n-        Authenticator.setDefault (auth);\n-        ProxySelector.setDefault(ProxySelector.of(null)); \/\/ no proxy\n-        InetAddress loopback = InetAddress.getLoopbackAddress();\n-        CacheImpl cache;\n-        try {\n-            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10);\n-            server.createContext(\"\/\", b4933582);\n-            server.setExecutor(Executors.newSingleThreadExecutor());\n-            server.start();\n-            cache = new CacheImpl (server.getAddress().getPort());\n-            AuthCacheValue.setAuthCache (cache);\n-            String serverURL = URIBuilder.newBuilder()\n-                .scheme(\"http\")\n-                .loopback()\n-                .port(server.getAddress().getPort())\n-                .path(\"\/\")\n-                .build()\n-                .toString();\n-            client(serverURL + \"d1\/foo.html\");\n-        } finally {\n-            if (server != null) {\n-                server.stop(1);\n-            }\n-        }\n-\n-        int f = auth.getCount();\n-        if (f != 1) {\n-            except(\"Authenticator was called \" + f + \" times. Should be 1\");\n-        }\n-\n-        firstTime = false;\n-\n-        int retries = 0;\n-        cache = new CacheImpl();\n-        while (true) {\n-            try {\n-                server = HttpServer.create(new InetSocketAddress(loopback, cache.getPort()), 10);\n-                server.createContext(\"\/\", b4933582);\n-                server.setExecutor(Executors.newSingleThreadExecutor());\n-                server.start();\n-                break;\n-            } catch (BindException e) {\n-                if (retries++ < 5) {\n-                    Thread.sleep(200L);\n-                    System.out.println(\"BindException \\\"\" + e.getMessage()\n-                            + \"\\\", retrying...\");\n-                    continue;\n-                } else {\n-                    throw e;\n-                }\n-            }\n-        }\n-\n-        try {\n-            AuthCacheValue.setAuthCache(cache);\n-            String serverURL = URIBuilder.newBuilder()\n-                .scheme(\"http\")\n-                .loopback()\n-                .port(server.getAddress().getPort())\n-                .path(\"\/\")\n-                .build()\n-                .toString();\n-            client(serverURL + \"d1\/foo.html\");\n-        } finally {\n-            if (server != null) {\n-                server.stop(1);\n-            }\n-        }\n-\n-        f = auth.getCount();\n-        if (f != 1) {\n-            except(\"Authenticator was called \" + f + \" times. Should be 1\");\n-        }\n-    }\n-\n-    public static void except (String s) {\n-        server.stop(1);\n-        throw new RuntimeException (s);\n-    }\n-\n-    static class MyAuthenticator extends Authenticator {\n-        MyAuthenticator () {\n-            super ();\n-        }\n-\n-        volatile int count = 0;\n-\n-        public PasswordAuthentication getPasswordAuthentication () {\n-            PasswordAuthentication pw;\n-            pw = new PasswordAuthentication (\"user\", \"pass1\".toCharArray());\n-            count ++;\n-            return pw;\n-        }\n-\n-        public int getCount () {\n-            return (count);\n-        }\n-    }\n-\n-    static class CacheImpl extends AuthCacheImpl {\n-        HashMap<String,LinkedList<AuthCacheValue>> map;\n-        int port; \/\/ need to store the port number the server is using\n-\n-        CacheImpl () throws IOException {\n-            this (-1);\n-        }\n-\n-        CacheImpl (int port) throws IOException {\n-            super();\n-            this.port = port;\n-            File src = new File (\"cache.ser\");\n-            if (src.exists()) {\n-                try (ObjectInputStream is = new ObjectInputStream(\n-                        new FileInputStream(src))) {\n-                    map = (HashMap<String,LinkedList<AuthCacheValue>>)is\n-                              .readObject();\n-                    this.port = (Integer)is.readObject ();\n-                    System.out.println (\"read port from file \" + port);\n-                } catch (ClassNotFoundException e) {\n-                    assert false;\n-                }\n-                System.out.println (\"setMap from cache.ser\");\n-            } else {\n-                map = new HashMap<>();\n-            }\n-            setMap (map);\n-        }\n-\n-        int getPort () {\n-            return port;\n-        }\n-\n-        private void writeMap () {\n-            File dst = new File(\"cache.ser\");\n-            try {\n-                dst.delete();\n-                if (!dst.createNewFile()) {\n-                    return;\n-                }\n-            } catch (IOException e) {\n-            }\n-\n-            try (ObjectOutputStream os = new ObjectOutputStream(\n-                    new FileOutputStream(dst))) {\n-                os.writeObject(map);\n-                os.writeObject(port);\n-                System.out.println(\"wrote port \" + port);\n-            } catch (IOException e) {\n-            }\n-        }\n-\n-        public void put (String pkey, AuthCacheValue value) {\n-            System.out.println (\"put: \" + pkey + \" \" + value);\n-            super.put (pkey, value);\n-            writeMap();\n-        }\n-\n-        public AuthCacheValue get (String pkey, String skey) {\n-            System.out.println (\"get: \" + pkey + \" \" + skey);\n-            AuthCacheValue i = super.get (pkey, skey);\n-            System.out.println (\"---> \" + i);\n-            return i;\n-        }\n-\n-        public void remove (String pkey, AuthCacheValue value) {\n-            System.out.println (\"remove: \" + pkey + \" \" + value);\n-            super.remove (pkey, value);\n-            writeMap();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/Authenticator\/B4933582.java","additions":0,"deletions":337,"binary":false,"changes":337,"status":"deleted"},{"patch":"@@ -124,1 +124,0 @@\n-\n@@ -286,1 +285,1 @@\n-        return sun.net.www.protocol.http.AuthenticatorKeys.getKey(a);\n+        return a == null ? \"null\" : a.toString();\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPSetAuthenticatorTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304818\n+ * @modules java.base\/sun.net.www.protocol.http\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.ForceGC\n+ * @run main\/othervm AuthCache\n+ *\/\n+\n+import com.sun.net.httpserver.BasicAuthenticator;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import java.io.IOException;\n+import java.lang.ref.PhantomReference;\n+import java.net.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+public class AuthCache {\n+    static class ClientAuth extends Authenticator {\n+        private final String realm;\n+        private final String username;\n+        private final String password;\n+        private AtomicBoolean wasCalled = new AtomicBoolean();\n+\n+        private String errorMsg;\n+\n+        ClientAuth(String realm, String username, String password) {\n+            this.realm = realm;\n+            this.username = username;\n+            this.password = password;\n+        }\n+\n+        \/**\n+         * returns true if getPasswordAuthentication() was called\n+         * since the last time this method was called. The wasCalled\n+         * flag is cleared after each call.\n+         * If an error occurred, a RuntimeException is thrown\n+         * @return\n+         *\/\n+        public synchronized boolean wasCalled() {\n+            if (errorMsg != null)\n+                throw new RuntimeException(errorMsg);\n+\n+            return wasCalled.getAndSet(false);\n+        }\n+        protected synchronized PasswordAuthentication getPasswordAuthentication() {\n+            if (!getRequestingPrompt().equals(realm)) {\n+                errorMsg = String.format(\"Error: %s expected as realm, received %s\", realm, getRequestingPrompt());\n+            }\n+            wasCalled.set(true);\n+            return new PasswordAuthentication(username, password.toCharArray());\n+        }\n+    }\n+\n+    static final HttpHandler handler = (HttpExchange exch) -> {\n+        exch.sendResponseHeaders(200, -1);\n+        exch.close();\n+    };\n+\n+    static class ServerAuth extends BasicAuthenticator {\n+        private final String user, pass;\n+\n+        ServerAuth(String realm, String user, String pass) {\n+            super(realm);\n+            this.user = user;\n+            this.pass = pass;\n+        }\n+\n+        @Override\n+        public boolean checkCredentials(String username, String password) {\n+            return username.equals(user) && password.equals(pass);\n+        }\n+    }\n+\n+    \/**\n+     * Creates two Authenticators and two realms (\"r1\" and \"r2\")\n+     * \"r1\" uses context \"\/path1\" credentials = user1\/pass1\n+     * \"r2\" uses context \"\/path2\" credentials = user2\/pass2\n+     *\n+     * 1) Send request to \"r1\" and \"r2\" expect both authenticators to be called\n+     *    cache size should be 4\n+     *\n+     * 2) Send request to \"r1\" and \"r2\". Authenticators should not be called (cache)\n+     *\n+     * 3) Clear reference to \"r1\" and call gc.\n+     *    cache size should be 2\n+     *\n+     * 4) Send request to \"r1\" and \"r2\". \"r1\" auth should be called, but not \"r2\"\n+     *    cache size should be 4\n+     *\/\n+    public static void main(String[] args) throws IOException {\n+        var clauth1 = new ClientAuth(\"r1\", \"user1\", \"pass1\");\n+        PhantomReference<Authenticator> ref = new PhantomReference<>(clauth1, null);\n+        var clauth2 = new ClientAuth(\"r2\", \"user2\", \"pass2\");\n+        var server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        var ctx1 = server.createContext(\"\/path1\", handler);\n+        ctx1.setAuthenticator(new ServerAuth(\"r1\", \"user1\", \"pass1\"));\n+\n+        var ctx2 = server.createContext(\"\/path2\", handler);\n+        ctx2.setAuthenticator(new ServerAuth(\"r2\", \"user2\", \"pass2\"));\n+        var addr = server.getAddress();\n+        var url1 = URI.create(\"http:\/\/\" + addr.getHostName() + \":\" + addr.getPort() + \"\/path1\/\").toURL();\n+        var url2 = URI.create(\"http:\/\/\" + addr.getHostName() + \":\" + addr.getPort() + \"\/path2\/\").toURL();\n+        server.start();\n+\n+        sendRequest(url1, url2, clauth1, clauth2, true, true);\n+        sendRequest(url1, url2, clauth1, clauth2, false, false);\n+        clauth1 = null;\n+        ForceGC.wait(() -> ref.refersTo(null));\n+        delay(1);\n+        clauth1 = new ClientAuth(\"r1\", \"user1\", \"pass1\");\n+        sendRequest(url1, url2, clauth1, clauth2, true, false);\n+        System.out.println(\"Passed\");\n+        server.stop(0);\n+    }\n+\n+    static void delay(int seconds) {\n+        try {\n+            Thread.sleep(seconds * 1000);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    static void sendRequest(URL u1, URL u2, ClientAuth a1, ClientAuth a2, boolean auth1Called, boolean auth2Called) throws IOException {\n+        var urlc1 = (HttpURLConnection)u1.openConnection();\n+        urlc1.setAuthenticator(a1);\n+        var urlc2 = (HttpURLConnection)u2.openConnection();\n+        urlc2.setAuthenticator(a2);\n+\n+        var is1 = urlc1.getInputStream();\n+        is1.readAllBytes();\n+        is1.close();\n+        var is2 = urlc2.getInputStream();\n+        is2.readAllBytes();\n+        is2.close();\n+        urlc1 = urlc2 = null;\n+\n+        boolean a1Called = a1.wasCalled();\n+        boolean a2Called = a2.wasCalled();\n+        if (a1Called && !auth1Called)\n+            throw new RuntimeException(\"a1Called && !auth1Called\");\n+        if (!a1Called && auth1Called)\n+            throw new RuntimeException(\"!a1Called && auth1Called\");\n+        if (a2Called && !auth2Called)\n+            throw new RuntimeException(\"a2Called && !auth2Called\");\n+        if (!a2Called && auth2Called)\n+            throw new RuntimeException(\"!a2Called && auth2Called\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/AuthCache.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"}]}