{"files":[{"patch":"@@ -325,0 +325,10 @@\n+static inline void log_circularity_error(Thread* thread, PlaceholderEntry* probe) {\n+  LogTarget(Debug, class, load, placeholders) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(thread);\n+    LogStream ls(lt);\n+    ls.print(\"ClassCircularityError detected for placeholder \");\n+    probe->print_entry(&ls);\n+    ls.cr();\n+  }\n+}\n@@ -326,1 +336,1 @@\n-\/\/ Must be called for any super-class or super-interface resolution\n+\/\/ Must be called for any superclass or superinterface resolution\n@@ -328,4 +338,4 @@\n-\/\/ super-interface callers:\n-\/\/    parse_interfaces - for defineClass\n-\/\/ super-class callers:\n-\/\/   ClassFileParser - for defineClass\n+\/\/ superinterface callers:\n+\/\/    parse_interfaces - from defineClass\n+\/\/ superclass callers:\n+\/\/   ClassFileParser - from defineClass\n@@ -337,25 +347,9 @@\n-\/\/      if another thread is trying to resolve the class, it must do\n-\/\/      super-class checks on its own thread to catch class circularity\n-\/\/ This last call is critical in class circularity checking for cases\n-\/\/ where classloading is delegated to different threads and the\n-\/\/ classloader lock is released.\n-\/\/ Take the case: Base->Super->Base\n-\/\/   1. If thread T1 tries to do a defineClass of class Base\n-\/\/    resolve_super_or_fail creates placeholder: T1, Base (super Super)\n-\/\/   2. resolve_instance_class_or_null does not find SD or placeholder for Super\n-\/\/    so it tries to load Super\n-\/\/   3. If we load the class internally, or user classloader uses same thread\n-\/\/      loadClassFromxxx or defineClass via parseClassFile Super ...\n-\/\/      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)\n-\/\/      3.3 resolve_instance_class_or_null Base, finds placeholder for Base\n-\/\/      3.4 calls resolve_super_or_fail Base\n-\/\/      3.5 finds T1,Base -> throws class circularity\n-\/\/OR 4. If T2 tries to resolve Super via defineClass Super ...\n-\/\/      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)\n-\/\/      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)\n-\/\/      4.3 calls resolve_super_or_fail Super in parallel on own thread T2\n-\/\/      4.4 finds T2, Super -> throws class circularity\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_SUPER),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+\/\/      If another thread is trying to resolve the class, it must do\n+\/\/      superclass checks on its own thread to catch class circularity and\n+\/\/      to avoid deadlock.\n+\/\/\n+\/\/ resolve_super_or_fail adds a LOAD_SUPER placeholder to the placeholder table before calling\n+\/\/ resolve_instance_class_or_null. ClassCircularityError is detected when a LOAD_SUPER or LOAD_INSTANCE\n+\/\/ placeholder for the same thread, class, classloader is found.\n+\/\/ This can be seen with logging option: -Xlog:class+load+placeholders=debug.\n+\/\/\n@@ -368,1 +362,3 @@\n-  assert(!Signature::is_array(super_name), \"invalid super class name\");\n+\n+  assert(super_name != NULL, \"null superclass for resolving\");\n+  assert(!Signature::is_array(super_name), \"invalid superclass name\");\n@@ -380,14 +376,4 @@\n-  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n-  \/\/ Don't add a placedholder if already loaded, i.e. already in appropriate class loader\n-  \/\/ dictionary.\n-  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n-  \/\/ Used as a claim that this thread is currently loading superclass\/classloader\n-  \/\/ Used here for ClassCircularity checks and also for heap verification\n-  \/\/ (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).\n-  \/\/ Must check ClassCircularity before checking if super class is already loaded.\n-  \/\/\n-  \/\/ We might not already have a placeholder if this class_name was\n-  \/\/ first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);\n-  \/\/ the name of the class might not be known until the stream is actually\n-  \/\/ parsed.\n-  \/\/ Bugs 4643874, 4715493\n+  \/\/ If klass is already loaded, just return the superclass or superinterface.\n+  \/\/ Make sure there's a placeholder for the class_name before resolving.\n+  \/\/ This is used as a claim that this thread is currently loading superclass\/classloader\n+  \/\/ and for ClassCircularity checks.\n@@ -399,0 +385,1 @@\n+\n@@ -414,0 +401,1 @@\n+      \/\/ Must check ClassCircularity before checking if superclass is already loaded.\n@@ -416,0 +404,1 @@\n+          log_circularity_error(THREAD, probe);\n@@ -419,0 +408,1 @@\n+\n@@ -421,1 +411,5 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n+                                                                class_name,\n+                                                                loader_data,\n+                                                                PlaceholderTable::LOAD_SUPER,\n+                                                                super_name, THREAD);\n@@ -424,0 +418,1 @@\n+\n@@ -429,3 +424,1 @@\n-  \/\/ java.lang.Object should have been found above\n-  assert(super_name != NULL, \"null super class for resolving\");\n-  \/\/ Resolve the super class or interface, check results on return\n+  \/\/ Resolve the superclass or superinterface, check results on return\n@@ -438,6 +431,1 @@\n-  \/\/ Clean up of placeholders moved so that each classloadAction registrar self-cleans up\n-  \/\/ It is no longer necessary to keep the placeholder table alive until update_dictionary\n-  \/\/ or error. GC used to walk the placeholder table as strong roots.\n-  \/\/ The instanceKlass is kept alive because the class loader is on the stack,\n-  \/\/ which keeps the loader_data alive, as well as all instanceKlasses in\n-  \/\/ the loader_data. parseClassFile adds the instanceKlass to loader_data.\n+  \/\/ Clean up placeholder entry.\n@@ -482,1 +470,1 @@\n-void SystemDictionary::double_lock_wait(JavaThread* thread, Handle lockObject) {\n+static void double_lock_wait(JavaThread* thread, Handle lockObject) {\n@@ -499,1 +487,1 @@\n-\/\/ If the class in is in the placeholder table, class loading is in progress\n+\/\/ If the class in is in the placeholder table, class loading is in progress.\n@@ -502,14 +490,7 @@\n-\/\/ the superclass on the same thread internally, so we do parallel\n-\/\/ super class loading here.\n-\/\/ This also is critical in cases where the original thread gets stalled\n-\/\/ even in non-circularity situations.\n-\/\/ Returns non-null Klass* if other thread has completed load\n-\/\/ and we are done.  If this returns a null Klass* and no pending exception,\n-\/\/ the caller must load the class.\n-InstanceKlass* SystemDictionary::handle_parallel_super_load(\n-    Symbol* name, Symbol* superclassname, Handle class_loader,\n-    Handle protection_domain, Handle lockObject, TRAPS) {\n-\n-  ClassLoaderData* loader_data = class_loader_data(class_loader);\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(name);\n+\/\/ the superclass on the new thread internally, so we do parallel\n+\/\/ superclass loading here.  This avoids deadlock for ClassCircularity\n+\/\/ detection for parallelCapable class loaders that lock on a per-class lock.\n+static void handle_parallel_super_load(Symbol* name,\n+                                       Symbol* superclassname,\n+                                       Handle class_loader,\n+                                       Handle protection_domain, TRAPS) {\n@@ -523,1 +504,2 @@\n-                                                          CHECK_NULL);\n+                                                          CHECK);\n+}\n@@ -525,6 +507,5 @@\n-  \/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n-  \/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n- if (!class_loader.is_null() && is_parallelCapable(class_loader)) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    return dictionary->find_class(name_hash, name);\n-  }\n+\/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n+\/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n+static bool should_wait_for_loading(Handle class_loader) {\n+  return class_loader.is_null() || !is_parallelCapable(class_loader);\n+}\n@@ -532,11 +513,16 @@\n-  \/\/ must loop to both handle other placeholder updates\n-  \/\/ and spurious notifications\n-  bool super_load_in_progress = true;\n-  PlaceholderEntry* placeholder;\n-  while (super_load_in_progress) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    \/\/ Check if classloading completed while we were loading superclass or waiting\n-    InstanceKlass* check = dictionary->find_class(name_hash, name);\n-    if (check != NULL) {\n-      \/\/ Klass is already loaded, so just return it\n-      return check;\n+\/\/ For bootstrap and non-parallelCapable class loaders, check and wait for\n+\/\/ another thread to complete loading this class.\n+InstanceKlass* SystemDictionary::handle_parallel_loading(JavaThread* current,\n+                                                         unsigned int name_hash,\n+                                                         Symbol* name,\n+                                                         ClassLoaderData* loader_data,\n+                                                         Handle lockObject,\n+                                                         bool* throw_circularity_error) {\n+  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  if (oldprobe != NULL) {\n+    \/\/ only need check_seen_thread once, not on each loop\n+    \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n+    if (oldprobe->check_seen_thread(current, PlaceholderTable::LOAD_INSTANCE)) {\n+      log_circularity_error(THREAD, oldprobe);\n+      *throw_circularity_error = true;\n+      return NULL;\n@@ -544,2 +530,5 @@\n-      placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n+      \/\/ Wait until the first thread has finished loading this class. Also wait until all the\n+      \/\/ threads trying to load its superclass have removed their placeholders.\n+      while (oldprobe != NULL &&\n+             (oldprobe->instance_load_in_progress() || oldprobe->super_load_in_progress())) {\n+\n@@ -558,2 +547,3 @@\n-        \/\/ We also get here for parallel bootstrap classloader\n-        if (class_loader.is_null()) {\n+        oldprobe = NULL;  \/\/ Other thread could delete this placeholder entry\n+\n+        if (lockObject.is_null()) {\n@@ -562,1 +552,1 @@\n-          double_lock_wait(THREAD->as_Java_thread(), lockObject);\n+          double_lock_wait(current, lockObject);\n@@ -564,4 +554,9 @@\n-      } else {\n-        \/\/ If not in SD and not in PH, the other thread is done loading the super class\n-        \/\/ but not done loading this class. We'll give up the lock and wait for that below.\n-        super_load_in_progress = false;\n+\n+        \/\/ Check if classloading completed while we were waiting\n+        InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+        if (check != NULL) {\n+          \/\/ Klass is already loaded, so just return it\n+          return check;\n+        }\n+        \/\/ check if other thread failed to load and cleaned up\n+        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n@@ -584,7 +579,5 @@\n-\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-\/\/\n-\/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n+\/\/ SystemDictionary::resolve_instance_class_or_null is the main function for class name resolution.\n+\/\/ After checking if the InstanceKlass already exists, it checks for ClassCircularityError and\n+\/\/ whether the thread must wait for loading in parallel.  It eventually calls load_instance_class,\n+\/\/ which will load the class via the bootstrap loader or call ClassLoader.loadClass().\n+\/\/ This can return NULL, an exception or an InstanceKlass.\n@@ -595,0 +588,1 @@\n+  \/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n@@ -608,2 +602,2 @@\n-  \/\/ Do lookup to see if class already exist and the protection domain\n-  \/\/ has the right access\n+  \/\/ Do lookup to see if class already exists and the protection domain\n+  \/\/ has the right access.\n@@ -611,7 +605,4 @@\n-  \/\/ All subsequent calls use find_class, and set has_loaded_class so that\n-  \/\/ before we return a result we call out to java to check for valid protection domain\n-  \/\/ to allow returning the Klass* and add it to the pd_set if it is valid\n-  {\n-    InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n-    if (probe != NULL) return probe;\n-  }\n+  \/\/ All subsequent calls use find_class, and set loaded_class so that\n+  \/\/ before we return a result, we call out to java to check for valid protection domain.\n+  InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n+  if (probe != NULL) return probe;\n@@ -626,1 +617,1 @@\n-  \/\/ ParallelCapable Classloaders and the bootstrap classloader\n+  \/\/ ParallelCapable class loaders and the bootstrap classloader\n@@ -631,2 +622,0 @@\n-  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n-  bool class_has_been_loaded   = false;\n@@ -644,0 +633,1 @@\n+  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n@@ -648,2 +638,1 @@\n-      \/\/ InstanceKlass is already loaded, so just return it\n-      class_has_been_loaded = true;\n+      \/\/ InstanceKlass is already loaded, but we still need to check protection domain below.\n@@ -661,1 +650,2 @@\n-  \/\/ If the class is in the placeholder table, class loading is in progress\n+  \/\/ If the class is in the placeholder table with super_class set,\n+  \/\/ handle superclass loading in progress.\n@@ -663,8 +653,4 @@\n-    loaded_class = handle_parallel_super_load(name,\n-                                              superclassname,\n-                                              class_loader,\n-                                              protection_domain,\n-                                              lockObject, CHECK_NULL);\n-    if (loaded_class != NULL) {\n-      class_has_been_loaded = true;\n-    }\n+    handle_parallel_super_load(name, superclassname,\n+                               class_loader,\n+                               protection_domain,\n+                               CHECK_NULL);\n@@ -674,2 +660,2 @@\n-  if (!class_has_been_loaded) {\n-    bool load_instance_added = false;\n+  if (loaded_class == NULL) {\n+    bool load_placeholder_added = false;\n@@ -678,1 +664,1 @@\n-    \/\/ Three cases:\n+    \/\/ Four cases:\n@@ -694,1 +680,1 @@\n-    if (class_loader.is_null() || !is_parallelCapable(class_loader)) {\n+    {\n@@ -696,30 +682,7 @@\n-      PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (oldprobe != NULL) {\n-        \/\/ only need check_seen_thread once, not on each loop\n-        \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n-        if (oldprobe->check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {\n-          throw_circularity_error = true;\n-        } else {\n-          \/\/ case 3: traditional: should never see load_in_progress.\n-          while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n-\n-            \/\/ case 1: bootstrap classloader: prevent futile classloading,\n-            \/\/ wait on first requestor\n-            if (class_loader.is_null()) {\n-              SystemDictionary_lock->wait();\n-            } else {\n-              \/\/ case 4: traditional with broken classloader lock. wait on first\n-              \/\/ requestor.\n-              double_lock_wait(THREAD->as_Java_thread(), lockObject);\n-            }\n-            \/\/ Check if classloading completed while we were waiting\n-            InstanceKlass* check = dictionary->find_class(name_hash, name);\n-            if (check != NULL) {\n-              \/\/ Klass is already loaded, so just return it\n-              loaded_class = check;\n-              class_has_been_loaded = true;\n-            }\n-            \/\/ check if other thread failed to load and cleaned up\n-            oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-          }\n-        }\n+      if (should_wait_for_loading(class_loader)) {\n+        loaded_class = handle_parallel_loading(THREAD->as_Java_thread(),\n+                                               name_hash,\n+                                               name,\n+                                               loader_data,\n+                                               lockObject,\n+                                               &throw_circularity_error);\n@@ -728,5 +691,3 @@\n-      \/\/ Add LOAD_INSTANCE while holding the SystemDictionary_lock\n-      if (!throw_circularity_error && !class_has_been_loaded) {\n-        \/\/ For the bootclass loader, if the thread did not catch another thread holding\n-        \/\/ the LOAD_INSTANCE token, we need to check whether it completed loading\n-        \/\/ while holding the SD_lock.\n+      \/\/ Recheck if the class has been loaded for all class loader cases and\n+      \/\/ add a LOAD_INSTANCE placeholder while holding the SystemDictionary_lock.\n+      if (!throw_circularity_error && loaded_class == NULL) {\n@@ -735,1 +696,0 @@\n-          \/\/ Klass is already loaded, so return it after checking\/adding protection domain\n@@ -737,3 +697,2 @@\n-          class_has_been_loaded = true;\n-        } else {\n-          \/\/ Now we've got the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+        } else if (should_wait_for_loading(class_loader)) {\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n@@ -744,1 +703,1 @@\n-          load_instance_added = true;\n+          load_placeholder_added = true;\n@@ -749,1 +708,1 @@\n-    \/\/ must throw error outside of owning lock\n+    \/\/ Must throw error outside of owning lock\n@@ -751,1 +710,1 @@\n-      assert(!HAS_PENDING_EXCEPTION && !load_instance_added, \"circularity error cleanup\");\n+      assert(!HAS_PENDING_EXCEPTION && !load_placeholder_added, \"circularity error cleanup\");\n@@ -756,1 +715,4 @@\n-    if (!class_has_been_loaded) {\n+    \/\/ Be careful when modifying this code: once you have run\n+    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ you need to find_and_remove it before returning.\n+    \/\/ So be careful to not exit with a CHECK_ macro between these calls.\n@@ -758,0 +720,1 @@\n+    if (loaded_class == NULL) {\n@@ -759,31 +722,2 @@\n-      loaded_class = load_instance_class(name, class_loader, THREAD);\n-\n-      \/\/ If everything was OK (no exceptions, no null return value), and\n-      \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n-      if (!HAS_PENDING_EXCEPTION && loaded_class != NULL &&\n-        loaded_class->class_loader() != class_loader()) {\n-\n-        check_constraints(name_hash, loaded_class, class_loader, false, THREAD);\n-\n-        \/\/ Need to check for a PENDING_EXCEPTION again; check_constraints\n-        \/\/ can throw but we may have to remove entry from the placeholder table below.\n-        if (!HAS_PENDING_EXCEPTION) {\n-          \/\/ Record dependency for non-parent delegation.\n-          \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n-          \/\/ from being unloaded while the initiating class loader is loaded\n-          \/\/ even if the reference to the defining class loader is dropped\n-          \/\/ before references to the initiating class loader.\n-          loader_data->record_dependency(loaded_class);\n-\n-          { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n-            \/\/ during compilations.\n-            MutexLocker mu(THREAD, Compile_lock);\n-            update_dictionary(name_hash, loaded_class, class_loader);\n-          }\n-\n-          if (JvmtiExport::should_post_class_load()) {\n-            JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n-          }\n-        }\n-      }\n-    } \/\/ load_instance_class\n+      loaded_class = load_instance_class(name_hash, name, class_loader, THREAD);\n+    }\n@@ -791,1 +725,1 @@\n-    if (load_instance_added) {\n+    if (load_placeholder_added) {\n@@ -804,0 +738,1 @@\n+\n@@ -1036,1 +971,1 @@\n-\/\/ forces the super class and all interfaces to be loaded.\n+\/\/ forces the superclass and all interfaces to be loaded.\n@@ -1146,1 +1081,1 @@\n-    \/\/ Check if the super class is loaded by the current class_loader\n+    \/\/ Check if the superclass is loaded by the current class_loader\n@@ -1313,1 +1248,1 @@\n-InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {\n+InstanceKlass* SystemDictionary::load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS) {\n@@ -1452,0 +1387,35 @@\n+InstanceKlass* SystemDictionary::load_instance_class(unsigned int name_hash,\n+                                                     Symbol* name,\n+                                                     Handle class_loader,\n+                                                     TRAPS) {\n+\n+  InstanceKlass* loaded_class = load_instance_class_impl(name, class_loader, CHECK_NULL);\n+\n+  \/\/ If everything was OK (no exceptions, no null return value), and\n+  \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n+  if (loaded_class != NULL &&\n+    loaded_class->class_loader() != class_loader()) {\n+\n+    check_constraints(name_hash, loaded_class, class_loader, false, CHECK_NULL);\n+\n+    \/\/ Record dependency for non-parent delegation.\n+    \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n+    \/\/ from being unloaded while the initiating class loader is loaded\n+    \/\/ even if the reference to the defining class loader is dropped\n+    \/\/ before references to the initiating class loader.\n+    ClassLoaderData* loader_data = class_loader_data(class_loader);\n+    loader_data->record_dependency(loaded_class);\n+\n+    { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n+      \/\/ during compilations.\n+      MutexLocker mu(THREAD, Compile_lock);\n+      update_dictionary(name_hash, loaded_class, class_loader);\n+    }\n+\n+    if (JvmtiExport::should_post_class_load()) {\n+      JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n+    }\n+  }\n+  return loaded_class;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":180,"deletions":210,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -49,3 +49,1 @@\n-\/\/ a side data structure, and is used to detect ClassCircularityErrors\n-\/\/ and to perform verification during GC.  A GC can occur in the midst\n-\/\/ of class loading, as we call out to Java, have to take locks, etc.\n+\/\/ a side data structure, and is used to detect ClassCircularityErrors.\n@@ -61,3 +59,2 @@\n-\/\/    - entries are only deleted at safepoints\n-\/\/    - readers cannot come to a safepoint while actively examining\n-\/\/         an entry  (an entry cannot be deleted from under a reader)\n+\/\/    - entries are only deleted when the class loader is not alive, when the\n+\/\/      entire dictionary is deleted.\n@@ -335,10 +332,7 @@\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n-                                                   Symbol* supername,\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n-                                                   Handle lockObject, TRAPS);\n-  \/\/ Wait on SystemDictionary_lock; unlocks lockObject before\n-  \/\/ waiting; relocks lockObject with correct recursion count\n-  \/\/ after waiting, but before reentering SystemDictionary_lock\n-  \/\/ to preserve lock order semantics.\n-  static void double_lock_wait(JavaThread* thread, Handle lockObject);\n+  static InstanceKlass* handle_parallel_loading(JavaThread* current,\n+                                                unsigned int name_hash,\n+                                                Symbol* name,\n+                                                ClassLoaderData* loader_data,\n+                                                Handle lockObject,\n+                                                bool* throw_circularity_error);\n+\n@@ -349,1 +343,4 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class(unsigned int name_hash,\n+                                            Symbol* class_name,\n+                                            Handle class_loader, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.*;\n+\n+public class AsmClasses implements Opcodes {\n+\n+    \/\/ class B extends A {} to generate ClassCircularityError\n+    \/\/ Can't use jcod, jasm or InMemoryCompiler because the compiler will\n+    \/\/ see that A extends B and fail.\n+    public static byte[] dumpB() throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"B\", null, \"A\", null);\n+\n+        classWriter.visitSource(\"B.java\", null);\n+        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        methodVisitor.visitCode();\n+        Label label0 = new Label();\n+        methodVisitor.visitLabel(label0);\n+        methodVisitor.visitLineNumber(24, label0);\n+        methodVisitor.visitVarInsn(ALOAD, 0);\n+        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"A\", \"<init>\", \"()V\", false);\n+        methodVisitor.visitInsn(RETURN);\n+        methodVisitor.visitMaxs(1, 1);\n+        methodVisitor.visitEnd();\n+        classWriter.visitEnd();\n+\n+        return classWriter.toByteArray();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/AsmClasses.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class ClassLoadingThread extends Thread {\n+\n+    private ClassLoader ldr = null;\n+    private Object thread_sync = null;\n+\n+    public ClassLoadingThread(ClassLoader loader, Object sync) {\n+        ldr = loader;\n+        thread_sync = sync;\n+    }\n+\n+    private boolean success = true;\n+    public boolean report_success() { return success; }\n+\n+    public void run() {\n+        try {\n+            ThreadPrint.println(\"Starting...\");\n+            \/\/ Initiate class loading using specified type\n+            Class<?> a = Class.forName(\"ClassInLoader\", true, ldr);\n+            Object obj = a.getConstructor().newInstance();\n+\n+        } catch (Throwable e) {\n+            ThreadPrint.println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = false;\n+        } finally {\n+            ThreadPrint.println(\"Finished\");\n+            \/\/ Wake up the second thread\n+            synchronized (thread_sync) {\n+                thread_sync.notify();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+\/\/ This class loader will deadlock where one thread has a lock for A, trying to get a lock for B\n+\/\/ and the other thread has a lock for B, trying to get a lock for A in the case of\n+\/\/ A extends B extends A.  It should throw ClassCircularityError from both threads.\n+\n+class MyLoader extends ClassLoader {\n+    static {\n+        registerAsParallelCapable();\n+    }\n+\n+    private static boolean first = true;\n+\n+    public Class loadClass(String name) throws ClassNotFoundException {\n+        \/\/ Wait before getting B lock.\n+        if (name.equals(\"B\") && first) {\n+            first = false;\n+            makeThreadWait();\n+        }\n+        synchronized(getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c != null) return c;\n+\n+            if (name.equals(\"B\") && !first) {\n+              wakeUpThread();\n+            }\n+\n+            byte[] b = loadClassData(name);\n+            if (b != null) {\n+                return defineClass(name, b, 0, b.length);\n+            } else {\n+                return super.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static boolean parallel = false;\n+    private Object sync = new Object();\n+    private Object thread_sync = new Object();\n+\n+    private void makeThreadWait() {\n+        if (!parallel) { return; }\n+\n+        \/\/ Wake up the second thread here.\n+        synchronized (thread_sync) {\n+            thread_sync.notify();\n+        }\n+        if (isRegisteredAsParallelCapable()) {\n+            synchronized(sync) {\n+                try {\n+                    ThreadPrint.println(\"t1 waits parallelCapable loader\");\n+                    sync.wait();  \/\/ Give up lock before request to load B\n+                } catch (InterruptedException e) {}\n+             }\n+         } else {\n+             try {\n+                ThreadPrint.println(\"t1 waits non-parallelCapable loader\");\n+                wait();  \/\/ Give up lock before request to load B\n+              } catch (InterruptedException e) {}\n+         }\n+    }\n+\n+    \/\/ Parallel capable loader should wake up the first thread.\n+    \/\/ Non-parallelCapable class loader thread will be woken up by the jvm.\n+    private void wakeUpThread() {\n+        if (isRegisteredAsParallelCapable()) {\n+            synchronized(sync) {\n+                sync.notify();\n+            }\n+        }\n+    }\n+\n+    private byte[] loadClassData(String name) {\n+        if (name.equals(\"A\")) {\n+            ThreadPrint.println(\"loading A extends B\");\n+            return ClassUnloadCommon.getClassData(\"A\");\n+        } else if (name.equals(\"B\")) {\n+            ThreadPrint.println(\"loading B extends A\");\n+            try {\n+                return AsmClasses.dumpB();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                return null;\n+            }\n+        } else if (!name.startsWith(\"java\")) {\n+            return ClassUnloadCommon.getClassData(name);\n+        }\n+        return null;\n+    }\n+\n+\n+    ClassLoadingThread[] threads = new ClassLoadingThread[2];\n+    private boolean success = true;\n+\n+    public boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+            if (!threads[i].report_success()) success = false;\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    void startLoading() {\n+\n+        for (int i = 0; i < 2; i++) {\n+            threads[i] = new ClassLoadingThread(this, thread_sync);\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+            \/\/ wait to start the second thread if not concurrent\n+            if (i == 0) {\n+                synchronized(thread_sync) {\n+                    try {\n+                        ThreadPrint.println(\"t2 waits\");\n+                        thread_sync.wait();\n+                    } catch (InterruptedException e) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    MyLoader(boolean load_in_parallel) {\n+       parallel = load_in_parallel;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class MyNonParallelLoader extends MyLoader {\n+    \/\/ This loader isn't parallel capable because it's not registered in the static\n+    \/\/ initializer as such.  parallelCapable is not an inheritable attribute.\n+    MyNonParallelLoader(boolean load_in_parallel) {\n+       super(load_in_parallel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyNonParallelLoader.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test MyLoaderTest\n+ * @bug 8262046\n+ * @summary Call handle_parallel_super_load, loading parallel threads that throw CCE\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file AsmClasses.java\n+ * @compile test-classes\/ClassInLoader.java test-classes\/A.java test-classes\/B.java\n+ * @run main\/othervm ParallelSuperTest\n+ * @run main\/othervm ParallelSuperTest -parallel\n+ * @run main\/othervm ParallelSuperTest -parallel -parallelCapable\n+ *\/\n+\n+public class ParallelSuperTest {\n+    public static void main(java.lang.String[] args) throws Exception {\n+        boolean parallel = false;\n+        boolean parallelCapable = false;\n+        boolean success = true;\n+        for (int i = 0; i < args.length; i++) {\n+            try {\n+                \/\/ Don't print debug info\n+                if (args[i].equals(\"-parallel\")) {\n+                    parallel = true;\n+                } else if (args[i].equals(\"-parallelCapable\")) {\n+                    parallelCapable = true;\n+                } else {\n+                    System.out.println(\"Unrecognized \" + args[i]);\n+                }\n+            } catch (NumberFormatException e) {\n+                System.err.println(\"Invalid parameter: \" + args[i - 1] + \" \" + args[i]);\n+            }\n+        }\n+        \/\/ The -parallel -parallelCapable case will deadlock on locks for A and B if\n+        \/\/ the jvm doesn't eagerly try to load A's superclass from the second thread.\n+        \/\/ ie. needs to call SystemDictionary::handle_parallel_super_load\n+        if (parallelCapable) {\n+            MyLoader ldr = new MyLoader(parallel);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        } else {\n+            MyNonParallelLoader ldr = new MyNonParallelLoader(parallel);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        }\n+        if (success) {\n+            System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuperTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ class to print thread-annotated output\n+class ThreadPrint {\n+    public static void println(String s) {\n+        System.out.println(Thread.currentThread().getName() + \": \" + s);\n+        System.out.flush();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ThreadPrint.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class A extends B {\n+    public A() {\n+       System.out.println(\"A extends B\");\n+       throw new RuntimeException(\"Should throw CCE here\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/A.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class B { public B() { System.out.println(\"B\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/B.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Create a class to load inside the loader instance, that will load\n+\/\/ A through a constant pool reference.\n+\/\/ Class A extends B extends A\n+class CP1 {\n+  void foo() throws Exception {\n+      ThreadPrint.println(\"CP1.foo()\");\n+      try {\n+          Class<?> a = A.class;\n+          Object obj = a.getConstructor().newInstance();\n+          throw new RuntimeException(\"Should throw CCE here\");\n+      } catch (Throwable e) {\n+          ThreadPrint.println(\"Exception is caught: \" + e);\n+          if (!(e instanceof java.lang.ClassCircularityError)) {\n+              throw new RuntimeException(\"Unexpected exception\");\n+          }\n+      }\n+  }\n+}\n+\n+\/\/ This class has a constant pool reference to B which will also get CCE, but\n+\/\/ starting at B.\n+class CP2 {\n+  void foo() throws Exception {\n+      ThreadPrint.println(\"CP2.foo()\");\n+      try {\n+          Class<?> a = B.class;\n+          Object obj = a.getConstructor().newInstance();\n+          throw new RuntimeException(\"Should throw CCE here\");\n+      } catch (Throwable e) {\n+          ThreadPrint.println(\"Exception is caught: \" + e);\n+          if (!(e instanceof java.lang.ClassCircularityError)) {\n+              throw new RuntimeException(\"Unexpected exception\");\n+          }\n+      }\n+  }\n+}\n+\n+public class ClassInLoader {\n+  private static boolean first = true;\n+  public ClassInLoader() throws Exception {\n+    ThreadPrint.println(\"ClassInLoader\");\n+    if (first) {\n+        first = false;\n+        CP1 c1 = new CP1();\n+        c1.foo();\n+    } else {\n+        CP2 c2 = new CP2();\n+        c2.foo();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/ClassInLoader.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}