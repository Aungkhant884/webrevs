{"files":[{"patch":"@@ -1,346 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Alphabet LLC. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.code;\n-\n-import static com.sun.tools.javac.code.TargetType.CLASS_EXTENDS;\n-import static com.sun.tools.javac.code.TargetType.CLASS_TYPE_PARAMETER_BOUND;\n-import static com.sun.tools.javac.code.TargetType.METHOD_FORMAL_PARAMETER;\n-import static com.sun.tools.javac.code.TargetType.METHOD_RECEIVER;\n-import static com.sun.tools.javac.code.TargetType.METHOD_RETURN;\n-import static com.sun.tools.javac.code.TargetType.METHOD_TYPE_PARAMETER_BOUND;\n-import static com.sun.tools.javac.code.TargetType.THROWS;\n-import static com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT;\n-\n-import com.sun.tools.javac.code.Attribute.TypeCompound;\n-import com.sun.tools.javac.code.Type.ArrayType;\n-import com.sun.tools.javac.code.Type.ClassType;\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.Type.TypeVar;\n-import com.sun.tools.javac.code.Type.WildcardType;\n-import com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.ListBuffer;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.BiFunction;\n-import java.util.function.Predicate;\n-\n-\/** Contains operations to processing type annotations read from class files. *\/\n-public final class TypeAnnotationMapper {\n-\n-    private TypeAnnotationMapper() {}\n-\n-    \/**\n-     * Rewrites types in the given symbol to include type annotations.\n-     *\n-     * <p>The list of type annotations includes annotations for all types in the signature of the\n-     * symbol. Associating the annotations with the correct type requires interpreting the JVMS\n-     * 4.7.20-A target_type to locate the correct type to rewrite, and then interpreting the JVMS\n-     * 4.7.20.2 type_path to associate the annotation with the correct contained type.\n-     *\/\n-    public static void addTypeAnnotationsToSymbol(Symbol s, List<TypeCompound> attributes) {\n-        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n-    }\n-\n-    private static class TypeAnnotationSymbolVisitor\n-            extends Types.DefaultSymbolVisitor<Void, Void> {\n-\n-        private final List<TypeCompound> attributes;\n-\n-        public TypeAnnotationSymbolVisitor(List<TypeCompound> attributes) {\n-            this.attributes = attributes;\n-        }\n-\n-        @Override\n-        public Void visitClassSymbol(Symbol.ClassSymbol s, Void unused) {\n-            ClassType t = (ClassType) s.type;\n-            int i = 0;\n-            ListBuffer<Type> interfaces = new ListBuffer<>();\n-            for (Type itf : t.interfaces_field) {\n-                interfaces.add(addTypeAnnotations(itf, classExtends(i++)));\n-            }\n-            t.interfaces_field = interfaces.toList();\n-            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n-            if (t.typarams_field != null) {\n-                t.typarams_field = rewriteTypeParameters(t.typarams_field, CLASS_TYPE_PARAMETER_BOUND);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitMethodSymbol(Symbol.MethodSymbol s, Void unused) {\n-            Type t = s.type;\n-            if (t.hasTag(TypeTag.FORALL)) {\n-                Type.ForAll fa = (Type.ForAll) t;\n-                fa.tvars = rewriteTypeParameters(fa.tvars, METHOD_TYPE_PARAMETER_BOUND);\n-                t = fa.qtype;\n-            }\n-            MethodType mt = (MethodType) t;\n-            ListBuffer<Type> argtypes = new ListBuffer<>();\n-            int i = 0;\n-            for (Symbol.VarSymbol param : s.params) {\n-                param.type = addTypeAnnotations(param.type, methodFormalParameter(i++));\n-                argtypes.add(param.type);\n-            }\n-            mt.argtypes = argtypes.toList();\n-            ListBuffer<Type> thrown = new ListBuffer<>();\n-            i = 0;\n-            for (Type thrownType : mt.thrown) {\n-                thrown.add(addTypeAnnotations(thrownType, thrownType(i++)));\n-            }\n-            mt.thrown = thrown.toList();\n-            mt.restype = addTypeAnnotations(mt.restype, METHOD_RETURN);\n-            if (mt.recvtype != null) {\n-                mt.recvtype = addTypeAnnotations(mt.recvtype, METHOD_RECEIVER);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitVarSymbol(Symbol.VarSymbol s, Void unused) {\n-            s.type = addTypeAnnotations(s.type, TargetType.FIELD);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSymbol(Symbol s, Void unused) {\n-            return null;\n-        }\n-\n-        private List<Type> rewriteTypeParameters(List<Type> tvars, TargetType boundType) {\n-            ListBuffer<Type> tvarbuf = new ListBuffer<>();\n-            int typeVariableIndex = 0;\n-            for (Type tvar : tvars) {\n-                Type bound = tvar.getUpperBound();\n-                if (bound.isCompound()) {\n-                    ClassType ct = (ClassType) bound;\n-                    int boundIndex = 0;\n-                    if (ct.supertype_field != null) {\n-                        ct.supertype_field =\n-                                addTypeAnnotations(\n-                                        ct.supertype_field,\n-                                        typeParameterBound(\n-                                                boundType, typeVariableIndex, boundIndex++));\n-                    }\n-                    ListBuffer<Type> itfbuf = new ListBuffer<>();\n-                    for (Type itf : ct.interfaces_field) {\n-                        itfbuf.add(\n-                                addTypeAnnotations(\n-                                        itf,\n-                                        typeParameterBound(\n-                                                boundType, typeVariableIndex, boundIndex++)));\n-                    }\n-                    ct.interfaces_field = itfbuf.toList();\n-                } else {\n-                    bound =\n-                            addTypeAnnotations(\n-                                    bound,\n-                                    typeParameterBound(\n-                                            boundType,\n-                                            typeVariableIndex,\n-                                            bound.isInterface() ? 1 : 0));\n-                }\n-                ((TypeVar) tvar).setUpperBound(bound);\n-                tvarbuf.add(tvar);\n-                typeVariableIndex++;\n-            }\n-            return tvarbuf.toList();\n-        }\n-\n-        private Type addTypeAnnotations(Type type, TargetType targetType) {\n-            return addTypeAnnotations(type, pos -> pos.type == targetType);\n-        }\n-\n-        private Type addTypeAnnotations(Type type, Predicate<TypeAnnotationPosition> filter) {\n-            Assert.checkNonNull(type);\n-\n-            \/\/ Find type annotations that match the given target type\n-            ListBuffer<TypeCompound> filtered = new ListBuffer<>();\n-            for (TypeCompound attribute : this.attributes) {\n-                if (filter.test(attribute.position)) {\n-                    filtered.add(attribute);\n-                }\n-            }\n-            if (filtered.isEmpty()) {\n-                return type;\n-            }\n-\n-            \/\/ Group the matching annotations by their type path. Each group of annotations will be\n-            \/\/ added to a type at that location.\n-            Map<List<TypePathEntry>, ListBuffer<TypeCompound>> attributesByPath = new HashMap<>();\n-            for (TypeCompound attribute : filtered.toList()) {\n-                attributesByPath\n-                        .computeIfAbsent(attribute.position.location, k -> new ListBuffer<>())\n-                        .add(attribute);\n-            }\n-\n-            \/\/ Search the structure of the type to find the contained types at each type path\n-            Map<Type, List<TypeCompound>> attributesByType = new HashMap<>();\n-            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n-\n-            \/\/ Rewrite the type and add the annotations\n-            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n-            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n-\n-            return type;\n-        }\n-\n-        private static Predicate<TypeAnnotationPosition> typeParameterBound(\n-                TargetType targetType, int parameterIndex, int boundIndex) {\n-            return pos ->\n-                    pos.type == targetType\n-                            && pos.parameter_index == parameterIndex\n-                            && pos.bound_index == boundIndex;\n-        }\n-\n-        private static Predicate<TypeAnnotationPosition> methodFormalParameter(int index) {\n-            return pos -> pos.type == METHOD_FORMAL_PARAMETER && pos.parameter_index == index;\n-        }\n-\n-        private static Predicate<TypeAnnotationPosition> thrownType(int index) {\n-            return pos -> pos.type == THROWS && pos.type_index == index;\n-        }\n-\n-        private static Predicate<TypeAnnotationPosition> classExtends(int index) {\n-            return pos -> pos.type == CLASS_EXTENDS && pos.type_index == index;\n-        }\n-    }\n-\n-    \/**\n-     * Visit all contained types, assembling a type path to represent the current location, and\n-     * record the types at each type path that need to be annotated.\n-     *\/\n-    private static class TypeAnnotationLocator\n-            extends Types.DefaultTypeVisitor<Void, List<TypePathEntry>> {\n-        private final Map<List<TypePathEntry>, ListBuffer<TypeCompound>> attributesByPath;\n-        private final Map<Type, List<TypeCompound>> attributesByType;\n-\n-        public TypeAnnotationLocator(\n-                Map<List<TypePathEntry>, ListBuffer<TypeCompound>> attributesByPath,\n-                Map<Type, List<TypeCompound>> attributesByType) {\n-            this.attributesByPath = attributesByPath;\n-            this.attributesByType = attributesByType;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, List<TypePathEntry> path) {\n-            \/\/ As described in JVMS 4.7.20.2, type annotations on nested types are located with\n-            \/\/ 'left-to-right' steps starting on 'the outermost part of the type for which a type\n-            \/\/ annotation is admissible'. So the current path represents the outermost containing\n-            \/\/ type of the type being visited, and we add type path steps for every contained nested\n-            \/\/ type.\n-            List<ClassType> enclosing = List.nil();\n-            for (Type curr = t;\n-                    curr != null && curr != Type.noType;\n-                    curr = curr.getEnclosingType()) {\n-                enclosing = enclosing.prepend((ClassType) curr);\n-            }\n-            for (ClassType te : enclosing) {\n-                if (te.typarams_field != null) {\n-                    int i = 0;\n-                    for (Type typaram : te.typarams_field) {\n-                        visit(typaram, path.append(new TypePathEntry(TYPE_ARGUMENT, i++)));\n-                    }\n-                }\n-                visitType(te, path);\n-                path = path.append(TypePathEntry.INNER_TYPE);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, List<TypePathEntry> path) {\n-            visit(t.type, path.append(TypePathEntry.WILDCARD));\n-            return super.visitWildcardType(t, path);\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, List<TypePathEntry> path) {\n-            visit(t.elemtype, path.append(TypePathEntry.ARRAY));\n-            return super.visitArrayType(t, path);\n-        }\n-\n-        @Override\n-        public Void visitType(Type t, List<TypePathEntry> path) {\n-            ListBuffer<TypeCompound> attributes = attributesByPath.remove(path);\n-            if (attributes != null) {\n-                attributesByType.put(t, attributes.toList());\n-            }\n-            return null;\n-        }\n-    }\n-\n-    \/** A type mapping that rewrites the type to include type annotations. *\/\n-    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n-\n-        private final Map<Type, List<TypeCompound>> attributesByType;\n-\n-        public TypeAnnotationTypeMapping(Map<Type, List<TypeCompound>> attributesByType) {\n-            this.attributesByType = attributesByType;\n-        }\n-\n-        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n-            \/\/ We're relying on object identify of Type instances to record where the annotations need to be added,\n-            \/\/ so we have to retrieve the annotations for each type before rewriting it, and then add them after\n-            \/\/ it's contained types have been rewritten.\n-            List<TypeCompound> attributes = attributesByType.remove(t);\n-            Type mapped = f.apply(t, null);\n-            if (attributes == null) {\n-                return mapped;\n-            }\n-            \/\/ Runtime-visible and -invisible annotations are completed separately, so if the same type has annotations\n-            \/\/ from both it will get annotated twice.\n-            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n-            if (existing != null) {\n-                existing.annotationBuffer().addAll(attributes);\n-                return mapped;\n-            }\n-            return mapped.addMetadata(new TypeMetadata.Annotations(attributes));\n-        }\n-\n-        @Override\n-        public Type visitClassType(ClassType t, Void unused) {\n-            return reannotate(t, super::visitClassType);\n-        }\n-\n-        @Override\n-        public Type visitWildcardType(WildcardType t, Void unused) {\n-            return reannotate(t, super::visitWildcardType);\n-        }\n-\n-        @Override\n-        public Type visitArrayType(ArrayType t, Void unused) {\n-            return reannotate(t, super::visitArrayType);\n-        }\n-\n-        @Override\n-        public Type visitType(Type t, Void unused) {\n-            return reannotate(t, (x, u) -> x);\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotationMapper.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"deleted"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Predicate;\n@@ -2264,1 +2266,1 @@\n-                TypeAnnotationMapper.addTypeAnnotationsToSymbol(sym, newList);\n+                addTypeAnnotationsToSymbol(sym, newList);\n@@ -2271,0 +2273,289 @@\n+    \/**\n+     * Rewrites types in the given symbol to include type annotations.\n+     *\n+     * <p>The list of type annotations includes annotations for all types in the signature of the\n+     * symbol. Associating the annotations with the correct type requires interpreting the JVMS\n+     * 4.7.20-A target_type to locate the correct type to rewrite, and then interpreting the JVMS\n+     * 4.7.20.2 type_path to associate the annotation with the correct contained type.\n+     *\/\n+    private static void addTypeAnnotationsToSymbol(Symbol s, List<Attribute.TypeCompound> attributes) {\n+        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    }\n+\n+    private static class TypeAnnotationSymbolVisitor\n+            extends Types.DefaultSymbolVisitor<Void, Void> {\n+\n+        private final List<Attribute.TypeCompound> attributes;\n+\n+        private TypeAnnotationSymbolVisitor(List<Attribute.TypeCompound> attributes) {\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public Void visitClassSymbol(Symbol.ClassSymbol s, Void unused) {\n+            ClassType t = (ClassType) s.type;\n+            int i = 0;\n+            ListBuffer<Type> interfaces = new ListBuffer<>();\n+            for (Type itf : t.interfaces_field) {\n+                interfaces.add(addTypeAnnotations(itf, classExtends(i++)));\n+            }\n+            t.interfaces_field = interfaces.toList();\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            if (t.typarams_field != null) {\n+                t.typarams_field = rewriteTypeParameters(t.typarams_field, TargetType.CLASS_TYPE_PARAMETER_BOUND);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethodSymbol(Symbol.MethodSymbol s, Void unused) {\n+            Type t = s.type;\n+            if (t.hasTag(TypeTag.FORALL)) {\n+                Type.ForAll fa = (Type.ForAll) t;\n+                fa.tvars = rewriteTypeParameters(fa.tvars, TargetType.METHOD_TYPE_PARAMETER_BOUND);\n+                t = fa.qtype;\n+            }\n+            MethodType mt = (MethodType) t;\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            int i = 0;\n+            for (Symbol.VarSymbol param : s.params) {\n+                param.type = addTypeAnnotations(param.type, methodFormalParameter(i++));\n+                argtypes.add(param.type);\n+            }\n+            mt.argtypes = argtypes.toList();\n+            ListBuffer<Type> thrown = new ListBuffer<>();\n+            i = 0;\n+            for (Type thrownType : mt.thrown) {\n+                thrown.add(addTypeAnnotations(thrownType, thrownType(i++)));\n+            }\n+            mt.thrown = thrown.toList();\n+            mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            if (mt.recvtype != null) {\n+                mt.recvtype = addTypeAnnotations(mt.recvtype, TargetType.METHOD_RECEIVER);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVarSymbol(Symbol.VarSymbol s, Void unused) {\n+            s.type = addTypeAnnotations(s.type, TargetType.FIELD);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitSymbol(Symbol s, Void unused) {\n+            return null;\n+        }\n+\n+        private List<Type> rewriteTypeParameters(List<Type> tvars, TargetType boundType) {\n+            ListBuffer<Type> tvarbuf = new ListBuffer<>();\n+            int typeVariableIndex = 0;\n+            for (Type tvar : tvars) {\n+                Type bound = tvar.getUpperBound();\n+                if (bound.isCompound()) {\n+                    ClassType ct = (ClassType) bound;\n+                    int boundIndex = 0;\n+                    if (ct.supertype_field != null) {\n+                        ct.supertype_field =\n+                                addTypeAnnotations(\n+                                        ct.supertype_field,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++));\n+                    }\n+                    ListBuffer<Type> itfbuf = new ListBuffer<>();\n+                    for (Type itf : ct.interfaces_field) {\n+                        itfbuf.add(\n+                                addTypeAnnotations(\n+                                        itf,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++)));\n+                    }\n+                    ct.interfaces_field = itfbuf.toList();\n+                } else {\n+                    bound =\n+                            addTypeAnnotations(\n+                                    bound,\n+                                    typeParameterBound(\n+                                            boundType,\n+                                            typeVariableIndex,\n+                                            bound.isInterface() ? 1 : 0));\n+                }\n+                ((TypeVar) tvar).setUpperBound(bound);\n+                tvarbuf.add(tvar);\n+                typeVariableIndex++;\n+            }\n+            return tvarbuf.toList();\n+        }\n+\n+        private Type addTypeAnnotations(Type type, TargetType targetType) {\n+            return addTypeAnnotations(type, pos -> pos.type == targetType);\n+        }\n+\n+        private Type addTypeAnnotations(Type type, Predicate<TypeAnnotationPosition> filter) {\n+            Assert.checkNonNull(type);\n+\n+            \/\/ Find type annotations that match the given target type\n+            ListBuffer<Attribute.TypeCompound> filtered = new ListBuffer<>();\n+            for (Attribute.TypeCompound attribute : this.attributes) {\n+                if (filter.test(attribute.position)) {\n+                    filtered.add(attribute);\n+                }\n+            }\n+            if (filtered.isEmpty()) {\n+                return type;\n+            }\n+\n+            \/\/ Group the matching annotations by their type path. Each group of annotations will be\n+            \/\/ added to a type at that location.\n+            Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>> attributesByPath = new HashMap<>();\n+            for (Attribute.TypeCompound attribute : filtered.toList()) {\n+                attributesByPath\n+                        .computeIfAbsent(attribute.position.location, k -> new ListBuffer<>())\n+                        .add(attribute);\n+            }\n+\n+            \/\/ Search the structure of the type to find the contained types at each type path\n+            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n+            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n+\n+            \/\/ Rewrite the type and add the annotations\n+            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n+            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+\n+            return type;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> typeParameterBound(\n+                TargetType targetType, int parameterIndex, int boundIndex) {\n+            return pos ->\n+                    pos.type == targetType\n+                            && pos.parameter_index == parameterIndex\n+                            && pos.bound_index == boundIndex;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> methodFormalParameter(int index) {\n+            return pos -> pos.type == TargetType.METHOD_FORMAL_PARAMETER && pos.parameter_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> thrownType(int index) {\n+            return pos -> pos.type == TargetType.THROWS && pos.type_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> classExtends(int index) {\n+            return pos -> pos.type == TargetType.CLASS_EXTENDS && pos.type_index == index;\n+        }\n+    }\n+\n+    \/**\n+     * Visit all contained types, assembling a type path to represent the current location, and\n+     * record the types at each type path that need to be annotated.\n+     *\/\n+    private static class TypeAnnotationLocator\n+            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+        private final Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>> attributesByPath;\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationLocator(\n+                Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>> attributesByPath,\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByPath = attributesByPath;\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            \/\/ As described in JVMS 4.7.20.2, type annotations on nested types are located with\n+            \/\/ 'left-to-right' steps starting on 'the outermost part of the type for which a type\n+            \/\/ annotation is admissible'. So the current path represents the outermost containing\n+            \/\/ type of the type being visited, and we add type path steps for every contained nested\n+            \/\/ type.\n+            List<ClassType> enclosing = List.nil();\n+            for (Type curr = t;\n+                 curr != null && curr != Type.noType;\n+                 curr = curr.getEnclosingType()) {\n+                enclosing = enclosing.prepend((ClassType) curr);\n+            }\n+            for (ClassType te : enclosing) {\n+                if (te.typarams_field != null) {\n+                    int i = 0;\n+                    for (Type typaram : te.typarams_field) {\n+                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n+                    }\n+                }\n+                visitType(te, path);\n+                path = path.append(TypeAnnotationPosition.TypePathEntry.INNER_TYPE);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            return super.visitWildcardType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            return super.visitArrayType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            if (attributes != null) {\n+                attributesByType.put(t, attributes.toList());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/** A type mapping that rewrites the type to include type annotations. *\/\n+    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n+\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationTypeMapping(Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n+            \/\/ We're relying on object identify of Type instances to record where the annotations need to be added,\n+            \/\/ so we have to retrieve the annotations for each type before rewriting it, and then add them after\n+            \/\/ it's contained types have been rewritten.\n+            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n+            Type mapped = f.apply(t, null);\n+            if (attributes == null) {\n+                return mapped;\n+            }\n+            \/\/ Runtime-visible and -invisible annotations are completed separately, so if the same type has annotations\n+            \/\/ from both it will get annotated twice.\n+            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n+            if (existing != null) {\n+                existing.annotationBuffer().addAll(attributes);\n+                return mapped;\n+            }\n+            return mapped.annotatedType(attributes);\n+        }\n+\n+        @Override\n+        public Type visitClassType(ClassType t, Void unused) {\n+            return reannotate(t, super::visitClassType);\n+        }\n+\n+        @Override\n+        public Type visitWildcardType(WildcardType t, Void unused) {\n+            return reannotate(t, super::visitWildcardType);\n+        }\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Void unused) {\n+            return reannotate(t, super::visitArrayType);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void unused) {\n+            return reannotate(t, (x, u) -> x);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":292,"deletions":1,"binary":false,"changes":293,"status":"modified"}]}