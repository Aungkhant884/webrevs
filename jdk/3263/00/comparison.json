{"files":[{"patch":"@@ -647,1 +647,1 @@\n-                InputStream in = uc.getInputStream();\n+\n@@ -655,0 +655,2 @@\n+\n+                InputStream in = uc.getInputStream();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,2 +120,0 @@\n-\n-\n@@ -124,2 +122,2 @@\n-            \/* the factory call will do the security checks *\/\n-            jarFile = factory.get(getJarFileURL(), getUseCaches());\n+            boolean useCaches = getUseCaches();\n+            String entryName = this.entryName;\n@@ -127,8 +125,8 @@\n-            \/* we also ask the factory the permission that was required\n-             * to get the jarFile, and set it as our permission.\n-             *\/\n-            if (getUseCaches()) {\n-                boolean oldUseCaches = jarFileURLConnection.getUseCaches();\n-                jarFileURLConnection = factory.getConnection(jarFile);\n-                jarFileURLConnection.setUseCaches(oldUseCaches);\n-            }\n+            \/* the factory call will do the security checks *\/\n+            URL url = getJarFileURL();\n+            \/\/ if we have an entry name, and the jarfile is local,\n+            \/\/ don't put the jar into the cache until after we have\n+            \/\/ validated that the entry name exists\n+            jarFile = entryName == null\n+                    ? factory.get(url, useCaches)\n+                    : factory.getOrCreate(url, useCaches);\n@@ -137,1 +135,1 @@\n-                jarEntry = (JarEntry)jarFile.getEntry(entryName);\n+                jarEntry = (JarEntry) jarFile.getEntry(entryName);\n@@ -140,3 +138,4 @@\n-                        if (!getUseCaches()) {\n-                            jarFile.close();\n-                        }\n+                        \/\/ only close the jar file if it isn't in the\n+                        \/\/ cache. If the jar file is local, it won't be\n+                        \/\/ in the cache yet, and so will be closed here.\n+                        factory.closeIfNotCached(url, jarFile);\n@@ -146,2 +145,2 @@\n-                                                    \" not found in \" +\n-                                                    jarFile.getName());\n+                            \" not found in \" +\n+                            jarFile.getName());\n@@ -150,0 +149,21 @@\n+\n+            \/\/ we have validated that the entry exists.\n+            \/\/ if useCaches was requested, update the cache now.\n+            if (useCaches && entryName != null) {\n+                \/\/ someone may have beat us and updated the cache\n+                \/\/ already - in which case - cacheIfAbsent will\n+                \/\/ return false. cacheIfAbsent returns true if\n+                \/\/ our jarFile is in the cache when the method\n+                \/\/ returns, whether because it put it there or\n+                \/\/ because it found it there.\n+                useCaches = factory.cacheIfAbsent(url, jarFile);\n+            }\n+\n+            \/* we also ask the factory the permission that was required\n+             * to get the jarFile, and set it as our permission.\n+             *\/\n+            if (useCaches) {\n+                boolean oldUseCaches = jarFileURLConnection.getUseCaches();\n+                jarFileURLConnection = factory.getConnection(jarFile);\n+                jarFileURLConnection.setUseCaches(oldUseCaches);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarURLConnection.java","additions":39,"deletions":19,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-    private static boolean isFileURL(URL url) {\n+    static boolean isFileURL(URL url) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/URLJarFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,69 @@\n+    \/**\n+     * Get or create a {@code JarFile} for the given {@code url}.\n+     * If {@code useCaches} is true, this method attempts to find\n+     * a jar file in the cache, and if so, returns it.\n+     * If no jar file is found in the cache, or {@code useCaches}\n+     * is false, the method creates a new jar file.\n+     * If the URL points to a local file, the returned jar file\n+     * will not be put in the cache yet.\n+     * The caller should then call {@link #cacheIfAbsent(URL, JarFile)}\n+     * with the returned jar file, if updating the cache is desired.\n+     * @param url the jar file url\n+     * @param useCaches whether the cache should be used\n+     * @return a new or cached jar file.\n+     * @throws IOException if the jar file couldn't be created\n+     *\/\n+    JarFile getOrCreate(URL url, boolean useCaches) throws IOException {\n+        if (useCaches == false) {\n+            return get(url, false);\n+        }\n+\n+        if (!URLJarFile.isFileURL(url)) {\n+            \/\/ A temporary file will be created, we can prepopulate\n+            \/\/ the cache in this case.\n+            return get(url, useCaches);\n+        }\n+\n+        \/\/ We have a local file. Do not prepopulate the cache.\n+        JarFile result;\n+        synchronized (instance) {\n+            result = getCachedJarFile(url);\n+        }\n+        if (result == null) {\n+            result = URLJarFile.getJarFile(url, this);\n+        }\n+        if (result == null)\n+            throw new FileNotFoundException(url.toString());\n+        return result;\n+    }\n+\n+    \/**\n+     * Close the given jar file if it isn't present in the cache.\n+     * Otherwise, does nothing.\n+     * @param url the jar file URL\n+     * @param jarFile the jar file to close\n+     * @return true if the jar file has been closed, false otherwise.\n+     * @throws IOException if an error occurs while closing the jar file.\n+     *\/\n+    boolean closeIfNotCached(URL url, JarFile jarFile) throws IOException {\n+        JarFile result;\n+        synchronized (instance) {\n+            result = getCachedJarFile(url);\n+        }\n+        if (result != jarFile) jarFile.close();\n+        return result != jarFile;\n+    }\n+\n+    boolean cacheIfAbsent(URL url, JarFile jarFile) {\n+        JarFile cached;\n+        synchronized (instance) {\n+            String key = urlKey(url);\n+            cached = fileCache.get(key);\n+            if (cached == null) {\n+                fileCache.put(key, jarFile);\n+                urlCache.put(jarFile, url);\n+            }\n+        }\n+        return cached == null || cached == jarFile;\n+    }\n+\n@@ -109,1 +178,1 @@\n-     * indicate that the JarFile is close. This way we can\n+     * indicate that the JarFile is closed. This way we can\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -74,1 +74,77 @@\n-    JarFile get(URL url, boolean useCaches) throws IOException {\n+    \/**\n+     * Get or create a {@code JarFile} for the given {@code url}.\n+     * If {@code useCaches} is true, this method attempts to find\n+     * a jar file in the cache, and if so, returns it.\n+     * If no jar file is found in the cache, or {@code useCaches}\n+     * is false, the method creates a new jar file.\n+     * If the URL points to a local file, the returned jar file\n+     * will not be put in the cache yet.\n+     * The caller should then call {@link #cacheIfAbsent(URL, JarFile)}\n+     * with the returned jar file, if updating the cache is desired.\n+     * @param url the jar file url\n+     * @param useCaches whether the cache should be used\n+     * @return a new or cached jar file.\n+     * @throws IOException if the jar file couldn't be created\n+     *\/\n+    JarFile getOrCreate(URL url, boolean useCaches) throws IOException {\n+        if (useCaches == false) {\n+            return get(url, false);\n+        }\n+        URL patched = urlFor(url);\n+        if (!URLJarFile.isFileURL(patched)) {\n+            \/\/ A temporary file will be created, we can prepopulate\n+            \/\/ the cache in this case.\n+            return get(url, useCaches);\n+        }\n+\n+        \/\/ We have a local file. Do not prepopulate the cache.\n+        JarFile result;\n+        synchronized (instance) {\n+            result = getCachedJarFile(patched);\n+        }\n+        if (result == null) {\n+            result = URLJarFile.getJarFile(patched, this);\n+        }\n+        if (result == null)\n+            throw new FileNotFoundException(url.toString());\n+        return result;\n+    }\n+\n+    \/**\n+     * Close the given jar file if it isn't present in the cache.\n+     * Otherwise, does nothing.\n+     * @param url the jar file URL\n+     * @param jarFile the jar file to close\n+     * @return true if the jar file has been closed, false otherwise.\n+     * @throws IOException if an error occurs while closing the jar file.\n+     *\/\n+    boolean closeIfNotCached(URL url, JarFile jarFile) throws IOException {\n+        url = urlFor(url);\n+        JarFile result;\n+        synchronized (instance) {\n+            result = getCachedJarFile(url);\n+        }\n+        if (result != jarFile) jarFile.close();\n+        return result != jarFile;\n+    }\n+\n+    boolean cacheIfAbsent(URL url, JarFile jarFile) {\n+        try {\n+            url = urlFor(url);\n+        } catch (IOException x) {\n+            \/\/ should not happen\n+            return false;\n+        }\n+        JarFile cached;\n+        synchronized (instance) {\n+            String key = urlKey(url);\n+            cached = fileCache.get(key);\n+            if (cached == null) {\n+                fileCache.put(key, jarFile);\n+                urlCache.put(jarFile, url);\n+            }\n+        }\n+        return cached == null || cached == jarFile;\n+    }\n+\n+    private URL urlFor(URL url) throws IOException {\n@@ -80,1 +156,1 @@\n-                !host.equalsIgnoreCase(\"localhost\")) {\n+                    !host.equalsIgnoreCase(\"localhost\")) {\n@@ -85,0 +161,6 @@\n+        return url;\n+    }\n+\n+    JarFile get(URL url, boolean useCaches) throws IOException {\n+\n+        url = urlFor(url);\n@@ -119,1 +201,1 @@\n-     * indicate that the JarFile is close. This way we can\n+     * indicate that the JarFile is closed. This way we can\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":85,"deletions":3,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264048\n+ *\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar true false testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar false true testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar false false testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Test badpath\n+ *\n+ * @summary URLClassLoader.close() doesn't close cached JAR file on Windows when load() fails\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.net.URLConnection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipException;\n+import java.util.spi.ToolProvider;\n+\n+public class RemoveJar {\n+    private final static String TEST_PKG = \"testpkg\";\n+    private final static String JAR_DIR = \"testjar\/\" + TEST_PKG;\n+    private final static String FILE_NAME = \"testjar.jar\";\n+    private final static ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final static PrintStream out = new PrintStream(baos);\n+    private final static ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    private static void buildJar() throws IOException {\n+        \/\/ create dir\n+        mkdir(JAR_DIR);\n+        \/\/ create file\n+        Path path = Paths.get(JAR_DIR);\n+        String src = \"package \" + TEST_PKG + \";\\n\" +\n+                \"class Test {}\\n\";\n+        Files.write(Paths.get(JAR_DIR + \"\/Test.java\"), src.getBytes());\n+        \/\/ compile class\n+        compile(JAR_DIR + \"\/Test.java\");\n+        \/\/ package jar\n+        jar(\"-cf testjar.jar \" + JAR_DIR);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        buildJar();\n+\n+        URLClassLoader loader = null;\n+        URL url = null;\n+        Path path = Paths.get(FILE_NAME);\n+\n+        boolean useCacheFirst = Boolean.parseBoolean(args[0]);\n+        boolean useCacheSecond = Boolean.parseBoolean(args[1]);\n+        String firstClass = args[2];\n+        String secondClass = args[3];\n+        String subPath = args[4];\n+\n+        try {\n+            String path_str = path.toUri().toURL().toString();\n+            URLConnection.setDefaultUseCaches(\"jar\", useCacheFirst);\n+\n+            url = new URL(\"jar\", \"\", path_str + \"!\/\" + subPath);\n+            loader = new URLClassLoader(new URL[]{url});\n+\n+            loader.loadClass(firstClass);\n+        } catch (Exception e) {\n+            System.err.println(\"EXCEPTION: \" + e);\n+        }\n+\n+        try {\n+            URLConnection.setDefaultUseCaches(\"jar\", useCacheSecond);\n+            loader.loadClass(secondClass);\n+        } catch (Exception e) {\n+            System.err.println(\"EXCEPTION: \" + e);\n+        } finally {\n+            loader.close();\n+            Files.delete(path);\n+        }\n+    }\n+\n+    private static Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private static void mkdir(String cmdline) {\n+        System.out.println(\"mkdir -p \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createDirectories(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private static void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        int rc = JAR_TOOL.run(out, err, cmdline.split(\" +\"));\n+        System.setErr(saveErr);\n+        if (rc != 0) {\n+            String s = baes.toString();\n+            if (s.startsWith(\"java.util.zip.ZipException: duplicate entry: \")) {\n+                throw new ZipException(s);\n+            }\n+            throw new IOException(s);\n+        }\n+    }\n+\n+    \/* run javac <args> *\/\n+    private static void compile(String... args) {\n+        if (com.sun.tools.javac.Main.compile(args) != 0) {\n+            throw new RuntimeException(\"javac failed: args=\" + Arrays.toString(args));\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/RemoveJar.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264048\n+ * @modules jdk.jartool\/sun.tools.jar\n+ *\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true true testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar true false testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar true false testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar false true testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false true testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar false false testpkg.Test testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Test testpkg.Missing testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Missing testpkg.Test testjar\/\n+ * @run main\/othervm RemoveJar false false testpkg.Missing testpkg.Missing testjar\/\n+ *\n+ * @run main\/othervm RemoveJar true true testpkg.Test testpkg.Test badpath\n+ *\n+ * @summary URLClassLoader.close() doesn't close cached JAR file on Windows when load() fails\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.net.URLConnection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipException;\n+\n+import sun.tools.jar.Main;\n+\n+public class RemoveJar {\n+    private final static String TEST_PKG = \"testpkg\";\n+    private final static String JAR_DIR = \"testjar\/\" + TEST_PKG;\n+    private final static String FILE_NAME = \"testjar.jar\";\n+    private final static ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final static PrintStream out = new PrintStream(baos);\n+\n+    private static void buildJar() throws IOException {\n+        \/\/ create dir\n+        mkdir(JAR_DIR);\n+        \/\/ create file\n+        Path path = Paths.get(JAR_DIR);\n+        String src = \"package \" + TEST_PKG + \";\\n\" +\n+                \"class Test {}\\n\";\n+        Files.write(Paths.get(JAR_DIR + \"\/Test.java\"), src.getBytes());\n+        \/\/ compile class\n+        compile(JAR_DIR + \"\/Test.java\");\n+        \/\/ package jar\n+        jar(\"-cf testjar.jar \" + JAR_DIR);\n+    }\n+\n+    public static void setDefaultUseCaches(boolean useCaches)\n+            throws IOException, MalformedURLException {\n+        URL url = new URL(\"jar\", \"\", \"file:\/\/testjar.jar!\/\");\n+        URLConnection uConn = url.openConnection();\n+        uConn.setDefaultUseCaches(useCaches);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        buildJar();\n+\n+        URLClassLoader loader = null;\n+        URL url;\n+        Path path = Paths.get(FILE_NAME);\n+\n+        boolean useCacheFirst = Boolean.parseBoolean(args[0]);\n+        boolean useCacheSecond = Boolean.parseBoolean(args[1]);\n+        String firstClass = args[2];\n+        String secondClass = args[3];\n+        String subPath = args[4];\n+\n+        try {\n+            String path_str = path.toUri().toURL().toString();\n+            setDefaultUseCaches(useCacheFirst);\n+\n+            url = new URL(\"jar\", \"\", path_str + \"!\/\" + subPath);\n+            loader = new URLClassLoader(new URL[]{url});\n+\n+            loader.loadClass(firstClass);\n+        } catch (Exception e) {\n+            System.err.println(\"EXCEPTION: \" + e);\n+        }\n+\n+        try {\n+            setDefaultUseCaches(useCacheSecond);\n+            loader.loadClass(secondClass);\n+        } catch (Exception e) {\n+            System.err.println(\"EXCEPTION: \" + e);\n+        } finally {\n+            loader.close();\n+            Files.delete(path);\n+        }\n+    }\n+\n+    private static Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private static void mkdir(String cmdline) {\n+        System.out.println(\"mkdir -p \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createDirectories(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private static void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+\n+        Main jarMain = new Main(out, err, \"jar\");\n+        boolean res = jarMain.run(cmdline.split(\" +\"));\n+        System.setErr(saveErr);\n+        if (!res) {\n+            String s = baes.toString();\n+            if (s.startsWith(\"java.util.zip.ZipException: duplicate entry: \")) {\n+                throw new ZipException(s);\n+            }\n+            throw new IOException(s);\n+        }\n+    }\n+\n+    \/* run javac <args> *\/\n+    private static void compile(String... args) {\n+        if (com.sun.tools.javac.Main.compile(args) != 0) {\n+            throw new RuntimeException(\"javac failed: args=\" + Arrays.toString(args));\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/misc\/URLClassPath\/RemoveJar.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"}]}