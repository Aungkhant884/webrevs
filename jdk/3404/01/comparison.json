{"files":[{"patch":"@@ -1636,0 +1636,59 @@\n+\/\/------------------------------inline_math_pow-----------------------------\n+bool LibraryCallKit::inline_math_pow() {\n+  Node* exp = round_double_node(argument(2));\n+  const TypeD* d = _gvn.type(exp)->isa_double_constant();\n+  if (d != NULL) {\n+    if (d->getd() == 2.0) {\n+      \/\/ Special case: pow(x, 2.0) => x * x\n+      Node* base = round_double_node(argument(0));\n+      set_result(_gvn.transform(new MulDNode(base, base)));\n+      return true;\n+    }\n+#if defined(X86) && defined(_LP64)\n+    else if (d->getd() == 0.5 && Matcher::match_rule_supported(Op_SqrtD)) {\n+      \/\/ Special case: pow(x, 0.5) => sqrt(x)\n+      Node* base = round_double_node(argument(0));\n+      Node* zero = _gvn.zerocon(T_DOUBLE);\n+\n+      RegionNode* region = new RegionNode(3);\n+      Node* phi = new PhiNode(region, Type::DOUBLE);\n+\n+      Node* cmp  = _gvn.transform(new CmpDNode(base, zero));\n+      Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::lt));\n+\n+      Node* if_pow = generate_slow_guard(test, NULL);\n+      Node* value_sqrt = _gvn.transform(new SqrtDNode(C, control(), base));\n+      phi->init_req(1, value_sqrt);\n+      region->init_req(1, control());\n+\n+      if (if_pow != NULL) {\n+        set_control(if_pow);\n+        address target = StubRoutines::dpow() != NULL ? StubRoutines::dpow() :\n+                                                        CAST_FROM_FN_PTR(address, SharedRuntime::dpow);\n+        const TypePtr* no_memory_effects = NULL;\n+        Node* trig = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(), target, \"POW\",\n+                                       no_memory_effects, base, top(), exp, top());\n+        Node* value_pow = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));\n+#ifdef ASSERT\n+        Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));\n+        assert(value_top == top(), \"second value must be top\");\n+#endif\n+        phi->init_req(2, value_pow);\n+        region->init_req(2, _gvn.transform(new ProjNode(trig, TypeFunc::Control)));\n+      }\n+\n+      C->set_has_split_ifs(true); \/\/ Has chance for split-if optimization\n+      set_control(_gvn.transform(region));\n+      record_for_igvn(region);\n+      set_result(_gvn.transform(phi));\n+\n+      return true;\n+    }\n+#endif \/\/ defined(X86) && defined(_LP64)\n+  }\n+\n+  return StubRoutines::dpow() != NULL ?\n+    runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  \"dpow\") :\n+    runtime_math(OptoRuntime::Math_DD_D_Type(), CAST_FROM_FN_PTR(address, SharedRuntime::dpow),  \"POW\");\n+}\n+\n@@ -1676,13 +1735,0 @@\n-  case vmIntrinsics::_dpow: {\n-    Node* exp = round_double_node(argument(2));\n-    const TypeD* d = _gvn.type(exp)->isa_double_constant();\n-    if (d != NULL && d->getd() == 2.0) {\n-      \/\/ Special case: pow(x, 2.0) => x * x\n-      Node* base = round_double_node(argument(0));\n-      set_result(_gvn.transform(new MulDNode(base, base)));\n-      return true;\n-    }\n-    return StubRoutines::dpow() != NULL ?\n-      runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  \"dpow\") :\n-      runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  \"POW\");\n-  }\n@@ -1691,0 +1737,1 @@\n+  case vmIntrinsics::_dpow:      return inline_math_pow();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":60,"deletions":13,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,1 @@\n+  bool inline_math_pow();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}