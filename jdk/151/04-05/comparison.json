{"files":[{"patch":"@@ -44,0 +44,2 @@\n+  \/\/ Keeps track of emitted and completed handshake operations.\n+  \/\/ Once it reaches zero all handshake operations have been performed.\n@@ -60,1 +62,1 @@\n-  bool is_asynch()                 { return _handshake_cl->is_asynch(); }\n+  bool is_async()                  { return _handshake_cl->is_async(); }\n@@ -69,1 +71,1 @@\n-  virtual ~AsyncHandshakeOperation() { delete _handshake_cl; };\n+  virtual ~AsyncHandshakeOperation() { delete _handshake_cl; }\n@@ -185,2 +187,2 @@\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-    if (thr->handshake_state()->has_operation()) {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* thr = jtiwh.next(); ) {\n+    if (thr->handshake_state()->has_operation_for_self()) {\n@@ -195,1 +197,1 @@\n-static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int requester_executed, const char* extra = NULL) {\n+static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int non_self_executed, const char* extra = NULL) {\n@@ -200,1 +202,1 @@\n-                        requester_executed,\n+                        non_self_executed,\n@@ -216,1 +218,1 @@\n-    for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+    for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n@@ -230,1 +232,3 @@\n-    int executed_by_driver = 0;\n+    \/\/ Keeps count on how many of own emitted handshakes\n+    \/\/ this thread execute.\n+    int emitted_handshakes_executed = 0;\n@@ -241,1 +245,1 @@\n-      for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+      for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n@@ -247,1 +251,1 @@\n-          executed_by_driver++;\n+          emitted_handshakes_executed++;\n@@ -259,1 +263,1 @@\n-    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, executed_by_driver);\n+    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, emitted_handshakes_executed);\n@@ -315,1 +319,3 @@\n-  int executed_by_driver = 0;\n+  \/\/ Keeps count on how many of own emitted handshakes\n+  \/\/ this thread execute.\n+  int emitted_handshakes_executed = 0;\n@@ -320,1 +326,1 @@\n-      executed_by_driver++;\n+      emitted_handshakes_executed++;\n@@ -340,1 +346,1 @@\n-  log_handshake_info(start_time_ns, op.name(), 1, executed_by_driver);\n+  log_handshake_info(start_time_ns, op.name(), 1, emitted_handshakes_executed);\n@@ -356,2 +362,2 @@\n-HandshakeState::HandshakeState(JavaThread* thread) :\n-  _handshakee(thread),\n+HandshakeState::HandshakeState(JavaThread* target) :\n+  _handshakee(target),\n@@ -368,1 +374,1 @@\n-  _queue.add(op);\n+  _queue.push(op);\n@@ -373,0 +379,1 @@\n+  assert(_handshakee == Thread::current(), \"Must be called by self\");\n@@ -377,2 +384,2 @@\n-static bool processor_filter(HandshakeOperation* op) {\n-  return !op->is_asynch();\n+static bool non_self_queue_filter(HandshakeOperation* op) {\n+  return !op->is_async();\n@@ -381,1 +388,2 @@\n-bool HandshakeState::has_operation_for_processor() {\n+bool HandshakeState::has_operation() {\n+  assert(_handshakee != Thread::current(), \"Must not be called by self\");\n@@ -383,1 +391,1 @@\n-  return _queue.contains(processor_filter);\n+  return _queue.contains(non_self_queue_filter);\n@@ -386,1 +394,2 @@\n-HandshakeOperation* HandshakeState::pop_for_processor() {\n+HandshakeOperation* HandshakeState::pop() {\n+  assert(_handshakee != Thread::current(), \"Must not be called by self\");\n@@ -388,1 +397,1 @@\n-  return _queue.pop(processor_filter);\n+  return _queue.pop(non_self_queue_filter);\n@@ -405,1 +414,1 @@\n-  while (block_for_operation()) {\n+  while (should_process()) {\n@@ -412,2 +421,1 @@\n-      assert(_handshakee == Thread::current(), \"Wrong thread\");\n-      bool asynch = op->is_asynch();\n+      bool async = op->is_async();\n@@ -415,1 +423,1 @@\n-                           asynch ? \"asynchronous\" : \"synchronous\", p2i(op), p2i(_handshakee));\n+                           async ? \"asynchronous\" : \"synchronous\", p2i(op), p2i(_handshakee));\n@@ -417,1 +425,1 @@\n-      if (asynch) {\n+      if (async) {\n@@ -457,1 +465,1 @@\n-  if (has_operation_for_processor()) {\n+  if (has_operation()) {\n@@ -467,1 +475,1 @@\n-  if (!has_operation()) {\n+  if (!has_operation_for_self()) {\n@@ -496,1 +504,1 @@\n-    HandshakeOperation* op = pop_for_processor();\n+    HandshakeOperation* op = pop();\n@@ -514,1 +522,1 @@\n-  } while (has_operation_for_processor());\n+  } while (has_operation());\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -37,8 +37,5 @@\n-\/\/ A handshake closure is a callback that is executed for each JavaThread\n-\/\/ while that thread is in a safepoint safe state. The callback is executed\n-\/\/ either by the target JavaThread itself or by the VMThread while keeping\n-\/\/ the target thread in a blocked state. A handshake can be performed with a\n-\/\/ single JavaThread as well. In that case, the callback is executed either\n-\/\/ by the target JavaThread itself or, depending on whether the operation is\n-\/\/ a single target\/direct handshake or not, by the JavaThread that requested the\n-\/\/ handshake or the VMThread respectively.\n+\/\/ A handshake closure is a callback that is executed for a JavaThread\n+\/\/ while it is in a safepoint\/handshake-safe state. Depending on the\n+\/\/ nature of the closure, the callback may be executed by the initiating\n+\/\/ thread, the target thread, or the VMThread. If the callback is not executed\n+\/\/ by the target thread it will remain in a blocked state until the callback completes.\n@@ -51,1 +48,1 @@\n-  virtual bool is_asynch()    { return false; };\n+  virtual bool is_async()     { return false; }\n@@ -59,1 +56,1 @@\n-   virtual bool is_asynch()          { return true; }\n+   virtual bool is_async()          { return true; }\n@@ -75,0 +72,2 @@\n+  \/\/ This a back reference to the JavaThread, \n+  \/\/ the target for all operation in the queue.\n@@ -76,0 +75,1 @@\n+  \/\/ The queue containing handshake operations to be performed on _handshakee.\n@@ -77,0 +77,1 @@\n+  \/\/ Provides mutual exclusion to this state and queue.\n@@ -78,0 +79,1 @@\n+  \/\/ Set to the thread executing the handshake operation during the execution.\n@@ -90,1 +92,1 @@\n-  HandshakeOperation* pop_for_processor();\n+  HandshakeOperation* pop();\n@@ -92,2 +94,2 @@\n-  bool has_operation_for_processor();\n-  bool has_operation() {\n+  bool has_operation();\n+  bool has_operation_for_self() {\n@@ -96,1 +98,1 @@\n-  bool block_for_operation() {\n+  bool should_process() {\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  if (thread->handshake_state()->block_for_operation()) {\n+  if (thread->handshake_state()->should_process()) {\n@@ -99,1 +99,1 @@\n-    if (global_poll() || thread->handshake_state()->has_operation()) {\n+    if (global_poll() || thread->handshake_state()->has_operation_for_self()) {\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1359,1 +1359,1 @@\n-  \/\/ can do it safely it if they are the active handshaker.\n+  \/\/ can do it safely if they are the active handshaker.\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+\/\/ The FilterQueue is FIFO with the ability to skip over queued items.\n+\/\/ The skipping is controlled by using a filter when poping.\n+\/\/ It also supports lock free pushes, while poping (including contain())\n+\/\/ needs to be externally serialized.\n@@ -34,1 +38,1 @@\n-  class FilterQueueNode : public CHeapObj<mtInternal> {\n+  class Node : public CHeapObj<mtInternal> {\n@@ -36,2 +40,2 @@\n-    FilterQueueNode(const E& e): _next(NULL), _data(e) { }\n-    FilterQueueNode*    _next;\n+    Node(const E& e): _next(NULL), _data(e) { }\n+    Node*    _next;\n@@ -41,2 +45,2 @@\n-  FilterQueueNode* _first;\n-  FilterQueueNode* load_first() {\n+  Node* _first;\n+  Node* load_first() {\n@@ -51,1 +55,0 @@\n-  \/\/ MT-safe\n@@ -56,2 +59,2 @@\n-  \/\/ MT-safe\n-  void add(E data);\n+  \/\/ Adds an item to the queue in a MT safe way, re-entrant.\n+  void push(E data);\n@@ -59,1 +62,5 @@\n-  \/\/ MT-Unsafe, external serialization needed.\n+  \/\/ Applies the match_func to the items in the queue until match_func returns\n+  \/\/ true and then return false, or there is no more items and then returns\n+  \/\/ false. Any pushed item while executing may or may not have match_func\n+  \/\/ applied. The method is not re-entrant and must be executed mutually\n+  \/\/ exclusive other contains and pops calls.\n@@ -63,1 +70,2 @@\n-  \/\/ MT-Unsafe, external serialization needed.\n+  \/\/ Same as pop(MATCH_FUNC& match_func) but matches everything, thus returning\n+  \/\/ the first inserted item.\n@@ -68,1 +76,5 @@\n-  \/\/ MT-Unsafe, external serialization needed.\n+  \/\/ Applies the match_func to all items in the queue returns the item which\n+  \/\/ match_func return true for and was inserted first. Any pushed item while\n+  \/\/ executing may or may not have be popped, if popped it was the first\n+  \/\/ inserted match. The method is not re-entrant and must be executed mutual\n+  \/\/ exclusive with other contains and pops calls.\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n-void FilterQueue<E>::add(E data) {\n-  FilterQueueNode* head;\n-  FilterQueueNode* insnode = new FilterQueueNode(data);\n+void FilterQueue<E>::push(E data) {\n+  Node* head;\n+  Node* insnode = new Node(data);\n@@ -50,1 +50,1 @@\n-  FilterQueueNode* cur = load_first();\n+  Node* cur = load_first();\n@@ -67,5 +67,5 @@\n-  FilterQueueNode*  first       = load_first();\n-  FilterQueueNode*  cur         = first;\n-  FilterQueueNode*  prev        = NULL;\n-  FilterQueueNode*  match       = NULL;\n-  FilterQueueNode*  match_prev  = NULL;\n+  Node*  first       = load_first();\n+  Node*  cur         = first;\n+  Node*  prev        = NULL;\n+  Node*  match       = NULL;\n+  Node*  match_prev  = NULL;\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  queue.add(1);\n+  queue.push(1);\n@@ -78,2 +78,2 @@\n-  queue.add(1);\n-  queue.add(2);\n+  queue.push(1);\n+  queue.push(2);\n@@ -95,1 +95,1 @@\n-  queue.add(3);\n+  queue.push(3);\n@@ -99,1 +99,1 @@\n-  queue.add(2);\n+  queue.push(2);\n@@ -118,3 +118,3 @@\n-  queue.add(1);\n-  queue.add(2);\n-  queue.add(3);\n+  queue.push(1);\n+  queue.push(2);\n+  queue.push(3);\n@@ -151,1 +151,1 @@\n-        _fq->add(_val);\n+        _fq->push(_val);\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}