{"files":[{"patch":"@@ -691,3 +691,3 @@\n-  \/\/ java_thread is thread owning the monitors.\n-  \/\/ current_thread is thread executint this code, can be a non-JavaThread (e.g. VM Thread).\n-  \/\/ And they all maybe different threads.\n+  \/\/ java_thread is the thread owning the monitors.\n+  \/\/ current_thread is the thread executing this code, can be a non-JavaThread (e.g. VM Thread).\n+  \/\/ And they all may be different threads.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-\n+   bool _completed;\n@@ -256,1 +256,2 @@\n-      _bci(0) {}\n+      _bci(0),\n+      _completed(false) {}\n@@ -275,0 +276,1 @@\n+    _completed = true;\n@@ -280,0 +282,3 @@\n+  bool completed() {\n+    return _completed;\n+  }\n@@ -321,0 +326,1 @@\n+        guarantee(op.completed(), \"Handshake failed. Target thread is not alive?\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -197,3 +197,4 @@\n-\n-public:\n-  EnterInterpOnlyModeClosure() : HandshakeClosure(\"EnterInterpOnlyMode\") { }\n+ private:\n+  bool _completed;\n+ public:\n+  EnterInterpOnlyModeClosure() : HandshakeClosure(\"EnterInterpOnlyMode\"), _completed(false) { }\n@@ -223,0 +224,4 @@\n+    _completed = true;\n+  }\n+  bool completed() {\n+    return _completed = true;\n@@ -340,0 +345,1 @@\n+    guarantee(hs.completed(), \"Handshake failed: Target thread is not alive?\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2030,0 +2030,1 @@\n+    JavaThread* _self;\n@@ -2032,1 +2033,4 @@\n-      JavaThread* jt = (JavaThread*)th;\n+      \/\/ AsynchHandshake handshakes are only executed by target.\n+      assert(_self == th, \"Must be\");\n+      assert(Thread::current() == th, \"Must be\");\n+      JavaThread* jt = th->as_Java_thread();\n@@ -2040,1 +2044,1 @@\n-    TraceSelfClosure() : AsynchHandshakeClosure(\"WB_TraceSelf\") {}\n+    TraceSelfClosure(JavaThread* self_target) : AsynchHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n@@ -2042,2 +2046,0 @@\n-  TraceSelfClosure* tsc = new TraceSelfClosure();\n-\n@@ -2047,0 +2049,1 @@\n+    TraceSelfClosure* tsc = new TraceSelfClosure(target);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  jlong start_time()                 { return _start_time_ns; }\n+  jlong start_time() const           { return _start_time_ns; }\n@@ -246,1 +246,1 @@\n-        if (pr == HandshakeState::_succeed) {\n+        if (pr == HandshakeState::_succeeded) {\n@@ -309,1 +309,3 @@\n-    log_handshake_info(start_time_ns, op.name(), 0, 0, \"(thread dead)\");\n+    char buf[128];\n+    jio_snprintf(buf, sizeof(buf),  \"(thread= \" INTPTR_FORMAT \" dead)\", p2i(target));\n+    log_handshake_info(start_time_ns, op.name(), 0, 0, buf);\n@@ -317,1 +319,1 @@\n-    if (pr == HandshakeState::_succeed) {\n+    if (pr == HandshakeState::_succeeded) {\n@@ -450,1 +452,1 @@\n-  \/\/ Operations are added without lock and then the poll is armed.\n+  \/\/ Operations are added lock free and then the poll is armed.\n@@ -453,1 +455,1 @@\n-  \/\/ armed yet it is not safe to procced.\n+  \/\/ armed yet it is not safe to proceed.\n@@ -479,1 +481,1 @@\n-  \/\/ If we own the mutex at this point and while owning the mutex\n+  \/\/ If we own the mutex at this point and while owning the mutex we\n@@ -502,1 +504,1 @@\n-        pr_ret = HandshakeState::_succeed;\n+        pr_ret = HandshakeState::_succeeded;\n@@ -518,1 +520,1 @@\n-                       pr_ret == HandshakeState::_succeed ? \"including\" : \"excluding\", p2i(match_op));\n+                       pr_ret == HandshakeState::_succeeded ? \"including\" : \"excluding\", p2i(match_op));\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,6 +103,6 @@\n-      _no_operation = 0,\n-      _not_safe,\n-      _claim_failed,\n-      _processed,\n-      _succeed,\n-      _number_states\n+    _no_operation = 0,\n+    _not_safe,\n+    _claim_failed,\n+    _processed,\n+    _succeeded,\n+    _number_states\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -480,4 +480,2 @@\n-\/\/ A JavaThread is considered \"dangling\" if it is not the current\n-\/\/ thread, his not handshaking with current thread, as been added the Threads\n-\/\/ list, the system is not at a safepoint and the Thread is not \"protected\".\n-\/\/\n+\/\/ A JavaThread is considered dangling if it not handshake-safe with respect to\n+\/\/ the current thread, it is not on a ThreadsList, or not at safepoint.\n@@ -486,2 +484,2 @@\n-         ((JavaThread *) thread)->is_handshake_safe_for(Thread::current()) ||\n-         !((JavaThread *) thread)->on_thread_list() ||\n+         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n+         !thread->as_Java_thread()->on_thread_list() ||\n@@ -2442,3 +2440,2 @@\n-  assert(Thread::current()->is_VM_thread() ||\n-         is_handshake_safe_for(Thread::current()),\n-         \"should be in the vm thread, self or handshakee\");\n+  assert(is_handshake_safe_for(Thread::current()),\n+         \"should be self or handshakee\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1358,0 +1358,2 @@\n+  \/\/ A JavaThread can always safely operate on it self and other threads\n+  \/\/ can do it safely it if they are the active handshaker.\n@@ -1359,2 +1361,1 @@\n-    return _handshake.active_handshaker() == th ||\n-           this == th;\n+    return _handshake.active_handshaker() == th || this == th;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-  \/\/ Since pops and adds are allowed while we add, we do not know if _first is same even if it's the same address.\n-  \/\/ But that ABA race is benign.\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with mutiple failed CAS.\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with multiple failed CAS.\n@@ -76,1 +76,1 @@\n-  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with mutiple failed CAS.\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with multiple failed CAS.\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/AsyncHandshakeWalkStackTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n@@ -38,1 +37,1 @@\n-    public static Thread tthreads[];\n+    public static Thread testThreads[];\n@@ -41,3 +40,3 @@\n-        tthreads = new Thread[Runtime.getRuntime().availableProcessors()];\n-        for (int i = 0; i < tthreads.length; i++) {\n-            tthreads[i] = new Thread(() -> handshake());\n+        testThreads = new Thread[Runtime.getRuntime().availableProcessors()];\n+        for (int i = 0; i < testThreads.length; i++) {\n+            testThreads[i] = new Thread(() -> handshake());\n@@ -46,1 +45,1 @@\n-        for (Thread t : tthreads) {\n+        for (Thread t : testThreads) {\n@@ -52,1 +51,1 @@\n-        for (Thread t : tthreads) {\n+        for (Thread t : testThreads) {\n@@ -62,3 +61,3 @@\n-            wb.asyncHandshakeWalkStack(tthreads[rand.nextInt(tthreads.length)]);\n-            wb.handshakeWalkStack(tthreads[rand.nextInt(tthreads.length)], false);\n-            wb.handshakeWalkStack(tthreads[rand.nextInt(tthreads.length)], true);\n+            wb.asyncHandshakeWalkStack(testThreads[rand.nextInt(testThreads.length)]);\n+            wb.handshakeWalkStack(testThreads[rand.nextInt(testThreads.length)], false);\n+            wb.handshakeWalkStack(testThreads[rand.nextInt(testThreads.length)], true);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/MixedHandshakeWalkStackTest.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}