{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-class ThreadClosure: public Closure {\n+class ThreadClosure {\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1216,2 +1216,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1261,2 +1261,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1305,2 +1305,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1543,2 +1543,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1588,2 +1588,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1626,2 +1626,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1724,4 +1724,3 @@\n-        bool executed = Handshake::execute_direct(&op, java_thread);\n-        jvmtiError err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n-        if (err != JVMTI_ERROR_NONE) {\n-          return err;\n+        Handshake::execute(&op, java_thread);\n+        if (op.result() != JVMTI_ERROR_NONE) {\n+          return op.result();\n@@ -1759,2 +1758,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1808,2 +1807,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -652,4 +652,3 @@\n-  JavaThread *current_jt = JavaThread::current();\n-  assert(current_jt == java_thread ||\n-         current_jt == java_thread->active_handshaker(),\n-         \"call by myself or at direct handshake\");\n+  Thread *current_thread = Thread::current();\n+  assert(java_thread->is_handshake_safe_for(current_thread),\n+         \"call by myself or at handshake\");\n@@ -679,2 +678,2 @@\n-    HandleMark hm(current_jt);\n-    Handle     hobj(current_jt, obj);\n+    HandleMark hm(current_thread);\n+    Handle     hobj(current_thread, obj);\n@@ -690,0 +689,5 @@\n+  \/\/ Note:\n+  \/\/ calling_thread is the thread that requested the list of monitors for java_thread.\n+  \/\/ java_thread is the thread owning the monitors.\n+  \/\/ current_thread is the thread executing this code, can be a non-JavaThread (e.g. VM Thread).\n+  \/\/ And they all may be different threads.\n@@ -691,4 +695,3 @@\n-  JavaThread *current_jt = JavaThread::current();\n-  assert(current_jt == java_thread ||\n-         current_jt == java_thread->active_handshaker(),\n-         \"call by myself or at direct handshake\");\n+  Thread *current_thread = Thread::current();\n+  assert(java_thread->is_handshake_safe_for(current_thread),\n+         \"call by myself or at handshake\");\n@@ -697,2 +700,2 @@\n-    ResourceMark rm(current_jt);\n-    HandleMark   hm(current_jt);\n+    ResourceMark rm(current_thread);\n+    HandleMark   hm(current_thread);\n@@ -822,3 +825,2 @@\n-  assert(current_thread == java_thread ||\n-         SafepointSynchronize::is_at_safepoint() ||\n-         current_thread == java_thread->active_handshaker(),\n+  assert(SafepointSynchronize::is_at_safepoint() ||\n+         java_thread->is_handshake_safe_for(current_thread),\n@@ -906,3 +908,2 @@\n-  assert(current_thread == java_thread ||\n-         current_thread == java_thread->active_handshaker(),\n-         \"call by myself or at direct handshake\");\n+  assert(java_thread->is_handshake_safe_for(current_thread),\n+         \"call by myself or at handshake\");\n@@ -1162,3 +1163,2 @@\n-  assert(current_thread == thr ||\n-         SafepointSynchronize::is_at_safepoint() ||\n-         current_thread == thr->active_handshaker(),\n+  assert(SafepointSynchronize::is_at_safepoint() ||\n+         thr->is_handshake_safe_for(current_thread),\n@@ -1308,1 +1308,1 @@\n-JvmtiEnvBase::check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+JvmtiEnvBase::check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -1371,1 +1371,1 @@\n-  JavaThread* current_thread = JavaThread::current();\n+  Thread* current_thread = Thread::current();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+  jvmtiError check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -339,0 +339,10 @@\n+class JvmtiHandshakeClosure : public HandshakeClosure {\n+ protected:\n+  jvmtiError _result;\n+ public:\n+  JvmtiHandshakeClosure(const char* name)\n+    : HandshakeClosure(name),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n+  jvmtiError result() { return _result; }\n+};\n+\n@@ -340,1 +350,1 @@\n-class UpdateForPopTopFrameClosure : public HandshakeClosure {\n+class UpdateForPopTopFrameClosure : public JvmtiHandshakeClosure {\n@@ -343,1 +353,0 @@\n-  jvmtiError _result;\n@@ -347,4 +356,2 @@\n-    : HandshakeClosure(\"UpdateForPopTopFrame\"),\n-      _state(state),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+    : JvmtiHandshakeClosure(\"UpdateForPopTopFrame\"),\n+      _state(state) {}\n@@ -355,1 +362,1 @@\n-class SetFramePopClosure : public HandshakeClosure {\n+class SetFramePopClosure : public JvmtiHandshakeClosure {\n@@ -360,1 +367,0 @@\n-  jvmtiError _result;\n@@ -364,1 +370,1 @@\n-    : HandshakeClosure(\"SetFramePop\"),\n+    : JvmtiHandshakeClosure(\"SetFramePop\"),\n@@ -367,3 +373,1 @@\n-      _depth(depth),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+      _depth(depth) {}\n@@ -373,1 +377,0 @@\n-\n@@ -375,1 +378,1 @@\n-class GetOwnedMonitorInfoClosure : public HandshakeClosure {\n+class GetOwnedMonitorInfoClosure : public JvmtiHandshakeClosure {\n@@ -379,1 +382,0 @@\n-  jvmtiError _result;\n@@ -385,1 +387,1 @@\n-    : HandshakeClosure(\"GetOwnedMonitorInfo\"),\n+    : JvmtiHandshakeClosure(\"GetOwnedMonitorInfo\"),\n@@ -388,1 +390,0 @@\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE),\n@@ -390,1 +391,0 @@\n-  jvmtiError result() { return _result; }\n@@ -420,1 +420,1 @@\n-class GetCurrentContendedMonitorClosure : public HandshakeClosure {\n+class GetCurrentContendedMonitorClosure : public JvmtiHandshakeClosure {\n@@ -425,1 +425,0 @@\n-  jvmtiError _result;\n@@ -429,1 +428,1 @@\n-    : HandshakeClosure(\"GetCurrentContendedMonitor\"),\n+    : JvmtiHandshakeClosure(\"GetCurrentContendedMonitor\"),\n@@ -432,3 +431,1 @@\n-      _owned_monitor_ptr(mon_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+      _owned_monitor_ptr(mon_ptr) {}\n@@ -439,1 +436,1 @@\n-class GetStackTraceClosure : public HandshakeClosure {\n+class GetStackTraceClosure : public JvmtiHandshakeClosure {\n@@ -446,1 +443,0 @@\n-  jvmtiError _result;\n@@ -451,1 +447,1 @@\n-    : HandshakeClosure(\"GetStackTrace\"),\n+    : JvmtiHandshakeClosure(\"GetStackTrace\"),\n@@ -456,4 +452,1 @@\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result() { return _result; }\n+      _count_ptr(count_ptr) {}\n@@ -559,1 +552,1 @@\n-class GetFrameCountClosure : public HandshakeClosure {\n+class GetFrameCountClosure : public JvmtiHandshakeClosure {\n@@ -564,1 +557,0 @@\n-  jvmtiError _result;\n@@ -568,1 +560,1 @@\n-    : HandshakeClosure(\"GetFrameCount\"),\n+    : JvmtiHandshakeClosure(\"GetFrameCount\"),\n@@ -571,4 +563,1 @@\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result()    { return _result; }\n+      _count_ptr(count_ptr) {}\n@@ -579,1 +568,1 @@\n-class GetFrameLocationClosure : public HandshakeClosure {\n+class GetFrameLocationClosure : public JvmtiHandshakeClosure {\n@@ -585,1 +574,0 @@\n-  jvmtiError _result;\n@@ -590,1 +578,1 @@\n-    : HandshakeClosure(\"GetFrameLocation\"),\n+    : JvmtiHandshakeClosure(\"GetFrameLocation\"),\n@@ -594,4 +582,1 @@\n-      _location_ptr(location_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result()    { return _result; }\n+      _location_ptr(location_ptr) {}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -215,1 +215,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -226,1 +226,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -237,1 +237,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -251,1 +251,1 @@\n-\n+   bool _completed;\n@@ -256,1 +256,2 @@\n-      _bci(0) {}\n+      _bci(0),\n+      _completed(false) {}\n@@ -275,0 +276,1 @@\n+    _completed = true;\n@@ -280,0 +282,3 @@\n+  bool completed() {\n+    return _completed;\n+  }\n@@ -317,1 +322,1 @@\n-      if (current == _thread || _thread->active_handshaker() == current) {\n+      if (_thread->is_handshake_safe_for(current)) {\n@@ -320,2 +325,2 @@\n-        bool executed = Handshake::execute_direct(&op, _thread);\n-        guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+        Handshake::execute(&op, _thread);\n+        guarantee(op.completed(), \"Handshake failed. Target thread is not alive?\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -197,3 +197,4 @@\n-\n-public:\n-  EnterInterpOnlyModeClosure() : HandshakeClosure(\"EnterInterpOnlyMode\") { }\n+ private:\n+  bool _completed;\n+ public:\n+  EnterInterpOnlyModeClosure() : HandshakeClosure(\"EnterInterpOnlyMode\"), _completed(false) { }\n@@ -223,0 +224,4 @@\n+    _completed = true;\n+  }\n+  bool completed() {\n+    return _completed = true;\n@@ -336,1 +341,1 @@\n-  if (target == current || target->active_handshaker() == current) {\n+  if (target->is_handshake_safe_for(current)) {\n@@ -339,2 +344,2 @@\n-    bool executed = Handshake::execute_direct(&hs, target);\n-    guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+    Handshake::execute(&hs, target);\n+    guarantee(hs.completed(), \"Handshake failed: Target thread is not alive?\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -227,3 +227,2 @@\n-  assert(current_thread == get_thread() ||\n-         SafepointSynchronize::is_at_safepoint() ||\n-         current_thread == get_thread()->active_handshaker(),\n+  assert(SafepointSynchronize::is_at_safepoint() ||\n+         get_thread()->is_handshake_safe_for(current_thread),\n@@ -249,2 +248,1 @@\n-         JavaThread::current() == get_thread() ||\n-         Thread::current() == get_thread()->active_handshaker(),\n+         get_thread()->is_handshake_safe_for(Thread::current()),\n@@ -280,2 +278,2 @@\n-  JavaThread *current = JavaThread::current();\n-  guarantee(current == get_thread() || current == get_thread()->active_handshaker(),\n+  Thread *current = Thread::current();\n+  guarantee(get_thread()->is_handshake_safe_for(current),\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2029,0 +2029,26 @@\n+WB_ENTRY(void, WB_AsyncHandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class TraceSelfClosure : public AsyncHandshakeClosure {\n+    JavaThread* _self;\n+    void do_thread(Thread* th) {\n+      assert(th->is_Java_thread(), \"sanity\");\n+      \/\/ AsynchHandshake handshakes are only executed by target.\n+      assert(_self == th, \"Must be\");\n+      assert(Thread::current() == th, \"Must be\");\n+      JavaThread* jt = th->as_Java_thread();\n+      ResourceMark rm;\n+      jt->print_on(tty);\n+      jt->print_stack_on(tty);\n+      tty->cr();\n+    }\n+\n+  public:\n+    TraceSelfClosure(JavaThread* self_target) : AsyncHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n+  };\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    TraceSelfClosure* tsc = new TraceSelfClosure(target);\n+    Handshake::execute(tsc, target);\n+  }\n+WB_END\n+\n@@ -2490,0 +2516,1 @@\n+  {CC\"asyncHandshakeWalkStack\", CC\"(Ljava\/lang\/Thread;)V\", (void*)&WB_AsyncHandshakeWalkStack },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+  bool _executed;\n@@ -520,1 +521,4 @@\n-    , _biased_locker_id(0) {}\n+    , _biased_locker_id(0)\n+    , _executed(false) {}\n+\n+  bool executed() { return _executed; }\n@@ -524,0 +528,1 @@\n+    _executed = true;\n@@ -625,1 +630,1 @@\n-  bool executed = Handshake::execute_direct(&revoke, biaser);\n+  Handshake::execute(&revoke, biaser);\n@@ -629,1 +634,1 @@\n-  if (executed) {\n+  if (revoke.executed()) {\n@@ -671,1 +676,1 @@\n-  assert(cur == biased_locker || cur == biased_locker->active_handshaker(), \"wrong thread\");\n+  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/semaphore.inline.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/filterQueue.inline.hpp\"\n@@ -40,8 +40,11 @@\n-\n-class HandshakeOperation: public StackObj {\n-  HandshakeClosure* _handshake_cl;\n-  int32_t _pending_threads;\n-  bool _executed;\n-  bool _is_direct;\n-public:\n-  HandshakeOperation(HandshakeClosure* cl, bool is_direct = false) :\n+class HandshakeOperation : public CHeapObj<mtThread> {\n+  friend class HandshakeState;\n+ protected:\n+  HandshakeClosure*   _handshake_cl;\n+  \/\/ Keeps track of emitted and completed handshake operations.\n+  \/\/ Once it reaches zero all handshake operations have been performed.\n+  int32_t             _pending_threads;\n+  JavaThread*         _target;\n+\n+  \/\/ Must use AsyncHandshakeOperation when using AsyncHandshakeClosure.\n+  HandshakeOperation(AsyncHandshakeClosure* cl, JavaThread* target) :\n@@ -50,2 +53,1 @@\n-    _executed(false),\n-    _is_direct(is_direct) {}\n+    _target(target) {}\n@@ -53,0 +55,6 @@\n+ public:\n+  HandshakeOperation(HandshakeClosure* cl, JavaThread* target) :\n+    _handshake_cl(cl),\n+    _pending_threads(1),\n+    _target(target) {}\n+  virtual ~HandshakeOperation() {}\n@@ -59,3 +67,4 @@\n-  void add_target_count(int count) { Atomic::add(&_pending_threads, count, memory_order_relaxed); }\n-  bool executed() const { return _executed; }\n-  const char* name() { return _handshake_cl->name(); }\n+  void add_target_count(int count) { Atomic::add(&_pending_threads, count); }\n+  const char* name()               { return _handshake_cl->name(); }\n+  bool is_async()                  { return _handshake_cl->is_async(); }\n+};\n@@ -63,1 +72,8 @@\n-  bool is_direct() { return _is_direct; }\n+class AsyncHandshakeOperation : public HandshakeOperation {\n+ private:\n+  jlong _start_time_ns;\n+ public:\n+  AsyncHandshakeOperation(AsyncHandshakeClosure* cl, JavaThread* target, jlong start_ns)\n+    : HandshakeOperation(cl, target), _start_time_ns(start_ns) {}\n+  virtual ~AsyncHandshakeOperation() { delete _handshake_cl; }\n+  jlong start_time() const           { return _start_time_ns; }\n@@ -82,1 +98,0 @@\n-  int prev_result_pos() { return _prev_result_pos & 0x1; }\n@@ -179,2 +194,2 @@\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-    if (thr->has_handshake()) {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* thr = jtiwh.next(); ) {\n+    if (thr->handshake_state()->has_operation()) {\n@@ -189,2 +204,2 @@\n-static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {\n-  if (start_time_ns != 0) {\n+static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int emitted_handshakes_executed, const char* extra = NULL) {\n+  if (log_is_enabled(Info, handshake)) {\n@@ -192,1 +207,1 @@\n-    log_info(handshake)(\"Handshake \\\"%s\\\", Targeted threads: %d, Executed by targeted threads: %d, Total completion time: \" JLONG_FORMAT \" ns%s%s\",\n+    log_info(handshake)(\"Handshake \\\"%s\\\", Targeted threads: %d, Executed by requesting thread: %d, Total completion time: \" JLONG_FORMAT \" ns%s%s\",\n@@ -194,1 +209,1 @@\n-                        targets - vmt_executed,\n+                        emitted_handshakes_executed,\n@@ -201,43 +216,0 @@\n-class VM_HandshakeOneThread: public VM_Handshake {\n-  JavaThread* _target;\n- public:\n-  VM_HandshakeOneThread(HandshakeOperation* op, JavaThread* target) :\n-    VM_Handshake(op), _target(target) {}\n-\n-  void doit() {\n-    jlong start_time_ns = os::javaTimeNanos();\n-\n-    ThreadsListHandle tlh;\n-    if (tlh.includes(_target)) {\n-      _target->set_handshake_operation(_op);\n-    } else {\n-      log_handshake_info(start_time_ns, _op->name(), 0, 0, \"(thread dead)\");\n-      return;\n-    }\n-\n-    log_trace(handshake)(\"JavaThread \" INTPTR_FORMAT \" signaled, begin attempt to process by VMThtread\", p2i(_target));\n-    HandshakeState::ProcessResult pr = HandshakeState::_no_operation;\n-    HandshakeSpinYield hsy(start_time_ns);\n-    do {\n-      if (handshake_has_timed_out(start_time_ns)) {\n-        handle_timeout();\n-      }\n-      pr = _target->handshake_try_process(_op);\n-      hsy.add_result(pr);\n-      hsy.process();\n-    } while (!_op->is_completed());\n-\n-    \/\/ This pairs up with the release store in do_handshake(). It prevents future\n-    \/\/ loads from floating above the load of _pending_threads in is_completed()\n-    \/\/ and thus prevents reading stale data modified in the handshake closure\n-    \/\/ by the Handshakee.\n-    OrderAccess::acquire();\n-\n-    log_handshake_info(start_time_ns, _op->name(), 1, (pr == HandshakeState::_success) ? 1 : 0);\n-  }\n-\n-  VMOp_Type type() const { return VMOp_HandshakeOneThread; }\n-\n-  bool executed() const { return _op->executed(); }\n-};\n-\n@@ -250,1 +222,0 @@\n-    int handshake_executed_by_vm_thread = 0;\n@@ -254,2 +225,2 @@\n-    for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n-      thr->set_handshake_operation(_op);\n+    for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+      thr->handshake_state()->add_operation(_op);\n@@ -260,1 +231,1 @@\n-      log_handshake_info(start_time_ns, _op->name(), 0, 0);\n+      log_handshake_info(start_time_ns, _op->name(), 0, 0, \"no threads alive\");\n@@ -268,0 +239,3 @@\n+    \/\/ Keeps count on how many of own emitted handshakes\n+    \/\/ this thread execute.\n+    int emitted_handshakes_executed = 0;\n@@ -276,1 +250,1 @@\n-      \/\/ by semaphores and we optimistically begin by working on the blocked threads\n+      \/\/ by mutexes and we optimistically begin by working on the blocked threads\n@@ -278,1 +252,1 @@\n-      for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n+      for (JavaThread* thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {\n@@ -281,4 +255,1 @@\n-        HandshakeState::ProcessResult pr = thr->handshake_try_process(_op);\n-        if (pr == HandshakeState::_success) {\n-          handshake_executed_by_vm_thread++;\n-        }\n+        HandshakeState::ProcessResult pr = thr->handshake_state()->try_process(_op);\n@@ -286,0 +257,3 @@\n+        if (pr == HandshakeState::_succeeded) {\n+          emitted_handshakes_executed++;\n+        }\n@@ -296,1 +270,1 @@\n-    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, handshake_executed_by_vm_thread);\n+    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, emitted_handshakes_executed);\n@@ -310,0 +284,1 @@\n+    NoSafepointVerifier nsv;\n@@ -311,1 +286,0 @@\n-    _executed = true;\n@@ -330,2 +304,2 @@\n-void Handshake::execute(HandshakeClosure* thread_cl) {\n-  HandshakeOperation cto(thread_cl);\n+void Handshake::execute(HandshakeClosure* hs_cl) {\n+  HandshakeOperation cto(hs_cl, NULL);\n@@ -336,8 +310,1 @@\n-bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {\n-  HandshakeOperation cto(thread_cl);\n-  VM_HandshakeOneThread handshake(&cto, target);\n-  VMThread::execute(&handshake);\n-  return handshake.executed();\n-}\n-\n-bool Handshake::execute_direct(HandshakeClosure* thread_cl, JavaThread* target) {\n+void Handshake::execute(HandshakeClosure* hs_cl, JavaThread* target) {\n@@ -345,1 +312,1 @@\n-  HandshakeOperation op(thread_cl, \/*is_direct*\/ true);\n+  HandshakeOperation op(hs_cl, target);\n@@ -351,1 +318,1 @@\n-    target->set_handshake_operation(&op);\n+    target->handshake_state()->add_operation(&op);\n@@ -353,2 +320,4 @@\n-    log_handshake_info(start_time_ns, op.name(), 0, 0, \"(thread dead)\");\n-    return false;\n+    char buf[128];\n+    jio_snprintf(buf, sizeof(buf),  \"(thread= \" INTPTR_FORMAT \" dead)\", p2i(target));\n+    log_handshake_info(start_time_ns, op.name(), 0, 0, buf);\n+    return;\n@@ -357,1 +326,3 @@\n-  HandshakeState::ProcessResult pr =  HandshakeState::_no_operation;\n+  \/\/ Keeps count on how many of own emitted handshakes\n+  \/\/ this thread execute.\n+  int emitted_handshakes_executed = 0;\n@@ -360,1 +331,7 @@\n-    HandshakeState::ProcessResult pr = target->handshake_try_process(&op);\n+    HandshakeState::ProcessResult pr = target->handshake_state()->try_process(&op);\n+    if (pr == HandshakeState::_succeeded) {\n+      emitted_handshakes_executed++;\n+    }\n+    if (op.is_completed()) {\n+      break;\n+    }\n@@ -376,1 +353,6 @@\n-  log_handshake_info(start_time_ns, op.name(), 1,  (pr == HandshakeState::_success) ? 1 : 0);\n+  log_handshake_info(start_time_ns, op.name(), 1, emitted_handshakes_executed);\n+}\n+\n+void Handshake::execute(AsyncHandshakeClosure* hs_cl, JavaThread* target) {\n+  jlong start_time_ns = os::javaTimeNanos();\n+  AsyncHandshakeOperation* op = new AsyncHandshakeOperation(hs_cl, target, start_time_ns);\n@@ -378,1 +360,7 @@\n-  return op.executed();\n+  ThreadsListHandle tlh;\n+  if (tlh.includes(target)) {\n+    target->handshake_state()->add_operation(op);\n+  } else {\n+    log_handshake_info(start_time_ns, op->name(), 0, 0, \"(thread dead)\");\n+    delete op;\n+  }\n@@ -381,7 +369,5 @@\n-HandshakeState::HandshakeState() :\n-  _operation(NULL),\n-  _operation_direct(NULL),\n-  _handshake_turn_sem(1),\n-  _processing_sem(1),\n-  _thread_in_process_handshake(false),\n-  _active_handshaker(NULL)\n+HandshakeState::HandshakeState(JavaThread* target) :\n+  _handshakee(target),\n+  _queue(),\n+  _lock(Monitor::leaf, \"HandshakeState\", Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never),\n+  _active_handshaker()\n@@ -391,9 +377,5 @@\n-void HandshakeState::set_operation(HandshakeOperation* op) {\n-  if (!op->is_direct()) {\n-    assert(Thread::current()->is_VM_thread(), \"should be the VMThread\");\n-    _operation = op;\n-  } else {\n-    \/\/ Serialize direct handshakes so that only one proceeds at a time for a given target\n-    _handshake_turn_sem.wait_with_safepoint_check(JavaThread::current());\n-    _operation_direct = op;\n-  }\n+void HandshakeState::add_operation(HandshakeOperation* op) {\n+  \/\/ Adds are done lock free and so is arming.\n+  \/\/ Calling this method with lock held is considered an error.\n+  assert(!_lock.owned_by_self(), \"Lock should not be held\");\n+  _queue.push(op);\n@@ -403,6 +385,27 @@\n-void HandshakeState::clear_handshake(bool is_direct) {\n-  if (!is_direct) {\n-    _operation = NULL;\n-  } else {\n-    _operation_direct = NULL;\n-    _handshake_turn_sem.signal();\n+HandshakeOperation* HandshakeState::pop_for_self() {\n+  assert(_handshakee == Thread::current(), \"Must be called by self\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.pop();\n+};\n+\n+static bool non_self_queue_filter(HandshakeOperation* op) {\n+  return !op->is_async();\n+}\n+\n+bool HandshakeState::have_non_self_executable_operation() {\n+  assert(_handshakee != Thread::current(), \"Must not be called by self\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.contains(non_self_queue_filter);\n+}\n+\n+HandshakeOperation* HandshakeState::pop() {\n+  assert(_handshakee != Thread::current(), \"Must not be called by self\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.pop(non_self_queue_filter);\n+};\n+\n+void HandshakeState::process_by_self() {\n+  ThreadInVMForHandshake tivm(_handshakee);\n+  {\n+    NoSafepointVerifier nsv;\n+    process_self_inner();\n@@ -417,1 +420,0 @@\n-  JavaThread* self = _handshakee;\n@@ -419,19 +421,14 @@\n-  do {\n-    ThreadInVMForHandshake tivm(self);\n-    if (!_processing_sem.trywait()) {\n-      _processing_sem.wait_with_safepoint_check(self);\n-    }\n-    if (has_operation()) {\n-      HandleMark hm(self);\n-      CautiouslyPreserveExceptionMark pem(self);\n-      HandshakeOperation * op = _operation;\n-      if (op != NULL) {\n-        \/\/ Disarm before executing the operation\n-        clear_handshake(\/*is_direct*\/ false);\n-        op->do_handshake(self);\n-      }\n-      op = _operation_direct;\n-      if (op != NULL) {\n-        \/\/ Disarm before executing the operation\n-        clear_handshake(\/*is_direct*\/ true);\n-        op->do_handshake(self);\n+  while (should_process()) {\n+    HandleMark hm(_handshakee);\n+    CautiouslyPreserveExceptionMark pem(_handshakee);\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    HandshakeOperation* op = pop_for_self();\n+    if (op != NULL) {\n+      assert(op->_target == NULL || op->_target == Thread::current(), \"Wrong thread\");\n+      bool async = op->is_async();\n+      log_trace(handshake)(\"Proc handshake %s \" INTPTR_FORMAT \" on \" INTPTR_FORMAT \" by self\",\n+                           async ? \"asynchronous\" : \"synchronous\", p2i(op), p2i(_handshakee));\n+      op->do_handshake(_handshakee);\n+      if (async) {\n+        log_handshake_info(((AsyncHandshakeOperation*)op)->start_time(), op->name(), 1, 0, \"asynchronous\");\n+        delete op;\n@@ -440,2 +437,1 @@\n-    _processing_sem.signal();\n-  } while (has_operation());\n+  }\n@@ -468,2 +464,2 @@\n-bool HandshakeState::claim_handshake(bool is_direct) {\n-  if (!_processing_sem.trywait()) {\n+bool HandshakeState::claim_handshake() {\n+  if (!_lock.try_lock()) {\n@@ -472,2 +468,8 @@\n-  if (has_specific_operation(is_direct)){\n-    return true;\n+  \/\/ Operations are added lock free and then the poll is armed.\n+  \/\/ If all handshake operations for the handshakee are finished and someone\n+  \/\/ just adds an operation we may see it here. But if the handshakee is not\n+  \/\/ armed yet it is not safe to proceed.\n+  if (have_non_self_executable_operation()) {\n+    if (SafepointMechanism::local_poll_armed(_handshakee)) {\n+      return true;\n+    }\n@@ -475,1 +477,1 @@\n-  _processing_sem.signal();\n+  _lock.unlock();\n@@ -479,4 +481,2 @@\n-HandshakeState::ProcessResult HandshakeState::try_process(HandshakeOperation* op) {\n-  bool is_direct = op->is_direct();\n-\n-  if (!has_specific_operation(is_direct)){\n+HandshakeState::ProcessResult HandshakeState::try_process(HandshakeOperation* match_op) {\n+  if (!has_operation()) {\n@@ -484,1 +484,1 @@\n-    return _no_operation;\n+    return HandshakeState::_no_operation;\n@@ -489,1 +489,1 @@\n-    return _not_safe;\n+    return HandshakeState::_not_safe;\n@@ -492,3 +492,3 @@\n-  \/\/ Claim the semaphore if there still an operation to be executed.\n-  if (!claim_handshake(is_direct)) {\n-    return _state_busy;\n+  \/\/ Claim the mutex if there still an operation to be executed.\n+  if (!claim_handshake()) {\n+    return HandshakeState::_claim_failed;\n@@ -497,9 +497,1 @@\n-  \/\/ Check if the handshake operation is the same as the one we meant to execute. The\n-  \/\/ handshake could have been already processed by the handshakee and a new handshake\n-  \/\/ by another JavaThread might be in progress.\n-  if (is_direct && op != _operation_direct) {\n-    _processing_sem.signal();\n-    return _no_operation;\n-  }\n-\n-  \/\/ If we own the semaphore at this point and while owning the semaphore\n+  \/\/ If we own the mutex at this point and while owning the mutex we\n@@ -507,11 +499,4 @@\n-  \/\/ getting caught by the semaphore.\n-  ProcessResult pr = _not_safe;\n-  if (can_process_handshake()) {\n-    guarantee(!_processing_sem.trywait(), \"we should already own the semaphore\");\n-    log_trace(handshake)(\"Processing handshake by %s\", Thread::current()->is_VM_thread() ? \"VMThread\" : \"Handshaker\");\n-    _active_handshaker = Thread::current();\n-    op->do_handshake(_handshakee);\n-    _active_handshaker = NULL;\n-    \/\/ Disarm after we have executed the operation.\n-    clear_handshake(is_direct);\n-    pr = _success;\n+  \/\/ getting caught by the mutex.\n+  if (!can_process_handshake()) {\n+    _lock.unlock();\n+    return HandshakeState::_not_safe;\n@@ -520,2 +505,27 @@\n-  \/\/ Release the thread\n-  _processing_sem.signal();\n+  Thread* current_thread = Thread::current();\n+\n+  HandshakeState::ProcessResult pr_ret = HandshakeState::_processed;\n+  int executed = 0;\n+\n+  do {\n+    HandshakeOperation* op = pop();\n+    if (op != NULL) {\n+      assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n+      assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n+      log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s(%s)\", p2i(op),\n+                           op == match_op ? \"handshaker\" : \"cooperative\",\n+                           current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\");\n+\n+      if (op == match_op) {\n+        pr_ret = HandshakeState::_succeeded;\n+      }\n+\n+      _active_handshaker = current_thread;\n+      op->do_handshake(_handshakee);\n+      _active_handshaker = NULL;\n+\n+      executed++;\n+    }\n+  } while (have_non_self_executable_operation());\n+\n+  _lock.unlock();\n@@ -523,1 +533,5 @@\n-  return pr;\n+  log_trace(handshake)(\"%s(\" INTPTR_FORMAT \") executed %d ops for JavaThread: \" INTPTR_FORMAT \" %s target op: \" INTPTR_FORMAT,\n+                       current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\",\n+                       p2i(current_thread), executed, p2i(_handshakee),\n+                       pr_ret == HandshakeState::_succeeded ? \"including\" : \"excluding\", p2i(match_op));\n+  return pr_ret;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":190,"deletions":176,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n-#include \"runtime\/semaphore.hpp\"\n-#include \"utilities\/autoRestore.hpp\"\n+#include \"runtime\/flags\/flagSetting.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/filterQueue.hpp\"\n@@ -36,9 +37,6 @@\n-\/\/ A handshake closure is a callback that is executed for each JavaThread\n-\/\/ while that thread is in a safepoint safe state. The callback is executed\n-\/\/ either by the target JavaThread itself or by the VMThread while keeping\n-\/\/ the target thread in a blocked state. A handshake can be performed with a\n-\/\/ single JavaThread as well. In that case, the callback is executed either\n-\/\/ by the target JavaThread itself or, depending on whether the operation is\n-\/\/ a direct handshake or not, by the JavaThread that requested the handshake\n-\/\/ or the VMThread respectively.\n-class HandshakeClosure : public ThreadClosure {\n+\/\/ A handshake closure is a callback that is executed for a JavaThread\n+\/\/ while it is in a safepoint\/handshake-safe state. Depending on the\n+\/\/ nature of the closure, the callback may be executed by the initiating\n+\/\/ thread, the target thread, or the VMThread. If the callback is not executed\n+\/\/ by the target thread it will remain in a blocked state until the callback completes.\n+class HandshakeClosure : public ThreadClosure, public CHeapObj<mtThread> {\n@@ -48,3 +46,3 @@\n-  const char* name() const {\n-    return _name;\n-  }\n+  virtual ~HandshakeClosure() {}\n+  const char* name() const    { return _name; }\n+  virtual bool is_async()     { return false; }\n@@ -54,0 +52,7 @@\n+class AsyncHandshakeClosure : public HandshakeClosure {\n+ public:\n+   AsyncHandshakeClosure(const char* name) : HandshakeClosure(name) {}\n+   virtual ~AsyncHandshakeClosure() {}\n+   virtual bool is_async()          { return true; }\n+};\n+\n@@ -57,3 +62,3 @@\n-  static void execute(HandshakeClosure* hs_cl);\n-  static bool execute(HandshakeClosure* hs_cl, JavaThread* target);\n-  static bool execute_direct(HandshakeClosure* hs_cl, JavaThread* target);\n+  static void execute(HandshakeClosure*       hs_cl);\n+  static void execute(HandshakeClosure*       hs_cl, JavaThread* target);\n+  static void execute(AsyncHandshakeClosure* hs_cl, JavaThread* target);\n@@ -63,3 +68,3 @@\n-\/\/ VMThread\/Handshaker and JavaThread are serialized with semaphore _processing_sem\n-\/\/ making sure the operation is only done by either VMThread\/Handshaker on behalf\n-\/\/ of the JavaThread or by the target JavaThread itself.\n+\/\/ VMThread\/Handshaker and JavaThread are serialized with _lock making sure the\n+\/\/ operation is only done by either VMThread\/Handshaker on behalf of the\n+\/\/ JavaThread or by the target JavaThread itself.\n@@ -67,0 +72,2 @@\n+  \/\/ This a back reference to the JavaThread,\n+  \/\/ the target for all operation in the queue.\n@@ -68,6 +75,6 @@\n-  HandshakeOperation* volatile _operation;\n-  HandshakeOperation* volatile _operation_direct;\n-\n-  Semaphore _handshake_turn_sem;  \/\/ Used to serialize direct handshakes for this JavaThread.\n-  Semaphore _processing_sem;\n-  bool _thread_in_process_handshake;\n+  \/\/ The queue containing handshake operations to be performed on _handshakee.\n+  FilterQueue<HandshakeOperation*> _queue;\n+  \/\/ Provides mutual exclusion to this state and queue.\n+  Mutex   _lock;\n+  \/\/ Set to the thread executing the handshake operation.\n+  Thread* _active_handshaker;\n@@ -75,1 +82,1 @@\n-  bool claim_handshake(bool is_direct);\n+  bool claim_handshake();\n@@ -78,2 +85,0 @@\n-  void clear_handshake(bool is_direct);\n-\n@@ -82,2 +87,6 @@\n-public:\n-  HandshakeState();\n+  bool have_non_self_executable_operation();\n+  HandshakeOperation* pop_for_self();\n+  HandshakeOperation* pop();\n+\n+ public:\n+  HandshakeState(JavaThread* thread);\n@@ -85,1 +94,1 @@\n-  void set_handshakee(JavaThread* thread) { _handshakee = thread; }\n+  void add_operation(HandshakeOperation* op);\n@@ -87,4 +96,2 @@\n-  void set_operation(HandshakeOperation* op);\n-  bool has_operation() const { return _operation != NULL || _operation_direct != NULL; }\n-  bool has_specific_operation(bool is_direct) const {\n-    return is_direct ? _operation_direct != NULL : _operation != NULL;\n+  bool has_operation() {\n+    return !_queue.is_empty();\n@@ -93,5 +100,9 @@\n-  void process_by_self() {\n-    if (!_thread_in_process_handshake) {\n-      AutoModifyRestore<bool> temporarily(_thread_in_process_handshake, true);\n-      process_self_inner();\n-    }\n+  \/\/ Both _queue and _lock must be checked. If a thread has seen this _handshakee\n+  \/\/ as safe it will execute all possible handshake operations in a loop while\n+  \/\/ holding _lock. We use lock free addition to the queue, which means it is\n+  \/\/ possible for the queue to be seen as empty by _handshakee but as non-empty\n+  \/\/ by the thread executing in the loop. To avoid the _handshakee continuing\n+  \/\/ while handshake operations are being executed, the _handshakee\n+  \/\/ must take slow path, process_by_self(), if _lock is held.\n+  bool should_process() {\n+    return !_queue.is_empty() || _lock.is_locked();\n@@ -100,0 +111,2 @@\n+  void process_by_self();\n+\n@@ -103,2 +116,3 @@\n-    _state_busy,\n-    _success,\n+    _claim_failed,\n+    _processed,\n+    _succeeded,\n@@ -107,1 +121,1 @@\n-  ProcessResult try_process(HandshakeOperation* op);\n+  ProcessResult try_process(HandshakeOperation* match_op);\n@@ -109,1 +123,0 @@\n-  Thread* _active_handshaker;\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":58,"deletions":45,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -135,4 +135,0 @@\n-    \/\/ Change to transition state and ensure it is seen by the VM thread.\n-    _thread->set_thread_state_fence(_thread_in_vm_trans);\n-\n-    SafepointMechanism::process_if_requested(_thread);\n@@ -159,0 +155,3 @@\n+\n+    \/\/ Threads shouldn't block if they are in the middle of printing, but...\n+    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  if (Thread::current() == thread->active_handshaker()) return;\n+  if (thread->is_handshake_safe_for(Thread::current())) return;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-  if (thread->has_handshake()) {\n-    thread->handshake_process_by_self();\n+  if (thread->handshake_state()->should_process()) {\n+    thread->handshake_state()->process_by_self(); \/\/ Recursive\n@@ -99,1 +99,1 @@\n-    if (global_poll() || thread->has_handshake()) {\n+    if (global_poll() || thread->handshake_state()->has_operation()) {\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  static inline bool local_poll_armed(JavaThread* thread);\n@@ -61,0 +60,1 @@\n+  static inline bool local_poll_armed(JavaThread* thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -470,4 +470,2 @@\n-\/\/ A JavaThread is considered \"dangling\" if it is not the current\n-\/\/ thread, has been added the Threads list, the system is not at a\n-\/\/ safepoint and the Thread is not \"protected\".\n-\/\/\n+\/\/ A JavaThread is considered dangling if it not handshake-safe with respect to\n+\/\/ the current thread, it is not on a ThreadsList, or not at safepoint.\n@@ -475,1 +473,2 @@\n-  assert(!thread->is_Java_thread() || Thread::current() == thread ||\n+  assert(!thread->is_Java_thread() ||\n+         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n@@ -840,1 +839,1 @@\n-  if (this != JavaThread::current()) {\n+  if (this != Thread::current()) {\n@@ -1718,1 +1717,0 @@\n-  _handshake.set_handshakee(this);\n@@ -1736,1 +1734,1 @@\n-                       Thread() {\n+                       Thread(), _handshake(this) {\n@@ -1851,1 +1849,1 @@\n-                       Thread() {\n+                       Thread(), _handshake(this) {\n@@ -2409,1 +2407,2 @@\n-  assert(Thread::current()->is_VM_thread() || Thread::current() == this, \"should be in the vm thread\");\n+  assert(is_handshake_safe_for(Thread::current()),\n+         \"should be self or handshakee\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1357,15 +1357,1 @@\n-  void set_handshake_operation(HandshakeOperation* op) {\n-    _handshake.set_operation(op);\n-  }\n-\n-  bool has_handshake() const {\n-    return _handshake.has_operation();\n-  }\n-\n-  void handshake_process_by_self() {\n-    _handshake.process_by_self();\n-  }\n-\n-  HandshakeState::ProcessResult handshake_try_process(HandshakeOperation* op) {\n-    return _handshake.try_process(op);\n-  }\n+  HandshakeState* handshake_state() { return &_handshake; }\n@@ -1373,2 +1359,4 @@\n-  Thread* active_handshaker() const {\n-    return _handshake.active_handshaker();\n+  \/\/ A JavaThread can always safely operate on it self and other threads\n+  \/\/ can do it safely if they are the active handshaker.\n+  bool is_handshake_safe_for(Thread* th) const {\n+    return _handshake.active_handshaker() == th || this == th;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FILTERQUEUE_HPP\n+#define SHARE_UTILITIES_FILTERQUEUE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+\/\/ The FilterQueue is FIFO with the ability to skip over queued items.\n+\/\/ The skipping is controlled by using a filter when popping.\n+\/\/ It also supports lock free pushes, while popping (including contains())\n+\/\/ needs to be externally serialized.\n+template <class E>\n+class FilterQueue {\n+ private:\n+  class Node : public CHeapObj<mtInternal> {\n+   public:\n+    Node(const E& e): _next(NULL), _data(e) { }\n+    Node*    _next;\n+    E                   _data;\n+  };\n+\n+  Node* _first;\n+  Node* load_first() {\n+    return Atomic::load_acquire(&_first);\n+  }\n+\n+  static bool match_all(E d) { return true; }\n+\n+ public:\n+  FilterQueue() : _first(NULL) { }\n+\n+  bool is_empty() {\n+    return load_first() == NULL;\n+  }\n+\n+  \/\/ Adds an item to the queue in a MT safe way, re-entrant.\n+  void push(E data);\n+\n+  \/\/ Applies the match_func to the items in the queue until match_func returns\n+  \/\/ true and then returns true, or there is no more items and then returns\n+  \/\/ false. Items pushed after execution starts will not have match_func\n+  \/\/ applied. The method is not re-entrant and must be executed mutually\n+  \/\/ exclusive to other contains and pops calls.\n+  template <typename MATCH_FUNC>\n+  bool contains(MATCH_FUNC& match_func);\n+\n+  \/\/ Same as pop(MATCH_FUNC& match_func) but matches everything, thus returning\n+  \/\/ the first inserted item.\n+  E pop() {\n+    return pop(match_all);\n+  }\n+\n+  \/\/ Applies the match_func to each item in the queue and returns the first\n+  \/\/ inserted item for which match_func returns true. Returns false if there are\n+  \/\/ no matches or the queue is empty. Any pushed item before execution is\n+  \/\/ complete may or may not have match_func applied. The method is not\n+  \/\/ re-entrant and must be executed mutual exclusive to other contains and pops\n+  \/\/ calls.\n+  template <typename MATCH_FUNC>\n+  E pop(MATCH_FUNC& match_func);\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n+\n+#include \"utilities\/filterQueue.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+template <class E>\n+void FilterQueue<E>::push(E data) {\n+  Node* head;\n+  Node* insnode = new Node(data);\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with multiple failed CAS.\n+  while (true){\n+    head = load_first();\n+    insnode->_next = head;\n+    if (Atomic::cmpxchg(&_first, head, insnode) == head) {\n+      break;\n+    }\n+    yield.wait();\n+  }\n+}\n+\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+bool FilterQueue<E>::contains(MATCH_FUNC& match_func) {\n+  Node* cur = load_first();\n+  if (cur == NULL) {\n+    return false;\n+  }\n+  do {\n+    if (match_func(cur->_data)) {\n+      return true;\n+    }\n+    cur = cur->_next;\n+  } while (cur != NULL);\n+  return false;\n+}\n+\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+E FilterQueue<E>::pop(MATCH_FUNC& match_func) {\n+  Node*  first       = load_first();\n+  Node*  cur         = first;\n+  Node*  prev        = NULL;\n+  Node*  match       = NULL;\n+  Node*  match_prev  = NULL;\n+\n+  if (cur == NULL) {\n+    return (E)NULL;\n+  }\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with multiple failed CAS.\n+  do {\n+    do {\n+      if (match_func(cur->_data)) {\n+        match = cur;\n+        match_prev = prev;\n+      }\n+      prev = cur;\n+      cur = cur->_next;\n+    } while (cur != NULL);\n+\n+    if (match == NULL) {\n+      return (E)NULL;\n+    }\n+\n+    if (match_prev == NULL) {\n+      \/\/ Working on first\n+      if (Atomic::cmpxchg(&_first, match, match->_next) == match) {\n+        E ret = match->_data;\n+        delete match;\n+        return ret;\n+      }\n+      yield.wait();\n+      \/\/ Failed, we need to restart to know the Node prior to the match.\n+      first       = load_first();\n+      cur         = first;\n+      prev        = NULL;\n+      match       = NULL;\n+      match_prev  = NULL;\n+    } else {\n+      match_prev->_next = match->_next;\n+      E ret = match->_data;\n+      delete match;\n+      return ret;\n+    }\n+  } while (true);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/filterQueue.inline.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Get did not find value.\";\n+\n+static bool match_all(uintptr_t val) {\n+  return true;\n+}\n+\n+static bool match_1(uintptr_t val) {\n+  return 1 == val;\n+}\n+\n+static bool match_2(uintptr_t val) {\n+  return 2 == val;\n+}\n+\n+static bool match_3(uintptr_t val) {\n+  return 3 == val;\n+}\n+\n+static bool match_4(uintptr_t val) {\n+  return 4 == val;\n+}\n+\n+static bool match_even(uintptr_t val) {\n+  return (val & 0x1) == 0x0;\n+}\n+\n+static void is_empty(FilterQueue<uintptr_t>& queue) {\n+  EXPECT_EQ(queue.is_empty(), true) << \"Must be empty.\";\n+  EXPECT_EQ(queue.contains(match_1), false) << \"Must be empty.\";\n+  EXPECT_EQ(queue.contains(match_all), false) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)0) << \"Must be empty.\";\n+}\n+\n+TEST_VM(FilterQueue, one) {\n+  FilterQueue<uintptr_t> queue;\n+  is_empty(queue);\n+  queue.push(1);\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+  is_empty(queue);\n+}\n+\n+TEST_VM(FilterQueue, two) {\n+  FilterQueue<uintptr_t> queue;\n+\n+  queue.push(1);\n+  queue.push(2);\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  queue.push(3);\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+\n+  queue.push(2);\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_3), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), false) << \"Must not contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)3) << \"Must not be empty.\";\n+\n+  is_empty(queue);\n+}\n+\n+TEST_VM(FilterQueue, three) {\n+  FilterQueue<uintptr_t> queue;\n+\n+  queue.push(1);\n+  queue.push(2);\n+  queue.push(3);\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_3), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_4), false) << \"Must not contain a value.\";\n+\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)3) << \"Must not be empty.\";\n+\n+  is_empty(queue);\n+}\n+\n+class FilterQueueTestThread : public JavaTestThread {\n+  FilterQueue<uintptr_t>* _fq;\n+  Mutex* _lock;\n+  uintptr_t _val;\n+  uintptr_t _pop;\n+public:\n+  FilterQueueTestThread(Semaphore* post, FilterQueue<uintptr_t>* fq, Mutex* lock, uintptr_t val, uintptr_t pop)\n+    : JavaTestThread(post), _fq(fq), _lock(lock), _val(val), _pop(pop) {\n+  }\n+  virtual void main_run() {\n+    for (int i = 0; i < 1000; i++) {\n+      for (int j = 0; j < 10; j++) {\n+        _fq->push(_val);\n+      }\n+      {\n+        do {\n+          MutexLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+          if (_fq->contains(*this) != 0) {\n+            break;\n+          }\n+        } while (true);\n+      }\n+      for (int j = 0; j < 10; j++) {\n+        MutexLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        while (_fq->pop(*this) == 0) {}\n+      }\n+    }\n+  }\n+  bool operator()(uintptr_t val) {\n+    return val == _pop;\n+  }\n+};\n+\n+TEST_VM(FilterQueue, stress) {\n+  FilterQueue<uintptr_t> queue;\n+  Mutex lock(Mutex::leaf, \"Test Lock\", true, Mutex::_safepoint_check_never);\n+  static const int nthreads = 4;\n+  Semaphore post;\n+  FilterQueueTestThread* threads[nthreads] = {};\n+  for (int i = 0; i < nthreads; ++i) {\n+    threads[i] = new FilterQueueTestThread(&post, &queue, &lock, i + 1, i + 2 > nthreads ? 1 : i + 2);\n+    threads[i]->doit();\n+  }\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+  EXPECT_EQ(queue.is_empty(), true) << \"Must be empty.\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test AsyncHandshakeWalkStackTest\n+ * @library \/testlibrary \/test\/lib\n+ * @build AsyncHandshakeWalkStackTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI AsyncHandshakeWalkStackTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class AsyncHandshakeWalkStackTest {\n+\n+    public static void main(String... args) throws Exception {\n+        int iterations = 3;\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+        }\n+        test(iterations);\n+    }\n+\n+    private static void test(int iterations) throws Exception {\n+        Thread loop_thread  = new Thread(() -> run_loop(create_list()));\n+        Thread alloc_thread = new Thread(() -> run_alloc());\n+        Thread wait_thread  = new Thread(() -> run_wait(new Object() {}));\n+        loop_thread.start();\n+        alloc_thread.start();\n+        wait_thread.start();\n+\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        for (int i = 0; i < iterations; i++) {\n+            System.out.println(\"Iteration \" + i);\n+            System.out.flush();\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(loop_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(alloc_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(wait_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(Thread.currentThread());\n+        }\n+    }\n+\n+    static class List {\n+        List next;\n+\n+        List(List next) {\n+            this.next = next;\n+        }\n+    }\n+\n+    public static List create_list() {\n+        List head = new List(null);\n+        List elem = new List(head);\n+        List elem2 = new List(elem);\n+        List elem3 = new List(elem2);\n+        List elem4 = new List(elem3);\n+        head.next = elem4;\n+\n+        return head;\n+    }\n+\n+    public static void run_loop(List loop) {\n+        while (loop.next != null) {\n+            loop = loop.next;\n+        }\n+    }\n+\n+    public static byte[] array;\n+\n+    public static void run_alloc() {\n+        while (true) {\n+            \/\/ Write to public static to ensure the byte array escapes.\n+            array = new byte[4096];\n+        }\n+    }\n+\n+    public static void run_wait(Object lock) {\n+        synchronized (lock) {\n+            try {\n+                lock.wait();\n+            } catch (InterruptedException ie) {}\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/AsyncHandshakeWalkStackTest.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 50000;\n+    static final int DIRECT_HANDSHAKES_MARK = 500000;\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MixedHandshakeWalkStackTest\n+ * @library \/testlibrary \/test\/lib\n+ * @build MixedHandshakeWalkStackTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI MixedHandshakeWalkStackTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class MixedHandshakeWalkStackTest {\n+    public static Thread testThreads[];\n+\n+    public static void main(String... args) throws Exception {\n+        testThreads = new Thread[Runtime.getRuntime().availableProcessors()];\n+        for (int i = 0; i < testThreads.length; i++) {\n+            testThreads[i] = new Thread(() -> handshake());\n+        }\n+\n+        for (Thread t : testThreads) {\n+            t.start();\n+        }\n+\n+        handshake();\n+\n+        for (Thread t : testThreads) {\n+            t.join();\n+        }\n+    }\n+\n+    public static void handshake() {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        java.util.concurrent.ThreadLocalRandom rand = java.util.concurrent.ThreadLocalRandom.current();\n+        long end = System.currentTimeMillis() + 20000;\n+        while (end > System.currentTimeMillis()) {\n+            wb.asyncHandshakeWalkStack(testThreads[rand.nextInt(testThreads.length)]);\n+            wb.handshakeWalkStack(testThreads[rand.nextInt(testThreads.length)], false);\n+            wb.handshakeWalkStack(testThreads[rand.nextInt(testThreads.length)], true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/MixedHandshakeWalkStackTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -590,0 +590,1 @@\n+  public native void asyncHandshakeWalkStack(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}