{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-class ThreadClosure: public Closure {\n+class ThreadClosure {\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1216,2 +1216,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1261,2 +1261,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1305,2 +1305,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1543,2 +1543,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1588,2 +1588,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1626,2 +1626,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1724,4 +1724,3 @@\n-        bool executed = Handshake::execute_direct(&op, java_thread);\n-        jvmtiError err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n-        if (err != JVMTI_ERROR_NONE) {\n-          return err;\n+        Handshake::execute(&op, java_thread);\n+        if (op.result() != JVMTI_ERROR_NONE) {\n+          return op.result();\n@@ -1759,2 +1758,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n@@ -1808,2 +1807,2 @@\n-    bool executed = Handshake::execute_direct(&op, java_thread);\n-    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    Handshake::execute(&op, java_thread);\n+    err = op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -652,3 +652,2 @@\n-  JavaThread *current_jt = JavaThread::current();\n-  assert(current_jt == java_thread ||\n-         current_jt == java_thread->active_handshaker(),\n+  Thread *current_thread = Thread::current();\n+  assert(java_thread->is_handshake_safe_for(current_thread),\n@@ -679,2 +678,2 @@\n-    HandleMark hm(current_jt);\n-    Handle     hobj(current_jt, obj);\n+    HandleMark hm(current_thread);\n+    Handle     hobj(current_thread, obj);\n@@ -690,0 +689,5 @@\n+  \/\/ Note:\n+  \/\/ calling_thread is the thread that requested the list of monitors for java_thread.\n+  \/\/ java_thread is thread owning the monitors.\n+  \/\/ current_thread is thread executint this code, can be a non-JavaThread (e.g. VM Thread).\n+  \/\/ And they all maybe different threads.\n@@ -691,3 +695,2 @@\n-  JavaThread *current_jt = JavaThread::current();\n-  assert(current_jt == java_thread ||\n-         current_jt == java_thread->active_handshaker(),\n+  Thread *current_thread = Thread::current();\n+  assert(java_thread->is_handshake_safe_for(current_thread),\n@@ -697,2 +700,2 @@\n-    ResourceMark rm(current_jt);\n-    HandleMark   hm(current_jt);\n+    ResourceMark rm(current_thread);\n+    HandleMark   hm(current_thread);\n@@ -824,1 +827,1 @@\n-         current_thread == java_thread->active_handshaker(),\n+         java_thread->is_handshake_safe_for(current_thread),\n@@ -907,1 +910,1 @@\n-         current_thread == java_thread->active_handshaker(),\n+         java_thread->is_handshake_safe_for(current_thread),\n@@ -1164,1 +1167,1 @@\n-         current_thread == thr->active_handshaker(),\n+         thr->is_handshake_safe_for(current_thread),\n@@ -1308,1 +1311,1 @@\n-JvmtiEnvBase::check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+JvmtiEnvBase::check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -1371,1 +1374,1 @@\n-  JavaThread* current_thread = JavaThread::current();\n+  Thread* current_thread = Thread::current();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,\n+  jvmtiError check_top_frame(Thread* current_thread, JavaThread* java_thread,\n@@ -339,0 +339,10 @@\n+class JvmtiHandshakeClosure : public HandshakeClosure {\n+ protected:\n+  jvmtiError _result;\n+ public:\n+  JvmtiHandshakeClosure(const char* name)\n+    : HandshakeClosure(name),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n+  jvmtiError result() { return _result; }\n+};\n+\n@@ -340,1 +350,1 @@\n-class UpdateForPopTopFrameClosure : public HandshakeClosure {\n+class UpdateForPopTopFrameClosure : public JvmtiHandshakeClosure {\n@@ -343,1 +353,0 @@\n-  jvmtiError _result;\n@@ -347,4 +356,2 @@\n-    : HandshakeClosure(\"UpdateForPopTopFrame\"),\n-      _state(state),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+    : JvmtiHandshakeClosure(\"UpdateForPopTopFrame\"),\n+      _state(state) {}\n@@ -355,1 +362,1 @@\n-class SetFramePopClosure : public HandshakeClosure {\n+class SetFramePopClosure : public JvmtiHandshakeClosure {\n@@ -360,1 +367,0 @@\n-  jvmtiError _result;\n@@ -364,1 +370,1 @@\n-    : HandshakeClosure(\"SetFramePop\"),\n+    : JvmtiHandshakeClosure(\"SetFramePop\"),\n@@ -367,3 +373,1 @@\n-      _depth(depth),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+      _depth(depth) {}\n@@ -373,1 +377,0 @@\n-\n@@ -375,1 +378,1 @@\n-class GetOwnedMonitorInfoClosure : public HandshakeClosure {\n+class GetOwnedMonitorInfoClosure : public JvmtiHandshakeClosure {\n@@ -379,1 +382,0 @@\n-  jvmtiError _result;\n@@ -385,1 +387,1 @@\n-    : HandshakeClosure(\"GetOwnedMonitorInfo\"),\n+    : JvmtiHandshakeClosure(\"GetOwnedMonitorInfo\"),\n@@ -388,1 +390,0 @@\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE),\n@@ -390,1 +391,0 @@\n-  jvmtiError result() { return _result; }\n@@ -420,1 +420,1 @@\n-class GetCurrentContendedMonitorClosure : public HandshakeClosure {\n+class GetCurrentContendedMonitorClosure : public JvmtiHandshakeClosure {\n@@ -425,1 +425,0 @@\n-  jvmtiError _result;\n@@ -429,1 +428,1 @@\n-    : HandshakeClosure(\"GetCurrentContendedMonitor\"),\n+    : JvmtiHandshakeClosure(\"GetCurrentContendedMonitor\"),\n@@ -432,3 +431,1 @@\n-      _owned_monitor_ptr(mon_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-  jvmtiError result() { return _result; }\n+      _owned_monitor_ptr(mon_ptr) {}\n@@ -439,1 +436,1 @@\n-class GetStackTraceClosure : public HandshakeClosure {\n+class GetStackTraceClosure : public JvmtiHandshakeClosure {\n@@ -446,1 +443,0 @@\n-  jvmtiError _result;\n@@ -451,1 +447,1 @@\n-    : HandshakeClosure(\"GetStackTrace\"),\n+    : JvmtiHandshakeClosure(\"GetStackTrace\"),\n@@ -456,4 +452,1 @@\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result() { return _result; }\n+      _count_ptr(count_ptr) {}\n@@ -559,1 +552,1 @@\n-class GetFrameCountClosure : public HandshakeClosure {\n+class GetFrameCountClosure : public JvmtiHandshakeClosure {\n@@ -564,1 +557,0 @@\n-  jvmtiError _result;\n@@ -568,1 +560,1 @@\n-    : HandshakeClosure(\"GetFrameCount\"),\n+    : JvmtiHandshakeClosure(\"GetFrameCount\"),\n@@ -571,4 +563,1 @@\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result()    { return _result; }\n+      _count_ptr(count_ptr) {}\n@@ -579,1 +568,1 @@\n-class GetFrameLocationClosure : public HandshakeClosure {\n+class GetFrameLocationClosure : public JvmtiHandshakeClosure {\n@@ -585,1 +574,0 @@\n-  jvmtiError _result;\n@@ -590,1 +578,1 @@\n-    : HandshakeClosure(\"GetFrameLocation\"),\n+    : JvmtiHandshakeClosure(\"GetFrameLocation\"),\n@@ -594,4 +582,1 @@\n-      _location_ptr(location_ptr),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-  }\n-  jvmtiError result()    { return _result; }\n+      _location_ptr(location_ptr) {}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -215,1 +215,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -226,1 +226,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -237,1 +237,1 @@\n-  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+  assert(get_thread()->is_handshake_safe_for(current),\n@@ -317,1 +317,1 @@\n-      if (current == _thread || _thread->active_handshaker() == current) {\n+      if (_thread->is_handshake_safe_for(current)) {\n@@ -320,2 +320,1 @@\n-        bool executed = Handshake::execute_direct(&op, _thread);\n-        guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+        Handshake::execute(&op, _thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-  if (target == current || target->active_handshaker() == current) {\n+  if (target->is_handshake_safe_for(current)) {\n@@ -339,2 +339,1 @@\n-    bool executed = Handshake::execute_direct(&hs, target);\n-    guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+    Handshake::execute(&hs, target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-         current_thread == get_thread()->active_handshaker(),\n+         get_thread()->is_handshake_safe_for(current_thread),\n@@ -244,2 +244,1 @@\n-         JavaThread::current() == get_thread() ||\n-         Thread::current() == get_thread()->active_handshaker(),\n+         get_thread()->is_handshake_safe_for(Thread::current()),\n@@ -275,2 +274,2 @@\n-  JavaThread *current = JavaThread::current();\n-  guarantee(current == get_thread() || current == get_thread()->active_handshaker(),\n+  Thread *current = Thread::current();\n+  guarantee(get_thread()->is_handshake_safe_for(current),\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2028,0 +2028,23 @@\n+WB_ENTRY(void, WB_AsyncHandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class TraceSelfClosure : public AsynchHandshakeClosure {\n+    void do_thread(Thread* th) {\n+      assert(th->is_Java_thread(), \"sanity\");\n+      JavaThread* jt = (JavaThread*)th;\n+      ResourceMark rm;\n+      jt->print_on(tty);\n+      jt->print_stack_on(tty);\n+      tty->cr();\n+    }\n+\n+  public:\n+    TraceSelfClosure() : AsynchHandshakeClosure(\"WB_TraceSelf\") {}\n+  };\n+  TraceSelfClosure* tsc = new TraceSelfClosure();\n+\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    Handshake::execute(tsc, target);\n+  }\n+WB_END\n+\n@@ -2489,0 +2512,1 @@\n+  {CC\"asyncHandshakeWalkStack\", CC\"(Ljava\/lang\/Thread;)V\", (void*)&WB_AsyncHandshakeWalkStack },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+  bool _executed;\n@@ -520,1 +521,4 @@\n-    , _biased_locker_id(0) {}\n+    , _biased_locker_id(0)\n+    , _executed(false) {}\n+\n+  bool executed() { return _executed; }\n@@ -524,0 +528,1 @@\n+    _executed = true;\n@@ -625,1 +630,1 @@\n-  bool executed = Handshake::execute_direct(&revoke, biaser);\n+  Handshake::execute(&revoke, biaser);\n@@ -629,1 +634,1 @@\n-  if (executed) {\n+  if (revoke.executed()) {\n@@ -671,1 +676,1 @@\n-  assert(cur == biased_locker || cur == biased_locker->active_handshaker(), \"wrong thread\");\n+  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/semaphore.inline.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/filterQueue.inline.hpp\"\n@@ -40,6 +40,6 @@\n-\n-class HandshakeOperation: public StackObj {\n-  HandshakeClosure* _handshake_cl;\n-  int32_t _pending_threads;\n-  bool _executed;\n-  bool _is_direct;\n+class HandshakeOperation : public CHeapObj<mtThread> {\n+  friend class HandshakeState;\n+ protected:\n+  HandshakeClosure*   _handshake_cl;\n+  int32_t             _pending_threads;\n+  JavaThread*         _target;\n@@ -47,1 +47,1 @@\n-  HandshakeOperation(HandshakeClosure* cl, bool is_direct = false) :\n+  HandshakeOperation(HandshakeClosure* cl, JavaThread* target) :\n@@ -50,3 +50,2 @@\n-    _executed(false),\n-    _is_direct(is_direct) {}\n-\n+    _target(target) {}\n+  virtual ~HandshakeOperation() {}\n@@ -59,3 +58,4 @@\n-  void add_target_count(int count) { Atomic::add(&_pending_threads, count, memory_order_relaxed); }\n-  bool executed() const { return _executed; }\n-  const char* name() { return _handshake_cl->name(); }\n+  void add_target_count(int count) { Atomic::add(&_pending_threads, count); }\n+  const char* name()               { return _handshake_cl->name(); }\n+  bool is_asynch()                 { return _handshake_cl->is_asynch(); }\n+};\n@@ -63,1 +63,8 @@\n-  bool is_direct() { return _is_direct; }\n+class AsyncHandshakeOperation : public HandshakeOperation {\n+ private:\n+  jlong _start_time_ns;\n+ public:\n+  AsyncHandshakeOperation(AsynchHandshakeClosure* cl, JavaThread* target, jlong start_ns)\n+    : HandshakeOperation(cl, target), _start_time_ns(start_ns) {}\n+  virtual ~AsyncHandshakeOperation() { delete _handshake_cl; };\n+  jlong start_time()                 { return _start_time_ns; }\n@@ -79,1 +86,1 @@\n-  int _result_count[2][HandshakeState::_number_states];\n+  int _result_count[2][HandshakeState::ProcessResult::_number_states];\n@@ -82,1 +89,0 @@\n-  int prev_result_pos() { return _prev_result_pos & 0x1; }\n@@ -101,1 +107,1 @@\n-    for (int i = 0; i < HandshakeState::_number_states; i++) {\n+    for (int i = 0; i < HandshakeState::ProcessResult::_number_states; i++) {\n@@ -111,1 +117,1 @@\n-    for (int i = 0; i < HandshakeState::_number_states; i++) {\n+    for (int i = 0; i < HandshakeState::ProcessResult::_number_states; i++) {\n@@ -128,1 +134,1 @@\n-    _result_count[current_result_pos()][pr]++;\n+    _result_count[current_result_pos()][pr.result()]++;\n@@ -180,1 +186,1 @@\n-    if (thr->has_handshake()) {\n+    if (thr->handshake_state()->has_operation()) {\n@@ -190,1 +196,1 @@\n-  if (start_time_ns != 0) {\n+  if (log_is_enabled(Info, handshake)) {\n@@ -201,43 +207,0 @@\n-class VM_HandshakeOneThread: public VM_Handshake {\n-  JavaThread* _target;\n- public:\n-  VM_HandshakeOneThread(HandshakeOperation* op, JavaThread* target) :\n-    VM_Handshake(op), _target(target) {}\n-\n-  void doit() {\n-    jlong start_time_ns = os::javaTimeNanos();\n-\n-    ThreadsListHandle tlh;\n-    if (tlh.includes(_target)) {\n-      _target->set_handshake_operation(_op);\n-    } else {\n-      log_handshake_info(start_time_ns, _op->name(), 0, 0, \"(thread dead)\");\n-      return;\n-    }\n-\n-    log_trace(handshake)(\"JavaThread \" INTPTR_FORMAT \" signaled, begin attempt to process by VMThtread\", p2i(_target));\n-    HandshakeState::ProcessResult pr = HandshakeState::_no_operation;\n-    HandshakeSpinYield hsy(start_time_ns);\n-    do {\n-      if (handshake_has_timed_out(start_time_ns)) {\n-        handle_timeout();\n-      }\n-      pr = _target->handshake_try_process(_op);\n-      hsy.add_result(pr);\n-      hsy.process();\n-    } while (!_op->is_completed());\n-\n-    \/\/ This pairs up with the release store in do_handshake(). It prevents future\n-    \/\/ loads from floating above the load of _pending_threads in is_completed()\n-    \/\/ and thus prevents reading stale data modified in the handshake closure\n-    \/\/ by the Handshakee.\n-    OrderAccess::acquire();\n-\n-    log_handshake_info(start_time_ns, _op->name(), 1, (pr == HandshakeState::_success) ? 1 : 0);\n-  }\n-\n-  VMOp_Type type() const { return VMOp_HandshakeOneThread; }\n-\n-  bool executed() const { return _op->executed(); }\n-};\n-\n@@ -250,1 +213,0 @@\n-    int handshake_executed_by_vm_thread = 0;\n@@ -255,1 +217,1 @@\n-      thr->set_handshake_operation(_op);\n+      thr->handshake_state()->add_operation(_op);\n@@ -260,1 +222,1 @@\n-      log_handshake_info(start_time_ns, _op->name(), 0, 0);\n+      log_handshake_info(start_time_ns, _op->name(), 0, 0, \"no threads alive\");\n@@ -268,0 +230,1 @@\n+    int executed_by_driver = 0;\n@@ -276,1 +239,1 @@\n-      \/\/ by semaphores and we optimistically begin by working on the blocked threads\n+      \/\/ by mutexes and we optimistically begin by working on the blocked threads\n@@ -281,4 +244,1 @@\n-        HandshakeState::ProcessResult pr = thr->handshake_try_process(_op);\n-        if (pr == HandshakeState::_success) {\n-          handshake_executed_by_vm_thread++;\n-        }\n+        HandshakeState::ProcessResult pr = thr->handshake_state()->try_process();\n@@ -286,0 +246,1 @@\n+        executed_by_driver += pr.processed();\n@@ -296,1 +257,1 @@\n-    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, handshake_executed_by_vm_thread);\n+    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, executed_by_driver);\n@@ -311,1 +272,0 @@\n-    _executed = true;\n@@ -330,2 +290,2 @@\n-void Handshake::execute(HandshakeClosure* thread_cl) {\n-  HandshakeOperation cto(thread_cl);\n+void Handshake::execute(HandshakeClosure* hs_cl) {\n+  HandshakeOperation cto(hs_cl, NULL);\n@@ -336,8 +296,1 @@\n-bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {\n-  HandshakeOperation cto(thread_cl);\n-  VM_HandshakeOneThread handshake(&cto, target);\n-  VMThread::execute(&handshake);\n-  return handshake.executed();\n-}\n-\n-bool Handshake::execute_direct(HandshakeClosure* thread_cl, JavaThread* target) {\n+void Handshake::execute(HandshakeClosure* hs_cl, JavaThread* target) {\n@@ -345,1 +298,1 @@\n-  HandshakeOperation op(thread_cl, \/*is_direct*\/ true);\n+  HandshakeOperation op(hs_cl, target);\n@@ -351,1 +304,1 @@\n-    target->set_handshake_operation(&op);\n+    target->handshake_state()->add_operation(&op);\n@@ -354,1 +307,1 @@\n-    return false;\n+    return;\n@@ -357,1 +310,1 @@\n-  HandshakeState::ProcessResult pr =  HandshakeState::_no_operation;\n+  int executed_by_driver = 0;\n@@ -360,1 +313,6 @@\n-    HandshakeState::ProcessResult pr = target->handshake_try_process(&op);\n+    HandshakeState::ProcessResult pr(0);\n+    pr = target->handshake_state()->try_process();\n+    executed_by_driver += pr.processed();\n+    if (op.is_completed()) {\n+      break;\n+    }\n@@ -376,1 +334,6 @@\n-  log_handshake_info(start_time_ns, op.name(), 1,  (pr == HandshakeState::_success) ? 1 : 0);\n+  log_handshake_info(start_time_ns, op.name(), 1, executed_by_driver);\n+}\n+\n+void Handshake::execute(AsynchHandshakeClosure* hs_cl, JavaThread* target) {\n+  jlong start_time_ns = os::javaTimeNanos();\n+  AsyncHandshakeOperation* op = new AsyncHandshakeOperation(hs_cl, target, start_time_ns);\n@@ -378,1 +341,7 @@\n-  return op.executed();\n+  ThreadsListHandle tlh;\n+  if (tlh.includes(target)) {\n+    target->handshake_state()->add_operation(op);\n+  } else {\n+    log_handshake_info(start_time_ns, op->name(), 0, 0, \"(thread dead)\");\n+    delete op;\n+  }\n@@ -381,7 +350,4 @@\n-HandshakeState::HandshakeState() :\n-  _operation(NULL),\n-  _operation_direct(NULL),\n-  _handshake_turn_sem(1),\n-  _processing_sem(1),\n-  _thread_in_process_handshake(false),\n-  _active_handshaker(NULL)\n+HandshakeState::HandshakeState(JavaThread* thread) :\n+  _handshakee(thread),\n+  _queue(),\n+  _lock(Monitor::leaf, \"HandshakeState\", Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never)\n@@ -391,9 +357,5 @@\n-void HandshakeState::set_operation(HandshakeOperation* op) {\n-  if (!op->is_direct()) {\n-    assert(Thread::current()->is_VM_thread(), \"should be the VMThread\");\n-    _operation = op;\n-  } else {\n-    \/\/ Serialize direct handshakes so that only one proceeds at a time for a given target\n-    _handshake_turn_sem.wait_with_safepoint_check(JavaThread::current());\n-    _operation_direct = op;\n-  }\n+void HandshakeState::add_operation(HandshakeOperation* op) {\n+  \/\/ Adds are done lock free and so is arming.\n+  \/\/ Calling this method with lock held is considered an error.\n+  assert(!_lock.owned_by_self(), \"Lock should not be held\");\n+  _queue.add(op);\n@@ -403,6 +365,24 @@\n-void HandshakeState::clear_handshake(bool is_direct) {\n-  if (!is_direct) {\n-    _operation = NULL;\n-  } else {\n-    _operation_direct = NULL;\n-    _handshake_turn_sem.signal();\n+HandshakeOperation* HandshakeState::pop_for_self() {\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.pop();\n+};\n+\n+static bool processor_filter(HandshakeOperation* op) {\n+  return !op->is_asynch();\n+}\n+\n+bool HandshakeState::has_operation_for_processor() {\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.contains(processor_filter);\n+}\n+\n+HandshakeOperation* HandshakeState::pop_for_processor() {\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  return _queue.pop(processor_filter);\n+};\n+\n+void HandshakeState::process_by_self() {\n+  ThreadInVMForHandshake tivm(_handshakee);\n+  {\n+    NoSafepointVerifier nsv;\n+    process_self_inner();\n@@ -417,1 +397,0 @@\n-  JavaThread* self = _handshakee;\n@@ -419,19 +398,15 @@\n-  do {\n-    ThreadInVMForHandshake tivm(self);\n-    if (!_processing_sem.trywait()) {\n-      _processing_sem.wait_with_safepoint_check(self);\n-    }\n-    if (has_operation()) {\n-      HandleMark hm(self);\n-      CautiouslyPreserveExceptionMark pem(self);\n-      HandshakeOperation * op = _operation;\n-      if (op != NULL) {\n-        \/\/ Disarm before executing the operation\n-        clear_handshake(\/*is_direct*\/ false);\n-        op->do_handshake(self);\n-      }\n-      op = _operation_direct;\n-      if (op != NULL) {\n-        \/\/ Disarm before executing the operation\n-        clear_handshake(\/*is_direct*\/ true);\n-        op->do_handshake(self);\n+  while (block_for_operation()) {\n+    HandleMark hm(_handshakee);\n+    CautiouslyPreserveExceptionMark pem(_handshakee);\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    HandshakeOperation* op = pop_for_self();\n+    if (op != NULL) {\n+      assert(op->_target == NULL || op->_target == Thread::current(), \"Wrong thread\");\n+      assert(_handshakee == Thread::current(), \"Wrong thread\");\n+      bool asynch = op->is_asynch();\n+      log_trace(handshake)(\"Proc handshake %s \" INTPTR_FORMAT \" on \" INTPTR_FORMAT \" by self\",\n+                           asynch ? \"asynchronous\" : \"synchronous\", p2i(op), p2i(_handshakee));\n+      op->do_handshake(_handshakee);\n+      if (asynch) {\n+        log_handshake_info(((AsyncHandshakeOperation*)op)->start_time(), op->name(), 1, 0, \"asynchronous\");\n+        delete op;\n@@ -440,2 +415,1 @@\n-    _processing_sem.signal();\n-  } while (has_operation());\n+  }\n@@ -468,2 +442,2 @@\n-bool HandshakeState::claim_handshake(bool is_direct) {\n-  if (!_processing_sem.trywait()) {\n+bool HandshakeState::claim_handshake() {\n+  if (!_lock.try_lock()) {\n@@ -472,2 +446,8 @@\n-  if (has_specific_operation(is_direct)){\n-    return true;\n+  \/\/ Operations are added without lock and then the poll is armed.\n+  \/\/ If all handshake operations for the handshakee are finished and someone\n+  \/\/ just adds an operation we may see it here. But if the handshakee is not\n+  \/\/ armed yet it is not safe to procced.\n+  if (has_operation_for_processor()) {\n+    if (SafepointMechanism::local_poll_armed(_handshakee)) {\n+      return true;\n+    }\n@@ -475,1 +455,1 @@\n-  _processing_sem.signal();\n+  _lock.unlock();\n@@ -479,4 +459,2 @@\n-HandshakeState::ProcessResult HandshakeState::try_process(HandshakeOperation* op) {\n-  bool is_direct = op->is_direct();\n-\n-  if (!has_specific_operation(is_direct)){\n+HandshakeState::ProcessResult HandshakeState::try_process() {\n+  if (!has_operation()) {\n@@ -484,1 +462,1 @@\n-    return _no_operation;\n+    return ProcessResult(HandshakeState::ProcessResult::_no_operation);\n@@ -489,1 +467,1 @@\n-    return _not_safe;\n+    return ProcessResult(HandshakeState::ProcessResult::_not_safe);\n@@ -492,3 +470,3 @@\n-  \/\/ Claim the semaphore if there still an operation to be executed.\n-  if (!claim_handshake(is_direct)) {\n-    return _state_busy;\n+  \/\/ Claim the mutex if there still an operation to be executed.\n+  if (!claim_handshake()) {\n+    return ProcessResult(HandshakeState::ProcessResult::_claim_failed);\n@@ -497,9 +475,1 @@\n-  \/\/ Check if the handshake operation is the same as the one we meant to execute. The\n-  \/\/ handshake could have been already processed by the handshakee and a new handshake\n-  \/\/ by another JavaThread might be in progress.\n-  if (is_direct && op != _operation_direct) {\n-    _processing_sem.signal();\n-    return _no_operation;\n-  }\n-\n-  \/\/ If we own the semaphore at this point and while owning the semaphore\n+  \/\/ If we own the mutex at this point and while owning the mutex\n@@ -507,11 +477,4 @@\n-  \/\/ getting caught by the semaphore.\n-  ProcessResult pr = _not_safe;\n-  if (can_process_handshake()) {\n-    guarantee(!_processing_sem.trywait(), \"we should already own the semaphore\");\n-    log_trace(handshake)(\"Processing handshake by %s\", Thread::current()->is_VM_thread() ? \"VMThread\" : \"Handshaker\");\n-    _active_handshaker = Thread::current();\n-    op->do_handshake(_handshakee);\n-    _active_handshaker = NULL;\n-    \/\/ Disarm after we have executed the operation.\n-    clear_handshake(is_direct);\n-    pr = _success;\n+  \/\/ getting caught by the mutex.\n+  if (!can_process_handshake()) {\n+    _lock.unlock();\n+    return ProcessResult(HandshakeState::ProcessResult::_not_safe);\n@@ -520,2 +483,13 @@\n-  \/\/ Release the thread\n-  _processing_sem.signal();\n+  int executed = 0;\n+  do {\n+    HandshakeOperation* op = pop_for_processor();\n+    if (op != NULL) {\n+      assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n+      assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n+      log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s\", p2i(op), Thread::current()->is_VM_thread() ? \"VMThread\" : \"Handshaker\");\n+      _active_handshaker = Thread::current();\n+      op->do_handshake(_handshakee);\n+      _active_handshaker = NULL;\n+      executed++;\n+    }\n+  } while (has_operation_for_processor());\n@@ -523,1 +497,2 @@\n-  return pr;\n+  _lock.unlock();\n+  return ProcessResult(executed);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":148,"deletions":173,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n-#include \"runtime\/semaphore.hpp\"\n-#include \"utilities\/autoRestore.hpp\"\n+#include \"runtime\/flags\/flagSetting.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/filterQueue.hpp\"\n@@ -42,3 +43,3 @@\n-\/\/ a direct handshake or not, by the JavaThread that requested the handshake\n-\/\/ or the VMThread respectively.\n-class HandshakeClosure : public ThreadClosure {\n+\/\/ a single target\/direct handshake or not, by the JavaThread that requested the\n+\/\/ handshake or the VMThread respectively.\n+class HandshakeClosure : public ThreadClosure, public CHeapObj<mtThread> {\n@@ -48,3 +49,3 @@\n-  const char* name() const {\n-    return _name;\n-  }\n+  virtual ~HandshakeClosure() {}\n+  const char* name() const    { return _name; }\n+  virtual bool is_asynch()    { return false; };\n@@ -54,0 +55,7 @@\n+class AsynchHandshakeClosure : public HandshakeClosure {\n+ public:\n+   AsynchHandshakeClosure(const char* name) : HandshakeClosure(name) {}\n+   virtual ~AsynchHandshakeClosure() {}\n+   virtual bool is_asynch()          { return true; }\n+};\n+\n@@ -57,3 +65,3 @@\n-  static void execute(HandshakeClosure* hs_cl);\n-  static bool execute(HandshakeClosure* hs_cl, JavaThread* target);\n-  static bool execute_direct(HandshakeClosure* hs_cl, JavaThread* target);\n+  static void execute(HandshakeClosure*       hs_cl);\n+  static void execute(HandshakeClosure*       hs_cl, JavaThread* target);\n+  static void execute(AsynchHandshakeClosure* hs_cl, JavaThread* target);\n@@ -63,3 +71,3 @@\n-\/\/ VMThread\/Handshaker and JavaThread are serialized with semaphore _processing_sem\n-\/\/ making sure the operation is only done by either VMThread\/Handshaker on behalf\n-\/\/ of the JavaThread or by the target JavaThread itself.\n+\/\/ VMThread\/Handshaker and JavaThread are serialized with _lock making sure the\n+\/\/ operation is only done by either VMThread\/Handshaker on behalf of the\n+\/\/ JavaThread or by the target JavaThread itself.\n@@ -68,2 +76,2 @@\n-  HandshakeOperation* volatile _operation;\n-  HandshakeOperation* volatile _operation_direct;\n+  FilterQueue<HandshakeOperation*> _queue;\n+  Mutex _lock;\n@@ -71,5 +79,1 @@\n-  Semaphore _handshake_turn_sem;  \/\/ Used to serialize direct handshakes for this JavaThread.\n-  Semaphore _processing_sem;\n-  bool _thread_in_process_handshake;\n-\n-  bool claim_handshake(bool is_direct);\n+  bool claim_handshake();\n@@ -78,2 +82,0 @@\n-  void clear_handshake(bool is_direct);\n-\n@@ -82,2 +84,2 @@\n-public:\n-  HandshakeState();\n+ public:\n+  HandshakeState(JavaThread* thread);\n@@ -85,1 +87,3 @@\n-  void set_handshakee(JavaThread* thread) { _handshakee = thread; }\n+  void add_operation(HandshakeOperation* op);\n+  HandshakeOperation* pop_for_self();\n+  HandshakeOperation* pop_for_processor();\n@@ -87,4 +91,3 @@\n-  void set_operation(HandshakeOperation* op);\n-  bool has_operation() const { return _operation != NULL || _operation_direct != NULL; }\n-  bool has_specific_operation(bool is_direct) const {\n-    return is_direct ? _operation_direct != NULL : _operation != NULL;\n+  bool has_operation_for_processor();\n+  bool has_operation() {\n+    return !_queue.is_empty();\n@@ -92,6 +95,2 @@\n-\n-  void process_by_self() {\n-    if (!_thread_in_process_handshake) {\n-      AutoModifyRestore<bool> temporarily(_thread_in_process_handshake, true);\n-      process_self_inner();\n-    }\n+  bool block_for_operation() {\n+    return !_queue.is_empty() || _lock.is_locked();\n@@ -100,6 +99,20 @@\n-  enum ProcessResult {\n-    _no_operation = 0,\n-    _not_safe,\n-    _state_busy,\n-    _success,\n-    _number_states\n+  void process_by_self();\n+\n+  class ProcessResult {\n+   public:\n+    enum Result {\n+      _no_operation = 0,\n+      _not_safe,\n+      _claim_failed,\n+      _success,\n+      _number_states\n+    };\n+   private:\n+    int _processed;\n+    Result _result;\n+   public:\n+    ProcessResult(int processed) : _processed(processed), _result(_success)\n+      { if (_processed <= 0) _result = _no_operation; }\n+    ProcessResult(Result r) : _processed(0), _result(r)  {}\n+    int processed() { return _processed; }\n+    Result result() { return _processed > 0 ? _success : _result; }\n@@ -107,1 +120,1 @@\n-  ProcessResult try_process(HandshakeOperation* op);\n+  ProcessResult try_process();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":56,"deletions":43,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -135,4 +135,0 @@\n-    \/\/ Change to transition state and ensure it is seen by the VM thread.\n-    _thread->set_thread_state_fence(_thread_in_vm_trans);\n-\n-    SafepointMechanism::process_if_requested(_thread);\n@@ -159,0 +155,3 @@\n+\n+    \/\/ Threads shouldn't block if they are in the middle of printing, but...\n+    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  if (Thread::current() == thread->active_handshaker()) return;\n+  if (thread->is_handshake_safe_for(Thread::current())) return;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-  if (thread->has_handshake()) {\n-    thread->handshake_process_by_self();\n+  if (thread->handshake_state()->block_for_operation()) {\n+    thread->handshake_state()->process_by_self(); \/\/ Recursive\n@@ -99,1 +99,1 @@\n-    if (global_poll() || thread->has_handshake()) {\n+    if (global_poll() || thread->handshake_state()->has_operation()) {\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  static inline bool local_poll_armed(JavaThread* thread);\n@@ -61,0 +60,1 @@\n+  static inline bool local_poll_armed(JavaThread* thread);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,2 +481,2 @@\n-\/\/ thread, has been added the Threads list, the system is not at a\n-\/\/ safepoint and the Thread is not \"protected\".\n+\/\/ thread, his not handshaking with current thread, as been added the Threads\n+\/\/ list, the system is not at a safepoint and the Thread is not \"protected\".\n@@ -485,2 +485,3 @@\n-  assert(!thread->is_Java_thread() || Thread::current() == thread ||\n-         !thread->as_Java_thread()->on_thread_list() ||\n+  assert(!thread->is_Java_thread() ||\n+         ((JavaThread *) thread)->is_handshake_safe_for(Thread::current()) ||\n+         !((JavaThread *) thread)->on_thread_list() ||\n@@ -850,1 +851,1 @@\n-  if (this != JavaThread::current()) {\n+  if (this != Thread::current()) {\n@@ -1731,1 +1732,0 @@\n-  _handshake.set_handshakee(this);\n@@ -1749,1 +1749,1 @@\n-                       Thread() {\n+                       Thread(), _handshake(this) {\n@@ -1871,1 +1871,1 @@\n-                       Thread() {\n+                       Thread(), _handshake(this) {\n@@ -2439,1 +2439,3 @@\n-  assert(Thread::current()->is_VM_thread() || Thread::current() == this, \"should be in the vm thread\");\n+  assert(Thread::current()->is_VM_thread() ||\n+         is_handshake_safe_for(Thread::current()),\n+         \"should be in the vm thread, self or handshakee\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1356,15 +1356,1 @@\n-  void set_handshake_operation(HandshakeOperation* op) {\n-    _handshake.set_operation(op);\n-  }\n-\n-  bool has_handshake() const {\n-    return _handshake.has_operation();\n-  }\n-\n-  void handshake_process_by_self() {\n-    _handshake.process_by_self();\n-  }\n-\n-  HandshakeState::ProcessResult handshake_try_process(HandshakeOperation* op) {\n-    return _handshake.try_process(op);\n-  }\n+  HandshakeState* handshake_state() { return &_handshake; }\n@@ -1372,2 +1358,3 @@\n-  Thread* active_handshaker() const {\n-    return _handshake.active_handshaker();\n+  bool is_handshake_safe_for(Thread* th) const {\n+    return _handshake.active_handshaker() == th ||\n+           this == th;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FILTERQUEUE_HPP\n+#define SHARE_UTILITIES_FILTERQUEUE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+template <class E>\n+class FilterQueue {\n+ private:\n+  class FilterQueueNode : public CHeapObj<mtInternal> {\n+   public:\n+    FilterQueueNode(const E& e): _next(NULL), _data(e) { }\n+    FilterQueueNode*    _next;\n+    E                   _data;\n+  };\n+\n+  FilterQueueNode* _first;\n+  FilterQueueNode* load_first() {\n+    return Atomic::load_acquire(&_first);\n+  }\n+\n+  static bool match_all(E d) { return true; }\n+\n+ public:\n+  FilterQueue() : _first(NULL) { }\n+\n+  \/\/ MT-safe\n+  bool is_empty() {\n+    return load_first() == NULL;\n+  }\n+\n+  \/\/ MT-safe\n+  \/\/ Since pops and adds are allowed while we add, we do not know if _first is same even if it's the same address.\n+  \/\/ But that ABA race is benign.\n+  void add(E data);\n+\n+  \/\/ MT-Unsafe, external serialization needed.\n+  template <typename MATCH_FUNC>\n+  bool contains(MATCH_FUNC& match_func);\n+\n+  \/\/ MT-Unsafe, external serialization needed.\n+  E pop() {\n+    return pop(match_all);\n+  }\n+\n+  \/\/ MT-Unsafe, external serialization needed.\n+  template <typename MATCH_FUNC>\n+  E pop(MATCH_FUNC& match_func);\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n+\n+#include \"utilities\/filterQueue.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+template <class E>\n+void FilterQueue<E>::add(E data) {\n+  FilterQueueNode* head;\n+  FilterQueueNode* insnode = new FilterQueueNode(data);\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with mutiple failed CAS.\n+  while (true){\n+    head = load_first();\n+    insnode->_next = head;\n+    if (Atomic::cmpxchg(&_first, head, insnode) == head) {\n+      break;\n+    }\n+    yield.wait();\n+  }\n+}\n+\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+bool FilterQueue<E>::contains(MATCH_FUNC& match_func) {\n+  FilterQueueNode* cur = load_first();\n+  if (cur == NULL) {\n+    return false;\n+  }\n+  do {\n+    if (match_func(cur->_data)) {\n+      return true;\n+    }\n+    cur = cur->_next;\n+  } while (cur != NULL);\n+  return false;\n+}\n+\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+E FilterQueue<E>::pop(MATCH_FUNC& match_func) {\n+  FilterQueueNode*  first       = load_first();\n+  FilterQueueNode*  cur         = first;\n+  FilterQueueNode*  prev        = NULL;\n+  FilterQueueNode*  match       = NULL;\n+  FilterQueueNode*  match_prev  = NULL;\n+\n+  if (cur == NULL) {\n+    return (E)NULL;\n+  }\n+  SpinYield yield(SpinYield::default_spin_limit * 10); \/\/ Very unlikely with mutiple failed CAS.\n+  do {\n+    do {\n+      if (match_func(cur->_data)) {\n+        match = cur;\n+        match_prev = prev;\n+      }\n+      prev = cur;\n+      cur = cur->_next;\n+    } while (cur != NULL);\n+\n+    if (match == NULL) {\n+      return (E)NULL;\n+    }\n+\n+    if (match_prev == NULL) {\n+      \/\/ Working on first\n+      if (Atomic::cmpxchg(&_first, match, match->_next) == match) {\n+        E ret = match->_data;\n+        delete match;\n+        return ret;\n+      }\n+      yield.wait();\n+      \/\/ Failed, we need to restart to know the Node prior to the match.\n+      first       = load_first();\n+      cur         = first;\n+      prev        = NULL;\n+      match       = NULL;\n+      match_prev  = NULL;\n+    } else {\n+      match_prev->_next = match->_next;\n+      E ret = match->_data;\n+      delete match;\n+      return ret;\n+    }\n+  } while (true);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_FILTERQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/filterQueue.inline.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Get did not find value.\";\n+\n+static bool match_all(uintptr_t val) {\n+  return true;\n+}\n+\n+static bool match_1(uintptr_t val) {\n+  return 1 == val;\n+}\n+\n+static bool match_2(uintptr_t val) {\n+  return 2 == val;\n+}\n+\n+static bool match_3(uintptr_t val) {\n+  return 3 == val;\n+}\n+\n+static bool match_4(uintptr_t val) {\n+  return 4 == val;\n+}\n+\n+static bool match_even(uintptr_t val) {\n+  return (val & 0x1) == 0x0;\n+}\n+\n+static void is_empty(FilterQueue<uintptr_t>& queue) {\n+  EXPECT_EQ(queue.is_empty(), true) << \"Must be empty.\";\n+  EXPECT_EQ(queue.contains(match_1), false) << \"Must be empty.\";\n+  EXPECT_EQ(queue.contains(match_all), false) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)0) << \"Must be empty.\";\n+}\n+\n+TEST_VM(FilterQueue, one) {\n+  FilterQueue<uintptr_t> queue;\n+  is_empty(queue);\n+  queue.add(1);\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+  is_empty(queue);\n+}\n+\n+TEST_VM(FilterQueue, two) {\n+  FilterQueue<uintptr_t> queue;\n+\n+  queue.add(1);\n+  queue.add(2);\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  queue.add(3);\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+\n+  queue.add(2);\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_3), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), false) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), false) << \"Must not contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)3) << \"Must not be empty.\";\n+\n+  is_empty(queue);\n+}\n+\n+TEST_VM(FilterQueue, three) {\n+  FilterQueue<uintptr_t> queue;\n+\n+  queue.add(1);\n+  queue.add(2);\n+  queue.add(3);\n+\n+  EXPECT_EQ(queue.is_empty(), false) << \"Must be not empty.\";\n+  EXPECT_EQ(queue.contains(match_1), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_2), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_3), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_4), false) << \"Must not contain a value.\";\n+\n+  EXPECT_EQ(queue.contains(match_all), true) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.contains(match_even), true) << \"Must contain a value.\";\n+\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.pop(match_even), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.pop(match_all), (uintptr_t)3) << \"Must not be empty.\";\n+\n+  is_empty(queue);\n+}\n+\n+class FilterQueueTestThread : public JavaTestThread {\n+  FilterQueue<uintptr_t>* _fq;\n+  Mutex* _lock;\n+  uintptr_t _val;\n+  uintptr_t _pop;\n+public:\n+  FilterQueueTestThread(Semaphore* post, FilterQueue<uintptr_t>* fq, Mutex* lock, uintptr_t val, uintptr_t pop)\n+    : JavaTestThread(post), _fq(fq), _lock(lock), _val(val), _pop(pop) {\n+  }\n+  virtual void main_run() {\n+    for (int i = 0; i < 1000; i++) {\n+      for (int j = 0; j < 10; j++) {\n+        _fq->add(_val);\n+      }\n+      {\n+        do {\n+          MutexLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+          if (_fq->contains(*this) != 0) {\n+            break;\n+          }\n+        } while (true);\n+      }\n+      for (int j = 0; j < 10; j++) {\n+        MutexLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        while (_fq->pop(*this) == 0) {}\n+      }\n+    }\n+  }\n+  bool operator()(uintptr_t val) {\n+    return val == _pop;\n+  }\n+};\n+\n+TEST_VM(FilterQueue, stress) {\n+  FilterQueue<uintptr_t> queue;\n+  Mutex lock(Mutex::leaf, \"Test Lock\", true, Mutex::_safepoint_check_never);\n+  static const int nthreads = 4;\n+  Semaphore post;\n+  FilterQueueTestThread* threads[nthreads] = {};\n+  for (int i = 0; i < nthreads; ++i) {\n+    threads[i] = new FilterQueueTestThread(&post, &queue, &lock, i + 1, i + 2 > nthreads ? 1 : i + 2);\n+    threads[i]->doit();\n+  }\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+  EXPECT_EQ(queue.is_empty(), true) << \"Must be empty.\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test AsyncHandshakeWalkStackTest\n+ * @library \/testlibrary \/test\/lib\n+ * @build AsyncHandshakeWalkStackTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI AsyncHandshakeWalkStackTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class AsyncHandshakeWalkStackTest {\n+\n+    public static void main(String... args) throws Exception {\n+        int iterations = 3;\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+        }\n+        test(iterations);\n+    }\n+\n+    private static void test(int iterations) throws Exception {\n+        Thread loop_thread  = new Thread(() -> run_loop(create_list()));\n+        Thread alloc_thread = new Thread(() -> run_alloc());\n+        Thread wait_thread  = new Thread(() -> run_wait(new Object() {}));\n+        loop_thread.start();\n+        alloc_thread.start();\n+        wait_thread.start();\n+\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        for (int i = 0; i < iterations; i++) {\n+            System.out.println(\"Iteration \" + i);\n+            System.out.flush();\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(loop_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(alloc_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(wait_thread);\n+            Thread.sleep(200);\n+            wb.asyncHandshakeWalkStack(Thread.currentThread());\n+        }\n+    }\n+\n+    static class List {\n+        List next;\n+\n+        List(List next) {\n+            this.next = next;\n+        }\n+    }\n+\n+    public static List create_list() {\n+        List head = new List(null);\n+        List elem = new List(head);\n+        List elem2 = new List(elem);\n+        List elem3 = new List(elem2);\n+        List elem4 = new List(elem3);\n+        head.next = elem4;\n+\n+        return head;\n+    }\n+\n+    public static void run_loop(List loop) {\n+        while (loop.next != null) {\n+            loop = loop.next;\n+        }\n+    }\n+\n+    public static byte[] array;\n+\n+    public static void run_alloc() {\n+        while (true) {\n+            \/\/ Write to public static to ensure the byte array escapes.\n+            array = new byte[4096];\n+        }\n+    }\n+\n+    public static void run_wait(Object lock) {\n+        synchronized (lock) {\n+            try {\n+                lock.wait();\n+            } catch (InterruptedException ie) {}\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/AsyncHandshakeWalkStackTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 50000;\n+    static final int DIRECT_HANDSHAKES_MARK = 500000;\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test MixedHandshakeWalkStackTest\n+ * @library \/testlibrary \/test\/lib\n+ * @build MixedHandshakeWalkStackTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI MixedHandshakeWalkStackTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class MixedHandshakeWalkStackTest {\n+    public static Thread tthreads[];\n+\n+    public static void main(String... args) throws Exception {\n+        tthreads = new Thread[Runtime.getRuntime().availableProcessors()];\n+        for (int i = 0; i < tthreads.length; i++) {\n+            tthreads[i] = new Thread(() -> handshake());\n+        }\n+\n+        for (Thread t : tthreads) {\n+            t.start();\n+        }\n+\n+        handshake();\n+\n+        for (Thread t : tthreads) {\n+            t.join();\n+        }\n+    }\n+\n+    public static void handshake() {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        java.util.concurrent.ThreadLocalRandom rand = java.util.concurrent.ThreadLocalRandom.current();\n+        long end = System.currentTimeMillis() + 20000;\n+        while (end > System.currentTimeMillis()) {\n+            wb.asyncHandshakeWalkStack(tthreads[rand.nextInt(tthreads.length)]);\n+            wb.handshakeWalkStack(tthreads[rand.nextInt(tthreads.length)], false);\n+            wb.handshakeWalkStack(tthreads[rand.nextInt(tthreads.length)], true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/MixedHandshakeWalkStackTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -590,0 +590,1 @@\n+  public native void asyncHandshakeWalkStack(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}