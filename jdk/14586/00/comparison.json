{"files":[{"patch":"@@ -774,0 +774,7 @@\n+                                                                            \\\n+  develop(bool, PrintLoopConditionalPropagation, false,                     \\\n+          \"Trace Loop Conditional Propagation pass\")                        \\\n+                                                                            \\\n+  product(bool, UseLoopConditionalPropagation, true,                        \\\n+          \"Perform Loop Conditional Propagation pass\")                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -1201,0 +1202,7 @@\n+        if (limit->is_Opaque1() && limit->as_Opaque1()->original_loop_limit() != nullptr) {\n+          limit = limit->as_Opaque1()->original_loop_limit();\n+        }\n+        const Type* init_t = phase->type(init, r->in(1));\n+        if (init_t == Type::TOP) {\n+          return Type::TOP;\n+        }\n@@ -1266,0 +1274,3 @@\n+    } else if (l->in(LoopNode::EntryControl) != nullptr &&\n+               phase->type(l->in(LoopNode::EntryControl)) == Type::TOP) {\n+      return Type::TOP;\n@@ -1274,1 +1285,1 @@\n-      const Type* ti = phase->type(in(i));\n+      const Type* ti = phase->type(in(i), r->in(i));\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  static const TypeInt* filtered_int_type(PhaseGVN* phase, Node* val, Node* if_proj);\n+  static const Type* filtered_int_type(PhaseValues* phase, Node* val, Node* if_proj, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1472,0 +1472,1 @@\n+  if (!tst->is_Con())  record_for_igvn(iff);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -611,1 +611,1 @@\n-const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {\n+const Type* IfNode::filtered_int_type(PhaseValues* phase, Node* val, Node* if_proj, BasicType bt) {\n@@ -616,52 +616,7 @@\n-    if (iff->in(1) && iff->in(1)->is_Bool()) {\n-      BoolNode* bol = iff->in(1)->as_Bool();\n-      if (bol->in(1) && bol->in(1)->is_Cmp()) {\n-        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n-        if (cmp->in(1) == val) {\n-          const TypeInt* cmp2_t = gvn->type(cmp->in(2))->isa_int();\n-          if (cmp2_t != nullptr) {\n-            jint lo = cmp2_t->_lo;\n-            jint hi = cmp2_t->_hi;\n-            BoolTest::mask msk = if_proj->Opcode() == Op_IfTrue ? bol->_test._test : bol->_test.negate();\n-            switch (msk) {\n-            case BoolTest::ne: {\n-              \/\/ If val is compared to its lower or upper bound, we can narrow the type\n-              const TypeInt* val_t = gvn->type(val)->isa_int();\n-              if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n-                if (val_t->_lo == lo) {\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n-                } else if (val_t->_hi == hi) {\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n-                }\n-              }\n-              \/\/ Can't refine type\n-              return nullptr;\n-            }\n-            case BoolTest::eq:\n-              return cmp2_t;\n-            case BoolTest::lt:\n-              lo = TypeInt::INT->_lo;\n-              if (hi != min_jint) {\n-                hi = hi - 1;\n-              }\n-              break;\n-            case BoolTest::le:\n-              lo = TypeInt::INT->_lo;\n-              break;\n-            case BoolTest::gt:\n-              if (lo != max_jint) {\n-                lo = lo + 1;\n-              }\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            case BoolTest::ge:\n-              \/\/ lo unchanged\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            default:\n-              break;\n-            }\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n-            return rtn_t;\n-          }\n-        }\n+    if (iff->in(1)) {\n+      Node* iff1 = iff->in(1);\n+      if (iff1->Opcode() == Op_Opaque4) {\n+        iff1 = iff1->in(1);\n+      }\n+      if (iff1->is_Bool()) {\n+        return iff1->as_Bool()->filtered_int_type(phase, val, bt, if_proj->Opcode() == Op_IfTrue);\n@@ -859,0 +814,1 @@\n+  Node* dom_cmp = dom_bool->in(1);\n@@ -864,2 +820,8 @@\n-  const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);\n-  const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);\n+  if (this_cmp->Value(igvn)->singleton() || dom_cmp->Value(igvn)->singleton()) {\n+    return false;\n+  }\n+\n+  const Type* t = IfNode::filtered_int_type(igvn, n, otherproj, T_INT);\n+  const TypeInt* lo_type = t != nullptr && t->isa_int() ? t->is_int() : nullptr;\n+  t = IfNode::filtered_int_type(igvn, n, success, T_INT);\n+  const TypeInt* hi_type = t != nullptr && t->isa_int() ? t->is_int() : nullptr;\n@@ -1000,1 +962,1 @@\n-    const TypeInt* failtype = filtered_int_type(igvn, n, proj);\n+    const Type* failtype = filtered_int_type(igvn, n, proj, T_INT);\n@@ -1002,1 +964,1 @@\n-      const TypeInt* type2 = filtered_int_type(igvn, n, fail);\n+      const Type* type2 = filtered_int_type(igvn, n, fail, T_INT);\n@@ -1004,6 +966,8 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->_lo > failtype->_hi) {\n-          \/\/ previous if determines the result of this if so\n-          \/\/ replace Bool with constant\n-          igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n-          return true;\n+        failtype = failtype->join(type2);\n+        if (failtype->isa_int()) {\n+          if (failtype->is_int()->_lo > failtype->is_int()->_hi) {\n+            \/\/ previous if determines the result of this if so\n+            \/\/ replace Bool with constant\n+            igvn->replace_input_of(this, 1, igvn->intcon(success->_con));\n+            return true;\n+          }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":27,"deletions":63,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,1213 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+  The goal of this pass is to optimize redundant conditions such as\n+  the second one in:\n+\n+  if (i < 10) {\n+    if (i < 42) {\n+\n+  In the branch of the first if, the type of i can be narrowed down to\n+  [min_jint, 9] which can then be used to constant fold the second\n+  condition.\n+\n+  The compiler already keeps track of type[n] for every node in the\n+  current compilation unit. That's not sufficient to optimize the\n+  snippet above though because the type of i can only be narrowed in\n+  some section of the control flow (that is a subset of all\n+  controls). The solution is to build a new table that tracks the type\n+  of n at every control c\n+\n+  type'[n, root] = type[n] \/\/ initialized from igvn's type table\n+  type'[n, c] = type[n, idom(c)]\n+\n+  This pass iterates over the CFG looking for conditions such as:\n+\n+  if (i < 10) {\n+\n+  that allows narrowing the type of i and update the type' table\n+  accordingly.\n+\n+  At a region r:\n+\n+  type'[n, r] = meet(type'[n, r->in(1)], type'[n, r->in(2)]...)\n+\n+  For a Phi phi at a region r:\n+\n+  type'[phi, r] = meet(type'[phi->in(1), r->in(1)], type'[phi->in(2), r->in(2)]...)\n+\n+  Once a type is narrowed, uses are enqueued and their types are\n+  computed by calling the Value() methods. Value() methods retrieve\n+  types from the type table, not the type' table. To address that\n+  issue while leaving Value() methods unchanged, before calling\n+  Value() at c, the type table is updated so:\n+\n+  type[n] = type'[n, c]\n+\n+  An exception is for Phi::Value which needs to retrieve the type of\n+  nodes are various controls: there a new type(Node* n, Node* c)\n+  method is used.\n+\n+  For most n and c, type'[n, c] is likely the same as type[n], the\n+  type recorded in the global igvn table (that there shouldn't be many\n+  nodes at only a few control for which we can narrow the type\n+  down). As a consequence, the types'[n, c] table is implemented as:\n+\n+  - At c, narrowed down types are stored in a GrowableArray. Each\n+    entry records the previous type at idom(c) and the narrowed down\n+    type at c.\n+\n+  - The GrowableArray of type updates is recorded in a hash table\n+    indexed by c. If there's no update at c, there's no entry in the\n+    hash table.\n+\n+  This pass operates in 2 steps:\n+\n+  - it first iterates over the graph looking for conditions that\n+    narrow the types of some nodes and propagate type updates to uses\n+    until a fix point.\n+\n+  - it transforms the graph so newly found constant nodes are folded.\n+\n+*\/\n+\n+#include \"memory\/resourceArea.hpp\"\n+#include \"node.hpp\"\n+#include \"precompiled.hpp\"\n+#include \"opto\/loopConditionalPropagation.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n+#include \"opto\/opaquenode.hpp\"\n+\n+\n+bool PhaseConditionalPropagation::related_use(Node* u, Node* c) {\n+  if (!_phase->has_node(u)) {\n+    return false;\n+  }\n+  if (u->is_Phi()) {\n+    if (u->in(0) ==  c) {\n+      return true;\n+    }\n+    int iterations = _iterations;\n+    if (_visited.test(u->in(0)->_idx)) {\n+      _progress = true;\n+      iterations = _iterations + 1;\n+    }\n+    \/\/ mark as needing processing either in the pass over the CFG (control not yet processed) or on the next one\n+    _control_dependent_node[iterations%2].set(u->in(0)->_idx);\n+    _control_dependent_node[iterations%2].set(u->_idx);\n+    return false;\n+  }\n+  Node* u_c = _phase->ctrl_or_self(u);\n+  if (!_phase->is_dominator(c, u_c) && (u->is_CFG() || !_phase->is_dominator(u_c, c))) {\n+    return false;\n+  }\n+  if (!u->is_CFG() && u->in(0) != nullptr && u->in(0)->is_CFG() && !_phase->is_dominator(u->in(0), c)) {\n+    \/\/ mark as needing processing either in the pass over the CFG (control not yet processed) or on the next one\n+    assert(!_visited.test(u->in(0)->_idx), \"\");\n+    _control_dependent_node[_iterations%2].set(u->in(0)->_idx);\n+    _control_dependent_node[_iterations%2].set(u->_idx);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void PhaseConditionalPropagation::enqueue_uses(const Node* n, Node* c) {\n+  assert(_phase->has_node(const_cast<Node*>(n)), \"\");\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (related_use(u, c)) {\n+      _wq.push(u);\n+      if (u->Opcode() == Op_AddI || u->Opcode() == Op_SubI) {\n+        for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+          Node* uu = u->fast_out(i2);\n+          if (uu->Opcode() == Op_CmpU && related_use(uu, c)) {\n+            _wq.push(uu);\n+          }\n+        }\n+      }\n+      if (u->is_AllocateArray()) {\n+        for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+          Node* uu = u->fast_out(i2);\n+          if (uu->is_Proj() && uu->as_Proj()->_con == TypeFunc::Control) {\n+            Node* catch_node = uu->find_out_with(Op_Catch);\n+            if (catch_node != nullptr) {\n+              _wq.push(catch_node);\n+            }\n+          }\n+        }\n+      }\n+      if (u->Opcode() == Op_OpaqueZeroTripGuard) {\n+        Node* cmp = u->unique_out();\n+        if (related_use(cmp, c)) {\n+          _wq.push(cmp);\n+        }\n+      }\n+      if (u->is_Opaque1() && u->as_Opaque1()->original_loop_limit() == n) {\n+        for (DUIterator_Fast i2max, i2 = u->fast_outs(i2max); i2 < i2max; i2++) {\n+          Node* uu = u->fast_out(i2);\n+          if (uu->Opcode() == Op_CmpI || uu->Opcode() == Op_CmpL) {\n+            Node* phi = uu->as_Cmp()->countedloop_phi(u);\n+            if (phi != nullptr && related_use(phi, c)) {\n+              _wq.push(phi);\n+            }\n+          }\n+        }\n+      }\n+      if (u->Opcode() == Op_CmpI || u->Opcode() == Op_CmpL) {\n+        Node* phi = u->as_Cmp()->countedloop_phi(n);\n+        if (phi != nullptr && related_use(phi, c)) {\n+          _wq.push(phi);\n+        }\n+      }\n+\n+      \/\/ If this node feeds into a condition that feeds into an If, mark the if as needing work (for iterations > 1)\n+      mark_if_from_cmp(u, c);\n+\n+      if (u->Opcode() == Op_ConvL2I) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* u2 = u->fast_out(j);\n+          mark_if_from_cmp(u2, c);\n+        }\n+      }\n+\n+      if (u->is_Region()) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* uu = u->fast_out(j);\n+          if (uu->is_Phi() && related_use(uu, c)) {\n+            _wq.push(uu);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::mark_if_from_cmp(const Node* u, Node* c) {\n+  if (u->Opcode() == Op_CmpI || u->Opcode() == Op_CmpL || u->Opcode() == Op_CmpU || u->Opcode() == Op_CmpUL) {\n+    for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+      Node* u2 = u->fast_out(j);\n+      if (u2->is_Bool()) {\n+        for (DUIterator_Fast kmax, k = u2->fast_outs(kmax); k < kmax; k++) {\n+          Node* u3 = u2->fast_out(k);\n+          if (u3->is_If()) {\n+            mark_if(u3->as_If(), c);\n+          } else if (u3->Opcode() == Op_Opaque4) {\n+            for (DUIterator_Fast lmax, l = u3->fast_outs(lmax); l < lmax; l++) {\n+              Node* u4 = u3->fast_out(l);\n+              if (u4->is_If()) {\n+                mark_if(u4->as_If(), c);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::mark_if(IfNode* iff, Node* c) {\n+  if (_phase->is_dominator(c, iff)) {\n+    ProjNode* proj_false = iff->proj_out(0);\n+    ProjNode* proj_true = iff->proj_out(1);\n+    assert(!_visited.test(proj_false->_idx), \"\");\n+    assert(!_visited.test(proj_true->_idx), \"\");\n+    _control_dependent_node[_iterations % 2].set(proj_false->_idx);\n+    _control_dependent_node[_iterations % 2].set(proj_true->_idx);\n+  }\n+}\n+\n+\/\/ PhaseValues::_types is in sync with types at _current_ctl, we want to update it to be in sync with types at c\n+void PhaseConditionalPropagation::sync(Node* c) {\n+  Node* lca = _phase->dom_lca_internal(_current_ctrl, c);\n+  \/\/ Update PhaseValues::_types to lca by undoing every update between _current_ctrl and lca\n+  TypeUpdate* lca_updates = updates_at(lca);\n+  {\n+    TypeUpdate* updates = updates_at(_current_ctrl);\n+    while (updates != lca_updates) {\n+      assert(updates != nullptr, \"\");\n+      assert(lca_updates == nullptr || !_phase->is_dominator(updates->control(), lca_updates->control()), \"\");\n+\n+      for (int i = 0; i < updates->length(); ++i) {\n+        Node* n = updates->node_at(i);\n+        const Type* t = updates->prev_type_at(i);\n+        PhaseValues::set_type(n, t);\n+      }\n+      updates = updates->prev();\n+    }\n+  }\n+  \/\/ Update PhaseValues::_types to c by applying every update between lca and c\n+  {\n+    TypeUpdate* updates = updates_at(c);\n+    assert(_stack.length() == 0, \"\");\n+    while (updates != lca_updates) {\n+      assert(updates != nullptr, \"\");\n+      assert(lca_updates == nullptr || !_phase->is_dominator(updates->control(), lca_updates->control()), \"\");\n+      _stack.push(updates);\n+      updates = updates->prev();\n+    }\n+    while (_stack.length() > 0) {\n+      TypeUpdate* updates = _stack.pop();\n+      for (int i = 0; i < updates->length(); ++i) {\n+        Node* n = updates->node_at(i);\n+        const Type* t = updates->type_at(i);\n+        PhaseValues::set_type(n, t);\n+      }\n+    }\n+  }\n+  _current_ctrl = c;\n+}\n+\n+void PhaseConditionalPropagation::analyze(int rounds) {\n+#ifdef ASSERT\n+  int extra_rounds = 0;\n+  int extra_rounds2 = 0;\n+  bool has_infinite_loop = false;\n+#endif\n+  VectorSet updated;\n+  while (_progress) {\n+    _control_dependent_node[_iterations % 2].clear();\n+    _iterations++;\n+    assert(_iterations - extra_rounds - extra_rounds2 >= 0, \"\");\n+    assert(_iterations - extra_rounds2 <= 2 || _phase->ltree_root()->_child != nullptr || has_infinite_loop, \"\");\n+    assert(_iterations - extra_rounds - extra_rounds2 <= 3 || _phase->_has_irreducible_loops, \"\");\n+    assert(_iterations < 100, \"\");\n+\n+    bool extra = false;\n+    bool extra2 = false;\n+    _progress = false;\n+\n+    _visited.clear();\n+\n+    if (_iterations == 1) {\n+      \/\/ Go over the entire cfg looking for conditions that allow type narrowing\n+      for (int i = _rpo_list.size() - 1; i >= 0; i--) {\n+        Node* c = _rpo_list.at(i);\n+        DEBUG_ONLY(has_infinite_loop = has_infinite_loop || (c->in(0)->Opcode() == Op_NeverBranch));\n+\n+        adjust_updates(c, false);\n+        _visited.set(c->_idx);\n+        one_iteration(c, extra, extra2, false);\n+      }\n+    } else {\n+      \/\/ Another pass of the entire cfg but this time, only process those controls that were marked at previous iteration\n+      updated.clear();\n+      for (int i = _rpo_list.size() - 1; i >= 0; i--) {\n+        assert(_wq.size() == 0, \"\");\n+        Node* c = _rpo_list.at(i);\n+        _visited.set(c->_idx);\n+        Node* dom = known_updates(_phase->idom(c));\n+        bool adjust_updates_called = false;\n+        \/\/ If we recorded a narrowed type at this control for a node n on a previous pass and on this pass, we narrowed\n+        \/\/ the type of n at some dominating control, we need to merge the 2 updates. The \"updated\" set is used to keep track\n+        \/\/ of parts of the CFG where updates happened on this pass.\n+        if (updated.test(dom->_idx)) {\n+          adjust_updates_called = true;\n+          adjust_updates(c, false);\n+          updated.set(c->_idx);\n+        }\n+        \/\/ Was control marked as needing work?\n+        if (_control_dependent_node[_iterations % 2].test(c->_idx) || _wq.size() > 0) {\n+          if (!adjust_updates_called) {\n+            adjust_updates(c, false);\n+          }\n+          if (one_iteration(c, extra, extra2, false)) {\n+            updated.set(c->_idx);\n+          }\n+        } else {\n+          if (c->is_Region()) {\n+            uint j;\n+            for (j = 1; j < c->req(); ++j) {\n+              if (updated.test(known_updates(c->in(j))->_idx)) {\n+                break;\n+              }\n+            }\n+            if (j < c->req()) {\n+              if (!adjust_updates_called) {\n+                adjust_updates(c, false);\n+              }\n+              \/\/ Process region because there was some update along some of the CFG inputs\n+              if (one_iteration(c, extra, extra2, false)) {\n+                updated.set(c->_idx);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+#ifdef ASSERT\n+    if (extra) {\n+      extra_rounds++;\n+    } else if (extra2) {\n+      extra_rounds2++;\n+    }\n+#endif\n+    rounds--;\n+    if (rounds <= 0) {\n+      break;\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  \/\/ Verify we've indeed reached a fixed point\n+  _control_dependent_node[_iterations % 2].clear();\n+  _iterations++;\n+  bool extra = false;\n+  bool extra2 = false;\n+  _visited.clear();\n+  for (int i = _rpo_list.size() - 1; i >= 0; i--) {\n+    int rpo = _rpo_list.size() - 1 - i;\n+    Node* c = _rpo_list.at(i);\n+\n+    adjust_updates(c, true);\n+    bool progress = one_iteration(c, extra, extra2, true);\n+    if (extra2) {\n+      break;\n+    }\n+    assert(!progress, \"\");\n+  }\n+#endif\n+\n+  sync(C->root());\n+}\n+\n+bool PhaseConditionalPropagation::one_iteration(Node* c, bool& extra, bool& extra2, bool verify) {\n+  Node* dom = _phase->idom(c);\n+\n+  if (c->is_Region()) {\n+    \/\/ Look for nodes whose types are narrowed between this region and the dominator control on all region's inputs\n+    \/\/ First find the region's input that has the smallest number of type updates to keep processing as low as possible\n+    uint in_idx = 1;\n+    int num_types = max_jint;\n+    for (uint i = 1 ; i < c->req(); ++i) {\n+      Node* in = c->in(i);\n+      TypeUpdate* updates = updates_at(in);\n+      int cnt = 0;\n+      while(updates != nullptr && updates->below(_dom_updates, _phase)) {\n+        cnt += updates->length();\n+        updates = updates->prev();\n+      }\n+      if (cnt < num_types) {\n+        in_idx = i;\n+        num_types = cnt;\n+      }\n+    }\n+    Node* in = c->in(in_idx);\n+    Node* ctrl = in;\n+    TypeUpdate* updates = updates_at(ctrl);\n+    assert(updates != nullptr || _dom_updates == nullptr || _phase->is_dominator(c, in) || C->has_irreducible_loop(), \"\");\n+    \/\/ now go over all type updates between this region input and the dominator\n+    while(updates != nullptr && updates->below(_dom_updates, _phase)) {\n+      for (int j = 0; j < updates->length(); ++j) {\n+        Node* n = updates->node_at(j);\n+        if (n->is_CMove()) {\n+          \/*\n+           If we have:\n+           \/\/ type of v1 is [min, max]\n+           v2 = v1 > 0 ? v1 : 0; \/\/ type of v2 is [min, max]\n+           if (v1 > 0) {\n+             \/\/ type of v1 is [1, max]\n+             ..\n+             \/\/ type of v2 is [1, max]\n+           } else {\n+             \/\/ type of v1 is [min, 0]\n+             ..\n+             \/\/ type of v2 is 0\n+           }\n+           \/\/ type of v2 is [0, max]\n+\n+           The if with the identical condition helps narrow down the value of the CMove beyond what C2 can usually figure\n+           out. Now if the if is eliminated as the compilation process moves on, a subsequent pass of this optimization\n+           may not be able  to narrow the type of CMove again. This graph shape shows up in the loop opts pass that creates\n+           the CMove (corresponding if not yet eliminated). Inconsistencies between passes of this optimization can cause\n+           issues so skip merging of CMove entirely.\n+           *\/\n+          continue;\n+        }\n+        const Type* t = find_type_between(n, in, dom);\n+        \/\/ and check if the type was updated from other region inputs\n+        uint k = 1;\n+        for (; k < c->req(); k++) {\n+          if (k == in_idx) {\n+            continue;\n+          }\n+          Node* other_in = c->in(k);\n+          const Type* type_at_in = find_type_between(n, other_in, dom);\n+          if (type_at_in == nullptr) {\n+            break;\n+          }\n+          t = t->meet_speculative(type_at_in);\n+        }\n+        \/\/ If that's the case, record type update\n+        if (k == c->req()) {\n+          const Type* current_type = find_prev_type_between(n, in, dom);\n+\n+          if (_iterations > 1) {\n+            t = current_type->filter(t);\n+            const Type* prev_t = t;\n+            const Type* prev_round_t = nullptr;\n+            if (_prev_updates != nullptr && _prev_updates->control() == c) {\n+              prev_round_t = _prev_updates->type_if_present(n);\n+            }\n+            if (prev_round_t == nullptr) {\n+              prev_round_t = current_type;\n+            }\n+            if (prev_round_t != nullptr) {\n+              t = prev_round_t->filter(t);\n+              assert(t == prev_t, \"\");\n+              t = saturate(t, prev_round_t, nullptr);\n+              if (c->is_Loop() && t != prev_round_t) {\n+                extra = true;\n+              }\n+            }\n+          }\n+          t = current_type->filter(t);\n+\n+          if (t != current_type) {\n+            assert(narrows_type(current_type, t), \"\");\n+            if (record_update(c, n, current_type, t)) {\n+              enqueue_uses(n, c);\n+            }\n+          }\n+        }\n+      }\n+      updates = updates->prev();\n+      assert(updates != nullptr || _dom_updates == nullptr || _phase->is_dominator(c, in) || C->has_irreducible_loop(), \"\");\n+    }\n+  } else if (c->is_IfProj()) {\n+    Node* iff = c->in(0);\n+    assert(iff->is_If(), \"\");\n+    if (!(iff->is_CountedLoopEnd() && iff->as_CountedLoopEnd()->loopnode() != nullptr &&\n+          iff->as_CountedLoopEnd()->loopnode()->is_strip_mined())) {\n+      Node* bol = iff->in(1);\n+      if (iff->is_OuterStripMinedLoopEnd()) {\n+        assert(iff->in(0)->in(0)->in(0)->is_CountedLoopEnd(), \"\");\n+        bol = iff->in(0)->in(0)->in(0)->in(1);\n+      }\n+      if (bol->Opcode() == Op_Opaque4) {\n+        bol = bol->in(1);\n+      }\n+      if (bol->is_Bool()) {\n+        Node* cmp = bol->in(1);\n+        if (cmp->Opcode() == Op_CmpI || cmp->Opcode() == Op_CmpU ||\n+            cmp->Opcode() == Op_CmpL || cmp->Opcode() == Op_CmpUL) {\n+          Node* cmp1 = cmp->in(1);\n+          Node* cmp2 = cmp->in(2);\n+          sync(iff);\n+          \/\/ narrowing the type of a LoadRange could cause a range check to optimize out and a Load to be hoisted above\n+          \/\/ checks that guarantee its within bounds\n+          if (cmp1->Opcode() != Op_LoadRange) {\n+            analyze_if(c, cmp, cmp1);\n+          }\n+          if (cmp2->Opcode() != Op_LoadRange) {\n+            analyze_if(c, cmp, cmp2);\n+          }\n+        }\n+      }\n+    }\n+  } else if (c->is_CatchProj() && c->in(0)->in(0)->in(0)->is_AllocateArray() &&\n+             c->as_CatchProj()->_con == CatchProjNode::fall_through_index) {\n+    \/\/ If the allocation succeeds, length is > 0 and less than max supported size\n+    AllocateArrayNode* alloc = c->in(0)->in(0)->in(0)->as_AllocateArray();\n+    sync(dom);\n+    analyze_allocate_array(c, alloc);\n+  }\n+  if (verify || _control_dependent_node[_iterations%2].test(c->_idx)) {\n+    for (DUIterator_Fast imax, i = c->fast_outs(imax); i < imax; i++) {\n+      Node* u = c->fast_out(i);\n+      if (!u->is_CFG() && u->in(0) == c && u->Opcode() != Op_CheckCastPP && _phase->has_node(u) && (verify || _control_dependent_node[_iterations%2].test(u->_idx))) {\n+        _wq.push(u);\n+      }\n+    }\n+  }\n+\n+  sync(c);\n+  while (_wq.size() > 0) {\n+    Node* n = _wq.pop();\n+    const Type* t = n->Value(this);\n+    const Type* current_type = PhaseValues::type(n);\n+    if (n->is_Phi() && _iterations > 1) {\n+      t = current_type->filter(t);\n+      const Type* prev_type = nullptr;\n+      if (_prev_updates != nullptr) {\n+        prev_type = _prev_updates->type_if_present(n);\n+      }\n+      if (prev_type != nullptr) {\n+        const Type* prev_t = t;\n+        t = prev_type->filter(t);\n+        assert(t == prev_t, \"\");\n+        if (!(n->in(0)->is_CountedLoop() && n->in(0)->as_CountedLoop()->phi() == n &&\n+              n->in(0)->as_CountedLoop()->can_be_counted_loop(this))) {\n+          t = saturate(t, prev_type, nullptr);\n+        }\n+      }\n+      if (c->is_Loop() && t != prev_type) {\n+        extra = true;\n+      }\n+    }\n+    t = current_type->filter(t);\n+    if (t != current_type) {\n+#ifdef ASSERT\n+      assert(narrows_type(current_type, t), \"\");\n+#endif\n+      set_type(n, t, current_type);\n+      enqueue_uses(n, c);\n+    }\n+  }\n+\n+  bool progress = false;\n+  if (_prev_updates == nullptr) {\n+    if (_current_updates != nullptr && _current_updates->length() > 0 && _current_updates->control() == c) {\n+      progress = true;\n+#ifdef ASSERT\n+      sync(dom);\n+      for (int i = 0; i < _current_updates->length(); ++i) {\n+        Node* n = _current_updates->node_at(i);\n+        assert(_current_updates->prev_type_at(i) == PhaseValues::type(n), \"\");\n+        assert(narrows_type(PhaseValues::type(n), _current_updates->type_at(i)), \"\");\n+      }\n+#endif\n+    }\n+  } else {\n+#ifdef ASSERT\n+    sync(dom);\n+#endif\n+\n+    int j = 0;\n+    assert(_current_updates->control() == c, \"\");\n+    for (int i = 0; i < _current_updates->length(); ++i) {\n+      Node* n = _current_updates->node_at(i);\n+      assert(_current_updates->prev_type_at(i) == PhaseValues::type(n), \"\");\n+      const Type* current_t = _current_updates->type_at(i);\n+      assert(narrows_type(PhaseValues::type(n), current_t), \"\");\n+      for (; j < _prev_updates->length() && _prev_updates->node_at(j)->_idx < n->_idx; j++) {\n+        assert(narrows_type(_prev_updates->type_at(j), PhaseValues::type(_prev_updates->node_at(j))), \"\");\n+      }\n+      if (j < _prev_updates->length() && _prev_updates->node_at(j) == n) {\n+        const Type* prev_t = _prev_updates->type_at(j);\n+        assert(narrows_type(prev_t, current_t), \"\");\n+        if (prev_t != current_t) {\n+          progress = true;\n+        }\n+        j++;\n+      } else {\n+        assert(_prev_updates->find(n) == -1, \"\");\n+        if (current_t != _current_updates->prev_type_at(i)) {\n+          progress = true;\n+        }\n+      }\n+    }\n+#ifdef ASSERT\n+    for (; j < _prev_updates->length(); j++) {\n+      assert(narrows_type(_prev_updates->type_at(j), PhaseValues::type(_prev_updates->node_at(j))), \"\");\n+    }\n+#endif\n+  }\n+#ifdef ASSERT\n+  if (_current_updates != nullptr && _current_updates->control() == c) {\n+    sync(C->root());\n+    for (int i = 0; i < _current_updates->length(); ++i) {\n+      Node* n = _current_updates->node_at(i);\n+      if (PhaseValues::type(n) != n->Value(this) &&\n+          _current_updates->prev_type_at(i) == PhaseValues::type(n)) {\n+        if (_current_updates->type_at(i) == PhaseValues::type(n)->filter(n->Value(this))) {\n+          extra2 = true;\n+        } else if (n->is_Phi() && c->is_Loop() && _current_updates->find(n->in(LoopNode::LoopBackControl)) != -1) {\n+          assert(narrows_type(PhaseValues::type(n)->filter(n->Value(this)), _current_updates->type_at(i)), \"\");\n+          extra2 = true;\n+        }\n+      }\n+    }\n+  }\n+#endif\n+  return progress;\n+}\n+\n+void PhaseConditionalPropagation::adjust_updates(Node* c, bool verify) {\n+  Node* dom = _phase->idom(c);\n+  _current_updates = updates_at(c);\n+  _dom_updates = updates_at(dom);\n+  _prev_updates = nullptr;\n+  if (_current_updates == nullptr) {\n+    _current_updates = _dom_updates;\n+    if (_current_updates != nullptr) {\n+      _updates->put(c, _current_updates);\n+      _updates->maybe_grow(load_factor);\n+    }\n+  } else {\n+    assert(_iterations > 1, \"\");\n+    if (_current_updates == _dom_updates) {\n+      \/\/ do nothing\n+    } else if (_current_updates->control() != c) {\n+      assert(_dom_updates != nullptr, \"\");\n+      _current_updates = _dom_updates;\n+      _updates->put(c, _current_updates);\n+      _updates->maybe_grow(load_factor);\n+    } else {\n+      _prev_updates = _current_updates->copy();\n+      sync(dom);\n+      for (int j = 0; j < _current_updates->length();) {\n+        Node* n = _current_updates->node_at(j);\n+        const Type* dom_t = PhaseValues::type(n);\n+        const Type* t = _current_updates->type_at(j);\n+        const Type* new_t = dom_t->filter(t);\n+        if (new_t == dom_t) {\n+          _current_updates->remove_at(j);\n+          enqueue_uses(n, c);\n+        } else {\n+          _current_updates->set_prev_type_at(j, dom_t);\n+          if (new_t != t) {\n+            assert(!verify, \"\");\n+            _current_updates->set_type_at(j, new_t);\n+            enqueue_uses(n, c);\n+          }\n+          j++;\n+        }\n+      }\n+      assert(_dom_updates == nullptr || !_phase->is_dominator(_current_updates->control(), _dom_updates->control()), \"\");\n+      _current_updates->set_prev(_dom_updates);\n+    }\n+  }\n+}\n+\n+void PhaseConditionalPropagation::analyze_allocate_array(Node* c, const AllocateArrayNode* alloc) {\n+  Node* length = alloc->in(AllocateArrayNode::ALength);\n+  Node* klass = alloc->in(AllocateNode::KlassNode);\n+  const Type* klass_t = PhaseValues::type(klass);\n+  if (klass_t != Type::TOP) {\n+    const TypeOopPtr* ary_type = klass_t->is_klassptr()->as_instance_type();\n+    const TypeInt* length_type = PhaseValues::type(length)->isa_int();\n+    if (ary_type->isa_aryptr() && length_type != nullptr) {\n+      const Type* narrow_length_type = ary_type->is_aryptr()->narrow_size_type(length_type);\n+      narrow_length_type = length_type->filter(narrow_length_type);\n+      assert(narrows_type(length_type, narrow_length_type), \"\");\n+      if (narrow_length_type != length_type) {\n+        if (record_update(c, length, length_type, narrow_length_type)) {\n+          enqueue_uses(length, c);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+const Type* PhaseConditionalPropagation::find_type_between(Node* n, Node* c, Node* dom) const {\n+  assert(_phase->is_dominator(dom, c), \"\");\n+  TypeUpdate* updates = updates_at(c);\n+  TypeUpdate* dom_updates = updates_at(dom);\n+  while(updates != nullptr && updates->below(dom_updates, _phase)) {\n+    int l = updates->find(n);\n+    if (l != -1) {\n+      return updates->type_at(l);\n+    }\n+    updates = updates->prev();\n+  }\n+  return nullptr;\n+}\n+\n+const Type* PhaseConditionalPropagation::find_prev_type_between(Node* n, Node* c, Node* dom) const {\n+  assert(_phase->is_dominator(dom, c), \"\");\n+  TypeUpdate* updates = updates_at(c);\n+  TypeUpdate* dom_updates = updates_at(dom);\n+  const Type* res = nullptr;\n+  while(updates->below(dom_updates, _phase)) {\n+    assert(updates != nullptr,\"\");\n+    int l = updates->find(n);\n+    if (l != -1) {\n+      res = updates->prev_type_at(l);\n+    }\n+    updates = updates->prev();\n+  }\n+  return res;\n+}\n+\n+bool PhaseConditionalPropagation::record_update(Node* c, const Node* n, const Type* old_t, const Type* new_t) {\n+  if (_current_updates == _dom_updates) {\n+    _current_updates = new TypeUpdate(_dom_updates, c);\n+    _updates->put(c, _current_updates);\n+    _updates->maybe_grow(load_factor);\n+  }\n+  int i = _current_updates->find(n);\n+  if (i == -1) {\n+    _current_updates->push_node(n, old_t, new_t);\n+    return true;\n+  } else if (_current_updates->type_at(i) != new_t) {\n+    _current_updates->set_type_at(i, new_t);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void PhaseConditionalPropagation::analyze_if(Node* c, const Node* cmp, Node* n) {\n+  const Type* t = IfNode::filtered_int_type(this, n, c, (cmp->Opcode() == Op_CmpI || cmp->Opcode() == Op_CmpU) ? T_INT : T_LONG);\n+  if (t != nullptr) {\n+    const Type* n_t = PhaseValues::type(n);\n+    const Type* new_n_t = n_t->filter(t);\n+    assert(narrows_type(n_t, new_n_t), \"\");\n+    if (n_t != new_n_t) {\n+#ifdef ASSERT\n+      _conditions.set(c->_idx);\n+#endif\n+      if (record_update(c, n, n_t, new_n_t)) {\n+        enqueue_uses(n, c);\n+        if (!n->is_Phi()) {\n+          _wq.push(n);\n+        }\n+      }\n+    }\n+    if (n->Opcode() == Op_ConvL2I) {\n+      Node* in = n->in(1);\n+      const Type* in_t = PhaseValues::type(in);\n+\n+      if (in_t->isa_long() && in_t->is_long()->_lo >= min_jint && in_t->is_long()->_hi <= max_jint) {\n+        const Type* t_as_long = t->isa_int() ? TypeLong::make(t->is_int()->_lo, t->is_int()->_hi, t->is_int()->_widen) : Type::TOP;\n+        const Type* new_in_t = in_t->filter(t_as_long);\n+        assert(narrows_type(in_t, new_in_t), \"\");\n+        if (in_t != new_in_t) {\n+#ifdef ASSERT\n+          _conditions.set(c->_idx);\n+#endif\n+          if (record_update(c, in, in_t, new_in_t)) {\n+            enqueue_uses(in, c);\n+            if (!in->is_Phi()) {\n+              _wq.push(in);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool PhaseConditionalPropagation::narrows_type(const Type* old_t, const Type* new_t) {\n+  if (old_t == new_t) {\n+    return true;\n+  }\n+\n+  if (new_t == Type::TOP) {\n+    return true;\n+  }\n+\n+  if (old_t == Type::TOP) {\n+    return false;\n+  }\n+\n+  if (!new_t->isa_int() && !new_t->isa_long()) {\n+    return true;\n+  }\n+\n+  assert(old_t->isa_int() || old_t->isa_long(), \"\");\n+  assert((old_t->isa_int() != nullptr) == (new_t->isa_int() != nullptr), \"\");\n+\n+  BasicType bt = new_t->isa_int() ? T_INT : T_LONG;\n+\n+  const TypeInteger* new_int = new_t->is_integer(bt);\n+  const TypeInteger* old_int = old_t->is_integer(bt);\n+\n+  if (new_int->lo_as_long() < old_int->lo_as_long()) {\n+    return false;\n+  }\n+\n+  if (new_int->hi_as_long() > old_int->hi_as_long()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif\n+\n+void PhaseConditionalPropagation::do_transform() {\n+  _wq.push(_phase->C->root());\n+  bool progress = false;\n+  for (uint i = 0; i < _wq.size(); i++) {\n+    Node* c = _wq.at(i);\n+\n+    if (c->is_CatchProj() && c->in(0)->in(0)->in(0)->is_AllocateArray()) {\n+      const Type* t = find_type_between(c, c, C->root());\n+      if (t == Type::TOP) {\n+        replace_node(c, _phase->C->top());\n+        _phase->C->set_major_progress();\n+        continue;\n+      }\n+    } else {\n+      assert(find_type_between(c, c, C->root()) != Type::TOP, \"\");\n+    }\n+\n+    for (DUIterator i = c->outs(); c->has_out(i); i++) {\n+      Node* u = c->out(i);\n+      if (u->is_CFG() && !_wq.member(u)) {\n+        if (transform_helper(u)) {\n+          progress = true;\n+        }\n+      }\n+    }\n+\n+  }\n+}\n+\n+bool PhaseConditionalPropagation::validate_control(Node* n, Node* c) {\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(n);\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* node = wq.at(i);\n+    assert(!node->is_CFG(), \"\");\n+    for (DUIterator_Fast jmax, j = node->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = node->fast_out(j);\n+      if (!_phase->has_node(u)) {\n+        continue;\n+      }\n+      if (u->is_CFG()) {\n+        if (_phase->is_dominator(u, c) || _phase->is_dominator(c, u)) {\n+          return true;\n+        }\n+      } else if (u->is_Phi()) {\n+        for (uint k = 1; k < u->req(); k++) {\n+          if (u->in(k) == node && (_phase->is_dominator(u->in(0)->in(k), c) || _phase->is_dominator(c, u->in(0)->in(k)))) {\n+            return true;\n+          }\n+        }\n+      } else {\n+        wq.push(u);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool PhaseConditionalPropagation::is_safe_for_replacement(Node* c, Node* node, Node* use) {\n+  \/\/ if the exit test of a counted loop doesn't constant fold, preserve the shape of the exit test\n+  Node* node_c = _phase->get_ctrl(node);\n+  IdealLoopTree* loop = _phase->get_loop(node_c);\n+  Node* head = loop->_head;\n+  if (head->is_BaseCountedLoop()) {\n+    BaseCountedLoopNode* cl = head->as_BaseCountedLoop();\n+    Node* cmp = cl->loopexit()->cmp_node();\n+    if (((node == cl->phi() && use == cl->incr()) ||\n+         (node == cl->incr() && use == cmp))) {\n+      const Type* cmp_t = find_type_between(cmp, cl->loopexit(), c);\n+      if (cmp_t == nullptr || !cmp_t->singleton()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+\/*\n+ With the following code snippet:\n+ if (i - 1) > 0) {\n+    \/\/ i - 1 in [1, max]\n+   if (i == 0) {\n+     \/\/ i - 1 is both -1 and [1, max] so top\n+\n+ The second if is redundant but first if updates the type of i-1, not i alone, we can't tell i != 0.\n+ Because i-1 becomes top in the second if branch, we can tell that branch is dead\n+ *\/\n+bool PhaseConditionalPropagation::transform_when_top_seen(Node* c, Node* node, const Type* t) {\n+  if (t->singleton()) {\n+    if (node->is_CFG()) {\n+      return false;\n+    }\n+    if (t == Type::TOP) {\n+#ifdef ASSERT\n+      if (PrintLoopConditionalPropagation) {\n+        tty->print(\"top at %d\", c->_idx);\n+        node->dump();\n+      }\n+#endif\n+      if (c->is_IfProj()) {\n+        \/\/ make sure the node has some use that dominates or are dominated by the current control\n+        if (!validate_control(node, c)) {\n+          return false;\n+        }\n+        Node* iff = c->in(0);\n+        if (iff->in(0)->is_top()) {\n+          return false;\n+        }\n+        Node* bol = iff->in(1);\n+        const Type* bol_t = bol->bottom_type();\n+        const Type* new_bol_t = TypeInt::make(1 - c->as_IfProj()->_con);\n+        if (bol_t != new_bol_t) {\n+          assert((c->is_IfProj() && _conditions.test(c->_idx)), \"\");\n+          if (bol_t->is_int()->is_con() && bol_t->is_int()->get_con() != new_bol_t->is_int()->get_con()) {\n+            \/\/ undetected dead path\n+            Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+            \/\/ can't use register_new_node here\n+            register_new_node_with_optimizer(frame);\n+            _phase->set_ctrl(frame, C->start());\n+            Node* halt = new HaltNode(iff->in(0), frame, \"dead path discovered by PhaseConditionalPropagation\");\n+            add_input_to(C->root(), halt);\n+            \/\/ can't use register_control here\n+            register_new_node_with_optimizer(halt);\n+            _phase->set_loop(halt, _phase->ltree_root());\n+            _phase->set_idom(halt, iff->in(0), _phase->dom_depth(iff->in(0))+1);\n+            replace_input_of(iff, 0, C->top());\n+          } else {\n+            Node* con = makecon(new_bol_t);\n+            _phase->set_ctrl(con, C->root());\n+            rehash_node_delayed(iff);\n+            iff->set_req_X(1, con, this);\n+          }\n+          _phase->C->set_major_progress();\n+#ifdef ASSERT\n+          if (PrintLoopConditionalPropagation) {\n+            tty->print_cr(\"killing path\");\n+            node->dump();\n+            bol_t->dump();\n+            tty->cr();\n+            new_bol_t->dump();\n+            tty->cr();\n+            c->dump();\n+          }\n+#endif\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool PhaseConditionalPropagation::transform_when_constant_seen(Node* c, Node* node, const Type* t, const Type* prev_t) {\n+  if (t->singleton()) {\n+    if (node->is_CFG()) {\n+      return false;\n+    }\n+    {\n+      Node* con = nullptr;\n+      bool progress = false;\n+      assert(_wq2.size() == 0, \"\");\n+      for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+        Node* use = node->fast_out(i);\n+        if (_wq2.member(use)) {\n+          continue;\n+        }\n+        _wq2.push(use);\n+        if (use->is_Phi()) {\n+          Node* r = use->in(0);\n+          if (r->Opcode() == Op_Region && r->req() == 3 &&\n+              ((r->in(1)->is_IfProj() && r->in(1)->in(0)->is_CountedLoopEnd() &&\n+                r->in(1)->in(0)->as_CountedLoopEnd()->loopnode() != nullptr &&\n+                r->in(1)->in(0)->as_CountedLoopEnd()->loopnode()->is_main_loop()) ||\n+               (r->in(2)->is_IfProj() && r->in(2)->in(0)->is_CountedLoopEnd() &&\n+                r->in(2)->in(0)->as_CountedLoopEnd()->loopnode() != nullptr &&\n+                r->in(2)->in(0)->as_CountedLoopEnd()->loopnode()->is_main_loop()))) {\n+            \/\/ Bounds of main loop may be adjusted. Can't constant fold.\n+            continue;\n+          }\n+          int nb_deleted = 0;\n+          for (uint j = 1; j < use->req(); ++j) {\n+            if (use->in(j) == node && _phase->is_dominator(c, r->in(j)) &&\n+                is_safe_for_replacement_at_phi(node, use, r, j)) {\n+              progress = true;\n+              if (con == NULL) {\n+                con = makecon(t);\n+                _phase->set_ctrl(con, C->root());\n+              }\n+              replace_input_of(use, j, con);\n+              nb_deleted++;\n+#ifdef ASSERT\n+              if (PrintLoopConditionalPropagation) {\n+                tty->print_cr(\"constant folding\");\n+                node->dump();\n+                tty->print(\"input %d of \", j); use->dump();\n+                prev_t->dump();\n+                tty->cr();\n+                t->dump();\n+                tty->cr();\n+              }\n+#endif\n+            }\n+          }\n+          if (nb_deleted > 0) {\n+            --i;\n+            imax -= nb_deleted;\n+          }\n+        } else if (_phase->is_dominator(c, _phase->ctrl_or_self(use)) && is_safe_for_replacement(c, node, use)) {\n+          progress = true;\n+          if (con == nullptr) {\n+            con = makecon(t);\n+            _phase->set_ctrl(con, C->root());\n+          }\n+          rehash_node_delayed(use);\n+          int nb = use->replace_edge(node, con, this);\n+          _worklist.push(use);\n+          --i, imax -= nb;\n+#ifdef ASSERT\n+          if (PrintLoopConditionalPropagation) {\n+            tty->print_cr(\"constant folding\");\n+            node->dump();\n+            use->dump();\n+            prev_t->dump();\n+            tty->cr();\n+            t->dump();\n+            tty->cr();\n+          }\n+#endif\n+          if (use->is_If()) {\n+            _phase->C->set_major_progress();\n+          }\n+        }\n+      }\n+      while (_wq2.size() != 0) {\n+        _wq2.pop();\n+      }\n+      return progress;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ We don't want to constant fold only the iv incr if the cmp doesn't constant fold as well\n+bool PhaseConditionalPropagation::is_safe_for_replacement_at_phi(Node* node, Node* use, Node* r, uint j) const {\n+  if (!(r->is_BaseCountedLoop() &&\n+        j == LoopNode::LoopBackControl &&\n+        use == r->as_BaseCountedLoop()->phi() &&\n+        node == r->as_BaseCountedLoop()->incr())) {\n+    return false;\n+  }\n+  const Type* cmp_type = find_type_between(r->as_BaseCountedLoop()->loopexit()->cmp_node(),\n+                                           r->as_BaseCountedLoop()->loopexit(), r);\n+  return cmp_type != nullptr && cmp_type->singleton();\n+}\n+\n+bool PhaseConditionalPropagation::transform_helper(Node* c) {\n+  bool progress = false;\n+  {\n+    TypeUpdate* updates = updates_at(c);\n+    if (updates != nullptr && updates->control() == c) {\n+      for (int i = 0; i < updates->length(); ++i) {\n+        Node* node = updates->node_at(i);\n+        const Type* t = updates->type_at(i);\n+        if (transform_when_top_seen(c, node, t)) {\n+          progress = true;\n+        }\n+      }\n+    }\n+  }\n+\n+  {\n+    TypeUpdate* updates = updates_at(c);\n+    if (updates != nullptr && updates->control() == c) {\n+      for (int i = 0; i < updates->length(); ++i) {\n+        Node* node = updates->node_at(i);\n+        const Type* t = updates->type_at(i);\n+        const Type* prev_t = updates->prev_type_at(i);\n+        if (transform_when_constant_seen(c, node, t, prev_t)) {\n+          progress = true;\n+        }\n+      }\n+    }\n+  }\n+\n+  if (c->is_IfProj()) {\n+    IfNode* iff = c->in(0)->as_If();\n+    if (!iff->in(0)->is_top()) {\n+      const TypeInt* bol_t = iff->in(1)->bottom_type()->is_int();\n+      if (bol_t->is_con()) {\n+        if (iff->proj_out(bol_t->get_con()) == c) {\n+          _wq.push(c);\n+          assert(!(updates_at(c) != nullptr && updates_at(c)->type_if_present(c) == Type::TOP), \"\");\n+        }\n+      } else {\n+        _wq.push(c);\n+      }\n+    }\n+  } else {\n+    _wq.push(c);\n+  }\n+\n+  return progress;\n+}\n+\n+const Type* PhaseConditionalPropagation::type(const Node* n, Node* c) const {\n+  if (_current_ctrl == C->root()) {\n+    return PhaseValues::type(n);\n+  }\n+  assert(c->is_CFG(), \"\");\n+  const Type* res = nullptr;\n+  assert(_current_ctrl->is_Region() && _current_ctrl->find_edge(c) != -1, \"\");\n+  Node* dom = _phase->idom(_current_ctrl);\n+  TypeUpdate* updates = updates_at(c);\n+  TypeUpdate* dom_updates = updates_at(dom);\n+  assert(updates != nullptr || dom_updates == nullptr || _phase->is_dominator(_current_ctrl, c) || C->has_irreducible_loop(), \"\");\n+  while (updates != nullptr && updates->below(dom_updates, _phase)) {\n+    int idx = updates->find(n);\n+    if (idx != -1) {\n+      res = updates->type_at(idx);\n+      break;\n+    }\n+    updates = updates->prev();\n+    assert(updates != nullptr || dom_updates == nullptr || _phase->is_dominator(_current_ctrl, c) || C->has_irreducible_loop(), \"\");\n+  }\n+  if (res == nullptr) {\n+    res = PhaseValues::type(n);\n+  }\n+  return res;\n+}\n+\n+PhaseConditionalPropagation::PhaseConditionalPropagation(PhaseIdealLoop* phase, VectorSet& visited, Node_Stack& nstack,\n+                                                         Node_List& rpo_list)\n+        : PhaseIterGVN(&phase->igvn()),\n+          _updates(nullptr),\n+          _phase(phase),\n+          _visited(visited),\n+          _rpo_list(rpo_list),\n+          _current_ctrl(phase->C->root()),\n+          _progress(true),\n+          _iterations(0),\n+          _current_updates(nullptr),\n+          _dom_updates(nullptr),\n+          _prev_updates(nullptr) {\n+  assert(nstack.is_empty(), \"\");\n+  assert(_rpo_list.size() == 0, \"\");\n+  phase->rpo(C->root(), nstack, _visited, _rpo_list);\n+  int shift = 0;\n+  for (uint i = 0; i < _rpo_list.size(); ++i) {\n+    Node* n = _rpo_list.at(i);\n+    if (n->is_MultiBranch()) {\n+      \/\/ no type update at non projections.\n+      shift++;\n+    } else if (shift > 0) {\n+      _rpo_list.map(i - shift, n);\n+    }\n+  }\n+  while (shift > 0) {\n+    shift--;\n+    _rpo_list.pop();\n+  }\n+  Node* root = _rpo_list.pop();\n+  assert(root == C->root(), \"\");\n+  _updates = new Updates(8, _rpo_list.size());\n+}\n+\n+void PhaseIdealLoop::conditional_elimination(VectorSet& visited, Node_Stack& nstack, Node_List& rpo_list, int rounds) {\n+  TraceTime tt(\"loop conditional propagation\", UseNewCode);\n+  PhaseConditionalPropagation pcp(this, visited, nstack, rpo_list);\n+  pcp.analyze(rounds);\n+  pcp.do_transform();\n+  _igvn.reset_from_igvn(&pcp);\n+}\n","filename":"src\/hotspot\/share\/opto\/loopConditionalPropagation.cpp","additions":1213,"deletions":0,"binary":false,"changes":1213,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n+#define SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n+\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+\n+class PhaseConditionalPropagation : public PhaseIterGVN {\n+private:\n+\n+  class TypeUpdate : public ResourceObj {\n+  private:\n+    class Entry {\n+    public:\n+      Entry(const Node* node, const Type* before, const Type* after)\n+              : _node(node), _before(before), _after(after) {\n+      }\n+      Entry()\n+              : _node(nullptr), _before(nullptr), _after(nullptr) {\n+      }\n+\n+      const Node* _node;\n+      const Type* _before;\n+      const Type* _after;\n+    };\n+    GrowableArray<Entry> _updates;\n+    TypeUpdate* _prev;\n+    Node* _control;\n+\n+    TypeUpdate(TypeUpdate* prev, Node* control, int size)\n+            : _updates(size), _prev(prev), _control(control) {\n+    }\n+\n+  public:\n+\n+    TypeUpdate(TypeUpdate* prev, Node* control)\n+            : _prev(prev), _control(control) {\n+    }\n+\n+    int length() const {\n+      return _updates.length();\n+    }\n+\n+    Node* node_at(int i) const {\n+      return const_cast<Node*>(_updates.at(i)._node);\n+    }\n+\n+    const Type* prev_type_at(int i) const {\n+      return _updates.at(i)._before;\n+    }\n+\n+    const Type* type_at(int i) const {\n+      return _updates.at(i)._after;\n+    }\n+\n+    const Type* type_if_present(Node* n) {\n+      int i = find(n);\n+      if (i == -1) {\n+        return nullptr;\n+      }\n+      return _updates.at(i)._after;\n+    }\n+\n+\n+    void set_type_at(int i, const Type* t) {\n+      _updates.at(i)._after = t;\n+    }\n+\n+    void set_prev_type_at(int i, const Type* t) {\n+      _updates.at(i)._before = t;\n+    }\n+\n+    bool contains(Node* n) {\n+      return find(n) != -1;\n+    }\n+\n+    void remove_at(int i) {\n+      _updates.remove_at(i);\n+    }\n+\n+    static int compare1(const Node* const& n, const Entry& e) {\n+      return  n->_idx - e._node->_idx;\n+    }\n+\n+    static int compare2(const Entry& e1, const Entry& e2) {\n+      return e1._node->_idx - e2._node->_idx;\n+    }\n+\n+    int find(const Node* n) {\n+      bool found = false;\n+      int res = _updates.find_sorted<const Node*, compare1>(n, found);\n+      if (!found) {\n+        return -1;\n+      }\n+      return res;\n+    }\n+\n+    void push_node(const Node* node, const Type* old_t, const Type* new_t) {\n+      _updates.insert_sorted<compare2>(Entry(node, old_t, new_t));\n+      assert(find(node) != -1 && _updates.at(find(node))._node == node, \"\");\n+    }\n+\n+    TypeUpdate* prev() const {\n+      return _prev;\n+    }\n+\n+    bool below(TypeUpdate* dom_updates, PhaseIdealLoop* phase) const {\n+      return this != dom_updates && (dom_updates == nullptr || !phase->is_dominator(control(), dom_updates->control()));\n+    }\n+\n+    void set_prev(TypeUpdate* prev) {\n+      _prev = prev;\n+    }\n+\n+    Node* control() const {\n+      return _control;\n+    }\n+\n+    TypeUpdate* copy() const {\n+      TypeUpdate* c = new TypeUpdate(_prev, _control, _updates.length());\n+      for (int i = 0; i < _updates.length(); ++i) {\n+        c->_updates.push(_updates.at(i));\n+      }\n+      return c;\n+    }\n+  };\n+\n+  using Updates = ResizeableResourceHashtable<Node*, TypeUpdate*, AnyObj::RESOURCE_AREA, mtInternal>;\n+  Updates* _updates;\n+\n+  bool related_use(Node* u, Node* c);\n+\n+  void enqueue_uses(const Node* n, Node* c);\n+\n+  void set_type(const Node* n, const Type* t, const Type* old_t) {\n+    record_update(_current_ctrl, n, old_t, t);\n+    PhaseValues::set_type(n, t);\n+  }\n+\n+  GrowableArray<TypeUpdate*> _stack;\n+\n+  void sync(Node* c);\n+\n+  PhaseIdealLoop* _phase;\n+  VectorSet& _visited;\n+  VectorSet _control_dependent_node[2];\n+  Node_List& _rpo_list;\n+  Node* _current_ctrl;\n+#ifdef ASSERT\n+  VectorSet _conditions;\n+#endif\n+  Unique_Node_List _wq;\n+  Unique_Node_List _wq2;\n+\n+  bool _progress;\n+  int _iterations;\n+\n+public:\n+  PhaseConditionalPropagation(PhaseIdealLoop* phase, VectorSet &visited, Node_Stack &nstack, Node_List &rpo_list);\n+\n+  Node* known_updates(Node* c) const {\n+    return _phase->find_non_split_ctrl(c);\n+  }\n+\n+  void analyze(int rounds);\n+\n+  static const int load_factor = 8;\n+\n+  bool one_iteration(Node* c, bool& extra, bool& extra2, bool verify);\n+\n+  void analyze_allocate_array(Node* c, const AllocateArrayNode* alloc);\n+\n+  TypeUpdate* updates_at(Node* c) const {\n+    TypeUpdate** updates_ptr = _updates->get(known_updates(c));\n+    if (updates_ptr == nullptr) {\n+      return nullptr;\n+    }\n+    return *updates_ptr;\n+  }\n+\n+  const Type* type_if_present(Node* c, Node* n) const {\n+    TypeUpdate* updates = updates_at(c);\n+    if (updates == nullptr) {\n+      return nullptr;\n+    }\n+    return updates->type_if_present(n);\n+  }\n+\n+\n+  const Type* find_type_between(Node* n, Node* c, Node* dom) const;\n+\n+  const Type* find_prev_type_between(Node* n, Node* c, Node* dom) const;\n+\n+  bool record_update(Node* c, const Node* n, const Type* old_t, const Type* new_t);\n+\n+  void analyze_if(Node* c, const Node* cmp, Node* n);\n+\n+#ifdef ASSERT\n+  bool narrows_type(const Type* old_t, const Type* new_t);\n+#endif\n+\n+  void do_transform();\n+\n+  bool validate_control(Node* n, Node* c);\n+\n+  bool is_safe_for_replacement(Node* c, Node* node, Node* use);\n+\n+  bool transform_when_top_seen(Node* c, Node* node, const Type* t);\n+\n+  bool transform_when_constant_seen(Node* c, Node* node, const Type* t, const Type* prev_t);\n+\n+  bool is_safe_for_replacement_at_phi(Node* node, Node* use, Node* r, uint j) const;\n+\n+  bool transform_helper(Node* c);\n+\n+  const Type* type(const Node* n, Node* c) const;\n+\n+  virtual PhaseConditionalPropagation* is_ConditionalPropagation() { return this; }\n+\n+  TypeUpdate* _current_updates;\n+  TypeUpdate* _dom_updates;\n+  TypeUpdate* _prev_updates;\n+\n+  void adjust_updates(Node* c, bool verify);\n+\n+  void mark_if(IfNode* iff, Node* c);\n+\n+  void mark_if_from_cmp(const Node* u, Node* c);\n+};\n+\n+#endif \/\/ SHARE_OPTO_LOOPCONDITIONALPROPAGATION_HPP\n","filename":"src\/hotspot\/share\/opto\/loopConditionalPropagation.hpp","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -583,1 +583,1 @@\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, output_proj);\n+  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, output_proj->in(0)->in(0));\n@@ -1372,1 +1372,1 @@\n-  if (invar.is_invariant(bol)) {\n+  if (invar.is_invariant(bol) && is_dominator(get_ctrl(bol), parse_predicate_proj)) {\n@@ -1516,2 +1516,2 @@\n-  max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-  register_new_node(max_value, predicate_proj);\n+  max_value = new CastIINode(new_proj, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+  register_new_node(max_value, new_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1279,1 +1279,1 @@\n-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n+Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n@@ -1285,1 +1285,1 @@\n-    if (n->is_Phi() && n->in(0) == loop) {\n+    if (n->is_Phi() && n->in(0) == loop && loop->phi() == n) {\n@@ -1290,0 +1290,1 @@\n+  ShouldNotReachHere();\n@@ -1547,0 +1548,3 @@\n+          if (next->Opcode() == Op_CastII) {\n+            next->set_req(0, control);\n+          }\n@@ -2501,1 +2505,3 @@\n-void PhaseIdealLoop::add_constraint(jlong stride_con, jlong scale_con, Node* offset, Node* low_limit, Node* upper_limit, Node* pre_ctrl, Node** pre_limit, Node** main_limit) {\n+void PhaseIdealLoop::add_constraint(IdealLoopTree* loop, jlong stride_con, jlong scale_con, Node* offset, Node* low_limit,\n+                                    Node* upper_limit,\n+                                    Node* pre_ctrl, Node** pre_limit, Node** main_limit, Node*& predicate_proj) {\n@@ -2570,0 +2576,29 @@\n+\n+  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n+  Node* init = cl->init_trip();\n+\n+  \/\/ predicate on first value of first iteration\n+  predicate_proj = add_range_check_elimination_assertion_predicate(loop, predicate_proj, scale, offset,\n+                                             low_limit, upper_limit, init);\n+  assert(!assertion_predicate_has_loop_opaque_node(predicate_proj->in(0)->as_If()), \"unexpected\");\n+\n+  Node* opaque_init = new OpaqueLoopInitNode(C, init);\n+  register_new_node(opaque_init, predicate_proj);\n+\n+  \/\/ template predicate so it can be updated on next unrolling\n+  predicate_proj = add_range_check_elimination_assertion_predicate(loop, predicate_proj, scale, offset, low_limit, upper_limit,\n+                                             opaque_init);\n+  assert(assertion_predicate_has_loop_opaque_node(predicate_proj->in(0)->as_If()), \"unexpected\");\n+\n+  Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n+  register_new_node(opaque_stride, predicate_proj);\n+  Node* max_value = new SubINode(opaque_stride, cl->stride());\n+  register_new_node(max_value, predicate_proj);\n+  max_value = new AddINode(opaque_init, max_value);\n+  register_new_node(max_value, predicate_proj);\n+  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n+  max_value = new CastIINode(predicate_proj,max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n+  register_new_node(max_value, predicate_proj);\n+  predicate_proj = add_range_check_elimination_assertion_predicate(loop, predicate_proj, scale, offset, low_limit, upper_limit,\n+                                             max_value);\n+  assert(assertion_predicate_has_loop_opaque_node(predicate_proj->in(0)->as_If()), \"unexpected\");\n@@ -2856,2 +2891,2 @@\n-                                                                      Node* ctrl, const int scale_con,\n-                                                                      Node* offset, Node* limit, jint stride_con,\n+                                                                      Node* ctrl, Node* scale,\n+                                                                      Node* offset, Node* low_limit, Node* upper_limit,\n@@ -2859,3 +2894,19 @@\n-  bool overflow = false;\n-  BoolNode* bol = rc_predicate(loop, ctrl, scale_con, offset, value, nullptr, stride_con,\n-                               limit, (stride_con > 0) != (scale_con > 0), overflow);\n+  Node* range = new SubLNode(upper_limit, low_limit);\n+  register_new_node(range, ctrl);\n+\n+  Node* max_idx_expr = new ConvI2LNode(value);\n+  register_new_node(max_idx_expr, ctrl);\n+\n+  max_idx_expr = new MulLNode(max_idx_expr, scale);\n+  register_new_node(max_idx_expr, ctrl);\n+\n+  max_idx_expr = new AddLNode(max_idx_expr, offset);\n+  register_new_node(max_idx_expr, ctrl);\n+  max_idx_expr = new SubLNode(max_idx_expr, low_limit);\n+  register_new_node(max_idx_expr, ctrl);\n+\n+  CmpNode* cmp = new CmpULNode(max_idx_expr, range);\n+  register_new_node(cmp, ctrl);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::lt);\n+  register_new_node(bol, ctrl);\n+\n@@ -2864,6 +2915,1 @@\n-  IfNode* new_iff = nullptr;\n-  if (overflow) {\n-    new_iff = new IfNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n-  } else {\n-    new_iff = new RangeCheckNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n-  }\n+  IfNode* new_iff = new IfNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n@@ -3056,29 +3102,2 @@\n-          add_constraint(stride_con, lscale_con, offset, zero, limit, pre_ctrl, &pre_limit, &main_limit);\n-          Node* init = cl->init_trip();\n-          Node* opaque_init = new OpaqueLoopInitNode(C, init);\n-          register_new_node(opaque_init, loop_entry);\n-\n-          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, init);\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n-\n-          \/\/ Add two Template Assertion Predicates to create new Initialized Assertion Predicates from when either\n-          \/\/ unrolling or splitting this main-loop further.\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, opaque_init);\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n-\n-          Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n-          register_new_node(opaque_stride, loop_entry);\n-          Node* max_value = new SubINode(opaque_stride, cl->stride());\n-          register_new_node(max_value, loop_entry);\n-          max_value = new AddINode(opaque_init, max_value);\n-          register_new_node(max_value, loop_entry);\n-          \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-          max_value = new CastIINode(max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-          register_new_node(max_value, loop_entry);\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, max_value);\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n-\n+          add_constraint(loop, stride_con, lscale_con, offset, zero, limit, pre_ctrl, &pre_limit, &main_limit,\n+                         loop_entry);\n@@ -3114,1 +3133,1 @@\n-          add_constraint(stride_con, lscale_con, offset, mini, limit, pre_ctrl, &pre_limit, &main_limit);\n+          add_constraint(loop, stride_con, lscale_con, offset, mini, limit, pre_ctrl, &pre_limit, &main_limit, loop_entry);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -794,0 +794,5 @@\n+\n+  if (head->phi() == nullptr) {\n+    return false;\n+  }\n+\n@@ -921,1 +926,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::make(0, max_signed_integer(bt), Type::WidenMin, bt), _igvn);\n@@ -923,1 +928,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::make(0, max_signed_integer(bt), Type::WidenMin, bt), _igvn);\n@@ -3098,2 +3103,2 @@\n-        const TypeInt* if_t = IfNode::filtered_int_type(&_igvn, val, pred);\n-        if (if_t != nullptr) {\n+        const Type* if_t = IfNode::filtered_int_type(&_igvn, val, pred, T_INT);\n+        if (if_t != nullptr && if_t->isa_int()) {\n@@ -3101,1 +3106,1 @@\n-            rtn_t = if_t;\n+            rtn_t = if_t->is_int();\n@@ -4002,3 +4007,5 @@\n-    int stride_con  = cl->stride_con();\n-    if (stride_con > 0) tty->print(\"+\");\n-    tty->print(\"%d\", stride_con);\n+    if (cl->stride() != nullptr) {\n+      int stride_con  = cl->stride_con();\n+      if (stride_con > 0) tty->print(\"+\");\n+      tty->print(\"%d\", stride_con);\n+    }\n@@ -4584,0 +4591,6 @@\n+  if (!C->major_progress() && UseLoopConditionalPropagation) {\n+    visited.clear();\n+    int rounds = max_jint;\n+    conditional_elimination(visited, nstack, worklist, rounds);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -932,12 +932,1 @@\n-  \/\/ Helper function for directing control inputs away from CFG split points.\n-  Node *find_non_split_ctrl( Node *ctrl ) const {\n-    if (ctrl != nullptr) {\n-      if (ctrl->is_MultiBranch()) {\n-        ctrl = ctrl->in(0);\n-      }\n-      assert(ctrl->is_CFG(), \"CFG\");\n-    }\n-    return ctrl;\n-  }\n-\n-  Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);\n+  Node* cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop);\n@@ -1079,0 +1068,11 @@\n+  \/\/ Helper function for directing control inputs away from CFG split points.\n+  Node *find_non_split_ctrl( Node *ctrl ) const {\n+    if (ctrl != nullptr) {\n+      if (ctrl->is_MultiBranch()) {\n+        ctrl = ctrl->in(0);\n+      }\n+      assert(ctrl->is_CFG(), \"CFG\");\n+    }\n+    return ctrl;\n+  }\n+\n@@ -1384,2 +1384,2 @@\n-  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, int scale_con,\n-                                                        Node* offset, Node* limit, jint stride_con, Node* value);\n+  Node* add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* predicate_proj, Node* scale,\n+                                                        Node* offset, Node* low_limit, Node* upper_limit, Node* value);\n@@ -1444,1 +1444,3 @@\n-  void add_constraint(jlong stride_con, jlong scale_con, Node* offset, Node* low_limit, Node* upper_limit, Node* pre_ctrl, Node** pre_limit, Node** main_limit);\n+  void add_constraint(IdealLoopTree* loop, jlong stride_con, jlong scale_con, Node* offset, Node* low_limit,\n+                      Node* upper_limit,\n+                      Node* pre_ctrl, Node** pre_limit, Node** main_limit, Node*& predicate_proj);\n@@ -1740,0 +1742,1 @@\n+  void conditional_elimination(VectorSet& visited, Node_Stack& nstack, Node_List& rpo_list, int rounds);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) {\n+  if ((n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) ||\n+      (n->Opcode() == Op_ConvL2I && n->bottom_type() != TypeInt::INT)){\n@@ -1591,0 +1592,3 @@\n+  bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n+                            n->in(1)->bottom_type()->isa_rawptr() &&\n+                            !n->bottom_type()->isa_rawptr();\n@@ -1597,2 +1601,2 @@\n-      n->Opcode() != Op_Opaque4 &&\n-      !n->is_Type()) {\n+      !is_raw_to_oop_cast && \/\/ don't extend live ranges of raw oops\n+      n->Opcode() != Op_Opaque4) {\n@@ -2332,1 +2336,5 @@\n-      set_ctrl(n, new_ctrl);\n+      if (is_member(outer_loop, get_ctrl(n))) {\n+        set_ctrl(n, new_ctrl);\n+      } else {\n+        assert(n->in(0) == inner_out, \"\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -166,0 +166,7 @@\n+  if (phase->type(in(Condition)) == TypeInt::ZERO) {\n+    return phase->type(in(IfFalse))->filter(_type); \/\/ Always pick left(false) input\n+  }\n+  if (phase->type(in(Condition)) == TypeInt::ONE) {\n+    return phase->type(in(IfTrue))->filter(_type);  \/\/ Always pick right(true) input\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -129,0 +129,7 @@\n+\n+const Type* OpaqueZeroTripGuardNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(1)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return bottom_type();\n+}\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -813,0 +814,5 @@\n+#ifndef PRODUCT\n+  memcpy(_verify_window, igvn->_verify_window, sizeof(_verify_window));\n+  _verify_counter = igvn->_verify_counter;\n+  _verify_full_passes = igvn->_verify_full_passes;\n+#endif\n@@ -1450,21 +1456,0 @@\n-\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n-\/\/ compares the induction variable with n\n-static PhiNode* countedloop_phi_from_cmp(CmpNode* cmp, Node* n) {\n-  for (DUIterator_Fast imax, i = cmp->fast_outs(imax); i < imax; i++) {\n-    Node* bol = cmp->fast_out(i);\n-    for (DUIterator_Fast i2max, i2 = bol->fast_outs(i2max); i2 < i2max; i2++) {\n-      Node* iff = bol->fast_out(i2);\n-      if (iff->is_BaseCountedLoopEnd()) {\n-        BaseCountedLoopEndNode* cle = iff->as_BaseCountedLoopEnd();\n-        if (cle->limit() == n) {\n-          PhiNode* phi = cle->phi();\n-          if (phi != nullptr) {\n-            return phi;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1515,1 +1500,1 @@\n-        Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n+        Node* phi = use->as_Cmp()->countedloop_phi(n);\n@@ -1689,0 +1674,11 @@\n+    if (use->is_Opaque1() && use->as_Opaque1()->original_loop_limit() == n) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_CmpI || u->Opcode() == Op_CmpL) {\n+          Node* phi = u->as_Cmp()->countedloop_phi(use);\n+          if (phi != nullptr) {\n+            _worklist.push(phi);\n+          }\n+        }\n+      }\n+    }\n@@ -1879,0 +1875,1 @@\n+  push_opaque_orig_limit(worklist, parent, use);\n@@ -1926,1 +1923,1 @@\n-void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use) {\n+void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, const Node* parent, const Node* use) {\n@@ -1929,1 +1926,1 @@\n-    PhiNode* phi = countedloop_phi_from_cmp(use->as_Cmp(), parent);\n+    PhiNode* phi = use->as_Cmp()->countedloop_phi(parent);\n@@ -2006,0 +2003,8 @@\n+void PhaseCCP::push_opaque_orig_limit(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+  if (use->is_Opaque1() && use->as_Opaque1()->original_loop_limit() == parent) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      push_counted_loop_phi(worklist, use, use->fast_out(i));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -289,0 +289,4 @@\n+\n+  virtual const Type* type(const Node* n, Node* c) const {\n+    return type(n);\n+  }\n@@ -409,1 +413,1 @@\n-\n+class PhaseConditionalPropagation;\n@@ -435,0 +439,1 @@\n+  virtual PhaseConditionalPropagation* is_ConditionalPropagation() { return nullptr; }\n@@ -623,1 +628,1 @@\n-  static void push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use);\n+  static void push_counted_loop_phi(Unique_Node_List& worklist, const Node* parent, const Node* use);\n@@ -629,0 +634,1 @@\n+  void push_opaque_orig_limit(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -642,0 +642,21 @@\n+\/\/ Return counted loop Phi if as a counted loop exit condition, cmp\n+\/\/ compares the induction variable with n\n+PhiNode* CmpNode::countedloop_phi(const Node* n) const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* bol = fast_out(i);\n+    for (DUIterator_Fast i2max, i2 = bol->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* iff = bol->fast_out(i2);\n+      if (iff->is_BaseCountedLoopEnd()) {\n+        BaseCountedLoopEndNode* cle = iff->as_BaseCountedLoopEnd();\n+        if (cle->limit() == n) {\n+          PhiNode* phi = cle->phi();\n+          if (phi != nullptr) {\n+            return phi;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -841,0 +862,13 @@\n+      } else if (underflow && overflow) {\n+        bool lo_overflow = lo_long > (jlong)max_jint;\n+        bool lo_underflow = lo_long < (jlong)min_jint;\n+        bool hi_overflow = hi_long > (jlong)max_jint;\n+        bool hi_underflow = hi_long < (jlong)min_jint;\n+\n+        if ((lo_overflow && hi_overflow) || (lo_underflow && hi_underflow)) {\n+          assert(lo_tr2 <= hi_tr1, \"\");\n+          int w = MAX2(r0->_widen, r1->_widen); \/\/ _widen does not matter here\n+          const TypeInt* tr = TypeInt::make(lo_tr2, hi_tr1, w);\n+          const TypeInt* cmp2 = sub(tr, t2)->is_int();\n+          return t_sub->filter(cmp2);\n+        }\n@@ -1836,0 +1870,79 @@\n+const Type* BoolNode::filtered_int_type(const PhaseValues* phase, const Node* val, BasicType bt, bool taken) const {\n+  if (in(1) && in(1)->is_Cmp()) {\n+    const CmpNode* cmp = in(1)->as_Cmp();\n+    if (cmp->in(1) == val || cmp->in(2) == val) {\n+      const Type* other_t = phase->type(cmp->in(1) == val ? cmp->in(2) : cmp->in(1));\n+      if (other_t == Type::TOP) {\n+        return Type::TOP;\n+      }\n+      const TypeInteger* other_int_t = other_t->is_integer(bt);\n+      jlong lo = other_int_t->lo_as_long();\n+      jlong hi = other_int_t->hi_as_long();\n+      assert(hi >= lo, \"\");\n+      BoolTest test = _test;\n+      if (cmp->in(2) == val) {\n+        test = test.commute();\n+      }\n+      BoolTest::mask msk = taken ? test._test : test.negate();\n+\n+      if (cmp->Opcode() == Op_Cmp_unsigned(bt)) {\n+        if (lo >= 0 && (msk == BoolTest::lt || msk == BoolTest::le)) {\n+          lo = 0;\n+          if (msk == BoolTest::lt) {\n+            hi = hi - 1;\n+          }\n+          return TypeInteger::make(lo, hi, other_int_t->_widen, bt);\n+        }\n+      } else {\n+        assert(cmp->Opcode() == Op_Cmp(bt), \"\");\n+        switch (msk) {\n+          case BoolTest::ne: {\n+            \/\/ If val is compared to its lower or upper bound, we can narrow the type\n+            const TypeInteger* val_t = phase->type(val)->isa_integer(bt);\n+            if (val_t != nullptr && other_int_t->is_con()) {\n+              if (val_t->singleton()) {\n+                if (val_t->lo_as_long() == lo) {\n+                  return Type::TOP;\n+                }\n+              } else {\n+                if (val_t->lo_as_long() == lo) {\n+                  return TypeInteger::make(val_t->lo_as_long() + 1, val_t->hi_as_long(), val_t->_widen, bt);\n+                } else if (val_t->hi_as_long() == hi) {\n+                  return TypeInteger::make(val_t->lo_as_long(), val_t->hi_as_long() - 1, val_t->_widen, bt);\n+                }\n+              }\n+            }\n+            \/\/ Can't refine type\n+            return nullptr;\n+          }\n+          case BoolTest::eq:\n+            return other_t;\n+          case BoolTest::lt:\n+            lo = TypeInteger::bottom(bt)->lo_as_long();\n+            if (hi != min_signed_integer(bt)) {\n+              hi = hi - 1;\n+            }\n+            break;\n+          case BoolTest::le:\n+            lo = TypeInteger::bottom(bt)->lo_as_long();\n+            break;\n+          case BoolTest::gt:\n+            if (lo != max_signed_integer(bt)) {\n+              lo = lo + 1;\n+            }\n+            hi = TypeInteger::bottom(bt)->hi_as_long();\n+            break;\n+          case BoolTest::ge:\n+            \/\/ lo unchanged\n+            hi = TypeInteger::bottom(bt)->hi_as_long();\n+            break;\n+          default:\n+            break;\n+        }\n+        return TypeInteger::make(lo, hi, other_int_t->_widen, bt);\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  PhiNode* countedloop_phi(const Node* n) const;\n@@ -356,0 +357,2 @@\n+  const Type* filtered_int_type(const PhaseValues* phase, const Node* val, BasicType bt, bool taken) const;\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3142,2 +3142,1 @@\n-          cnt = ConNode::make(TypeInt::make(shift & mask));\n-          _igvn.register_new_node_with_optimizer(cnt);\n+          cnt = _igvn.makecon(TypeInt::make(shift & mask));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1172,0 +1172,1 @@\n+  case Control:\n@@ -2316,1 +2317,1 @@\n-    if (_fields[i]->empty())  return true;\n+    if (!_fields[i]->empty())  return false;\n@@ -2318,1 +2319,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2512,1 +2512,1 @@\n-  Node* operation = gvn().transform(VectorInsertNode::make(opd, insert_val, idx->get_con()));\n+  Node* operation = gvn().transform(VectorInsertNode::make(opd, insert_val, idx->get_con(), gvn()));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1736,1 +1736,1 @@\n-Node* VectorInsertNode::make(Node* vec, Node* new_val, int position) {\n+Node* VectorInsertNode::make(Node* vec, Node* new_val, int position, PhaseGVN& gvn) {\n@@ -1738,1 +1738,1 @@\n-  ConINode* pos = ConINode::make(position);\n+  ConINode* pos = gvn.intcon(position);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1672,1 +1672,1 @@\n-  static Node* make(Node* vec, Node* new_val, int position);\n+  static Node* make(Node* vec, Node* new_val, int position, PhaseGVN& gvn);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,730 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestLoopConditionalPropagation\n+ *\/\n+\n+public class TestLoopConditionalPropagation {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-UseLoopPredicate\", \"-XX:-LoopUnswitching\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private void test1(int i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"3\"})\n+    @Arguments({Argument.NUMBER_42,Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @Warmup(10_000)\n+    private static void test2(int i, boolean flag) {\n+        if (flag) {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @DontInline\n+    private static void notInlined() {\n+\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"2\"})\n+    @Arguments({Argument.NUMBER_42,Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @Warmup(10_000)\n+    private static void test3(int i, boolean flag) {\n+        if (flag) {\n+            if (i < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            i = 100;\n+        }\n+        notInlined();\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    static volatile int volatileField;\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"3\"})\n+    @Arguments({Argument.NUMBER_42,Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test4(int i, int k) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            if (i < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"2\"})\n+    @IR(failOn = {IRNode.ADD_I,IRNode.MUL_I})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static int test5(int i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        notInlined();\n+        if (i > 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return (i + 5) * 100;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"3\"})\n+    @Arguments({Argument.NUMBER_42,Argument.NUMBER_42,Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test6(int i, int j, int k) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (j < i) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (k < j) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (k < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test7(int i) {\n+        if (i < 0 || i >= 43) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < -1) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test8(int i) {\n+        if (i < 0 || i >= 43) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i > 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test9(long i) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test10(int i) {\n+        if (i - 1 <= 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (i == 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"1\"})\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_TRUE, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test11(boolean flag, int i) {\n+        if (i - 1 <= 0) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        if (flag) {\n+            if (i == 0) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        } else {\n+            if (i == 0) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"2\"})\n+    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test12(int i, int j) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        \/\/ i >= 42\n+        if (i > j) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        \/\/ i <= j => j >= 42\n+        if (j < 10) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+    }\n+\n+    static volatile int barrier;\n+    static class C {\n+        float field;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"2\"})\n+    private static int test13(int[] array, int i, C c, boolean flag) {\n+        int dummy = array[0];\n+        int v = 0;\n+        int j = 1;\n+\n+        for (; j < 2; j *= 2);\n+\n+        test13Helper(j, c);\n+\n+        if (flag) {\n+            if (array.length > 42) {\n+                if (i >= 0) {\n+                    if (i <= 42) {\n+                        float f = c.field;\n+                        v = array[i];\n+                    }\n+                }\n+            }\n+        } else {\n+            if (array.length > 42) {\n+                if (i >= 0) {\n+                    if (i <= 42) {\n+                        float f = c.field;\n+                        v = array[i];\n+                    }\n+                }\n+            }\n+        }\n+\n+        return v;\n+    }\n+\n+    @ForceInline\n+    private static void test13Helper(int j, C c) {\n+        if (j == 2) {\n+            float f = c.field;\n+        } else {\n+            barrier = 0x42;\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10_000)\n+    public static void test13_runner() {\n+        C c = new C();\n+        test13Helper(42, c);\n+        test13Helper(2, c);\n+\n+        int[] array1 = new int[100];\n+        int[] array2 = new int[1];\n+        test13(array1, 0, c, true);\n+        test13(array1, 99, c, true);\n+        test13(array2, 0, c, true);\n+        test13(array1, 0, c, false);\n+        test13(array1, 99, c, false);\n+        test13(array2, 0, c, false);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"4\"})\n+    @Arguments({Argument.NUMBER_42,Argument.NUMBER_42,Argument.NUMBER_42})\n+    @Warmup(10_000)\n+    private static void test14(int i, int k, int l) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            \/\/ i >= 42\n+            if (l < i) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            \/\/ l >= 42\n+            if (l < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.IF,\"6\"})\n+    @Arguments({Argument.NUMBER_42,Argument.NUMBER_42,Argument.NUMBER_42,Argument.RANDOM_EACH})\n+    @Warmup(10_000)\n+    private static void test15(int i, int k, int l, boolean flag) {\n+        if (i < 42) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        for (int j = 1; j < 4; j *= 2) {\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            volatileField = 42;\n+            \/\/ i >= 42\n+            if (flag) {\n+                if (l < i) {\n+                    throw new RuntimeException(\"never taken\");\n+                }\n+            } else {\n+                if (l < i) {\n+                    throw new RuntimeException(\"never taken\");\n+                }\n+            }\n+            \/\/ l >= 42\n+            if (l < 10) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            if (k < 42) {\n+                throw new RuntimeException(\"never taken\");\n+            }\n+            i = k;\n+        }\n+    }\n+\n+    \/\/ @Test\n+    \/\/ @IR(counts = { IRNode.CMOVE_I, \"1\" })\n+    \/\/ @IR(failOn = { IRNode.IF })\n+    \/\/ private static int test14(int i) {\n+    \/\/     if (i < 0) {\n+    \/\/         i = 0;\n+    \/\/     }\n+    \/\/     if (i - 1 < -1) {\n+    \/\/         throw new RuntimeException(\"never taken\");\n+    \/\/     }\n+    \/\/     return i;\n+    \/\/ }\n+\n+    \/\/ @Run(test = \"test14\")\n+    \/\/ @Warmup(10_000)\n+    \/\/ public static void test14_runner() {\n+    \/\/     test14(-42);\n+    \/\/     test14(42);\n+    \/\/ }\n+\n+    \/\/ @Test\n+    \/\/ @IR(counts = { IRNode.CMOVE_I, \"1\" })\n+    \/\/ @IR(failOn = { IRNode.IF })\n+    \/\/ private static int test15(int i) {\n+    \/\/     if (i < 0) {\n+    \/\/         i = 0;\n+    \/\/     } else {\n+    \/\/         i = i - 1;\n+    \/\/     }\n+    \/\/     if (i - 1 < -2) {\n+    \/\/         throw new RuntimeException(\"never taken\");\n+    \/\/     }\n+    \/\/     return i;\n+    \/\/ }\n+\n+    \/\/ @Run(test = \"test15\")\n+    \/\/ @Warmup(10_000)\n+    \/\/ public static void test15_runner() {\n+    \/\/     test15(-42);\n+    \/\/     test15(42);\n+    \/\/ }\n+\n+    \/\/ @Test\n+    \/\/ @IR(counts = { IRNode.CMOVE_I, \"1\" })\n+    \/\/ @IR(failOn = { IRNode.IF })\n+    \/\/ private static int test16(int i) {\n+    \/\/     if (i < 0) {\n+    \/\/         i = 0;\n+    \/\/     } else {\n+    \/\/         i = i \/ 13 * 11;\n+    \/\/     }\n+    \/\/     if (i - 1 < -1) {\n+    \/\/         throw new RuntimeException(\"never taken\");\n+    \/\/     }\n+    \/\/     return i;\n+    \/\/ }\n+\n+    \/\/ @Run(test = \"test16\")\n+    \/\/ @Warmup(10_000)\n+    \/\/ public static void test16_runner() {\n+    \/\/     test16(-42);\n+    \/\/     test16(42);\n+    \/\/ }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLoopConditionalPropagation.java","additions":730,"deletions":0,"binary":false,"changes":730,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestCMoveAndIf::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=2017015930 TestCMoveAndIf\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestCMoveAndIf::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN TestCMoveAndIf\n+ *\/\n+\n+\n+public class TestCMoveAndIf {\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(-100);\n+            test(100);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        int[] src = new int[8];\n+        if (stop > 6) {\n+            stop = 6;\n+        }\n+        stop = stop + 1;\n+        barrier = 0x42;\n+        if (stop <= 0) {\n+            stop = 0;\n+        }\n+        barrier = 0x42;\n+        testHelper(stop+1, src);\n+    }\n+\n+    private static void testHelper(int stop, int[] src) {\n+        for (int i = 0; i < stop; i += 2) {\n+            int v = src[i];\n+            if (v != 0) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestCMoveAndIf.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:CompileOnly=TestConditionKillsRC::test -XX:LoopUnrollLimit=1000 TestConditionKillsRC\n+ *\/\n+\n+public class TestConditionKillsRC {\n+\n+    static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        byte[] array = new byte[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(16);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        byte[] array = new byte[16];\n+        testHelper(stop, array);\n+    }\n+\n+    private static void testHelper(int stop, byte[] array) {\n+        for (int i = 0; i < stop; i++) {\n+            if (i < array.length) {\n+                if (i % 2 == 0) {\n+                    array[0] = 42;\n+                } else {\n+                    array[i] = 42;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestConditionKillsRC.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-BackgroundCompilation TestLSMDeadInLoopPredication\n+ *\/\n+\n+\n+public class TestLSMDeadInLoopPredication {\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, 100);\n+            testHelper(100, 1000);\n+            test2(false, 100);\n+            testHelper2(100, 1000);\n+        }\n+    }\n+\n+    private static void test(boolean flag, int stop) {\n+        for (int i = 0; i < 10; i++) {\n+            testHelper(stop, 1);\n+            if (i % 2 == 0) {\n+                if (flag) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testHelper(int stop, int stop2) {\n+        int j = 0;\n+        for(;;) {\n+            synchronized (new Object()) {\n+            }\n+            barrier = 0x42;\n+            if (j+1 > stop2) {\n+                break;\n+            }\n+            j++;\n+            if (j >= stop) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static void test2(boolean flag, int stop) {\n+        for (int i = 0; i < 10; i++) {\n+            testHelper2(stop, 0);\n+            if (i % 2 == 0) {\n+                if (flag) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testHelper2(int stop, int stop2) {\n+        int j = 0;\n+        for(;;) {\n+            synchronized (new Object()) {\n+            }\n+            barrier = 0x42;\n+            if (j > stop2) {\n+                break;\n+            }\n+            j++;\n+            if (j >= stop) {\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestLSMDeadInLoopPredication.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275202\n+ * @summary C2: optimize out more redundant conditions\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestOverUnrolled::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=1183221360 TestOverUnrolled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestOverUnrolled::test -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN TestOverUnrolled\n+ *\/\n+\n+public class TestOverUnrolled {\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(8);\n+            testHelper(1000, array);\n+        }\n+    }\n+\n+    private static void test(int stop) {\n+        int[] src = new int[8];\n+        if (stop > 8 || stop < 0) {\n+        }\n+        testHelper(stop, src);\n+    }\n+\n+    private static void testHelper(int stop, int[] src) {\n+        for (int i = 0; i < stop; i += 2) {\n+            int v = src[i];\n+            if (v != 0) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopconditionalpropagation\/TestOverUnrolled.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}