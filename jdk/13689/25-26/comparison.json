{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -179,0 +180,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n+     * to create an unnamed class hosted in {@code Foo.java}. All\n+     * unnamed classes must be in an unnamed package.\n+     *\n@@ -258,0 +266,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n+     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n+     * classes must be in an unnamed package.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -172,1 +174,1 @@\n-     * For an anonymous class, an {@linkplain Name##empty_name empty\n+     * For an anonymous or unnamed class, an {@linkplain Name##empty_name empty\n@@ -176,1 +178,1 @@\n-     * an empty name for an anonymous class\n+     * an empty name for an anonymous or unnamed class\n@@ -182,0 +184,16 @@\n+    \/**\n+     * {@return {@code true} if this is an unnamed class and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns {@code false}.\n+     *\n+     * @jls 7.3 Compilation Units\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    default boolean isUnnamed() {\n+        return false;\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1259,0 +1259,1 @@\n+    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1370,4 +1371,11 @@\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public Name getQualifiedName() {\n-            return fullname;\n-        }\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getQualifiedName() {\n+             \/\/ return isUnnamed0 ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+             return fullname;\n+         }\n+\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getSimpleName() {\n+             return isUnnamed() ? name.subName(0, 0) \/* empty name *\/ : name;\n+             \/\/ return name;\n+         }\n@@ -1548,1 +1556,1 @@\n-            if (owner.kind == PCK)\n+            if (owner.kind == PCK) \/\/ Should handle unnamed classes too\n@@ -1639,0 +1647,5 @@\n+\n+        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+        public boolean isUnnamed() {\n+            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -128,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous class\n+                \/\/ Don't print out the constructor of an anonymous or unnamed class\n@@ -131,1 +132,1 @@\n-                    NestingKind.ANONYMOUS ==\n+                    (NestingKind.ANONYMOUS ==\n@@ -138,1 +139,8 @@\n-                    }).visit(enclosing))\n+                    }).visit(enclosing)\n+                    || \/\/ Don't print the constructor of an unnamed class\n+                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n+                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+                        public Boolean visitType(TypeElement e, Void p) {\n+                            return e.isUnnamed();\n+                        }\n+                    }).visit(enclosing)) ) {\n@@ -140,0 +148,1 @@\n+                }\n@@ -172,0 +181,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -205,0 +215,8 @@\n+            } else if (e.isUnnamed()) {\n+                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getQualifiedName());\n+\n+                for(Element element : e.getEnclosedElements()) {\n+                    this.visit(element);\n+                }\n+\n+                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * A class with no-name.\n+ *\/\n+\n+void main() {\n+    printMessage();\n+}\n+\n+private static String horseName = null;\n+\n+private static void printMessage() {\n+    if (horseName == null) {\n+        System.out.print(\"A horse has no name.\");\n+    } else\n+        System.out.print(\"A horse's name is \" + horseName);\n+}\n+\n+\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/Anonymous.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306112\n+ * @summary Test basic processing of unnamed classes.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor TestUnnamedClass\n+ * @compile -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} Anonymous.java\n+ *\/\n+\n+\n+import java.lang.annotation.*;\n+import java.io.Writer;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import static javax.lang.model.util.ElementFilter.*;\n+import javax.tools.JavaFileObject;\n+\n+\/*\n+ * Ideally, this processor would test both the compile-time\n+ * representation of an unnamed class starting from a source file as\n+ * well as the representation starting from a class file. Currently,\n+ * only the source file based view will be tested.\n+ *\n+ * For future work to test the class file based view, an additional jtreg directive like the following could\n+ * be used:\n+ *\n+ * @compile\/process -processor TestUnnamedClass -proc:only Anonymous Nameless\n+ *\/\n+@SuppressWarnings(\"preview\")\n+public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n+\n+    private static int round  = 0;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (round == 0) { \/\/ Check file from comamnd line\n+            checkRoots(roundEnv);\n+            generateUnnamed();\n+        }\n+\n+        if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n+            checkRoots(roundEnv);\n+        }\n+\n+        round++;\n+        return true;\n+    }\n+\n+    private void checkRoots(RoundEnvironment roundEnv) {\n+        int checks = 0;\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n+            System.out.println(\"Checking \" + type.getQualifiedName());\n+            checks++;\n+            checkUnnamedClassProperties(type);\n+        }\n+        if (checks == 0) {\n+            messager.printError(\"No checking done of any candidate unnamed classes.\");\n+        }\n+    }\n+\n+    private void generateUnnamed() {\n+        try {\n+            String unnamedSource = \"\"\"\n+            void main() {\n+                System.out.println(\"Nameless, but not voiceless.\");\n+            }\n+            \"\"\";\n+\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n+            try(Writer w = outputFile.openWriter()) {\n+                w.append(unnamedSource);\n+            }\n+        } catch (java.io.IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    \/*\n+     * From JEP 445 JLS changes:\n+     *\n+     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n+     * properties:\n+     * It is always a top level class.\n+     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n+     * It is never abstract (8.1.1.1).\n+     * It is always final (8.1.1.2).\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\n+     * Its direct superclass type is always Object (8.1.4).\n+     * It never has any direct superinterface types (8.1.5).\n+     *\n+     * The body of the class contains every ClassMemberDeclaration\n+     * from the unnamed class compilation unit. It is not possible for\n+     * an unnamed class compilation unit to declare an instance\n+     * initializer, static initializer, or constructor.\n+     *\n+     * It has an implicitly declared default constructor (8.8.9).\n+     * All members of this class, including any implicitly declared\n+     * members, are subject to the usual rules for member declarations\n+     * in a class.\n+     *\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n+     *\/\n+    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n+        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n+            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getSimpleName().isEmpty()) {\n+            messager.printError(\"Unnamed class does _not_ have an empty simple name.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n+            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n+        }\n+\n+        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n+            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n+            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n+            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n+        }\n+\n+        if ( !types.isSameType(unnamedClass.getSuperclass(),\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n+            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getInterfaces().isEmpty()) {\n+            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n+        }\n+\n+        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n+        if (ctors.size() != 1 ) {\n+            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n+        }\n+\n+        ExecutableElement ctor = ctors.getFirst();\n+        if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n+            messager.printError(\"Constructor was not marked as mandated\", ctor);\n+        }\n+\n+        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\n+        boolean mainFound = false;\n+        Name mainName = elements.getName(\"main\");\n+        for (var method : methods) {\n+            if (method.getSimpleName().equals(mainName)) {\n+                mainFound = true;\n+                break;\n+            }\n+        }\n+\n+        if (!mainFound) {\n+            messager.printError(\"No main mehtod found\", unnamedClass);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}