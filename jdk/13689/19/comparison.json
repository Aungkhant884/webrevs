{"files":[{"patch":"@@ -101,0 +101,1 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MainMethodFinder {\n+    private static boolean correctArgs(Method method) {\n+        int argc = method.getParameterCount();\n+\n+        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n+    }\n+\n+    \/**\n+     * Gather all the \"main\" methods in the class hierarchy.\n+     *\n+     * @param refc         the main class or super class\n+     * @param mains        accumulated main methods\n+     * @param isMainClass  the class is the main class and not a super class\n+     *\/\n+    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n+        if (refc != null && refc != Object.class) {\n+            for (Method method : refc.getDeclaredMethods()) {\n+                int mods = method.getModifiers();\n+                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n+                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n+                if (\"main\".equals(method.getName()) &&\n+                        !method.isSynthetic() &&\n+                        !Modifier.isPrivate(mods) &&\n+                        correctArgs(method) &&\n+                        (isMainClass || !Modifier.isStatic(mods)))\n+                {\n+                    mains.add(method);\n+                }\n+            }\n+\n+            gatherMains(refc.getSuperclass(), mains, false);\n+        }\n+    }\n+\n+    \/**\n+     * Comparator for two methods.\n+     * Priority order is;\n+     * sub-class < super-class.\n+     * static < non-static,\n+     * string arg < no arg and\n+     *\n+     * @param a  first method\n+     * @param b  second method\n+     *\n+     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n+     *\/\n+    private static int compareMethods(Method a, Method b) {\n+        Class<?> aClass = a.getDeclaringClass();\n+        Class<?> bClass = b.getDeclaringClass();\n+\n+        if (aClass != bClass) {\n+            if (bClass.isAssignableFrom(aClass)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        }\n+\n+        int aMods = a.getModifiers();\n+        int bMods = b.getModifiers();\n+        boolean aIsStatic = Modifier.isStatic(aMods);\n+        boolean bIsStatic = Modifier.isStatic(bMods);\n+\n+        if (aIsStatic && !bIsStatic) {\n+            return -1;\n+        } else if (!aIsStatic && bIsStatic) {\n+            return 1;\n+        }\n+\n+        int aCount = a.getParameterCount();\n+        int bCount = b.getParameterCount();\n+\n+        if (bCount < aCount) {\n+            return -1;\n+        } else if (aCount < bCount) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    \/**\n+     * Return the traditional main method or null if not found.\n+     *\n+     * @param mainClass main class\n+     *\n+     * @return main method or null\n+     *\/\n+    private static Method getTraditionalMain(Class<?> mainClass) {\n+        try {\n+            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n+            int mods = traditionalMain.getModifiers();\n+\n+            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n+                return traditionalMain;\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            \/\/ not found\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return priority main method if none found}\n+     *\n+     * @param mainClass main class\n+     *\n+     * @throws NoSuchMethodException when not preview and no method found\n+     *\/\n+    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n+        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n+        if (isTraditionMain) {\n+            return mainClass.getMethod(\"main\", String[].class);\n+        }\n+\n+        List<Method> mains = new ArrayList<>();\n+        gatherMains(mainClass, mains, true);\n+\n+        if (mains.isEmpty()) {\n+            throw new NoSuchMethodException(\"No main method found\");\n+        }\n+\n+        if (1 < mains.size()) {\n+            mains.sort(MainMethodFinder::compareMethods);\n+        }\n+\n+        Method mainMethod = mains.get(0);\n+        Method traditionalMain = getTraditionalMain(mainClass);\n+\n+        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n+            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n+        }\n+\n+        return mains.get(0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+import java.lang.reflect.Constructor;\n@@ -63,0 +64,1 @@\n+import java.util.Arrays;\n@@ -81,0 +83,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -846,0 +850,21 @@\n+    \/*\n+     * main type flags\n+     *\/\n+    private static final int MAIN_WITHOUT_ARGS = 1;\n+    private static final int MAIN_NONSTATIC = 2;\n+    private static int mainType = 0;\n+\n+    \/*\n+     * Return type so that launcher invokes the correct main\n+     *\/\n+    public static int getMainType() {\n+        return mainType;\n+    }\n+\n+    private static void setMainType(Method mainMethod) {\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+        mainType = (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n+    }\n+\n@@ -850,1 +875,1 @@\n-            mainMethod = mainClass.getMethod(\"main\", String[].class);\n+            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n@@ -858,2 +883,2 @@\n-                      mainClass.getName(), mainClass.getModule().getName(),\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        mainClass.getName(), mainClass.getModule().getName(),\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -862,1 +887,1 @@\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -866,0 +891,2 @@\n+        setMainType(mainMethod);\n+\n@@ -867,1 +894,1 @@\n-         * getMethod (above) will choose the correct method, based\n+         * findMainMethod (above) will choose the correct method, based\n@@ -869,1 +896,1 @@\n-         * ensure that the method is static and returns a void.\n+         * ensure that the method is static (non-preview) and returns a void.\n@@ -871,4 +898,10 @@\n-        int mod = mainMethod.getModifiers();\n-        if (!Modifier.isStatic(mod)) {\n-            abort(null, \"java.launcher.cls.error2\", \"static\",\n-                  mainMethod.getDeclaringClass().getName());\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled()) {\n+            if (!isStatic || !isPublic || noArgs) {\n+                abort(null, \"java.launcher.cls.error2\", \"static\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n@@ -876,0 +909,18 @@\n+\n+        if (!isStatic) {\n+            if (mainClass.isMemberClass() && !Modifier.isStatic(mainClass.getModifiers())) {\n+                abort(null, \"java.launcher.cls.error9\",\n+                        mainMethod.getDeclaringClass().getName());\n+            }\n+            try {\n+                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n+                if (Modifier.isPrivate(constructor.getModifiers())) {\n+                    abort(null, \"java.launcher.cls.error8\",\n+                          mainMethod.getDeclaringClass().getName());\n+                }\n+            } catch (Throwable ex) {\n+                abort(null, \"java.launcher.cls.error8\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":61,"deletions":10,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,7 @@\n+java.launcher.cls.error8=\\\n+    Error: no non-private zero argument constructor found in class {0}\\n\\\n+    remove private from existing constructor or define as:\\n\\\n+\\   public {0}()\n+java.launcher.cls.error9=\\\n+    Error: non-static inner class {0} constructor can not be invoked \\n\\\n+    make inner class static or move inner class out to separate source file\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -404,1 +404,0 @@\n-    jmethodID mainID;\n@@ -406,0 +405,3 @@\n+    jmethodID mainID;\n+    jmethodID constructor;\n+    jobject mainObject;\n@@ -542,6 +544,49 @@\n-    mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"([Ljava\/lang\/String;)V\");\n-    CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-\n-    \/* Invoke main method. *\/\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+#define MAIN_WITHOUT_ARGS 1\n+#define MAIN_NONSTATIC 2\n+\n+    jclass helperClass = GetLauncherHelperClass(env);\n+    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"getMainType\",\n+                                                      \"()I\");\n+    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n+    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n+    CHECK_EXCEPTION_LEAVE(mainType);\n+\n+    switch (mainType) {\n+    case 0: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_WITHOUT_ARGS: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+        break;\n+        }\n+    case MAIN_NONSTATIC: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID);\n+        break;\n+        }\n+    }\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,4 @@\n+    \/** Class is a unnamed top level class.\n+     *\/\n+    public static final int UNNAMED_CLASS    = 1<<19;\n+\n@@ -493,0 +497,1 @@\n+        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case UNNAMED_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,0 +241,1 @@\n+        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5508,0 +5508,4 @@\n+\n+                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                    chk.checkHasMain(env.tree.pos(), c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2253,0 +2253,30 @@\n+    public void checkHasMain(DiagnosticPosition pos, ClassSymbol c) {\n+        boolean found = false;\n+\n+        for (Symbol sym : c.members().getSymbolsByName(names.main)) {\n+            if (sym.kind == MTH && (sym.flags() & PRIVATE) == 0) {\n+                MethodSymbol meth = (MethodSymbol)sym;\n+                if (!types.isSameType(meth.getReturnType(), syms.voidType)) {\n+                    continue;\n+                }\n+                if (meth.params.isEmpty()) {\n+                    found = true;\n+                    break;\n+                }\n+                if (meth.params.size() != 1) {\n+                    continue;\n+                }\n+                if (!types.isSameType(meth.params.head.type, types.makeArrayType(syms.stringType))) {\n+                    continue;\n+                }\n+\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) {\n+            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,2 +311,0 @@\n-\/\/        Assert.checkNonNull(tree.modle, tree.sourcefile.toString());\n-\n@@ -444,0 +442,3 @@\n+            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+                syms.removeClass(env.toplevel.modle, tree.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -2435,1 +2433,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.reflect.Constructor;\n@@ -87,0 +88,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -204,2 +207,2 @@\n-        String[] appArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, appArgs, context);\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        execute(mainClassName, mainArgs, context);\n@@ -415,1 +418,1 @@\n-     * @param appArgs the arguments for the {@code main} method\n+     * @param mainArgs the arguments for the {@code main} method\n@@ -420,1 +423,1 @@\n-    private void execute(String mainClassName, String[] appArgs, Context context)\n+    private void execute(String mainClassName, String[] mainArgs, Context context)\n@@ -424,0 +427,2 @@\n+\n+        Class<?> appClass;\n@@ -425,11 +430,1 @@\n-            Class<?> appClass = Class.forName(mainClassName, true, cl);\n-            Method main = appClass.getDeclaredMethod(\"main\", String[].class);\n-            int PUBLIC_STATIC = Modifier.PUBLIC | Modifier.STATIC;\n-            if ((main.getModifiers() & PUBLIC_STATIC) != PUBLIC_STATIC) {\n-                throw new Fault(Errors.MainNotPublicStatic);\n-            }\n-            if (!main.getReturnType().equals(void.class)) {\n-                throw new Fault(Errors.MainNotVoid);\n-            }\n-            main.setAccessible(true);\n-            main.invoke(0, (Object) appArgs);\n+            appClass = Class.forName(mainClassName, true, cl);\n@@ -438,0 +433,5 @@\n+        }\n+\n+        Method mainMethod;\n+        try {\n+            mainMethod = MainMethodFinder.findMainMethod(appClass);\n@@ -440,0 +440,41 @@\n+        }\n+\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n+            throw new Fault(Errors.MainNotPublicStatic);\n+        }\n+\n+        if (!mainMethod.getReturnType().equals(void.class)) {\n+            throw new Fault(Errors.MainNotVoid);\n+        }\n+\n+        Constructor<?> constructor;\n+        try {\n+            constructor = appClass.getDeclaredConstructor();\n+        } catch (NoSuchMethodException e) {\n+            throw new Fault(Errors.CantFindConstructor(mainClassName));\n+        }\n+\n+        Object instance;\n+        try {\n+            constructor.setAccessible(true);\n+            instance = constructor.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            throw new Fault(Errors.CantAccessConstructor(mainClassName));\n+        }\n+\n+        try {\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+            Object receiver = isStatic ? appClass : instance;\n+\n+            if (noArgs) {\n+                mainMethod.invoke(receiver);\n+            } else {\n+                mainMethod.invoke(receiver, (Object)mainArgs);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":57,"deletions":16,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import javax.lang.model.SourceVersion;\n+\n@@ -39,0 +41,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -185,1 +188,1 @@\n-        docComments = newDocCommentTable(keepDocComments, fac);\n+        this.docComments = newDocCommentTable(keepDocComments, fac);\n@@ -188,1 +191,24 @@\n-        endPosTable = newEndPosTable(keepEndPositions);\n+        this.endPosTable = newEndPosTable(keepEndPositions);\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n+    }\n+\n+    \/** Construct a parser from an existing parser, with minimal overhead.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected JavacParser(JavacParser parser,\n+                          Lexer S) {\n+        this.S = S;\n+        this.token = parser.token;\n+        this.F = parser.F;\n+        this.log = parser.log;\n+        this.names = parser.names;\n+        this.source = parser.source;\n+        this.preview = parser.preview;\n+        this.allowStringFolding = parser.allowStringFolding;\n+        this.keepDocComments = false;\n+        this.parseModuleInfo = false;\n+        this.docComments = null;\n+        this.errorTree = F.Erroneous();\n+        this.endPosTable = newEndPosTable(false);\n@@ -2790,4 +2816,1 @@\n-            if (token.kind == INTERFACE ||\n-                token.kind == CLASS ||\n-                token.kind == ENUM ||\n-                isRecordStart()) {\n+            if (isDeclaration()) {\n@@ -3893,0 +3916,1 @@\n+        boolean isUnnamedClass = false;\n@@ -3951,0 +3975,1 @@\n+\n@@ -3952,4 +3977,29 @@\n-                JCTree def = typeDeclaration(mods, docComment);\n-                if (def instanceof JCExpressionStatement statement)\n-                    def = statement.expr;\n-                defs.append(def);\n+                boolean isTopLevelMethodOrField = false;\n+\n+                \/\/ Do to a significant number of existing negative tests\n+                \/\/ this code speculatively tests to see if a top level method\n+                \/\/ or field can parse. If the method or field can parse then\n+                \/\/ it is parsed. Otherwise, parsing continues as though\n+                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ is the same as in the past.\n+                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                    final JCModifiers finalMods = mods;\n+                    JavacParser speculative = new VirtualParser(this);\n+                    List<JCTree> speculativeResult =\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                    if (speculativeResult.head.hasTag(METHODDEF) ||\n+                        speculativeResult.head.hasTag(VARDEF)) {\n+                        isTopLevelMethodOrField = true;\n+                    }\n+                }\n+\n+                if (isTopLevelMethodOrField) {\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n+                    isUnnamedClass = true;\n+                } else {\n+                    JCTree def = typeDeclaration(mods, docComment);\n+                    if (def instanceof JCExpressionStatement statement)\n+                        def = statement.expr;\n+                    defs.append(def);\n+                }\n+\n@@ -3960,1 +4010,2 @@\n-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n+        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(topLevelDefs);\n@@ -3974,0 +4025,37 @@\n+    \/\/ Restructure top level to be an unnamed class.\n+    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+        checkSourceLevel(Feature.UNNAMED_CLASSES);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : origDefs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else if (!def.hasTag(Tag.SKIP)) {\n+                defs.append(def);\n+            }\n+        }\n+\n+        int primaryPos = defs.first().pos;\n+        String simplename = PathFileObject.getSimpleName(log.currentSourceFile());\n+\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(primaryPos, Errors.BadFileName(simplename));\n+        }\n+\n+        Name name = names.fromString(simplename);\n+        JCModifiers anonMods = F.at(primaryPos)\n+                .Modifiers(Flags.FINAL|Flags.MANDATED|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n+        JCClassDecl anon = F.at(primaryPos).ClassDef(\n+                anonMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(anon);\n+        return topDefs.toList();\n+    }\n+\n@@ -4134,1 +4222,2 @@\n-            final JCErroneous erroneousTree;\n+\n+            JCDiagnostic.Error error;\n@@ -4136,1 +4225,3 @@\n-                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                error = Errors.ExpectedModuleOrOpen;\n+            } else if (allowRecords) {\n+                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n@@ -4138,5 +4229,1 @@\n-                if (allowRecords) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                } else {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                }\n+                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n@@ -4144,1 +4231,2 @@\n-            return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(syntaxError(pos, errs, error)));\n+\n@@ -4365,1 +4453,1 @@\n-                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,\n+                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, enumName,\n@@ -4471,1 +4559,1 @@\n-            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));\n+            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, className, isInterface, isRecord));\n@@ -4475,1 +4563,1 @@\n-           }\n+            }\n@@ -4510,1 +4598,3 @@\n-    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {\n+    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(JCModifiers mods, Name className,\n+                                                                   boolean isInterface,\n+                                                                   boolean isRecord) {\n@@ -4517,5 +4607,2 @@\n-            JCModifiers mods = modifiersOpt();\n-            if (token.kind == CLASS ||\n-                allowRecords && isRecordStart() ||\n-                token.kind == INTERFACE ||\n-                token.kind == ENUM) {\n+            mods = modifiersOpt(mods);\n+            if (isDeclaration()) {\n@@ -4533,9 +4620,4 @@\n-                pos = token.pos;\n-                List<JCTypeParameter> typarams = typeParametersOpt();\n-                \/\/ if there are type parameters but no modifiers, save the start\n-                \/\/ position of the method in the modifiers.\n-                if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n-                    mods.pos = pos;\n-                    storeEnd(mods, pos);\n-                }\n-                List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+                return constructorOrMethodOrFieldDeclaration(mods, className, isInterface, isRecord, dc);\n+            }\n+        }\n+    }\n@@ -4543,5 +4625,13 @@\n-                if (annosAfterParams.nonEmpty()) {\n-                    mods.annotations = mods.annotations.appendList(annosAfterParams);\n-                    if (mods.pos == Position.NOPOS)\n-                        mods.pos = mods.annotations.head.pos;\n-                }\n+    private List<JCTree> constructorOrMethodOrFieldDeclaration(JCModifiers mods, Name className,\n+                                                               boolean isInterface,\n+                                                               boolean isRecord, Comment dc) {\n+        int pos;\n+        pos = token.pos;\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n@@ -4549,71 +4639,147 @@\n-                Token tk = token;\n-                pos = token.pos;\n-                JCExpression type;\n-                boolean isVoid = token.kind == VOID;\n-                if (isVoid) {\n-                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n-                    nextToken();\n-                } else {\n-                    \/\/ method returns types are un-annotated types\n-                    type = unannotatedType(false);\n-                }\n-                if ((token.kind == LPAREN && !isInterface ||\n-                        isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n-                    if (isInterface || tk.name() != className)\n-                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n-                    else if (annosAfterParams.nonEmpty())\n-                        illegal(annosAfterParams.head.pos);\n-                    if (isRecord && token.kind == LBRACE) {\n-                        mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n-                    }\n-                    return List.of(methodDeclaratorRest(\n-                        pos, mods, null, names.init, typarams,\n-                        isInterface, true, isRecord, dc));\n-                } else if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n-                    \/\/ trying to define a compact constructor with a throws clause\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                            Errors.InvalidCanonicalConstructorInRecord(\n-                                    Fragments.Compact,\n-                                    className,\n-                                    Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n-                    skip(false, true, false, false);\n-                    return List.of(methodDeclaratorRest(\n-                            pos, mods, null, names.init, typarams,\n-                            isInterface, true, isRecord, dc));\n-                } else {\n-                    pos = token.pos;\n-                    Name name = ident();\n-                    if (token.kind == LPAREN) {\n-                        return List.of(methodDeclaratorRest(\n-                            pos, mods, type, name, typarams,\n-                            isInterface, isVoid, false, dc));\n-                    } else if (!isVoid && typarams.isEmpty()) {\n-                        if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n-                        List<JCTree> defs =\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                                    new ListBuffer<JCTree>(), false).toList();\n-                        accept(SEMI);\n-                        storeEnd(defs.last(), S.prevToken().endPos);\n-                        return defs;\n-                    } else {\n-                            int errPos = pos;\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                    new ListBuffer<JCTree>(), false).toList();\n-                            accept(SEMI);\n-                            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n-                        }\n-                    } else {\n-                        pos = token.pos;\n-                        List<JCTree> err;\n-                        if (isVoid || typarams.nonEmpty()) {\n-                            JCMethodDecl m =\n-                                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n-                                                            List.nil(), List.nil(), null, null));\n-                            attach(m, dc);\n-                            err = List.of(m);\n-                        } else {\n-                            err = List.nil();\n-                        }\n-                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n-                    }\n-                }\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        Token tk = token;\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            \/\/ method returns types are un-annotated types\n+            type = unannotatedType(false);\n+        }\n+\n+        \/\/ Constructor\n+        if ((token.kind == LPAREN && !isInterface ||\n+                isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n+            if (isInterface || tk.name() != className) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+            } else if (annosAfterParams.nonEmpty()) {\n+                illegal(annosAfterParams.head.pos);\n+            }\n+\n+            if (isRecord && token.kind == LBRACE) {\n+                mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n+            }\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        \/\/ Record constructor\n+        if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n+            \/\/ trying to define a compact constructor with a throws clause\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.InvalidCanonicalConstructorInRecord(\n+                            Fragments.Compact,\n+                            className,\n+                            Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n+            skip(false, true, false, false);\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        pos = token.pos;\n+        Name name = ident();\n+\n+        \/\/ Method\n+        if (token.kind == LPAREN) {\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, type, name, typarams,\n+                    isInterface, isVoid, false, dc));\n+        }\n+\n+        \/\/ Field\n+        if (!isVoid && typarams.isEmpty()) {\n+            if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n+                List<JCTree> defs =\n+                    variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                                            new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+                return defs;\n+            }\n+\n+            int errPos = pos;\n+            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                    new ListBuffer<JCTree>(), false).toList();\n+            accept(SEMI);\n+            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n+         }\n+\n+         pos = token.pos;\n+         List<JCTree> err;\n+\n+         \/\/ Error recovery\n+         if (isVoid || typarams.nonEmpty()) {\n+             JCMethodDecl m =\n+                     toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                                             List.nil(), List.nil(), null, null));\n+             attach(m, dc);\n+             err = List.of(m);\n+         } else {\n+             err = List.nil();\n+         }\n+\n+         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n+    }\n+\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n+        int topPos = token.pos;\n+        int pos = token.pos;\n+        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            type = unannotatedType(false);\n+        }\n+\n+        if (token.kind == IDENTIFIER) {\n+            pos = token.pos;\n+            Name name = ident();\n+\n+            \/\/ Method\n+            if (token.kind == LPAREN) {\n+                return List.of(methodDeclaratorRest(pos, mods, type, name, typarams,\n+                        false, isVoid, false, dc));\n+            }\n+\n+            \/\/ Field\n+            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+                List<JCTree> defs =\n+                        variableDeclaratorsRest(pos, mods, type, name, false, dc,\n+                                new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+\n+                return defs;\n@@ -4622,0 +4788,2 @@\n+\n+        return List.of(F.Erroneous());\n@@ -4624,0 +4792,7 @@\n+    protected boolean isDeclaration() {\n+        return token.kind == CLASS ||\n+               token.kind == INTERFACE ||\n+               token.kind == ENUM ||\n+               isRecordStart() && allowRecords;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":288,"deletions":113,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private final Tokens tokens;\n+    protected Tokens tokens;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCErroneous;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.Error;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Position.LineMap;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The virtual parser allows for speculative parsing while not commiting to\n+ * consuming tokens unless the speculation is successful.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class VirtualParser extends JavacParser {\n+\n+    private boolean hasErrors;\n+\n+    public VirtualParser(JavacParser parser) {\n+        super(parser, new VirtualScanner(parser.S));\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(DiagnosticPosition diagPos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    public boolean hasErrors() {\n+        return hasErrors;\n+    }\n+\n+    \/**\n+     * Scanner that does token lookahead and throws AssertionErrors if an error\n+     * occurs.\n+     *\/\n+    public static class VirtualScanner implements Lexer {\n+        \/** Parent scanner.\n+         *\/\n+        Lexer S;\n+\n+        \/** Token offset from where parent scanner branched.\n+         *\/\n+        int offset = 0;\n+\n+        \/** The token, set by nextToken().\n+         *\/\n+        private Token token;\n+\n+        \/** The previous token, set by nextToken().\n+         *\/\n+        private Token prevToken;\n+\n+        public VirtualScanner(Lexer s) {\n+            while (s instanceof VirtualScanner virtualScanner) {\n+                s = virtualScanner.S;\n+                offset += virtualScanner.offset;\n+            }\n+            S = s;\n+            token = s.token();\n+            prevToken = S.prevToken();\n+        }\n+\n+        @Override\n+        public void nextToken() {\n+            prevToken = token;\n+            offset++;\n+            token = token();\n+        }\n+\n+        @Override\n+        public Token token() {\n+            return token(0);\n+        }\n+\n+        @Override\n+        public Token token(int lookahead) {\n+            return S.token(offset + lookahead);\n+        }\n+\n+        @Override\n+        public Token prevToken() {\n+            return prevToken;\n+        }\n+\n+        @Override\n+        public void setPrevToken(Token prevToken) {\n+            this.prevToken = prevToken;\n+        }\n+\n+        @Override\n+        public Token split() {\n+            Token[] splitTokens = token.split(((Scanner)S).tokens);\n+            prevToken = splitTokens[0];\n+            token = splitTokens[1];\n+            return token;\n+        }\n+\n+        @Override\n+        public int errPos() {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public void errPos(int pos) {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public LineMap getLineMap() {\n+            return S.getLineMap();\n+        }\n+\n+        public void commit() {\n+            for (int i = 0 ; i < offset ; i++) {\n+                S.nextToken(); \/\/ advance underlying lexer until position matches\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Attempts a parse action and returns true if successful or false if\n+     * a parse error is thrown.\n+     *\n+     * @param parser        parent parser\n+     * @param parserAction  function that takes a parser and invokes a method on that parser\n+     *\n+     * @return true if successful\n+     *\/\n+    public static boolean tryParse(JavacParser parser, Consumer<JavacParser> parserAction) {\n+        VirtualParser virtualParser = new VirtualParser(parser);\n+        try {\n+            parserAction.accept(virtualParser);\n+            return true;\n+        } catch (AssertionError ex) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -512,0 +512,10 @@\n+# 0: string\n+compiler.err.bad.file.name=\\\n+    bad file name: {0}\n+\n+compiler.err.unnamed.class.should.not.have.package.declaration=\\\n+    unnamed class should not have package declaration\n+\n+compiler.err.unnamed.class.does.not.have.main.method=\\\n+    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+\n@@ -3155,0 +3165,3 @@\n+compiler.misc.feature.unnamed.classes=\\\n+    unnamed classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -122,0 +122,8 @@\n+# 0: string\n+launcher.err.cant.find.constructor=\\\n+    can''t find no argument constructor in class: {0}\n+\n+# 0: string\n+launcher.err.cant.access.constructor=\\\n+    can''t access no argument constructor in class: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -630,0 +630,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+                || node instanceof JCMethodDecl\n+                || node instanceof JCVariableDecl\n@@ -1162,1 +1164,1 @@\n-        return false;\n+        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,2 +359,1 @@\n-        return name.subName(\n-            name.lastIndexOf((byte)'.') + 1, name.getByteLength());\n+        return name.subName(start, end);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,1 @@\n+    public final Name main;\n@@ -391,0 +392,1 @@\n+        main = fromString(\"main\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test\n+ * @summary test execution priority of main methods\n+ * @run main InstanceMainTest\n+ *\/\n+public class InstanceMainTest extends TestHelper {\n+\n+    @Test\n+    public void testStaticMainArgs() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                static void main() {\n+                    throw new AssertionError();\n+                }\n+                static void main(String[] args) {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testStaticMain() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+                static void main() {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testMainArgs() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main() {\n+                    throw new AssertionError();\n+                }\n+                void main(String[] args) {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testMain() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main() {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonStaticMainArgs() throws Exception {\n+        test(\"\"\"\n+            static void main() {\n+                throw new AssertionError();\n+            }\n+            static void main(String[] args) {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonStaticMain() throws Exception {\n+        test(\"\"\"\n+            void main(String[] args) {\n+                throw new AssertionError();\n+            }\n+            static void main() {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonMainArgs() throws Exception {\n+        test(\"\"\"\n+            void main() {\n+                throw new AssertionError();\n+            }\n+            void main(String[] args) {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonMain() throws Exception {\n+        test(\"\"\"\n+            void main() {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testSuperMain() throws Exception {\n+        test(\"\"\"\n+           class MainClass extends SuperClass {\n+               void main() {\n+               }\n+           }\n+           class SuperClass {\n+               void main(String[] args) {\n+                   throw new AssertionError();\n+               }\n+           }\n+           \"\"\");\n+    }\n+\n+    @Test\n+    public void testIgnoreBridgeMain() throws Exception {\n+        test(\"\"\"\n+            public class MainClass extends Super {\n+            }\n+\n+            class Super {\n+                public void main(String... args) {\n+                }\n+\n+                public void main() {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+     @Test\n+    public void testIgnoreSuperMain() throws Exception {\n+        try {\n+            test(\"\"\"\n+                public class MainClass extends Super {\n+                    public static void main(String... args) {\n+                    }\n+                }\n+\n+                class Super {\n+                    public static void main(String... args) {\n+                    }\n+                }\n+                \"\"\");\n+            throw new AssertionError();\n+        } catch (Throwable ex) {\n+            \/\/ okay\n+        }\n+    }\n+\n+    void test(String source) throws Exception {\n+        Files.writeString(Path.of(\"MainClass.java\"), source);\n+        var version = System.getProperty(\"java.specification.version\");\n+        var tr = doExec(javaCmd, \"--enable-preview\", \"--source\", version, \"MainClass.java\");\n+        if (!tr.isOK()) {\n+            System.out.println(tr);\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new InstanceMainTest().run(args);\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.bad.file.name\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassBad-Filename.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+package unnamed.classes;\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public void ordinaryMethod() {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -556,1 +556,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotPublic\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,8 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=UnnamedClassRecovery.out -XDrawDiagnostics --enable-preview --source ${jdk.version} UnnamedClassRecovery.java\n+ *\/\n+public void main() {\n+    \/\/the following is intentionally missing a semicolon:\n+    System.err.println(\"Hello!\")\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+UnnamedClassRecovery.java:7:33: compiler.err.expected: ';'\n+- compiler.note.preview.filename: UnnamedClassRecovery.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary enums: ensure unnamed class is visible to java.lang.Enum<unnamed_class>\n+ * @enablePreview\n+ * @compile NestedEnum.java\n+ *\/\n+\n+enum Foo {A, B}\n+void main() {\n+    System.out.println(Foo.A);\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/NestedEnum.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}