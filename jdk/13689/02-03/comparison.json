{"files":[{"patch":"@@ -64,2 +64,0 @@\n-                int argc = method.getParameterCount();\n-\n@@ -147,1 +145,1 @@\n-            return mainClass.getMethod(\"main\", String[].class);\n+            return mainMethod;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.lang.invoke.MethodHandleInfo;\n@@ -44,2 +43,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n@@ -69,0 +66,1 @@\n+import java.util.Arrays;\n@@ -94,0 +92,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -851,14 +850,0 @@\n-    \/*\n-     * main type flags\n-     *\/\n-    private static final int MAIN_WITHOUT_ARGS = 1;\n-    private static final int MAIN_NONSTATIC = 2;\n-    private static int mainType = 0;\n-\n-    \/*\n-     * Return type so that launcher invokes the correct main\n-     *\/\n-    public static int getMainType() {\n-        return mainType;\n-    }\n-\n@@ -866,1 +851,1 @@\n-    static void validateMainClass(Class<?> mainClass) {\n+    static Method validateMainClass(Class<?> mainClass) {\n@@ -886,1 +871,1 @@\n-         * getMethod (above) will choose the correct method, based\n+         * findMainMethod (above) will choose the correct method, based\n@@ -893,1 +878,1 @@\n-        boolean hasArgs = mainMethod.getParameterCount() != 0;\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n@@ -896,1 +881,1 @@\n-            if (!isStatic || !isPublic || !hasArgs) {\n+            if (!isStatic || !isPublic || noArgs) {\n@@ -920,2 +905,34 @@\n-        mainType = (isStatic ? 0 : MAIN_NONSTATIC) |\n-                   (hasArgs ? 0 : MAIN_WITHOUT_ARGS);\n+        return mainMethod;\n+    }\n+\n+    \/\/ Check the existence and signature of main, abort if incorrect otherwise execute.\n+    @Hidden\n+    static void executeMainClass(Class<?> mainClass, String[] mainArgs) throws Throwable {\n+        Method mainMethod = validateMainClass(mainClass);\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        \/\/ Similar to com.sun.tools.javac.launcher#execute\n+        \/\/ but duplicated here to prevent additional launcher frames\n+        mainMethod.setAccessible(true);\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = lookup.unreflect(mainMethod);\n+\n+        if (isStatic) {\n+            if (noArgs) {\n+                mh.invokeExact();\n+            } else {\n+                mh.invokeExact(mainArgs);\n+            }\n+        } else {\n+            Constructor<?> constructor = appClass.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            Object instance = constructor.newInstance();\n+\n+            if (noArgs) {\n+                mh.invokeExact(instance);\n+            } else {\n+                mh.invokeExact(instance, mainArgs);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -240,1 +240,3 @@\n-    Error: no non-private no argument constructor found in class {0}\n+    Error: no non-private zero argument constructor found in class {0}\\n\\\n+    remove private from existing constructor or define as:\\n\\\n+\\   public {0}() {}\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -539,4 +539,4 @@\n-     * The LoadMainClass not only loads the main class, it will also ensure\n-     * that the main method's signature is correct, therefore further checking\n-     * is not required. The main method is invoked here so that extraneous java\n-     * stacks are not in the application stack trace.\n+     * The LauncherHelper locates and verifies that the main method has the right\n+     * signature and flags. The LauncherHelper then executes the main method and\n+     * and returns here. If an exception occurs LauncherHelper strips away any\n+     * superfluous frames.\n@@ -544,3 +544,0 @@\n-#define MAIN_WITHOUT_ARGS 1\n-#define MAIN_NONSTATIC 2\n-\n@@ -548,45 +545,6 @@\n-    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n-                                                      \"getMainType\",\n-                                                      \"()I\");\n-    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n-    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n-    CHECK_EXCEPTION_LEAVE(mainType);\n-\n-    switch (mainType) {\n-    case 0: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_WITHOUT_ARGS: {\n-        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                           \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n-        break;\n-        }\n-    case MAIN_NONSTATIC: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"([Ljava\/lang\/String;)V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n-        break;\n-        }\n-    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n-        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n-        mainObject = (*env)->NewObject(env, mainClass, constructor);\n-        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n-        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n-                                     \"()V\");\n-        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-        (*env)->CallVoidMethod(env, mainObject, mainID);\n-        break;\n-        }\n-    }\n+    jmethodID executeMainClass = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"executeMainClass\",\n+                                                      \"(Ljava\/lang\/Class;[Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_NULL_LEAVE(executeMainClass);\n+    (*env)->CallStaticVoidMethod(env, helperClass, executeMainClass, appClass, mainArgs);\n+    CHECK_EXCEPTION_LEAVE(1);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":10,"deletions":52,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -394,1 +394,1 @@\n-            if (tree.isAnonymousMainClass() && tree.getAnonymousMainClass() == null) {\n+            if (isAnonymousMainClass(tree)) {\n@@ -405,1 +405,3 @@\n-        \/\/where:\n+\n+\n+    \/\/where:\n@@ -431,0 +433,9 @@\n+        private static boolean isAnonymousMainClass(JCCompilationUnit tree) {\n+            for (JCTree def : tree.defs) {\n+                if (def.hasTag(Tag.METHODDEF) || def.hasTag(Tag.VARDEF)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n@@ -453,1 +464,1 @@\n-            log.error(null, Errors.BadFileName(simplename));\n+            log.error(tree.pos, Errors.BadFileName(simplename));\n@@ -462,1 +473,1 @@\n-                log.error(null, Errors.AnonymousMainClassShouldNotHavePackageDeclaration);\n+                log.error(def.pos(), Errors.AnonymousMainClassShouldNotHavePackageDeclaration);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2433,3 +2433,0 @@\n-            if ((sym.flags() & ANONYMOUS_MAIN_CLASS) != 0) {\n-                sym = typeNotFound;\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-        String[] appArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, appArgs, context);\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        execute(mainClassName, mainArgs, context);\n@@ -426,1 +426,1 @@\n-     * @param appArgs the arguments for the {@code main} method\n+     * @param mainArgs the arguments for the {@code main} method\n@@ -431,1 +431,1 @@\n-    private void execute(String mainClassName, String[] appArgs, Context context)\n+    private void execute(String mainClassName, String[] mainArgs, Context context)\n@@ -437,2 +437,7 @@\n-            Method main = MainMethodFinder.findMainMethod(appClass);\n-            if (!PreviewFeatures.isEnabled() && (!isStatic(main) || !isPublic(main))) {\n+            Method mainMethod = MainMethodFinder.findMainMethod(appClass);\n+            int mods = mainMethod.getModifiers();\n+            boolean isStatic = Modifier.isStatic(mods);\n+            boolean isPublic = Modifier.isStatic(mods);\n+            boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+            if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n@@ -441,1 +446,2 @@\n-            if (!main.getReturnType().equals(void.class)) {\n+\n+            if (!mainMethod.getReturnType().equals(void.class)) {\n@@ -444,4 +450,8 @@\n-            main.setAccessible(true);\n-            if (isStatic(main)) {\n-                if (main.getParameterCount() == 0) {\n-                    main.invoke(appClass);\n+\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+\n+            if (isStatic) {\n+                if (noArgs) {\n+                    mainMethod.invoke(appClass);\n@@ -449,1 +459,1 @@\n-                    main.invoke(appClass, (Object)appArgs);\n+                    mainMethod.invoke(appClass, (Object)mainArgs);\n@@ -455,2 +465,3 @@\n-                 if (main.getParameterCount() == 0) {\n-                    main.invoke(instance);\n+\n+                if (noArgs) {\n+                    mainMethod.invoke(instance);\n@@ -458,1 +469,1 @@\n-                    main.invoke(instance, (Object)appArgs);\n+                    mainMethod.invoke(instance, (Object)mainArgs);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3931,3 +3931,1 @@\n-                if (Feature.ANONYMOUS_MAIN_CLASSES.allowedInSource(source) &&\n-                        !isDeclaration() &&\n-                        (token.kind == VOID || token.kind == IDENTIFIER)) {\n+                if (Feature.ANONYMOUS_MAIN_CLASSES.allowedInSource(source) && !isDeclaration()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,33 +176,0 @@\n-\n-    \/**\n-     * WARNING: do not use until the TODO is scoped out\n-     *\n-     * Attempts a parse action and optionally returns the result of that action. The result\n-     * will be empty of the action fails.\n-     *\n-     * @param parser           parent parser\n-     * @param parserAction     function that takes a parser and invokes a method on that parser\n-     * @param commitOnSuccess  if true updates the active parser scanner to reflect the effects\n-     *                         of the action\n-     * @return {@link Optional} result of the action\n-     *\n-     * @param <E> return type of parserAction\n-     *\/\n-    public static <E> Optional<E> speculativeParse(JavacParser parser,\n-                                                   Function<JavacParser, E> parserAction,\n-                                                   boolean commitOnSuccess) {\n-        VirtualParser virtualParser = new VirtualParser(parser);\n-        try {\n-            E result = parserAction.apply(virtualParser);\n-\n-            if (commitOnSuccess) {\n-                \/\/ TODO - additional data needs to be propagated\n-                ((VirtualScanner)virtualParser.S).commit();\n-                parser.nextToken();\n-            }\n-\n-            return Optional.of(result);\n-        } catch (AssertionError ex) {\n-            return Optional.empty();\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -627,23 +627,0 @@\n-        public boolean isAnonymousMainClass() {\n-            \/\/ Detect anonymous main class.\n-            for (JCTree def : defs) {\n-                if (def.hasTag(Tag.METHODDEF) || def.hasTag(Tag.VARDEF)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public JCClassDecl getAnonymousMainClass() {\n-            \/\/ Find anonymous main class.\n-            for (JCTree def : defs) {\n-                if (def.hasTag(CLASSDEF)) {\n-                    JCClassDecl cls = (JCClassDecl)def;\n-                    if ((cls.getModifiers().flags & Flags.ANONYMOUS_MAIN_CLASS) != 0) {\n-                        return cls;\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -346,4 +346,0 @@\n-            if (tree.isAnonymousMainClass()) {\n-                return;\n-            }\n-\n","filename":"test\/langtools\/tools\/javac\/tree\/TreePosTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}