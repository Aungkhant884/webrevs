{"files":[{"patch":"@@ -101,0 +101,1 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MainMethodFinder {\n+    private static boolean isPrivate(Method method) {\n+        return method != null && Modifier.isPrivate(method.getModifiers());\n+    }\n+\n+    private static boolean isPublic(Method method) {\n+        return method != null && Modifier.isPublic(method.getModifiers());\n+    }\n+\n+    private static boolean isStatic(Method method) {\n+        return method != null && Modifier.isStatic(method.getModifiers());\n+    }\n+\n+    private static boolean correctArgs(Method method) {\n+        int argc = method.getParameterCount();\n+\n+        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n+    }\n+\n+    \/**\n+     * Gather all the \"main\" methods in the class heirarchy.\n+     *\n+     * @param declc  the top level declaring class\n+     * @param refc   the declaring class or super class\n+     * @param mains  accumulated main methods\n+     *\/\n+    private static void gatherMains(Class<?> declc, Class<?> refc, List<Method> mains) {\n+        if (refc != null && refc != Object.class) {\n+            gatherMains(declc, refc.getSuperclass(), mains);\n+\n+            for (Method method : refc.getDeclaredMethods()) {\n+                \/\/ Must be named \"main\", public|protected|package-private and either\n+                \/\/ no arguments or one string array argument.\n+                if (\"main\".equals(method.getName()) &&\n+                        !isPrivate(method) &&\n+                        correctArgs(method) &&\n+                        \/\/ Only statics in the declaring class\n+                        (!isStatic(method) || declc == refc)\n+                ) {\n+                    mains.add(method);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Comparator for two methods.\n+     * Priority order is;\n+     * static < non-static,\n+     * public < non-public,\n+     * string arg < no arg and\n+     * sub-class < super-class.\n+     *\n+     * @param a  first method\n+     * @param b  second method\n+     *\n+     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n+     *\/\n+    private static int compareMethods(Method a, Method b) {\n+        int aMods = a.getModifiers();\n+        int bMods = b.getModifiers();\n+        boolean aIsStatic = Modifier.isStatic(aMods);\n+        boolean bIsStatic = Modifier.isStatic(bMods);\n+\n+        if (aIsStatic && !bIsStatic) {\n+            return -1;\n+        } else if (bIsStatic && !aIsStatic) {\n+            return 1;\n+        }\n+\n+        boolean aIsPublic = Modifier.isPublic(aMods);\n+        boolean bIsPublic = Modifier.isPublic(bMods);\n+\n+        if (aIsPublic && !bIsPublic) {\n+            return -1;\n+        } else if (bIsPublic && !aIsPublic) {\n+            return 1;\n+        }\n+\n+        int aCount = a.getParameterCount();\n+        int bCount = b.getParameterCount();\n+\n+        if (aCount > bCount) {\n+            return -1;\n+        } else if (bCount > aCount) {\n+            return 1;\n+        }\n+\n+        Class<?> aClass = a.getDeclaringClass();\n+        Class<?> bClass = b.getDeclaringClass();\n+\n+        if (bClass.isAssignableFrom(aClass)) {\n+            return -1;\n+        } else if (bClass.isAssignableFrom(aClass)) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    \/**\n+     * {@return priority main method or null if none found}\n+     * @param mainClass main class\n+     *\/\n+    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n+        try {\n+            Method mainMethod = mainClass.getMethod(\"main\", String[].class);\n+\n+            if (mainMethod.getDeclaringClass() != mainClass) {\n+                System.err.println(\"WARNING: static main in super class will be deprecated.\");\n+            }\n+\n+            return mainMethod;\n+        } catch (NoSuchMethodException nsme) {\n+            if (!PreviewFeatures.isEnabled()) {\n+                throw nsme;\n+            }\n+\n+            List<Method> mains = new ArrayList<>();\n+            gatherMains(mainClass, mainClass, mains);\n+\n+            if (mains.isEmpty()) {\n+                throw new NoSuchMethodException(\"No main method found\");\n+            }\n+\n+            mains.sort(MainMethodFinder::compareMethods);\n+            Method mainMethod = mains.get(0);\n+\n+            return mainMethod;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -51,0 +53,1 @@\n+import java.lang.reflect.Constructor;\n@@ -63,0 +66,1 @@\n+import java.util.Arrays;\n@@ -81,0 +85,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -86,0 +92,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -844,1 +851,1 @@\n-    static void validateMainClass(Class<?> mainClass) {\n+    static Method validateMainClass(Class<?> mainClass) {\n@@ -847,1 +854,1 @@\n-            mainMethod = mainClass.getMethod(\"main\", String[].class);\n+            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n@@ -855,2 +862,2 @@\n-                      mainClass.getName(), mainClass.getModule().getName(),\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        mainClass.getName(), mainClass.getModule().getName(),\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -859,1 +866,1 @@\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -864,1 +871,1 @@\n-         * getMethod (above) will choose the correct method, based\n+         * findMainMethod (above) will choose the correct method, based\n@@ -866,1 +873,1 @@\n-         * ensure that the method is static and returns a void.\n+         * ensure that the method is static (non-preview) and returns a void.\n@@ -868,4 +875,10 @@\n-        int mod = mainMethod.getModifiers();\n-        if (!Modifier.isStatic(mod)) {\n-            abort(null, \"java.launcher.cls.error2\", \"static\",\n-                  mainMethod.getDeclaringClass().getName());\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled()) {\n+            if (!isStatic || !isPublic || noArgs) {\n+                abort(null, \"java.launcher.cls.error2\", \"static\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n@@ -873,0 +886,14 @@\n+\n+        if (!isStatic) {\n+            try {\n+                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n+                if (Modifier.isPrivate(constructor.getModifiers())) {\n+                    abort(null, \"java.launcher.cls.error8\",\n+                          mainMethod.getDeclaringClass().getName());\n+                }\n+            } catch (Throwable ex) {\n+                abort(null, \"java.launcher.cls.error8\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n+        }\n+\n@@ -877,0 +904,35 @@\n+\n+        return mainMethod;\n+    }\n+\n+    \/\/ Check the existence and signature of main, abort if incorrect otherwise execute.\n+    @Hidden\n+    static void executeMainClass(Class<?> mainClass, String[] mainArgs) throws Throwable {\n+        Method mainMethod = validateMainClass(mainClass);\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        \/\/ Similar to com.sun.tools.javac.launcher#execute\n+        \/\/ but duplicated here to prevent additional launcher frames\n+        mainMethod.setAccessible(true);\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = lookup.unreflect(mainMethod);\n+\n+        if (isStatic) {\n+            if (noArgs) {\n+                mh.invokeExact();\n+            } else {\n+                mh.invokeExact(mainArgs);\n+            }\n+        } else {\n+            Constructor<?> constructor = appClass.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            Object instance = constructor.newInstance();\n+\n+            if (noArgs) {\n+                mh.invokeExact(instance);\n+            } else {\n+                mh.invokeExact(instance, mainArgs);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":74,"deletions":12,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,4 @@\n+java.launcher.cls.error8=\\\n+    Error: no non-private zero argument constructor found in class {0}\\n\\\n+    remove private from existing constructor or define as:\\n\\\n+\\   public {0}() {}\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,0 +405,1 @@\n+    jmethodID constructor;\n@@ -406,0 +407,1 @@\n+    jobject mainObject;\n@@ -537,4 +539,4 @@\n-     * The LoadMainClass not only loads the main class, it will also ensure\n-     * that the main method's signature is correct, therefore further checking\n-     * is not required. The main method is invoked here so that extraneous java\n-     * stacks are not in the application stack trace.\n+     * The LauncherHelper locates and verifies that the main method has the right\n+     * signature and flags. The LauncherHelper then executes the main method and\n+     * and returns here. If an exception occurs LauncherHelper strips away any\n+     * superfluous frames.\n@@ -542,6 +544,7 @@\n-    mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"([Ljava\/lang\/String;)V\");\n-    CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-\n-    \/* Invoke main method. *\/\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+    jclass helperClass = GetLauncherHelperClass(env);\n+    jmethodID executeMainClass = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"executeMainClass\",\n+                                                      \"(Ljava\/lang\/Class;[Ljava\/lang\/String;)V\");\n+    CHECK_EXCEPTION_NULL_LEAVE(executeMainClass);\n+    (*env)->CallStaticVoidMethod(env, helperClass, executeMainClass, appClass, mainArgs);\n+    CHECK_EXCEPTION_LEAVE(1);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,4 @@\n+    \/** Class is a top level anonymous class.\n+     *\/\n+    public static final int ANONYMOUS_MAIN_CLASS    = 1<<19;\n+\n@@ -493,0 +497,1 @@\n+        ANONYMOUS_MAIN_CLASS(Flags.ANONYMOUS_MAIN_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+            case ANONYMOUS_MAIN_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,1 @@\n+        ANONYMOUS_MAIN_CLASSES(JDK21, Fragments.FeatureAnonymousMainClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5491,0 +5491,4 @@\n+\n+                if ((c.flags_field & Flags.ANONYMOUS_MAIN_CLASS) != 0) {\n+                    chk.checkHasMain(env.tree.pos(), c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2249,0 +2249,30 @@\n+    public void checkHasMain(DiagnosticPosition pos, ClassSymbol c) {\n+        boolean found = false;\n+\n+        for (Symbol sym : c.members().getSymbolsByName(names.main)) {\n+            if (sym.kind == MTH && (sym.flags() & PRIVATE) == 0) {\n+                MethodSymbol meth = (MethodSymbol)sym;\n+                if (!types.isSameType(meth.getReturnType(), syms.voidType)) {\n+                    continue;\n+                }\n+                if (meth.params.isEmpty()) {\n+                    found = true;\n+                    break;\n+                }\n+                if (meth.params.size() != 1) {\n+                    continue;\n+                }\n+                if (!types.isSameType(meth.params.head.type, types.makeArrayType(syms.stringType))) {\n+                    continue;\n+                }\n+\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) {\n+            log.error(pos, Errors.AnonymousMainClassDoesNotHaveMainMethod);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javax.lang.model.SourceVersion;\n@@ -38,0 +39,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -40,0 +42,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -46,0 +49,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -107,0 +111,2 @@\n+    Source source;\n+    Preview preview;\n@@ -132,0 +138,2 @@\n+        source = Source.instance(context);\n+        preview = Preview.instance(context);\n@@ -311,2 +319,0 @@\n-\/\/        Assert.checkNonNull(tree.modle, tree.sourcefile.toString());\n-\n@@ -388,0 +394,3 @@\n+            if (isAnonymousMainClass(tree)) {\n+                constructAnonymousMainClass(tree, source, preview, make, log, names);\n+            }\n@@ -396,1 +405,3 @@\n-        \/\/where:\n+\n+\n+    \/\/where:\n@@ -422,0 +433,57 @@\n+        private static boolean isAnonymousMainClass(JCCompilationUnit tree) {\n+            for (JCTree def : tree.defs) {\n+                if (def.hasTag(Tag.METHODDEF) || def.hasTag(Tag.VARDEF)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+    \/\/ Restructure top level to be an top level anonymous class.\n+    public static void constructAnonymousMainClass(JCCompilationUnit tree,\n+                                                   Source source, Preview preview,\n+                                                   TreeMaker make, Log log, Names names) {\n+        Feature feature = Feature.ANONYMOUS_MAIN_CLASSES;\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n+            \/\/preview feature without --preview flag, error\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos, preview.disabledError(feature));\n+        } else if (!feature.allowedInSource(source)) {\n+            \/\/incompatible source level, error\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos, feature.error(source.name));\n+        } else if (preview.isPreview(feature)) {\n+            \/\/use of preview feature, warn\n+            preview.warnPreview(tree.pos, feature);\n+        }\n+\n+        make.at(tree.pos);\n+        String simplename = PathFileObject.getSimpleName(tree.sourcefile);\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(tree.pos, Errors.BadFileName(simplename));\n+        }\n+        Name name = names.fromString(simplename);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : tree.defs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.AnonymousMainClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else {\n+                defs.append(def);\n+            }\n+        }\n+\n+        JCModifiers anonMods = make.at(tree.pos)\n+                .Modifiers(FINAL|MANDATED|SYNTHETIC|ANONYMOUS_MAIN_CLASS, List.nil());\n+        JCClassDecl anon = make.at(tree.pos).ClassDef(\n+                anonMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(anon);\n+        tree.defs = topDefs.toList();\n+    }\n+\n@@ -444,0 +512,3 @@\n+            if ((tree.mods.flags & ANONYMOUS_MAIN_CLASS) != 0) {\n+                syms.removeClass(env.toplevel.modle, tree.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":75,"deletions":4,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -2435,1 +2433,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.reflect.Constructor;\n@@ -87,0 +88,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -204,2 +207,2 @@\n-        String[] appArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, appArgs, context);\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        execute(mainClassName, mainArgs, context);\n@@ -410,0 +413,8 @@\n+    private static boolean isPublic(Method method) {\n+        return method != null && Modifier.isPublic(method.getModifiers());\n+    }\n+\n+    private static boolean isStatic(Method method) {\n+        return method != null && Modifier.isStatic(method.getModifiers());\n+    }\n+\n@@ -415,1 +426,1 @@\n-     * @param appArgs the arguments for the {@code main} method\n+     * @param mainArgs the arguments for the {@code main} method\n@@ -420,1 +431,1 @@\n-    private void execute(String mainClassName, String[] appArgs, Context context)\n+    private void execute(String mainClassName, String[] mainArgs, Context context)\n@@ -426,3 +437,7 @@\n-            Method main = appClass.getDeclaredMethod(\"main\", String[].class);\n-            int PUBLIC_STATIC = Modifier.PUBLIC | Modifier.STATIC;\n-            if ((main.getModifiers() & PUBLIC_STATIC) != PUBLIC_STATIC) {\n+            Method mainMethod = MainMethodFinder.findMainMethod(appClass);\n+            int mods = mainMethod.getModifiers();\n+            boolean isStatic = Modifier.isStatic(mods);\n+            boolean isPublic = Modifier.isStatic(mods);\n+            boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+            if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n@@ -431,1 +446,2 @@\n-            if (!main.getReturnType().equals(void.class)) {\n+\n+            if (!mainMethod.getReturnType().equals(void.class)) {\n@@ -434,2 +450,22 @@\n-            main.setAccessible(true);\n-            main.invoke(0, (Object) appArgs);\n+\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+\n+            if (isStatic) {\n+                if (noArgs) {\n+                    mainMethod.invoke(appClass);\n+                } else {\n+                    mainMethod.invoke(appClass, (Object)mainArgs);\n+                }\n+            } else {\n+                Constructor<?> constructor = appClass.getDeclaredConstructor();\n+                constructor.setAccessible(true);\n+                Object instance = constructor.newInstance();\n+\n+                if (noArgs) {\n+                    mainMethod.invoke(instance);\n+                } else {\n+                    mainMethod.invoke(instance, (Object)mainArgs);\n+                }\n+            }\n@@ -440,1 +476,1 @@\n-        } catch (IllegalAccessException e) {\n+        } catch (IllegalAccessException | InstantiationException e) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        docComments = newDocCommentTable(keepDocComments, fac);\n+        this.docComments = newDocCommentTable(keepDocComments, fac);\n@@ -189,1 +189,24 @@\n-        endPosTable = newEndPosTable(keepEndPositions);\n+        this.endPosTable = newEndPosTable(keepEndPositions);\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n+    }\n+\n+    \/** Construct a parser from an existing parser, with minimal overhead.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected JavacParser(JavacParser parser,\n+                          Lexer S) {\n+        this.S = S;\n+        this.token = parser.token;\n+        this.F = parser.F;\n+        this.log = parser.log;\n+        this.names = parser.names;\n+        this.source = parser.source;\n+        this.preview = parser.preview;\n+        this.allowStringFolding = parser.allowStringFolding;\n+        this.keepDocComments = false;\n+        this.parseModuleInfo = false;\n+        this.docComments = null;\n+        this.errorTree = F.Erroneous();\n+        this.endPosTable = newEndPosTable(false);\n@@ -2679,4 +2702,1 @@\n-            if (token.kind == INTERFACE ||\n-                token.kind == CLASS ||\n-                token.kind == ENUM ||\n-                isRecordStart()) {\n+            if (isDeclaration()) {\n@@ -3901,0 +3921,1 @@\n+\n@@ -3902,4 +3923,24 @@\n-                JCTree def = typeDeclaration(mods, docComment);\n-                if (def instanceof JCExpressionStatement statement)\n-                    def = statement.expr;\n-                defs.append(def);\n+                boolean isTopLevelMethodOrField = false;\n+\n+                \/\/ Do to a significant number of existing negative tests\n+                \/\/ this code speculatively tests to see if a top level method\n+                \/\/ or field can parse. If the method or field can parse then\n+                \/\/ it is parsed. Otherwise, parsing continues as though\n+                \/\/ anonymous main classes did not exist and error reporting\n+                \/\/ is the same as in the past.\n+                if (Feature.ANONYMOUS_MAIN_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                    final JCModifiers finalMods = mods;\n+                    isTopLevelMethodOrField =\n+                            VirtualParser.tryParse(this,\n+                                    P -> P.topLevelMethodOrFieldDeclaration(finalMods));\n+                }\n+\n+                if (isTopLevelMethodOrField) {\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n+                } else {\n+                    JCTree def = typeDeclaration(mods, docComment);\n+                    if (def instanceof JCExpressionStatement statement)\n+                        def = statement.expr;\n+                    defs.append(def);\n+                }\n+\n@@ -4084,1 +4125,2 @@\n-            final JCErroneous erroneousTree;\n+\n+            JCDiagnostic.Error error;\n@@ -4086,1 +4128,3 @@\n-                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                error = Errors.ExpectedModuleOrOpen;\n+            } else if (allowRecords) {\n+                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n@@ -4088,5 +4132,1 @@\n-                if (allowRecords) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                } else {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                }\n+                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n@@ -4094,1 +4134,2 @@\n-            return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(syntaxError(pos, errs, error)));\n+\n@@ -4315,1 +4356,1 @@\n-                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,\n+                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, enumName,\n@@ -4421,1 +4462,1 @@\n-            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));\n+            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, className, isInterface, isRecord));\n@@ -4425,1 +4466,1 @@\n-           }\n+            }\n@@ -4460,1 +4501,3 @@\n-    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {\n+    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(JCModifiers mods, Name className,\n+                                                                   boolean isInterface,\n+                                                                   boolean isRecord) {\n@@ -4467,5 +4510,2 @@\n-            JCModifiers mods = modifiersOpt();\n-            if (token.kind == CLASS ||\n-                allowRecords && isRecordStart() ||\n-                token.kind == INTERFACE ||\n-                token.kind == ENUM) {\n+            mods = modifiersOpt(mods);\n+            if (isDeclaration()) {\n@@ -4483,9 +4523,4 @@\n-                pos = token.pos;\n-                List<JCTypeParameter> typarams = typeParametersOpt();\n-                \/\/ if there are type parameters but no modifiers, save the start\n-                \/\/ position of the method in the modifiers.\n-                if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n-                    mods.pos = pos;\n-                    storeEnd(mods, pos);\n-                }\n-                List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+                return constructorOrMethodOrFieldDeclaration(mods, className, isInterface, isRecord, dc);\n+            }\n+        }\n+    }\n@@ -4493,5 +4528,13 @@\n-                if (annosAfterParams.nonEmpty()) {\n-                    mods.annotations = mods.annotations.appendList(annosAfterParams);\n-                    if (mods.pos == Position.NOPOS)\n-                        mods.pos = mods.annotations.head.pos;\n-                }\n+    private List<JCTree> constructorOrMethodOrFieldDeclaration(JCModifiers mods, Name className,\n+                                                               boolean isInterface,\n+                                                               boolean isRecord, Comment dc) {\n+        int pos;\n+        pos = token.pos;\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n@@ -4499,71 +4542,30 @@\n-                Token tk = token;\n-                pos = token.pos;\n-                JCExpression type;\n-                boolean isVoid = token.kind == VOID;\n-                if (isVoid) {\n-                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n-                    nextToken();\n-                } else {\n-                    \/\/ method returns types are un-annotated types\n-                    type = unannotatedType(false);\n-                }\n-                if ((token.kind == LPAREN && !isInterface ||\n-                        isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n-                    if (isInterface || tk.name() != className)\n-                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n-                    else if (annosAfterParams.nonEmpty())\n-                        illegal(annosAfterParams.head.pos);\n-                    if (isRecord && token.kind == LBRACE) {\n-                        mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n-                    }\n-                    return List.of(methodDeclaratorRest(\n-                        pos, mods, null, names.init, typarams,\n-                        isInterface, true, isRecord, dc));\n-                } else if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n-                    \/\/ trying to define a compact constructor with a throws clause\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                            Errors.InvalidCanonicalConstructorInRecord(\n-                                    Fragments.Compact,\n-                                    className,\n-                                    Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n-                    skip(false, true, false, false);\n-                    return List.of(methodDeclaratorRest(\n-                            pos, mods, null, names.init, typarams,\n-                            isInterface, true, isRecord, dc));\n-                } else {\n-                    pos = token.pos;\n-                    Name name = ident();\n-                    if (token.kind == LPAREN) {\n-                        return List.of(methodDeclaratorRest(\n-                            pos, mods, type, name, typarams,\n-                            isInterface, isVoid, false, dc));\n-                    } else if (!isVoid && typarams.isEmpty()) {\n-                        if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n-                        List<JCTree> defs =\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                                    new ListBuffer<JCTree>(), false).toList();\n-                        accept(SEMI);\n-                        storeEnd(defs.last(), S.prevToken().endPos);\n-                        return defs;\n-                    } else {\n-                            int errPos = pos;\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                    new ListBuffer<JCTree>(), false).toList();\n-                            accept(SEMI);\n-                            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n-                        }\n-                    } else {\n-                        pos = token.pos;\n-                        List<JCTree> err;\n-                        if (isVoid || typarams.nonEmpty()) {\n-                            JCMethodDecl m =\n-                                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n-                                                            List.nil(), List.nil(), null, null));\n-                            attach(m, dc);\n-                            err = List.of(m);\n-                        } else {\n-                            err = List.nil();\n-                        }\n-                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n-                    }\n-                }\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        Token tk = token;\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            \/\/ method returns types are un-annotated types\n+            type = unannotatedType(false);\n+        }\n+\n+        \/\/ Constructor\n+        if ((token.kind == LPAREN && !isInterface ||\n+                isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n+            if (isInterface || tk.name() != className) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+            } else if (annosAfterParams.nonEmpty()) {\n+                illegal(annosAfterParams.head.pos);\n+            }\n+\n+            if (isRecord && token.kind == LBRACE) {\n+                mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n@@ -4571,0 +4573,18 @@\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        \/\/ Record constructor\n+        if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n+            \/\/ trying to define a compact constructor with a throws clause\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.InvalidCanonicalConstructorInRecord(\n+                            Fragments.Compact,\n+                            className,\n+                            Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n+            skip(false, true, false, false);\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n@@ -4572,0 +4592,44 @@\n+\n+        pos = token.pos;\n+        Name name = ident();\n+\n+        \/\/ Method\n+        if (token.kind == LPAREN) {\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, type, name, typarams,\n+                    isInterface, isVoid, false, dc));\n+        }\n+\n+        \/\/ Field\n+        if (!isVoid && typarams.isEmpty()) {\n+            if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n+                List<JCTree> defs =\n+                    variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                                            new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+                return defs;\n+            }\n+\n+            int errPos = pos;\n+            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                    new ListBuffer<JCTree>(), false).toList();\n+            accept(SEMI);\n+            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n+         }\n+\n+         pos = token.pos;\n+         List<JCTree> err;\n+\n+         \/\/ Error recovery\n+         if (isVoid || typarams.nonEmpty()) {\n+             JCMethodDecl m =\n+                     toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                                             List.nil(), List.nil(), null, null));\n+             attach(m, dc);\n+             err = List.of(m);\n+         } else {\n+             err = List.nil();\n+         }\n+\n+         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n@@ -4574,0 +4638,64 @@\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n+        int topPos = token.pos;\n+        int pos = token.pos;\n+        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            type = unannotatedType(false);\n+        }\n+\n+        if (token.kind == IDENTIFIER) {\n+            pos = token.pos;\n+            Name name = ident();\n+\n+            \/\/ Method\n+            if (token.kind == LPAREN) {\n+                return List.of(methodDeclaratorRest(pos, mods, type, name, typarams,\n+                        false, isVoid, false, dc));\n+            }\n+\n+            \/\/ Field\n+            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+                List<JCTree> defs =\n+                        variableDeclaratorsRest(pos, mods, type, name, false, dc,\n+                                new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+\n+                return defs;\n+            }\n+        }\n+\n+        throw new AssertionError(\"Not a method or field\");\n+    }\n+\n+    protected boolean isDeclaration() {\n+        return token.kind == CLASS ||\n+               token.kind == INTERFACE ||\n+               token.kind == ENUM ||\n+               isRecordStart() && allowRecords;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":240,"deletions":112,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    private Tokens tokens;\n+    protected Tokens tokens;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCErroneous;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.Error;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Position.LineMap;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The virtual parser allows for speculative parsing while not commiting to\n+ * consuming tokens unless the speculation is successful.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class VirtualParser extends JavacParser {\n+\n+    public VirtualParser(JavacParser parser) {\n+        super(parser, new VirtualScanner(parser.S));\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, Error errorKey) {\n+        throw new AssertionError(\"Speculative parsing fail\");\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+        throw new AssertionError(\"Speculative parsing fail\");\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(int pos, Error errorKey) {\n+        throw new AssertionError(\"Speculative parsing fail\");\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(DiagnosticPosition diagPos, Error errorKey) {\n+        throw new AssertionError(\"Speculative parsing fail\");\n+    }\n+\n+    \/**\n+     * Scanner that does token lookahead and throws AssertionErrors if an error\n+     * occurs.\n+     *\/\n+    public static class VirtualScanner implements Lexer {\n+        \/** Parent scanner.\n+         *\/\n+        Lexer S;\n+\n+        \/** Token offset from where parent scanner branched.\n+         *\/\n+        int offset = 0;\n+\n+        \/** The token, set by nextToken().\n+         *\/\n+        private Token token;\n+\n+        \/** The previous token, set by nextToken().\n+         *\/\n+        private Token prevToken;\n+\n+        public VirtualScanner(Lexer s) {\n+            while (s instanceof VirtualScanner virtualScanner) {\n+                s = virtualScanner.S;\n+                offset += virtualScanner.offset;\n+            }\n+            S = s;\n+            token = s.token();\n+            prevToken = S.prevToken();\n+        }\n+\n+        @Override\n+        public void nextToken() {\n+            prevToken = token;\n+            offset++;\n+            token = token();\n+        }\n+\n+        @Override\n+        public Token token() {\n+            return token(0);\n+        }\n+\n+        @Override\n+        public Token token(int lookahead) {\n+            return S.token(offset + lookahead);\n+        }\n+\n+        @Override\n+        public Token prevToken() {\n+            return prevToken;\n+        }\n+\n+        @Override\n+        public Token split() {\n+            Token[] splitTokens = token.split(((Scanner)S).tokens);\n+            prevToken = splitTokens[0];\n+            token = splitTokens[1];\n+            return token;\n+        }\n+\n+        @Override\n+        public int errPos() {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public void errPos(int pos) {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public LineMap getLineMap() {\n+            return S.getLineMap();\n+        }\n+\n+        public void commit() {\n+            for (int i = 0 ; i < offset ; i++) {\n+                S.nextToken(); \/\/ advance underlying lexer until position matches\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Attempts a parse action and returns true if successful or false if\n+     * a parse error is thrown.\n+     *\n+     * @param parser        parent parser\n+     * @param parserAction  function that takes a parser and invokes a method on that parser\n+     *\n+     * @return true if successful\n+     *\/\n+    public static boolean tryParse(JavacParser parser, Consumer<JavacParser> parserAction) {\n+        VirtualParser virtualParser = new VirtualParser(parser);\n+        try {\n+            parserAction.accept(virtualParser);\n+            return true;\n+        } catch (AssertionError ex) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -512,0 +512,10 @@\n+# 0: string\n+compiler.err.bad.file.name=\\\n+    bad file name: {0}\n+\n+compiler.err.anonymous.main.class.should.not.have.package.declaration=\\\n+    anonymous main class should not have package declaration\n+\n+compiler.err.anonymous.main.class.does.not.have.main.method=\\\n+    anonymous main class does not have main method in the form of void main() or void main(String[] args)\n+\n@@ -3133,0 +3143,3 @@\n+compiler.misc.feature.anonymous.main.classes=\\\n+    anonymous main classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -626,0 +626,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+                || node instanceof JCMethodDecl\n+                || node instanceof JCVariableDecl\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,2 +359,1 @@\n-        return name.subName(\n-            name.lastIndexOf((byte)'.') + 1, name.getByteLength());\n+        return name.subName(start, end);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,1 @@\n+    public final Name main;\n@@ -376,0 +377,1 @@\n+        main = fromString(\"main\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test\n+ * @summary test execution priority of main methods\n+ * @run main OnrampMainTest\n+ *\/\n+public class OnrampMainTest extends TestHelper {\n+\n+    @Test\n+    public void testStaticMainArgs() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                static void main() {\n+                    throw new AssertionError();\n+                }\n+                static void main(String[] args) {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testStaticMain() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+                static void main() {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testMainArgs() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main() {\n+                    throw new AssertionError();\n+                }\n+                void main(String[] args) {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testMain() throws Exception {\n+        test(\"\"\"\n+            class MainClass {\n+                void main() {\n+                }\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonStaticMainArgs() throws Exception {\n+        test(\"\"\"\n+            static void main() {\n+                throw new AssertionError();\n+            }\n+            static void main(String[] args) {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonStaticMain() throws Exception {\n+        test(\"\"\"\n+            void main(String[] args) {\n+                throw new AssertionError();\n+            }\n+            static void main() {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonMainArgs() throws Exception {\n+        test(\"\"\"\n+            void main() {\n+                throw new AssertionError();\n+            }\n+            void main(String[] args) {\n+            }\n+            \"\"\");\n+    }\n+\n+    @Test\n+    public void testTLAnonMain() throws Exception {\n+        test(\"\"\"\n+            void main() {\n+            }\n+            \"\"\");\n+    }\n+\n+    void test(String source) throws Exception {\n+        Files.writeString(Path.of(\"MainClass.java\"), source);\n+        var tr = doExec(javaCmd, \"--enable-preview\", \"--source\", \"21\", \"MainClass.java\");\n+        if (!tr.isOK()) {\n+            System.out.println(tr);\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new OnrampMainTest().run(args);\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/OnrampMainTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -106,1 +106,1 @@\n-        check(numAllMembers, \"#allMembers\", 52);\n+        check(numAllMembers, \"#allMembers\", 58);\n","filename":"test\/langtools\/tools\/javac\/api\/TestJavacTaskScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.anonymous.main.classes\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousMainClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.bad.file.name\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousMainClassBad-Filename.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.anonymous.main.class.should.not.have.package.declaration\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+package anonymous.main.classes;\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousMainClassHasPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.anonymous.main.class.does.not.have.main.method\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public void ordinaryMethod() {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousMainClassNoMain.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -556,1 +556,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotPublic\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}