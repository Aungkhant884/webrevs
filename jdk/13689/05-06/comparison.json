{"files":[{"patch":"@@ -41,2 +41,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n@@ -92,1 +90,0 @@\n-import jdk.internal.vm.annotation.Hidden;\n@@ -850,0 +847,21 @@\n+    \/*\n+     * main type flags\n+     *\/\n+    private static final int MAIN_WITHOUT_ARGS = 1;\n+    private static final int MAIN_NONSTATIC = 2;\n+    private static int mainType = 0;\n+\n+    \/*\n+     * Return type so that launcher invokes the correct main\n+     *\/\n+    public static int getMainType() {\n+        return mainType;\n+    }\n+\n+    private static void setMainType(Method mainMethod) {\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+        mainType = (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n+    }\n+\n@@ -851,1 +869,1 @@\n-    static Method validateMainClass(Class<?> mainClass) {\n+    public static void validateMainClass(Class<?> mainClass) {\n@@ -870,0 +888,2 @@\n+        setMainType(mainMethod);\n+\n@@ -904,35 +924,0 @@\n-\n-        return mainMethod;\n-    }\n-\n-    \/\/ Check the existence and signature of main, abort if incorrect otherwise execute.\n-    @Hidden\n-    static void executeMainClass(Class<?> mainClass, String[] mainArgs) throws Throwable {\n-        Method mainMethod = validateMainClass(mainClass);\n-        int mods = mainMethod.getModifiers();\n-        boolean isStatic = Modifier.isStatic(mods);\n-        boolean noArgs = mainMethod.getParameterCount() == 0;\n-\n-        \/\/ Similar to com.sun.tools.javac.launcher#execute\n-        \/\/ but duplicated here to prevent additional launcher frames\n-        mainMethod.setAccessible(true);\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh = lookup.unreflect(mainMethod);\n-\n-        if (isStatic) {\n-            if (noArgs) {\n-                mh.invokeExact();\n-            } else {\n-                mh.invokeExact(mainArgs);\n-            }\n-        } else {\n-            Constructor<?> constructor = appClass.getDeclaredConstructor();\n-            constructor.setAccessible(true);\n-            Object instance = constructor.newInstance();\n-\n-            if (noArgs) {\n-                mh.invoke(instance);\n-            } else {\n-                mh.invoke(instance, mainArgs);\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -405,0 +405,3 @@\n+    jmethodID mainID;\n+    jmethodID constructor;\n+    jobject mainObject;\n@@ -536,4 +539,4 @@\n-     * The LauncherHelper locates and verifies that the main method has the right\n-     * signature and flags. The LauncherHelper then executes the main method and\n-     * and returns here. If an exception occurs LauncherHelper strips away any\n-     * superfluous frames.\n+     * The LoadMainClass not only loads the main class, it will also ensure\n+     * that the main method's signature is correct, therefore further checking\n+     * is not required. The main method is invoked here so that extraneous java\n+     * stacks are not in the application stack trace.\n@@ -541,0 +544,3 @@\n+#define MAIN_WITHOUT_ARGS 1\n+#define MAIN_NONSTATIC 2\n+\n@@ -542,5 +548,45 @@\n-    jmethodID executeMainClass = (*env)->GetStaticMethodID(env, helperClass,\n-                                                      \"executeMainClass\",\n-                                                      \"(Ljava\/lang\/Class;[Ljava\/lang\/String;)V\");\n-    CHECK_EXCEPTION_NULL_LEAVE(executeMainClass);\n-    (*env)->CallStaticVoidMethod(env, helperClass, executeMainClass, appClass, mainArgs);\n+    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"getMainType\",\n+                                                      \"()I\");\n+    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n+    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n+    CHECK_EXCEPTION_LEAVE(mainType);\n+\n+    switch (mainType) {\n+    case 0: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_WITHOUT_ARGS: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+        break;\n+        }\n+    case MAIN_NONSTATIC: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID);\n+        break;\n+        }\n+    }\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":55,"deletions":9,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.SourceVersion;\n@@ -39,1 +38,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -42,1 +40,0 @@\n-import com.sun.tools.javac.file.PathFileObject;\n@@ -49,1 +46,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -111,2 +107,0 @@\n-    Source source;\n-    Preview preview;\n@@ -138,2 +132,0 @@\n-        source = Source.instance(context);\n-        preview = Preview.instance(context);\n@@ -394,3 +386,0 @@\n-            if (isAnonymousMainClass(tree)) {\n-                constructAnonymousMainClass(tree, source, preview, make, log, names);\n-            }\n@@ -405,3 +394,1 @@\n-\n-\n-    \/\/where:\n+        \/\/where:\n@@ -433,57 +420,0 @@\n-        private static boolean isAnonymousMainClass(JCCompilationUnit tree) {\n-            for (JCTree def : tree.defs) {\n-                if (def.hasTag(Tag.METHODDEF) || def.hasTag(Tag.VARDEF)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-    \/\/ Restructure top level to be an top level anonymous class.\n-    public static void constructAnonymousMainClass(JCCompilationUnit tree,\n-                                                   Source source, Preview preview,\n-                                                   TreeMaker make, Log log, Names names) {\n-        Feature feature = Feature.ANONYMOUS_MAIN_CLASSES;\n-        if (preview.isPreview(feature) && !preview.isEnabled()) {\n-            \/\/preview feature without --preview flag, error\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos, preview.disabledError(feature));\n-        } else if (!feature.allowedInSource(source)) {\n-            \/\/incompatible source level, error\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature)) {\n-            \/\/use of preview feature, warn\n-            preview.warnPreview(tree.pos, feature);\n-        }\n-\n-        make.at(tree.pos);\n-        String simplename = PathFileObject.getSimpleName(tree.sourcefile);\n-        if (simplename.endsWith(\".java\")) {\n-            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n-        }\n-        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n-            log.error(tree.pos, Errors.BadFileName(simplename));\n-        }\n-        Name name = names.fromString(simplename);\n-\n-        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n-        ListBuffer<JCTree> defs = new ListBuffer<>();\n-\n-        for (JCTree def : tree.defs) {\n-            if (def.hasTag(Tag.PACKAGEDEF)) {\n-                log.error(def.pos(), Errors.AnonymousMainClassShouldNotHavePackageDeclaration);\n-            } else if (def.hasTag(Tag.IMPORT)) {\n-                topDefs.append(def);\n-            } else {\n-                defs.append(def);\n-            }\n-        }\n-\n-        JCModifiers anonMods = make.at(tree.pos)\n-                .Modifiers(FINAL|MANDATED|SYNTHETIC|ANONYMOUS_MAIN_CLASS, List.nil());\n-        JCClassDecl anon = make.at(tree.pos).ClassDef(\n-                anonMods, name, List.nil(), null, List.nil(), List.nil(),\n-                defs.toList());\n-        topDefs.append(anon);\n-        tree.defs = topDefs.toList();\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":71,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -66,0 +67,1 @@\n+import javax.lang.model.SourceVersion;\n@@ -3863,0 +3865,1 @@\n+        boolean isAnonymousClass = false;\n@@ -3940,0 +3943,1 @@\n+                    isAnonymousClass = true;\n@@ -3951,1 +3955,2 @@\n-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n+        List<JCTree> topLevelDefs = isAnonymousClass ?  constructAnonymousMainClass(defs.toList()) : defs.toList();\n+        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(topLevelDefs);\n@@ -3965,0 +3970,37 @@\n+    \/\/ Restructure top level to be an top level anonymous class.\n+    private List<JCTree> constructAnonymousMainClass(List<JCTree> origDefs) {\n+        checkSourceLevel(Feature.ANONYMOUS_MAIN_CLASSES);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : origDefs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.AnonymousMainClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else {\n+                defs.append(def);\n+            }\n+        }\n+\n+        int primaryPos = defs.first().pos;\n+        String simplename = PathFileObject.getSimpleName(log.currentSourceFile());\n+\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(primaryPos, Errors.BadFileName(simplename));\n+        }\n+\n+        Name name = names.fromString(simplename);\n+        JCModifiers anonMods = F.at(primaryPos)\n+                .Modifiers(Flags.FINAL|Flags.MANDATED|Flags.SYNTHETIC|Flags.ANONYMOUS_MAIN_CLASS, List.nil());\n+        JCClassDecl anon = F.at(primaryPos).ClassDef(\n+                anonMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(anon);\n+        return topDefs.toList();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"}]}