{"files":[{"patch":"@@ -101,0 +101,1 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -75,0 +76,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -84,0 +86,1 @@\n+\n@@ -160,1 +163,2 @@\n- * <p> A class or interface created by the invocation of\n+ * <h2><a id=hiddenClasses>Hidden Classes<\/a><\/h2>\n+ * A class or interface created by the invocation of\n@@ -188,0 +192,25 @@\n+ * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n+ *\n+ * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n+ * is generated by a Java compiler from a source file for an unnamed class.\n+ * The {@code Class} object representing an unnamed class is top-level,\n+ * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n+ * unnamed class does <em>not<\/em> have a name in its Java source\n+ * form, several of the name-related methods of {@code java.lang.Class}\n+ * do return non-null and non-empty results for the {@code Class}\n+ * object representing an unnamed class.\n+ *\n+ * Conventionally, a Java compiler, starting from a source file for an\n+ * unnamed class, say {@code HelloWorld.java}, creates a\n+ * similarly-named {@code class} file, {@code HelloWorld.class}, where\n+ * the class stored in that {@code class} file is named {@code\n+ * \"HelloWorld\"}, matching the base names of the source and {@code\n+ * class} files.\n+ *\n+ * For the {@code Class} object of an unnamed class {@code\n+ * HelloWorld}, the methods to get the {@linkplain #getName name} and\n+ * {@linkplain #getTypeName type name} return results\n+ * equal to {@code \"HelloWorld\"}. The {@linkplain #getSimpleName\n+ * simple name} of such an unnamed class is the empty string and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ *\n@@ -1720,1 +1749,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous}.\n+     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n@@ -1733,0 +1762,3 @@\n+        if (isUnnamedClass()) {\n+            return \"\";\n+        }\n@@ -1782,0 +1814,1 @@\n+     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1801,0 +1834,3 @@\n+        if (isUnnamedClass()) {\n+            return null;\n+        }\n@@ -1835,0 +1871,20 @@\n+    \/**\n+     * {@return {@code true} if and only if the underlying class\n+     * is an unnamed class}\n+     *\n+     * @apiNote\n+     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n+     *\n+     * @since 21\n+     *\n+     * @jls 7.3 Compilation Units\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    public boolean isUnnamedClass() {\n+        return PreviewFeatures.isEnabled() && isSynthetic()\n+                                           && isTopLevelClass()\n+                                           && Modifier.isFinal(getModifiers());\n+    }\n+\n+\n@@ -1841,0 +1897,1 @@\n+     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\")\n+        UNNAMED_CLASSES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MainMethodFinder {\n+    private static boolean correctArgs(Method method) {\n+        int argc = method.getParameterCount();\n+\n+        return argc == 0 || argc == 1 && method.getParameterTypes()[0] == String[].class;\n+    }\n+\n+    \/**\n+     * Gather all the \"main\" methods in the class hierarchy.\n+     *\n+     * @param refc         the main class or super class\n+     * @param mains        accumulated main methods\n+     * @param isMainClass  the class is the main class and not a super class\n+     *\/\n+    private static void gatherMains(Class<?> refc, List<Method> mains, boolean isMainClass) {\n+        if (refc != null && refc != Object.class) {\n+            for (Method method : refc.getDeclaredMethods()) {\n+                int mods = method.getModifiers();\n+                \/\/ Must be named \"main\", public|protected|package-private, not synthetic (bridge) and either\n+                \/\/ no arguments or one string array argument. Only statics in the Main class are acceptable.\n+                if (\"main\".equals(method.getName()) &&\n+                        !method.isSynthetic() &&\n+                        !Modifier.isPrivate(mods) &&\n+                        correctArgs(method) &&\n+                        (isMainClass || !Modifier.isStatic(mods)))\n+                {\n+                    mains.add(method);\n+                }\n+            }\n+\n+            gatherMains(refc.getSuperclass(), mains, false);\n+        }\n+    }\n+\n+    \/**\n+     * Comparator for two methods.\n+     * Priority order is;\n+     * sub-class < super-class.\n+     * static < non-static,\n+     * string arg < no arg and\n+     *\n+     * @param a  first method\n+     * @param b  second method\n+     *\n+     * @return -1, 0 or 1 to represent higher priority. equals priority or lesser priority.\n+     *\/\n+    private static int compareMethods(Method a, Method b) {\n+        Class<?> aClass = a.getDeclaringClass();\n+        Class<?> bClass = b.getDeclaringClass();\n+\n+        if (aClass != bClass) {\n+            if (bClass.isAssignableFrom(aClass)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        }\n+\n+        int aMods = a.getModifiers();\n+        int bMods = b.getModifiers();\n+        boolean aIsStatic = Modifier.isStatic(aMods);\n+        boolean bIsStatic = Modifier.isStatic(bMods);\n+\n+        if (aIsStatic && !bIsStatic) {\n+            return -1;\n+        } else if (!aIsStatic && bIsStatic) {\n+            return 1;\n+        }\n+\n+        int aCount = a.getParameterCount();\n+        int bCount = b.getParameterCount();\n+\n+        if (bCount < aCount) {\n+            return -1;\n+        } else if (aCount < bCount) {\n+            return 1;\n+        }\n+\n+        return 0;\n+    }\n+\n+    \/**\n+     * Return the traditional main method or null if not found.\n+     *\n+     * @param mainClass main class\n+     *\n+     * @return main method or null\n+     *\/\n+    private static Method getTraditionalMain(Class<?> mainClass) {\n+        try {\n+            Method traditionalMain = mainClass.getMethod(\"main\", String[].class);\n+            int mods = traditionalMain.getModifiers();\n+\n+            if (Modifier.isStatic(mods) && Modifier.isPublic(mods) && traditionalMain.getReturnType() == void.class) {\n+                return traditionalMain;\n+            }\n+        } catch (NoSuchMethodException ex) {\n+            \/\/ not found\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return priority main method if none found}\n+     *\n+     * @param mainClass main class\n+     *\n+     * @throws NoSuchMethodException when not preview and no method found\n+     *\/\n+    public static Method findMainMethod(Class<?> mainClass) throws NoSuchMethodException {\n+        boolean isTraditionMain = !PreviewFeatures.isEnabled();\n+        if (isTraditionMain) {\n+            return mainClass.getMethod(\"main\", String[].class);\n+        }\n+\n+        List<Method> mains = new ArrayList<>();\n+        gatherMains(mainClass, mains, true);\n+\n+        if (mains.isEmpty()) {\n+            throw new NoSuchMethodException(\"No main method found\");\n+        }\n+\n+        if (1 < mains.size()) {\n+            mains.sort(MainMethodFinder::compareMethods);\n+        }\n+\n+        Method mainMethod = mains.get(0);\n+        Method traditionalMain = getTraditionalMain(mainClass);\n+\n+        if (traditionalMain != null && !traditionalMain.equals(mainMethod)) {\n+            System.err.println(\"WARNING: \\\"\" + mains.get(0) + \"\\\" chosen over \\\"\" + traditionalMain + \"\\\"\");\n+        }\n+\n+        return mains.get(0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/MainMethodFinder.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+import java.lang.reflect.Constructor;\n@@ -63,0 +64,1 @@\n+import java.util.Arrays;\n@@ -81,0 +83,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -846,0 +850,21 @@\n+    \/*\n+     * main type flags\n+     *\/\n+    private static final int MAIN_WITHOUT_ARGS = 1;\n+    private static final int MAIN_NONSTATIC = 2;\n+    private static int mainType = 0;\n+\n+    \/*\n+     * Return type so that launcher invokes the correct main\n+     *\/\n+    public static int getMainType() {\n+        return mainType;\n+    }\n+\n+    private static void setMainType(Method mainMethod) {\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+        mainType = (isStatic ? 0 : MAIN_NONSTATIC) | (noArgs ? MAIN_WITHOUT_ARGS : 0);\n+    }\n+\n@@ -850,1 +875,1 @@\n-            mainMethod = mainClass.getMethod(\"main\", String[].class);\n+            mainMethod = MainMethodFinder.findMainMethod(mainClass);\n@@ -858,2 +883,2 @@\n-                      mainClass.getName(), mainClass.getModule().getName(),\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        mainClass.getName(), mainClass.getModule().getName(),\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -862,1 +887,1 @@\n-                      e.getClass().getName(), e.getLocalizedMessage());\n+                        e.getClass().getName(), e.getLocalizedMessage());\n@@ -866,0 +891,2 @@\n+        setMainType(mainMethod);\n+\n@@ -867,1 +894,1 @@\n-         * getMethod (above) will choose the correct method, based\n+         * findMainMethod (above) will choose the correct method, based\n@@ -869,1 +896,1 @@\n-         * ensure that the method is static and returns a void.\n+         * ensure that the method is static (non-preview) and returns a void.\n@@ -871,4 +898,10 @@\n-        int mod = mainMethod.getModifiers();\n-        if (!Modifier.isStatic(mod)) {\n-            abort(null, \"java.launcher.cls.error2\", \"static\",\n-                  mainMethod.getDeclaringClass().getName());\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled()) {\n+            if (!isStatic || !isPublic || noArgs) {\n+                abort(null, \"java.launcher.cls.error2\", \"static\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n@@ -876,0 +909,18 @@\n+\n+        if (!isStatic) {\n+            if (mainClass.isMemberClass() && !Modifier.isStatic(mainClass.getModifiers())) {\n+                abort(null, \"java.launcher.cls.error9\",\n+                        mainMethod.getDeclaringClass().getName());\n+            }\n+            try {\n+                Constructor<?> constructor = mainClass.getDeclaredConstructor();\n+                if (Modifier.isPrivate(constructor.getModifiers())) {\n+                    abort(null, \"java.launcher.cls.error8\",\n+                          mainMethod.getDeclaringClass().getName());\n+                }\n+            } catch (Throwable ex) {\n+                abort(null, \"java.launcher.cls.error8\",\n+                      mainMethod.getDeclaringClass().getName());\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":61,"deletions":10,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,7 @@\n+java.launcher.cls.error8=\\\n+    Error: no non-private zero argument constructor found in class {0}\\n\\\n+    remove private from existing constructor or define as:\\n\\\n+\\   public {0}()\n+java.launcher.cls.error9=\\\n+    Error: non-static inner class {0} constructor can not be invoked \\n\\\n+    make inner class static or move inner class out to separate source file\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -404,1 +404,0 @@\n-    jmethodID mainID;\n@@ -406,0 +405,3 @@\n+    jmethodID mainID;\n+    jmethodID constructor;\n+    jobject mainObject;\n@@ -542,6 +544,49 @@\n-    mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n-                                       \"([Ljava\/lang\/String;)V\");\n-    CHECK_EXCEPTION_NULL_LEAVE(mainID);\n-\n-    \/* Invoke main method. *\/\n-    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+#define MAIN_WITHOUT_ARGS 1\n+#define MAIN_NONSTATIC 2\n+\n+    jclass helperClass = GetLauncherHelperClass(env);\n+    jmethodID getMainType = (*env)->GetStaticMethodID(env, helperClass,\n+                                                      \"getMainType\",\n+                                                      \"()I\");\n+    CHECK_EXCEPTION_NULL_LEAVE(getMainType);\n+    int mainType = (*env)->CallStaticIntMethod(env, helperClass, getMainType);\n+    CHECK_EXCEPTION_LEAVE(mainType);\n+\n+    switch (mainType) {\n+    case 0: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_WITHOUT_ARGS: {\n+        mainID = (*env)->GetStaticMethodID(env, mainClass, \"main\",\n+                                           \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallStaticVoidMethod(env, mainClass, mainID);\n+        break;\n+        }\n+    case MAIN_NONSTATIC: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"([Ljava\/lang\/String;)V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID, mainArgs);\n+        break;\n+        }\n+    case MAIN_NONSTATIC | MAIN_WITHOUT_ARGS: {\n+        constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(constructor);\n+        mainObject = (*env)->NewObject(env, mainClass, constructor);\n+        CHECK_EXCEPTION_NULL_LEAVE(mainObject);\n+        mainID = (*env)->GetMethodID(env, mainClass, \"main\",\n+                                     \"()V\");\n+        CHECK_EXCEPTION_NULL_LEAVE(mainID);\n+        (*env)->CallVoidMethod(env, mainObject, mainID);\n+        break;\n+        }\n+    }\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javax.lang.model.element.TypeElement;\n@@ -179,0 +180,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createSourceFile(\"Foo\")}\n+     * to create an unnamed class hosted in {@code Foo.java}. All\n+     * unnamed classes must be in an unnamed package.\n+     *\n@@ -258,0 +266,7 @@\n+     * <p>If the environment is configured to support {@linkplain\n+     * TypeElement#isUnnamed unnamed classes}, the name argument is\n+     * used to provide the leading component of the name used for the\n+     * output file. For example {@code filer.createClassFile(\"Foo\")} to\n+     * create an unnamed class hosted in {@code Foo.class}. All unnamed\n+     * classes must be in an unnamed package.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -150,1 +152,1 @@\n-     * For local and anonymous classes, which do not have canonical\n+     * For local, anonymous, and {@linkplain #isUnnamed() unnamed} classes, which do not have canonical\n@@ -166,0 +168,1 @@\n+     * @jls 7.3 Compilation Units\n@@ -175,0 +178,4 @@\n+     * For an {@linkplain #isUnnamed() unnamed} class, a name matching\n+     * the base name of the hosting file, minus any extension, is\n+     * returned.\n+     *\n@@ -182,0 +189,16 @@\n+    \/**\n+     * {@return {@code true} if this is an unnamed class and {@code\n+     * false} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns {@code false}.\n+     *\n+     * @jls 7.3 Compilation Units\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    default boolean isUnnamed() {\n+        return false;\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -447,0 +447,3 @@\n+                if ((c.flags_field & UNNAMED_CLASS) != 0) {\n+                    syms.removeClass(ps.modle, flatname);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,4 @@\n+    \/** Class is a unnamed top level class.\n+     *\/\n+    public static final int UNNAMED_CLASS    = 1<<19;\n+\n@@ -493,0 +497,1 @@\n+        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case UNNAMED_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,0 +241,1 @@\n+        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1259,0 +1259,1 @@\n+    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1370,4 +1371,9 @@\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public Name getQualifiedName() {\n-            return fullname;\n-        }\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getQualifiedName() {\n+             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+         }\n+\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getSimpleName() {\n+             return name;\n+         }\n@@ -1548,1 +1554,1 @@\n-            if (owner.kind == PCK)\n+            if (owner.kind == PCK) \/\/ Should handle unnamed classes too\n@@ -1639,0 +1645,5 @@\n+\n+        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+        public boolean isUnnamed() {\n+            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -5514,0 +5514,4 @@\n+\n+                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                    chk.checkHasMain(env.tree.pos(), c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2253,0 +2253,30 @@\n+    public void checkHasMain(DiagnosticPosition pos, ClassSymbol c) {\n+        boolean found = false;\n+\n+        for (Symbol sym : c.members().getSymbolsByName(names.main)) {\n+            if (sym.kind == MTH && (sym.flags() & PRIVATE) == 0) {\n+                MethodSymbol meth = (MethodSymbol)sym;\n+                if (!types.isSameType(meth.getReturnType(), syms.voidType)) {\n+                    continue;\n+                }\n+                if (meth.params.isEmpty()) {\n+                    found = true;\n+                    break;\n+                }\n+                if (meth.params.size() != 1) {\n+                    continue;\n+                }\n+                if (!types.isSameType(meth.params.head.type, types.makeArrayType(syms.stringType))) {\n+                    continue;\n+                }\n+\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) {\n+            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,2 +311,0 @@\n-\/\/        Assert.checkNonNull(tree.modle, tree.sourcefile.toString());\n-\n@@ -444,0 +442,3 @@\n+            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+                syms.removeClass(env.toplevel.modle, tree.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -68,1 +67,0 @@\n-import java.util.function.Consumer;\n@@ -2435,1 +2433,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2733,0 +2733,5 @@\n+        if (previewClassFile) {\n+            if ((c.flags_field & SYNTHETIC) != 0 && c.isSubClass(syms.objectType.tsym, types)) {\n+                c.flags_field |= UNNAMED_CLASS;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.reflect.Constructor;\n@@ -87,0 +88,2 @@\n+import jdk.internal.misc.MainMethodFinder;\n+import jdk.internal.misc.PreviewFeatures;\n@@ -204,2 +207,2 @@\n-        String[] appArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, appArgs, context);\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        execute(mainClassName, mainArgs, context);\n@@ -406,1 +409,3 @@\n-        String mainClassName = l.mainClass.getQualifiedName().toString();\n+        TypeElement mainClass = l.mainClass;\n+        String mainClassName = (mainClass.isUnnamed() ? mainClass.getSimpleName()\n+                                                      : mainClass.getQualifiedName()).toString();\n@@ -415,1 +420,1 @@\n-     * @param appArgs the arguments for the {@code main} method\n+     * @param mainArgs the arguments for the {@code main} method\n@@ -420,1 +425,1 @@\n-    private void execute(String mainClassName, String[] appArgs, Context context)\n+    private void execute(String mainClassName, String[] mainArgs, Context context)\n@@ -424,0 +429,2 @@\n+\n+        Class<?> appClass;\n@@ -425,11 +432,1 @@\n-            Class<?> appClass = Class.forName(mainClassName, true, cl);\n-            Method main = appClass.getDeclaredMethod(\"main\", String[].class);\n-            int PUBLIC_STATIC = Modifier.PUBLIC | Modifier.STATIC;\n-            if ((main.getModifiers() & PUBLIC_STATIC) != PUBLIC_STATIC) {\n-                throw new Fault(Errors.MainNotPublicStatic);\n-            }\n-            if (!main.getReturnType().equals(void.class)) {\n-                throw new Fault(Errors.MainNotVoid);\n-            }\n-            main.setAccessible(true);\n-            main.invoke(0, (Object) appArgs);\n+            appClass = Class.forName(mainClassName, true, cl);\n@@ -438,0 +435,5 @@\n+        }\n+\n+        Method mainMethod;\n+        try {\n+            mainMethod = MainMethodFinder.findMainMethod(appClass);\n@@ -440,0 +442,44 @@\n+        }\n+\n+        int mods = mainMethod.getModifiers();\n+        boolean isStatic = Modifier.isStatic(mods);\n+        boolean isPublic = Modifier.isPublic(mods);\n+        boolean noArgs = mainMethod.getParameterCount() == 0;\n+\n+        if (!PreviewFeatures.isEnabled() && (!isStatic || !isPublic)) {\n+            throw new Fault(Errors.MainNotPublicStatic);\n+        }\n+\n+        if (!mainMethod.getReturnType().equals(void.class)) {\n+            throw new Fault(Errors.MainNotVoid);\n+        }\n+\n+        Object instance = null;\n+\n+        if (!isStatic) {\n+            Constructor<?> constructor;\n+            try {\n+                constructor = appClass.getDeclaredConstructor();\n+            } catch (NoSuchMethodException e) {\n+                throw new Fault(Errors.CantFindConstructor(mainClassName));\n+            }\n+\n+            try {\n+                constructor.setAccessible(true);\n+                instance = constructor.newInstance();\n+            } catch (InstantiationException | IllegalAccessException e) {\n+                throw new Fault(Errors.CantAccessConstructor(mainClassName));\n+            }\n+        }\n+\n+        try {\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+            Object receiver = isStatic ? appClass : instance;\n+\n+            if (noArgs) {\n+                mainMethod.invoke(receiver);\n+            } else {\n+                mainMethod.invoke(receiver, (Object)mainArgs);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":63,"deletions":17,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import javax.lang.model.SourceVersion;\n+\n@@ -39,0 +41,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -185,1 +188,1 @@\n-        docComments = newDocCommentTable(keepDocComments, fac);\n+        this.docComments = newDocCommentTable(keepDocComments, fac);\n@@ -188,1 +191,24 @@\n-        endPosTable = newEndPosTable(keepEndPositions);\n+        this.endPosTable = newEndPosTable(keepEndPositions);\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n+    }\n+\n+    \/** Construct a parser from an existing parser, with minimal overhead.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected JavacParser(JavacParser parser,\n+                          Lexer S) {\n+        this.S = S;\n+        this.token = parser.token;\n+        this.F = parser.F;\n+        this.log = parser.log;\n+        this.names = parser.names;\n+        this.source = parser.source;\n+        this.preview = parser.preview;\n+        this.allowStringFolding = parser.allowStringFolding;\n+        this.keepDocComments = false;\n+        this.parseModuleInfo = false;\n+        this.docComments = null;\n+        this.errorTree = F.Erroneous();\n+        this.endPosTable = newEndPosTable(false);\n@@ -2797,4 +2823,1 @@\n-            if (token.kind == INTERFACE ||\n-                token.kind == CLASS ||\n-                token.kind == ENUM ||\n-                isRecordStart()) {\n+            if (isDeclaration()) {\n@@ -3894,0 +3917,1 @@\n+        boolean isUnnamedClass = false;\n@@ -3952,0 +3976,1 @@\n+\n@@ -3953,4 +3978,29 @@\n-                JCTree def = typeDeclaration(mods, docComment);\n-                if (def instanceof JCExpressionStatement statement)\n-                    def = statement.expr;\n-                defs.append(def);\n+                boolean isTopLevelMethodOrField = false;\n+\n+                \/\/ Do to a significant number of existing negative tests\n+                \/\/ this code speculatively tests to see if a top level method\n+                \/\/ or field can parse. If the method or field can parse then\n+                \/\/ it is parsed. Otherwise, parsing continues as though\n+                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ is the same as in the past.\n+                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                    final JCModifiers finalMods = mods;\n+                    JavacParser speculative = new VirtualParser(this);\n+                    List<JCTree> speculativeResult =\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                    if (speculativeResult.head.hasTag(METHODDEF) ||\n+                        speculativeResult.head.hasTag(VARDEF)) {\n+                        isTopLevelMethodOrField = true;\n+                    }\n+                }\n+\n+                if (isTopLevelMethodOrField) {\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n+                    isUnnamedClass = true;\n+                } else {\n+                    JCTree def = typeDeclaration(mods, docComment);\n+                    if (def instanceof JCExpressionStatement statement)\n+                        def = statement.expr;\n+                    defs.append(def);\n+                }\n+\n@@ -3961,1 +4011,2 @@\n-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n+        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(topLevelDefs);\n@@ -3975,0 +4026,37 @@\n+    \/\/ Restructure top level to be an unnamed class.\n+    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+        checkSourceLevel(Feature.UNNAMED_CLASSES);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : origDefs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else if (!def.hasTag(Tag.SKIP)) {\n+                defs.append(def);\n+            }\n+        }\n+\n+        int primaryPos = defs.first().pos;\n+        String simplename = PathFileObject.getSimpleName(log.currentSourceFile());\n+\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(primaryPos, Errors.BadFileName(simplename));\n+        }\n+\n+        Name name = names.fromString(simplename);\n+        JCModifiers anonMods = F.at(primaryPos)\n+                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n+        JCClassDecl anon = F.at(primaryPos).ClassDef(\n+                anonMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(anon);\n+        return topDefs.toList();\n+    }\n+\n@@ -4135,1 +4223,2 @@\n-            final JCErroneous erroneousTree;\n+\n+            JCDiagnostic.Error error;\n@@ -4137,1 +4226,3 @@\n-                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                error = Errors.ExpectedModuleOrOpen;\n+            } else if (allowRecords) {\n+                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n@@ -4139,5 +4230,1 @@\n-                if (allowRecords) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                } else {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                }\n+                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n@@ -4145,1 +4232,2 @@\n-            return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(syntaxError(pos, errs, error)));\n+\n@@ -4366,1 +4454,1 @@\n-                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,\n+                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, enumName,\n@@ -4472,1 +4560,1 @@\n-            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));\n+            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, className, isInterface, isRecord));\n@@ -4476,1 +4564,1 @@\n-           }\n+            }\n@@ -4511,1 +4599,3 @@\n-    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {\n+    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(JCModifiers mods, Name className,\n+                                                                   boolean isInterface,\n+                                                                   boolean isRecord) {\n@@ -4518,5 +4608,2 @@\n-            JCModifiers mods = modifiersOpt();\n-            if (token.kind == CLASS ||\n-                allowRecords && isRecordStart() ||\n-                token.kind == INTERFACE ||\n-                token.kind == ENUM) {\n+            mods = modifiersOpt(mods);\n+            if (isDeclaration()) {\n@@ -4534,9 +4621,4 @@\n-                pos = token.pos;\n-                List<JCTypeParameter> typarams = typeParametersOpt();\n-                \/\/ if there are type parameters but no modifiers, save the start\n-                \/\/ position of the method in the modifiers.\n-                if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n-                    mods.pos = pos;\n-                    storeEnd(mods, pos);\n-                }\n-                List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+                return constructorOrMethodOrFieldDeclaration(mods, className, isInterface, isRecord, dc);\n+            }\n+        }\n+    }\n@@ -4544,5 +4626,13 @@\n-                if (annosAfterParams.nonEmpty()) {\n-                    mods.annotations = mods.annotations.appendList(annosAfterParams);\n-                    if (mods.pos == Position.NOPOS)\n-                        mods.pos = mods.annotations.head.pos;\n-                }\n+    private List<JCTree> constructorOrMethodOrFieldDeclaration(JCModifiers mods, Name className,\n+                                                               boolean isInterface,\n+                                                               boolean isRecord, Comment dc) {\n+        int pos;\n+        pos = token.pos;\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n@@ -4550,71 +4640,147 @@\n-                Token tk = token;\n-                pos = token.pos;\n-                JCExpression type;\n-                boolean isVoid = token.kind == VOID;\n-                if (isVoid) {\n-                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n-                    nextToken();\n-                } else {\n-                    \/\/ method returns types are un-annotated types\n-                    type = unannotatedType(false);\n-                }\n-                if ((token.kind == LPAREN && !isInterface ||\n-                        isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n-                    if (isInterface || tk.name() != className)\n-                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n-                    else if (annosAfterParams.nonEmpty())\n-                        illegal(annosAfterParams.head.pos);\n-                    if (isRecord && token.kind == LBRACE) {\n-                        mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n-                    }\n-                    return List.of(methodDeclaratorRest(\n-                        pos, mods, null, names.init, typarams,\n-                        isInterface, true, isRecord, dc));\n-                } else if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n-                    \/\/ trying to define a compact constructor with a throws clause\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                            Errors.InvalidCanonicalConstructorInRecord(\n-                                    Fragments.Compact,\n-                                    className,\n-                                    Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n-                    skip(false, true, false, false);\n-                    return List.of(methodDeclaratorRest(\n-                            pos, mods, null, names.init, typarams,\n-                            isInterface, true, isRecord, dc));\n-                } else {\n-                    pos = token.pos;\n-                    Name name = ident();\n-                    if (token.kind == LPAREN) {\n-                        return List.of(methodDeclaratorRest(\n-                            pos, mods, type, name, typarams,\n-                            isInterface, isVoid, false, dc));\n-                    } else if (!isVoid && typarams.isEmpty()) {\n-                        if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n-                        List<JCTree> defs =\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                                    new ListBuffer<JCTree>(), false).toList();\n-                        accept(SEMI);\n-                        storeEnd(defs.last(), S.prevToken().endPos);\n-                        return defs;\n-                    } else {\n-                            int errPos = pos;\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                    new ListBuffer<JCTree>(), false).toList();\n-                            accept(SEMI);\n-                            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n-                        }\n-                    } else {\n-                        pos = token.pos;\n-                        List<JCTree> err;\n-                        if (isVoid || typarams.nonEmpty()) {\n-                            JCMethodDecl m =\n-                                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n-                                                            List.nil(), List.nil(), null, null));\n-                            attach(m, dc);\n-                            err = List.of(m);\n-                        } else {\n-                            err = List.nil();\n-                        }\n-                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n-                    }\n-                }\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        Token tk = token;\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            \/\/ method returns types are un-annotated types\n+            type = unannotatedType(false);\n+        }\n+\n+        \/\/ Constructor\n+        if ((token.kind == LPAREN && !isInterface ||\n+                isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n+            if (isInterface || tk.name() != className) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+            } else if (annosAfterParams.nonEmpty()) {\n+                illegal(annosAfterParams.head.pos);\n+            }\n+\n+            if (isRecord && token.kind == LBRACE) {\n+                mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n+            }\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        \/\/ Record constructor\n+        if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n+            \/\/ trying to define a compact constructor with a throws clause\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.InvalidCanonicalConstructorInRecord(\n+                            Fragments.Compact,\n+                            className,\n+                            Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n+            skip(false, true, false, false);\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        pos = token.pos;\n+        Name name = ident();\n+\n+        \/\/ Method\n+        if (token.kind == LPAREN) {\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, type, name, typarams,\n+                    isInterface, isVoid, false, dc));\n+        }\n+\n+        \/\/ Field\n+        if (!isVoid && typarams.isEmpty()) {\n+            if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n+                List<JCTree> defs =\n+                    variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                                            new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+                return defs;\n+            }\n+\n+            int errPos = pos;\n+            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                    new ListBuffer<JCTree>(), false).toList();\n+            accept(SEMI);\n+            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n+         }\n+\n+         pos = token.pos;\n+         List<JCTree> err;\n+\n+         \/\/ Error recovery\n+         if (isVoid || typarams.nonEmpty()) {\n+             JCMethodDecl m =\n+                     toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                                             List.nil(), List.nil(), null, null));\n+             attach(m, dc);\n+             err = List.of(m);\n+         } else {\n+             err = List.nil();\n+         }\n+\n+         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n+    }\n+\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n+        int topPos = token.pos;\n+        int pos = token.pos;\n+        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            type = unannotatedType(false);\n+        }\n+\n+        if (token.kind == IDENTIFIER) {\n+            pos = token.pos;\n+            Name name = ident();\n+\n+            \/\/ Method\n+            if (token.kind == LPAREN) {\n+                return List.of(methodDeclaratorRest(pos, mods, type, name, typarams,\n+                        false, isVoid, false, dc));\n+            }\n+\n+            \/\/ Field\n+            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+                List<JCTree> defs =\n+                        variableDeclaratorsRest(pos, mods, type, name, false, dc,\n+                                new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+\n+                return defs;\n@@ -4623,0 +4789,2 @@\n+\n+        return List.of(F.Erroneous());\n@@ -4625,0 +4793,7 @@\n+    protected boolean isDeclaration() {\n+        return token.kind == CLASS ||\n+               token.kind == INTERFACE ||\n+               token.kind == ENUM ||\n+               isRecordStart() && allowRecords;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":288,"deletions":113,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private final Tokens tokens;\n+    protected Tokens tokens;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCErroneous;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.Error;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Position.LineMap;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The virtual parser allows for speculative parsing while not commiting to\n+ * consuming tokens unless the speculation is successful.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class VirtualParser extends JavacParser {\n+\n+    private boolean hasErrors;\n+\n+    public VirtualParser(JavacParser parser) {\n+        super(parser, new VirtualScanner(parser.S));\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+        hasErrors = true;\n+        return F.Erroneous();\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(int pos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    @Override\n+    protected void reportSyntaxError(DiagnosticPosition diagPos, Error errorKey) {\n+        hasErrors = true;\n+    }\n+\n+    public boolean hasErrors() {\n+        return hasErrors;\n+    }\n+\n+    \/**\n+     * Scanner that does token lookahead and throws AssertionErrors if an error\n+     * occurs.\n+     *\/\n+    public static class VirtualScanner implements Lexer {\n+        \/** Parent scanner.\n+         *\/\n+        Lexer S;\n+\n+        \/** Token offset from where parent scanner branched.\n+         *\/\n+        int offset = 0;\n+\n+        \/** The token, set by nextToken().\n+         *\/\n+        private Token token;\n+\n+        \/** The previous token, set by nextToken().\n+         *\/\n+        private Token prevToken;\n+\n+        public VirtualScanner(Lexer s) {\n+            while (s instanceof VirtualScanner virtualScanner) {\n+                s = virtualScanner.S;\n+                offset += virtualScanner.offset;\n+            }\n+            S = s;\n+            token = s.token();\n+            prevToken = S.prevToken();\n+        }\n+\n+        @Override\n+        public void nextToken() {\n+            prevToken = token;\n+            offset++;\n+            token = token();\n+        }\n+\n+        @Override\n+        public Token token() {\n+            return token(0);\n+        }\n+\n+        @Override\n+        public Token token(int lookahead) {\n+            return S.token(offset + lookahead);\n+        }\n+\n+        @Override\n+        public Token prevToken() {\n+            return prevToken;\n+        }\n+\n+        @Override\n+        public void setPrevToken(Token prevToken) {\n+            this.prevToken = prevToken;\n+        }\n+\n+        @Override\n+        public Token split() {\n+            Token[] splitTokens = token.split(((Scanner)S).tokens);\n+            prevToken = splitTokens[0];\n+            token = splitTokens[1];\n+            return token;\n+        }\n+\n+        @Override\n+        public int errPos() {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public void errPos(int pos) {\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        public LineMap getLineMap() {\n+            return S.getLineMap();\n+        }\n+\n+        public void commit() {\n+            for (int i = 0 ; i < offset ; i++) {\n+                S.nextToken(); \/\/ advance underlying lexer until position matches\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Attempts a parse action and returns true if successful or false if\n+     * a parse error is thrown.\n+     *\n+     * @param parser        parent parser\n+     * @param parserAction  function that takes a parser and invokes a method on that parser\n+     *\n+     * @return true if successful\n+     *\/\n+    public static boolean tryParse(JavacParser parser, Consumer<JavacParser> parserAction) {\n+        VirtualParser virtualParser = new VirtualParser(parser);\n+        try {\n+            parserAction.accept(virtualParser);\n+            return true;\n+        } catch (AssertionError ex) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -121,0 +121,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -128,1 +129,1 @@\n-                \/\/ Don't print out the constructor of an anonymous class\n+                \/\/ Don't print out the constructor of an anonymous or unnamed class\n@@ -131,1 +132,1 @@\n-                    NestingKind.ANONYMOUS ==\n+                    (NestingKind.ANONYMOUS ==\n@@ -138,1 +139,8 @@\n-                    }).visit(enclosing))\n+                    }).visit(enclosing)\n+                    || \/\/ Don't print the constructor of an unnamed class\n+                    (new SimpleElementVisitor14<Boolean, Void>(false) {\n+                        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+                        public Boolean visitType(TypeElement e, Void p) {\n+                            return e.isUnnamed();\n+                        }\n+                    }).visit(enclosing)) ) {\n@@ -140,0 +148,1 @@\n+                }\n@@ -172,0 +181,1 @@\n+        @SuppressWarnings(\"preview\") \/\/ isUnnamed\n@@ -205,0 +215,8 @@\n+            } else if (e.isUnnamed()) {\n+                writer.println(\"\/\/ Unnamed class in file whose name starts with \" + e.getQualifiedName());\n+\n+                for(Element element : e.getEnclosedElements()) {\n+                    this.visit(element);\n+                }\n+\n+                return this;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,0 +515,10 @@\n+# 0: string\n+compiler.err.bad.file.name=\\\n+    bad file name: {0}\n+\n+compiler.err.unnamed.class.should.not.have.package.declaration=\\\n+    unnamed class should not have package declaration\n+\n+compiler.err.unnamed.class.does.not.have.main.method=\\\n+    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+\n@@ -3161,0 +3171,3 @@\n+compiler.misc.feature.unnamed.classes=\\\n+    unnamed classes\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -122,0 +122,8 @@\n+# 0: string\n+launcher.err.cant.find.constructor=\\\n+    can''t find no argument constructor in class: {0}\n+\n+# 0: string\n+launcher.err.cant.access.constructor=\\\n+    can''t access no argument constructor in class: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -630,0 +630,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+                || node instanceof JCMethodDecl\n+                || node instanceof JCVariableDecl\n@@ -1162,1 +1164,1 @@\n-        return false;\n+        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,2 +359,1 @@\n-        return name.subName(\n-            name.lastIndexOf((byte)'.') + 1, name.getByteLength());\n+        return name.subName(start, end);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Convert.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,1 @@\n+    public final Name main;\n@@ -391,0 +392,1 @@\n+        main = fromString(\"main\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test\n+ * @summary test execution priority of main methods\n+ * @run main InstanceMainTest\n+ *\/\n+public class InstanceMainTest extends TestHelper {\n+\n+    private static final String[] SOURCES = new String[] {\n+            \/\/ static dominating with args\n+            \"\"\"\n+            class MainClass {\n+                static void main() {\n+                    throw new AssertionError();\n+                }\n+                static void main(String[] args) {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ static dominating instance\n+            \"\"\"\n+            class MainClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+                static void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ instance dominating with args\n+            \"\"\"\n+            class MainClass {\n+                void main() {\n+                    throw new AssertionError();\n+                }\n+                void main(String[] args) {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ instance no args\n+            \"\"\"\n+            class MainClass {\n+                void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class static dominating with args\n+            \"\"\"\n+            static void main() {\n+                throw new AssertionError();\n+            }\n+            static void main(String[] args) {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class static dominating instance\n+            \"\"\"\n+            void main(String[] args) {\n+                throw new AssertionError();\n+            }\n+            static void main() {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class instance dominating with args\n+            \"\"\"\n+            void main() {\n+                throw new AssertionError();\n+            }\n+            void main(String[] args) {\n+            }\n+            \"\"\",\n+\n+            \/\/ unnamed class instance main no args\n+            \"\"\"\n+            void main() {\n+            }\n+            \"\"\",\n+\n+            \/\/ instance main dominating super static\n+            \"\"\"\n+            class MainClass extends SuperClass {\n+                void main() {\n+                }\n+            }\n+            class SuperClass {\n+                void main(String[] args) {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ super instance main with args dominating\n+            \"\"\"\n+            public class MainClass extends Super {\n+            }\n+\n+            class Super {\n+                public void main(String... args) {\n+                }\n+\n+                public void main() {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ ignore super instance main\n+            \"\"\"\n+            public class MainClass extends Super {\n+                public static void main(String... args) {\n+                }\n+            }\n+\n+            class Super {\n+                public static void main(String... args) {\n+                    throw new AssertionError();\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ enum main\n+            \"\"\"\n+            enum MainClass {\n+                A;\n+\n+                public static void main() {\n+                }\n+            }\n+            \"\"\",\n+\n+            \/\/ record main\n+            \"\"\"\n+            record MainClass() {\n+                 static void main() {\n+                     System.out.println(\"Done!\");\n+                 }\n+            }\n+            \"\"\",\n+            \/\/ interface main\n+            \"\"\"\n+            interface MainClass {\n+                 static void main() {\n+                     System.out.println(\"Done!\");\n+                 }\n+            }\n+            \"\"\"\n+    };\n+\n+    public static void main(String... args) throws Exception {\n+        for (String source : SOURCES) {\n+            Files.writeString(Path.of(\"MainClass.java\"), source);\n+            var version = System.getProperty(\"java.specification.version\");\n+            var tr = doExec(javaCmd, \"--enable-preview\", \"--source\", version, \"MainClass.java\");\n+            if (!tr.isOK()) {\n+                System.err.println(source);\n+                System.err.println(tr);\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.unnamed.classes\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.bad.file.name\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassBad-Filename.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.should.not.have.package.declaration\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+package unnamed.classes;\n+\n+public static void main(String... args) {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassHasPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.unnamed.class.does.not.have.main.method\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: -source ${jdk.version} --enable-preview\n+\n+public void ordinaryMethod() {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnnamedClassNoMain.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -556,1 +556,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotPublic\");\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * A class with no-name.\n+ *\/\n+\n+void main() {\n+    printMessage();\n+}\n+\n+private static String horseName = null;\n+\n+private static void printMessage() {\n+    if (horseName == null) {\n+        System.out.print(\"A horse has no name.\");\n+    } else\n+        System.out.print(\"A horse's name is \" + horseName);\n+}\n+\n+\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/Anonymous.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306112\n+ * @summary Test basic processing of unnamed classes.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @build   JavacTestingAbstractProcessor TestUnnamedClass\n+ * @compile -processor TestUnnamedClass -proc:only --enable-preview --release ${jdk.version} Anonymous.java\n+ *\/\n+\n+\n+import java.lang.annotation.*;\n+import java.io.Writer;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+import static javax.lang.model.util.ElementFilter.*;\n+import javax.tools.JavaFileObject;\n+\n+\/*\n+ * Ideally, this processor would test both the compile-time\n+ * representation of an unnamed class starting from a source file as\n+ * well as the representation starting from a class file. Currently,\n+ * only the source file based view will be tested.\n+ *\n+ * For future work to test the class file based view, an additional jtreg directive like the following could\n+ * be used:\n+ *\n+ * @compile\/process -processor TestUnnamedClass -proc:only Anonymous Nameless\n+ *\/\n+@SuppressWarnings(\"preview\")\n+public class TestUnnamedClass  extends JavacTestingAbstractProcessor {\n+\n+    private static int round  = 0;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (round == 0) { \/\/ Check file from comamnd line\n+            checkRoots(roundEnv);\n+            generateUnnamed();\n+        }\n+\n+        if (!roundEnv.processingOver()) { \/\/ Test generated file(s)\n+            checkRoots(roundEnv);\n+        }\n+\n+        round++;\n+        return true;\n+    }\n+\n+    private void checkRoots(RoundEnvironment roundEnv) {\n+        int checks = 0;\n+        for (TypeElement type : typesIn(roundEnv.getRootElements())) {\n+            System.out.println(\"Checking \" + type.getQualifiedName());\n+            checks++;\n+            checkUnnamedClassProperties(type);\n+        }\n+        if (checks == 0) {\n+            messager.printError(\"No checking done of any candidate unnamed classes.\");\n+        }\n+    }\n+\n+    private void generateUnnamed() {\n+        try {\n+            String unnamedSource = \"\"\"\n+            void main() {\n+                System.out.println(\"Nameless, but not voiceless.\");\n+            }\n+            \"\"\";\n+\n+            JavaFileObject outputFile = processingEnv.getFiler().createSourceFile(\"Nameless\");\n+            try(Writer w = outputFile.openWriter()) {\n+                w.append(unnamedSource);\n+            }\n+        } catch (java.io.IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    \/*\n+     * From JEP 445 JLS changes:\n+     *\n+     * \"An unnamed class compilation unit implicitly declares a class that satisfies the following\n+     * properties:\n+     * It is always a top level class.\n+     * It is always an unnamed class (it has no canonical or fully qualified name (6.7)).\n+     * It is never abstract (8.1.1.1).\n+     * It is always final (8.1.1.2).\n+     * It is always a member of an unnamed package (7.4.2) and has package access.\n+     * Its direct superclass type is always Object (8.1.4).\n+     * It never has any direct superinterface types (8.1.5).\n+     *\n+     * The body of the class contains every ClassMemberDeclaration\n+     * from the unnamed class compilation unit. It is not possible for\n+     * an unnamed class compilation unit to declare an instance\n+     * initializer, static initializer, or constructor.\n+     *\n+     * It has an implicitly declared default constructor (8.8.9).\n+     * All members of this class, including any implicitly declared\n+     * members, are subject to the usual rules for member declarations\n+     * in a class.\n+     *\n+     * It is a compile-time error if this class does not declare a candidate main method (12.1.4).\n+     *\/\n+    void checkUnnamedClassProperties(TypeElement unnamedClass) {\n+        if (unnamedClass.getNestingKind() != NestingKind.TOP_LEVEL) {\n+            messager.printError(\"Unnamed class is not top-level.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ indicated as such.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getSimpleName().isEmpty()) {\n+            messager.printError(\"Unnamed class does have an empty simple name.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getQualifiedName().isEmpty()) {\n+            messager.printError(\"Unnamed class does _not_ have an empty qualified name.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.ABSTRACT)) {\n+            messager.printError(\"Unnamed class is abstract.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Unnamed class is _not_ final.\", unnamedClass);\n+        }\n+\n+        if (!elements.getPackageOf(unnamedClass).isUnnamed()) {\n+            messager.printError(\"Unnamed class is _not_ in an unnamed package.\", unnamedClass);\n+        }\n+\n+        if (unnamedClass.getModifiers().contains(Modifier.PUBLIC)  ||\n+            unnamedClass.getModifiers().contains(Modifier.PRIVATE) ||\n+            unnamedClass.getModifiers().contains(Modifier.PROTECTED)) {\n+            messager.printError(\"Unnamed class does _not_ have package access.\", unnamedClass);\n+        }\n+\n+        if ( !types.isSameType(unnamedClass.getSuperclass(),\n+                               elements.getTypeElement(\"java.lang.Object\").asType())) {\n+            messager.printError(\"Unnamed class does _not_ have java.lang.Object as a superclass.\", unnamedClass);\n+        }\n+\n+        if (!unnamedClass.getInterfaces().isEmpty()) {\n+            messager.printError(\"Unnamed class has superinterfaces.\", unnamedClass);\n+        }\n+\n+        List<ExecutableElement> ctors = constructorsIn(unnamedClass.getEnclosedElements());\n+        if (ctors.size() != 1 ) {\n+            messager.printError(\"Did not find exactly one constructor\", unnamedClass);\n+        }\n+\n+        ExecutableElement ctor = ctors.getFirst();\n+        if (elements.getOrigin(ctor) != Elements.Origin.MANDATED) {\n+            messager.printError(\"Constructor was not marked as mandated\", ctor);\n+        }\n+\n+        List<ExecutableElement> methods = methodsIn(unnamedClass.getEnclosedElements());\n+        \/\/ Just look for a method named \"main\"; don't check the other details.\n+        boolean mainFound = false;\n+        Name mainName = elements.getName(\"main\");\n+        for (var method : methods) {\n+            if (method.getSimpleName().equals(mainName)) {\n+                mainFound = true;\n+                break;\n+            }\n+        }\n+\n+        if (!mainFound) {\n+            messager.printError(\"No main mehtod found\", unnamedClass);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedClass.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=UnnamedClassRecovery.out -XDrawDiagnostics --enable-preview --source ${jdk.version} UnnamedClassRecovery.java\n+ *\/\n+public void main() {\n+    \/\/the following is intentionally missing a semicolon:\n+    System.err.println(\"Hello!\")\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+UnnamedClassRecovery.java:7:33: compiler.err.expected: ';'\n+- compiler.note.preview.filename: UnnamedClassRecovery.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedClassRecovery.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary enums: ensure unnamed class is visible to java.lang.Enum<unnamed_class>\n+ * @enablePreview\n+ * @compile NestedEnum.java\n+ *\/\n+\n+enum Foo {A, B}\n+void main() {\n+    System.out.println(Foo.A);\n+}\n","filename":"test\/langtools\/tools\/javac\/unnamedclass\/NestedEnum.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}