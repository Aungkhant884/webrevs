{"files":[{"patch":"@@ -146,1 +146,1 @@\n-                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::SlotAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,2 +128,2 @@\n-                          \"InlinePtr #elems %u size %zu \"\n-                          \"Array Of Cards #elems %u size %zu \"\n+                          \"InlinePtr #cards %u size %zu \"\n+                          \"Array Of Cards #cards %u size %zu \"\n@@ -131,1 +131,1 @@\n-                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u \"\n+                          \"Howl Bitmap #cards %u size %zu coarsen threshold %u \"\n@@ -202,2 +202,2 @@\n-  \/\/ Did we insert at least one element in the table?\n-  bool volatile _inserted_elem;\n+  \/\/ Did we insert at least one card in the table?\n+  bool volatile _inserted_card;\n@@ -250,1 +250,1 @@\n-    _inserted_elem(false),\n+    _inserted_card(false),\n@@ -270,1 +270,1 @@\n-    if (!_inserted_elem && inserted) {\n+    if (!_inserted_card && inserted) {\n@@ -273,1 +273,1 @@\n-      Atomic::store(&_inserted_elem, true);\n+      Atomic::store(&_inserted_card, true);\n@@ -298,1 +298,1 @@\n-    if (Atomic::load(&_inserted_elem)) {\n+    if (Atomic::load(&_inserted_card)) {\n@@ -300,1 +300,1 @@\n-      Atomic::store(&_inserted_elem, false);\n+      Atomic::store(&_inserted_card, false);\n@@ -633,1 +633,1 @@\n-    \/\/ We add 1 element less because the values will be incremented\n+    \/\/ We add 1 card less because the values will be incremented\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  uint find(uint const card_idx, uint const bits_per_card, uint start_at, uint num_elems);\n+  uint find(uint const card_idx, uint const bits_per_card, uint start_at, uint num_cards);\n@@ -221,1 +221,1 @@\n-  G1CardSetArray(uint const card_in_region, EntryCountType num_elems);\n+  G1CardSetArray(uint const card_in_region, EntryCountType num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n-    uint num_elems = num_cards_in(_value);\n-    if (num_elems > 0) {\n-      cur_idx = find(card_idx, bits_per_card, cur_idx, num_elems);\n+    uint num_cards = num_cards_in(_value);\n+    if (num_cards > 0) {\n+      cur_idx = find(card_idx, bits_per_card, cur_idx, num_cards);\n@@ -58,1 +58,1 @@\n-    if (cur_idx < num_elems) {\n+    if (cur_idx < num_cards) {\n@@ -62,1 +62,1 @@\n-    if (num_elems >= max_cards_in_inline_ptr) {\n+    if (num_cards >= max_cards_in_inline_ptr) {\n@@ -65,1 +65,1 @@\n-    CardSetPtr new_value = merge(_value, card_idx, num_elems, bits_per_card);\n+    CardSetPtr new_value = merge(_value, card_idx, num_cards, bits_per_card);\n@@ -80,2 +80,2 @@\n-inline uint G1CardSetInlinePtr::find(uint card_idx, uint bits_per_card, uint start_at, uint num_elems) {\n-  assert(start_at < num_elems, \"Precondition!\");\n+inline uint G1CardSetInlinePtr::find(uint card_idx, uint bits_per_card, uint start_at, uint num_cards) {\n+  assert(start_at < num_cards, \"Precondition!\");\n@@ -87,1 +87,1 @@\n-  for (uint cur_idx = start_at; cur_idx < num_elems; cur_idx++) {\n+  for (uint cur_idx = start_at; cur_idx < num_cards; cur_idx++) {\n@@ -93,1 +93,1 @@\n-  return num_elems;\n+  return num_cards;\n@@ -97,2 +97,2 @@\n-  uint num_elems = num_cards_in(_value);\n-  if (num_elems == 0) {\n+  uint num_cards = num_cards_in(_value);\n+  if (num_cards == 0) {\n@@ -101,2 +101,2 @@\n-  uint cur_idx = find(card_idx, bits_per_card, 0, num_elems);\n-  return cur_idx < num_elems;\n+  uint cur_idx = find(card_idx, bits_per_card, 0, num_cards);\n+  return cur_idx < num_cards;\n@@ -107,1 +107,1 @@\n-  uint const num_elems = num_cards_in(_value);\n+  uint const num_cards = num_cards_in(_value);\n@@ -111,1 +111,1 @@\n-  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+  for (uint cur_idx = 0; cur_idx < num_cards; cur_idx++) {\n@@ -139,1 +139,1 @@\n-inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_elems) :\n+inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_cards) :\n@@ -141,1 +141,1 @@\n-  _size(num_elems),\n+  _size(num_cards),\n@@ -169,1 +169,1 @@\n-         \"Card index %u does not fit card element.\", card_idx);\n+         \"Card index %u does not fit card entry.\", card_idx);\n@@ -184,1 +184,1 @@\n-  \/\/ Look if the elements added while waiting for the lock are the same as our card.\n+  \/\/ Look if the cards added while waiting for the lock are the same as our card.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -33,5 +33,5 @@\n-template <class Elem>\n-G1CardSetAllocator<Elem>::G1CardSetAllocator(const char* name,\n-                                             const G1CardSetAllocOptions* buffer_options,\n-                                             G1CardSetBufferList* free_buffer_list) :\n-  _segmented_array(buffer_options, free_buffer_list),\n+template <class Slot>\n+G1CardSetAllocator<Slot>::G1CardSetAllocator(const char* name,\n+                                             const G1CardSetAllocOptions* alloc_options,\n+                                             G1CardSetFreeList* free_segment_list) :\n+  _segmented_array(alloc_options, free_segment_list),\n@@ -39,4 +39,4 @@\n-  _free_nodes_list(),\n-  _pending_nodes_list(),\n-  _num_pending_nodes(0),\n-  _num_free_nodes(0)\n+  _free_slots_list(),\n+  _pending_slots_list(),\n+  _num_pending_slots(0),\n+  _num_free_slots(0)\n@@ -44,2 +44,2 @@\n-  uint elem_size = _segmented_array.elem_size();\n-  assert(elem_size >= sizeof(G1CardSetContainer), \"Element instance size %u for allocator %s too small\", elem_size, name);\n+  uint slot_size = _segmented_array.slot_size();\n+  assert(slot_size >= sizeof(G1CardSetContainer), \"Slot instance size %u for allocator %s too small\", slot_size, name);\n@@ -48,2 +48,2 @@\n-template <class Elem>\n-G1CardSetAllocator<Elem>::~G1CardSetAllocator() {\n+template <class Slot>\n+G1CardSetAllocator<Slot>::~G1CardSetAllocator() {\n@@ -53,2 +53,2 @@\n-template <class Elem>\n-bool G1CardSetAllocator<Elem>::try_transfer_pending() {\n+template <class Slot>\n+bool G1CardSetAllocator<Slot>::try_transfer_pending() {\n@@ -62,2 +62,2 @@\n-  \/\/ Claim all the pending nodes.\n-  G1CardSetContainer* first = _pending_nodes_list.pop_all();\n+  \/\/ Claim all the pending slots.\n+  G1CardSetContainer* first = _pending_slots_list.pop_all();\n@@ -66,1 +66,1 @@\n-    \/\/ Prepare to add the claimed nodes, and update _num_pending_nodes.\n+    \/\/ Prepare to add the claimed slots, and update _num_pending_slots.\n@@ -68,1 +68,1 @@\n-    Atomic::load_acquire(&_num_pending_nodes);\n+    Atomic::load_acquire(&_num_pending_slots);\n@@ -76,1 +76,1 @@\n-    Atomic::sub(&_num_pending_nodes, count);\n+    Atomic::sub(&_num_pending_slots, count);\n@@ -80,1 +80,1 @@\n-    \/\/ Add synchronized nodes to _free_node_list.\n+    \/\/ Add synchronized slots to _free_slots_list.\n@@ -82,2 +82,2 @@\n-    Atomic::add(&_num_free_nodes, count);\n-    _free_nodes_list.prepend(*first, *last);\n+    Atomic::add(&_num_free_slots, count);\n+    _free_slots_list.prepend(*first, *last);\n@@ -89,3 +89,3 @@\n-template <class Elem>\n-void G1CardSetAllocator<Elem>::free(Elem* elem) {\n-  assert(elem != nullptr, \"precondition\");\n+template <class Slot>\n+void G1CardSetAllocator<Slot>::free(Slot* slot) {\n+  assert(slot != nullptr, \"precondition\");\n@@ -98,1 +98,1 @@\n-  \/\/ similar, due to how the buffers are used. - kbarret\n+  \/\/ similar, due to how the slots are used. - kbarret\n@@ -101,1 +101,1 @@\n-  uint pending_count = Atomic::add(&_num_pending_nodes, 1u, memory_order_relaxed);\n+  uint pending_count = Atomic::add(&_num_pending_slots, 1u, memory_order_relaxed);\n@@ -103,1 +103,1 @@\n-  G1CardSetContainer* node =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(elem));\n+  G1CardSetContainer* container =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(slot));\n@@ -105,2 +105,2 @@\n-  node->set_next(nullptr);\n-  assert(node->next() == nullptr, \"precondition\");\n+  container->set_next(nullptr);\n+  assert(container->next() == nullptr, \"precondition\");\n@@ -108,1 +108,1 @@\n-  _pending_nodes_list.push(*node);\n+  _pending_slots_list.push(*container);\n@@ -115,6 +115,6 @@\n-template <class Elem>\n-void G1CardSetAllocator<Elem>::drop_all() {\n-  _free_nodes_list.pop_all();\n-  _pending_nodes_list.pop_all();\n-  _num_pending_nodes = 0;\n-  _num_free_nodes = 0;\n+template <class Slot>\n+void G1CardSetAllocator<Slot>::drop_all() {\n+  _free_slots_list.pop_all();\n+  _pending_slots_list.pop_all();\n+  _num_pending_slots = 0;\n+  _num_free_slots = 0;\n@@ -124,6 +124,6 @@\n-template <class Elem>\n-void G1CardSetAllocator<Elem>::print(outputStream* os) {\n-  uint num_allocated_nodes = _segmented_array.num_allocated_nodes();\n-  uint num_available_nodes = _segmented_array.num_available_nodes();\n-  uint highest = _segmented_array.first_array_buffer() != nullptr\n-               ? _segmented_array.first_array_buffer()->num_elems()\n+template <class Slot>\n+void G1CardSetAllocator<Slot>::print(outputStream* os) {\n+  uint num_allocated_slots = _segmented_array.num_allocated_slots();\n+  uint num_available_slots = _segmented_array.num_available_slots();\n+  uint highest = _segmented_array.first_array_segment() != nullptr\n+               ? _segmented_array.first_array_segment()->num_slots()\n@@ -131,2 +131,2 @@\n-  uint num_buffers = _segmented_array.num_buffers();\n-  os->print(\"MA \" PTR_FORMAT \": %u elems pending (allocated %u available %u) used %.3f highest %u buffers %u size %zu \",\n+  uint num_segments = _segmented_array.num_segments();\n+  os->print(\"MA \" PTR_FORMAT \": %u slots pending (allocated %u available %u) used %.3f highest %u segments %u size %zu \",\n@@ -134,4 +134,4 @@\n-            _num_pending_nodes,\n-            num_allocated_nodes,\n-            num_available_nodes,\n-            percent_of(num_allocated_nodes - _num_pending_nodes, num_available_nodes),\n+            _num_pending_slots,\n+            num_allocated_slots,\n+            num_available_slots,\n+            percent_of(num_allocated_slots - _num_pending_slots, num_available_slots),\n@@ -139,1 +139,1 @@\n-            num_buffers,\n+            num_segments,\n@@ -208,1 +208,1 @@\n-    result._num_segments[i] += _allocators[i].num_buffers();\n+    result._num_segments[i] += _allocators[i].num_segments();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/ to determine the next size of the allocated G1CardSetBuffer.\n+\/\/ to determine the next size of the allocated G1CardSetSegment.\n@@ -42,2 +42,2 @@\n-  static const uint MinimumBufferSize = 8;\n-  static const uint MaximumBufferSize =  UINT_MAX \/ 2;\n+  static const uint MinimumNumSlots = 8;\n+  static const uint MaximumNumSlots = UINT_MAX \/ 2;\n@@ -45,2 +45,2 @@\n-  uint exponential_expand(uint prev_num_elems) const {\n-    return clamp(prev_num_elems * 2, _initial_num_elems, _max_num_elems);\n+  uint exponential_expand(uint prev_num_slots) const {\n+    return clamp(prev_num_slots * 2, _initial_num_slots, _max_num_slots);\n@@ -50,1 +50,1 @@\n-  static const uint BufferAlignment = 8;\n+  static const uint SlotAlignment = 8;\n@@ -52,2 +52,2 @@\n-  G1CardSetAllocOptions(uint elem_size, uint initial_num_elems = MinimumBufferSize, uint max_num_elems = MaximumBufferSize) :\n-    G1SegmentedArrayAllocOptions(align_up(elem_size, BufferAlignment), initial_num_elems, max_num_elems, BufferAlignment) {\n+  G1CardSetAllocOptions(uint slot_size, uint initial_num_slots = MinimumNumSlots, uint max_num_slots = MaximumNumSlots) :\n+    G1SegmentedArrayAllocOptions(align_up(slot_size, SlotAlignment), initial_num_slots, max_num_slots, SlotAlignment) {\n@@ -56,2 +56,2 @@\n-  virtual uint next_num_elems(uint prev_num_elems) const override {\n-    return exponential_expand(prev_num_elems);\n+  virtual uint next_num_slots(uint prev_num_slots) const override {\n+    return exponential_expand(prev_num_slots);\n@@ -61,1 +61,1 @@\n-typedef G1SegmentedArrayBuffer<mtGCCardSet> G1CardSetBuffer;\n+typedef G1SegmentedArraySegment<mtGCCardSet> G1CardSetSegment;\n@@ -63,1 +63,1 @@\n-typedef G1SegmentedArrayBufferList<mtGCCardSet> G1CardSetBufferList;\n+typedef G1SegmentedArrayFreeList<mtGCCardSet> G1CardSetFreeList;\n@@ -65,1 +65,1 @@\n-\/\/ Arena-like allocator for (card set) heap memory objects (Elem elements).\n+\/\/ Arena-like allocator for (card set) heap memory objects (Slot slots).\n@@ -71,2 +71,2 @@\n-\/\/ only then trying to bump-allocate from the current G1CardSetBuffer. If there is\n-\/\/ none, this class allocates a new G1CardSetBuffer (allocated from the C heap,\n+\/\/ only then trying to bump-allocate from the current G1CardSetSegment. If there is\n+\/\/ none, this class allocates a new G1CardSetSegment (allocated from the C heap,\n@@ -75,2 +75,2 @@\n-\/\/ The NodeStack free list is a linked list of G1CardSetContainers\n-\/\/ within all G1CardSetBuffer instances allocated so far. It uses a separate\n+\/\/ The SegmentStack free list is a linked list of G1CardSetContainers\n+\/\/ within all G1CardSetSegment instances allocated so far. It uses a separate\n@@ -87,1 +87,1 @@\n-template <class Elem>\n+template <class Slot>\n@@ -89,1 +89,1 @@\n-  \/\/ G1CardSetBuffer management.\n+  \/\/ G1CardSetSegment management.\n@@ -91,2 +91,2 @@\n-  typedef G1SegmentedArray<Elem, mtGCCardSet> SegmentedArray;\n-  \/\/ G1CardSetContainer node management within the G1CardSetBuffers allocated\n+  typedef G1SegmentedArray<Slot, mtGCCardSet> SegmentedArray;\n+  \/\/ G1CardSetContainer slot management within the G1CardSetSegments allocated\n@@ -94,2 +94,2 @@\n-  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& node);\n-  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> NodeStack;\n+  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& slot);\n+  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> SlotStack;\n@@ -99,2 +99,2 @@\n-  NodeStack _free_nodes_list;\n-  NodeStack _pending_nodes_list;\n+  SlotStack _free_slots_list;\n+  SlotStack _pending_slots_list;\n@@ -102,2 +102,2 @@\n-  volatile uint _num_pending_nodes;   \/\/ Number of nodes in the pending list.\n-  volatile uint _num_free_nodes;      \/\/ Number of nodes in the free list.\n+  volatile uint _num_pending_slots;   \/\/ Number of slots in the pending list.\n+  volatile uint _num_free_slots;      \/\/ Number of slots in the free list.\n@@ -105,2 +105,2 @@\n-  \/\/ Try to transfer nodes from _pending_nodes_list to _free_nodes_list, with a\n-  \/\/ synchronization delay for any in-progress pops from the _free_nodes_list\n+  \/\/ Try to transfer slots from _pending_slots_list to _free_slots_list, with a\n+  \/\/ synchronization delay for any in-progress pops from the _free_slots_list\n@@ -110,1 +110,1 @@\n-  uint num_free_elems() const;\n+  uint num_free_slots() const;\n@@ -114,2 +114,2 @@\n-                     const G1CardSetAllocOptions* buffer_options,\n-                     G1CardSetBufferList* free_buffer_list);\n+                     const G1CardSetAllocOptions* alloc_options,\n+                     G1CardSetFreeList* free_segment_list);\n@@ -118,2 +118,2 @@\n-  Elem* allocate();\n-  void free(Elem* elem);\n+  Slot* allocate();\n+  void free(Slot* slot);\n@@ -121,1 +121,1 @@\n-  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ Deallocate all segments to the free segment list and reset this allocator. Must\n@@ -127,1 +127,2 @@\n-      _segmented_array.num_buffers() * sizeof(G1CardSetBuffer) + _segmented_array.num_available_nodes() * _segmented_array.elem_size();\n+      _segmented_array.num_segments() * sizeof(G1CardSetSegment) + _segmented_array.num_available_slots() *\n+                                                                   _segmented_array.slot_size();\n@@ -131,1 +132,2 @@\n-    return (_segmented_array.num_available_nodes() - (_segmented_array.num_allocated_nodes() - _num_pending_nodes)) * _segmented_array.elem_size();\n+    return (_segmented_array.num_available_slots() - (_segmented_array.num_allocated_slots() - _num_pending_slots)) *\n+           _segmented_array.slot_size();\n@@ -134,1 +136,1 @@\n-  inline uint num_buffers() { return _segmented_array.num_buffers(); }\n+  inline uint num_segments() { return _segmented_array.num_segments(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-template <class Elem>\n-G1CardSetContainer* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainer& node) {\n-  return node.next_addr();\n+template <class Slot>\n+G1CardSetContainer* volatile* G1CardSetAllocator<Slot>::next_ptr(G1CardSetContainer& slot) {\n+  return slot.next_addr();\n@@ -41,3 +41,3 @@\n-template <class Elem>\n-Elem* G1CardSetAllocator<Elem>::allocate() {\n-  assert(_segmented_array.elem_size() > 0, \"instance size not set.\");\n+template <class Slot>\n+Slot* G1CardSetAllocator<Slot>::allocate() {\n+  assert(_segmented_array.slot_size() > 0, \"instance size not set.\");\n@@ -45,1 +45,1 @@\n-  if (num_free_elems() > 0) {\n+  if (num_free_slots() > 0) {\n@@ -50,6 +50,6 @@\n-    G1CardSetContainer* node = _free_nodes_list.pop();\n-    if (node != nullptr) {\n-      Elem* elem = reinterpret_cast<Elem*>(reinterpret_cast<char*>(node));\n-      Atomic::sub(&_num_free_nodes, 1u);\n-      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n-      return elem;\n+    G1CardSetContainer* container = _free_slots_list.pop();\n+    if (container != nullptr) {\n+      Slot* slot = reinterpret_cast<Slot*>(reinterpret_cast<char*>(container));\n+      Atomic::sub(&_num_free_slots, 1u);\n+      guarantee(is_aligned(slot, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(slot));\n+      return slot;\n@@ -59,3 +59,3 @@\n-  Elem* elem = _segmented_array.allocate();\n-  assert(elem != nullptr, \"must be\");\n-  return elem;\n+  Slot* slot = _segmented_array.allocate();\n+  assert(slot != nullptr, \"must be\");\n+  return slot;\n@@ -77,3 +77,3 @@\n-template <class Elem>\n-inline uint G1CardSetAllocator<Elem>::num_free_elems() const {\n-  return Atomic::load(&_num_free_nodes);\n+template <class Slot>\n+inline uint G1CardSetAllocator<Slot>::num_free_slots() const {\n+  return Atomic::load(&_num_free_slots);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), BufferLength, UINT_MAX, Alignment);\n+  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), SegmentLength, UINT_MAX, Alignment);\n@@ -36,1 +36,1 @@\n-G1SegmentedArrayBufferList<mtGC> G1EvacFailureObjectsSet::_free_buffer_list;\n+G1SegmentedArrayFreeList<mtGC> G1EvacFailureObjectsSet::_free_segment_list;\n@@ -60,1 +60,1 @@\n-  _offsets(&_alloc_options, &_free_buffer_list)  {\n+  _offsets(&_alloc_options, &_free_segment_list)  {\n@@ -79,1 +79,1 @@\n-    _segments->iterate_nodes(*this);\n+    _segments->iterate_segments(*this);\n@@ -99,1 +99,1 @@\n-    uint num = _segments->num_allocated_nodes();\n+    uint num = _segments->num_allocated_slots();\n@@ -109,3 +109,3 @@\n-  \/\/ Callback of G1SegmentedArray::iterate_nodes\n-  void do_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint length) {\n-    node->copy_to(&_offset_array[_array_length]);\n+  \/\/ Callback of G1SegmentedArray::iterate_segments\n+  void do_segment(G1SegmentedArraySegment<mtGC>* segment, uint length) {\n+    segment->copy_to(&_offset_array[_array_length]);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ Provides sorted iteration of these elements for processing during the remove\n+\/\/ Provides sorted iteration of these objects for processing during the remove\n@@ -48,1 +48,1 @@\n-  static const uint BufferLength = 256;\n+  static const uint SegmentLength = 256;\n@@ -54,1 +54,1 @@\n-  static G1SegmentedArrayBufferList<mtGC> _free_buffer_list;\n+  static G1SegmentedArrayFreeList<mtGC> _free_segment_list;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-                  \"size = \" SIZE_FORMAT \"%s, num_elems = \" SIZE_FORMAT \".\",\n+                  \"size = \" SIZE_FORMAT \"%s, num_slots = \" SIZE_FORMAT \".\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-\/\/ A single buffer\/arena containing _num_elems blocks of memory of _elem_size.\n-\/\/ G1SegmentedArrayBuffers can be linked together using a singly linked list.\n+\/\/ A single segment\/arena containing _num_slots blocks of memory of _slot_size.\n+\/\/ G1SegmentedArraySegments can be linked together using a singly linked list.\n@@ -35,3 +35,3 @@\n-class G1SegmentedArrayBuffer : public CHeapObj<flag> {\n-  const uint _elem_size;\n-  const uint _num_elems;\n+class G1SegmentedArraySegment : public CHeapObj<flag> {\n+  const uint _slot_size;\n+  const uint _num_slots;\n@@ -39,1 +39,1 @@\n-  G1SegmentedArrayBuffer* volatile _next;\n+  G1SegmentedArraySegment* volatile _next;\n@@ -41,1 +41,1 @@\n-  char* _buffer;  \/\/ Actual data.\n+  char* _segment;  \/\/ Actual data.\n@@ -43,2 +43,2 @@\n-  \/\/ Index into the next free block to allocate into. Full if equal (or larger)\n-  \/\/ to _num_elems (can be larger because we atomically increment this value and\n+  \/\/ Index into the next free slot to allocate into. Full if equal (or larger)\n+  \/\/ to _num_slots (can be larger because we atomically increment this value and\n@@ -49,2 +49,2 @@\n-  G1SegmentedArrayBuffer(uint elem_size, uint num_elems, G1SegmentedArrayBuffer* next);\n-  ~G1SegmentedArrayBuffer();\n+  G1SegmentedArraySegment(uint slot_size, uint num_slots, G1SegmentedArraySegment* next);\n+  ~G1SegmentedArraySegment();\n@@ -52,1 +52,1 @@\n-  G1SegmentedArrayBuffer* volatile* next_addr() { return &_next; }\n+  G1SegmentedArraySegment* volatile* next_addr() { return &_next; }\n@@ -54,1 +54,1 @@\n-  void* get_new_buffer_elem();\n+  void* get_new_slot();\n@@ -56,1 +56,1 @@\n-  uint num_elems() const { return _num_elems; }\n+  uint num_slots() const { return _num_slots; }\n@@ -58,1 +58,1 @@\n-  G1SegmentedArrayBuffer* next() const { return _next; }\n+  G1SegmentedArraySegment* next() const { return _next; }\n@@ -60,1 +60,1 @@\n-  void set_next(G1SegmentedArrayBuffer* next) {\n+  void set_next(G1SegmentedArraySegment* next) {\n@@ -65,1 +65,1 @@\n-  void reset(G1SegmentedArrayBuffer* next) {\n+  void reset(G1SegmentedArraySegment* next) {\n@@ -69,1 +69,1 @@\n-    memset((void*)_buffer, 0, (size_t)_num_elems * _elem_size);\n+    memset((void*)_segment, 0, (size_t)_num_slots * _slot_size);\n@@ -72,1 +72,1 @@\n-  uint elem_size() const { return _elem_size; }\n+  uint slot_size() const { return _slot_size; }\n@@ -74,1 +74,1 @@\n-  size_t mem_size() const { return sizeof(*this) + (size_t)_num_elems * _elem_size; }\n+  size_t mem_size() const { return sizeof(*this) + (size_t)_num_slots * _slot_size; }\n@@ -77,1 +77,1 @@\n-    \/\/ _next_allocate might grow larger than _num_elems in multi-thread environments\n+    \/\/ _next_allocate might grow larger than _num_slots in multi-thread environments\n@@ -79,1 +79,1 @@\n-    return MIN2(_next_allocate, _num_elems);\n+    return MIN2(_next_allocate, _num_slots);\n@@ -82,1 +82,1 @@\n-  \/\/ Copies the (valid) contents of this buffer into the destination.\n+  \/\/ Copies the (valid) contents of this segment into the destination.\n@@ -84,1 +84,1 @@\n-    ::memcpy(dest, _buffer, length() * _elem_size);\n+    ::memcpy(dest, _segment, length() * _slot_size);\n@@ -87,1 +87,1 @@\n-  bool is_full() const { return _next_allocate >= _num_elems; }\n+  bool is_full() const { return _next_allocate >= _num_slots; }\n@@ -90,2 +90,2 @@\n-\/\/ Set of (free) G1SegmentedArrayBuffers. The assumed usage is that allocation\n-\/\/ to it and removal of elements is strictly separate, but every action may be\n+\/\/ Set of (free) G1SegmentedArraySegments. The assumed usage is that allocation\n+\/\/ to it and removal of segments is strictly separate, but every action may be\n@@ -95,3 +95,3 @@\n-class G1SegmentedArrayBufferList {\n-  static G1SegmentedArrayBuffer<flag>* volatile* next_ptr(G1SegmentedArrayBuffer<flag>& node) {\n-    return node.next_addr();\n+class G1SegmentedArrayFreeList {\n+  static G1SegmentedArraySegment<flag>* volatile* next_ptr(G1SegmentedArraySegment<flag>& segment) {\n+    return segment.next_addr();\n@@ -99,1 +99,1 @@\n-  typedef LockFreeStack<G1SegmentedArrayBuffer<flag>, &G1SegmentedArrayBufferList::next_ptr> NodeStack;\n+  typedef LockFreeStack<G1SegmentedArraySegment<flag>, &G1SegmentedArrayFreeList::next_ptr> SegmentStack;\n@@ -101,1 +101,1 @@\n-  NodeStack _list;\n+  SegmentStack _list;\n@@ -103,1 +103,1 @@\n-  volatile size_t _num_buffers;\n+  volatile size_t _num_segments;\n@@ -107,2 +107,2 @@\n-  G1SegmentedArrayBufferList() : _list(), _num_buffers(0), _mem_size(0) { }\n-  ~G1SegmentedArrayBufferList() { free_all(); }\n+  G1SegmentedArrayFreeList() : _list(), _num_segments(0), _mem_size(0) { }\n+  ~G1SegmentedArrayFreeList() { free_all(); }\n@@ -110,1 +110,1 @@\n-  void bulk_add(G1SegmentedArrayBuffer<flag>& first, G1SegmentedArrayBuffer<flag>& last, size_t num, size_t mem_size);\n+  void bulk_add(G1SegmentedArraySegment<flag>& first, G1SegmentedArraySegment<flag>& last, size_t num, size_t mem_size);\n@@ -112,2 +112,2 @@\n-  G1SegmentedArrayBuffer<flag>* get();\n-  G1SegmentedArrayBuffer<flag>* get_all(size_t& num_buffers, size_t& mem_size);\n+  G1SegmentedArraySegment<flag>* get();\n+  G1SegmentedArraySegment<flag>* get_all(size_t& num_segments, size_t& mem_size);\n@@ -120,1 +120,1 @@\n-  size_t num_buffers() const { return Atomic::load(&_num_buffers); }\n+  size_t num_segments() const { return Atomic::load(&_num_segments); }\n@@ -124,1 +124,1 @@\n-\/\/ Configuration for G1SegmentedArray, e.g element size, element number of next G1SegmentedArrayBuffer.\n+\/\/ Configuration for G1SegmentedArray, e.g slot size, slot number of next G1SegmentedArraySegment.\n@@ -128,5 +128,5 @@\n-  const uint _elem_size;\n-  const uint _initial_num_elems;\n-  \/\/ Defines a limit to the number of elements in the buffer\n-  const uint _max_num_elems;\n-  const uint _alignment;\n+  const uint _slot_size;\n+  const uint _initial_num_slots;\n+  \/\/ Defines a limit to the number of slots in the segment\n+  const uint _max_num_slots;\n+  const uint _slot_alignment;\n@@ -135,9 +135,9 @@\n-  G1SegmentedArrayAllocOptions(uint elem_size, uint initial_num_elems, uint max_num_elems, uint alignment) :\n-    _elem_size(elem_size),\n-    _initial_num_elems(initial_num_elems),\n-    _max_num_elems(max_num_elems),\n-    _alignment(alignment) {\n-    assert(_elem_size > 0, \"Must be\");\n-    assert(_initial_num_elems > 0, \"Must be\");\n-    assert(_max_num_elems > 0, \"Must be\");\n-    assert(_alignment > 0, \"Must be\");\n+  G1SegmentedArrayAllocOptions(uint slot_size, uint initial_num_slots, uint max_num_slots, uint alignment) :\n+    _slot_size(slot_size),\n+    _initial_num_slots(initial_num_slots),\n+    _max_num_slots(max_num_slots),\n+    _slot_alignment(alignment) {\n+    assert(_slot_size > 0, \"Must be\");\n+    assert(_initial_num_slots > 0, \"Must be\");\n+    assert(_max_num_slots > 0, \"Must be\");\n+    assert(_slot_alignment > 0, \"Must be\");\n@@ -146,2 +146,2 @@\n-  virtual uint next_num_elems(uint prev_num_elems) const {\n-    return _initial_num_elems;\n+  virtual uint next_num_slots(uint prev_num_slots) const {\n+    return _initial_num_slots;\n@@ -150,1 +150,1 @@\n-  uint elem_size() const { return _elem_size; }\n+  uint slot_size() const { return _slot_size; }\n@@ -152,1 +152,1 @@\n-  uint alignment() const { return _alignment; }\n+  uint slot_alignment() const { return _slot_alignment; }\n@@ -155,2 +155,2 @@\n-\/\/ A segmented array where G1SegmentedArrayBuffer is the segment, and\n-\/\/ G1SegmentedArrayBufferList is the free list to cache G1SegmentedArrayBuffer,\n+\/\/ A segmented array where G1SegmentedArraySegment is the segment, and\n+\/\/ G1SegmentedArrayFreeList is the free list to cache G1SegmentedArraySegment,\n@@ -162,1 +162,1 @@\n-\/\/ Arena-like allocator for (card set, or ...) heap memory objects (Elem elements).\n+\/\/ Arena-like allocator for (card set, or ...) heap memory objects (Slot slots).\n@@ -164,2 +164,2 @@\n-\/\/ Actual allocation from the C heap occurs on G1SegmentedArrayBuffer basis, i.e. segments\n-\/\/ of elements. The assumed allocation pattern for these G1SegmentedArrayBuffer elements\n+\/\/ Actual allocation from the C heap occurs on G1SegmentedArraySegment basis, i.e. segments\n+\/\/ of slots. The assumed allocation pattern for these G1SegmentedArraySegment slots\n@@ -168,1 +168,1 @@\n-\/\/ - in the first phase, G1SegmentedArrayBuffers are allocated from the C heap (or a free\n+\/\/ - in the first phase, G1SegmentedArraySegments are allocated from the C heap (or a free\n@@ -172,1 +172,1 @@\n-\/\/ - in the second phase, G1SegmentedArrayBuffers are given back in bulk to the free list.\n+\/\/ - in the second phase, G1SegmentedArraySegments are given back in bulk to the free list.\n@@ -183,1 +183,1 @@\n-template <class Elem, MEMFLAGS flag>\n+template <class Slot, MEMFLAGS flag>\n@@ -185,1 +185,1 @@\n-  \/\/ G1SegmentedArrayAllocOptions provides parameters for allocation buffer\n+  \/\/ G1SegmentedArrayAllocOptions provides parameters for allocation segment\n@@ -189,4 +189,4 @@\n-  G1SegmentedArrayBuffer<flag>* volatile _first;       \/\/ The (start of the) list of all buffers.\n-  G1SegmentedArrayBuffer<flag>* _last;                 \/\/ The last element of the list of all buffers.\n-  volatile uint _num_buffers;                          \/\/ Number of assigned buffers to this allocator.\n-  volatile size_t _mem_size;                           \/\/ Memory used by all buffers.\n+  G1SegmentedArraySegment<flag>* volatile _first;       \/\/ The (start of the) list of all segments.\n+  G1SegmentedArraySegment<flag>* _last;                 \/\/ The last segment of the list of all segments.\n+  volatile uint _num_segments;                          \/\/ Number of assigned segments to this allocator.\n+  volatile size_t _mem_size;                            \/\/ Memory used by all segments.\n@@ -194,2 +194,2 @@\n-  G1SegmentedArrayBufferList<flag>* _free_buffer_list; \/\/ The global free buffer list to\n-                                                       \/\/ preferentially get new buffers from.\n+  G1SegmentedArrayFreeList<flag>* _free_segment_list; \/\/ The global free segment list to\n+                                                         \/\/ preferentially get new segments from.\n@@ -197,2 +197,2 @@\n-  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n-  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n+  volatile uint _num_available_slots; \/\/ Number of slots available in all segments (allocated + free + pending + not yet used).\n+  volatile uint _num_allocated_slots; \/\/ Number of total slots allocated and in use.\n@@ -201,1 +201,1 @@\n-  inline G1SegmentedArrayBuffer<flag>* create_new_buffer(G1SegmentedArrayBuffer<flag>* const prev);\n+  inline G1SegmentedArraySegment<flag>* create_new_segment(G1SegmentedArraySegment<flag>* const prev);\n@@ -206,1 +206,1 @@\n-  const G1SegmentedArrayBuffer<flag>* first_array_buffer() const { return Atomic::load(&_first); }\n+  const G1SegmentedArraySegment<flag>* first_array_segment() const { return Atomic::load(&_first); }\n@@ -208,3 +208,3 @@\n-  uint num_available_nodes() const { return Atomic::load(&_num_available_nodes); }\n-  uint num_allocated_nodes() const {\n-    uint allocated = Atomic::load(&_num_allocated_nodes);\n+  uint num_available_slots() const { return Atomic::load(&_num_available_slots); }\n+  uint num_allocated_slots() const {\n+    uint allocated = Atomic::load(&_num_allocated_slots);\n@@ -215,1 +215,1 @@\n-  inline uint elem_size() const;\n+  inline uint slot_size() const;\n@@ -217,2 +217,2 @@\n-  G1SegmentedArray(const G1SegmentedArrayAllocOptions* buffer_options,\n-                   G1SegmentedArrayBufferList<flag>* free_buffer_list);\n+  G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n+                   G1SegmentedArrayFreeList<flag>* free_segment_list);\n@@ -221,1 +221,1 @@\n-  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ Deallocate all segments to the free segment list and reset this allocator. Must\n@@ -225,1 +225,1 @@\n-  inline Elem* allocate();\n+  inline Slot* allocate();\n@@ -227,1 +227,1 @@\n-  inline uint num_buffers() const;\n+  inline uint num_segments() const;\n@@ -229,2 +229,2 @@\n-  template<typename BufferClosure>\n-  void iterate_nodes(BufferClosure& closure) const;\n+  template<typename SegmentClosure>\n+  void iterate_segments(SegmentClosure& closure) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":88,"deletions":88,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-G1SegmentedArrayBuffer<flag>::G1SegmentedArrayBuffer(uint elem_size, uint num_instances, G1SegmentedArrayBuffer* next) :\n-  _elem_size(elem_size), _num_elems(num_instances), _next(next), _next_allocate(0) {\n+G1SegmentedArraySegment<flag>::G1SegmentedArraySegment(uint slot_size, uint num_slots, G1SegmentedArraySegment* next) :\n+  _slot_size(slot_size), _num_slots(num_slots), _next(next), _next_allocate(0) {\n@@ -37,1 +37,1 @@\n-  _buffer = NEW_C_HEAP_ARRAY(char, (size_t)_num_elems * elem_size, mtGCCardSet);\n+  _segment = NEW_C_HEAP_ARRAY(char, (size_t)_num_slots * slot_size, mtGCCardSet);\n@@ -41,2 +41,2 @@\n-G1SegmentedArrayBuffer<flag>::~G1SegmentedArrayBuffer() {\n-  FREE_C_HEAP_ARRAY(mtGCCardSet, _buffer);\n+G1SegmentedArraySegment<flag>::~G1SegmentedArraySegment() {\n+  FREE_C_HEAP_ARRAY(mtGCCardSet, _segment);\n@@ -46,2 +46,2 @@\n-void* G1SegmentedArrayBuffer<flag>::get_new_buffer_elem() {\n-  if (_next_allocate >= _num_elems) {\n+void* G1SegmentedArraySegment<flag>::get_new_slot() {\n+  if (_next_allocate >= _num_slots) {\n@@ -51,1 +51,1 @@\n-  if (result >= _num_elems) {\n+  if (result >= _num_slots) {\n@@ -54,1 +54,1 @@\n-  void* r = _buffer + (uint)result * _elem_size;\n+  void* r = _segment + (uint)result * _slot_size;\n@@ -59,4 +59,4 @@\n-void G1SegmentedArrayBufferList<flag>::bulk_add(G1SegmentedArrayBuffer<flag>& first,\n-                                                G1SegmentedArrayBuffer<flag>& last,\n-                                                size_t num,\n-                                                size_t mem_size) {\n+void G1SegmentedArrayFreeList<flag>::bulk_add(G1SegmentedArraySegment<flag>& first,\n+                                              G1SegmentedArraySegment<flag>& last,\n+                                              size_t num,\n+                                              size_t mem_size) {\n@@ -64,1 +64,1 @@\n-  Atomic::add(&_num_buffers, num, memory_order_relaxed);\n+  Atomic::add(&_num_segments, num, memory_order_relaxed);\n@@ -69,3 +69,3 @@\n-void G1SegmentedArrayBufferList<flag>::print_on(outputStream* out, const char* prefix) {\n-  out->print_cr(\"%s: buffers %zu size %zu\",\n-                prefix, Atomic::load(&_num_buffers), Atomic::load(&_mem_size));\n+void G1SegmentedArrayFreeList<flag>::print_on(outputStream* out, const char* prefix) {\n+  out->print_cr(\"%s: segments %zu size %zu\",\n+                prefix, Atomic::load(&_num_segments), Atomic::load(&_mem_size));\n@@ -75,1 +75,1 @@\n-G1SegmentedArrayBuffer<flag>* G1SegmentedArrayBufferList<flag>::get() {\n+G1SegmentedArraySegment<flag>* G1SegmentedArrayFreeList<flag>::get() {\n@@ -78,1 +78,1 @@\n-  G1SegmentedArrayBuffer<flag>* result = _list.pop();\n+  G1SegmentedArraySegment<flag>* result = _list.pop();\n@@ -80,1 +80,1 @@\n-    Atomic::dec(&_num_buffers, memory_order_relaxed);\n+    Atomic::dec(&_num_segments, memory_order_relaxed);\n@@ -87,2 +87,2 @@\n-G1SegmentedArrayBuffer<flag>* G1SegmentedArrayBufferList<flag>::get_all(size_t& num_buffers,\n-                                                                        size_t& mem_size) {\n+G1SegmentedArraySegment<flag>* G1SegmentedArrayFreeList<flag>::get_all(size_t& num_segments,\n+                                                                       size_t& mem_size) {\n@@ -91,2 +91,2 @@\n-  G1SegmentedArrayBuffer<flag>* result = _list.pop_all();\n-  num_buffers = Atomic::load(&_num_buffers);\n+  G1SegmentedArraySegment<flag>* result = _list.pop_all();\n+  num_segments = Atomic::load(&_num_segments);\n@@ -96,1 +96,1 @@\n-    Atomic::sub(&_num_buffers, num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_num_segments, num_segments, memory_order_relaxed);\n@@ -103,1 +103,1 @@\n-void G1SegmentedArrayBufferList<flag>::free_all() {\n+void G1SegmentedArrayFreeList<flag>::free_all() {\n@@ -106,1 +106,1 @@\n-  G1SegmentedArrayBuffer<flag>* cur;\n+  G1SegmentedArraySegment<flag>* cur;\n@@ -114,1 +114,1 @@\n-  Atomic::sub(&_num_buffers, num_freed, memory_order_relaxed);\n+  Atomic::sub(&_num_segments, num_freed, memory_order_relaxed);\n@@ -118,4 +118,4 @@\n-template <class Elem, MEMFLAGS flag>\n-G1SegmentedArrayBuffer<flag>* G1SegmentedArray<Elem, flag>::create_new_buffer(G1SegmentedArrayBuffer<flag>* const prev) {\n-  \/\/ Take an existing buffer if available.\n-  G1SegmentedArrayBuffer<flag>* next = _free_buffer_list->get();\n+template <class Slot, MEMFLAGS flag>\n+G1SegmentedArraySegment<flag>* G1SegmentedArray<Slot, flag>::create_new_segment(G1SegmentedArraySegment<flag>* const prev) {\n+  \/\/ Take an existing segment if available.\n+  G1SegmentedArraySegment<flag>* next = _free_segment_list->get();\n@@ -123,3 +123,3 @@\n-    uint prev_num_elems = (prev != nullptr) ? prev->num_elems() : 0;\n-    uint num_elems = _alloc_options->next_num_elems(prev_num_elems);\n-    next = new G1SegmentedArrayBuffer<flag>(elem_size(), num_elems, prev);\n+    uint prev_num_slots = (prev != nullptr) ? prev->num_slots() : 0;\n+    uint num_slots = _alloc_options->next_num_slots(prev_num_slots);\n+    next = new G1SegmentedArraySegment<flag>(slot_size(), num_slots, prev);\n@@ -127,2 +127,2 @@\n-    assert(elem_size() == next->elem_size() ,\n-           \"Mismatch %d != %d Elem %zu\", elem_size(), next->elem_size(), sizeof(Elem));\n+    assert(slot_size() == next->slot_size() ,\n+           \"Mismatch %d != %d Slot %zu\", slot_size(), next->slot_size(), sizeof(Slot));\n@@ -132,2 +132,2 @@\n-  \/\/ Install it as current allocation buffer.\n-  G1SegmentedArrayBuffer<flag>* old = Atomic::cmpxchg(&_first, prev, next);\n+  \/\/ Install it as current allocation segment.\n+  G1SegmentedArraySegment<flag>* old = Atomic::cmpxchg(&_first, prev, next);\n@@ -135,1 +135,1 @@\n-    \/\/ Somebody else installed the buffer, use that one.\n+    \/\/ Somebody else installed the segment, use that one.\n@@ -139,1 +139,1 @@\n-    \/\/ Did we install the first element in the list? If so, this is also the last.\n+    \/\/ Did we install the first segment in the list? If so, this is also the last.\n@@ -143,2 +143,2 @@\n-    \/\/ Successfully installed the buffer into the list.\n-    Atomic::inc(&_num_buffers, memory_order_relaxed);\n+    \/\/ Successfully installed the segment into the list.\n+    Atomic::inc(&_num_segments, memory_order_relaxed);\n@@ -146,1 +146,1 @@\n-    Atomic::add(&_num_available_nodes, next->num_elems(), memory_order_relaxed);\n+    Atomic::add(&_num_available_slots, next->num_slots(), memory_order_relaxed);\n@@ -151,3 +151,3 @@\n-template <class Elem, MEMFLAGS flag>\n-uint G1SegmentedArray<Elem, flag>::elem_size() const {\n-  return _alloc_options->elem_size();\n+template <class Slot, MEMFLAGS flag>\n+uint G1SegmentedArray<Slot, flag>::slot_size() const {\n+  return _alloc_options->slot_size();\n@@ -156,4 +156,4 @@\n-template <class Elem, MEMFLAGS flag>\n-G1SegmentedArray<Elem, flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* buffer_options,\n-                                               G1SegmentedArrayBufferList<flag>* free_buffer_list) :\n-     _alloc_options(buffer_options),\n+template <class Slot, MEMFLAGS flag>\n+G1SegmentedArray<Slot, flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n+                                               G1SegmentedArrayFreeList<flag>* free_segment_list) :\n+     _alloc_options(alloc_options),\n@@ -162,1 +162,1 @@\n-     _num_buffers(0),\n+     _num_segments(0),\n@@ -164,4 +164,4 @@\n-     _free_buffer_list(free_buffer_list),\n-     _num_available_nodes(0),\n-     _num_allocated_nodes(0) {\n-  assert(_free_buffer_list != nullptr, \"precondition!\");\n+     _free_segment_list(free_segment_list),\n+     _num_available_slots(0),\n+     _num_allocated_slots(0) {\n+  assert(_free_segment_list != nullptr, \"precondition!\");\n@@ -170,2 +170,2 @@\n-template <class Elem, MEMFLAGS flag>\n-G1SegmentedArray<Elem, flag>::~G1SegmentedArray() {\n+template <class Slot, MEMFLAGS flag>\n+G1SegmentedArray<Slot, flag>::~G1SegmentedArray() {\n@@ -175,3 +175,3 @@\n-template <class Elem, MEMFLAGS flag>\n-void G1SegmentedArray<Elem, flag>::drop_all() {\n-  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n+template <class Slot, MEMFLAGS flag>\n+void G1SegmentedArray<Slot, flag>::drop_all() {\n+  G1SegmentedArraySegment<flag>* cur = Atomic::load_acquire(&_first);\n@@ -180,1 +180,1 @@\n-    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+    assert(_last != nullptr, \"If there is at least one segment, there must be a last one.\");\n@@ -182,1 +182,1 @@\n-    G1SegmentedArrayBuffer<flag>* first = cur;\n+    G1SegmentedArraySegment<flag>* first = cur;\n@@ -185,2 +185,2 @@\n-    G1SegmentedArrayBuffer<flag>* last = cur;\n-    uint num_buffers = 0;\n+    G1SegmentedArraySegment<flag>* last = cur;\n+    uint num_segments = 0;\n@@ -190,1 +190,1 @@\n-      num_buffers++;\n+      num_segments++;\n@@ -192,1 +192,1 @@\n-      G1SegmentedArrayBuffer<flag>* next = cur->next();\n+      G1SegmentedArraySegment<flag>* next = cur->next();\n@@ -197,1 +197,1 @@\n-    assert(num_buffers == _num_buffers, \"Buffer count inconsistent %u %u\", num_buffers, _num_buffers);\n+    assert(num_segments == _num_segments, \"Segment count inconsistent %u %u\", num_segments, _num_segments);\n@@ -199,1 +199,1 @@\n-    assert(last == _last, \"Inconsistent last element\");\n+    assert(last == _last, \"Inconsistent last segment\");\n@@ -201,1 +201,1 @@\n-    _free_buffer_list->bulk_add(*first, *_last, _num_buffers, _mem_size);\n+    _free_segment_list->bulk_add(*first, *_last, _num_segments, _mem_size);\n@@ -206,1 +206,1 @@\n-  _num_buffers = 0;\n+  _num_segments = 0;\n@@ -208,2 +208,2 @@\n-  _num_available_nodes = 0;\n-  _num_allocated_nodes = 0;\n+  _num_available_slots = 0;\n+  _num_allocated_slots = 0;\n@@ -212,3 +212,3 @@\n-template <class Elem, MEMFLAGS flag>\n-Elem* G1SegmentedArray<Elem, flag>::allocate() {\n-  assert(elem_size() > 0, \"instance size not set.\");\n+template <class Slot, MEMFLAGS flag>\n+Slot* G1SegmentedArray<Slot, flag>::allocate() {\n+  assert(slot_size() > 0, \"instance size not set.\");\n@@ -216,1 +216,1 @@\n-  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n+  G1SegmentedArraySegment<flag>* cur = Atomic::load_acquire(&_first);\n@@ -218,1 +218,1 @@\n-    cur = create_new_buffer(cur);\n+    cur = create_new_segment(cur);\n@@ -222,6 +222,6 @@\n-    Elem* elem = (Elem*)cur->get_new_buffer_elem();\n-    if (elem != nullptr) {\n-      Atomic::inc(&_num_allocated_nodes, memory_order_relaxed);\n-      guarantee(is_aligned(elem, _alloc_options->alignment()),\n-                \"result \" PTR_FORMAT \" not aligned at %u\", p2i(elem), _alloc_options->alignment());\n-      return elem;\n+    Slot* slot = (Slot*) cur->get_new_slot();\n+    if (slot != nullptr) {\n+      Atomic::inc(&_num_allocated_slots, memory_order_relaxed);\n+      guarantee(is_aligned(slot, _alloc_options->slot_alignment()),\n+                \"result \" PTR_FORMAT \" not aligned at %u\", p2i(slot), _alloc_options->slot_alignment());\n+      return slot;\n@@ -229,1 +229,1 @@\n-    \/\/ The buffer is full. Next round.\n+    \/\/ The segment is full. Next round.\n@@ -231,1 +231,1 @@\n-    cur = create_new_buffer(cur);\n+    cur = create_new_segment(cur);\n@@ -235,3 +235,3 @@\n-template <class Elem, MEMFLAGS flag>\n-inline uint G1SegmentedArray<Elem, flag>::num_buffers() const {\n-  return Atomic::load(&_num_buffers);\n+template <class Slot, MEMFLAGS flag>\n+inline uint G1SegmentedArray<Slot, flag>::num_segments() const {\n+  return Atomic::load(&_num_segments);\n@@ -246,1 +246,1 @@\n-  void do_buffer(G1SegmentedArrayBuffer<flag>* node, uint limit) {\n+  void do_segment(G1SegmentedArraySegment<flag>* segment, uint limit) {\n@@ -254,2 +254,2 @@\n-template <class Elem, MEMFLAGS flag>\n-uint G1SegmentedArray<Elem, flag>::calculate_length() const {\n+template <class Slot, MEMFLAGS flag>\n+uint G1SegmentedArray<Slot, flag>::calculate_length() const {\n@@ -257,1 +257,1 @@\n-  iterate_nodes(closure);\n+  iterate_segments(closure);\n@@ -262,4 +262,4 @@\n-template <class Elem, MEMFLAGS flag>\n-template <typename BufferClosure>\n-void G1SegmentedArray<Elem, flag>::iterate_nodes(BufferClosure& closure) const {\n-  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n+template <class Slot, MEMFLAGS flag>\n+template <typename SegmentClosure>\n+void G1SegmentedArray<Slot, flag>::iterate_segments(SegmentClosure& closure) const {\n+  G1SegmentedArraySegment<flag>* cur = Atomic::load_acquire(&_first);\n@@ -268,1 +268,1 @@\n-         \"If there is at least one element, there must be a last one\");\n+         \"If there is at least one segment, there must be a last one\");\n@@ -271,1 +271,1 @@\n-    closure.do_buffer(cur, cur->length());\n+    closure.do_segment(cur, cur->length());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":99,"deletions":99,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-void G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayBufferList<flag>* source) {\n+void G1SegmentedArrayFreePool<flag>::G1ReturnMemoryProcessor::visit_free_list(G1SegmentedArrayFreeList<flag>* source) {\n@@ -81,1 +81,1 @@\n-  assert(_first != nullptr, \"must have element to return\");\n+  assert(_first != nullptr, \"must have segment to return\");\n@@ -86,2 +86,2 @@\n-  G1SegmentedArrayBuffer<flag>* cur = _first;\n-  G1SegmentedArrayBuffer<flag>* last = nullptr;\n+  G1SegmentedArraySegment<flag>* cur = _first;\n+  G1SegmentedArraySegment<flag>* last = nullptr;\n@@ -114,1 +114,1 @@\n-  log_trace(gc, task)(\"Segmented Array Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Returned to VM %zu segments size %zu\", keep_num, keep_size);\n@@ -138,1 +138,1 @@\n-    G1SegmentedArrayBuffer<flag>* next = _first->next();\n+    G1SegmentedArraySegment<flag>* next = _first->next();\n@@ -150,1 +150,1 @@\n-  log_trace(gc, task)(\"Segmented Array Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+  log_trace(gc, task)(\"Segmented Array Free Memory: Return to OS %zu segments size %zu\", num_delete, mem_size_deleted);\n@@ -162,1 +162,1 @@\n-  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayBufferList<flag>, _num_free_lists, mtGC);\n+  _free_lists = NEW_C_HEAP_ARRAY(G1SegmentedArrayFreeList < flag >, _num_free_lists, mtGC);\n@@ -164,1 +164,1 @@\n-    new (&_free_lists[i]) G1SegmentedArrayBufferList<flag>();\n+    new (&_free_lists[i]) G1SegmentedArrayFreeList<flag>();\n@@ -171,1 +171,1 @@\n-    _free_lists[i].~G1SegmentedArrayBufferList<flag>();\n+    _free_lists[i].~G1SegmentedArrayFreeList<flag>();\n@@ -182,1 +182,1 @@\n-    free_list_stats._num_segments[i] = _free_lists[i].num_buffers();\n+    free_list_stats._num_segments[i] = _free_lists[i].num_segments();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-\/\/ A set of free lists holding memory buffers for use by G1SegmentedArray,\n+\/\/ A set of free lists holding freed segments for use by G1SegmentedArray,\n@@ -65,1 +65,1 @@\n-  G1SegmentedArrayBufferList<flag>* _free_lists;\n+  G1SegmentedArrayFreeList<flag>* _free_lists;\n@@ -79,1 +79,1 @@\n-  G1SegmentedArrayBufferList<flag>* free_list(uint i) {\n+  G1SegmentedArrayFreeList<flag>* free_list(uint i) {\n@@ -93,1 +93,1 @@\n-\/\/ operating system for a single G1SegmentedArrayBufferList.\n+\/\/ operating system for a single G1SegmentedArrayFreeList.\n@@ -96,1 +96,1 @@\n-  G1SegmentedArrayBufferList<flag>* _source;\n+  G1SegmentedArrayFreeList<flag>* _source;\n@@ -99,1 +99,1 @@\n-  G1SegmentedArrayBuffer<flag>* _first;\n+  G1SegmentedArraySegment<flag>* _first;\n@@ -108,1 +108,1 @@\n-  \/\/ Updates the instance members about the given segmented array buffer list for\n+  \/\/ Updates the instance members about the given free list for\n@@ -111,1 +111,1 @@\n-  void visit_free_list(G1SegmentedArrayBufferList<flag>* source);\n+  void visit_free_list(G1SegmentedArrayFreeList<flag>* source);\n@@ -117,1 +117,1 @@\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one segment\n@@ -119,1 +119,1 @@\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  \/\/ return_to_vm() re-adds segments to the respective free list.\n@@ -122,1 +122,1 @@\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one segment\n@@ -124,1 +124,1 @@\n-  \/\/ return_to_os() gives back buffers to the OS.\n+  \/\/ return_to_os() gives back segments to the OS.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}