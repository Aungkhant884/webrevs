{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte128Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte128Mask.class, op, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte256Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte256Mask.class, op, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte512Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte512Mask.class, op, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte64Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte64Mask.class, op, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1878,2 +1878,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1881,2 +1880,23 @@\n-                                  VectorMask<Byte> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ByteSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ByteVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Byte> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (byte) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (byte) 0, mask);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Long128Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double128Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double128Mask.class, op, (Long128Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Long256Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double256Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double256Mask.class, op, (Long256Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Long512Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double512Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double512Mask.class, op, (Long512Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Long64Vector.*;\n@@ -358,0 +359,6 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Double64Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double64Mask.class, op, (Long64Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.LongMaxVector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(DoubleMaxMask.class, op, (LongMaxMask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1728,2 +1728,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1731,2 +1730,40 @@\n-                                  VectorMask<Double> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M1 extends VectorMask<Double>,\n+     M2 extends VectorMask<Long>>\n+    M1 testTemplate(Class<M1> maskType, Test op, M2 mask) {\n+        DoubleSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            LongVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Long> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (long) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (long) 0, mask);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Long.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                long infbits = (long) toBits(Double.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, mask);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, mask);\n+                } else {\n+                    m = bits.compare(EQ, infbits, mask);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(this.vspecies()));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Int128Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float128Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float128Mask.class, op, (Int128Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Int256Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float256Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float256Mask.class, op, (Int256Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Int512Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float512Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float512Mask.class, op, (Int512Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.Int64Vector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float64Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float64Mask.class, op, (Int64Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static jdk.incubator.vector.IntMaxVector.*;\n@@ -360,0 +361,6 @@\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(FloatMaxMask.class, op, (IntMaxMask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1740,2 +1740,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1743,2 +1742,40 @@\n-                                  VectorMask<Float> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M1 extends VectorMask<Float>,\n+     M2 extends VectorMask<Integer>>\n+    M1 testTemplate(Class<M1> maskType, Test op, M2 mask) {\n+        FloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            IntVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Integer> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (int) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (int) 0, mask);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Integer.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                int infbits = (int) toBits(Float.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, mask);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, mask);\n+                } else {\n+                    m = bits.compare(EQ, infbits, mask);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(this.vspecies()));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int128Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int128Mask.class, op, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int256Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int256Mask.class, op, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,0 +371,6 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Int512Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int512Mask.class, op, (Int512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int64Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int64Mask.class, op, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1877,2 +1877,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1880,2 +1879,23 @@\n-                                  VectorMask<Integer> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        IntSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            IntVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Integer> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (int) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (int) 0, mask);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long128Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long128Mask.class, op, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long256Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long256Mask.class, op, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long512Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long512Mask.class, op, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long64Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long64Mask.class, op, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1790,2 +1790,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1793,2 +1792,23 @@\n-                                  VectorMask<Long> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        LongSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            LongVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Long> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (long) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (long) 0, mask);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short128Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short128Mask.class, op, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short256Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short256Mask.class, op, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short512Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short512Mask.class, op, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short64Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short64Mask.class, op, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1878,2 +1878,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1881,2 +1880,23 @@\n-                                  VectorMask<Short> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ShortSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0, mask);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2169,2 +2169,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -2172,2 +2171,47 @@\n-                                  VectorMask<$Boxtype$> m) {\n-        return test(op).and(m);\n+                                  VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+#if[FP]\n+    <M1 extends VectorMask<$Boxtype$>,\n+     M2 extends VectorMask<$Boxbitstype$>>\n+    M1 testTemplate(Class<M1> maskType, Test op, M2 mask) {\n+#else[FP]\n+    <M extends VectorMask<$Boxtype$>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+#end[FP]\n+        $Type$Species vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            $Bitstype$Vector bits = this.viewAsIntegralLanes();\n+            VectorMask<$Boxbitstype$> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, ($bitstype$) 0, mask);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, ($bitstype$) 0, mask);\n+            }\n+#if[FP]\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and($Boxbitstype$.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, mask);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, mask);\n+                } else {\n+                    m = bits.compare(EQ, infbits, mask);\n+                }\n+            }\n+#end[FP]\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m{#if[FP]?.cast(this.vspecies())});\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":49,"deletions":5,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+#if[FP]\n+import static jdk.incubator.vector.$Bitstype$$bits$Vector.*;\n+#end[FP]\n@@ -377,0 +380,10 @@\n+    @Override\n+    @ForceInline\n+    public final $masktype$ test(Test op, VectorMask<$Boxtype$> m) {\n+#if[FP]\n+        return super.testTemplate($masktype$.class, op, ($Bitstype$$bits$Mask) m.cast(vspecies().asIntegral()));  \/\/ specialize\n+#else[FP]\n+        return super.testTemplate($masktype$.class, op, ($masktype$) m);  \/\/ specialize\n+#end[FP]\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3578,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3582,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3616,3 +3618,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3620,3 +3623,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2591,3 +2591,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2595,3 +2596,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2629,3 +2631,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2633,3 +2636,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2668,3 +2672,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2672,3 +2677,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2708,3 +2714,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2712,3 +2719,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2748,3 +2756,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2752,3 +2761,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2601,3 +2601,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2605,3 +2606,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2639,3 +2641,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2643,3 +2646,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2678,3 +2682,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2682,3 +2687,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2718,3 +2724,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2722,3 +2729,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2758,3 +2766,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2762,3 +2771,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3543,3 +3543,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3547,3 +3548,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3581,3 +3583,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3585,3 +3588,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3565,3 +3565,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3569,3 +3570,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3603,3 +3605,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3607,3 +3610,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3568,3 +3568,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3572,3 +3573,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3606,3 +3608,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3610,3 +3613,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,3 +29,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-            VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n@@ -33,3 +34,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}