{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte128Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte128Mask.class, op, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte256Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte256Mask.class, op, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte512Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte512Mask.class, op, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte64Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte64Mask.class, op, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1858,1 +1858,0 @@\n-            ByteVector bits = this.viewAsIntegralLanes();\n@@ -1861,1 +1860,1 @@\n-                m = bits.compare(EQ, (byte) 0);\n+                m = compare(EQ, (byte) 0);\n@@ -1863,1 +1862,1 @@\n-                m = bits.compare(LT, (byte) 0);\n+                m = compare(LT, (byte) 0);\n@@ -1878,2 +1877,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1881,2 +1879,23 @@\n-                                  VectorMask<Byte> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ByteSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Byte> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (byte) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (byte) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double128Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double128Mask.class, op, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double256Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double256Mask.class, op, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double512Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double512Mask.class, op, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,0 +358,6 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Double64Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double64Mask.class, op, (Double64Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1718,1 +1718,1 @@\n-            return maskType.cast(m.cast(this.vspecies()));\n+            return maskType.cast(m.cast(vsp));\n@@ -1728,2 +1728,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1731,2 +1730,40 @@\n-                                  VectorMask<Double> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        DoubleSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            LongVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Long> m = mask.cast(LongVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (long) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (long) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Long.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                long infbits = (long) toBits(Double.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float128Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float128Mask.class, op, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float256Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float256Mask.class, op, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float512Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float512Mask.class, op, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float64Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float64Mask.class, op, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1730,1 +1730,1 @@\n-            return maskType.cast(m.cast(this.vspecies()));\n+            return maskType.cast(m.cast(vsp));\n@@ -1740,2 +1740,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1743,2 +1742,40 @@\n-                                  VectorMask<Float> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        FloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            IntVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Integer> m = mask.cast(IntVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (int) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (int) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Integer.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                int infbits = (int) toBits(Float.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int128Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int128Mask.class, op, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int256Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int256Mask.class, op, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,0 +371,6 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Int512Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int512Mask.class, op, (Int512Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int64Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int64Mask.class, op, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1857,1 +1857,0 @@\n-            IntVector bits = this.viewAsIntegralLanes();\n@@ -1860,1 +1859,1 @@\n-                m = bits.compare(EQ, (int) 0);\n+                m = compare(EQ, (int) 0);\n@@ -1862,1 +1861,1 @@\n-                m = bits.compare(LT, (int) 0);\n+                m = compare(LT, (int) 0);\n@@ -1877,2 +1876,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1880,2 +1878,23 @@\n-                                  VectorMask<Integer> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        IntSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Integer> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (int) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (int) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long128Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long128Mask.class, op, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long256Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long256Mask.class, op, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long512Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long512Mask.class, op, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long64Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long64Mask.class, op, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1770,1 +1770,0 @@\n-            LongVector bits = this.viewAsIntegralLanes();\n@@ -1773,1 +1772,1 @@\n-                m = bits.compare(EQ, (long) 0);\n+                m = compare(EQ, (long) 0);\n@@ -1775,1 +1774,1 @@\n-                m = bits.compare(LT, (long) 0);\n+                m = compare(LT, (long) 0);\n@@ -1790,2 +1789,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1793,2 +1791,23 @@\n-                                  VectorMask<Long> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        LongSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Long> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (long) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (long) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short128Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short128Mask.class, op, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short256Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short256Mask.class, op, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short512Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short512Mask.class, op, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short64Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short64Mask.class, op, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1858,1 +1858,0 @@\n-            ShortVector bits = this.viewAsIntegralLanes();\n@@ -1861,1 +1860,1 @@\n-                m = bits.compare(EQ, (short) 0);\n+                m = compare(EQ, (short) 0);\n@@ -1863,1 +1862,1 @@\n-                m = bits.compare(LT, (short) 0);\n+                m = compare(LT, (short) 0);\n@@ -1878,2 +1877,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1881,2 +1879,23 @@\n-                                  VectorMask<Short> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ShortSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Short> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (short) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2131,0 +2131,1 @@\n+#if[FP]\n@@ -2132,0 +2133,1 @@\n+#end[FP]\n@@ -2134,1 +2136,1 @@\n-                m = bits.compare(EQ, ($bitstype$) 0);\n+                m = {#if[FP]?bits.}compare(EQ, ($bitstype$) 0);\n@@ -2136,1 +2138,1 @@\n-                m = bits.compare(LT, ($bitstype$) 0);\n+                m = {#if[FP]?bits.}compare(LT, ($bitstype$) 0);\n@@ -2159,1 +2161,1 @@\n-            return maskType.cast(m{#if[FP]?.cast(this.vspecies())});\n+            return maskType.cast(m{#if[FP]?.cast(vsp)});\n@@ -2169,2 +2171,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -2172,2 +2173,46 @@\n-                                  VectorMask<$Boxtype$> m) {\n-        return test(op).and(m);\n+                                  VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        $Type$Species vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+#if[FP]\n+            $Bitstype$Vector bits = this.viewAsIntegralLanes();\n+            VectorMask<$Boxbitstype$> m = mask.cast($Bitstype$Vector.species(shape()));\n+#else[FP]\n+            VectorMask<$Boxbitstype$> m = mask;\n+#end[FP]\n+            if (op == IS_DEFAULT) {\n+                m = {#if[FP]?bits.}compare(EQ, ($bitstype$) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = {#if[FP]?bits.}compare(LT, ($bitstype$) 0, m);\n+            }\n+#if[FP]\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and($Boxbitstype$.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+#end[FP]\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m{#if[FP]?.cast(vsp)});\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":53,"deletions":8,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,0 +377,6 @@\n+    @Override\n+    @ForceInline\n+    public final $masktype$ test(Test op, VectorMask<$Boxtype$> m) {\n+        return super.testTemplate($masktype$.class, op, ($masktype$) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3567,1 +3567,1 @@\n-    static void IS_DEFAULTMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3605,1 +3607,1 @@\n-    static void IS_NEGATIVEMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte128VectorTests(IntFunction<byte[]> fa,\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3567,1 +3567,1 @@\n-    static void IS_DEFAULTMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3605,1 +3607,1 @@\n-    static void IS_NEGATIVEMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte256VectorTests(IntFunction<byte[]> fa,\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3567,1 +3567,1 @@\n-    static void IS_DEFAULTMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3605,1 +3607,1 @@\n-    static void IS_NEGATIVEMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte512VectorTests(IntFunction<byte[]> fa,\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3567,1 +3567,1 @@\n-    static void IS_DEFAULTMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n@@ -3573,3 +3573,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3577,3 +3578,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3605,1 +3607,1 @@\n-    static void IS_NEGATIVEMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte64VectorTests(IntFunction<byte[]> fa,\n@@ -3611,3 +3613,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3615,3 +3618,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3572,1 +3572,1 @@\n-    static void IS_DEFAULTMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n@@ -3578,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3582,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3610,1 +3612,1 @@\n-    static void IS_NEGATIVEMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n@@ -3616,3 +3618,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3620,3 +3623,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2580,1 +2580,1 @@\n-    static void IS_DEFAULTMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2618,1 +2620,1 @@\n-    static void IS_NEGATIVEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2657,1 +2661,1 @@\n-    static void IS_FINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2697,1 +2703,1 @@\n-    static void IS_NANMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2737,1 +2745,1 @@\n-    static void IS_INFINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2580,1 +2580,1 @@\n-    static void IS_DEFAULTMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2618,1 +2620,1 @@\n-    static void IS_NEGATIVEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2657,1 +2661,1 @@\n-    static void IS_FINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2697,1 +2703,1 @@\n-    static void IS_NANMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2737,1 +2745,1 @@\n-    static void IS_INFINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2580,1 +2580,1 @@\n-    static void IS_DEFAULTMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2618,1 +2620,1 @@\n-    static void IS_NEGATIVEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2657,1 +2661,1 @@\n-    static void IS_FINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2697,1 +2703,1 @@\n-    static void IS_NANMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2737,1 +2745,1 @@\n-    static void IS_INFINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2580,1 +2580,1 @@\n-    static void IS_DEFAULTMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2586,3 +2586,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2590,3 +2591,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2618,1 +2620,1 @@\n-    static void IS_NEGATIVEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2624,3 +2626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2628,3 +2631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2657,1 +2661,1 @@\n-    static void IS_FINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2663,3 +2667,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2667,3 +2672,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2697,1 +2703,1 @@\n-    static void IS_NANMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2703,3 +2709,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2707,3 +2714,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2737,1 +2745,1 @@\n-    static void IS_INFINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2743,3 +2751,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2747,3 +2756,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2585,1 +2585,1 @@\n-    static void IS_DEFAULTMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2591,3 +2591,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2595,3 +2596,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2623,1 +2625,1 @@\n-    static void IS_NEGATIVEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2629,3 +2631,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2633,3 +2636,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2662,1 +2666,1 @@\n-    static void IS_FINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2668,3 +2672,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2672,3 +2677,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2702,1 +2708,1 @@\n-    static void IS_NANMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2708,3 +2714,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2712,3 +2719,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2742,1 +2750,1 @@\n-    static void IS_INFINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2748,3 +2756,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2752,3 +2761,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2590,1 +2590,1 @@\n-    static void IS_DEFAULTMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2628,1 +2630,1 @@\n-    static void IS_NEGATIVEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2667,1 +2671,1 @@\n-    static void IS_FINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2707,1 +2713,1 @@\n-    static void IS_NANMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2747,1 +2755,1 @@\n-    static void IS_INFINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2590,1 +2590,1 @@\n-    static void IS_DEFAULTMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2628,1 +2630,1 @@\n-    static void IS_NEGATIVEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2667,1 +2671,1 @@\n-    static void IS_FINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2707,1 +2713,1 @@\n-    static void IS_NANMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2747,1 +2755,1 @@\n-    static void IS_INFINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2590,1 +2590,1 @@\n-    static void IS_DEFAULTMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2628,1 +2630,1 @@\n-    static void IS_NEGATIVEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2667,1 +2671,1 @@\n-    static void IS_FINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2707,1 +2713,1 @@\n-    static void IS_NANMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2747,1 +2755,1 @@\n-    static void IS_INFINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2590,1 +2590,1 @@\n-    static void IS_DEFAULTMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2596,3 +2596,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2600,3 +2601,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2628,1 +2630,1 @@\n-    static void IS_NEGATIVEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2634,3 +2636,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2638,3 +2641,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2667,1 +2671,1 @@\n-    static void IS_FINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2673,3 +2677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2677,3 +2682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2707,1 +2713,1 @@\n-    static void IS_NANMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2713,3 +2719,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2717,3 +2724,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2747,1 +2755,1 @@\n-    static void IS_INFINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2753,3 +2761,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2757,3 +2766,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2595,1 +2595,1 @@\n-    static void IS_DEFAULTMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2601,3 +2601,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2605,3 +2606,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2633,1 +2635,1 @@\n-    static void IS_NEGATIVEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2639,3 +2641,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2643,3 +2646,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2672,1 +2676,1 @@\n-    static void IS_FINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2678,3 +2682,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2682,3 +2687,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2712,1 +2718,1 @@\n-    static void IS_NANMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2718,3 +2724,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2722,3 +2729,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2752,1 +2760,1 @@\n-    static void IS_INFINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2758,3 +2766,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2762,3 +2771,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3532,1 +3532,1 @@\n-    static void IS_DEFAULTMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt128VectorTests(IntFunction<int[]> fa,\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3570,1 +3572,1 @@\n-    static void IS_NEGATIVEMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt128VectorTests(IntFunction<int[]> fa,\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3532,1 +3532,1 @@\n-    static void IS_DEFAULTMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt256VectorTests(IntFunction<int[]> fa,\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3570,1 +3572,1 @@\n-    static void IS_NEGATIVEMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt256VectorTests(IntFunction<int[]> fa,\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3532,1 +3532,1 @@\n-    static void IS_DEFAULTMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt512VectorTests(IntFunction<int[]> fa,\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3570,1 +3572,1 @@\n-    static void IS_NEGATIVEMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt512VectorTests(IntFunction<int[]> fa,\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3532,1 +3532,1 @@\n-    static void IS_DEFAULTMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt64VectorTests(IntFunction<int[]> fa,\n@@ -3538,3 +3538,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3542,3 +3543,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3570,1 +3572,1 @@\n-    static void IS_NEGATIVEMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt64VectorTests(IntFunction<int[]> fa,\n@@ -3576,3 +3578,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3580,3 +3583,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3537,1 +3537,1 @@\n-    static void IS_DEFAULTMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n@@ -3543,3 +3543,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3547,3 +3548,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3575,1 +3577,1 @@\n-    static void IS_NEGATIVEMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n@@ -3581,3 +3583,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3585,3 +3588,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3554,1 +3554,1 @@\n-    static void IS_DEFAULTMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong128VectorTests(IntFunction<long[]> fa,\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3592,1 +3594,1 @@\n-    static void IS_NEGATIVEMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong128VectorTests(IntFunction<long[]> fa,\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3554,1 +3554,1 @@\n-    static void IS_DEFAULTMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong256VectorTests(IntFunction<long[]> fa,\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3592,1 +3594,1 @@\n-    static void IS_NEGATIVEMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong256VectorTests(IntFunction<long[]> fa,\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3554,1 +3554,1 @@\n-    static void IS_DEFAULTMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong512VectorTests(IntFunction<long[]> fa,\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3592,1 +3594,1 @@\n-    static void IS_NEGATIVEMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong512VectorTests(IntFunction<long[]> fa,\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3554,1 +3554,1 @@\n-    static void IS_DEFAULTMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong64VectorTests(IntFunction<long[]> fa,\n@@ -3560,3 +3560,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3564,3 +3565,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3592,1 +3594,1 @@\n-    static void IS_NEGATIVEMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong64VectorTests(IntFunction<long[]> fa,\n@@ -3598,3 +3600,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3602,3 +3605,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3559,1 +3559,1 @@\n-    static void IS_DEFAULTMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n@@ -3565,3 +3565,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3569,3 +3570,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3597,1 +3599,1 @@\n-    static void IS_NEGATIVEMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n@@ -3603,3 +3605,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3607,3 +3610,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3557,1 +3557,1 @@\n-    static void IS_DEFAULTMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort128VectorTests(IntFunction<short[]> fa,\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3595,1 +3597,1 @@\n-    static void IS_NEGATIVEMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort128VectorTests(IntFunction<short[]> fa,\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3557,1 +3557,1 @@\n-    static void IS_DEFAULTMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort256VectorTests(IntFunction<short[]> fa,\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3595,1 +3597,1 @@\n-    static void IS_NEGATIVEMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort256VectorTests(IntFunction<short[]> fa,\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3557,1 +3557,1 @@\n-    static void IS_DEFAULTMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort512VectorTests(IntFunction<short[]> fa,\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3595,1 +3597,1 @@\n-    static void IS_NEGATIVEMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort512VectorTests(IntFunction<short[]> fa,\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3557,1 +3557,1 @@\n-    static void IS_DEFAULTMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort64VectorTests(IntFunction<short[]> fa,\n@@ -3563,3 +3563,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3567,3 +3568,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3595,1 +3597,1 @@\n-    static void IS_NEGATIVEMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort64VectorTests(IntFunction<short[]> fa,\n@@ -3601,3 +3603,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3605,3 +3608,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3562,1 +3562,1 @@\n-    static void IS_DEFAULTMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n@@ -3568,3 +3568,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3572,3 +3573,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3600,1 +3602,1 @@\n-    static void IS_NEGATIVEMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n@@ -3606,3 +3608,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3610,3 +3613,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    static void [[TEST]]Masked$vectorteststype$SmokeTest(IntFunction<$type$[]> fa,\n+    static void [[TEST]]Masked$vectorteststype$(IntFunction<$type$[]> fa,\n@@ -29,3 +29,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-            VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n@@ -33,3 +34,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}