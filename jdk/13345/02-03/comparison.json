{"files":[{"patch":"@@ -3209,0 +3209,24 @@\n+  enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n+\n+    C2_MacroAssembler _masm(&cbuf);\n+\n+    Label done;\n+    __ cmpwi($crx$$CondRegister, $src$$Register, 0);\n+    __ li($dst$$Register, $zero$$constant);\n+    __ beq($crx$$CondRegister, done);\n+    __ li($dst$$Register, $notzero$$constant);\n+    __ bind(done);\n+  %}\n+\n+  enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n+\n+    C2_MacroAssembler _masm(&cbuf);\n+\n+    Label done;\n+    __ cmpdi($crx$$CondRegister, $src$$Register, 0);\n+    __ li($dst$$Register, $zero$$constant);\n+    __ beq($crx$$CondRegister, done);\n+    __ li($dst$$Register, $notzero$$constant);\n+    __ bind(done);\n+  %}\n+\n@@ -10392,0 +10416,162 @@\n+\/\/ Convert to boolean.\n+\n+\/\/ int_to_bool(src) : { 1   if src != 0\n+\/\/                    { 0   else\n+\/\/\n+\/\/ strategy:\n+\/\/ 1) Count leading zeros of 32 bit-value src,\n+\/\/    this returns 32 (0b10.0000) iff src == 0 and <32 otherwise.\n+\/\/ 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n+\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n+\n+\/\/ convI2Bool\n+instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{\n+  match(Set dst (Conv2B src));\n+  predicate(UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  expand %{\n+    immI shiftAmount %{ 0x5 %}\n+    uimmI16 mask %{ 0x1 %}\n+    iRegIdst tmp1;\n+    iRegIdst tmp2;\n+    countLeadingZerosI(tmp1, src);\n+    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n+    xorI_reg_uimm16(dst, tmp2, mask);\n+  %}\n+%}\n+\n+instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{\n+  match(Set dst (Conv2B src));\n+  effect(TEMP crx);\n+  predicate(!UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ convI2B\"\n+            \"LI      $dst, #0\\n\\t\"\n+            \"BEQ     $crx, done\\n\\t\"\n+            \"LI      $dst, #1\\n\"\n+            \"done:\" %}\n+  size(16);\n+  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ ConvI2B + XorI\n+instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{\n+  match(Set dst (XorI (Conv2B src) mask));\n+  predicate(UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  expand %{\n+    immI shiftAmount %{ 0x5 %}\n+    iRegIdst tmp1;\n+    countLeadingZerosI(tmp1, src);\n+    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n+  %}\n+%}\n+\n+instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{\n+  match(Set dst (XorI (Conv2B src) mask));\n+  effect(TEMP crx);\n+  predicate(!UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ Xor(convI2B($src), $mask)\"\n+            \"LI      $dst, #1\\n\\t\"\n+            \"BEQ     $crx, done\\n\\t\"\n+            \"LI      $dst, #0\\n\"\n+            \"done:\" %}\n+  size(16);\n+  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ AndI 0b0..010..0 + ConvI2B\n+instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{\n+  match(Set dst (Conv2B (AndI src mask)));\n+  predicate(UseRotateAndMaskInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"RLWINM  $dst, $src, $mask \\t\/\/ convI2B(AndI($src, $mask))\" %}\n+  size(4);\n+  ins_encode %{\n+    __ rlwinm($dst$$Register, $src$$Register, 32 - log2i_exact((juint)($mask$$constant)), 31, 31);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Convert pointer to boolean.\n+\/\/\n+\/\/ ptr_to_bool(src) : { 1   if src != 0\n+\/\/                    { 0   else\n+\/\/\n+\/\/ strategy:\n+\/\/ 1) Count leading zeros of 64 bit-value src,\n+\/\/    this returns 64 (0b100.0000) iff src == 0 and <64 otherwise.\n+\/\/ 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n+\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n+\n+\/\/ ConvP2B\n+instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{\n+  match(Set dst (Conv2B src));\n+  predicate(UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  expand %{\n+    immI shiftAmount %{ 0x6 %}\n+    uimmI16 mask %{ 0x1 %}\n+    iRegIdst tmp1;\n+    iRegIdst tmp2;\n+    countLeadingZerosP(tmp1, src);\n+    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n+    xorI_reg_uimm16(dst, tmp2, mask);\n+  %}\n+%}\n+\n+instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{\n+  match(Set dst (Conv2B src));\n+  effect(TEMP crx);\n+  predicate(!UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ convP2B\"\n+            \"LI      $dst, #0\\n\\t\"\n+            \"BEQ     $crx, done\\n\\t\"\n+            \"LI      $dst, #1\\n\"\n+            \"done:\" %}\n+  size(16);\n+  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ ConvP2B + XorI\n+instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{\n+  match(Set dst (XorI (Conv2B src) mask));\n+  predicate(UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  expand %{\n+    immI shiftAmount %{ 0x6 %}\n+    iRegIdst tmp1;\n+    countLeadingZerosP(tmp1, src);\n+    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n+  %}\n+%}\n+\n+instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{\n+  match(Set dst (XorI (Conv2B src) mask));\n+  effect(TEMP crx);\n+  predicate(!UseCountLeadingZerosInstructionsPPC64);\n+  ins_cost(DEFAULT_COST);\n+\n+  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ XorI(convP2B($src), $mask)\"\n+            \"LI      $dst, #1\\n\\t\"\n+            \"BEQ     $crx, done\\n\\t\"\n+            \"LI      $dst, #0\\n\"\n+            \"done:\" %}\n+  size(16);\n+  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -8025,0 +8025,30 @@\n+\/\/ int to bool\n+instruct convI2Bool(iRegINoSp dst, iRegI src)\n+%{\n+  match(Set dst (Conv2B src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"snez  $dst, $src\\t#@convI2Bool\" %}\n+\n+  ins_encode %{\n+    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ pointer to bool\n+instruct convP2Bool(iRegINoSp dst, iRegP src)\n+%{\n+  match(Set dst (Conv2B src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"snez  $dst, $src\\t#@convP2Bool\" %}\n+\n+  ins_encode %{\n+    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -562,0 +562,14 @@\n+\n+\/\/ AndI 0b0..010..0 + ConvI2B\n+instruct convI2Bool_andI_reg_immIpowerOf2(iRegINoSp dst, iRegIorL2I src, immIpowerOf2 mask) %{\n+  predicate(UseZbs);\n+  match(Set dst (Conv2B (AndI src mask)));\n+  ins_cost(ALU_COST);\n+\n+  format %{ \"bexti  $dst, $src, $mask\\t#@convI2Bool_andI_reg_immIpowerOf2\" %}\n+  ins_encode %{\n+    __ bexti($dst$$Register, $src$$Register, exact_log2((juint)($mask$$constant)));\n+  %}\n+\n+  ins_pipe(ialu_reg_reg);\n+%}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7767,0 +7767,29 @@\n+\/\/----------Convert to Boolean-------------------------------------------------\n+\n+\/\/ Convert integer to boolean.\n+instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{\n+  match(Set dst (Conv2B src));\n+  effect(KILL cr);\n+  ins_cost(3 * DEFAULT_COST);\n+  size(6);\n+  format %{ \"convI2B $dst,$src\" %}\n+  ins_encode %{\n+    __ z_lnr($dst$$Register, $src$$Register);  \/\/ Rdst := -|Rsrc|, i.e. Rdst == 0 <=> Rsrc == 0\n+    __ z_srl($dst$$Register, 31);              \/\/ Rdst := sign(Rdest)\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{\n+  match(Set dst (Conv2B src));\n+  effect(KILL cr);\n+  ins_cost(3 * DEFAULT_COST);\n+  size(10);\n+  format %{ \"convP2B $dst,$src\" %}\n+  ins_encode %{\n+    __ z_lngr($dst$$Register, $src$$Register);     \/\/ Rdst := -|Rsrc| i.e. Rdst == 0 <=> Rsrc == 0\n+    __ z_srlg($dst$$Register, $dst$$Register, 63); \/\/ Rdst := sign(Rdest)\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -8613,0 +8613,54 @@\n+\/\/----------Convert Int to Boolean---------------------------------------------\n+\n+instruct movI_nocopy(rRegI dst, rRegI src) %{\n+  effect( DEF dst, USE src );\n+  format %{ \"MOV    $dst,$src\" %}\n+  ins_encode( enc_Copy( dst, src) );\n+  ins_pipe( ialu_reg_reg );\n+%}\n+\n+instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{\n+  effect( USE_DEF dst, USE src, KILL cr );\n+\n+  size(4);\n+  format %{ \"NEG    $dst\\n\\t\"\n+            \"ADC    $dst,$src\" %}\n+  ins_encode( neg_reg(dst),\n+              OpcRegReg(0x13,dst,src) );\n+  ins_pipe( ialu_reg_reg_long );\n+%}\n+\n+instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{\n+  match(Set dst (Conv2B src));\n+\n+  expand %{\n+    movI_nocopy(dst,src);\n+    ci2b(dst,src,cr);\n+  %}\n+%}\n+\n+instruct movP_nocopy(rRegI dst, eRegP src) %{\n+  effect( DEF dst, USE src );\n+  format %{ \"MOV    $dst,$src\" %}\n+  ins_encode( enc_Copy( dst, src) );\n+  ins_pipe( ialu_reg_reg );\n+%}\n+\n+instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{\n+  effect( USE_DEF dst, USE src, KILL cr );\n+  format %{ \"NEG    $dst\\n\\t\"\n+            \"ADC    $dst,$src\" %}\n+  ins_encode( neg_reg(dst),\n+              OpcRegReg(0x13,dst,src) );\n+  ins_pipe( ialu_reg_reg_long );\n+%}\n+\n+instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{\n+  match(Set dst (Conv2B src));\n+\n+  expand %{\n+    movP_nocopy(dst,src);\n+    cp2b(dst,src,cr);\n+  %}\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -889,0 +889,13 @@\n+\n+  \/\/ Try to convert (c ? 1 : 0) ^ 1 into !c ? 1 : 0. This pattern can occur after expansion of Conv2B nodes.\n+  if (in1->Opcode() == Op_CMoveI && phase->type(in2) == TypeInt::ONE) {\n+    \/\/ Ensure the inputs to the cmove are constants 1 or 0\n+    if (phase->type(in1) == TypeInt::BOOL && in1->in(2)->is_Con() && in1->in(3)->is_Con()) {\n+      int cmp_op = in1->in(1)->in(1)->Opcode();\n+      if (cmp_op == Op_CmpI || cmp_op == Op_CmpP) {\n+        \/\/ Flip the sense of comparison in the bool and return a new cmove\n+        return new CMoveINode(phase->transform(in1->in(1)->as_Bool()->negate(phase)), in1->in(2), in1->in(3),TypeInt::BOOL);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1530,1 +1530,1 @@\n-  \/\/ If we're late in the optimization process, we may have already macro expanded Conv2B nodes\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n@@ -1577,4 +1577,3 @@\n-  Node* n = new Conv2BNode(Compile::current(), cmp->in(1));\n-  if (flipped) {\n-    n = new XorINode(phase->transform(n), phase->intcon(1));\n-  }\n+  Node *n = new Conv2BNode(cmp->in(1));\n+  if( flipped )\n+    n = new XorINode( phase->transform(n), phase->intcon(1) );\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -64,0 +66,24 @@\n+Node* Conv2BNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!Matcher::match_rule_supported(Op_Conv2B)) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      \/\/ Get type of comparison to make\n+      const Type* t = phase->type(in(1));\n+      Node* cmp = nullptr;\n+      if (t->isa_int()) {\n+        cmp = phase->transform(new CmpINode(in(1), phase->intcon(0)));\n+      } else if (t->isa_ptr()) {\n+        cmp = phase->transform(new CmpPNode(in(1), phase->zerocon(BasicType::T_OBJECT)));\n+      } else {\n+        assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[in(1)->Opcode()]);\n+      }\n+\n+      \/\/ Replace Conv2B with the cmove\n+      Node* bol = phase->transform(new BoolNode(cmp, BoolTest::eq));\n+      return new CMoveINode(bol, phase->intcon(1), phase->intcon(0), TypeInt::BOOL);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,4 +36,1 @@\n-  Conv2BNode(Compile* C, Node* i) : Node(nullptr, i) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n-  }\n+  Conv2BNode(Node* i) : Node(nullptr, i) {}\n@@ -43,0 +40,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4002,1 +4002,1 @@\n-  Node *bol     = _gvn.transform(new Conv2BNode(Compile::current(), opq));\n+  Node *bol     = _gvn.transform(new Conv2BNode(opq));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  Node* bol = new Conv2BNode(Compile::current(), opq);\n+  Node* bol = new Conv2BNode(opq);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-    Node *bol = new Conv2BNode(Compile::current(), opq);\n+    Node *bol = new Conv2BNode(opq);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2377,1 +2377,0 @@\n-               n->Opcode() == Op_Conv2B    ||\n@@ -2462,35 +2461,0 @@\n-      } else if (n->Opcode() == Op_Conv2B) {\n-        \/\/ Conv2B nodes convert an integer (or pointer) to a boolean through a '== 0' or '== null' check.\n-        \/\/ As this conversion is essentially a special case of a conditional move, it can be generalized before going to the backend.\n-\n-        \/\/ Conv2B nodes can be created with an xor of one, flipping the result. Try to detect that pattern.\n-        Node* flip_xor = nullptr;\n-        if (n->outcnt() == 1) {\n-          Node* n_out = n->unique_out();\n-          if (n_out->Opcode() == Op_XorI && _igvn.type(n_out->in(2)) == TypeInt::ONE) {\n-            flip_xor = n_out;\n-          }\n-        }\n-\n-        \/\/ Get the type of comparison to make\n-        const Type* t = _igvn.type(n->in(1));\n-        Node* cmp = nullptr;\n-        if (t->isa_int()) {\n-          cmp = _igvn.transform(new CmpINode(n->in(1), _igvn.intcon(0)));\n-        } else if (t->isa_ptr()) {\n-          cmp = _igvn.transform(new CmpPNode(n->in(1), _igvn.zerocon(BasicType::T_OBJECT)));\n-        } else {\n-          assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[n->in(1)->Opcode()]);\n-        }\n-\n-        Node* bol = _igvn.transform(new BoolNode(cmp, flip_xor == nullptr ? BoolTest::eq : BoolTest::ne));\n-        Node* cmov = _igvn.transform(new CMoveINode(bol, _igvn.intcon(1), _igvn.intcon(0), TypeInt::BOOL));\n-        \/\/ If the xor is found then replace it with the cmov, subsuming its outputs. If not, replace the Conv2B node.\n-        _igvn.replace_node(flip_xor == nullptr ? n : flip_xor, cmov);\n-\n-        \/\/ If the xor was subsumed, the Conv2B node needs to be removed as it's now dead.\n-        if (flip_xor != nullptr) {\n-          _igvn.remove_dead_node(n);\n-          C->remove_macro_node(n);\n-        }\n-        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  \/\/ If we're late in the optimization process, we may have already macro expanded Conv2B nodes\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n@@ -245,8 +245,4 @@\n-  if (PrintOpto) {\n-    tty->print_cr(\"CMOV to I2B\");\n-  }\n-\n-  Node* n = new Conv2BNode(Compile::current(), cmp->in(1));\n-  if (flip) {\n-    n = new XorINode(phase->transform(n), phase->intcon(1));\n-  }\n+  if (PrintOpto) { tty->print_cr(\"CMOV to I2B\"); }\n+  Node *n = new Conv2BNode( cmp->in(1) );\n+  if( flip )\n+    n = new XorINode( phase->transform(n), phase->intcon(1) );\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @summary Test that patterns leading to Conv2B are correctly macro expanded.\n+ * @summary Test that patterns leading to Conv2B are correctly expanded.\n@@ -37,0 +37,1 @@\n+ * @requires os.arch == \"x86_64\" | os.arch == \"amd64\" | os.arch == \"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}