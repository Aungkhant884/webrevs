{"files":[{"patch":"@@ -14955,36 +14955,0 @@\n-instruct convI2B(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpw $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpw(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct convP2B(iRegINoSp dst, iRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmp  $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmp(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7041,33 +7041,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{ \/\/ FIXME: can do better?\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n-instruct convP2B( iRegI dst, iRegP src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3209,24 +3209,0 @@\n-  enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n-    Label done;\n-    __ cmpwi($crx$$CondRegister, $src$$Register, 0);\n-    __ li($dst$$Register, $zero$$constant);\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, $notzero$$constant);\n-    __ bind(done);\n-  %}\n-\n-  enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n-    Label done;\n-    __ cmpdi($crx$$CondRegister, $src$$Register, 0);\n-    __ li($dst$$Register, $zero$$constant);\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, $notzero$$constant);\n-    __ bind(done);\n-  %}\n-\n@@ -10416,162 +10392,0 @@\n-\/\/ Convert to boolean.\n-\n-\/\/ int_to_bool(src) : { 1   if src != 0\n-\/\/                    { 0   else\n-\/\/\n-\/\/ strategy:\n-\/\/ 1) Count leading zeros of 32 bit-value src,\n-\/\/    this returns 32 (0b10.0000) iff src == 0 and <32 otherwise.\n-\/\/ 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n-\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n-\n-\/\/ convI2Bool\n-instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (Conv2B src));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x5 %}\n-    uimmI16 mask %{ 0x1 %}\n-    iRegIdst tmp1;\n-    iRegIdst tmp2;\n-    countLeadingZerosI(tmp1, src);\n-    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n-    xorI_reg_uimm16(dst, tmp2, mask);\n-  %}\n-%}\n-\n-instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{\n-  match(Set dst (Conv2B src));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ convI2B\"\n-            \"LI      $dst, #0\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #1\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ ConvI2B + XorI\n-instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x5 %}\n-    iRegIdst tmp1;\n-    countLeadingZerosI(tmp1, src);\n-    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n-  %}\n-%}\n-\n-instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ Xor(convI2B($src), $mask)\"\n-            \"LI      $dst, #1\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #0\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ AndI 0b0..010..0 + ConvI2B\n-instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{\n-  match(Set dst (Conv2B (AndI src mask)));\n-  predicate(UseRotateAndMaskInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"RLWINM  $dst, $src, $mask \\t\/\/ convI2B(AndI($src, $mask))\" %}\n-  size(4);\n-  ins_encode %{\n-    __ rlwinm($dst$$Register, $src$$Register, 32 - log2i_exact((juint)($mask$$constant)), 31, 31);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Convert pointer to boolean.\n-\/\/\n-\/\/ ptr_to_bool(src) : { 1   if src != 0\n-\/\/                    { 0   else\n-\/\/\n-\/\/ strategy:\n-\/\/ 1) Count leading zeros of 64 bit-value src,\n-\/\/    this returns 64 (0b100.0000) iff src == 0 and <64 otherwise.\n-\/\/ 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n-\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n-\n-\/\/ ConvP2B\n-instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{\n-  match(Set dst (Conv2B src));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x6 %}\n-    uimmI16 mask %{ 0x1 %}\n-    iRegIdst tmp1;\n-    iRegIdst tmp2;\n-    countLeadingZerosP(tmp1, src);\n-    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n-    xorI_reg_uimm16(dst, tmp2, mask);\n-  %}\n-%}\n-\n-instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{\n-  match(Set dst (Conv2B src));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ convP2B\"\n-            \"LI      $dst, #0\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #1\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ ConvP2B + XorI\n-instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x6 %}\n-    iRegIdst tmp1;\n-    countLeadingZerosP(tmp1, src);\n-    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n-  %}\n-%}\n-\n-instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ XorI(convP2B($src), $mask)\"\n-            \"LI      $dst, #1\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #0\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":186,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -8025,30 +8025,0 @@\n-\/\/ int to bool\n-instruct convI2Bool(iRegINoSp dst, iRegI src)\n-%{\n-  match(Set dst (Conv2B src));\n-\n-  ins_cost(ALU_COST);\n-  format %{ \"snez  $dst, $src\\t#@convI2Bool\" %}\n-\n-  ins_encode %{\n-    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ pointer to bool\n-instruct convP2Bool(iRegINoSp dst, iRegP src)\n-%{\n-  match(Set dst (Conv2B src));\n-\n-  ins_cost(ALU_COST);\n-  format %{ \"snez  $dst, $src\\t#@convP2Bool\" %}\n-\n-  ins_encode %{\n-    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -562,14 +562,0 @@\n-\n-\/\/ AndI 0b0..010..0 + ConvI2B\n-instruct convI2Bool_andI_reg_immIpowerOf2(iRegINoSp dst, iRegIorL2I src, immIpowerOf2 mask) %{\n-  predicate(UseZbs);\n-  match(Set dst (Conv2B (AndI src mask)));\n-  ins_cost(ALU_COST);\n-\n-  format %{ \"bexti  $dst, $src, $mask\\t#@convI2Bool_andI_reg_immIpowerOf2\" %}\n-  ins_encode %{\n-    __ bexti($dst$$Register, $src$$Register, exact_log2((juint)($mask$$constant)));\n-  %}\n-\n-  ins_pipe(ialu_reg_reg);\n-%}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7767,29 +7767,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-\n-\/\/ Convert integer to boolean.\n-instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(3 * DEFAULT_COST);\n-  size(6);\n-  format %{ \"convI2B $dst,$src\" %}\n-  ins_encode %{\n-    __ z_lnr($dst$$Register, $src$$Register);  \/\/ Rdst := -|Rsrc|, i.e. Rdst == 0 <=> Rsrc == 0\n-    __ z_srl($dst$$Register, 31);              \/\/ Rdst := sign(Rdest)\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(3 * DEFAULT_COST);\n-  size(10);\n-  format %{ \"convP2B $dst,$src\" %}\n-  ins_encode %{\n-    __ z_lngr($dst$$Register, $src$$Register);     \/\/ Rdst := -|Rsrc| i.e. Rdst == 0 <=> Rsrc == 0\n-    __ z_srlg($dst$$Register, $dst$$Register, 63); \/\/ Rdst := sign(Rdest)\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -12400,4 +12400,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | dst->encoding()));\n-}\n-\n@@ -12408,5 +12404,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  int enc = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | enc));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2243,2 +2243,0 @@\n-  void set_byte_if_not_zero(Register dst); \/\/ sets reg to 1 if not zero, otherwise 0\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2837,1 +2837,1 @@\n-    __ set_byte_if_not_zero(dest);\n+    __ setne(dest);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -8613,54 +8613,0 @@\n-\/\/----------Convert Int to Boolean---------------------------------------------\n-\n-instruct movI_nocopy(rRegI dst, rRegI src) %{\n-  effect( DEF dst, USE src );\n-  format %{ \"MOV    $dst,$src\" %}\n-  ins_encode( enc_Copy( dst, src) );\n-  ins_pipe( ialu_reg_reg );\n-%}\n-\n-instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{\n-  effect( USE_DEF dst, USE src, KILL cr );\n-\n-  size(4);\n-  format %{ \"NEG    $dst\\n\\t\"\n-            \"ADC    $dst,$src\" %}\n-  ins_encode( neg_reg(dst),\n-              OpcRegReg(0x13,dst,src) );\n-  ins_pipe( ialu_reg_reg_long );\n-%}\n-\n-instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{\n-  match(Set dst (Conv2B src));\n-\n-  expand %{\n-    movI_nocopy(dst,src);\n-    ci2b(dst,src,cr);\n-  %}\n-%}\n-\n-instruct movP_nocopy(rRegI dst, eRegP src) %{\n-  effect( DEF dst, USE src );\n-  format %{ \"MOV    $dst,$src\" %}\n-  ins_encode( enc_Copy( dst, src) );\n-  ins_pipe( ialu_reg_reg );\n-%}\n-\n-instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{\n-  effect( USE_DEF dst, USE src, KILL cr );\n-  format %{ \"NEG    $dst\\n\\t\"\n-            \"ADC    $dst,$src\" %}\n-  ins_encode( neg_reg(dst),\n-              OpcRegReg(0x13,dst,src) );\n-  ins_pipe( ialu_reg_reg_long );\n-%}\n-\n-instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{\n-  match(Set dst (Conv2B src));\n-\n-  expand %{\n-    movP_nocopy(dst,src);\n-    cp2b(dst,src,cr);\n-  %}\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -10639,34 +10639,0 @@\n-\/\/ Convert Int to Boolean\n-instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1529,0 +1529,6 @@\n+\n+  \/\/ If we're late in the optimization process, we may have already macro expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase()) {\n+    return nullptr;\n+  }\n+\n@@ -1571,3 +1577,4 @@\n-  Node *n = new Conv2BNode(cmp->in(1));\n-  if( flipped )\n-    n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(Compile::current(), cmp->in(1));\n+  if (flipped) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,4 @@\n-  Conv2BNode( Node *i ) : Node(0,i) {}\n+  Conv2BNode(Compile* C, Node* i) : Node(nullptr, i) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4002,1 +4002,1 @@\n-  Node *bol     = _gvn.transform(new Conv2BNode(opq));\n+  Node *bol     = _gvn.transform(new Conv2BNode(Compile::current(), opq));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  Node* bol = new Conv2BNode(opq);\n+  Node* bol = new Conv2BNode(Compile::current(), opq);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-    Node *bol = new Conv2BNode(opq);\n+    Node *bol = new Conv2BNode(Compile::current(), opq);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -2376,0 +2377,1 @@\n+               n->Opcode() == Op_Conv2B    ||\n@@ -2460,0 +2462,35 @@\n+      } else if (n->Opcode() == Op_Conv2B) {\n+        \/\/ Conv2B nodes convert an integer (or pointer) to a boolean through a '== 0' or '== null' check.\n+        \/\/ As this conversion is essentially a special case of a conditional move, it can be generalized before going to the backend.\n+\n+        \/\/ Conv2B nodes can be created with an xor of one, flipping the result. Try to detect that pattern.\n+        Node* flip_xor = nullptr;\n+        if (n->outcnt() == 1) {\n+          Node* n_out = n->unique_out();\n+          if (n_out->Opcode() == Op_XorI && _igvn.type(n_out->in(2)) == TypeInt::ONE) {\n+            flip_xor = n_out;\n+          }\n+        }\n+\n+        \/\/ Get the type of comparison to make\n+        const Type* t = _igvn.type(n->in(1));\n+        Node* cmp = nullptr;\n+        if (t->isa_int()) {\n+          cmp = _igvn.transform(new CmpINode(n->in(1), _igvn.intcon(0)));\n+        } else if (t->isa_ptr()) {\n+          cmp = _igvn.transform(new CmpPNode(n->in(1), _igvn.zerocon(BasicType::T_OBJECT)));\n+        } else {\n+          assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[n->in(1)->Opcode()]);\n+        }\n+\n+        Node* bol = _igvn.transform(new BoolNode(cmp, flip_xor == nullptr ? BoolTest::eq : BoolTest::ne));\n+        Node* cmov = _igvn.transform(new CMoveINode(bol, _igvn.intcon(1), _igvn.intcon(0), TypeInt::BOOL));\n+        \/\/ If the xor is found then replace it with the cmov, subsuming its outputs. If not, replace the Conv2B node.\n+        _igvn.replace_node(flip_xor == nullptr ? n : flip_xor, cmov);\n+\n+        \/\/ If the xor was subsumed, the Conv2B node needs to be removed as it's now dead.\n+        if (flip_xor != nullptr) {\n+          _igvn.remove_dead_node(n);\n+          C->remove_macro_node(n);\n+        }\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -210,0 +210,5 @@\n+  \/\/ If we're late in the optimization process, we may have already macro expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase()) {\n+    return nullptr;\n+  }\n+\n@@ -240,4 +245,8 @@\n-  if (PrintOpto) { tty->print_cr(\"CMOV to I2B\"); }\n-  Node *n = new Conv2BNode( cmp->in(1) );\n-  if( flip )\n-  n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  if (PrintOpto) {\n+    tty->print_cr(\"CMOV to I2B\");\n+  }\n+\n+  Node* n = new Conv2BNode(Compile::current(), cmp->in(1));\n+  if (flip) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns leading to Conv2B are correctly macro expanded.\n+ * @bug 8051725\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestConv2BExpansion\n+ *\/\n+public class TestConv2BExpansion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testIntEquals0(int x) {\n+        return x == 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testIntNotEquals0(int x) {\n+        return x != 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testObjEqualsNull(Object o) {\n+        return o == null;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testObjNotEqualsNull(Object o) {\n+        return o != null;\n+    }\n+\n+    @Run(test = {\"testIntEquals0\", \"testIntNotEquals0\"})\n+    public void runTestInts() {\n+        assertResult(0);\n+        assertResult(1);\n+    }\n+\n+    @Run(test = {\"testObjEqualsNull\", \"testObjNotEqualsNull\"})\n+    public void runTestObjs() {\n+        assertResult(new Object());\n+        assertResult(null);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x) {\n+        Asserts.assertEQ(x == 0, testIntEquals0(x));\n+        Asserts.assertEQ(x != 0, testIntNotEquals0(x));\n+    }\n+\n+    @DontCompile\n+    public void assertResult(Object o) {\n+        Asserts.assertEQ(o == null, testObjEqualsNull(o));\n+        Asserts.assertEQ(o != null, testObjNotEqualsNull(o));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class Conv2BRules {\n+    @Benchmark\n+    public void testNotEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j != 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals1(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testNotEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o != null);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o == null);\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        int[] ints;\n+        Object[] objs;\n+\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            ints = new int[128];\n+            objs = new Object[128];\n+            for (int i = 0; i < 128; i++) {\n+                ints[i] = random.nextInt(3);\n+                objs[i] = random.nextInt(3) == 0 ? null : new Object();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/Conv2BRules.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}