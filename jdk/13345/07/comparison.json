{"files":[{"patch":"@@ -14955,36 +14955,0 @@\n-instruct convI2B(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpw $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpw(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct convP2B(iRegINoSp dst, iRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmp  $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmp(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7045,33 +7045,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{ \/\/ FIXME: can do better?\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n-instruct convP2B( iRegI dst, iRegP src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -5880,15 +5880,0 @@\n-void Assembler::sete(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x94, (0xC0 | encode));\n-}\n-\n-void Assembler::setl(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x9C, (0xC0 | encode));\n-}\n-\n-void Assembler::setne(Register dst) {\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | encode));\n-}\n-\n@@ -12400,4 +12385,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | dst->encoding()));\n-}\n-\n@@ -12408,5 +12389,0 @@\n-void Assembler::set_byte_if_not_zero(Register dst) {\n-  int enc = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x95, (0xC0 | enc));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2092,4 +2092,0 @@\n-  void sete(Register dst);\n-  void setl(Register dst);\n-  void setne(Register dst);\n-\n@@ -2243,2 +2239,0 @@\n-  void set_byte_if_not_zero(Register dst); \/\/ sets reg to 1 if not zero, otherwise 0\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2837,1 +2837,1 @@\n-    __ set_byte_if_not_zero(dest);\n+    __ setb(Assembler::notZero, dest);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8096,1 +8096,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8119,1 +8119,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8141,1 +8141,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8163,1 +8163,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8185,1 +8185,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8206,1 +8206,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -10629,34 +10629,0 @@\n-\/\/ Convert Int to Boolean\n-instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n@@ -10675,1 +10641,1 @@\n-    __ setl($dst$$Register);\n+    __ setb(Assembler::less, $dst$$Register);\n@@ -12809,1 +12775,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -12835,1 +12801,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -12861,1 +12827,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -889,0 +889,16 @@\n+\n+  \/\/ Propagate xor through constant cmoves. This pattern can occur after expansion of Conv2B nodes.\n+  if (in1->Opcode() == Op_CMoveI && in2->is_Con()) {\n+    if (in1->in(CMoveNode::IfFalse)->is_Con() && in1->in(CMoveNode::IfTrue)->is_Con() && in1->in(CMoveNode::Condition)->is_Bool()) {\n+      int cmp_op = in1->in(CMoveNode::Condition)->in(1)->Opcode();\n+\n+      int in2_val = phase->type(in2)->is_int()->get_con();\n+      int l_val = phase->type(in1->in(CMoveNode::IfFalse))->is_int()->get_con();\n+      int r_val = phase->type(in1->in(CMoveNode::IfTrue))->is_int()->get_con();\n+\n+      if (cmp_op == Op_CmpI || cmp_op == Op_CmpP) {\n+        return new CMoveINode(in1->in(CMoveNode::Condition), phase->intcon(l_val ^ in2_val), phase->intcon(r_val ^ in2_val), TypeInt::INT);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1526,0 +1526,6 @@\n+\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -1568,3 +1574,4 @@\n-  Node *n = new Conv2BNode(cmp->in(1));\n-  if( flipped )\n-    n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flipped) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -64,0 +66,24 @@\n+Node* Conv2BNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!Matcher::match_rule_supported(Op_Conv2B)) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      \/\/ Get type of comparison to make\n+      const Type* t = phase->type(in(1));\n+      Node* cmp = nullptr;\n+      if (t->isa_int()) {\n+        cmp = phase->transform(new CmpINode(in(1), phase->intcon(0)));\n+      } else if (t->isa_ptr()) {\n+        cmp = phase->transform(new CmpPNode(in(1), phase->zerocon(BasicType::T_OBJECT)));\n+      } else {\n+        assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[in(1)->Opcode()]);\n+      }\n+\n+      \/\/ Replace Conv2B with the cmove\n+      Node* bol = phase->transform(new BoolNode(cmp, BoolTest::eq));\n+      return new CMoveINode(bol, phase->intcon(1), phase->intcon(0), TypeInt::BOOL);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  Conv2BNode( Node *i ) : Node(0,i) {}\n+  Conv2BNode(Node* i) : Node(nullptr, i) {}\n@@ -40,0 +40,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -210,0 +211,5 @@\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -241,3 +247,4 @@\n-  Node *n = new Conv2BNode( cmp->in(1) );\n-  if( flip )\n-  n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flip) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns leading to Conv2B are correctly expanded.\n+ * @bug 8051725\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"x86_64\" | os.arch == \"amd64\" | os.arch == \"aarch64\"\n+ * @run driver compiler.c2.irTests.TestConv2BExpansion\n+ *\/\n+public class TestConv2BExpansion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testIntEquals0(int x) {\n+        return x == 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testIntNotEquals0(int x) {\n+        return x != 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testObjEqualsNull(Object o) {\n+        return o == null;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testObjNotEqualsNull(Object o) {\n+        return o != null;\n+    }\n+\n+    @Run(test = {\"testIntEquals0\", \"testIntNotEquals0\"})\n+    public void runTestInts() {\n+        assertResult(0);\n+        assertResult(1);\n+    }\n+\n+    @Run(test = {\"testObjEqualsNull\", \"testObjNotEqualsNull\"})\n+    public void runTestObjs() {\n+        assertResult(new Object());\n+        assertResult(null);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x) {\n+        Asserts.assertEQ(x == 0, testIntEquals0(x));\n+        Asserts.assertEQ(x != 0, testIntNotEquals0(x));\n+    }\n+\n+    @DontCompile\n+    public void assertResult(Object o) {\n+        Asserts.assertEQ(o == null, testObjEqualsNull(o));\n+        Asserts.assertEQ(o != null, testObjNotEqualsNull(o));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 4, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class Conv2BRules {\n+    @Benchmark\n+    public void testNotEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j != 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals0(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEquals1(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            int j = state.ints[i];\n+            blackhole.consume(j == 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testNotEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o != null);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testEqualsNull(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 128; i++) {\n+            Object o = state.objs[i];\n+            blackhole.consume(o == null);\n+        }\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        int[] ints;\n+        Object[] objs;\n+\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup(Level.Iteration)\n+        public void setup() {\n+            Random random = new Random(1000);\n+            ints = new int[128];\n+            objs = new Object[128];\n+            for (int i = 0; i < 128; i++) {\n+                ints[i] = random.nextInt(3);\n+                objs[i] = random.nextInt(3) == 0 ? null : new Object();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/Conv2BRules.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}