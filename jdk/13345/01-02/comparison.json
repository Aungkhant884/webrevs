{"files":[{"patch":"@@ -14955,36 +14955,0 @@\n-instruct convI2B(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpw $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpw(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct convP2B(iRegINoSp dst, iRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmp  $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmp(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7041,33 +7041,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{ \/\/ FIXME: can do better?\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n-instruct convP2B( iRegI dst, iRegP src, flagsReg ccr ) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL ccr);\n-  size(12);\n-  ins_cost(DEFAULT_COST*2);\n-  format %{ \"TST    $src,$src \\n\\t\"\n-            \"MOV    $dst, 0   \\n\\t\"\n-            \"MOV.ne $dst, 1\" %}\n-  ins_encode %{\n-    __ tst($src$$Register, $src$$Register);\n-    __ mov($dst$$Register, 0);\n-    __ mov($dst$$Register, 1, ne);\n-  %}\n-  ins_pipe(ialu_reg_ialu);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3209,24 +3209,0 @@\n-  enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n-    Label done;\n-    __ cmpwi($crx$$CondRegister, $src$$Register, 0);\n-    __ li($dst$$Register, $zero$$constant);\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, $notzero$$constant);\n-    __ bind(done);\n-  %}\n-\n-  enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{\n-\n-    C2_MacroAssembler _masm(&cbuf);\n-\n-    Label done;\n-    __ cmpdi($crx$$CondRegister, $src$$Register, 0);\n-    __ li($dst$$Register, $zero$$constant);\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, $notzero$$constant);\n-    __ bind(done);\n-  %}\n-\n@@ -10416,162 +10392,0 @@\n-\/\/ Convert to boolean.\n-\n-\/\/ int_to_bool(src) : { 1   if src != 0\n-\/\/                    { 0   else\n-\/\/\n-\/\/ strategy:\n-\/\/ 1) Count leading zeros of 32 bit-value src,\n-\/\/    this returns 32 (0b10.0000) iff src == 0 and <32 otherwise.\n-\/\/ 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n-\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n-\n-\/\/ convI2Bool\n-instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (Conv2B src));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x5 %}\n-    uimmI16 mask %{ 0x1 %}\n-    iRegIdst tmp1;\n-    iRegIdst tmp2;\n-    countLeadingZerosI(tmp1, src);\n-    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n-    xorI_reg_uimm16(dst, tmp2, mask);\n-  %}\n-%}\n-\n-instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{\n-  match(Set dst (Conv2B src));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ convI2B\"\n-            \"LI      $dst, #0\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #1\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ ConvI2B + XorI\n-instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x5 %}\n-    iRegIdst tmp1;\n-    countLeadingZerosI(tmp1, src);\n-    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n-  %}\n-%}\n-\n-instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPWI   $crx, $src, #0 \\t\/\/ Xor(convI2B($src), $mask)\"\n-            \"LI      $dst, #1\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #0\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ AndI 0b0..010..0 + ConvI2B\n-instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{\n-  match(Set dst (Conv2B (AndI src mask)));\n-  predicate(UseRotateAndMaskInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"RLWINM  $dst, $src, $mask \\t\/\/ convI2B(AndI($src, $mask))\" %}\n-  size(4);\n-  ins_encode %{\n-    __ rlwinm($dst$$Register, $src$$Register, 32 - log2i_exact((juint)($mask$$constant)), 31, 31);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ Convert pointer to boolean.\n-\/\/\n-\/\/ ptr_to_bool(src) : { 1   if src != 0\n-\/\/                    { 0   else\n-\/\/\n-\/\/ strategy:\n-\/\/ 1) Count leading zeros of 64 bit-value src,\n-\/\/    this returns 64 (0b100.0000) iff src == 0 and <64 otherwise.\n-\/\/ 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.\n-\/\/ 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.\n-\n-\/\/ ConvP2B\n-instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{\n-  match(Set dst (Conv2B src));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x6 %}\n-    uimmI16 mask %{ 0x1 %}\n-    iRegIdst tmp1;\n-    iRegIdst tmp2;\n-    countLeadingZerosP(tmp1, src);\n-    urShiftI_reg_imm(tmp2, tmp1, shiftAmount);\n-    xorI_reg_uimm16(dst, tmp2, mask);\n-  %}\n-%}\n-\n-instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{\n-  match(Set dst (Conv2B src));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ convP2B\"\n-            \"LI      $dst, #0\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #1\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-\/\/ ConvP2B + XorI\n-instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  predicate(UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    immI shiftAmount %{ 0x6 %}\n-    iRegIdst tmp1;\n-    countLeadingZerosP(tmp1, src);\n-    urShiftI_reg_imm(dst, tmp1, shiftAmount);\n-  %}\n-%}\n-\n-instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{\n-  match(Set dst (XorI (Conv2B src) mask));\n-  effect(TEMP crx);\n-  predicate(!UseCountLeadingZerosInstructionsPPC64);\n-  ins_cost(DEFAULT_COST);\n-\n-  format %{ \"CMPDI   $crx, $src, #0 \\t\/\/ XorI(convP2B($src), $mask)\"\n-            \"LI      $dst, #1\\n\\t\"\n-            \"BEQ     $crx, done\\n\\t\"\n-            \"LI      $dst, #0\\n\"\n-            \"done:\" %}\n-  size(16);\n-  ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":186,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -8025,30 +8025,0 @@\n-\/\/ int to bool\n-instruct convI2Bool(iRegINoSp dst, iRegI src)\n-%{\n-  match(Set dst (Conv2B src));\n-\n-  ins_cost(ALU_COST);\n-  format %{ \"snez  $dst, $src\\t#@convI2Bool\" %}\n-\n-  ins_encode %{\n-    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ pointer to bool\n-instruct convP2Bool(iRegINoSp dst, iRegP src)\n-%{\n-  match(Set dst (Conv2B src));\n-\n-  ins_cost(ALU_COST);\n-  format %{ \"snez  $dst, $src\\t#@convP2Bool\" %}\n-\n-  ins_encode %{\n-    __ snez(as_Register($dst$$reg), as_Register($src$$reg));\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -562,14 +562,0 @@\n-\n-\/\/ AndI 0b0..010..0 + ConvI2B\n-instruct convI2Bool_andI_reg_immIpowerOf2(iRegINoSp dst, iRegIorL2I src, immIpowerOf2 mask) %{\n-  predicate(UseZbs);\n-  match(Set dst (Conv2B (AndI src mask)));\n-  ins_cost(ALU_COST);\n-\n-  format %{ \"bexti  $dst, $src, $mask\\t#@convI2Bool_andI_reg_immIpowerOf2\" %}\n-  ins_encode %{\n-    __ bexti($dst$$Register, $src$$Register, exact_log2((juint)($mask$$constant)));\n-  %}\n-\n-  ins_pipe(ialu_reg_reg);\n-%}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7767,29 +7767,0 @@\n-\/\/----------Convert to Boolean-------------------------------------------------\n-\n-\/\/ Convert integer to boolean.\n-instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(3 * DEFAULT_COST);\n-  size(6);\n-  format %{ \"convI2B $dst,$src\" %}\n-  ins_encode %{\n-    __ z_lnr($dst$$Register, $src$$Register);  \/\/ Rdst := -|Rsrc|, i.e. Rdst == 0 <=> Rsrc == 0\n-    __ z_srl($dst$$Register, 31);              \/\/ Rdst := sign(Rdest)\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(3 * DEFAULT_COST);\n-  size(10);\n-  format %{ \"convP2B $dst,$src\" %}\n-  ins_encode %{\n-    __ z_lngr($dst$$Register, $src$$Register);     \/\/ Rdst := -|Rsrc| i.e. Rdst == 0 <=> Rsrc == 0\n-    __ z_srlg($dst$$Register, $dst$$Register, 63); \/\/ Rdst := sign(Rdest)\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -8613,54 +8613,0 @@\n-\/\/----------Convert Int to Boolean---------------------------------------------\n-\n-instruct movI_nocopy(rRegI dst, rRegI src) %{\n-  effect( DEF dst, USE src );\n-  format %{ \"MOV    $dst,$src\" %}\n-  ins_encode( enc_Copy( dst, src) );\n-  ins_pipe( ialu_reg_reg );\n-%}\n-\n-instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{\n-  effect( USE_DEF dst, USE src, KILL cr );\n-\n-  size(4);\n-  format %{ \"NEG    $dst\\n\\t\"\n-            \"ADC    $dst,$src\" %}\n-  ins_encode( neg_reg(dst),\n-              OpcRegReg(0x13,dst,src) );\n-  ins_pipe( ialu_reg_reg_long );\n-%}\n-\n-instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{\n-  match(Set dst (Conv2B src));\n-\n-  expand %{\n-    movI_nocopy(dst,src);\n-    ci2b(dst,src,cr);\n-  %}\n-%}\n-\n-instruct movP_nocopy(rRegI dst, eRegP src) %{\n-  effect( DEF dst, USE src );\n-  format %{ \"MOV    $dst,$src\" %}\n-  ins_encode( enc_Copy( dst, src) );\n-  ins_pipe( ialu_reg_reg );\n-%}\n-\n-instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{\n-  effect( USE_DEF dst, USE src, KILL cr );\n-  format %{ \"NEG    $dst\\n\\t\"\n-            \"ADC    $dst,$src\" %}\n-  ins_encode( neg_reg(dst),\n-              OpcRegReg(0x13,dst,src) );\n-  ins_pipe( ialu_reg_reg_long );\n-%}\n-\n-instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{\n-  match(Set dst (Conv2B src));\n-\n-  expand %{\n-    movP_nocopy(dst,src);\n-    cp2b(dst,src,cr);\n-  %}\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -10639,74 +10639,0 @@\n-\/\/ Convert Int to Boolean\n-instruct convI2B_Flip(rRegI dst, rRegI src, immI_1 one, rFlagsReg cr)\n-%{\n-  match(Set dst (XorI (Conv2B src) one));\n-  effect(KILL cr);\n-  ins_cost(125);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"sete    $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ sete($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Int to Boolean\n-instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(150);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ setne($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B_Flip(rRegI dst, rRegP src, immI_1 one, rFlagsReg cr)\n-%{\n-  match(Set dst (XorI (Conv2B src) one));\n-  effect(KILL cr);\n-  ins_cost(125);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"sete    $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ sete($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-  ins_cost(150);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ setne($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @summary Test that patterns leading to Conv2B are correctly macro expanded.\n+ * @bug 8051725\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestConv2BExpansion\n+ *\/\n+public class TestConv2BExpansion {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testIntEquals0(int x) {\n+        return x == 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testIntNotEquals0(int x) {\n+        return x != 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"}, failOn = {IRNode.XOR})\n+    public boolean testObjEqualsNull(Object o) {\n+        return o == null;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public boolean testObjNotEqualsNull(Object o) {\n+        return o != null;\n+    }\n+\n+    @Run(test = {\"testIntEquals0\", \"testIntNotEquals0\"})\n+    public void runTestInts() {\n+        assertResult(0);\n+        assertResult(1);\n+    }\n+\n+    @Run(test = {\"testObjEqualsNull\", \"testObjNotEqualsNull\"})\n+    public void runTestObjs() {\n+        assertResult(new Object());\n+        assertResult(null);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x) {\n+        Asserts.assertEQ(x == 0, testIntEquals0(x));\n+        Asserts.assertEQ(x != 0, testIntNotEquals0(x));\n+    }\n+\n+    @DontCompile\n+    public void assertResult(Object o) {\n+        Asserts.assertEQ(o == null, testObjEqualsNull(o));\n+        Asserts.assertEQ(o != null, testObjNotEqualsNull(o));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests.x86;\n-\n-import jdk.test.lib.Asserts;\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @summary Test that Conv2B nodes are matched into the correct mach nodes on x86_64.\n- * @bug 8051725\n- * @library \/test\/lib \/\n- * @requires vm.compiler2.enabled\n- * @requires os.arch == \"x86_64\" | os.arch == \"amd64\"\n- * @run driver compiler.c2.irTests.x86.TestConv2BMatches\n- *\/\n-public class TestConv2BMatches {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMOVEI_01_X86, \"1\"})\n-    public boolean testIntEquals0(int x) {\n-        return x == 0;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMOVEI_01_X86, \"1\"})\n-    public boolean testIntNotEquals0(int x) {\n-        return x != 0;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMOVEI_01_X86, \"1\"})\n-    public boolean testObjEqualsNull(Object o) {\n-        return o == null;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.CMOVEI_01_X86, \"1\"})\n-    public boolean testObjNotEqualsNull(Object o) {\n-        return o != null;\n-    }\n-\n-    @Run(test = {\"testIntEquals0\", \"testIntNotEquals0\"})\n-    public void runTestInts() {\n-        assertResult(0);\n-        assertResult(1);\n-    }\n-\n-    @Run(test = {\"testObjEqualsNull\", \"testObjNotEqualsNull\"})\n-    public void runTestObjs() {\n-        assertResult(new Object());\n-        assertResult(null);\n-    }\n-\n-    @DontCompile\n-    public void assertResult(int x) {\n-        Asserts.assertEQ(x == 0, testIntEquals0(x));\n-        Asserts.assertEQ(x != 0, testIntNotEquals0(x));\n-    }\n-\n-    @DontCompile\n-    public void assertResult(Object o) {\n-        Asserts.assertEQ(o == null, testObjEqualsNull(o));\n-        Asserts.assertEQ(o != null, testObjNotEqualsNull(o));\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/x86\/TestConv2BMatches.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1421,7 +1421,0 @@\n-    \/\/ x86 specific\n-\n-    public static final String CMOVEI_01_X86 = PREFIX + \"CMOVEI_01_X86\" + POSTFIX;\n-    static {\n-        machOnlyNameRegex(CMOVEI_01_X86, \"cmovI_imm_01\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}