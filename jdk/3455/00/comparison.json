{"files":[{"patch":"@@ -352,6 +352,12 @@\n-template <typename T>\n-bool ZMark::drain_and_flush(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks, ZMarkCache* cache, T* timeout) {\n-  const bool success = drain(stripe, stacks, cache, timeout);\n-\n-  \/\/ Flush and publish worker stacks\n-  stacks->flush(&_allocator, &_stripes);\n+bool ZMark::try_steal_local(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks) {\n+  \/\/ Try to steal a local stack from another stripe\n+  for (ZMarkStripe* victim_stripe = _stripes.stripe_next(stripe);\n+       victim_stripe != stripe;\n+       victim_stripe = _stripes.stripe_next(victim_stripe)) {\n+    ZMarkStack* const stack = stacks->steal(&_stripes, victim_stripe);\n+    if (stack != NULL) {\n+      \/\/ Success, install the stolen stack\n+      stacks->install(&_stripes, stripe, stack);\n+      return true;\n+    }\n+  }\n@@ -359,1 +365,2 @@\n-  return success;\n+  \/\/ Nothing to steal\n+  return false;\n@@ -362,1 +369,1 @@\n-bool ZMark::try_steal(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks) {\n+bool ZMark::try_steal_global(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks) {\n@@ -379,0 +386,4 @@\n+bool ZMark::try_steal(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks) {\n+  return try_steal_local(stripe, stacks) || try_steal_global(stripe, stacks);\n+}\n+\n@@ -498,1 +509,1 @@\n-    drain_and_flush(stripe, stacks, cache, &no_timeout);\n+    drain(stripe, stacks, cache, &no_timeout);\n@@ -560,1 +571,1 @@\n-    if (!drain_and_flush(stripe, stacks, cache, &timeout)) {\n+    if (!drain(stripe, stacks, cache, &timeout)) {\n@@ -586,2 +597,2 @@\n-  \/\/ Make sure stacks have been flushed\n-  assert(stacks->is_empty(&_stripes), \"Should be empty\");\n+  \/\/ Flush and publish stacks\n+  stacks->flush(&_allocator, &_stripes);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -74,4 +74,2 @@\n-  template <typename T> bool drain_and_flush(ZMarkStripe* stripe,\n-                                             ZMarkThreadLocalStacks* stacks,\n-                                             ZMarkCache* cache,\n-                                             T* timeout);\n+  bool try_steal_local(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks);\n+  bool try_steal_global(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  ZMarkStack* steal(ZMarkStripeSet* stripes,\n+                    ZMarkStripe* stripe);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,0 +222,11 @@\n+inline ZMarkStack* ZMarkThreadLocalStacks::steal(ZMarkStripeSet* stripes,\n+                                                 ZMarkStripe* stripe) {\n+  ZMarkStack** const stackp = &_stacks[stripes->stripe_id(stripe)];\n+  ZMarkStack* const stack = *stackp;\n+  if (stack != NULL) {\n+    *stackp = NULL;\n+  }\n+\n+  return stack;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}