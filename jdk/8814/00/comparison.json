{"files":[{"patch":"@@ -28,0 +28,4 @@\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n-  volatile_nonstatic_field(JavaFrameAnchor, _last_Java_fp, intptr_t*)\n+  volatile_nonstatic_field(JavaFrameAnchor, _last_Java_fp,   intptr_t*) \\\n+              static_field(VM_Version,      _rop_protection, bool)      \\\n+              static_field(VM_Version,      _pac_mask,       uintptr_t)\n@@ -36,1 +38,2 @@\n-#define VM_TYPES_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type)\n+#define VM_TYPES_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+  declare_toplevel_type(VM_Version)\n","filename":"src\/hotspot\/cpu\/aarch64\/vmStructs_aarch64.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"pauth_aarch64.hpp\"\n@@ -49,0 +50,1 @@\n+uintptr_t VM_Version::_pac_mask;\n@@ -447,1 +449,0 @@\n-  \/\/ The frame pointer must be preserved for ROP protection.\n@@ -449,0 +450,5 @@\n+    \/\/ Determine the mask of address bits used for PAC. Clear bit 55 of\n+    \/\/ the input to make it look like a user address.\n+    _pac_mask = (uintptr_t)pauth_strip_pointer((address)~(UINT64_C(1) << 55));\n+\n+    \/\/ The frame pointer must be preserved for ROP protection.\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  friend class VMStructs;\n@@ -49,0 +50,1 @@\n+  static uintptr_t _pac_mask;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,3 @@\n+  private static CIntegerField ropProtectionField;\n+  private static CIntegerField pacMaskField;\n+\n@@ -93,1 +96,0 @@\n-  }\n@@ -95,0 +97,4 @@\n+    Type vmVersion = db.lookupType(\"VM_Version\");\n+    ropProtectionField = vmVersion.getCIntegerField(\"_rop_protection\");\n+    pacMaskField = vmVersion.getCIntegerField(\"_pac_mask\");\n+  }\n@@ -394,1 +400,1 @@\n-    Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());\n+    Address senderPC = stripPAC(senderSP.getAddressAt(-1 * VM.getVM().getAddressSize()));\n@@ -448,1 +454,13 @@\n-  public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }\n+  public Address getSenderPC()     { return stripPAC(getSenderPCAddr().getAddressAt(0)); }\n+\n+  \/\/ Remove any embedded pointer authentication code from an address.\n+  private Address stripPAC(Address addr) {\n+    \/\/ Really we should use the XPACI instruction to do this but we\n+    \/\/ can't access that from Java so rely on the mask of PAC bits\n+    \/\/ calculated by vm_version_aarch64.cpp on startup.\n+    if (ropProtectionField.getValue() != 0) {\n+      return addr.andWithMask(pacMaskField.getValue());\n+    } else {\n+      return addr;\n+    }\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"}]}