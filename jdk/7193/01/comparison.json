{"files":[{"patch":"@@ -1194,4 +1194,0 @@\n-  notproduct(bool, VerifyJNIEnvThread, false,                               \\\n-          \"Verify JNIEnv.thread == Thread::current() when entering VM \"     \\\n-          \"from JNI\")                                                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,0 +343,5 @@\n+\/\/\n+\/\/ As the JNIEnv can be passed from external native code we validate\n+\/\/ it in debug builds, primarily for our own testing. In general JNI\n+\/\/ does not attempt to detect programming errors and a bad JNIEnv may\n+\/\/ not even be readable.\n@@ -352,1 +357,1 @@\n-    assert( !VerifyJNIEnvThread || (thread == Thread::current()), \"JNIEnv is only valid in same thread\"); \\\n+    assert(thread == Thread::current(), \"JNIEnv is only valid in same thread\"); \\\n@@ -363,1 +368,1 @@\n-    assert( !VerifyJNIEnvThread || (thread == Thread::current()), \"JNIEnv is only valid in same thread\"); \\\n+    assert(thread == Thread::current(), \"JNIEnv is only valid in same thread\"); \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1315,0 +1315,3 @@\n+  \/\/ Returns the current thread as indicated by the given JNIEnv.\n+  \/\/ We don't assert it is Thread::current here as that is done at the\n+  \/\/ external JNI entry points where the JNIEnv is passed into the VM.\n@@ -1316,8 +1319,9 @@\n-    JavaThread *thread_from_jni_env = (JavaThread*)((intptr_t)env - in_bytes(jni_environment_offset()));\n-    \/\/ Only return NULL if thread is off the thread list; starting to\n-    \/\/ exit should not return NULL.\n-    if (thread_from_jni_env->is_terminated()) {\n-      thread_from_jni_env->block_if_vm_exited();\n-      return NULL;\n-    } else {\n-      return thread_from_jni_env;\n+    JavaThread* current = (JavaThread*)((intptr_t)env - in_bytes(jni_environment_offset()));\n+    \/\/ We can't get here in a thread that has completed its execution and so\n+    \/\/ \"is_terminated\", but a thread is also considered terminated if the VM\n+    \/\/ has exited, so we have to check this and block in case this is a daemon\n+    \/\/ thread returning to the VM (the JNI DirectBuffer entry points rely on\n+    \/\/ this).\n+    if (current->is_terminated()) {\n+      current->block_if_vm_exited();\n+      ShouldNotReachHere();\n@@ -1325,0 +1329,1 @@\n+    return current;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"}]}