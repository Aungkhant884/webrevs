{"files":[{"patch":"@@ -2392,2 +2392,0 @@\n-#ifdef _LP64\n-  emit_int8(0x67); \/\/ addr32\n@@ -2395,1 +2393,0 @@\n-#endif \/\/ LP64\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1047,0 +1047,19 @@\n+  \/\/ Old CPUs perform lea on AGU which causes additional latency transfering the\n+  \/\/ value from\/to ALU for other operations\n+  static bool supports_fast_2op_lea() {\n+    return (is_intel() && supports_avx()) || \/\/ Sandy Bridge and above\n+           (is_amd()   && supports_avx());   \/\/ Jaguar and Bulldozer and above\n+  }\n+\n+  \/\/ Pre Icelake Intels suffer inefficiency regarding 3-operand lea, which contains\n+  \/\/ all of base register, index register and displacement immediate, with 3 latency.\n+  \/\/ Note that when the address contains no displacement but the base register is\n+  \/\/ rbp or r13, the machine code must contain a zero displacement immediate,\n+  \/\/ effectively transform a 2-operand lea into a 3-operand lea. This can be\n+  \/\/ replaced by add-add or lea-add\n+  static bool supports_fast_3op_lea() {\n+    return supports_fast_2op_lea() &&\n+           ((is_intel() && supports_clwb()) || \/\/ Icelake and above\n+            is_amd());\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,5 @@\n+\/\/ Class for all long registers (excluding RBP and R13)\n+reg_class long_no_rbp_r13_reg %{\n+  return _LONG_NO_RBP_R13_REG_mask;\n+%}\n+\n@@ -259,0 +264,5 @@\n+\/\/ Class for all int registers (excluding RBP and R13)\n+reg_class int_no_rbp_r13_reg %{\n+  return _INT_NO_RBP_R13_REG_mask;\n+%}\n+\n@@ -322,0 +332,1 @@\n+extern RegMask _LONG_NO_RBP_R13_REG_mask;\n@@ -325,0 +336,1 @@\n+extern RegMask _INT_NO_RBP_R13_REG_mask;\n@@ -351,0 +363,1 @@\n+RegMask _LONG_NO_RBP_R13_REG_mask;\n@@ -354,0 +367,1 @@\n+RegMask _INT_NO_RBP_R13_REG_mask;\n@@ -412,0 +426,6 @@\n+  _LONG_NO_RBP_R13_REG_mask = _LONG_REG_mask;\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+\n@@ -430,0 +450,4 @@\n+  _INT_NO_RBP_R13_REG_mask = _INT_REG_mask;\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+\n@@ -3494,0 +3518,15 @@\n+operand no_rbp_r13_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_no_rbp_r13_reg));\n+  match(RegI);\n+  match(rRegI);\n+  match(rax_RegI);\n+  match(rbx_RegI);\n+  match(rcx_RegI);\n+  match(rdx_RegI);\n+  match(rdi_RegI);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -3721,0 +3760,13 @@\n+operand no_rbp_r13_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_no_rbp_r13_reg));\n+  match(RegL);\n+  match(rRegL);\n+  match(rax_RegL);\n+  match(rcx_RegL);\n+  match(rdx_RegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -7446,1 +7498,1 @@\n-instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)\n+instruct leaI_rReg_immI2_immI(rRegI dst, rRegI index, immI2 scale, immI disp)\n@@ -7448,1 +7500,2 @@\n-  match(Set dst (AddI src0 src1));\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI (LShiftI index scale) disp));\n@@ -7450,2 +7503,14 @@\n-  ins_cost(110);\n-  format %{ \"addr32 leal $dst, [$src0 + $src1]\\t# int\" %}\n+  format %{ \"leal $dst, [$index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI(rRegI dst, rRegI base, rRegI index, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base index) disp));\n+\n+  format %{ \"leal $dst, [$base + $index + $disp]\\t# int\" %}\n@@ -7453,1 +7518,29 @@\n-    __ leal($dst$$Register, Address($src0$$Register, $src1$$constant));\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2(rRegI dst, no_rbp_r13_RegI base, rRegI index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI base (LShiftI index scale)));\n+  match(Set dst (AddI (LShiftI index scale) base));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2_immI(rRegI dst, rRegI base, rRegI index, immI2 scale, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base (LShiftI index scale)) disp));\n+  match(Set dst (AddI (AddI (LShiftI index scale) base) disp));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n@@ -7577,1 +7670,1 @@\n-instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)\n+instruct leaL_rReg_immI2_immL32(rRegL dst, rRegL index, immI2 scale, immL32 disp)\n@@ -7579,1 +7672,2 @@\n-  match(Set dst (AddL src0 src1));\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL (LShiftL index scale) disp));\n@@ -7581,2 +7675,41 @@\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, [$src0 + $src1]\\t# long\" %}\n+  format %{ \"leaq $dst, [$index << $scale + $disp]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immL32(rRegL dst, rRegL base, rRegL index, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base index) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index + $disp]\\t# long\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2(rRegL dst, no_rbp_r13_RegL base, rRegL index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL base (LShiftL index scale)));\n+  match(Set dst (AddL (LShiftL index scale) base));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2_immL32(rRegL dst, rRegL base, rRegL index, immI2 scale, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base (LShiftL index scale)) disp));\n+  match(Set dst (AddL (AddL (LShiftL index scale) base) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale + $disp]\\t# long\" %}\n@@ -7584,1 +7717,2 @@\n-    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n@@ -7615,12 +7749,0 @@\n-instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)\n-%{\n-  match(Set dst (AddP src0 src1));\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, [$src0 + $src1]\\t# ptr\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":145,"deletions":23,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-XX:LoopUnrollLimit=1\"})\n+@State(Scope.Thread)\n+public class LeaInstruction {\n+    static final int ITERATION = 1000;\n+\n+    int x, y;\n+\n+    @Benchmark\n+    public void IS_D_int(Blackhole bh) {\n+        int x = this.x;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x * 4 + 10;\n+        }\n+        bh.consume(x);\n+    }\n+\n+    @Benchmark\n+    public void B_I_D_int(Blackhole bh) {\n+        int x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y + 10;\n+            y = x + y + 20;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_IS_int(Blackhole bh) {\n+        int x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y * 4;\n+            y = x + y * 8;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_IS_D_int(Blackhole bh) {\n+        int x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y * 4 + 10;\n+            y = x + y * 8 + 20;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void IS_D_long(Blackhole bh) {\n+        long x = this.x;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x * 4 + 10;\n+        }\n+        bh.consume(x);\n+    }\n+\n+    @Benchmark\n+    public void B_I_D_long(Blackhole bh) {\n+        long x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y + 10;\n+            y = x + y + 20;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_IS_long(Blackhole bh) {\n+        long x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y * 4;\n+            y = x + y * 8;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_IS_D_long(Blackhole bh) {\n+        long x = this.x, y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            x = x + y * 4 + 10;\n+            y = x + y * 8 + 20;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LeaInstruction.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}