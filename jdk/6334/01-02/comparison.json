{"files":[{"patch":"@@ -388,1 +388,1 @@\n-    __ authenticate_return_address(exception_pc, Address(rfp), rscratch1);\n+    __ authenticate_return_address(exception_pc, rscratch1);\n@@ -437,1 +437,1 @@\n-  __ protect_return_address(exception_pc, Address(rfp), rscratch1);\n+  __ protect_return_address(exception_pc, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-          \"Use ROP based branch protection\")                            \\\n+          \"Protect branches against ROP attacks.\")                      \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5184,0 +5184,4 @@\n+\/\/ Use the AArch64 PAC feature to add ROP protection for generated code. Use whenever creating\/\n+\/\/ destroying stack frames or whenever directly loading\/storing the LR to memory.\n+\/\/ If UseROPProtection is not set then these functions are no-ops.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n@@ -5185,0 +5189,3 @@\n+\/\/ Sign the LR. Use during construction of a stack frame, before storing the LR to memory.\n+\/\/ Uses the FP as the modifier.\n+\/\/\n@@ -5186,1 +5193,0 @@\n-  \/\/ Used before pushing the LR on the stack.\n@@ -5189,4 +5195,3 @@\n-    \/\/ The standard convention here is to use paciasp as SP would equal FP. Thus when LR and FP\n-    \/\/ are pushed to the stack, the modifier used to sign LR is the value before it on the stack.\n-    \/\/ In JDK, SP and FP may not match, but we still want to sign using the value pushed to the\n-    \/\/ stack (FP). Note this version of the instruction is not in the NOP space.\n+    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n+    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n+    \/\/ match, so instead explicitly use the FP.\n@@ -5197,1 +5202,6 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Address modifier, Register temp_reg) {\n+\/\/ Sign the return value in the given register. Use before updating the LR in the exisiting stack\n+\/\/ frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n@@ -5200,1 +5210,1 @@\n-    ldr(temp_reg, modifier);\n+    ldr(temp_reg, Address(rfp));\n@@ -5205,0 +5215,2 @@\n+\/\/ Authenticate the LR. Use before function return, after restoring FP and loading LR from memory.\n+\/\/\n@@ -5206,1 +5218,0 @@\n-  \/\/ Used after popping the LR off the stack.\n@@ -5208,1 +5219,0 @@\n-    \/\/ Match with protect_return_address.\n@@ -5214,1 +5224,6 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Address modifier, Register temp_reg) {\n+\/\/ Authenticate the return value in the given register. Use before updating the LR in the exisiting\n+\/\/ stack frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n@@ -5216,1 +5231,1 @@\n-    ldr(temp_reg, modifier);\n+    ldr(temp_reg, Address(rfp));\n@@ -5222,0 +5237,3 @@\n+\/\/ Strip any PAC data from LR without performing any authentication. Use with caution - only if\n+\/\/ there is no guaranteed way of authenticating the LR.\n+\/\/\n@@ -5229,0 +5247,7 @@\n+\/\/ PAC failures can be difficult to debug. After an authentication failure, a segfault will only\n+\/\/ occur when the pointer is used - ie when the program returns to the invalid LR. At this point\n+\/\/ it is difficult to debug back to the callee function.\n+\/\/ This function simply loads from the address in the given register.\n+\/\/ Use directly after authentication to catch authentication failures.\n+\/\/ Also use before signing to check that the pointer is valid and hasn't already been signed.\n+\/\/\n@@ -5230,2 +5255,0 @@\n-  \/\/ This load helps debugging sign\/auth failures, as the segfault will happen here instead of\n-  \/\/ after using the failed address.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-  \/\/ROP Protection\n+  \/\/ ROP Protection\n@@ -691,1 +691,1 @@\n-  void protect_return_address(Register return_reg, Address modifier, Register temp_reg);\n+  void protect_return_address(Register return_reg, Register temp_reg);\n@@ -693,1 +693,1 @@\n-  void authenticate_return_address(Register return_reg, Address modifier, Register temp_reg);\n+  void authenticate_return_address(Register return_reg, Register temp_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-#include OS_CPU_HEADER_INLINE(pauth)\n+#ifdef __APPLE__\n+#include <ptrauth.h>\n+#endif\n@@ -30,2 +32,35 @@\n-inline bool pauth_ptr_is_raw(address ptr) {\n-  \/\/ Confirm none of the high bits are set in the pointer.\n+\/\/ Support for ROP Protection in VM code.\n+\/\/ This is provided by via the AArch64 PAC feature.\n+\/\/ For more details on PAC see The Arm ARM, section \"Pointer authentication in AArch64 state\".\n+\/\/\n+\/\/ PAC provides a method to sign and authenticate pointer values. Signing combines the register\n+\/\/ being signed, an additional modifier and a per-process secret key, writing the result to unused\n+\/\/ high bits of the signed register. Once signed a register must be authenticated or stripped\n+\/\/ before it can be used.\n+\/\/ Authentication reverses the signing operation, clearing the high bits. If the signed register\n+\/\/ or modifier has changed then authentication will fail and invalid data will be written to the\n+\/\/ high bits and the next time the pointer is used a segfault will be raised.\n+\/\/\n+\/\/ Assume a malicious attacker is able to edit the stack via an exploit. Control flow can be\n+\/\/ changed by re-writing the return values stored on the stack. ROP protection prevents this by\n+\/\/ signing return addresses before saving them on the stack, then authenticating when they are\n+\/\/ loaded back. The scope of this protection is per function (a value is signed and authenticated\n+\/\/ by the same function), therefore it is possible for different functions within the same\n+\/\/ program to use different signing methods.\n+\/\/\n+\/\/ The VM and native code is protected by compiling with the GCC AArch64 branch protection flag.\n+\/\/\n+\/\/ All generated code is protected via the ROP functions provided in macroAssembler.\n+\/\/\n+\/\/ In addition, the VM needs to be aware of PAC whenever viewing or editing the stack. We should\n+\/\/ assume all stack frames for generated code have signed return values. Rewriting the stack\n+\/\/ should ensure new values are correctly signed. However, we cannot make any assumptions about\n+\/\/ how (or if) native code uses PAC - here we should limit access to viewing via stripping.\n+\/\/\n+\n+\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n+\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n+\/\/ compilers can still be used. For Apple, instead use the recommended pauth interface.\n+#define XPACLRI   \"hint #0x7;\"\n+#define PACIA1716 \"hint #0x8;\"\n+#define AUTIA1716 \"hint #0xc;\"\n@@ -33,6 +68,0 @@\n-  \/\/ Note this can give false positives. The PAC signing can generate a signature\n-  \/\/ with all signing bits as zeros, causing this function to return true.\n-  \/\/ Therefore this should only be used for assert style checking.\n-  \/\/ In addition, this function should never be used with a \"not\" to confirm a pointer\n-  \/\/ is signed, as it will fail the above case. The only safe way to do this is to\n-  \/\/ instead authenticate the pointer.\n@@ -40,0 +69,22 @@\n+\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n+\/\/ value.\n+\/\/\n+inline address pauth_strip_pointer(address ptr) {\n+#ifdef __APPLE__\n+  return ptrauth_strip(ptr, ptrauth_key_asib);\n+#else\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+#endif\n+}\n+\n+\/\/ Confirm the given pointer has not been signed - ie none of the high bits are set.\n+\/\/\n+\/\/ Note this can give false positives. The PAC signing can generate a signature with all signing\n+\/\/ bits as zeros, causing this function to return true. Therefore this should only be used for\n+\/\/ assert style checking. In addition, this function should never be used with a \"not\" to confirm\n+\/\/ a pointer is signed, as it will fail the above case. The only safe way to do this is to instead\n+\/\/ authenticate the pointer.\n+\/\/\n+inline bool pauth_ptr_is_raw(address ptr) {\n@@ -43,0 +94,39 @@\n+\/\/ Sign a return value, using the given modifier.\n+\/\/\n+inline address pauth_sign_return_address(address ret_addr, address modifier) {\n+  if (UseROPProtection) {\n+    \/\/ A pointer cannot be double signed.\n+    assert(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n+#ifdef __APPLE__\n+    ret_addr = ptrauth_sign_unauthenticated(ret_addr, ptrauth_key_asib, modifier);\n+#else\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = modifier;\n+    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+#endif\n+  }\n+  return ret_addr;\n+}\n+\n+\/\/ Authenticate a return value, using the given modifier.\n+\/\/\n+inline address pauth_authenticate_return_address(address ret_addr, address modifier) {\n+  if (UseROPProtection) {\n+#ifdef __APPLE__\n+    ret_addr = ptrauth_auth_data(ret_addr, ptrauth_key_asib, modifier);\n+#else\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = modifier;\n+    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+#endif\n+    \/\/ Ensure that the pointer authenticated.\n+    assert(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+  }\n+  return ret_addr;\n+}\n+\n+\/\/ Authenticate or strip a return value. Use for efficiency and only when the safety of the data\n+\/\/ isn't an issue - for example when viewing the stack.\n+\/\/\n@@ -44,1 +134,0 @@\n-  \/\/ For use only when the returned pointer is not being used as a jump destination.\n@@ -52,0 +141,4 @@\n+#undef XPACLRI\n+#undef PACIA1716\n+#undef AUTIA1716\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":103,"deletions":10,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-  __ authenticate_return_address(c_rarg1, Address(rfp), rscratch1);\n+  __ authenticate_return_address(c_rarg1, rscratch1);\n@@ -2326,1 +2326,1 @@\n-  __ protect_return_address(r3, Address(rfp), rscratch1);\n+  __ protect_return_address(r3, rscratch1);\n@@ -2798,1 +2798,1 @@\n-    __ protect_return_address(r20, Address(rfp), rscratch1);\n+    __ protect_return_address(r20, rscratch1);\n@@ -2839,1 +2839,1 @@\n-    __ authenticate_return_address(r20, Address(rfp), rscratch1);\n+    __ authenticate_return_address(r20, rscratch1);\n@@ -2854,1 +2854,1 @@\n-    __ protect_return_address(r20, Address(rfp), rscratch1);\n+    __ protect_return_address(r20, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n-#define OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n-\n-inline bool pauth_ptr_is_raw(address ptr);\n-\n-#ifdef __APPLE__\n-#include <ptrauth.h>\n-#endif\n-\n-\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n-\/\/ binaries work on systems without PAC. Write these instructions using their\n-\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n-\/\/ For Apple, use the provided interface as this may provide additional\n-\/\/ optimization.\n-\n-#define XPACLRI \"hint #0x7;\"\n-#define PACIA1716 \"hint #0x8;\"\n-#define AUTIA1716 \"hint #0xc;\"\n-\n-inline address pauth_strip_pointer(address ptr) {\n-#ifdef __APPLE__\n-  return ptrauth_strip(ptr, ptrauth_key_asib);\n-#else\n-  register address result __asm__(\"x30\") = ptr;\n-  asm (XPACLRI : \"+r\"(result));\n-  return result;\n-#endif\n-}\n-\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n-  if (UseROPProtection) {\n-    \/\/ A pointer cannot be double signed.\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n-#ifdef __APPLE__\n-    ret_addr = ptrauth_sign_unauthenticated(ret_addr, ptrauth_key_asib, sp);\n-#else\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-#endif\n-  }\n-  return ret_addr;\n-}\n-\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n-  if (UseROPProtection) {\n-#ifdef __APPLE__\n-    ret_addr = ptrauth_auth_data(ret_addr, ptrauth_key_asib, sp);\n-#else\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-#endif\n-    \/\/ Ensure that the pointer authenticated.\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n-  }\n-  return ret_addr;\n-}\n-\n-#undef XPACLRI\n-#undef PACIA1716\n-#undef AUTIA1716\n-\n-#endif \/\/ OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n-#define OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n-\n-inline bool pauth_ptr_is_raw(address ptr);\n-\n-\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n-\/\/ binaries work on systems without PAC. Write these instructions using their\n-\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n-\n-#define XPACLRI \"hint #0x7;\"\n-#define PACIA1716 \"hint #0x8;\"\n-#define AUTIA1716 \"hint #0xc;\"\n-\n-inline address pauth_strip_pointer(address ptr) {\n-  register address result __asm__(\"x30\") = ptr;\n-  asm (XPACLRI : \"+r\"(result));\n-  return result;\n-}\n-\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n-  if (UseROPProtection) {\n-    \/\/ A pointer cannot be double signed.\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-  }\n-  return ret_addr;\n-}\n-\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n-  if (UseROPProtection) {\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-    \/\/ Ensure that the pointer authenticated.\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n-  }\n-  return ret_addr;\n-}\n-\n-#undef XPACLRI\n-#undef PACIA1716\n-#undef AUTIA1716\n-\n-#endif \/\/ OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n-#define OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n-\n-inline address pauth_strip_pointer(address ptr) {\n-  \/\/ No PAC support in windows as of yet.\n-  return ptr;\n-}\n-\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n-  \/\/ No PAC support in windows as of yet.\n-  return ret_addr;\n-}\n-\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n-  \/\/ No PAC support in windows as of yet.\n-  return ret_addr;\n-}\n-\n-#endif \/\/ OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"}]}