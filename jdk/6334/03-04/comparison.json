{"files":[{"patch":"@@ -448,2 +448,0 @@\n-  \/\/      Move it into LR ready for returning.\n-  __ mov(lr, r0);\n@@ -454,0 +452,4 @@\n+  \/\/ patch the return address, this stub will directly return to the exception handler\n+  __ protect_return_address(r0, rscratch1);\n+  __ str(r0, Address(rfp, 1*BytesPerWord));\n+\n@@ -466,5 +468,0 @@\n-  \/\/ Restore the frame (without overwriting lr), and return.\n-  __ mov(sp, rfp);\n-  __ ldr(rfp, Address(__ post(sp, 2 * wordSize)));\n-  __ ret(lr);\n-\n@@ -629,0 +626,2 @@\n+        __ leave();\n+        __ ret(lr);\n@@ -1053,1 +1052,1 @@\n-      { StubFrame f(sasm, \"handle_exception\", dont_gc_arguments, does_not_return);\n+      { StubFrame f(sasm, \"handle_exception\", dont_gc_arguments);\n@@ -1059,1 +1058,1 @@\n-      { StubFrame f(sasm, \"handle_exception_from_callee\", dont_gc_arguments, does_not_return);\n+      { StubFrame f(sasm, \"handle_exception_from_callee\", dont_gc_arguments);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-      sender_pc = pauth_authenticate_or_strip_return_address((address) this->fp()[return_addr_offset], (address)saved_fp);\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n@@ -156,1 +156,1 @@\n-      sender_pc = pauth_authenticate_or_strip_return_address((address) *(sender_sp-1), (address)saved_fp);\n+      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n@@ -280,1 +280,1 @@\n-  address pc_old = pauth_authenticate_or_strip_return_address(*pc_addr, (address)signing_sp);\n+  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n@@ -459,1 +459,1 @@\n-  address sender_pc = pauth_authenticate_or_strip_return_address(sender_pc_maybe_signed(), (address)link());\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n@@ -478,1 +478,1 @@\n-  address sender_pc = pauth_authenticate_or_strip_return_address((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-#ifdef __APPLE__\n-#include <ptrauth.h>\n-#endif\n+#include OS_CPU_HEADER_INLINE(pauth)\n@@ -33,1 +31,1 @@\n-\/\/ This is provided by via the AArch64 PAC feature.\n+\/\/ This is provided via the AArch64 PAC feature.\n@@ -55,4 +53,5 @@\n-\/\/ In addition, the VM needs to be aware of PAC whenever viewing or editing the stack. We should\n-\/\/ assume all stack frames for generated code have signed return values. Rewriting the stack\n-\/\/ should ensure new values are correctly signed. However, we cannot make any assumptions about\n-\/\/ how (or if) native code uses PAC - here we should limit access to viewing via stripping.\n+\/\/ In addition, the VM needs to be aware of PAC whenever viewing or editing the stack. Functions\n+\/\/ are provided here and in the OS specific files. We should assume all stack frames for generated\n+\/\/ code have signed return values. Rewriting the stack should ensure new values are correctly\n+\/\/ signed. However, we cannot make any assumptions about how (or if) native code uses PAC - here\n+\/\/ we should limit access to viewing via stripping.\n@@ -61,20 +60,0 @@\n-\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n-\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n-\/\/ compilers can still be used. For Apple, instead use the recommended pauth interface.\n-#define XPACLRI   \"hint #0x7;\"\n-#define PACIA1716 \"hint #0x8;\"\n-#define AUTIA1716 \"hint #0xc;\"\n-\n-\n-\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n-\/\/ value.\n-\/\/\n-inline address pauth_strip_pointer(address ptr) {\n-#ifdef __APPLE__\n-  return ptrauth_strip(ptr, ptrauth_key_asib);\n-#else\n-  register address result __asm__(\"x30\") = ptr;\n-  asm (XPACLRI : \"+r\"(result));\n-  return result;\n-#endif\n-}\n@@ -94,1 +73,2 @@\n-\/\/ Sign a return value, using the given modifier.\n+\/\/ Strip a return value (same as pauth_strip_pointer). When debug is enabled then authenticate\n+\/\/ instead.\n@@ -96,38 +76,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address modifier) {\n-  if (UseROPProtection) {\n-    \/\/ A pointer cannot be double signed.\n-    assert(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n-#ifdef __APPLE__\n-    ret_addr = ptrauth_sign_unauthenticated(ret_addr, ptrauth_key_asib, modifier);\n-#else\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = modifier;\n-    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-#endif\n-  }\n-  return ret_addr;\n-}\n-\n-\/\/ Authenticate a return value, using the given modifier.\n-\/\/\n-inline address pauth_authenticate_return_address(address ret_addr, address modifier) {\n-  if (UseROPProtection) {\n-#ifdef __APPLE__\n-    ret_addr = ptrauth_auth_data(ret_addr, ptrauth_key_asib, modifier);\n-#else\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = modifier;\n-    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n-#endif\n-    \/\/ Ensure that the pointer authenticated.\n-    assert(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n-  }\n-  return ret_addr;\n-}\n-\n-\/\/ Authenticate or strip a return value. Use for efficiency and only when the safety of the data\n-\/\/ isn't an issue - for example when viewing the stack.\n-\/\/\n-inline address pauth_authenticate_or_strip_return_address(address ret_addr, address modifier) {\n+inline address pauth_strip_verifiable(address ret_addr, address modifier) {\n@@ -141,4 +84,0 @@\n-#undef XPACLRI\n-#undef PACIA1716\n-#undef AUTIA1716\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":10,"deletions":71,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+inline bool pauth_ptr_is_raw(address ptr);\n+\n+#ifdef __APPLE__\n+#include <ptrauth.h>\n+#endif\n+\n+\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n+\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n+\/\/ compilers can still be used. For Apple, instead use the recommended pauth interface.\n+#define XPACLRI   \"hint #0x7;\"\n+#define PACIA1716 \"hint #0x8;\"\n+#define AUTIA1716 \"hint #0xc;\"\n+\n+\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n+\/\/ value.\n+\/\/\n+inline address pauth_strip_pointer(address ptr) {\n+#ifdef __APPLE__\n+  return ptrauth_strip(ptr, ptrauth_key_asib);\n+#else\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+#endif\n+}\n+\n+\/\/ Sign a return value, using the given modifier.\n+\/\/\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  if (UseROPProtection) {\n+    \/\/ A pointer cannot be double signed.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n+#ifdef __APPLE__\n+    ret_addr = ptrauth_sign_unauthenticated(ret_addr, ptrauth_key_asib, sp);\n+#else\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+#endif\n+  }\n+  return ret_addr;\n+}\n+\n+\/\/ Authenticate a return value, using the given modifier.\n+\/\/\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  if (UseROPProtection) {\n+#ifdef __APPLE__\n+    ret_addr = ptrauth_auth_data(ret_addr, ptrauth_key_asib, sp);\n+#else\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+#endif\n+    \/\/ Ensure that the pointer authenticated.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+  }\n+  return ret_addr;\n+}\n+\n+#undef XPACLRI\n+#undef PACIA1716\n+#undef AUTIA1716\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n+#define OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n+\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+inline bool pauth_ptr_is_raw(address ptr);\n+\n+\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n+\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n+\/\/ compilers can still be used.\n+#define XPACLRI   \"hint #0x7;\"\n+#define PACIA1716 \"hint #0x8;\"\n+#define AUTIA1716 \"hint #0xc;\"\n+\n+\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n+\/\/ value.\n+\/\/\n+inline address pauth_strip_pointer(address ptr) {\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+}\n+\n+\/\/ Sign a return value, using the given modifier.\n+\/\/\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  if (UseROPProtection) {\n+    \/\/ A pointer cannot be double signed.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm volatile (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+  }\n+  return ret_addr;\n+}\n+\n+\/\/ Authenticate a return value, using the given modifier.\n+\/\/\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  if (UseROPProtection) {\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm volatile (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+    \/\/ Ensure that the pointer authenticated.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+  }\n+  return ret_addr;\n+}\n+\n+#undef XPACLRI\n+#undef PACIA1716\n+#undef AUTIA1716\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+inline address pauth_strip_pointer(address ptr) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ptr;\n+}\n+\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ret_addr;\n+}\n+\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ret_addr;\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}