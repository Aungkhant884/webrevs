{"files":[{"patch":"@@ -296,0 +296,40 @@\n+G1PLABAllocator::PerDestinationPLABData::PerDestinationPLABData() :\n+  _alloc_buffer(nullptr),\n+  _direct_allocated(0),\n+  _num_plab_fills(0),\n+  _num_direct_allocations(0),\n+  _plab_fill_counter(0),\n+  _cur_desired_plab_size(0),\n+  _num_alloc_buffers(0) { }\n+\n+G1PLABAllocator::PerDestinationPLABData::~PerDestinationPLABData() {\n+  if (_alloc_buffer == nullptr) {\n+    return;\n+  }\n+  for (uint node_index = 0; node_index < _num_alloc_buffers; node_index++) {\n+    delete _alloc_buffer[node_index];\n+  }\n+}\n+\n+void G1PLABAllocator::PerDestinationPLABData::initialize(uint num_alloc_buffers, size_t desired_plab_size, size_t tolerated_refills) {\n+  _num_alloc_buffers = num_alloc_buffers;\n+  _alloc_buffer = NEW_C_HEAP_ARRAY(PLAB*, _num_alloc_buffers, mtGC);\n+\n+  for (uint node_index = 0; node_index < _num_alloc_buffers; node_index++) {\n+    _alloc_buffer[node_index] = new PLAB(desired_plab_size);\n+  }\n+\n+  _plab_fill_counter = tolerated_refills;\n+  _cur_desired_plab_size = desired_plab_size;\n+}\n+\n+void G1PLABAllocator::PerDestinationPLABData::notify_plab_refill(size_t tolerated_refills, size_t next_plab_size) {\n+  _num_plab_fills++;\n+  if (should_boost()) {\n+    _plab_fill_counter = tolerated_refills;\n+    _cur_desired_plab_size = next_plab_size;\n+  } else {\n+    _plab_fill_counter--;\n+  }\n+}\n+\n@@ -312,3 +352,2 @@\n-    \/\/ Make the tolerated refills a huge number; -1 because we add one to this\n-    \/\/ value later and it would overflow otherwise.\n-    _tolerated_refills = SIZE_MAX - 1;\n+    \/\/ Make the tolerated refills a huge number.\n+    _tolerated_refills = SIZE_MAX;\n@@ -316,1 +355,2 @@\n-\n+  \/\/ The initial PLAB refill should not count, hence the +1 for the first boost.\n+  size_t initial_tolerated_refills = ResizePLAB ? _tolerated_refills + 1 : _tolerated_refills;\n@@ -318,22 +358,1 @@\n-    _direct_allocated[state] = 0;\n-    uint length = alloc_buffers_length(state);\n-    _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);\n-    size_t word_sz = _g1h->desired_plab_sz(state);\n-    for (uint node_index = 0; node_index < length; node_index++) {\n-      _alloc_buffers[state][node_index] = new PLAB(word_sz);\n-    }\n-    _num_plab_fills[state] = 0;\n-    \/\/ The initial PLAB refill should not count, hence the +1 for the first boost.\n-    _plab_fill_counter[state] = _tolerated_refills + 1;\n-    _num_direct_allocations[state] = 0;\n-    _cur_desired_plab_size[state] = word_sz;\n-  }\n-}\n-\n-G1PLABAllocator::~G1PLABAllocator() {\n-  for (region_type_t state = 0; state < G1HeapRegionAttr::Num; state++) {\n-    uint length = alloc_buffers_length(state);\n-    for (uint node_index = 0; node_index < length; node_index++) {\n-      delete _alloc_buffers[state][node_index];\n-    }\n-    FREE_C_HEAP_ARRAY(PLAB*, _alloc_buffers[state]);\n+    _data[state].initialize(alloc_buffers_length(state), _g1h->desired_plab_sz(state), initial_tolerated_refills);\n@@ -354,2 +373,3 @@\n-  bool const should_boost_plab = _plab_fill_counter[dest.type()] == 0;\n-  if (should_boost_plab) {\n+  PerDestinationPLABData* plab_data = &_data[dest.type()];\n+\n+  if (plab_data->should_boost()) {\n@@ -370,1 +390,0 @@\n-    _num_plab_fills[dest.type()]++;\n@@ -373,5 +392,1 @@\n-    if (should_boost_plab) {\n-      _plab_fill_counter[dest.type()] = _tolerated_refills;\n-    } else {\n-      _plab_fill_counter[dest.type()]--;\n-    }\n+    plab_data->notify_plab_refill(_tolerated_refills, next_plab_word_size);\n@@ -379,1 +394,0 @@\n-    _cur_desired_plab_size[dest.type()] = plab_word_size;\n@@ -407,2 +421,2 @@\n-    _direct_allocated[dest.type()] += word_sz;\n-    _num_direct_allocations[dest.type()]++;\n+    plab_data->_direct_allocated += word_sz;\n+    plab_data->_num_direct_allocations++;\n@@ -426,3 +440,4 @@\n-    stats->add_num_plab_filled(_num_plab_fills[state]);\n-    stats->add_direct_allocated(_direct_allocated[state]);\n-    stats->add_num_direct_allocated(_num_direct_allocations[state]);\n+    PerDestinationPLABData* plab_data = &_data[state];\n+    stats->add_num_plab_filled(plab_data->_num_plab_fills);\n+    stats->add_direct_allocated(plab_data->_direct_allocated);\n+    stats->add_num_direct_allocated(plab_data->_num_direct_allocations);\n@@ -434,1 +449,1 @@\n-                      _num_plab_fills[G1HeapRegionAttr::Young],\n+                      _data[G1HeapRegionAttr::Young]._num_plab_fills,\n@@ -438,1 +453,1 @@\n-                      _num_plab_fills[G1HeapRegionAttr::Old],\n+                      _data[G1HeapRegionAttr::Old]._num_plab_fills,\n@@ -456,1 +471,1 @@\n-  return _cur_desired_plab_size[which.type()];\n+  return _data[which.type()]._cur_desired_plab_size;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":58,"deletions":43,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -159,1 +159,4 @@\n-  PLAB** _alloc_buffers[G1HeapRegionAttr::Num];\n+  \/\/ Collects per-destination information (e.g. young, old gen) about current PLAB\n+  \/\/ and statistics about it.\n+  struct PerDestinationPLABData {\n+    PLAB** _alloc_buffer;\n@@ -161,2 +164,3 @@\n-  \/\/ Number of words allocated directly (not counting PLAB allocation).\n-  size_t _direct_allocated[G1HeapRegionAttr::Num];\n+    size_t _direct_allocated;             \/\/ Number of words allocated directly (not counting PLAB allocation).\n+    size_t _num_plab_fills;               \/\/ Number of PLAB refills experienced so far.\n+    size_t _num_direct_allocations;       \/\/ Number of direct allocations experienced so far.\n@@ -164,3 +168,2 @@\n-  \/\/ Number of PLAB refills experienced so far.\n-  size_t _num_plab_fills[G1HeapRegionAttr::Num];\n-  size_t _num_direct_allocations[G1HeapRegionAttr::Num];\n+    size_t _plab_fill_counter;            \/\/ How many PLAB refills left until boosting.\n+    size_t _cur_desired_plab_size;        \/\/ Current desired PLAB size incorporating eventual boosting.\n@@ -168,3 +171,15 @@\n-  size_t _plab_fill_counter[G1HeapRegionAttr::Num];\n-  \/\/ Current desired PLAB size incorporating eventual boosting.\n-  size_t _cur_desired_plab_size[G1HeapRegionAttr::Num];\n+    uint _num_alloc_buffers;              \/\/ The number of PLABs for this destination.\n+\n+    PerDestinationPLABData();\n+    ~PerDestinationPLABData();\n+\n+    void initialize(uint num_alloc_buffers, size_t desired_plab_size, size_t tolerated_refills);\n+\n+    \/\/ Should we actually boost the PLAB size?\n+    \/\/ The _plab_refill_counter reset value encodes the ResizePLAB flag value already, so no\n+    \/\/ need to check here.\n+    bool should_boost() const { return _plab_fill_counter == 0; }\n+\n+    void notify_plab_refill(size_t tolerated_refills, size_t next_plab_size);\n+\n+  } _data[G1HeapRegionAttr::Num];\n@@ -189,1 +204,0 @@\n-  ~G1PLABAllocator();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(_alloc_buffers[dest.type()] != NULL,\n+  assert(_data[dest.type()]._alloc_buffer != nullptr,\n@@ -104,1 +104,1 @@\n-    return _alloc_buffers[dest][node_index];\n+    return _data[dest]._alloc_buffer[node_index];\n@@ -106,1 +106,1 @@\n-    return _alloc_buffers[dest][0];\n+    return _data[dest]._alloc_buffer[0];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}