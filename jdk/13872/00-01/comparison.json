{"files":[{"patch":"@@ -817,1 +817,1 @@\n-C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jint opcode))\n@@ -819,1 +819,1 @@\n-  return cp->uncached_name_and_type_ref_index_at(index);\n+  return cp->name_and_type_ref_index_at(index, (Bytecodes::Code)opcode);\n@@ -822,1 +822,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which, jint opcode))\n@@ -824,1 +824,1 @@\n-  JVMCIObject sym = JVMCIENV->create_string(cp->uncached_name_ref_at(which), JVMCI_CHECK_NULL);\n+  JVMCIObject sym = JVMCIENV->create_string(cp->name_ref_at(which, (Bytecodes::Code)opcode), JVMCI_CHECK_NULL);\n@@ -828,1 +828,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n+C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which, jint opcode))\n@@ -830,1 +830,1 @@\n-  JVMCIObject sym = JVMCIENV->create_string(cp->uncached_signature_ref_at(which), JVMCI_CHECK_NULL);\n+  JVMCIObject sym = JVMCIENV->create_string(cp->signature_ref_at(which, (Bytecodes::Code)opcode), JVMCI_CHECK_NULL);\n@@ -834,1 +834,1 @@\n-C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jint opcode))\n@@ -836,1 +836,1 @@\n-  return cp->uncached_klass_ref_index_at(index);\n+  return cp->klass_ref_index_at(index, (Bytecodes::Code)opcode);\n@@ -3088,4 +3088,4 @@\n-  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupNameInPool)},\n-  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupNameAndTypeRefIndexInPool)},\n-  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL2 \"I)\" STRING,                                                 FN_PTR(lookupSignatureInPool)},\n-  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(lookupKlassRefIndexInPool)},\n+  {CC \"lookupNameInPool\",                             CC \"(\" HS_CONSTANT_POOL2 \"II)\" STRING,                                                FN_PTR(lookupNameInPool)},\n+  {CC \"lookupNameAndTypeRefIndexInPool\",              CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(lookupNameAndTypeRefIndexInPool)},\n+  {CC \"lookupSignatureInPool\",                        CC \"(\" HS_CONSTANT_POOL2 \"II)\" STRING,                                                FN_PTR(lookupSignatureInPool)},\n+  {CC \"lookupKlassRefIndexInPool\",                    CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(lookupKlassRefIndexInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -678,1 +678,2 @@\n-int ConstantPool::cp_index_helper(int index, Bytecodes::Code code) {\n+\/\/ Translate index, which could be CPCache index or Indy index, to a constant pool index\n+int ConstantPool::to_cp_index(int index, Bytecodes::Code code) {\n@@ -714,1 +715,1 @@\n-  return uncached_name_and_type_ref_index_at(cp_index_helper(index, code));\n+  return uncached_name_and_type_ref_index_at(to_cp_index(index, code));\n@@ -720,3 +721,2 @@\n-  if (cache() != nullptr) {\n-    pool_index = cp_index_helper(which, code);\n-  }\n+  assert(cache() != nullptr, \"'index' is a rewritten index so this class must have been rewritten\");\n+  pool_index = to_cp_index(which, code);\n@@ -737,1 +737,1 @@\n-  return uncached_klass_ref_index_at(cp_index_helper(index, code));\n+  return uncached_klass_ref_index_at(to_cp_index(index, code));\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  int cp_index_helper(int which, Bytecodes::Code code);\n+  int to_cp_index(int which, Bytecodes::Code code);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,2 +289,2 @@\n-     * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in\n-     * {@code constantPool}.\n+     * Gets the {@code JVM_CONSTANT_NameAndType} index referenced by the {@code rawIndex}.\n+     * The meaning of {@code rawIndex} is dependent on the given {@opcode}.\n@@ -292,2 +292,3 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a\n-     * {@code JVM_CONSTANT_NameAndType} index.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -295,2 +296,2 @@\n-    int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return lookupNameAndTypeRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupNameAndTypeRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -299,1 +300,1 @@\n-    private native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -302,2 +303,3 @@\n-     * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry\n-     * denoted by {@code which} in {@code constantPool}.\n+     * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -305,2 +307,3 @@\n-     * The behavior of this method is undefined if {@code which} does not denote a entry that\n-     * references a {@code JVM_CONSTANT_NameAndType} entry.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -308,2 +311,2 @@\n-    String lookupNameInPool(HotSpotConstantPool constantPool, int which) {\n-        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    String lookupNameInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -312,1 +315,1 @@\n-    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n+    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -315,2 +318,3 @@\n-     * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry\n-     * denoted by {@code which} in {@code constantPool}.\n+     * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -318,2 +322,3 @@\n-     * The behavior of this method is undefined if {@code which} does not denote a entry that\n-     * references a {@code JVM_CONSTANT_NameAndType} entry.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -321,2 +326,2 @@\n-    String lookupSignatureInPool(HotSpotConstantPool constantPool, int which) {\n-        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), which);\n+    String lookupSignatureInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -325,1 +330,1 @@\n-    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which);\n+    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n@@ -328,2 +333,3 @@\n-     * Gets the {@code JVM_CONSTANT_Class} index from the entry at index {@code cpi} in\n-     * {@code constantPool}.\n+     * Gets the {@code JVM_CONSTANT_Class} index from the entry in {@code constantPool}\n+     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * on the given {@opcode}.\n@@ -331,2 +337,3 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a\n-     * {@code JVM_CONSTANT_Class} index.\n+     * The behavior of this method is undefined if the class holding the {@code constantPool}\n+     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * this class for the given {@code opcode}\n@@ -334,2 +341,2 @@\n-    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi) {\n-        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n+        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n@@ -338,1 +345,1 @@\n-    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -393,0 +393,1 @@\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -395,2 +396,2 @@\n-    private int getNameAndTypeRefIndexAt(int index) {\n-        return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index);\n+    private int getNameAndTypeRefIndexAt(int index, int opcode) {\n+        return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index, opcode);\n@@ -404,0 +405,1 @@\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -406,2 +408,2 @@\n-    private String getNameOf(int which) {\n-        return compilerToVM().lookupNameInPool(this, which);\n+    private String getNameOf(int which, int opcode) {\n+        return compilerToVM().lookupNameInPool(this, which, opcode);\n@@ -415,0 +417,1 @@\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -428,1 +431,1 @@\n-     * @param opcode bytecode\n+     * @param opcode the opcode of the instruction for which the lookup is being performed\n@@ -431,2 +434,2 @@\n-    private String getSignatureOf(int which) {\n-        return compilerToVM().lookupSignatureInPool(this, which);\n+    private String getSignatureOf(int which, int opcode) {\n+        return compilerToVM().lookupSignatureInPool(this, which, opcode);\n@@ -454,2 +457,2 @@\n-    private int getKlassRefIndexAt(int index) {\n-        return compilerToVM().lookupKlassRefIndexInPool(this, index);\n+    private int getKlassRefIndexAt(int index, int opcode) {\n+        return compilerToVM().lookupKlassRefIndexInPool(this, index, opcode);\n@@ -714,2 +717,2 @@\n-            String name = getNameOf(cpi);\n-            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(cpi));\n+            String name = getNameOf(index, opcode);\n+            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index, opcode));\n@@ -719,1 +722,1 @@\n-                final int klassIndex = getKlassRefIndexAt(index);\n+                final int klassIndex = getKlassRefIndexAt(index, opcode);\n@@ -764,1 +767,1 @@\n-                index = getKlassRefIndexAt(cpi);\n+                index = getKlassRefIndexAt(index, opcode);\n@@ -777,1 +780,1 @@\n-        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(cpi);\n+        final int nameAndTypeIndex = getNameAndTypeRefIndexAt(index, opcode);\n@@ -782,1 +785,1 @@\n-        final int holderIndex = getKlassRefIndexAt(cpi);\n+        final int holderIndex = getKlassRefIndexAt(index, opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,2 +109,2 @@\n-    public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi, int opcode) {\n+        return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n@@ -113,2 +113,2 @@\n-    public static String lookupNameInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static String lookupNameInPool(ConstantPool constantPool, int cpi, int opcode) {\n+        return CTVM.lookupNameInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n@@ -117,2 +117,2 @@\n-    public static String lookupSignatureInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static String lookupSignatureInPool(ConstantPool constantPool, int cpi, int opcode) {\n+        return CTVM.lookupSignatureInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n@@ -121,2 +121,2 @@\n-    public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int cpi) {\n-        return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, cpi);\n+    public static int lookupKlassRefIndexInPool(ConstantPool constantPool, int cpi, int opcode) {\n+        return CTVM.lookupKlassRefIndexInPool((HotSpotConstantPool) constantPool, cpi, opcode);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool.Bytecodes;\n@@ -96,1 +97,16 @@\n-        int indexToVerify = CompilerToVMHelper.lookupKlassRefIndexInPool(constantPoolCTVM, cpi);\n+        int opcode;\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        \/\/ Select an arbitrary bytecode of the type associated with the Constant pool entry\n+        switch(cpType) {\n+          case CONSTANT_FIELDREF:\n+            opcode = Bytecodes.GETFIELD;\n+            break;\n+          case CONSTANT_METHODREF:\n+          case CONSTANT_INTERFACEMETHODREF:\n+            opcode = Bytecodes.INVOKEVIRTUAL;\n+            break;\n+          default:\n+            throw new Error(\"Unexpected consant pool entry\");\n+        }\n+        int indexToVerify = CompilerToVMHelper.lookupKlassRefIndexInPool(constantPoolCTVM, index, opcode);\n@@ -99,1 +115,1 @@\n-                                           + \"applied to constant pool index %d\", cpi);\n+                                           + \"applied to cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupKlassRefIndexInPoolTest.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool.Bytecodes;\n@@ -98,1 +99,19 @@\n-        int indexToVerify = CompilerToVMHelper.lookupNameAndTypeRefIndexInPool(constantPoolCTVM, cpi);\n+        int opcode;\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        \/\/ Select an arbitrary bytecode of the type associated with the Constant pool entry\n+        switch(cpType) {\n+          case CONSTANT_FIELDREF:\n+            opcode = Bytecodes.GETFIELD;\n+            break;\n+          case CONSTANT_METHODREF:\n+          case CONSTANT_INTERFACEMETHODREF:\n+            opcode = Bytecodes.INVOKEVIRTUAL;\n+            break;\n+          case CONSTANT_INVOKEDYNAMIC:\n+            opcode = Bytecodes.INVOKEDYNAMIC;\n+            break;\n+          default:\n+            throw new Error(\"Unexpected consant pool entry\");\n+        }\n+        int indexToVerify = CompilerToVMHelper.lookupNameAndTypeRefIndexInPool(constantPoolCTVM, index, opcode);\n@@ -101,2 +120,1 @@\n-                                           + \" method applied to constant pool index %d\",\n-                                   cpi);\n+                                           + \" method applied to cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupNameAndTypeRefIndexInPoolTest.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool.Bytecodes;\n@@ -99,1 +100,19 @@\n-        String nameToVerify = CompilerToVMHelper.lookupNameInPool(constantPoolCTVM, cpi);\n+        int opcode;\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        \/\/ Select an arbitrary bytecode of the type associated with the Constant pool entry\n+        switch(cpType) {\n+          case CONSTANT_FIELDREF:\n+            opcode = Bytecodes.GETFIELD;\n+            break;\n+          case CONSTANT_METHODREF:\n+          case CONSTANT_INTERFACEMETHODREF:\n+            opcode = Bytecodes.INVOKEVIRTUAL;\n+            break;\n+          case CONSTANT_INVOKEDYNAMIC:\n+            opcode = Bytecodes.INVOKEDYNAMIC;\n+            break;\n+          default:\n+            throw new Error(\"Unexpected consant pool entry\");\n+        }\n+        String nameToVerify = CompilerToVMHelper.lookupNameInPool(constantPoolCTVM, index, opcode);\n@@ -101,1 +120,1 @@\n-        String msg = String.format(\"Wrong name accessed by constant pool index %d\", cpi);\n+        String msg = String.format(\"Wrong name accessed by cached constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupNameInPoolTest.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.vm.ci.hotspot.HotSpotConstantPool.Bytecodes;\n@@ -99,1 +100,19 @@\n-        String sigToVerify = CompilerToVMHelper.lookupSignatureInPool(constantPoolCTVM, cpi);\n+        int opcode;\n+        int index = dummyClass.getCPCacheIndex(cpi);\n+        Asserts.assertTrue(index != ConstantPoolTestsHelper.NO_CP_CACHE_PRESENT, \"the class must have been rewritten\");\n+        \/\/ Select an arbitrary bytecode of the type associated with the Constant pool entry\n+        switch(cpType) {\n+          case CONSTANT_FIELDREF:\n+            opcode = Bytecodes.GETFIELD;\n+            break;\n+          case CONSTANT_METHODREF:\n+          case CONSTANT_INTERFACEMETHODREF:\n+            opcode = Bytecodes.INVOKEVIRTUAL;\n+            break;\n+          case CONSTANT_INVOKEDYNAMIC:\n+            opcode = Bytecodes.INVOKEDYNAMIC;\n+            break;\n+          default:\n+            throw new Error(\"Unexpected consant pool entry\");\n+        }\n+        String sigToVerify = CompilerToVMHelper.lookupSignatureInPool(constantPoolCTVM, index, opcode);\n@@ -101,2 +120,1 @@\n-        String msg = String.format(\"Wrong signature accessed by constant pool index %d\",\n-                                   cpi);\n+        String msg = String.format(\"Wrong signature accessed by cache constant pool index %d\", index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupSignatureInPoolTest.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"}]}