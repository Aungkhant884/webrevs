{"files":[{"patch":"@@ -726,1 +726,1 @@\n-    <Field type=\"string\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n+    <Field type=\"NMTType\" name=\"type\" label=\"Memory Type\" description=\"Type used for the native memory allocation\" \/>\n@@ -1381,0 +1381,4 @@\n+  <Type name=\"NMTType\" label=\"Native Memory Tracking Type\">\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+  <\/Type>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+#include \"services\/nmtCommon.hpp\"\n@@ -324,0 +325,9 @@\n+\n+void NMTTypeConstant::serialize(JfrCheckpointWriter& writer) {\n+  writer.write_count(mt_number_of_types);\n+  for (int i = 0; i < mt_number_of_types; ++i) {\n+    writer.write_key(i);\n+    MEMFLAGS flag = NMTUtil::index_to_flag(i);\n+    writer.write(NMTUtil::flag_to_name(flag));\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,5 @@\n+class NMTTypeConstant : public JfrSerializer {\n+ public:\n+  void serialize(JfrCheckpointWriter& writer);\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -240,0 +241,3 @@\n+  if (MemTracker::enabled()) {\n+    register_static_type(TYPE_NMTTYPE, true, new NMTTypeConstant());\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-void MemJFRReporter::send_type_event(const Ticks& starttime, const char* type, size_t reserved, size_t committed) {\n+void MemJFRReporter::send_type_event(const Ticks& starttime, MEMFLAGS flag, size_t reserved, size_t committed) {\n@@ -91,1 +91,1 @@\n-  event.set_type(type);\n+  event.set_type(NMTUtil::flag_to_index(flag));\n@@ -111,1 +111,1 @@\n-    send_type_event(timestamp, NMTUtil::flag_to_name(flag), usage->reserved(flag), usage->committed(flag));\n+    send_type_event(timestamp, flag, usage->reserved(flag), usage->committed(flag));\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  static void send_type_event(const Ticks& starttime, const char* tag, size_t reserved, size_t committed);\n+  static void send_type_event(const Ticks& starttime, MEMFLAGS flag, size_t reserved, size_t committed);\n","filename":"src\/hotspot\/share\/services\/memJfrReporter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}