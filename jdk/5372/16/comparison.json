{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -810,6 +811,6 @@\n-     * identifying comment. Any one of a line feed ('\\n'), a carriage\n-     * return ('\\r'), or a carriage return followed immediately by a line feed\n-     * in comments is replaced by a line separator generated by the {@code Writer}\n-     * and if the next character in comments is not character {@code #} or\n-     * character {@code !} then an ASCII {@code #} is written out\n-     * after that line separator.\n+     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n+     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n+     * ({@code \\r\\n}) in comments is replaced by a\n+     * {@link System#lineSeparator() line separator} and if the next\n+     * character in comments is not character {@code #} or character {@code !} then\n+     * an ASCII {@code #} is written out after that line separator.\n@@ -817,4 +818,12 @@\n-     * Next, a comment line is always written, consisting of an ASCII\n-     * {@code #} character, the current date and time (as if produced\n-     * by the {@code toString} method of {@code Date} for the\n-     * current time), and a line separator as generated by the {@code Writer}.\n+     * If the {@systemProperty java.util.Properties.storeDate} is set and\n+     * is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n+     * a comment line is written as follows.\n+     * First, a {@code #} character is written, followed by the contents\n+     * of the property, followed by a line separator. Any line terminator characters\n+     * in the value of the system property are treated the same way as noted above\n+     * for the comments argument.\n+     * If the system property is not set or is empty, a comment line is written\n+     * as follows.\n+     * First, a {@code #} character is written, followed by the current date and time\n+     * formatted as if by the {@link Date#toString() Date.toString} method,\n+     * followed by a line separator.\n@@ -836,0 +845,7 @@\n+     * @implNote This method invokes the {@link #entrySet()} method\n+     * and writes out the returned key and element pairs\n+     * in the natural sort order of those keys. If subclasses override\n+     * the {@code entrySet} method and return a different {@code Set} instance,\n+     * then the property list is written out in the iteration order of\n+     * that returned {@code Set}\n+     *\n@@ -906,2 +922,2 @@\n-        bw.write(\"#\" + new Date().toString());\n-        bw.newLine();\n+        writeDateComment(bw);\n+\n@@ -909,3 +925,13 @@\n-            for (Map.Entry<Object, Object> e : entrySet()) {\n-                String key = (String)e.getKey();\n-                String val = (String)e.getValue();\n+            @SuppressWarnings(\"unchecked\")\n+            Collection<Map.Entry<String, String>> entries = (Set<Map.Entry<String, String>>) (Set) entrySet();\n+            \/\/ entrySet() can be overridden by subclasses. Here we check to see if the returned instance is the one\n+            \/\/ returned by the Properties.entrySet() implementation.If yes, then we sort those entries\n+            \/\/ in the natural order of their key. Else we just use the iteration order of the returned instance.\n+            if (entries instanceof Collections.SynchronizedSet<?> ss\n+                    && ss.c instanceof EntrySet) {\n+                entries = new ArrayList<>(entries);\n+                ((List<Map.Entry<String, String>>) entries).sort(Map.Entry.comparingByKey());\n+            }\n+            for (Map.Entry<String, String> e : entries) {\n+                String key = e.getKey();\n+                String val = e.getValue();\n@@ -924,0 +950,13 @@\n+    private static void writeDateComment(BufferedWriter bw) throws IOException {\n+        \/\/ value of java.util.Properties.storeDate system property isn't sensitive\n+        \/\/ and so doesn't need any security manager checks to make the value accessible\n+        \/\/ to the callers\n+        String storeDate = StaticProperty.javaUtilPropertiesStoreDate();\n+        if (storeDate != null && !storeDate.isEmpty()) {\n+            writeComments(bw, storeDate);\n+        } else {\n+            bw.write(\"#\" + new Date());\n+            bw.newLine();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":54,"deletions":15,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final String JAVA_UTIL_PROPERTIES_STOREDATE;\n@@ -70,0 +71,1 @@\n+        JAVA_UTIL_PROPERTIES_STOREDATE = getProperty(props, \"java.util.Properties.storeDate\", null);\n@@ -230,0 +232,12 @@\n+\n+    \/**\n+     * Return the {@code java.util.Properties.storeDate} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method.<\/strong>\n+     *\n+     * @return the {@code java.util.Properties.storeDate} system property\n+     *\/\n+    public static String javaUtilPropertiesStoreDate() {\n+        return JAVA_UTIL_PROPERTIES_STOREDATE;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+\/*\n+ * @test\n+ * @summary tests the order in which the Properties.store() method writes out the properties\n+ * @bug 8231640\n+ * @run testng PropertiesStoreTest\n+ *\/\n+public class PropertiesStoreTest {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"EEE MMM dd HH:mm:ss zzz uuuu\";\n+\n+    @DataProvider(name = \"propsProvider\")\n+    private Object[][] createProps() {\n+        final Properties simple = new Properties();\n+        simple.setProperty(\"1\", \"one\");\n+        simple.setProperty(\"2\", \"two\");\n+        simple.setProperty(\"10\", \"ten\");\n+        simple.setProperty(\"02\", \"zero-two\");\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+        simple.setProperty(\"00\", \"zero-zero\");\n+        simple.setProperty(\"0\", \"zero-again\");\n+\n+        final Properties specialChars = new Properties();\n+        \/\/ some special chars\n+        simple.setProperty(\" 1\", \"space-one\");\n+        simple.setProperty(\"\\t 3 7 \\n\", \"tab-space-three-space-seven-space-newline\");\n+        \/\/ add some simple chars\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+\n+        final Properties overrideCallsSuper = new OverridesEntrySetCallsSuper();\n+        overrideCallsSuper.putAll(simple);\n+\n+        final OverridesEntrySet overridesEntrySet = new OverridesEntrySet();\n+        overridesEntrySet.putAll(simple);\n+\n+        final Properties doesNotOverrideEntrySet = new DoesNotOverrideEntrySet();\n+        doesNotOverrideEntrySet.putAll(simple);\n+\n+        return new Object[][]{\n+                {simple, naturalOrder(simple)},\n+                {specialChars, naturalOrder(specialChars)},\n+                {overrideCallsSuper, naturalOrder(overrideCallsSuper)},\n+                {overridesEntrySet, overridesEntrySet.expectedKeyOrder()},\n+                {doesNotOverrideEntrySet, naturalOrder(doesNotOverrideEntrySet)}\n+        };\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(Writer, String)} API writes out the properties\n+     * in the expected order\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreWriterKeyOrder(final Properties props, final String[] expectedOrder) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile, expectedOrder);\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(OutputStream, String)} API writes out the properties\n+     * in the expected order\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreOutputStreamKeyOrder(final Properties props, final String[] expectedOrder) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final OutputStream os = Files.newOutputStream(tmpFile)) {\n+            props.store(os, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile, expectedOrder);\n+    }\n+\n+    \/**\n+     * {@link Properties#load(InputStream) Loads a Properties instance} from the passed\n+     * {@code Path} and then verifies that:\n+     * - the loaded properties instance \"equals\" the passed (original) \"props\" instance\n+     * - the order in which the properties appear in the file represented by the path\n+     * is the same as the passed \"expectedOrder\"\n+     *\/\n+    private void testStoreKeyOrder(final Properties props, final Path storedProps,\n+                                   final String[] expectedOrder) throws Exception {\n+        \/\/ Properties.load(...) from that stored file and verify that the loaded\n+        \/\/ Properties has expected content\n+        final Properties loaded = new Properties();\n+        try (final InputStream is = Files.newInputStream(storedProps)) {\n+            loaded.load(is);\n+        }\n+        Assert.assertEquals(loaded, props, \"Unexpected properties loaded from stored state\");\n+\n+        \/\/ now read lines from the stored file and keep track of the order in which the keys were\n+        \/\/ found in that file. Compare that order with the expected store order of the keys.\n+        final List<String> actualOrder;\n+        try (final BufferedReader reader = Files.newBufferedReader(storedProps)) {\n+            actualOrder = readInOrder(reader);\n+        }\n+        Assert.assertEquals(actualOrder.size(), expectedOrder.length,\n+                \"Unexpected number of keys read from stored properties\");\n+        if (!Arrays.equals(actualOrder.toArray(new String[0]), expectedOrder)) {\n+            Assert.fail(\"Unexpected order of stored property keys. Expected order: \" + Arrays.toString(expectedOrder)\n+                    + \", found order: \" + actualOrder);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(Writer, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreWriterDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(OutputStream, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreOutputStreamDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Reads each line in the {@code file} and verifies that there is only one comment line\n+     * and that comment line can be parsed into a {@link java.util.Date}\n+     *\/\n+    private void testDateComment(Path file) throws Exception {\n+        String comment = null;\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    if (comment != null) {\n+                        Assert.fail(\"More than one comment line found in the stored properties file \" + file);\n+                    }\n+                    comment = line.substring(1);\n+                }\n+            }\n+        }\n+        if (comment == null) {\n+            Assert.fail(\"No comment line found in the stored properties file \" + file);\n+        }\n+        try {\n+            DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN).parse(comment);\n+        } catch (DateTimeParseException pe) {\n+            Assert.fail(\"Unexpected date comment: \" + comment, pe);\n+        }\n+    }\n+\n+    \/\/ returns the property keys in their natural order\n+    private static String[] naturalOrder(final Properties props) {\n+        return new TreeSet<>(props.stringPropertyNames()).toArray(new String[0]);\n+    }\n+\n+    \/\/ reads each non-comment line and keeps track of the order in which the property key lines\n+    \/\/ were read\n+    private static List<String> readInOrder(final BufferedReader reader) throws IOException {\n+        final List<String> readKeys = new ArrayList<>();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            final String key = line.substring(0, line.indexOf(\"=\"));\n+            \/\/ the Properties.store(...) APIs write out the keys in a specific format for certain\n+            \/\/ special characters. Our test uses some of the keys which have those special characters.\n+            \/\/ Here we handle such special character conversion (for only those characters that this test uses).\n+            \/\/ replace the backslash character followed by the t character with the tab character\n+            String replacedKey = key.replace(\"\\\\t\", \"\\t\");\n+            \/\/ replace the backslash character followed by the n character with the newline character\n+            replacedKey = replacedKey.replace(\"\\\\n\", \"\\n\");\n+            \/\/ replace backslash character followed by the space character with the space character\n+            replacedKey = replacedKey.replace(\"\\\\ \", \" \");\n+            readKeys.add(replacedKey);\n+        }\n+        return readKeys;\n+    }\n+\n+    \/\/ Extends java.util.Properties and overrides entrySet() to return a reverse\n+    \/\/ sorted entries set\n+    private static class OverridesEntrySet extends Properties {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Set<Map.Entry<Object, Object>> entrySet() {\n+            \/\/ return a reverse sorted entries set\n+            var entries = super.entrySet();\n+            Comparator<Map.Entry<String, String>> comparator = Map.Entry.comparingByKey(Comparator.reverseOrder());\n+            TreeSet<Map.Entry<String, String>> reverseSorted = new TreeSet<>(comparator);\n+            reverseSorted.addAll((Set) entries);\n+            return (Set) reverseSorted;\n+        }\n+\n+        String[] expectedKeyOrder() {\n+            \/\/ returns in reverse order of the property keys' natural ordering\n+            var keys = new ArrayList<>(stringPropertyNames());\n+            keys.sort(Comparator.reverseOrder());\n+            return keys.toArray(new String[0]);\n+        }\n+    }\n+\n+    \/\/ Extends java.util.Properties and overrides entrySet() to just return \"super.entrySet()\"\n+    private static class OverridesEntrySetCallsSuper extends Properties {\n+        @Override\n+        public Set<Map.Entry<Object, Object>> entrySet() {\n+            return super.entrySet();\n+        }\n+    }\n+\n+    \/\/ Extends java.util.Properties but doesn't override entrySet() method\n+    private static class DoesNotOverrideEntrySet extends Properties {\n+\n+        @Override\n+        public String toString() {\n+            return \"DoesNotOverrideEntrySet - \" + super.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/PropertiesStoreTest.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Properties;\n+import java.util.TimeZone;\n+\n+\/*\n+ * @test\n+ * @summary Tests that the Properties.store() APIs generate output that is reproducible\n+ * @bug 8231640\n+ * @library \/test\/lib\n+ * @run driver StoreReproducibilityTest\n+ *\/\n+public class StoreReproducibilityTest {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"EEE MMM dd HH:mm:ss zzz uuuu\";\n+    private static final String SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE = \"java.util.Properties.storeDate\";\n+    private static final DateTimeFormatter reproducibleDateTimeFormatter = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN)\n+            .withLocale(Locale.ROOT).withZone(ZoneOffset.UTC);\n+\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ no security manager enabled\n+        testWithoutSecurityManager();\n+        \/\/ security manager enabled and security policy explicitly allows\n+        \/\/ read permissions on java.util.Properties.storeDate system property\n+        testWithSecMgrExplicitPermission();\n+        \/\/ security manager enabled and no explicit permission on java.util.Properties.storeDate system property\n+        testWithSecMgrNoSpecificPermission();\n+        \/\/ free form non-date value for java.util.Properties.storeDate system property\n+        testNonDateStoreDateValue();\n+        \/\/ blank value for java.util.Properties.storeDate system property\n+        testBlankStoreDateValue();\n+        \/\/ empty value for java.util.Properties.storeDate system property\n+        testEmptyStoreDateValue();\n+        \/\/ value for java.util.Properties.storeDate system property contains line terminator characters\n+        testMultiLineStoreDateValue();\n+        \/\/ value for java.util.Properties.storeDate system property contains backslash character\n+        testBackSlashInStoreDateValue();\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out\n+     * to the file is expected to use this value.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     * The launched Java program is run without any security manager\n+     *\/\n+    private static void testWithoutSecurityManager() throws Exception {\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(243535322));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is granted\n+     * a {@code read} permission on {@code java.util.Properties.storeDate}.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     *\/\n+    private static void testWithSecMgrExplicitPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ explicitly grant read permission on java.util.Properties.storeDate system property\n+                    \/\/ to verify store() APIs work fine\n+                    permission java.util.PropertyPermission \"java.util.Properties.storeDate\", \"read\";\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is NOT granted\n+     * any explicit permission for {@code java.util.Properties.storeDate} system property.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     *\/\n+    private static void testWithSecMgrNoSpecificPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ no other grants, not even \"read\" java.util.Properties.storeDate system property.\n+                    \/\/ test should still work fine and the date comment should correspond to the value of\n+                    \/\/ java.util.Properties.storeDate system property.\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a {@link String#isBlank() blank} value\n+     * for the {@code java.util.Properties.storeDate} system property.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause a comment line to be written out with only whitespaces.\n+     * The launched program is expected to complete without any errors.\n+     *\/\n+    private static void testBlankStoreDateValue() throws Exception {\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = \"      \\t\";\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            String blankCommentLine = findNthComment(tmpFile, 2);\n+            if (blankCommentLine == null) {\n+                throw new RuntimeException(\"Comment line representing the value of \"\n+                        + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \" system property is missing in file \" + tmpFile);\n+            }\n+            if (!blankCommentLine.isBlank()) {\n+                throw new RuntimeException(\"Expected comment line to be blank but was \" + blankCommentLine);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a {@link String#isEmpty() empty} value\n+     * for the {@code java.util.Properties.storeDate} system property.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause the current date and time to be written out as a comment.\n+     * The launched program is expected to complete without any errors.\n+     *\/\n+    private static void testEmptyStoreDateValue() throws Exception {\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + \"\",\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            Date launchedAt = new Date();\n+            \/\/ wait for a second before launching so that we can then expect\n+            \/\/ the date written out by the store() APIs to be \"after\" this launch date\n+            Thread.sleep(1000);\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertCurrentDate(tmpFile, launchedAt);\n+        }\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed the {@code java.util.Properties.storeDate}\n+     * system property with a value that doesn't represent a formatted date.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause the comment to use that value verbatim. The launched program is expected to complete\n+     * without any errors.\n+     *\/\n+    private static void testNonDateStoreDateValue() throws Exception {\n+        final String storeDate = \"foo-bar\";\n+        final List<Path> storedFiles = new ArrayList<>();\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed the {@code java.util.Properties.storeDate}\n+     * system property with a value that has line terminator characters.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause the comment written out to be multiple separate comments. The launched program is expected\n+     * to complete without any errors.\n+     *\/\n+    private static void testMultiLineStoreDateValue() throws Exception {\n+        final String[] storeDates = {\"hello-world\\nc=d\", \"hello-world\\rc=d\", \"hello-world\\r\\nc=d\"};\n+        for (final String storeDate : storeDates) {\n+            final List<Path> storedFiles = new ArrayList<>();\n+            for (int i = 0; i < 2; i++) {\n+                final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+                storedFiles.add(tmpFile);\n+                final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                        \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                        StoreTest.class.getName(),\n+                        tmpFile.toString(),\n+                        i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+                executeJavaProcess(processBuilder);\n+                if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                    throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+                }\n+                \/\/ verify this results in 2 separate comment lines in the stored file\n+                String commentLine1 = findNthComment(tmpFile, 2);\n+                String commentLine2 = findNthComment(tmpFile, 3);\n+                if (commentLine1 == null || commentLine2 == null) {\n+                    throw new RuntimeException(\"Did not find the expected multi-line comments in \" + tmpFile);\n+                }\n+                if (!commentLine1.equals(\"hello-world\")) {\n+                    throw new RuntimeException(\"Unexpected comment line \" + commentLine1 + \" in \" + tmpFile);\n+                }\n+                if (!commentLine2.equals(\"c=d\")) {\n+                    throw new RuntimeException(\"Unexpected comment line \" + commentLine2 + \" in \" + tmpFile);\n+                }\n+            }\n+            assertAllFileContentsAreSame(storedFiles, storeDate);\n+        }\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed the {@code java.util.Properties.storeDate}\n+     * system property with a value that has backslash character.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will not cause any malformed comments or introduce any new properties in the stored content.\n+     * The launched program is expected to complete without any errors.\n+     *\/\n+    private static void testBackSlashInStoreDateValue() throws Exception {\n+        final String[] storeDates = {\"\\\\hello-world\", \"hello-world\\\\\", \"hello-world\\\\c=d\",\n+                \"newline-plus-backslash\\\\\\nc=d\"};\n+        for (final String storeDate : storeDates) {\n+            final List<Path> storedFiles = new ArrayList<>();\n+            for (int i = 0; i < 2; i++) {\n+                final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+                storedFiles.add(tmpFile);\n+                final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                        \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                        StoreTest.class.getName(),\n+                        tmpFile.toString(),\n+                        i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+                executeJavaProcess(processBuilder);\n+                if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                    throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+                }\n+                String commentLine1 = findNthComment(tmpFile, 2);\n+                if (commentLine1 == null) {\n+                    throw new RuntimeException(\"Did not find the expected comment line in \" + tmpFile);\n+                }\n+                if (storeDate.contains(\"newline-plus-backslash\")) {\n+                    if (!commentLine1.equals(\"newline-plus-backslash\\\\\")) {\n+                        throw new RuntimeException(\"Unexpected comment line \" + commentLine1 + \" in \" + tmpFile);\n+                    }\n+                    \/\/ we expect this specific system property value to be written out into 2 separate comment lines\n+                    String commentLine2 = findNthComment(tmpFile, 3);\n+                    if (commentLine2 == null) {\n+                        throw new RuntimeException(storeDate + \" was expected to be split into 2 comment line, \" +\n+                                \"but wasn't, in \" + tmpFile);\n+                    }\n+                    if (!commentLine2.equals(\"c=d\")) {\n+                        throw new RuntimeException(\"Unexpected comment line \" + commentLine2 + \" in \" + tmpFile);\n+                    }\n+                } else {\n+                    if (!commentLine1.equals(storeDate)) {\n+                        throw new RuntimeException(\"Unexpected comment line \" + commentLine1 + \" in \" + tmpFile);\n+                    }\n+                }\n+            }\n+            assertAllFileContentsAreSame(storedFiles, storeDate);\n+        }\n+    }\n+\n+    \/\/ launches the java process and waits for it to exit. throws an exception if exit value is non-zero\n+    private static void executeJavaProcess(ProcessBuilder pb) throws Exception {\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+        try {\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } finally {\n+            \/\/ print out any stdout\/err that was generated in the launched program\n+            outputAnalyzer.reportDiagnosticSummary();\n+        }\n+    }\n+\n+    \/\/ Properties.load() from the passed file and return the loaded Properties instance\n+    private static Properties loadProperties(final Path file) throws IOException {\n+        final Properties props = new Properties();\n+        props.load(Files.newBufferedReader(file));\n+        return props;\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} is same as {@code storeDate}\n+     *\/\n+    private static void assertExpectedStoreDate(final Path destFile,\n+                                                final String storeDate) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Comment \\\"\" + storeDate + \"\\\" not found in stored properties \" + destFile);\n+        }\n+        if (!storeDate.equals(dateComment)) {\n+            throw new RuntimeException(\"Expected comment \\\"\" + storeDate + \"\\\" but found \\\"\" + dateComment + \"\\\" \" +\n+                    \"in stored properties \" + destFile);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} can be parsed using the\n+     * \"EEE MMM dd HH:mm:ss zzz yyyy\" format and the time represented by it is {@link Date#after(Date) after}\n+     * the passed {@code date}\n+     *\/\n+    private static void assertCurrentDate(final Path destFile, final Date date) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile);\n+        }\n+        System.out.println(\"Found date comment \" + dateComment + \" in file \" + destFile);\n+        final Date parsedDate;\n+        try {\n+            Instant instant = Instant.from(DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN).parse(dateComment));\n+            parsedDate = new Date(instant.toEpochMilli());\n+        } catch (DateTimeParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile);\n+        }\n+        if (!parsedDate.after(date)) {\n+            throw new RuntimeException(\"Expected date comment \" + dateComment + \" to be after \" + date\n+                    + \" but was \" + parsedDate);\n+        }\n+    }\n+\n+    \/\/ returns the \"Nth\" comment from the file. Comment index starts from 1.\n+    private static String findNthComment(Path file, int commentIndex) throws IOException {\n+        List<String> comments = new ArrayList<>();\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    comments.add(line.substring(1));\n+                    if (comments.size() == commentIndex) {\n+                        return comments.get(commentIndex - 1);\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(final List<Path> files,\n+                                                     final String storeDate) throws Exception {\n+        final byte[] file1Contents = Files.readAllBytes(files.get(0));\n+        for (int i = 1; i < files.size(); i++) {\n+            final byte[] otherFileContents = Files.readAllBytes(files.get(i));\n+            if (!Arrays.equals(file1Contents, otherFileContents)) {\n+                throw new RuntimeException(\"Properties.store() did not generate reproducible content when \" +\n+                        \"storeDate was set to \" + storeDate);\n+            }\n+        }\n+    }\n+\n+    static class StoreTest {\n+        private static final Properties propsToStore = new Properties();\n+\n+        static {\n+            propsToStore.setProperty(\"a\", \"b\");\n+        }\n+\n+        \/**\n+         * Uses Properties.store() APIs to store the properties into file\n+         *\/\n+        public static void main(final String[] args) throws Exception {\n+            final Path destFile = Path.of(args[0]);\n+            final String comment = \"some user specified comment\";\n+            System.out.println(\"Current default timezone is \" + TimeZone.getDefault());\n+            if (args[1].equals(\"--use-outputstream\")) {\n+                try (var os = Files.newOutputStream(destFile)) {\n+                    propsToStore.store(os, comment);\n+                }\n+            } else {\n+                try (var br = Files.newBufferedWriter(destFile)) {\n+                    propsToStore.store(br, comment);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"}]}