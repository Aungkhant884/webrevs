{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,7 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.DateTimeException;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n@@ -49,0 +56,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -168,0 +176,4 @@\n+    \/\/ used to format the date comment written out by the store() APIs.\n+    \/\/ This format matches the one used by java.util.Date.toString()\n+    private static final String dateFormatPattern = \"EEE MMM dd HH:mm:ss zzz yyyy\";\n+\n@@ -817,4 +829,10 @@\n-     * Next, a comment line is always written, consisting of an ASCII\n-     * {@code #} character, the current date and time (as if produced\n-     * by the {@code toString} method of {@code Date} for the\n-     * current time), and a line separator as generated by the {@code Writer}.\n+     * If the {@systemProperty java.util.Properties.storeDate} is set and\n+     * is non-blank (as determined by {@link String#isBlank String.isBlank}),\n+     * a comment line is written as follows.\n+     * First, a {@code #} character is written, followed by the contents\n+     * of the property, followed by a line separator.\n+     * If the system property is not set or is blank, a comment line is written\n+     * as follows.\n+     * First, a {@code #} character is written, followed by the current date and time\n+     * formatted as if by {@link DateTimeFormatter} with the format\n+     * {@code \"EEE MMM dd HH:mm:ss zzz yyyy\"}, followed by a line separator.\n@@ -836,0 +854,6 @@\n+     * @implNote Although this method doesn't mandate it, conventionally,\n+     * the value of the {@systemProperty java.util.Properties.storeDate}\n+     * system property, if set, represents a formatted date time value that can be\n+     * parsed back into a {@link Date} using an appropriate\n+     * {@link DateTimeFormatter}\n+     *\n@@ -906,2 +930,2 @@\n-        bw.write(\"#\" + new Date().toString());\n-        bw.newLine();\n+        writeDateComment(bw);\n+\n@@ -909,3 +933,6 @@\n-            for (Map.Entry<Object, Object> e : entrySet()) {\n-                String key = (String)e.getKey();\n-                String val = (String)e.getValue();\n+            @SuppressWarnings(\"unchecked\")\n+            var entries = new ArrayList<>(((Map<String, String>) (Map) map).entrySet());\n+            entries.sort(Map.Entry.comparingByKey());\n+            for (Map.Entry<String, String> e : entries) {\n+                String key = e.getKey();\n+                String val = e.getValue();\n@@ -924,0 +951,12 @@\n+    private static void writeDateComment(BufferedWriter bw) throws IOException {\n+        \/\/ value of java.util.Properties.storeDate system property isn't sensitive\n+        \/\/ and so doesn't need any security manager checks to make the value accessible\n+        \/\/ to the callers\n+        String storeDate = StaticProperty.javaUtilPropertiesStoreDate();\n+        String dateComment = (storeDate != null && !storeDate.isBlank())\n+                ? \"#\" + storeDate\n+                : \"#\" + DateTimeFormatter.ofPattern(dateFormatPattern).format(ZonedDateTime.now());\n+        bw.write(dateComment);\n+        bw.newLine();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final String JAVA_UTIL_PROPERTIES_STOREDATE;\n@@ -70,0 +71,1 @@\n+        JAVA_UTIL_PROPERTIES_STOREDATE = getProperty(props, \"java.util.Properties.storeDate\", null);\n@@ -230,0 +232,12 @@\n+\n+    \/**\n+     * Return the {@code java.util.Properties.storeDate} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method.<\/strong>\n+     *\n+     * @return the {@code java.util.Properties.storeDate} system property\n+     *\/\n+    public static String javaUtilPropertiesStoreDate() {\n+        return JAVA_UTIL_PROPERTIES_STOREDATE;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.TreeSet;\n+\n+\/*\n+ * @test\n+ * @summary tests the order in which the Properties.store() method writes out the properties\n+ * @bug 8231640\n+ * @run testng PropertiesStoreTest\n+ *\/\n+public class PropertiesStoreTest {\n+\n+    private static final String dateCommentFormat = \"EEE MMM dd HH:mm:ss zzz yyyy\";\n+\n+    @DataProvider(name = \"propsProvider\")\n+    private Object[][] createProps() {\n+        final Properties simple = new Properties();\n+        simple.setProperty(\"1\", \"one\");\n+        simple.setProperty(\"2\", \"two\");\n+        simple.setProperty(\"10\", \"ten\");\n+        simple.setProperty(\"02\", \"zero-two\");\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+        simple.setProperty(\"00\", \"zero-zero\");\n+        simple.setProperty(\"0\", \"zero-again\");\n+\n+        final Properties specialChars = new Properties();\n+        \/\/ some special chars\n+        simple.setProperty(\" 1\", \"space-one\");\n+        simple.setProperty(\"\\t 3 7 \\n\", \"tab-space-three-space-seven-space-newline\");\n+        \/\/ add some simple chars\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+\n+        return new Object[][]{\n+                {simple},\n+                {specialChars}\n+        };\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(Writer, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreWriterKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(OutputStream, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreOutputStreamKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final OutputStream os = Files.newOutputStream(tmpFile)) {\n+            props.store(os, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * {@link Properties#load(InputStream) Loads a Properties instance} from the passed\n+     * {@code Path} and then verifies that:\n+     * - the loaded properties instance \"equals\" the passed (original) \"props\" instance\n+     * - the order in which the properties appear in the file represented by the path\n+     * is the expected natural order of the property keys.\n+     *\/\n+    private void testStoreKeyOrder(final Properties props, final Path storedProps) throws Exception {\n+        \/\/ Properties.load(...) from that stored file and verify that the loaded\n+        \/\/ Properties has expected content\n+        final Properties loaded = new Properties();\n+        try (final InputStream is = Files.newInputStream(storedProps)) {\n+            loaded.load(is);\n+        }\n+        Assert.assertEquals(loaded, props, \"Unexpected properties loaded from stored state\");\n+\n+        \/\/ now read lines from the stored file and keep track of the order in which the keys were\n+        \/\/ found in that file. Compare that order with the expected store order of the keys.\n+        final List<String> actualOrder;\n+        try (final BufferedReader reader = Files.newBufferedReader(storedProps)) {\n+            actualOrder = readInOrder(reader);\n+        }\n+        final String[] expectedOrder = expectedKeyOrder(props);\n+        Assert.assertEquals(actualOrder.size(), expectedOrder.length,\n+                \"Unexpected number of keys read from stored properties\");\n+        if (!Arrays.equals(actualOrder.toArray(new String[0]), expectedOrder)) {\n+            Assert.fail(\"Unexpected order of stored property keys. Expected order: \" + Arrays.toString(expectedOrder)\n+                    + \", found order: \" + actualOrder);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(Writer, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreWriterDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(OutputStream, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreOutputStreamDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Reads each line in the {@code file} and verifies that there is only one comment line\n+     * and that comment line can be parsed into a {@link java.util.Date}\n+     *\/\n+    private void testDateComment(Path file) throws Exception {\n+        String comment = null;\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    if (comment != null) {\n+                        Assert.fail(\"More than one comment line found in the stored properties file \" + file);\n+                    }\n+                    comment = line.substring(1);\n+                }\n+            }\n+        }\n+        if (comment == null) {\n+            Assert.fail(\"No comment line found in the stored properties file \" + file);\n+        }\n+        try {\n+            new SimpleDateFormat(dateCommentFormat).parse(comment);\n+        } catch (ParseException pe) {\n+            Assert.fail(\"Unexpected date comment: \" + comment, pe);\n+        }\n+    }\n+\n+    \/\/ returns the property keys in their natural order\n+    private static String[] expectedKeyOrder(final Properties props) {\n+        return new TreeSet<>(props.stringPropertyNames()).toArray(new String[0]);\n+    }\n+\n+    \/\/ reads each non-comment line and keeps track of the order in which the property key lines\n+    \/\/ were read\n+    private static List<String> readInOrder(final BufferedReader reader) throws IOException {\n+        final List<String> readKeys = new ArrayList<>();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            final String key = line.substring(0, line.indexOf(\"=\"));\n+            \/\/ the Properties.store(...) APIs write out the keys in a specific format for certain\n+            \/\/ special characters. Our test uses some of the keys which have those special characters.\n+            \/\/ Here we handle such special character conversion (for only those characters that this test uses).\n+            \/\/ replace the backslash character followed by the t character with the tab character\n+            String replacedKey = key.replace(\"\\\\t\", \"\\t\");\n+            \/\/ replace the backslash character followed by the n character with the newline character\n+            replacedKey = replacedKey.replace(\"\\\\n\", \"\\n\");\n+            \/\/ replace backslash character followed by the space character with the space character\n+            replacedKey = replacedKey.replace(\"\\\\ \", \" \");\n+            readKeys.add(replacedKey);\n+        }\n+        return readKeys;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/PropertiesStoreTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Properties;\n+import java.util.TimeZone;\n+\n+\/*\n+ * @test\n+ * @summary Tests that the Properties.store() APIs generate output that is reproducible\n+ * @bug 8231640\n+ * @library \/test\/lib\n+ * @run driver StoreReproducibilityTest\n+ *\/\n+public class StoreReproducibilityTest {\n+\n+    private static final String dateCommentFormat = \"EEE MMM dd HH:mm:ss zzz yyyy\";\n+    private static final String SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE = \"java.util.Properties.storeDate\";\n+    private static final DateTimeFormatter reproducibleDateTimeFormatter = DateTimeFormatter.ofPattern(dateCommentFormat)\n+            .withLocale(Locale.ROOT).withZone(ZoneOffset.UTC);\n+\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ no security manager enabled\n+        testWithoutSecurityManager();\n+        \/\/ security manager enabled and security policy explicitly allows\n+        \/\/ read permissions on java.util.Properties.storeDate system property\n+        testWithSecMgrExplicitPermission();\n+        \/\/ security manager enabled and no explicit permission on java.util.Properties.storeDate system property\n+        testWithSecMgrNoSpecificPermission();\n+        \/\/ free form non-date value for java.util.Properties.storeDate system property\n+        testNonDateStoreDateValue();\n+        \/\/ blank value for java.util.Properties.storeDate system property\n+        testBlankStoreDateValue();\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out\n+     * to the file is expected to use this value.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     * The launched Java program is run without any security manager\n+     *\/\n+    private static void testWithoutSecurityManager() throws Exception {\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(243535322));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is granted\n+     * a {@code read} permission on {@code java.util.Properties.storeDate}.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     *\/\n+    private static void testWithSecMgrExplicitPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ explicitly grant read permission on java.util.Properties.storeDate system property\n+                    \/\/ to verify store() APIs work fine\n+                    permission java.util.PropertyPermission \"java.util.Properties.storeDate\", \"read\";\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a value for the\n+     * {@code java.util.Properties.storeDate} system property and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is NOT granted\n+     * any explicit permission for {@code java.util.Properties.storeDate} system property.\n+     * The program is launched multiple times with the same value for {@code java.util.Properties.storeDate}\n+     * and the output written by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code java.util.Properties.storeDate}.\n+     *\/\n+    private static void testWithSecMgrNoSpecificPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ no other grants, not even \"read\" java.util.Properties.storeDate system property.\n+                    \/\/ test should still work fine and the date comment should correspond to the value of\n+                    \/\/ java.util.Properties.storeDate system property.\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String storeDate = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, storeDate);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed a blank value\n+     * for the {@code java.util.Properties.storeDate} system property.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause the date comment to use the current date time. The launched program is expected to complete\n+     * without any errors.\n+     *\/\n+    private static void testBlankStoreDateValue() throws Exception {\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + \"      \\t\",\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            Date launchedAt = new Date();\n+            \/\/ wait for a second before launching so that we can then expect\n+            \/\/ the date written out by the store() APIs to be \"after\" this launch date\n+            Thread.sleep(1000);\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertCurrentDate(tmpFile, launchedAt);\n+        }\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed the {@code java.util.Properties.storeDate}\n+     * system property with a value that doesn't represent a formatted date.\n+     * It is expected and verified in this test that such a value for the system property\n+     * will cause the comment to use that value verbatim. The launched program is expected to complete\n+     * without any errors.\n+     *\/\n+    private static void testNonDateStoreDateValue() throws Exception {\n+        final String storeDate = \"foo-bar\";\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-D\" + SYS_PROP_JAVA_UTIL_PROPERTIES_STOREDATE + \"=\" + storeDate,\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertExpectedStoreDate(tmpFile, storeDate);\n+        }\n+    }\n+\n+    \/\/ launches the java process and waits for it to exit. throws an exception if exit value is non-zero\n+    private static void executeJavaProcess(ProcessBuilder pb) throws Exception {\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+        try {\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } finally {\n+            \/\/ print out any stdout\/err that was generated in the launched program\n+            outputAnalyzer.reportDiagnosticSummary();\n+        }\n+    }\n+\n+    \/\/ Properties.load() from the passed file and return the loaded Properties instance\n+    private static Properties loadProperties(final Path file) throws IOException {\n+        final Properties props = new Properties();\n+        props.load(Files.newBufferedReader(file));\n+        return props;\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} is same as {@code storeDate}\n+     *\/\n+    private static void assertExpectedStoreDate(final Path destFile,\n+                                                final String storeDate) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Comment \\\"\" + storeDate + \"\\\" not found in stored properties \" + destFile);\n+        }\n+        if (!storeDate.equals(dateComment)) {\n+            throw new RuntimeException(\"Expected comment \\\"\" + storeDate + \"\\\" but found \\\"\" + dateComment + \"\\\" \" +\n+                    \"in stored properties \" + destFile);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} can be parsed and the time\n+     * represented by it is {@link Date#after(Date) after} the passed {@code date}\n+     *\/\n+    private static void assertCurrentDate(final Path destFile, final Date date) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile);\n+        }\n+        System.out.println(\"Found date comment \" + dateComment + \" in file \" + destFile);\n+        final Date parsedDate;\n+        try {\n+            parsedDate = new SimpleDateFormat(dateCommentFormat).parse(dateComment);\n+        } catch (ParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile);\n+        }\n+        if (!parsedDate.after(date)) {\n+            throw new RuntimeException(\"Expected date comment \" + dateComment + \" to be after \" + date\n+                    + \" but was \" + parsedDate);\n+        }\n+    }\n+\n+    \/\/ returns the \"Nth\" comment from the file. Comment index starts from 1.\n+    private static String findNthComment(Path file, int commentIndex) throws IOException {\n+        List<String> comments = new ArrayList<>();\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    comments.add(line.substring(1));\n+                    if (comments.size() == commentIndex) {\n+                        return comments.get(commentIndex - 1);\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(final List<Path> files,\n+                                                     final String storeDate) throws Exception {\n+        final byte[] file1Contents = Files.readAllBytes(files.get(0));\n+        for (int i = 1; i < files.size(); i++) {\n+            final byte[] otherFileContents = Files.readAllBytes(files.get(i));\n+            if (!Arrays.equals(file1Contents, otherFileContents)) {\n+                throw new RuntimeException(\"Properties.store() did not generate reproducible content when \" +\n+                        \"storeDate was set to \" + storeDate);\n+            }\n+        }\n+    }\n+\n+    static class StoreTest {\n+        private static final Properties propsToStore = new Properties();\n+\n+        static {\n+            propsToStore.setProperty(\"a\", \"b\");\n+        }\n+\n+        \/**\n+         * Uses Properties.store() APIs to store the properties into file\n+         *\/\n+        public static void main(final String[] args) throws Exception {\n+            final Path destFile = Path.of(args[0]);\n+            final String comment = \"some user specified comment\";\n+            System.out.println(\"Current default timezone is \" + TimeZone.getDefault());\n+            if (args[1].equals(\"--use-outputstream\")) {\n+                try (var os = Files.newOutputStream(destFile)) {\n+                    propsToStore.store(os, comment);\n+                }\n+            } else {\n+                try (var br = Files.newBufferedWriter(destFile)) {\n+                    propsToStore.store(br, comment);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"}]}