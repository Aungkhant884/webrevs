{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n@@ -168,0 +170,5 @@\n+    \/\/ cached, string representation of any Date parsed out of the SOURCE_DATE_EPOCH environment variable\n+    private static volatile String cachedDateComment;\n+    \/\/ true if SOURCE_DATE_EPOCH environment variable value has been parsed\n+    private static volatile boolean sourceDateEpochParsed;\n+\n@@ -836,0 +843,10 @@\n+     * @implNote When writing the date comment, this method checks whether the\n+     * {@code SOURCE_DATE_EPOCH} environment variable is set. If it is set, then instead\n+     * of writing the current date and time, the date and time represented by the\n+     * value of {@code SOURCE_DATE_EPOCH} will be written, using the\n+     * {@code d MMM yyyy HH:mm:ss 'GMT'} date format and {@link Locale#ROOT root locale}.\n+     * In the presence of a SecurityManager, if the caller doesn't have permission\n+     * to read the {@code SOURCE_DATE_EPOCH} environment variable, then the current date\n+     * and time will be written. Similarly, if the value set for {@code SOURCE_DATE_EPOCH}\n+     * cannot be parsed to a {@code long}, then the current date and time will be written.\n+     *\n@@ -906,2 +923,1 @@\n-        bw.write(\"#\" + new Date().toString());\n-        bw.newLine();\n+        writeDateComment(bw);\n@@ -909,1 +925,1 @@\n-            for (Map.Entry<Object, Object> e : entrySet()) {\n+            for (Map.Entry<Object, Object> e : new TreeMap<>(map).entrySet()) {\n@@ -924,0 +940,53 @@\n+    private static void writeDateComment(BufferedWriter bw) throws IOException {\n+        if (sourceDateEpochParsed && cachedDateComment == null) {\n+            \/\/ SOURCE_DATE_EPOCH environment variable value has already been queried previously and\n+            \/\/ the environment variable was either not set or its value couldn't be parsed to a Date.\n+            \/\/ In either case, we write out the current date in the date comment\n+            bw.write(\"#\" + new Date());\n+            bw.newLine();\n+            return;\n+        }\n+        \/\/ Either the SOURCE_DATE_EPOCH environment variable needs to be queried or we have already\n+        \/\/ queried it previously and are holding a cached string representation of that value.\n+        \/\/ In either case, we first make sure the current caller has the necessary permissions to access\n+        \/\/ that environment variable's value\n+        String sourceDateEpoch = null;\n+        try {\n+            sourceDateEpoch = System.getenv(\"SOURCE_DATE_EPOCH\");\n+        } catch (SecurityException se) {\n+            \/\/ caller code doesn't have permissions to SOURCE_DATE_EPOCH environment variable.\n+            \/\/ Use current date in comment\n+            bw.write(\"#\" + new Date());\n+            bw.newLine();\n+            return;\n+        }\n+        \/\/ caller code has permissions to the environment variable, OK to use (any parseable) value\n+        \/\/ of that environment variable in the date comment\n+        if (!sourceDateEpochParsed) {\n+            synchronized (Properties.class) {\n+                if (!sourceDateEpochParsed) {\n+                    try {\n+                        String dateComment = null;\n+                        if (sourceDateEpoch != null) {\n+                            try {\n+                                Date d = new Date(Long.parseLong(sourceDateEpoch) * 1000);\n+                                \/\/ use the same format as that of Date.toGMTString() and a neutral locale for reproducibility\n+                                DateFormat df = new SimpleDateFormat(\"d MMM yyyy HH:mm:ss 'GMT'\", Locale.ROOT);\n+                                df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+                                dateComment = \"#\" + df.format(d);\n+                            } catch (NumberFormatException nfe) {\n+                                \/\/ ignore any value that cannot be parsed for the SOURCE_DATE_EPOCH.\n+                                \/\/ store APIs will subsequently use current date, in their date comments\n+                            }\n+                        }\n+                        cachedDateComment = dateComment;\n+                    } finally {\n+                        sourceDateEpochParsed = true;\n+                    }\n+                }\n+            }\n+        }\n+        bw.write(cachedDateComment != null ? cachedDateComment : \"#\" + new Date());\n+        bw.newLine();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":73,"deletions":4,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.TreeSet;\n+\n+\/*\n+ * @test\n+ * @summary tests the order in which the Properties.store() method writes out the properties\n+ * @bug 8231640\n+ * @run testng PropertiesStoreTest\n+ *\/\n+public class PropertiesStoreTest {\n+\n+    @DataProvider(name = \"propsProvider\")\n+    private Object[][] createProps() {\n+        final Properties simple = new Properties();\n+        simple.setProperty(\"1\", \"one\");\n+        simple.setProperty(\"2\", \"two\");\n+        simple.setProperty(\"10\", \"ten\");\n+        simple.setProperty(\"02\", \"zero-two\");\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+        simple.setProperty(\"00\", \"zero-zero\");\n+        simple.setProperty(\"0\", \"zero-again\");\n+\n+        final Properties specialChars = new Properties();\n+        \/\/ some special chars\n+        simple.setProperty(\" 1\", \"space-one\");\n+        simple.setProperty(\"\\t 3 7 \\n\", \"tab-space-three-space-seven-space-newline\");\n+        \/\/ add some simple chars\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+\n+        return new Object[][]{\n+                {simple},\n+                {specialChars}\n+        };\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(Writer, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreWriterKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(OutputStream, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreOutputStreamKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final OutputStream os = Files.newOutputStream(tmpFile)) {\n+            props.store(os, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * {@link Properties#load(InputStream) Loads a Properties instance} from the passed\n+     * {@code Path} and then verifies that:\n+     * - the loaded properties instance \"equals\" the passed (original) \"props\" instance\n+     * - the order in which the properties appear in the file represented by the path\n+     * is the expected natural order of the property keys.\n+     *\/\n+    private void testStoreKeyOrder(final Properties props, final Path storedProps) throws Exception {\n+        \/\/ Properties.load(...) from that stored file and verify that the loaded\n+        \/\/ Properties has expected content\n+        final Properties loaded = new Properties();\n+        try (final InputStream is = Files.newInputStream(storedProps)) {\n+            loaded.load(is);\n+        }\n+        Assert.assertEquals(loaded, props, \"Unexpected properties loaded from stored state\");\n+\n+        \/\/ now read lines from the stored file and keep track of the order in which the keys were\n+        \/\/ found in that file. Compare that order with the expected store order of the keys.\n+        final List<String> actualOrder;\n+        try (final BufferedReader reader = Files.newBufferedReader(storedProps)) {\n+            actualOrder = readInOrder(reader);\n+        }\n+        final String[] expectedOrder = expectedKeyOrder(props);\n+        Assert.assertEquals(actualOrder.size(), expectedOrder.length,\n+                \"Unexpected number of keys read from stored properties\");\n+        if (!Arrays.equals(actualOrder.toArray(new String[0]), expectedOrder)) {\n+            Assert.fail(\"Unexpected order of stored property keys. Expected order: \" + Arrays.toString(expectedOrder)\n+                    + \", found order: \" + actualOrder);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(Writer, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreWriterDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(OutputStream, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreOutputStreamDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Reads each line in the {@code file} and verifies that there is only one comment line\n+     * and that comment line can be parsed into a {@link java.util.Date}\n+     *\/\n+    private void testDateComment(Path file) throws Exception {\n+        String comment = null;\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    if (comment != null) {\n+                        Assert.fail(\"More than one comment line found in the stored properties file \" + file);\n+                    }\n+                    comment = line.substring(1);\n+                }\n+            }\n+        }\n+        if (comment == null) {\n+            Assert.fail(\"No comment line found in the stored properties file \" + file);\n+        }\n+        try {\n+            new SimpleDateFormat(\"EEE MMM dd hh:mm:ss zzz yyyy\").parse(comment);\n+        } catch (ParseException pe) {\n+            Assert.fail(\"Unexpected date comment: \" + comment);\n+        }\n+    }\n+\n+    \/\/ returns the property keys in their natural order\n+    private static String[] expectedKeyOrder(final Properties props) {\n+        return new TreeSet<>(props.stringPropertyNames()).toArray(new String[0]);\n+    }\n+\n+    \/\/ reads each non-comment line and keeps track of the order in which the property key lines\n+    \/\/ were read\n+    private static List<String> readInOrder(final BufferedReader reader) throws IOException {\n+        final List<String> readKeys = new ArrayList<>();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            final String key = line.substring(0, line.indexOf(\"=\"));\n+            \/\/ the Properties.store(...) APIs write out the keys in a specific format for certain\n+            \/\/ special characters. Our test uses some of the keys which have those special characters.\n+            \/\/ Here we handle such special character conversion (for only those characters that this test uses).\n+            \/\/ replace the backslash character followed by the t character with the tab character\n+            String replacedKey = key.replace(\"\\\\t\", \"\\t\");\n+            \/\/ replace the backslash character followed by the n character with the newline character\n+            replacedKey = replacedKey.replace(\"\\\\n\", \"\\n\");\n+            \/\/ replace backslash character followed by the space character with the space character\n+            replacedKey = replacedKey.replace(\"\\\\ \", \" \");\n+            readKeys.add(replacedKey);\n+        }\n+        return readKeys;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/PropertiesStoreTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Properties;\n+import java.util.TimeZone;\n+\n+\/*\n+ * @test\n+ * @summary tests that the Properties.store() APIs generate output that is reproducible\n+ * @bug 8231640\n+ * @library \/test\/lib\n+ * @run driver StoreReproducibilityTest\n+ *\/\n+public class StoreReproducibilityTest {\n+\n+    private static final String ENV_SOURCE_DATE_EPOCH = \"SOURCE_DATE_EPOCH\";\n+    private static final String GMT_DATE_FORMAT = \"d MMM yyyy HH:mm:ss 'GMT'\";\n+\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ no security manager enabled\n+        testWithoutSecurityManager();\n+        \/\/ security manager enabled and security policy allows read permissions on getenv.SOURCE_DATE_EPOCH\n+        testWithSecMgrCallerHasPermission();\n+        \/\/ security manager enabled and security policy doesn't allow getenv.SOURCE_DATE_EPOCH permission\n+        testWithSecMgrCallerNotPermitted();\n+        \/\/ invalid\/unparsable value for SOURCE_DATE_EPOCH\n+        testInvalidSourceDateEpochValue();\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n+     * The launched Java program is run without any security manager\n+     *\/\n+    private static void testWithoutSecurityManager() throws Exception {\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String sourceDateEpoch = \"243535322\";\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            executeJavaProcess(processBuilder);\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n+     * The launched Java program is run with the default security manager and the launched program that\n+     * uses the Properties.store() APIs is granted a {@code read} permission on {@code getenv.SOURCE_DATE_EPOCH},\n+     * thus allowing it to see the actual value of the environment variable.\n+     *\/\n+    private static void testWithSecMgrCallerHasPermission() throws Exception {\n+        final Path policyFile = Path.of(System.getProperty(\"test.src\"),\n+                \"source-date-epoch-policy\").toAbsolutePath();\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String sourceDateEpoch = \"1234342423\";\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            executeJavaProcess(processBuilder);\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager. The launched program that\n+     * uses the Properties.store() APIs is NOT granted any permission on {@code getenv.SOURCE_DATE_EPOCH}.\n+     * It is expected and verified in this test that the absence of such a permission will cause the\n+     * date comment to be the \"current date\" instead of the date corresponding to the {@code SOURCE_DATE_EPOCH}\n+     *\/\n+    private static void testWithSecMgrCallerNotPermitted() throws Exception {\n+        final Path policyFile = Path.of(System.getProperty(\"test.src\"),\n+                \"source-date-epoch-policy-no-perm\").toAbsolutePath();\n+        final String sourceDateEpoch = \"1234342423\";\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            final Date processLaunchedAt = new Date();\n+            \/\/ launch with a second delay so that we can then verify that the date comment\n+            \/\/ written out by the program is \"after\" this date\n+            Thread.sleep(1000);\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertCurrentDate(tmpFile, processLaunchedAt);\n+        }\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an invalid value for\n+     * the {@code SOURCE_DATE_EPOCH} environment variable.\n+     * It is expected and verified in this test that such an invalid value for the environment variable\n+     * will cause the date comment to be the \"current date\". The launched program is expected to complete\n+     * without any errors.\n+     *\/\n+    private static void testInvalidSourceDateEpochValue() throws Exception {\n+        final String sourceDateEpoch = \"foo-bar\";\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            final Date processLaunchedAt = new Date();\n+            \/\/ launch with a second delay so that we can then verify that the date comment\n+            \/\/ written out by the program is \"after\" this date\n+            Thread.sleep(1000);\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertCurrentDate(tmpFile, processLaunchedAt);\n+        }\n+    }\n+\n+    \/\/ launches the java process and waits for it to exit. throws an exception if exit value is non-zero\n+    private static void executeJavaProcess(ProcessBuilder pb) throws Exception {\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+        try {\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } catch (Exception e) {\n+            outputAnalyzer.reportDiagnosticSummary();\n+            throw e;\n+        }\n+    }\n+\n+    \/\/ Properties.load() from the passed file and return the loaded Properties instance\n+    private static Properties loadProperties(final Path file) throws IOException {\n+        final Properties props = new Properties();\n+        props.load(Files.newBufferedReader(file));\n+        return props;\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} is of the expected GMT format\n+     * and the time represented by it corresponds to the passed {@code sourceEpochDate}\n+     *\/\n+    private static void assertExpectedSourceEpochDate(final Path destFile,\n+                                                      final String sourceEpochDate) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile\n+                    + \" when \" + ENV_SOURCE_DATE_EPOCH + \" was set \" +\n+                    \"(to \" + sourceEpochDate + \")\");\n+        }\n+        final Date parsedDate;\n+        try {\n+            final DateFormat df = new SimpleDateFormat(GMT_DATE_FORMAT, Locale.ROOT);\n+            df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            parsedDate = df.parse(dateComment);\n+        } catch (ParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile\n+                    + \" when \" + ENV_SOURCE_DATE_EPOCH + \" was set \" +\n+                    \"(to \" + sourceEpochDate + \")\");\n+\n+        }\n+        final long expected = Long.parseLong(sourceEpochDate) * 1000;\n+        if (parsedDate.getTime() != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" millis since epoch but found \"\n+                    + parsedDate.getTime());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} can be parsed and the time\n+     * represented by it is {@link Date#after(Date)} the passed {@code date}\n+     *\/\n+    private static void assertCurrentDate(final Path destFile, final Date date) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile);\n+        }\n+        final Date parsedDate;\n+        try {\n+            parsedDate = new SimpleDateFormat(\"EEE MMM dd hh:mm:ss zzz yyyy\").parse(dateComment);\n+        } catch (ParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile);\n+        }\n+        if (!parsedDate.after(date)) {\n+            throw new RuntimeException(\"Expected \" + parsedDate + \" to be after \" + date);\n+        }\n+    }\n+\n+    \/\/ returns the \"Nth\" comment from the file. Comment index starts from 1.\n+    private static String findNthComment(Path file, int commentIndex) throws IOException {\n+        List<String> comments = new ArrayList<>();\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    comments.add(line.substring(1));\n+                    if (comments.size() == commentIndex) {\n+                        return comments.get(commentIndex - 1);\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(final List<Path> files,\n+                                                     final String sourceDateEpoch) throws Exception {\n+        final byte[] file1Contents = Files.readAllBytes(files.get(0));\n+        for (int i = 1; i < files.size(); i++) {\n+            final byte[] otherFileContents = Files.readAllBytes(files.get(i));\n+            if (!Arrays.equals(file1Contents, otherFileContents)) {\n+                throw new RuntimeException(\"Properties.store() did not generate reproducible content when \"\n+                        + ENV_SOURCE_DATE_EPOCH + \" was set (to \" + sourceDateEpoch + \")\");\n+            }\n+        }\n+    }\n+\n+    static class StoreTest {\n+        private static final Properties propsToStore = new Properties();\n+\n+        static {\n+            propsToStore.setProperty(\"a\", \"b\");\n+        }\n+\n+        \/**\n+         * Uses Properties.store() APIs to store the properties into file\n+         *\/\n+        public static void main(final String[] args) throws Exception {\n+            final Path destFile = Path.of(args[0]);\n+            final String comment = \"some user specified comment\";\n+            if (args[1].equals(\"--use-outputstream\")) {\n+                try (var os = Files.newOutputStream(destFile)) {\n+                    propsToStore.store(os, comment);\n+                }\n+            } else {\n+                try (var br = Files.newBufferedWriter(destFile)) {\n+                    propsToStore.store(br, comment);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+grant {\n+    \/\/ Permissions needed by the launched program that uses Properties.store() APIs\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete,execute\";\n+    permission java.lang.RuntimePermission \"getenv.SOURCE_DATE_EPOCH\", \"read\";\n+};\n","filename":"test\/jdk\/java\/util\/Properties\/source-date-epoch-policy","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+grant {\n+    \/\/ We intentionally don't grant \"getenv.SOURCE_DATE_EPOCH\" permission\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete,execute\";\n+};\n","filename":"test\/jdk\/java\/util\/Properties\/source-date-epoch-policy-no-perm","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"}]}