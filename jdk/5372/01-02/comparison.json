{"files":[{"patch":"@@ -44,2 +44,7 @@\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.DateTimeException;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n@@ -170,4 +175,35 @@\n-    \/\/ cached, string representation of any Date parsed out of the SOURCE_DATE_EPOCH environment variable\n-    private static volatile String cachedDateComment;\n-    \/\/ true if SOURCE_DATE_EPOCH environment variable value has been parsed\n-    private static volatile boolean sourceDateEpochParsed;\n+    @SuppressWarnings(\"removal\")\n+    private static final class LazyDateCommentProvider {\n+        \/\/ formatter used while writing out current date. this formatter matches the format\n+        \/\/ used by java.util.Date.toString()\n+        private static final DateTimeFormatter currentDateFormatter =\n+                DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n+        private static final String cachedDateComment;\n+\n+        static {\n+            String sourceDateEpoch = System.getSecurityManager() == null\n+                                        ? System.getenv(\"SOURCE_DATE_EPOCH\")\n+                                        : AccessController.doPrivileged((PrivilegedAction<String>)\n+                                                () -> System.getenv(\"SOURCE_DATE_EPOCH\"));\n+            String dateComment = null;\n+            if (sourceDateEpoch != null) {\n+                try {\n+                    long epochSeconds = Long.parseLong(sourceDateEpoch);\n+                    dateComment = \"#\" + DateTimeFormatter.RFC_1123_DATE_TIME\n+                            .withLocale(Locale.ROOT)\n+                            .withZone(ZoneOffset.UTC)\n+                            .format(Instant.ofEpochSecond(epochSeconds));\n+                } catch (NumberFormatException | DateTimeException e) {\n+                    \/\/ ignore any value that cannot be parsed for the SOURCE_DATE_EPOCH.\n+                    \/\/ store APIs will subsequently use current date, in their date comments\n+                }\n+            }\n+            cachedDateComment = dateComment;\n+        }\n+\n+        private static String getDateComment() {\n+            return cachedDateComment != null\n+                            ? cachedDateComment\n+                            : \"#\" + currentDateFormatter.format(ZonedDateTime.now());\n+        }\n+    }\n@@ -923,1 +959,2 @@\n-        writeDateComment(bw);\n+        bw.write(LazyDateCommentProvider.getDateComment());\n+        bw.newLine();\n@@ -925,1 +962,8 @@\n-            for (Map.Entry<Object, Object> e : new TreeMap<>(map).entrySet()) {\n+            var entries = map.entrySet().toArray(new Map.Entry<?, ?>[0]);\n+            Arrays.sort(entries, new Comparator<Map.Entry<?, ?>>() {\n+                @Override\n+                public int compare(Map.Entry<?, ?> o1, Map.Entry<?, ?> o2) {\n+                    return ((String) o1.getKey()).compareTo((String) o2.getKey());\n+                }\n+            });\n+            for (Map.Entry<?, ?> e : entries) {\n@@ -940,53 +984,0 @@\n-    private static void writeDateComment(BufferedWriter bw) throws IOException {\n-        if (sourceDateEpochParsed && cachedDateComment == null) {\n-            \/\/ SOURCE_DATE_EPOCH environment variable value has already been queried previously and\n-            \/\/ the environment variable was either not set or its value couldn't be parsed to a Date.\n-            \/\/ In either case, we write out the current date in the date comment\n-            bw.write(\"#\" + new Date());\n-            bw.newLine();\n-            return;\n-        }\n-        \/\/ Either the SOURCE_DATE_EPOCH environment variable needs to be queried or we have already\n-        \/\/ queried it previously and are holding a cached string representation of that value.\n-        \/\/ In either case, we first make sure the current caller has the necessary permissions to access\n-        \/\/ that environment variable's value\n-        String sourceDateEpoch = null;\n-        try {\n-            sourceDateEpoch = System.getenv(\"SOURCE_DATE_EPOCH\");\n-        } catch (SecurityException se) {\n-            \/\/ caller code doesn't have permissions to SOURCE_DATE_EPOCH environment variable.\n-            \/\/ Use current date in comment\n-            bw.write(\"#\" + new Date());\n-            bw.newLine();\n-            return;\n-        }\n-        \/\/ caller code has permissions to the environment variable, OK to use (any parseable) value\n-        \/\/ of that environment variable in the date comment\n-        if (!sourceDateEpochParsed) {\n-            synchronized (Properties.class) {\n-                if (!sourceDateEpochParsed) {\n-                    try {\n-                        String dateComment = null;\n-                        if (sourceDateEpoch != null) {\n-                            try {\n-                                Date d = new Date(Long.parseLong(sourceDateEpoch) * 1000);\n-                                \/\/ use the same format as that of Date.toGMTString() and a neutral locale for reproducibility\n-                                DateFormat df = new SimpleDateFormat(\"d MMM yyyy HH:mm:ss 'GMT'\", Locale.ROOT);\n-                                df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                                dateComment = \"#\" + df.format(d);\n-                            } catch (NumberFormatException nfe) {\n-                                \/\/ ignore any value that cannot be parsed for the SOURCE_DATE_EPOCH.\n-                                \/\/ store APIs will subsequently use current date, in their date comments\n-                            }\n-                        }\n-                        cachedDateComment = dateComment;\n-                    } finally {\n-                        sourceDateEpochParsed = true;\n-                    }\n-                }\n-            }\n-        }\n-        bw.write(cachedDateComment != null ? cachedDateComment : \"#\" + new Date());\n-        bw.newLine();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":52,"deletions":61,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.text.DateFormat;\n@@ -34,0 +33,5 @@\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -36,0 +40,1 @@\n+import java.util.Collections;\n@@ -40,1 +45,0 @@\n-import java.util.TimeZone;\n@@ -52,1 +56,0 @@\n-    private static final String GMT_DATE_FORMAT = \"d MMM yyyy HH:mm:ss 'GMT'\";\n@@ -57,4 +60,4 @@\n-        \/\/ security manager enabled and security policy allows read permissions on getenv.SOURCE_DATE_EPOCH\n-        testWithSecMgrCallerHasPermission();\n-        \/\/ security manager enabled and security policy doesn't allow getenv.SOURCE_DATE_EPOCH permission\n-        testWithSecMgrCallerNotPermitted();\n+        \/\/ security manager enabled and security policy explicitly allows read permissions on getenv.SOURCE_DATE_EPOCH\n+        testWithSecMgrExplicitPermission();\n+        \/\/ security manager enabled and no explicit getenv.SOURCE_DATE_EPOCH permission\n+        testWithSecMgrNoSpecificPermission();\n@@ -101,0 +104,2 @@\n+     * The launched Java program is run with the default security manager and is granted\n+     * a {@code read} permission on {@code getenv.SOURCE_DATE_EPOCH}.\n@@ -105,3 +110,0 @@\n-     * The launched Java program is run with the default security manager and the launched program that\n-     * uses the Properties.store() APIs is granted a {@code read} permission on {@code getenv.SOURCE_DATE_EPOCH},\n-     * thus allowing it to see the actual value of the environment variable.\n@@ -109,3 +111,10 @@\n-    private static void testWithSecMgrCallerHasPermission() throws Exception {\n-        final Path policyFile = Path.of(System.getProperty(\"test.src\"),\n-                \"source-date-epoch-policy\").toAbsolutePath();\n+    private static void testWithSecMgrExplicitPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ explicitly grant read on SOURCE_DATE_EPOCH to verifies store() APIs work fine\n+                    permission java.lang.RuntimePermission \"getenv.SOURCE_DATE_EPOCH\", \"read\";\n+                };\n+                \"\"\"));\n@@ -138,4 +147,6 @@\n-     * The launched Java program is run with the default security manager. The launched program that\n-     * uses the Properties.store() APIs is NOT granted any permission on {@code getenv.SOURCE_DATE_EPOCH}.\n-     * It is expected and verified in this test that the absence of such a permission will cause the\n-     * date comment to be the \"current date\" instead of the date corresponding to the {@code SOURCE_DATE_EPOCH}\n+     * The launched Java program is run with the default security manager and is NOT granted\n+     * any explicit permission for {@code getenv.SOURCE_DATE_EPOCH}.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n@@ -143,3 +154,11 @@\n-    private static void testWithSecMgrCallerNotPermitted() throws Exception {\n-        final Path policyFile = Path.of(System.getProperty(\"test.src\"),\n-                \"source-date-epoch-policy-no-perm\").toAbsolutePath();\n+    private static void testWithSecMgrNoSpecificPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ no other grants, not even \"read\" on SOURCE_DATE_EPOCH. test should still\n+                    \/\/ work fine and the date comment should correspond to the value of SOURCE_DATE_EPOCH\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n@@ -147,1 +166,1 @@\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < 5; i++) {\n@@ -149,0 +168,1 @@\n+            storedFiles.add(tmpFile);\n@@ -156,4 +176,0 @@\n-            final Date processLaunchedAt = new Date();\n-            \/\/ launch with a second delay so that we can then verify that the date comment\n-            \/\/ written out by the program is \"after\" this date\n-            Thread.sleep(1000);\n@@ -161,0 +177,1 @@\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n@@ -164,1 +181,0 @@\n-            assertCurrentDate(tmpFile, processLaunchedAt);\n@@ -166,0 +182,1 @@\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n@@ -227,1 +244,1 @@\n-        final Date parsedDate;\n+        long parsedSecondsSinceEpoch;\n@@ -229,4 +246,5 @@\n-            final DateFormat df = new SimpleDateFormat(GMT_DATE_FORMAT, Locale.ROOT);\n-            df.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-            parsedDate = df.parse(dateComment);\n-        } catch (ParseException pe) {\n+            var d = DateTimeFormatter.RFC_1123_DATE_TIME\n+                    .withLocale(Locale.ROOT)\n+                    .withZone(ZoneOffset.UTC).parse(dateComment);\n+            parsedSecondsSinceEpoch = Duration.between(Instant.ofEpochSecond(0), Instant.from(d)).toSeconds();\n+        } catch (DateTimeParseException pe) {\n@@ -235,1 +253,1 @@\n-                    \"(to \" + sourceEpochDate + \")\");\n+                    \"(to \" + sourceEpochDate + \")\", pe);\n@@ -238,4 +256,4 @@\n-        final long expected = Long.parseLong(sourceEpochDate) * 1000;\n-        if (parsedDate.getTime() != expected) {\n-            throw new RuntimeException(\"Expected \" + expected + \" millis since epoch but found \"\n-                    + parsedDate.getTime());\n+        final long expected = Long.parseLong(sourceEpochDate);\n+        if (parsedSecondsSinceEpoch != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" seconds since epoch but found \"\n+                    + parsedSecondsSinceEpoch);\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":54,"deletions":36,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,28 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\n-grant {\n-    \/\/ Permissions needed by the launched program that uses Properties.store() APIs\n-    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete,execute\";\n-    permission java.lang.RuntimePermission \"getenv.SOURCE_DATE_EPOCH\", \"read\";\n-};\n","filename":"test\/jdk\/java\/util\/Properties\/source-date-epoch-policy","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\n-grant {\n-    \/\/ We intentionally don't grant \"getenv.SOURCE_DATE_EPOCH\" permission\n-    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write,delete,execute\";\n-};\n","filename":"test\/jdk\/java\/util\/Properties\/source-date-epoch-policy-no-perm","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"}]}