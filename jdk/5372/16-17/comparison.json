{"files":[{"patch":"@@ -818,2 +818,2 @@\n-     * If the {@systemProperty java.util.Properties.storeDate} is set and\n-     * is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n+     * If the {@systemProperty java.util.Properties.storeDate} is set on the command line\n+     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n@@ -845,6 +845,3 @@\n-     * @implNote This method invokes the {@link #entrySet()} method\n-     * and writes out the returned key and element pairs\n-     * in the natural sort order of those keys. If subclasses override\n-     * the {@code entrySet} method and return a different {@code Set} instance,\n-     * then the property list is written out in the iteration order of\n-     * that returned {@code Set}\n+     * @implSpec The keys and elements are written in the natural sort order\n+     * of the keys in the {@code Properties.entrySet()} unless {@code entrySet()}\n+     * is overridden by a subclass to return a different set implementation.\n@@ -927,3 +924,4 @@\n-            \/\/ entrySet() can be overridden by subclasses. Here we check to see if the returned instance is the one\n-            \/\/ returned by the Properties.entrySet() implementation.If yes, then we sort those entries\n-            \/\/ in the natural order of their key. Else we just use the iteration order of the returned instance.\n+            \/\/ entrySet() can be overridden by subclasses. Here we check to see if the returned instance type is the one\n+            \/\/ returned by the Properties.entrySet() implementation. If yes, then we sort those entries\n+            \/\/ in the natural order of their key. Else, we consider that the subclassed implementation may potentially\n+            \/\/ have returned a differently ordered entries and so we just use the iteration order of the returned instance.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"}]}