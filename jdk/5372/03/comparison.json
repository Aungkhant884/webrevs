{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,7 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.DateTimeException;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n@@ -168,0 +175,36 @@\n+    @SuppressWarnings(\"removal\")\n+    private static final class LazyDateCommentProvider {\n+        \/\/ formatter used while writing out current date. this formatter matches the format\n+        \/\/ used by java.util.Date.toString()\n+        private static final DateTimeFormatter currentDateFormatter =\n+                DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n+        private static final String cachedDateComment;\n+\n+        static {\n+            String sourceDateEpoch = System.getSecurityManager() == null\n+                                        ? System.getenv(\"SOURCE_DATE_EPOCH\")\n+                                        : AccessController.doPrivileged((PrivilegedAction<String>)\n+                                                () -> System.getenv(\"SOURCE_DATE_EPOCH\"));\n+            String dateComment = null;\n+            if (sourceDateEpoch != null) {\n+                try {\n+                    long epochSeconds = Long.parseLong(sourceDateEpoch);\n+                    dateComment = \"#\" + DateTimeFormatter.RFC_1123_DATE_TIME\n+                            .withLocale(Locale.ROOT)\n+                            .withZone(ZoneOffset.UTC)\n+                            .format(Instant.ofEpochSecond(epochSeconds));\n+                } catch (NumberFormatException | DateTimeException e) {\n+                    \/\/ ignore any value that cannot be parsed for the SOURCE_DATE_EPOCH.\n+                    \/\/ store APIs will subsequently use current date, in their date comments\n+                }\n+            }\n+            cachedDateComment = dateComment;\n+        }\n+\n+        private static String getDateComment() {\n+            return cachedDateComment != null\n+                            ? cachedDateComment\n+                            : \"#\" + currentDateFormatter.format(ZonedDateTime.now());\n+        }\n+    }\n+\n@@ -836,0 +879,9 @@\n+     * @implNote When writing the date comment, this method checks whether the\n+     * {@code SOURCE_DATE_EPOCH} environment variable is set. If it is set, then instead\n+     * of writing the current date and time, the date and time represented by the\n+     * value of {@code SOURCE_DATE_EPOCH} will be written, using the\n+     * {@link DateTimeFormatter#RFC_1123_DATE_TIME} date format with a\n+     * {@link Locale#ROOT root locale} and {@link ZoneOffset#UTC UTC zone offset}.\n+     * If the value set for {@code SOURCE_DATE_EPOCH} cannot be parsed to a {@code long},\n+     * then the current date and time will be written.\n+     *\n@@ -906,1 +958,1 @@\n-        bw.write(\"#\" + new Date().toString());\n+        bw.write(LazyDateCommentProvider.getDateComment());\n@@ -909,1 +961,8 @@\n-            for (Map.Entry<Object, Object> e : entrySet()) {\n+            var entries = map.entrySet().toArray(new Map.Entry<?, ?>[0]);\n+            Arrays.sort(entries, new Comparator<Map.Entry<?, ?>>() {\n+                @Override\n+                public int compare(Map.Entry<?, ?> o1, Map.Entry<?, ?> o2) {\n+                    return ((String) o1.getKey()).compareTo((String) o2.getKey());\n+                }\n+            });\n+            for (Map.Entry<?, ?> e : entries) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Properties.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.TreeSet;\n+\n+\/*\n+ * @test\n+ * @summary tests the order in which the Properties.store() method writes out the properties\n+ * @bug 8231640\n+ * @run testng PropertiesStoreTest\n+ *\/\n+public class PropertiesStoreTest {\n+\n+    @DataProvider(name = \"propsProvider\")\n+    private Object[][] createProps() {\n+        final Properties simple = new Properties();\n+        simple.setProperty(\"1\", \"one\");\n+        simple.setProperty(\"2\", \"two\");\n+        simple.setProperty(\"10\", \"ten\");\n+        simple.setProperty(\"02\", \"zero-two\");\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+        simple.setProperty(\"00\", \"zero-zero\");\n+        simple.setProperty(\"0\", \"zero-again\");\n+\n+        final Properties specialChars = new Properties();\n+        \/\/ some special chars\n+        simple.setProperty(\" 1\", \"space-one\");\n+        simple.setProperty(\"\\t 3 7 \\n\", \"tab-space-three-space-seven-space-newline\");\n+        \/\/ add some simple chars\n+        simple.setProperty(\"3\", \"three\");\n+        simple.setProperty(\"0\", \"zero\");\n+\n+        return new Object[][]{\n+                {simple},\n+                {specialChars}\n+        };\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(Writer, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreWriterKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that the {@link Properties#store(OutputStream, String)} API writes out the properties\n+     * in the natural order of the property keys\n+     *\/\n+    @Test(dataProvider = \"propsProvider\")\n+    public void testStoreOutputStreamKeyOrder(final Properties props) throws Exception {\n+        \/\/ Properties.store(...) to a temp file\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final OutputStream os = Files.newOutputStream(tmpFile)) {\n+            props.store(os, null);\n+        }\n+        testStoreKeyOrder(props, tmpFile);\n+    }\n+\n+    \/**\n+     * {@link Properties#load(InputStream) Loads a Properties instance} from the passed\n+     * {@code Path} and then verifies that:\n+     * - the loaded properties instance \"equals\" the passed (original) \"props\" instance\n+     * - the order in which the properties appear in the file represented by the path\n+     * is the expected natural order of the property keys.\n+     *\/\n+    private void testStoreKeyOrder(final Properties props, final Path storedProps) throws Exception {\n+        \/\/ Properties.load(...) from that stored file and verify that the loaded\n+        \/\/ Properties has expected content\n+        final Properties loaded = new Properties();\n+        try (final InputStream is = Files.newInputStream(storedProps)) {\n+            loaded.load(is);\n+        }\n+        Assert.assertEquals(loaded, props, \"Unexpected properties loaded from stored state\");\n+\n+        \/\/ now read lines from the stored file and keep track of the order in which the keys were\n+        \/\/ found in that file. Compare that order with the expected store order of the keys.\n+        final List<String> actualOrder;\n+        try (final BufferedReader reader = Files.newBufferedReader(storedProps)) {\n+            actualOrder = readInOrder(reader);\n+        }\n+        final String[] expectedOrder = expectedKeyOrder(props);\n+        Assert.assertEquals(actualOrder.size(), expectedOrder.length,\n+                \"Unexpected number of keys read from stored properties\");\n+        if (!Arrays.equals(actualOrder.toArray(new String[0]), expectedOrder)) {\n+            Assert.fail(\"Unexpected order of stored property keys. Expected order: \" + Arrays.toString(expectedOrder)\n+                    + \", found order: \" + actualOrder);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(Writer, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreWriterDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Tests that {@link Properties#store(OutputStream, String)} writes out a proper date comment\n+     *\/\n+    @Test\n+    public void testStoreOutputStreamDateComment() throws Exception {\n+        final Properties props = new Properties();\n+        props.setProperty(\"a\", \"b\");\n+        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+            props.store(writer, null);\n+        }\n+        testDateComment(tmpFile);\n+    }\n+\n+    \/**\n+     * Reads each line in the {@code file} and verifies that there is only one comment line\n+     * and that comment line can be parsed into a {@link java.util.Date}\n+     *\/\n+    private void testDateComment(Path file) throws Exception {\n+        String comment = null;\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    if (comment != null) {\n+                        Assert.fail(\"More than one comment line found in the stored properties file \" + file);\n+                    }\n+                    comment = line.substring(1);\n+                }\n+            }\n+        }\n+        if (comment == null) {\n+            Assert.fail(\"No comment line found in the stored properties file \" + file);\n+        }\n+        try {\n+            new SimpleDateFormat(\"EEE MMM dd hh:mm:ss zzz yyyy\").parse(comment);\n+        } catch (ParseException pe) {\n+            Assert.fail(\"Unexpected date comment: \" + comment);\n+        }\n+    }\n+\n+    \/\/ returns the property keys in their natural order\n+    private static String[] expectedKeyOrder(final Properties props) {\n+        return new TreeSet<>(props.stringPropertyNames()).toArray(new String[0]);\n+    }\n+\n+    \/\/ reads each non-comment line and keeps track of the order in which the property key lines\n+    \/\/ were read\n+    private static List<String> readInOrder(final BufferedReader reader) throws IOException {\n+        final List<String> readKeys = new ArrayList<>();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            final String key = line.substring(0, line.indexOf(\"=\"));\n+            \/\/ the Properties.store(...) APIs write out the keys in a specific format for certain\n+            \/\/ special characters. Our test uses some of the keys which have those special characters.\n+            \/\/ Here we handle such special character conversion (for only those characters that this test uses).\n+            \/\/ replace the backslash character followed by the t character with the tab character\n+            String replacedKey = key.replace(\"\\\\t\", \"\\t\");\n+            \/\/ replace the backslash character followed by the n character with the newline character\n+            replacedKey = replacedKey.replace(\"\\\\n\", \"\\n\");\n+            \/\/ replace backslash character followed by the space character with the space character\n+            replacedKey = replacedKey.replace(\"\\\\ \", \" \");\n+            readKeys.add(replacedKey);\n+        }\n+        return readKeys;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/PropertiesStoreTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Properties;\n+\n+\/*\n+ * @test\n+ * @summary tests that the Properties.store() APIs generate output that is reproducible\n+ * @bug 8231640\n+ * @library \/test\/lib\n+ * @run driver StoreReproducibilityTest\n+ *\/\n+public class StoreReproducibilityTest {\n+\n+    private static final String ENV_SOURCE_DATE_EPOCH = \"SOURCE_DATE_EPOCH\";\n+\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ no security manager enabled\n+        testWithoutSecurityManager();\n+        \/\/ security manager enabled and security policy explicitly allows read permissions on getenv.SOURCE_DATE_EPOCH\n+        testWithSecMgrExplicitPermission();\n+        \/\/ security manager enabled and no explicit getenv.SOURCE_DATE_EPOCH permission\n+        testWithSecMgrNoSpecificPermission();\n+        \/\/ invalid\/unparsable value for SOURCE_DATE_EPOCH\n+        testInvalidSourceDateEpochValue();\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n+     * The launched Java program is run without any security manager\n+     *\/\n+    private static void testWithoutSecurityManager() throws Exception {\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String sourceDateEpoch = \"243535322\";\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            executeJavaProcess(processBuilder);\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is granted\n+     * a {@code read} permission on {@code getenv.SOURCE_DATE_EPOCH}.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n+     *\/\n+    private static void testWithSecMgrExplicitPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ explicitly grant read on SOURCE_DATE_EPOCH to verifies store() APIs work fine\n+                    permission java.lang.RuntimePermission \"getenv.SOURCE_DATE_EPOCH\", \"read\";\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String sourceDateEpoch = \"1234342423\";\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            executeJavaProcess(processBuilder);\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an environment variable value for\n+     * {@code SOURCE_DATE_EPOCH} environment variable and the date comment written out to the file\n+     * is expected to use this value.\n+     * The launched Java program is run with the default security manager and is NOT granted\n+     * any explicit permission for {@code getenv.SOURCE_DATE_EPOCH}.\n+     * The program is launched multiple times with the same value for {@code SOURCE_DATE_EPOCH}\n+     * and the output written out by each run of this program is verified to be exactly the same.\n+     * Additionally, the date comment that's written out is verified to be the expected date that\n+     * corresponds to the passed {@code SOURCE_DATE_EPOCH}.\n+     *\/\n+    private static void testWithSecMgrNoSpecificPermission() throws Exception {\n+        final Path policyFile = Files.createTempFile(\"8231640\", \".policy\");\n+        Files.write(policyFile, Collections.singleton(\"\"\"\n+                grant {\n+                    \/\/ test writes\/stores to a file, so FilePermission\n+                    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+                    \/\/ no other grants, not even \"read\" on SOURCE_DATE_EPOCH. test should still\n+                    \/\/ work fine and the date comment should correspond to the value of SOURCE_DATE_EPOCH\n+                };\n+                \"\"\"));\n+        final List<Path> storedFiles = new ArrayList<>();\n+        final String sourceDateEpoch = \"1234342423\";\n+        for (int i = 0; i < 5; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            storedFiles.add(tmpFile);\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.policy=\" + policyFile.toString(),\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            executeJavaProcess(processBuilder);\n+            assertExpectedSourceEpochDate(tmpFile, sourceDateEpoch);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+        }\n+        assertAllFileContentsAreSame(storedFiles, sourceDateEpoch);\n+    }\n+\n+    \/**\n+     * Launches a Java program which is responsible for using Properties.store() to write out the\n+     * properties to a file. The launched Java program is passed an invalid value for\n+     * the {@code SOURCE_DATE_EPOCH} environment variable.\n+     * It is expected and verified in this test that such an invalid value for the environment variable\n+     * will cause the date comment to be the \"current date\". The launched program is expected to complete\n+     * without any errors.\n+     *\/\n+    private static void testInvalidSourceDateEpochValue() throws Exception {\n+        final String sourceDateEpoch = \"foo-bar\";\n+        for (int i = 0; i < 2; i++) {\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \".props\");\n+            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n+                    StoreTest.class.getName(),\n+                    tmpFile.toString(),\n+                    i % 2 == 0 ? \"--use-outputstream\" : \"--use-writer\");\n+            processBuilder.environment().put(ENV_SOURCE_DATE_EPOCH, sourceDateEpoch);\n+            final Date processLaunchedAt = new Date();\n+            \/\/ launch with a second delay so that we can then verify that the date comment\n+            \/\/ written out by the program is \"after\" this date\n+            Thread.sleep(1000);\n+            executeJavaProcess(processBuilder);\n+            if (!StoreTest.propsToStore.equals(loadProperties(tmpFile))) {\n+                throw new RuntimeException(\"Unexpected properties stored in \" + tmpFile);\n+            }\n+            assertCurrentDate(tmpFile, processLaunchedAt);\n+        }\n+    }\n+\n+    \/\/ launches the java process and waits for it to exit. throws an exception if exit value is non-zero\n+    private static void executeJavaProcess(ProcessBuilder pb) throws Exception {\n+        final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(pb);\n+        try {\n+            outputAnalyzer.shouldHaveExitValue(0);\n+        } catch (Exception e) {\n+            outputAnalyzer.reportDiagnosticSummary();\n+            throw e;\n+        }\n+    }\n+\n+    \/\/ Properties.load() from the passed file and return the loaded Properties instance\n+    private static Properties loadProperties(final Path file) throws IOException {\n+        final Properties props = new Properties();\n+        props.load(Files.newBufferedReader(file));\n+        return props;\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} is of the expected GMT format\n+     * and the time represented by it corresponds to the passed {@code sourceEpochDate}\n+     *\/\n+    private static void assertExpectedSourceEpochDate(final Path destFile,\n+                                                      final String sourceEpochDate) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile\n+                    + \" when \" + ENV_SOURCE_DATE_EPOCH + \" was set \" +\n+                    \"(to \" + sourceEpochDate + \")\");\n+        }\n+        long parsedSecondsSinceEpoch;\n+        try {\n+            var d = DateTimeFormatter.RFC_1123_DATE_TIME\n+                    .withLocale(Locale.ROOT)\n+                    .withZone(ZoneOffset.UTC).parse(dateComment);\n+            parsedSecondsSinceEpoch = Duration.between(Instant.ofEpochSecond(0), Instant.from(d)).toSeconds();\n+        } catch (DateTimeParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile\n+                    + \" when \" + ENV_SOURCE_DATE_EPOCH + \" was set \" +\n+                    \"(to \" + sourceEpochDate + \")\", pe);\n+\n+        }\n+        final long expected = Long.parseLong(sourceEpochDate);\n+        if (parsedSecondsSinceEpoch != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" seconds since epoch but found \"\n+                    + parsedSecondsSinceEpoch);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the date comment in the {@code destFile} can be parsed and the time\n+     * represented by it is {@link Date#after(Date)} the passed {@code date}\n+     *\/\n+    private static void assertCurrentDate(final Path destFile, final Date date) throws Exception {\n+        final String dateComment = findNthComment(destFile, 2);\n+        if (dateComment == null) {\n+            throw new RuntimeException(\"Date comment not found in stored properties \" + destFile);\n+        }\n+        final Date parsedDate;\n+        try {\n+            parsedDate = new SimpleDateFormat(\"EEE MMM dd hh:mm:ss zzz yyyy\").parse(dateComment);\n+        } catch (ParseException pe) {\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile);\n+        }\n+        if (!parsedDate.after(date)) {\n+            throw new RuntimeException(\"Expected \" + parsedDate + \" to be after \" + date);\n+        }\n+    }\n+\n+    \/\/ returns the \"Nth\" comment from the file. Comment index starts from 1.\n+    private static String findNthComment(Path file, int commentIndex) throws IOException {\n+        List<String> comments = new ArrayList<>();\n+        try (final BufferedReader reader = Files.newBufferedReader(file)) {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.startsWith(\"#\")) {\n+                    comments.add(line.substring(1));\n+                    if (comments.size() == commentIndex) {\n+                        return comments.get(commentIndex - 1);\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(final List<Path> files,\n+                                                     final String sourceDateEpoch) throws Exception {\n+        final byte[] file1Contents = Files.readAllBytes(files.get(0));\n+        for (int i = 1; i < files.size(); i++) {\n+            final byte[] otherFileContents = Files.readAllBytes(files.get(i));\n+            if (!Arrays.equals(file1Contents, otherFileContents)) {\n+                throw new RuntimeException(\"Properties.store() did not generate reproducible content when \"\n+                        + ENV_SOURCE_DATE_EPOCH + \" was set (to \" + sourceDateEpoch + \")\");\n+            }\n+        }\n+    }\n+\n+    static class StoreTest {\n+        private static final Properties propsToStore = new Properties();\n+\n+        static {\n+            propsToStore.setProperty(\"a\", \"b\");\n+        }\n+\n+        \/**\n+         * Uses Properties.store() APIs to store the properties into file\n+         *\/\n+        public static void main(final String[] args) throws Exception {\n+            final Path destFile = Path.of(args[0]);\n+            final String comment = \"some user specified comment\";\n+            if (args[1].equals(\"--use-outputstream\")) {\n+                try (var os = Files.newOutputStream(destFile)) {\n+                    propsToStore.store(os, comment);\n+                }\n+            } else {\n+                try (var br = Files.newBufferedWriter(destFile)) {\n+                    propsToStore.store(br, comment);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"}]}