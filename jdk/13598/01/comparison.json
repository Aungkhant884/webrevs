{"files":[{"patch":"@@ -53,0 +53,10 @@\n+ * <h2 id=\"constant-class-info\">The {@code CONSTANT_Class_info} Structure<\/h2>\n+ *\n+ * <p>While most appearances of {@link Class} constants are in the form of {@linkplain\n+ * #descriptorString() descriptors}, in the {@code CONSTANT_Class_info} structure\n+ * (JVMS {@jvms 4.4.1}), they appear as binary name encoded in internal forms,\n+ * such as {@code \"java\/lang\/String\"} for {@link String} class. Such forms can be\n+ * converted to ClassDesc with {@link #ofInternalName(String)} and retrieved from a\n+ * {@linkplain ClassDesc} with {@link #internalName()}. In addition, primitive types\n+ * cannot be encoded in the {@code CONSTANT_Class_info} structure.\n+ *\n@@ -85,9 +95,2 @@\n-     * Returns a {@linkplain ClassDesc} for a class or interface type,\n-     * given the name of the class or interface in internal form,\n-     * such as {@code \"java\/lang\/String\"}.\n-     *\n-     * @apiNote\n-     * To create a descriptor for an array type, either use {@link #ofDescriptor(String)}\n-     * or {@link #arrayType()}; to create a descriptor for a primitive type, use\n-     * {@link #ofDescriptor(String)} or use the predefined constants in\n-     * {@link ConstantDescs}.\n+     * {@return a {@linkplain ClassDesc} from a string representation\n+     * in a {@link ##constant-class-info CONSTANT_Class_info} structure}\n@@ -95,2 +98,2 @@\n-     * @param name the fully qualified class name, in internal (slash-separated) form\n-     * @return a {@linkplain ClassDesc} describing the desired class\n+     * @param name the class name, compliant with requirements of the\n+     * {@code CONSTANT_Class_info} structure\n@@ -100,1 +103,0 @@\n-     * @jvms 4.2.1 Binary Class and Interface Names\n@@ -103,0 +105,2 @@\n+     * @see ClassDesc#internalName()\n+     * @see <a href=\"#constant-class-info\">The {@code CONSTANT_Class_info} Structure<\/a>\n@@ -106,1 +110,8 @@\n-        ConstantUtils.validateInternalClassName(requireNonNull(name));\n+        if (name.isEmpty()) \/\/ implicit null check\n+            throw new IllegalArgumentException(\"Invalid class name: \");\n+        \/\/ Arrays\n+        if (name.charAt(0) == '[') {\n+            return ofDescriptor(name);\n+        }\n+        \/\/ Classes or Interfaces\n+        ConstantUtils.validateInternalClassName(name);\n@@ -156,1 +167,0 @@\n-     * @jvms 4.4.1 The CONSTANT_Class_info Structure\n@@ -184,1 +194,0 @@\n-     * @jvms 4.4.1 The CONSTANT_Class_info Structure\n@@ -205,1 +214,0 @@\n-     * @jvms 4.4.1 The CONSTANT_Class_info Structure\n@@ -358,0 +366,17 @@\n+    \/**\n+     * {@return the string representation of this {@linkplain ClassDesc} in a\n+     * {@link ##constant-class-info CONSTANT_Class_info} structure}\n+     *\n+     * @apiNote\n+     * In a future release, this API may return a value instead of throwing\n+     * an exception if this {@linkplain ClassDesc} becomes representable in a\n+     * {@code CONSTANT_Class_info}.\n+     *\n+     * @throws IllegalStateException if this {@linkplain ClassDesc} describes a type\n+     * that cannot be represented by a {@code CONSTANT_Class_info}, such as primitive types\n+     * @see ClassDesc#ofInternalName(String)\n+     * @see <a href=\"#constant-class-info\">The {@code CONSTANT_Class_info} Structure<\/a>\n+     * @since 21\n+     *\/\n+    String internalName();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,5 @@\n+    @Override\n+    public String internalName() {\n+        throw new IllegalStateException(\"primitive type \" + displayName() + \" cannot be encoded in CONSTANT_Class_info\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PrimitiveClassDescImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+    @Override\n+    public String internalName() {\n+        return isArray() ? descriptorString() : descriptorString().substring(1, descriptorString().length() - 1);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ReferenceClassDescImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -58,0 +53,3 @@\n+        if (!r.isPrimitive()) {\n+            assertEquals(r, ClassDesc.ofInternalName(r.internalName()));\n+        }\n@@ -67,0 +65,4 @@\n+        if (r.isClassOrInterface()) {\n+            assertEquals(r.descriptorString(), \"L\" + r.internalName() + \";\");\n+        }\n+\n@@ -71,0 +73,1 @@\n+            assertEquals(r.descriptorString(), r.internalName());\n@@ -80,0 +83,5 @@\n+\n+        if (!c.isPrimitive()) {\n+            assertEquals(c.getName(), r.internalName().replace('\/', '.')); \/\/ may be invalid in valhalla\n+            assertEquals(r, ClassDesc.ofInternalName(c.getName().replace('.', '\/')));\n+        }\n@@ -121,0 +129,2 @@\n+\n+                assertThrows(IllegalStateException.class, c::internalName);\n@@ -268,1 +278,1 @@\n-        List<String> badInternalNames = List.of(\"I;\", \"[]\", \"[Ljava\/lang\/String;\",\n+        List<String> badInternalNames = List.of(\"I;\", \"[]\", \"[Ljava.lang.String;\",\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"}]}