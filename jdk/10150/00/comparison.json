{"files":[{"patch":"@@ -210,1 +210,0 @@\n-        DIAMOND(MIN, Fragments.FeatureDiamond, DiagKind.NORMAL), \/\/ Used in Analyzer\n@@ -214,5 +213,0 @@\n-        POLY(JDK8),\n-        LAMBDA(JDK8, Fragments.FeatureLambda, DiagKind.PLURAL),\n-        DEFAULT_METHODS(JDK8, Fragments.FeatureDefaultMethods, DiagKind.PLURAL),\n-        STRICT_METHOD_CLASH_CHECK(JDK8),\n-        GRAPH_INFERENCE(JDK8), \/\/ Used in Analyzer\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2798,5 +2798,1 @@\n-        return isSubSignature(t, s, true);\n-    }\n-\n-    public boolean isSubSignature(Type t, Type s, boolean strict) {\n-        return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);\n+        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,3 +143,3 @@\n-        DIAMOND(\"diamond\", Feature.DIAMOND),\n-        LAMBDA(\"lambda\", Feature.LAMBDA),\n-        METHOD(\"method\", Feature.GRAPH_INFERENCE),\n+        DIAMOND(\"diamond\"),\n+        LAMBDA(\"lambda\"),\n+        METHOD(\"method\"),\n@@ -151,0 +151,4 @@\n+        AnalyzerMode(String opt) {\n+            this(opt, null);\n+        }\n+\n@@ -172,1 +176,1 @@\n-                if (modes.contains(\"-\" + mode.opt) || !mode.feature.allowedInSource(source)) {\n+                if (modes.contains(\"-\" + mode.opt) || (mode.feature != null && !mode.feature.allowedInSource(source))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -169,2 +169,0 @@\n-        allowPoly = Feature.POLY.allowedInSource(source);\n-        allowLambda = Feature.LAMBDA.allowedInSource(source);\n@@ -189,8 +187,0 @@\n-    \/** Switch: support target-typing inference\n-     *\/\n-    boolean allowPoly;\n-\n-    \/** Switch: support lambda expressions ?\n-     *\/\n-    boolean allowLambda;\n-\n@@ -250,1 +240,1 @@\n-        } else if (allowPoly && inferenceContext.free(found)) {\n+        } else if (inferenceContext.free(found)) {\n@@ -773,1 +763,1 @@\n-            Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));\n+            Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, methodAttrInfo));\n@@ -1986,2 +1976,1 @@\n-        tree.polyKind = (!allowPoly ||\n-                pt().hasTag(NONE) && pt() != Type.recoveryType && pt() != Infer.anyPoly ||\n+        tree.polyKind = (pt().hasTag(NONE) && pt() != Type.recoveryType && pt() != Infer.anyPoly ||\n@@ -2443,4 +2432,2 @@\n-        Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);\n-        if (allowPoly) {\n-            chk.checkType(tree, owntype, syms.throwableType);\n-        }\n+        Type owntype = attribExpr(tree.expr, env, Type.noType);\n+        chk.checkType(tree, owntype, syms.throwableType);\n@@ -4059,1 +4046,1 @@\n-        boolean isPoly = allowPoly && (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));\n+        boolean isPoly = (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2578,1 +2578,1 @@\n-                if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &&\n+                if (!types.isSubSignature(sym.type, types.memberType(site, m2)) &&\n@@ -2623,1 +2623,1 @@\n-            if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {\n+            if (!types.isSubSignature(sym.type, types.memberType(site, s))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -31,1 +30,0 @@\n-import com.sun.tools.javac.comp.Attr.CheckMode;\n@@ -92,3 +90,0 @@\n-    \/** should the graph solver be used? *\/\n-    boolean allowGraphInference;\n-\n@@ -122,3 +117,0 @@\n-        Source source = Source.instance(context);\n-        allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source)\n-                && options.isUnset(\"useLegacyInference\");\n@@ -185,1 +177,1 @@\n-            if (allowGraphInference && resultInfo != null && resultInfo.pt == anyPoly) {\n+            if (resultInfo != null && resultInfo.pt == anyPoly) {\n@@ -189,1 +181,1 @@\n-            } else if (allowGraphInference && resultInfo != null) {\n+            } else if (resultInfo != null) {\n@@ -218,6 +210,1 @@\n-            if (allowGraphInference) {\n-                inferenceContext.solve(warn);\n-            } else {\n-                inferenceContext.solveLegacy(true, warn, LegacyInferenceSteps.EQ_LOWER.steps); \/\/minimizeInst\n-            }\n-\n+            inferenceContext.solve(warn);\n@@ -226,9 +213,0 @@\n-            if (!allowGraphInference &&\n-                    inferenceContext.restvars().nonEmpty() &&\n-                    resultInfo != null &&\n-                    !warn.hasNonSilentLint(Lint.LintCategory.UNCHECKED)) {\n-                generateReturnConstraints(env.tree, resultInfo, mt, inferenceContext);\n-                inferenceContext.solveLegacy(false, warn, LegacyInferenceSteps.EQ_UPPER.steps); \/\/maximizeInst\n-                mt = (MethodType)inferenceContext.asInstType(mt);\n-            }\n-\n@@ -242,1 +220,1 @@\n-            if (resultInfo != null || !allowGraphInference) {\n+            if (resultInfo != null) {\n@@ -413,2 +391,1 @@\n-            if (needsEagerInstantiation((UndetVar)qtype, to, inferenceContext) &&\n-                    (allowGraphInference || !to.isPrimitive())) {\n+            if (needsEagerInstantiation((UndetVar)qtype, to, inferenceContext)) {\n@@ -421,2 +398,0 @@\n-        Assert.check(allowGraphInference || !rsInfoInfContext.free(to),\n-                \"legacy inference engine cannot handle constraints on both sides of a subtyping assertion\");\n@@ -425,3 +400,1 @@\n-        if (!resultInfo.checkContext.compatible(qtype, rsInfoInfContext.asUndetVar(to), retWarn) ||\n-                \/\/unchecked conversion is not allowed in source 7 mode\n-                (!allowGraphInference && retWarn.hasLint(Lint.LintCategory.UNCHECKED))) {\n+        if (!resultInfo.checkContext.compatible(qtype, rsInfoInfContext.asUndetVar(to), retWarn)) {\n@@ -619,1 +592,1 @@\n-            UndetVar uv = new UndetVar(tv, incorporationEngine(), types);\n+            UndetVar uv = new UndetVar(tv, incorporationEngine, types);\n@@ -810,22 +783,0 @@\n-    \/**\n-     * Custom check executed by the legacy incorporation engine. Newly added bounds are checked\n-     * against existing eq bounds.\n-     *\/\n-    class EqCheckLegacy extends CheckBounds {\n-        EqCheckLegacy(UndetVar uv, Type t, InferenceBound from) {\n-            super(uv, t, InferenceContext::asInstType, InferenceContext::free, from);\n-        }\n-\n-        @Override\n-        public IncorporationAction dup(UndetVar that) {\n-            return new EqCheckLegacy(that, t, from);\n-        }\n-\n-        @Override\n-        EnumSet<InferenceBound> boundsToCheck() {\n-            return (from == InferenceBound.EQ) ?\n-                            EnumSet.allOf(InferenceBound.class) :\n-                            EnumSet.of(InferenceBound.EQ);\n-        }\n-    }\n-\n@@ -1020,1 +971,1 @@\n-    abstract class AbstractIncorporationEngine implements UndetVarListener {\n+    class IncorporationEngine implements UndetVarListener {\n@@ -1033,25 +984,0 @@\n-        abstract List<IncorporationAction> getIncorporationActions(UndetVar uv, InferenceBound ib, Type t, boolean update);\n-    }\n-\n-    \/**\n-     * A legacy incorporation engine. Used for source <= 7.\n-     *\/\n-    AbstractIncorporationEngine legacyEngine = new AbstractIncorporationEngine() {\n-\n-        List<IncorporationAction> getIncorporationActions(UndetVar uv, InferenceBound ib, Type t, boolean update) {\n-            ListBuffer<IncorporationAction> actions = new ListBuffer<>();\n-            Type inst = uv.getInst();\n-            if (inst != null) {\n-                actions.add(new CheckInst(uv, ib));\n-            }\n-            actions.add(new EqCheckLegacy(uv, t, ib));\n-            return actions.toList();\n-        }\n-    };\n-\n-    \/**\n-     * The standard incorporation engine. Used for source >= 8.\n-     *\/\n-    AbstractIncorporationEngine graphEngine = new AbstractIncorporationEngine() {\n-\n-        @Override\n@@ -1078,7 +1004,0 @@\n-    };\n-\n-    \/**\n-     * Get the incorporation engine to be used in this compilation.\n-     *\/\n-    AbstractIncorporationEngine incorporationEngine() {\n-        return allowGraphInference ? graphEngine : legacyEngine;\n@@ -1087,0 +1006,2 @@\n+    IncorporationEngine incorporationEngine = new IncorporationEngine();\n+\n@@ -1359,1 +1280,1 @@\n-         * Computes a path that goes from a given node to the leafs in the graph.\n+         * Computes a path that goes from a given node to the leaves in the graph.\n@@ -1496,15 +1417,0 @@\n-        \/**\n-         * Like the former; the only difference is that this step can only be applied\n-         * if all upper bounds are ground.\n-         *\/\n-        UPPER_LEGACY(InferenceBound.UPPER) {\n-            @Override\n-            public boolean accepts(UndetVar t, InferenceContext inferenceContext) {\n-                return !inferenceContext.free(t.getBounds(ib)) && !t.isCaptured();\n-            }\n-\n-            @Override\n-            Type solve(UndetVar uv, InferenceContext inferenceContext) {\n-                return UPPER.solve(uv, inferenceContext);\n-            }\n-        },\n@@ -1564,17 +1470,0 @@\n-    \/**\n-     * This enumeration defines the sequence of steps to be applied when the\n-     * solver works in legacy mode. The steps in this enumeration reflect\n-     * the behavior of old inference routine (see JLS SE 7 15.12.2.7\/15.12.2.8).\n-     *\/\n-    enum LegacyInferenceSteps {\n-\n-        EQ_LOWER(EnumSet.of(InferenceStep.EQ, InferenceStep.LOWER)),\n-        EQ_UPPER(EnumSet.of(InferenceStep.EQ, InferenceStep.UPPER_LEGACY));\n-\n-        final EnumSet<InferenceStep> steps;\n-\n-        LegacyInferenceSteps(EnumSet<InferenceStep> steps) {\n-            this.steps = steps;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":11,"deletions":122,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -513,7 +513,0 @@\n-    \/**\n-     * Apply a set of inference steps\n-     *\/\n-    private List<Type> solveBasic(EnumSet<InferenceStep> steps) {\n-        return solveBasic(inferencevars, steps);\n-    }\n-\n@@ -535,30 +528,0 @@\n-    \/**\n-     * Instantiate inference variables in legacy mode (JLS 15.12.2.7, 15.12.2.8).\n-     * During overload resolution, instantiation is done by doing a partial\n-     * inference process using eq\/lower bound instantiation. During check,\n-     * we also instantiate any remaining vars by repeatedly using eq\/upper\n-     * instantiation, until all variables are solved.\n-     *\/\n-    public void solveLegacy(boolean partial, Warner warn, EnumSet<InferenceStep> steps) {\n-        while (true) {\n-            List<Type> solvedVars = solveBasic(steps);\n-            if (restvars().isEmpty() || partial) {\n-                \/\/all variables have been instantiated - exit\n-                break;\n-            } else if (solvedVars.isEmpty()) {\n-                \/\/some variables could not be instantiated because of cycles in\n-                \/\/upper bounds - provide a (possibly recursive) default instantiation\n-                infer.instantiateAsUninferredVars(restvars(), this);\n-                break;\n-            } else {\n-                \/\/some variables have been instantiated - replace newly instantiated\n-                \/\/variables in remaining upper bounds and continue\n-                for (Type t : undetvars) {\n-                    UndetVar uv = (UndetVar)t;\n-                    uv.substBounds(solvedVars, asInstTypes(solvedVars), types);\n-                }\n-            }\n-        }\n-        infer.doIncorporation(this, warn);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -79,3 +79,0 @@\n-    \/** Switch: is complex graph inference supported? *\/\n-    private final boolean allowGraphInference;\n-\n@@ -92,2 +89,0 @@\n-        Source source = Source.instance(context);\n-        allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source);\n@@ -674,2 +669,1 @@\n-        boolean useInstantiatedPtArgs =\n-                allowGraphInference && !types.isSignaturePolymorphic((MethodSymbol)meth.baseSymbol());\n+        boolean useInstantiatedPtArgs = !types.isSignaturePolymorphic((MethodSymbol)meth.baseSymbol());\n@@ -709,1 +703,1 @@\n-        List<Type> argtypes = erasedConstructorType != null && allowGraphInference ?\n+        List<Type> argtypes = erasedConstructorType != null ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1556,1 +1556,1 @@\n-            if (Feature.LAMBDA.allowedInSource(source) && scanner.hasLambdas) {\n+            if (scanner.hasLambdas) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2005,1 +2005,0 @@\n-        checkSourceLevel(Feature.LAMBDA);\n@@ -2141,1 +2140,0 @@\n-                checkSourceLevel(Feature.DIAMOND);\n@@ -3302,1 +3300,1 @@\n-            case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;\n+            case DEFAULT     : flag = Flags.DEFAULT; break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3014,1 +3014,0 @@\n-\n@@ -3024,9 +3023,0 @@\n-compiler.misc.feature.diamond=\\\n-    diamond operator\n-\n-compiler.misc.feature.lambda=\\\n-    lambda expressions\n-\n-compiler.misc.feature.default.methods=\\\n-    default methods\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = i -> i + i\",\n+                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = (var i) -> i + i\",\n@@ -80,1 +80,1 @@\n-                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = i -> i + i\",\n+                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = (var i) -> i + i\",\n@@ -88,1 +88,1 @@\n-                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = i -> i + i\",\n+                (a) -> assertCommandOutputContains(a, \"Function<Integer,Integer> f = (var i) -> i + i\",\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-compiler.misc.feature.default.methods                   # just preserved for testing (for now)\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ key: compiler.misc.feature.diamond\n+\/\/ key: compiler.misc.feature.case.null\n@@ -28,2 +28,0 @@\n-import java.util.ArrayList;\n-\n@@ -31,2 +29,4 @@\n-    void m() {\n-        new ArrayList<>();\n+    void m(String s) {\n+        switch (s) {\n+            case null:\n+        }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewFeatureDisabled.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ key: compiler.misc.feature.lambda\n+\/\/ key: compiler.misc.feature.var.syntax.in.implicit.lambda\n@@ -28,0 +28,2 @@\n+import java.util.function.Function;\n+\n@@ -30,1 +32,1 @@\n-        Runnable r = () -> {};\n+        Function<String, String> f = (var s) -> s;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewFeatureDisabledPlural.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\/\/key: compiler.warn.preview.feature.use\n@@ -26,2 +25,1 @@\n-\/\/key: compiler.misc.feature.diamond\n-\/\/key: compiler.misc.feature.lambda\n+\/\/key: compiler.misc.feature.var.syntax.in.implicit.lambda\n@@ -30,1 +28,1 @@\n-import java.util.ArrayList;\n+import java.util.function.Function;\n@@ -34,2 +32,1 @@\n-        new ArrayList<>();\n-        Runnable r = () -> {};\n+        Function<String, String> f = (var s) -> s;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewFeatureUse.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.function.Function;\n@@ -32,1 +31,1 @@\n-    List<String> ls = new ArrayList<>();\n+    Function<String, String> f = (var s) -> s;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewFilename.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-\/\/ key: compiler.warn.preview.feature.use\n-\/\/ key: compiler.misc.feature.diamond\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.var.syntax.in.implicit.lambda\n@@ -29,1 +29,1 @@\n-import java.util.ArrayList;\n+import java.util.function.Function;\n@@ -33,2 +33,2 @@\n-        new ArrayList<>();\n-        new ArrayList<>();\n+        Function<String, String> f = (var s) -> s;\n+        Function<String, String> j = (var s) -> s;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewFilenameAdditional.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-        new ArrayList<>();\n+        record R() {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewPlural\/PreviewPlural.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    Runnable r = () -> {};\n+    record R() {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PreviewPlural\/PreviewPluralBar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    Runnable r = () -> {};\n+    record R() {}\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Bar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}