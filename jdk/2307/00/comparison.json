{"files":[{"patch":"@@ -42,2 +42,2 @@\n-    private static final ThreadLocal<BufferReference[]> CACHE =\n-        new ThreadLocal<BufferReference[]>() {\n+    private static final ThreadLocal<WeakReference<ByteBuffer[]>> CACHE =\n+        new ThreadLocal<WeakReference<ByteBuffer[]>>() {\n@@ -45,1 +45,1 @@\n-            protected BufferReference[] initialValue() {\n+            protected WeakReference<ByteBuffer[]> initialValue() {\n@@ -47,1 +47,1 @@\n-                return new BufferReference[MAX_CACHED_BUFFERS + 1];\n+                return new WeakReference<>(new ByteBuffer[MAX_CACHED_BUFFERS + 1]);\n@@ -52,1 +52,1 @@\n-        return ByteBuffer.allocateDirect((int)((size + 0xFFF) & ~0xFFF));\n+        return ByteBuffer.allocateDirect((int) ((size + 0xFFF) & ~0xFFF));\n@@ -65,1 +65,1 @@\n-            BufferReference[] cache = CACHE.get();\n+            ByteBuffer[] cachedBuffers = getCachedBuffers();\n@@ -70,1 +70,1 @@\n-                BufferReference reference = cache[i];\n+                ByteBuffer buffer = cachedBuffers[i];\n@@ -72,9 +72,5 @@\n-                if (reference != null) {\n-                    ByteBuffer buffer = reference.get();\n-\n-                    if (buffer != null && size <= buffer.capacity()) {\n-                        cache[i] = null;\n-                        result = buffer;\n-                        result.rewind();\n-                        break;\n-                    }\n+                if (buffer != null && size <= buffer.capacity()) {\n+                    cachedBuffers[i] = null;\n+                    result = buffer;\n+                    result.rewind();\n+                    break;\n@@ -89,1 +85,1 @@\n-        result.limit((int)size);\n+        result.limit((int) size);\n@@ -94,0 +90,19 @@\n+    private static ByteBuffer[] getCachedBuffers() {\n+        WeakReference<ByteBuffer[]> cache = CACHE.get();\n+        ByteBuffer[] cachedBuffers;\n+\n+        if (cache == null) {\n+            cachedBuffers = new ByteBuffer[MAX_CACHED_BUFFERS + 1];\n+            cache = new WeakReference<>(cachedBuffers);\n+            CACHE.set(cache);\n+        } else {\n+            cachedBuffers = cache.get();\n+            if (cachedBuffers == null) {\n+                cachedBuffers = new ByteBuffer[MAX_CACHED_BUFFERS + 1];\n+                cache = new WeakReference<>(cachedBuffers);\n+                CACHE.set(cache);\n+            }\n+        }\n+        return cachedBuffers;\n+    }\n+\n@@ -99,9 +114,1 @@\n-        BufferReference[] cache = CACHE.get();\n-\n-        \/\/ expunge cleared BufferRef(s)\n-        for (int i = 0; i < MAX_CACHED_BUFFERS; i++) {\n-            BufferReference reference = cache[i];\n-            if (reference != null && reference.get() == null) {\n-                cache[i] = null;\n-            }\n-        }\n+        ByteBuffer[] cachedBuffers = getCachedBuffers();\n@@ -110,2 +117,2 @@\n-        cache[MAX_CACHED_BUFFERS] = new BufferReference(buffer);\n-        Arrays.sort(cache, DECREASING_CAPACITY_NULLS_LAST);\n+        cachedBuffers[MAX_CACHED_BUFFERS] = buffer;\n+        Arrays.sort(cachedBuffers, DECREASING_CAPACITY_NULLS_LAST);\n@@ -113,1 +120,1 @@\n-        cache[MAX_CACHED_BUFFERS] = null;\n+        cachedBuffers[MAX_CACHED_BUFFERS] = null;\n@@ -116,19 +123,8 @@\n-    private static Comparator<BufferReference> DECREASING_CAPACITY_NULLS_LAST =\n-        new Comparator<BufferReference>() {\n-            @Override\n-            public int compare(BufferReference br1, BufferReference br2) {\n-                return Integer.compare(br2 == null ? 0 : br2.capacity,\n-                                       br1 == null ? 0 : br1.capacity);\n-            }\n-        };\n-\n-    private static class BufferReference extends WeakReference<ByteBuffer> {\n-        \/\/ saved capacity so that DECREASING_CAPACITY_NULLS_LAST comparator\n-        \/\/ is stable in the presence of GC clearing the WeakReference concurrently\n-        final int capacity;\n-\n-        BufferReference(ByteBuffer buffer) {\n-            super(buffer);\n-            capacity = buffer.capacity();\n-        }\n-    }\n+    private static final Comparator<ByteBuffer> DECREASING_CAPACITY_NULLS_LAST =\n+            new Comparator<ByteBuffer>() {\n+                @Override\n+                public int compare(ByteBuffer br1, ByteBuffer br2) {\n+                    return Integer.compare(br2 == null ? 0 : br2.capacity(),\n+                            br1 == null ? 0 : br1.capacity());\n+                }\n+            };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageBufferCache.java","additions":44,"deletions":48,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/*\n+* @test\n+* @bug 8260621\n+* @summary Bug 4083270: ThreadLocal memory leak in ImageBufferCache\n+* @run main\/othervm -Xmx32m -XX:MaxMetaspaceSize=32m Bug8260621Test\n+* @author Bo Zhang\n+*\/\n+\n+public class Bug8260621Test {\n+    public static void main(String[] args) throws IOException, ClassNotFoundException {\n+        Map<String, String> map = new HashMap<>();\n+        map.put(\"java.home\", System.getProperty(\"java.home\"));\n+        for (int i = 0; i < 1000; ++i) {\n+            try (FileSystem fs = FileSystems.newFileSystem(URI.create(\"jrt:\/\"), map)) {\n+                Path path = fs.getPath(\"modules\");\n+                try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n+                    stream.forEach(it -> {\n+                    });\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/Bug8260621Test.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}