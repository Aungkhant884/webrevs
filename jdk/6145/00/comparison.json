{"files":[{"patch":"@@ -2561,0 +2561,8 @@\n+      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n+                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        int vopc = VectorNode::opcode(opc, bt);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorCastNode::make(vopc, in, bt, vlen);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -227,0 +227,8 @@\n+  case Op_ConvI2F:\n+    return Op_VectorCastI2X;\n+  case Op_ConvL2D:\n+    return Op_VectorCastL2X;\n+  case Op_ConvF2I:\n+    return Op_VectorCastF2X;\n+  case Op_ConvD2L:\n+    return Op_VectorCastD2X;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+      test_conv_i2f(a1, b1);\n+      test_conv_f2i(a1, b1);\n@@ -341,0 +343,66 @@\n+      \/\/ Reset to test conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = (int)i;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)i);\n+      }\n+      \/\/ Reset to test conversion from float to int.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = (float)(i+1);\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (i+1));\n+      }\n+      \/\/ Reset to test NAN conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Integer.MIN_VALUE;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)Integer.MIN_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Integer.MAX_VALUE;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)Integer.MAX_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.NaN;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.NaN);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.POSITIVE_INFINITY;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.POSITIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.NEGATIVE_INFINITY;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.NEGATIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = 0.0f;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)0.0);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = -0.0f;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)(-0.0));\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_i2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_i2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_f2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2i: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_i2f(int[] a, float[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float)a[i];\n+    }\n+  }\n+  static void test_conv_f2i(int[] a, float[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n@@ -568,1 +658,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntFloatVect.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+      test_conv_l2d(a1, b1);\n+      test_conv_d2l(a1, b1);\n@@ -341,0 +343,66 @@\n+      \/\/ Reset to test conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = (long)i;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)i);\n+      }\n+      \/\/ Reset to test conversion from float to int.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = (double)(i+1);\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)(i+1));\n+      }\n+      \/\/ Reset to test special conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.NaN;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.NaN);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Long.MIN_VALUE;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)Long.MIN_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Long.MAX_VALUE;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)Long.MAX_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.POSITIVE_INFINITY;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.POSITIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.NEGATIVE_INFINITY;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.NEGATIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = 0.0;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)0.0);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = -0.0;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)(-0.0));\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_l2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_d2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2l: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_l2d(long[] a, double[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double)a[i];\n+    }\n+  }\n+  static void test_conv_d2l(long[] a, double[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (long)b[i];\n+    }\n+  }\n@@ -568,1 +658,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongDoubleVect.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,28 @@\n+    @Benchmark\n+    public void convert_i2f() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_f2i() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_l2d() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_d2l() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) doubles[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}