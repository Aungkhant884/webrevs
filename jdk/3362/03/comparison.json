{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -81,1 +82,1 @@\n-  entry->set_pd_set(NULL);\n+  entry->release_set_pd_set(NULL);\n@@ -86,1 +87,0 @@\n-\n@@ -92,3 +92,3 @@\n-  while (entry->pd_set() != NULL) {\n-    ProtectionDomainEntry* to_delete = entry->pd_set();\n-    entry->set_pd_set(to_delete->next());\n+  while (entry->pd_set_acquire() != NULL) {\n+    ProtectionDomainEntry* to_delete = entry->pd_set_acquire();\n+    entry->release_set_pd_set(to_delete->next_acquire());\n@@ -144,0 +144,8 @@\n+\/\/ Reading the pd_set on each DictionaryEntry is lock free and cannot safepoint.\n+\/\/ Adding and deleting entries is under the SystemDictionary_lock\n+\/\/ Deleting unloaded entries on ClassLoaderData for dictionaries that are not unloaded\n+\/\/ is a three step process:\n+\/\/     moving the entries to a separate list, handshake to wait for\n+\/\/     readers to complete (see NSV here), and then actually deleting the entries.\n+\/\/ Deleting entries is done by the ServiceThread when triggered by class unloading.\n+\n@@ -145,0 +153,4 @@\n+  assert(Thread::current()->is_Java_thread() || SafepointSynchronize::is_at_safepoint(),\n+         \"can only be called by a JavaThread or at safepoint\");\n+  \/\/ This cannot safepoint while reading the protection domain set.\n+  NoSafepointVerifier nsv;\n@@ -147,1 +159,0 @@\n-    MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n@@ -150,1 +161,1 @@\n-    for (ProtectionDomainEntry* current = pd_set();\n+    for (ProtectionDomainEntry* current = pd_set_acquire();\n@@ -152,1 +163,1 @@\n-                                current = current->next()) {\n+                                current = current->next_acquire()) {\n@@ -170,4 +181,1 @@\n-  \/\/ Lock the pd_set list.  This lock cannot safepoint since the caller holds\n-  \/\/ a Dictionary entry, which can be moved if the Dictionary is resized.\n-  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n-  for (ProtectionDomainEntry* current = pd_set();\n+  for (ProtectionDomainEntry* current = pd_set_acquire();\n@@ -175,1 +183,1 @@\n-                              current = current->next()) {\n+                              current = current->next_acquire()) {\n@@ -183,1 +191,0 @@\n-\n@@ -188,6 +195,3 @@\n-    \/\/ The pd_set in the dictionary entry is protected by a low level lock.\n-    \/\/ With concurrent PD table cleanup, these links could be broken.\n-    MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n-    ProtectionDomainEntry* new_head =\n-                new ProtectionDomainEntry(entry, pd_set());\n-    set_pd_set(new_head);\n+    \/\/ Additions and deletions hold the SystemDictionary_lock, readers are lock-free\n+    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(entry, _pd_set);\n+    release_set_pd_set(new_head);\n@@ -423,2 +427,3 @@\n-void Dictionary::clean_cached_protection_domains() {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n+void Dictionary::clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list) {\n+  assert(Thread::current()->is_Java_thread(), \"only called by JavaThread\");\n+  assert_lock_strong(SystemDictionary_lock);\n@@ -438,2 +443,1 @@\n-      MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n-      ProtectionDomainEntry* current = probe->pd_set();\n+      ProtectionDomainEntry* current = probe->pd_set_acquire();\n@@ -453,2 +457,2 @@\n-          if (probe->pd_set() == current) {\n-            probe->set_pd_set(current->next());\n+          if (probe->pd_set_acquire() == current) {\n+            probe->release_set_pd_set(current->next_acquire());\n@@ -457,1 +461,1 @@\n-            prev->set_next(current->next());\n+            prev->release_set_next(current->next_acquire());\n@@ -459,3 +463,4 @@\n-          ProtectionDomainEntry* to_delete = current;\n-          current = current->next();\n-          delete to_delete;\n+          \/\/ Mark current for deletion but in the meantime it can still be\n+          \/\/ traversed.\n+          delete_list->push(current);\n+          current = current->next_acquire();\n@@ -464,1 +469,1 @@\n-          current = current->next();\n+          current = current->next_acquire();\n@@ -555,2 +560,2 @@\n-  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n-  for (ProtectionDomainEntry* current = pd_set(); \/\/ accessed at a safepoint\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called as safepoint\");\n+  for (ProtectionDomainEntry* current = pd_set_acquire(); \/\/ accessed at a safepoint\n@@ -558,2 +563,2 @@\n-                              current = current->_next) {\n-    guarantee(oopDesc::is_oop_or_null(current->_pd_cache->object_no_keepalive()), \"Invalid oop\");\n+                              current = current->next_acquire()) {\n+    guarantee(oopDesc::is_oop_or_null(current->object_no_keepalive()), \"Invalid oop\");\n@@ -564,1 +569,1 @@\n-  MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n@@ -566,1 +571,1 @@\n-  for (ProtectionDomainEntry* current = pd_set();  \/\/ accessed inside SD lock\n+  for (ProtectionDomainEntry* current = pd_set_acquire();\n@@ -568,1 +573,1 @@\n-                              current = current->_next) {\n+                              current = current->next_acquire()) {\n@@ -599,0 +604,2 @@\n+        st->print(\", \");\n+        probe->print_count(st);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":45,"deletions":38,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+template <typename T> class GrowableArray;\n@@ -70,1 +71,1 @@\n-  void clean_cached_protection_domains();\n+  void clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list);\n@@ -114,4 +115,0 @@\n-  \/\/ This protection domain set is a set of tuples:\n-  \/\/\n-  \/\/ (InstanceKlass C, initiating class loader ICL, Protection Domain PD)\n-  \/\/\n@@ -121,5 +118,2 @@\n-  \/\/ If such an entry (C, ICL, PD) exists in the table, it means that\n-  \/\/ it is okay for a class Foo to reference C, where\n-  \/\/\n-  \/\/    Foo.protection_domain() == PD, and\n-  \/\/    Foo's defining class loader == ICL\n+  \/\/ If an entry for PD exists in the list, it means that\n+  \/\/ it is okay for a caller class to reference the class in this dictionary entry.\n@@ -150,2 +144,2 @@\n-  ProtectionDomainEntry* pd_set() const            { return _pd_set; }\n-  void set_pd_set(ProtectionDomainEntry* new_head) {  _pd_set = new_head; }\n+  ProtectionDomainEntry* pd_set_acquire() const            { return Atomic::load_acquire(&_pd_set); }\n+  void release_set_pd_set(ProtectionDomainEntry* entry)    { Atomic::release_store(&_pd_set, entry); }\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -61,0 +63,5 @@\n+  GrowableArray<ProtectionDomainEntry*>* _delete_list;\n+ public:\n+  CleanProtectionDomainEntries(GrowableArray<ProtectionDomainEntry*>* delete_list) :\n+                               _delete_list(delete_list) {}\n+\n@@ -64,1 +71,1 @@\n-      dictionary->clean_cached_protection_domains();\n+      dictionary->clean_cached_protection_domains(_delete_list);\n@@ -69,0 +76,32 @@\n+static GrowableArray<ProtectionDomainEntry*>* _delete_list = NULL;\n+\n+class HandshakeForPD : public HandshakeClosure {\n+ public:\n+  HandshakeForPD() : HandshakeClosure(\"HandshakeForPD\") {}\n+\n+  void do_thread(Thread* thread) {\n+    log_trace(protectiondomain)(\"HandshakeForPD::do_thread: thread=\"\n+                                INTPTR_FORMAT, p2i(thread));\n+  }\n+};\n+\n+static void purge_deleted_entries() {\n+  \/\/ If there are any deleted entries, Handshake-all then they'll be\n+  \/\/ safe to remove since traversing the pd_set list does not stop for\n+  \/\/ safepoints and only JavaThreads will read the pd_set.\n+  \/\/ This is actually quite rare because the protection domain is generally associated\n+  \/\/ with the caller class and class loader, which if still alive will keep this\n+  \/\/ protection domain entry alive.\n+  if (_delete_list->length() >= 10) {\n+    HandshakeForPD hs_pd;\n+    Handshake::execute(&hs_pd);\n+\n+    for (int i = _delete_list->length() - 1; i >= 0; i--) {\n+      ProtectionDomainEntry* entry = _delete_list->at(i);\n+      _delete_list->remove_at(i);\n+      delete entry;\n+    }\n+    assert(_delete_list->length() == 0, \"should be cleared\");\n+  }\n+}\n+\n@@ -73,0 +112,6 @@\n+  \/\/ Create a list for holding deleted entries\n+  if (_delete_list == NULL) {\n+    _delete_list = new (ResourceObj::C_HEAP, mtClass)\n+                       GrowableArray<ProtectionDomainEntry*>(20, mtClass);\n+  }\n+\n@@ -80,1 +125,1 @@\n-    CleanProtectionDomainEntries clean;\n+    CleanProtectionDomainEntries clean(_delete_list);\n@@ -84,0 +129,3 @@\n+  \/\/ Purge any deleted entries outside of the SystemDictionary_lock.\n+  purge_deleted_entries();\n+\n@@ -132,4 +180,0 @@\n-oop ProtectionDomainEntry::object() {\n-  return _pd_cache->object();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"memory\/iterator.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -65,2 +65,0 @@\n-  friend class VMStructs;\n-private:\n@@ -107,0 +105,1 @@\n+\/\/ This describes the linked list protection domain for each DictionaryEntry in pd_set.\n@@ -108,3 +107,0 @@\n-  friend class VMStructs;\n- public:\n-  ProtectionDomainEntry* _next;\n@@ -112,0 +108,2 @@\n+  ProtectionDomainEntry* volatile _next;\n+ public:\n@@ -113,4 +111,2 @@\n-  ProtectionDomainEntry(ProtectionDomainCacheEntry* pd_cache, ProtectionDomainEntry* next) {\n-    _pd_cache = pd_cache;\n-    _next     = next;\n-  }\n+  ProtectionDomainEntry(ProtectionDomainCacheEntry* pd_cache,\n+                        ProtectionDomainEntry* head) : _pd_cache(pd_cache), _next(head) {}\n@@ -118,3 +114,2 @@\n-  ProtectionDomainEntry* next() { return _next; }\n-  void set_next(ProtectionDomainEntry* entry) { _next = entry; }\n-  oop object();\n+  ProtectionDomainEntry* next_acquire() { return Atomic::load_acquire(&_next); }\n+  void release_set_next(ProtectionDomainEntry* entry) { Atomic::release_store(&_next, entry); }\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.hpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-Mutex*   ProtectionDomainSet_lock     = NULL;\n@@ -264,1 +263,0 @@\n-  def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-extern Mutex*   ProtectionDomainSet_lock;        \/\/ a lock on the pd_set list in the system dictionary\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-            \/\/ class_loader = URLClassLoader, protection_domain = ClassForName.getProtectionDomain()\n+            \/\/ class_loader = App$ClassLoader, protection_domain = ClassForName.getProtectionDomain()\n","filename":"test\/hotspot\/jtreg\/runtime\/Dictionary\/ClassForName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,3 @@\n-            loadAndRun(jarFilePath);\n+            for (int i = 0; i < 20; i++) {\n+                loadAndRun(jarFilePath);\n+            }\n@@ -104,1 +106,1 @@\n-                                      \"-Xlog:gc+verify,protectiondomain=debug\",\n+                                      \"-Xlog:gc+verify,protectiondomain=trace\",\n@@ -109,0 +111,1 @@\n+        output.shouldContain(\"HandshakeForPD::do_thread\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Dictionary\/ProtectionDomainCacheTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n- *\n@@ -48,0 +47,8 @@\n+ *\n+ * To see code that takes more time to safepoint run with:\n+ * main\/othervm -XX:+SafepointTimeout -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnSafepointTimeout\n+ *                   -XX:SafepointTimeoutDelay=500\n+ *                   -XX:+PrintSystemDictionaryAtExit\n+ *                   -Xlog:gc,safepoint\n+ *                   vm.mlvm.mixed.stress.java.findDeadlock.INDIFY_Test\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/mixed\/stress\/java\/findDeadlock\/TestDescription.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-    public boolean quiet = false;\n+    public boolean quiet = true;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/tools\/Indify.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}