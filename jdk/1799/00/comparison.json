{"files":[{"patch":"@@ -37,1 +37,0 @@\n-#include \"utilities\/vmError.hpp\"\n@@ -271,34 +270,1 @@\n-\n-\/\/ simple test for SafeFetch32\n-static void test_safefetch32() {\n-  if (CanUseSafeFetch32()) {\n-    int dummy = 17;\n-    int* const p_invalid = (int*) VMError::get_segfault_address();\n-    int* const p_valid = &dummy;\n-    int result_invalid = SafeFetch32(p_invalid, 0xABC);\n-    assert(result_invalid == 0xABC, \"SafeFetch32 error\");\n-    int result_valid = SafeFetch32(p_valid, 0xABC);\n-    assert(result_valid == 17, \"SafeFetch32 error\");\n-  }\n-}\n-\n-\/\/ simple test for SafeFetchN\n-static void test_safefetchN() {\n-  if (CanUseSafeFetchN()) {\n-#ifdef _LP64\n-    const intptr_t v1 = UCONST64(0xABCD00000000ABCD);\n-    const intptr_t v2 = UCONST64(0xDEFD00000000DEFD);\n-#else\n-    const intptr_t v1 = 0xABCDABCD;\n-    const intptr_t v2 = 0xDEFDDEFD;\n-#endif\n-    intptr_t dummy = v1;\n-    intptr_t* const p_invalid = (intptr_t*) VMError::get_segfault_address();\n-    intptr_t* const p_valid = &dummy;\n-    intptr_t result_invalid = SafeFetchN(p_invalid, v2);\n-    assert(result_invalid == v2, \"SafeFetchN error\");\n-    intptr_t result_valid = SafeFetchN(p_valid, v2);\n-    assert(result_valid == v1, \"SafeFetchN error\");\n-  }\n-}\n-#endif\n+#endif \/\/ ASSERT\n@@ -396,7 +362,0 @@\n-  \/\/ test safefetch routines\n-  \/\/ Not on Windows 32bit until 8074860 is fixed\n-#if ! (defined(_WIN32) && defined(_M_IX86))\n-  test_safefetch32();\n-  test_safefetchN();\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -71,11 +71,0 @@\n-\/\/ returns an address which is guaranteed to generate a SIGSEGV on read,\n-\/\/ for test purposes, which is not NULL and contains bits in every word\n-void* VMError::get_segfault_address() {\n-  return (void*)\n-#ifdef _LP64\n-    0xABC0000000000ABCULL;\n-#else\n-    0x00000ABC;\n-#endif\n-}\n-\n@@ -493,1 +482,1 @@\n-        int* const invalid_pointer = (int*) get_segfault_address();\n+        int* const invalid_pointer = (int*)segfault_address;\n@@ -1763,1 +1752,1 @@\n-  char* const crash_addr = (char*) VMError::get_segfault_address();\n+  char* const crash_addr = (char*)VMError::segfault_address;\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -188,3 +188,4 @@\n-  \/\/ returns an address which is guaranteed to generate a SIGSEGV on read,\n-  \/\/ for test purposes, which is not NULL and contains bits in every word\n-  static void* get_segfault_address();\n+  \/\/ Address which is guaranteed to generate a fault on read, for test purposes,\n+  \/\/ which is not NULL and contains bits in every word.\n+  static const intptr_t segfault_address = LP64_ONLY(0xABC0000000000ABCULL) NOT_LP64(0x00000ABC);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -34,1 +35,7 @@\n-static intptr_t* invalid_address = (intptr_t*)(intptr_t) NOT_AIX(os::min_page_size()) AIX_ONLY(-1);\n+static intptr_t* invalid_address = (intptr_t*)VMError::segfault_address;\n+\n+TEST_VM(os, safefetch_can_use) {\n+  \/\/ Once VM initialization is through,\n+  \/\/ safefetch should work on every platform.\n+  ASSERT_TRUE(CanUseSafeFetch32());\n+}\n@@ -42,2 +49,0 @@\n-#ifndef _WIN32\n-\/\/ Needs JDK-8185734 to be solved\n@@ -50,1 +55,0 @@\n-#endif \/\/ _WIN32\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}