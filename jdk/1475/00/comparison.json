{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-    \/\/ We don't use format().\n-    format_width       =  0\n+    \/\/ Must be at least 1 for RelocInfo::narrow_oop_in_const.\n+    format_width       =  1\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.vm.ci.aarch64.AArch64;\n@@ -30,0 +31,1 @@\n+import jdk.vm.ci.code.test.aarch64.AArch64TestAssembler;\n@@ -31,0 +33,1 @@\n+import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n@@ -47,0 +50,2 @@\n+    private static final boolean DEBUG = false;\n+\n@@ -71,0 +76,2 @@\n+        } else if (arch instanceof AArch64) {\n+            return new AArch64TestAssembler(codeCache, config);\n@@ -98,0 +105,5 @@\n+            if (DEBUG) {\n+                String str = ((HotSpotCodeCacheProvider) codeCache).disassemble(installed);\n+                System.out.println(str);\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -34,0 +34,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -35,1 +36,1 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/DataPatchTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -34,0 +34,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -35,1 +36,1 @@\n- * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/InterpreterFrameSizeTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -35,0 +35,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -36,1 +37,1 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/MaxOopMapStackOffsetTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -35,0 +35,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -36,1 +37,1 @@\n- * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -34,0 +34,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -35,1 +36,1 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -34,0 +34,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -35,1 +36,1 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n@@ -34,0 +34,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.aarch64\n@@ -35,1 +36,1 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,537 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.code.test.aarch64;\n+\n+import jdk.vm.ci.aarch64.AArch64;\n+import jdk.vm.ci.aarch64.AArch64Kind;\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CodeCacheProvider;\n+import jdk.vm.ci.code.DebugInfo;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterValue;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.site.ConstantReference;\n+import jdk.vm.ci.code.site.DataSectionReference;\n+import jdk.vm.ci.code.test.TestAssembler;\n+import jdk.vm.ci.code.test.TestHotSpotVMConfig;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.hotspot.HotSpotConstant;\n+import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.VMConstant;\n+\n+public class AArch64TestAssembler extends TestAssembler {\n+\n+    private static final Register scratchRegister = AArch64.rscratch1;\n+    private static final Register doubleScratch = AArch64.v9;\n+\n+    public AArch64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {\n+        super(codeCache, config,\n+              16 \/* initialFrameSize *\/, 16 \/* stackAlignment *\/,\n+              AArch64Kind.DWORD \/* narrowOopKind *\/,\n+              \/* registers *\/\n+              AArch64.r0, AArch64.r1, AArch64.r2, AArch64.r3,\n+              AArch64.r4, AArch64.r5, AArch64.r6, AArch64.r7);\n+    }\n+\n+    private static int f(int val, int msb, int lsb) {\n+        int nbits = msb - lsb + 1;\n+        assert val >= 0;\n+        assert val < (1 << nbits);\n+        assert msb >= lsb;\n+        return val << lsb;\n+    }\n+\n+    private static int f(Register r, int msb, int lsb) {\n+        assert msb - lsb == 4;\n+        return f(r.encoding, msb, lsb);\n+    }\n+\n+    private void emitNop() {\n+        code.emitInt(0xd503201f);\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rn, Register Rm) {\n+        \/\/ ADD (shifted register)\n+        code.emitInt(f(0b10001011000, 31, 21)\n+                     | f(Rm, 20, 16)\n+                     | f(0, 15, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADD (immediate)\n+        code.emitInt(f(0b1001000100, 31, 22)\n+                     | f(imm12, 21, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitSub(Register Rd, Register Rn, int imm12) {\n+        \/\/ SUB (immediate)\n+        code.emitInt(f(0b1101000100, 31, 22)\n+                     | f(imm12, 21, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitSub(Register Rd, Register Rn, Register Rm) {\n+        \/\/ SUB (extended register)\n+        code.emitInt(f(0b11001011001, 31, 21)\n+                     | f(Rm, 20, 16)\n+                     | f(0b011000, 15, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitMov(Register Rd, Register Rm) {\n+        \/\/ MOV (register)\n+        code.emitInt(f(0b10101010000, 31, 21)\n+                     | f(Rm, 20, 16)\n+                     | f(0, 15, 10)\n+                     | f(AArch64.zr, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitMovz(Register Rd, int imm16, int shift) {\n+        \/\/ MOVZ\n+        int hw = 0;\n+        switch (shift) {\n+            case 0:  hw = 0; break;\n+            case 16: hw = 1; break;\n+            case 32: hw = 2; break;\n+            case 48: hw = 3; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(0b110100101, 31, 23)\n+                     | f(hw, 22, 21)\n+                     | f(imm16, 20, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitMovk(Register Rd, int imm16, int shift) {\n+        \/\/ MOVK\n+        int hw = 0;\n+        switch (shift) {\n+            case 0:  hw = 0; break;\n+            case 16: hw = 1; break;\n+            case 32: hw = 2; break;\n+            case 48: hw = 3; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(0b111100101, 31, 23)\n+                     | f(hw, 22, 21)\n+                     | f(imm16, 20, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitShiftLeft(Register Rd, Register Rn, int shift) {\n+        \/\/ LSL (immediate)\n+        code.emitInt(f(0b1101001101, 31, 22)\n+                     | f(-shift & 0b111111, 21, 16)\n+                     | f(63 - shift, 15, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    private void emitLoadRegister(Register Rt, AArch64Kind kind, int offset) {\n+        \/\/ LDR (literal)\n+        int opc = 0;\n+        switch (kind) {\n+            case DWORD: opc = 0; break;\n+            case QWORD: opc = 1; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(opc, 31, 30)\n+                     | f(0b011000, 29, 24)\n+                     | f(offset, 23, 5)\n+                     | f(Rt, 4, 0));\n+    }\n+\n+    private void emitLoadRegister(Register Rt, AArch64Kind kind, Register Rn, int offset) {\n+        \/\/ LDR (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        switch (kind) {\n+            case DWORD: size = 0b10; break;\n+            case QWORD: size = 0b11; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(size, 31, 30)\n+                     | f(0b11100101, 29, 22)\n+                     | f(offset >> size, 21, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rt, 4, 0));\n+    }\n+\n+    private void emitStoreRegister(Register Rt, AArch64Kind kind, Register Rn, int offset) {\n+        \/\/ STR (immediate)\n+        assert offset >= 0;\n+        int size = 0, fp = 0;\n+        switch (kind) {\n+            case DWORD: size = 0b10; fp = 0; break;\n+            case QWORD: size = 0b11; fp = 0; break;\n+            case SINGLE: size = 0b10; fp = 1; break;\n+            case DOUBLE: size = 0b11; fp = 1; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(size, 31, 30)\n+                     | f(0b111, 29, 27)\n+                     | f(fp, 26, 26)\n+                     | f(0b0100, 25, 22)\n+                     | f(offset >> size, 21, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rt, 4, 0));\n+    }\n+\n+    private void emitBlr(Register Rn) {\n+        \/\/ BLR\n+        code.emitInt(f(0b1101011000111111000000, 31, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(0, 4, 0));\n+    }\n+\n+    private void emitFmov(Register Rd, AArch64Kind kind, Register Rn) {\n+        \/\/ FMOV (general)\n+        int ftype = 0, sf = 0;\n+        switch (kind) {\n+            case SINGLE: sf = 0; ftype = 0b00; break;\n+            case DOUBLE: sf = 1; ftype = 0b01; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(sf, 31, 31)\n+                     | f(0b0011110, 30, 24)\n+                     | f(ftype, 23, 22)\n+                     | f(0b100111, 21, 16)\n+                     | f(0, 15, 10)\n+                     | f(Rn, 9, 5)\n+                     | f(Rd, 4, 0));\n+    }\n+\n+    @Override\n+    public void emitGrowStack(int size) {\n+        assert size % 16 == 0;\n+        if (size > -4096 && size < 0) {\n+            emitAdd(AArch64.sp, AArch64.sp, -size);\n+        } else if (size == 0) {\n+            \/\/ No-op\n+        } else if (size < 4096) {\n+            emitSub(AArch64.sp, AArch64.sp, size);\n+        } else if (size < 65535) {\n+            emitMovz(scratchRegister, size & 0xffff, 0);\n+            emitMovk(scratchRegister, (size >> 16) & 0xffff, 16);\n+            emitSub(AArch64.sp, AArch64.sp, scratchRegister);\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    @Override\n+    public void emitPrologue() {\n+        \/\/ Must be patchable by NativeJump::patch_verified_entry\n+        emitNop();\n+        code.emitInt(0xa9be7bfd);  \/\/ stp x29, x30, [sp, #-32]!\n+        code.emitInt(0x910003fd);  \/\/ mov x29, sp\n+\n+        setDeoptRescueSlot(newStackSlot(AArch64Kind.QWORD));\n+    }\n+\n+    @Override\n+    public void emitEpilogue() {\n+        recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);\n+        recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 5, true, null);\n+        code.emitInt(0x94000000);  \/\/ bl <imm26>\n+    }\n+\n+    @Override\n+    public void emitCallPrologue(CallingConvention cc, Object... prim) {\n+        emitGrowStack(cc.getStackSize());\n+        frameSize += cc.getStackSize();\n+        AllocatableValue[] args = cc.getArguments();\n+        for (int i = 0; i < args.length; i++) {\n+            emitLoad(args[i], prim[i]);\n+        }\n+    }\n+\n+    @Override\n+    public void emitCallEpilogue(CallingConvention cc) {\n+        emitGrowStack(-cc.getStackSize());\n+        frameSize -= cc.getStackSize();\n+    }\n+\n+    @Override\n+    public void emitCall(long addr) {\n+        emitLoadLong(scratchRegister, addr);\n+        emitBlr(scratchRegister);\n+    }\n+\n+    @Override\n+    public void emitLoad(AllocatableValue av, Object prim) {\n+        if (av instanceof RegisterValue) {\n+            Register reg = ((RegisterValue) av).getRegister();\n+            if (prim instanceof Float) {\n+                emitLoadFloat(reg, (Float) prim);\n+            } else if (prim instanceof Double) {\n+                emitLoadDouble(reg, (Double) prim);\n+            } else if (prim instanceof Integer) {\n+                emitLoadInt(reg, (Integer) prim);\n+            } else if (prim instanceof Long) {\n+                emitLoadLong(reg, (Long) prim);\n+            }\n+        } else if (av instanceof StackSlot) {\n+            StackSlot slot = (StackSlot) av;\n+            if (prim instanceof Float) {\n+                emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));\n+            } else if (prim instanceof Double) {\n+                emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));\n+            } else if (prim instanceof Integer) {\n+                emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));\n+            } else if (prim instanceof Long) {\n+                emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));\n+            } else {\n+                assert false : \"Unimplemented\";\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown value \" + av);\n+        }\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(HotSpotConstant c) {\n+        recordDataPatchInCode(new ConstantReference((VMConstant) c));\n+\n+        Register ret = newRegister();\n+        if (c.isCompressed()) {\n+            \/\/ Set upper 16 bits first. See MacroAssembler::patch_oop().\n+            emitMovz(ret, 0xdead, 16);\n+            emitMovk(ret, 0xdead, 0);\n+        } else {\n+            \/\/ 48-bit VA\n+            emitMovz(ret, 0xdead, 0);\n+            emitMovk(ret, 0xdead, 16);\n+            emitMovk(ret, 0xdead, 32);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(Register b, int offset) {\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, AArch64Kind.QWORD, b, offset);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadNarrowPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, AArch64Kind.DWORD, 0xdead);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, AArch64Kind.QWORD, 0xdead);\n+        return ret;\n+    }\n+\n+    private Register emitLoadDouble(Register reg, double c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitDouble(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitLoadRegister(scratchRegister, AArch64Kind.QWORD, 0xdead);\n+        emitFmov(reg, AArch64Kind.DOUBLE, scratchRegister);\n+        return reg;\n+    }\n+\n+    private Register emitLoadFloat(Register reg, float c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitFloat(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitLoadRegister(scratchRegister, AArch64Kind.DWORD, 0xdead);\n+        emitFmov(reg, AArch64Kind.SINGLE, scratchRegister);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadFloat(float c) {\n+        Register ret = AArch64.v0;\n+        return emitLoadFloat(ret, c);\n+    }\n+\n+    private Register emitLoadLong(Register reg, long c) {\n+        emitMovz(reg, (int)(c & 0xffff), 0);\n+        emitMovk(reg, (int)((c >> 16) & 0xffff), 16);\n+        emitMovk(reg, (int)((c >> 32) & 0xffff), 32);\n+        emitMovk(reg, (int)((c >> 48) & 0xffff), 48);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadLong(long c) {\n+        Register ret = newRegister();\n+        return emitLoadLong(ret, c);\n+    }\n+\n+    private Register emitLoadInt(Register reg, int c) {\n+        emitMovz(reg, (int)(c & 0xffff), 0);\n+        emitMovk(reg, (int)((c >> 16) & 0xffff), 16);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadInt(int c) {\n+        Register ret = newRegister();\n+        return emitLoadInt(ret, c);\n+    }\n+\n+    @Override\n+    public Register emitIntArg0() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(0);\n+    }\n+\n+    @Override\n+    public Register emitIntArg1() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(1);\n+    }\n+\n+    @Override\n+    public Register emitIntAdd(Register a, Register b) {\n+        emitAdd(a, a, b);\n+        return a;\n+    }\n+\n+    @Override\n+    public void emitTrap(DebugInfo info) {\n+        \/\/ Dereference null pointer\n+        emitMovz(scratchRegister, 0, 0);\n+        recordImplicitException(info);\n+        emitLoadRegister(AArch64.zr, AArch64Kind.QWORD, scratchRegister, 0);\n+    }\n+\n+    @Override\n+    public void emitIntRet(Register a) {\n+        emitMov(AArch64.r0, a);\n+        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n+        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0xd65f03c0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitFloatRet(Register a) {\n+        assert a == AArch64.v0 : \"Unimplemented move \" + a;\n+        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n+        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0xd65f03c0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitPointerRet(Register a) {\n+        emitIntRet(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitPointerToStack(Register a) {\n+        return emitLongToStack(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitNarrowPointerToStack(Register a) {\n+        return emitIntToStack(a);\n+    }\n+\n+    @Override\n+    public Register emitUncompressPointer(Register compressed, long base, int shift) {\n+        if (shift > 0) {\n+            emitShiftLeft(compressed, compressed, shift);\n+        }\n+\n+        if (base != 0) {\n+            emitLoadLong(scratchRegister, base);\n+            emitAdd(compressed, compressed, scratchRegister);\n+        }\n+\n+        return compressed;\n+    }\n+\n+    private StackSlot emitDoubleToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, AArch64Kind.DOUBLE, AArch64.sp, slot.getOffset(frameSize));\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitDoubleToStack(Register a) {\n+        StackSlot ret = newStackSlot(AArch64Kind.DOUBLE);\n+        return emitDoubleToStack(ret, a);\n+    }\n+\n+    private StackSlot emitFloatToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, AArch64Kind.SINGLE, AArch64.sp, slot.getOffset(frameSize));\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitFloatToStack(Register a) {\n+        StackSlot ret = newStackSlot(AArch64Kind.SINGLE);\n+        return emitFloatToStack(ret, a);\n+    }\n+\n+    private StackSlot emitIntToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, AArch64Kind.DWORD, AArch64.sp, slot.getOffset(frameSize));\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitIntToStack(Register a) {\n+        StackSlot ret = newStackSlot(AArch64Kind.DWORD);\n+        return emitIntToStack(ret, a);\n+    }\n+\n+    private StackSlot emitLongToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, AArch64Kind.QWORD, AArch64.sp, slot.getOffset(frameSize));\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitLongToStack(Register a) {\n+        StackSlot ret = newStackSlot(AArch64Kind.QWORD);\n+        return emitLongToStack(ret, a);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":537,"deletions":0,"binary":false,"changes":537,"status":"added"}]}