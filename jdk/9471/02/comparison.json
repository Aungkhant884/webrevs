{"files":[{"patch":"@@ -59,1 +59,1 @@\n-double G1MMUTracker::calculate_gc_time(double current_time) {\n+double G1MMUTracker::calculate_gc_time(double current_timestamp) {\n@@ -61,1 +61,1 @@\n-  double limit = current_time - _time_slice;\n+  double limit = timestamp - _time_slice;\n@@ -114,2 +114,2 @@\n-double G1MMUTracker::when_sec(double current_time, double pause_time) {\n-  \/\/ if the pause is over the maximum, just assume that it's the maximum\n+double G1MMUTracker::when_sec(double current_timestamp, double pause_time) {\n+  \/\/ If the pause is over the maximum, just assume that it's the maximum.\n@@ -118,5 +118,10 @@\n-  double earliest_end = current_time + adjusted_pause_time;\n-  double limit = earliest_end - _time_slice;\n-  double gc_time = calculate_gc_time(earliest_end);\n-  double diff = gc_time + adjusted_pause_time - max_gc_time();\n-  if (is_double_leq_0(diff))\n+\n+  \/\/ Earliest end time of a hypothetical pause starting now, taking pause_time.\n+  double earliest_end_time = current_timestamp + adjusted_pause_time;\n+  double gc_time_in_recent_time_slice = calculate_gc_time(earliest_end_time) + adjusted_pause_time;\n+\n+  \/\/ How much gc time is needed to pass within the MMU window to fit the given pause into the MMU.\n+  double gc_time_to_pass = gc_time_in_recent_time_slice - max_gc_time();\n+\n+  \/\/ If that time to pass is zero or negative we could start the pause immediately.\n+  if (is_double_leq_0(gc_time_to_pass)) {\n@@ -124,0 +129,1 @@\n+  }\n@@ -125,0 +131,2 @@\n+  \/\/ Trivially, if the pause is of maximum pause time, the required delay is what the MMU dictates by\n+  \/\/ the time slice and maximum gc pause, counted from the end of the last pause.\n@@ -127,1 +135,1 @@\n-    return elem->end_time() - limit;\n+    return (elem->end_time() + (_time_slice - max_gc_time())) - current_timestamp;\n@@ -130,0 +138,2 @@\n+  \/\/ Now go through the recent pause time events,\n+  double limit = earliest_end_time - _time_slice;\n@@ -134,6 +144,8 @@\n-      if (elem->start_time() > limit)\n-        diff -= elem->duration();\n-      else\n-        diff -= elem->end_time() - limit;\n-      if (is_double_leq_0(diff))\n-        return elem->end_time() + diff - limit;\n+      if (elem->start_time() > limit) {\n+        gc_time_to_pass -= elem->duration();\n+      } else {\n+        gc_time_to_pass -= elem->end_time() - limit;\n+      }\n+      if (is_double_leq_0(gc_time_to_pass)) {\n+        return elem->end_time() + (_time_slice + gc_time_to_pass) - earliest_end_time;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.cpp","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -103,1 +103,3 @@\n-  double calculate_gc_time(double current_time);\n+  \/\/ Returns the amount of time spent in gc pauses in the time slice before the\n+  \/\/ given timestamp.\n+  double calculate_gc_time(double current_timestamp);\n@@ -110,1 +112,3 @@\n-  double when_sec(double current_time, double pause_time);\n+  \/\/ Distance to the earliest possible GC pause of length pause_time from\n+  \/\/ current_timestamp without violating the MMU constraint.\n+  double when_sec(double current_timestamp, double pause_time);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MMUTracker.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}