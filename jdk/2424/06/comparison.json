{"files":[{"patch":"@@ -76,0 +76,1 @@\n+    public static final int IO_REPARSE_TAG_AF_UNIX              = 0x80000023;\n@@ -110,0 +111,1 @@\n+    public static final int ERROR_CANT_ACCESS_FILE      = 1920;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,0 +434,4 @@\n+    boolean isUnixDomainSocket() {\n+        return reparseTag == IO_REPARSE_TAG_AF_UNIX;\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,0 +142,6 @@\n+        \/\/ if source is a Unix domain socket, we don't want to copy it for various\n+        \/\/ reasons including consistency with Unix\n+        if (sourceAttrs.isUnixDomainSocket()) {\n+            throw new IOException(\"Can not copy socket file\");\n+        }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileCopy.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -337,0 +337,7 @@\n+            try {\n+                if (exc.lastError() == ERROR_CANT_ACCESS_FILE && isUnixDomainSocket(file)) {\n+                    \/\/ socket file is accessible\n+                    return;\n+                }\n+            } catch (WindowsException ignore) {}\n+\n@@ -349,0 +356,5 @@\n+    private static boolean isUnixDomainSocket(WindowsPath path) throws WindowsException {\n+        WindowsFileAttributes attrs = WindowsFileAttributes.get(path, false);\n+        return attrs.isUnixDomainSocket();\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -834,0 +834,17 @@\n+        try {\n+            return openFileForReadAttributeAccess(flags);\n+        } catch (WindowsException e) {\n+            if (!followLinks || e.lastError() != ERROR_CANT_ACCESS_FILE)\n+                throw e;\n+            \/\/ Object could be a Unix domain socket\n+            try {\n+                return openSocketForReadAttributeAccess();\n+            } catch (WindowsException ignore) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private long openFileForReadAttributeAccess(int flags)\n+        throws WindowsException\n+    {\n@@ -835,5 +852,29 @@\n-                          FILE_READ_ATTRIBUTES,\n-                          (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE),\n-                          0L,\n-                          OPEN_EXISTING,\n-                          flags);\n+                            FILE_READ_ATTRIBUTES,\n+                            (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE),\n+                            0L,\n+                            OPEN_EXISTING,\n+                            flags);\n+    }\n+\n+    \/**\n+     * Returns a handle to the file if it is a socket.\n+     * Throws WindowsException if file is not a socket\n+     *\/\n+    private long openSocketForReadAttributeAccess()\n+        throws WindowsException\n+    {\n+        \/\/ needs to specify FILE_FLAG_OPEN_REPARSE_POINT if the file is a socket\n+        int flags = FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT;\n+\n+        long handle = openFileForReadAttributeAccess(flags);\n+\n+        try {\n+            WindowsFileAttributes attrs = WindowsFileAttributes.readAttributes(handle);\n+            if (!attrs.isUnixDomainSocket()) {\n+                throw new WindowsException(\"not a socket\");\n+            }\n+            return handle;\n+        } catch (WindowsException e) {\n+            CloseHandle(handle);\n+            throw e;\n+        }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsPath.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include <Winioctl.h>\n@@ -190,0 +191,54 @@\n+\/**\n+ * path is likely to be a Unix domain socket.\n+ * Verify and if it is return its attributes\n+ *\/\n+static DWORD getFinalAttributesUnixSocket(const WCHAR *path)\n+{\n+    DWORD result;\n+    BY_HANDLE_FILE_INFORMATION finfo;\n+    REPARSE_GUID_DATA_BUFFER reparse;\n+\n+    HANDLE h = CreateFileW(path,\n+                           FILE_READ_ATTRIBUTES,\n+                           FILE_SHARE_DELETE |\n+                               FILE_SHARE_READ | FILE_SHARE_WRITE,\n+                           NULL,\n+                           OPEN_EXISTING,\n+                           FILE_FLAG_BACKUP_SEMANTICS |\n+                               FILE_FLAG_OPEN_REPARSE_POINT,\n+                           NULL);\n+\n+    if (h == INVALID_HANDLE_VALUE)\n+        return INVALID_FILE_ATTRIBUTES;\n+\n+\n+    if (!GetFileInformationByHandle(h, &finfo)) {\n+        DWORD error = GetLastError();\n+        if (CloseHandle(h)) {\n+            SetLastError(error);\n+        }\n+        return INVALID_FILE_ATTRIBUTES;\n+    }\n+\n+    if ((finfo.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == 0) {\n+        CloseHandle(h);\n+        return INVALID_FILE_ATTRIBUTES;\n+    }\n+\n+    \/* check the reparse tag *\/\n+\n+    if (DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, &reparse,\n+                (DWORD)sizeof(reparse), &result, NULL) == 0) {\n+        CloseHandle(h);\n+        return INVALID_FILE_ATTRIBUTES;\n+    }\n+\n+    if (reparse.ReparseTag != IO_REPARSE_TAG_AF_UNIX) {\n+        CloseHandle(h);\n+        return INVALID_FILE_ATTRIBUTES;\n+    }\n+\n+    CloseHandle(h);\n+    return finfo.dwFileAttributes;\n+}\n+\n@@ -220,0 +275,5 @@\n+        if (attr == INVALID_FILE_ATTRIBUTES) {\n+            if (GetLastError() == ERROR_CANT_ACCESS_FILE) {\n+                attr = getFinalAttributesUnixSocket(path);\n+            }\n+        }\n","filename":"src\/java.base\/windows\/native\/libjava\/WinNTFileSystem_md.c","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -95,10 +95,1 @@\n-\n-    \/* Check for build 18362 or newer, due to Windows bug described in 8259014 *\/\n-\n-    OSVERSIONINFOEXW osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };\n-    DWORDLONG cond_mask = 0;\n-\n-    VER_SET_CONDITION(cond_mask, VER_BUILDNUMBER, VER_GREATER_EQUAL);\n-    osvi.dwBuildNumber  = 18362; \/\/ Windows 10 (1903) or newer\n-\n-    return VerifyVersionInfoW(&osvi, VER_BUILDNUMBER, cond_mask) != 0;\n+    return JNI_TRUE;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8252971\n+ * @library \/test\/lib\n+ * @run testng FileAttributes\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+import org.testng.SkipException;\n+\n+import static java.net.StandardProtocolFamily.UNIX;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+\/**\n+ *\/\n+public class FileAttributes {\n+\n+    @Test\n+    public static void test() throws Exception {\n+        checkSupported();\n+        Path path = null;\n+        try (var chan = SocketChannel.open(UNIX)) {\n+            path = Path.of(\"foo.sock\");\n+            var addr = UnixDomainSocketAddress.of(path);\n+\n+            chan.bind(addr);\n+\n+            \/\/ Check file exists\n+\n+            File f = path.toFile();\n+            assertTrue(f.exists(), \"File.exists failed\");\n+\n+            assertTrue(Files.exists(path), \"Files.exists failed\");\n+\n+            \/\/ Check basic attributes\n+            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n+\n+            assertFalse(attrs.isDirectory(), \"file is not a directory\");\n+            assertTrue(attrs.isOther(), \"file is other\");\n+            assertFalse(attrs.isRegularFile(), \"file is not a regular file\");\n+            assertFalse(attrs.isSymbolicLink(), \"file is not a symbolic link\");\n+\n+            \/\/ Check can't copy\n+            final Path src = path;\n+            final Path dest = Path.of(\"bar.sock\");\n+            assertThrows(IOException.class, () -> Files.copy(src, dest));\n+\n+            \/\/ Check deletion\n+            assertTrue(f.delete(), \"File.delete failed\");\n+        } finally {\n+            Files.deleteIfExists(path);\n+        }\n+    }\n+\n+    static void checkSupported() {\n+        try {\n+            SocketChannel.open(UNIX).close();\n+        } catch (UnsupportedOperationException e) {\n+            throw new SkipException(\"Unix domain channels not supported\");\n+        } catch (Exception e) {\n+            \/\/ continue test to see what problem is\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/FileAttributes.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}