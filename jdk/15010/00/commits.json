[{"commit":{"message":"8312570: [TESTBUG] Jtreg compiler\/loopopts\/superword\/TestDependencyOffsets.java fails on 512-bit SVE\n\nHotspot jtreg `compiler\/loopopts\/superword\/TestDependencyOffsets.java`\nfails on AArch64 CPUs with 512-bit SVE. The reason is that many test\nloops in the code cannot be vectorized due to data dependence but IR\ntests assume they can.\n\nOn AArch64, these IR tests just check the CPU feature of `asimd` and\nincorrectly assumes AArch64 vectors are at most 256 bits. But actually,\n`asimd` on AArch64 only represents NEON vectors which are at most 128\nbits. AArch64 CPUs may have another feature of `sve` which represents\nscalable vectors of at most 2048 bits. The vectorization won't succeed\non 512-bit SVE CPUs if the memory offset between some read and write is\nless than 512 bits.\n\nAs this jtreg is auto-generated by a python script, we have updated the\nscript and re-generated this jtreg. In this new version, we checked the\nauto-vectorization on both NEON-only and NEON+SVE platforms. Below is\nthe diff of the generator script. We have also attached the new script\nto the JBS page.\n\n```\n@@ -321,7 +321,8 @@ class Type:\n            p.append(Platform(\"avx512\", [\"avx512\", \"true\"], 64))\n         else:\n            assert False, \"type not implemented\" + self.name\n-        p.append(Platform(\"asimd\", [\"asimd\", \"true\"], 32))\n+        p.append(Platform(\"asimd\", [\"asimd\", \"true\", \"sve\", \"false\"], 16))\n+        p.append(Platform(\"sve\", [\"sve\", \"true\"], 256))\n         return p\n\n class Test:\n@@ -457,7 +458,7 @@ class Generator:\n         lines.append(\" *   and various MaxVectorSize values, and +- AlignVector.\")\n         lines.append(\" *\")\n         lines.append(\" * Note: this test is auto-generated. Please modify \/ generate with script:\")\n-        lines.append(\" *       https:\/\/bugs.openjdk.org\/browse\/JDK-8308606\")\n+        lines.append(\" *       https:\/\/bugs.openjdk.org\/browse\/JDK-8312570\")\n         lines.append(\" *\")\n         lines.append(\" * Types: \" + \", \".join([t.name for t in self.types]))\n         lines.append(\" * Offsets: \" + \", \".join([str(o) for o in self.offsets]))\n@@ -598,7 +599,8 @@ class Generator:\n             # IR rules\n             for p in test.t.platforms():\n                 elements = p.vector_width \/\/ test.t.size\n-                lines.append(f\"    \/\/ CPU: {p.name} -> vector_width: {p.vector_width} -> elements in vector: {elements}\")\n+                max_pre = \"max \" if p.name == \"sve\" else \"\"\n+                lines.append(f\"    \/\/ CPU: {p.name} -> {max_pre}vector_width: {p.vector_width} -> {max_pre}elements in vector: {elements}\")\n                 ###############  -AlignVector\n                 rule = PlatformIRRule(p)\n                 rule.add_pre_constraint(\"AlignVector\", IRBool.makeFalse())\n@@ -694,8 +696,8 @@ class Generator:\n def main():\n     g = Generator()\n     g.generate(\"TestDependencyOffsets\",\n-               \"\/home\/emanuel\/Documents\/fork7-jdk\/open\/test\/hotspot\/jtreg\/compiler\/loopopts\/superword\",\n-               \"8298935 8308606\", # Big ID\n+               \"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\",\n+               \"8298935 8308606 8312570\", # Bug ID\n                \"compiler.loopopts.superword\", # package\n     )\n```\n\nWe tested this on various of AArch64 CPUs."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java"}],"sha":"b62ade2b1231d21512897592ee50f4e07695189f"}]