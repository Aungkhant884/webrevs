{"files":[{"patch":"@@ -1724,2 +1724,5 @@\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n-    st->print(\"pacia  lr, rfp\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n+    st->print(\"ldr  rscratch1, [rthread, #%d]\\n\\t\", in_bytes(JavaThread::cont_entry_offset()));\n+    st->print(\"sub  rscratch1, sp, rscratch1\\n\\t\");\n+    st->print(\"sub  rscratch1, rscratch1, 2 * wordSize\\n\\t\");\n+    st->print(\"pacia  lr, rscratch1\\n\\t\");\n@@ -1854,2 +1857,5 @@\n-    st->print(\"autia lr, rfp\\n\\t\");\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"ldr  rscratch1, [rthread, #%d]\\n\\t\", in_bytes(JavaThread::cont_entry_offset()));\n+    st->print(\"sub  rscratch1, sp, rscratch1\\n\\t\");\n+    st->print(\"sub  rscratch1, rscratch1, 2 * wordSize\\n\\t\");\n+    st->print(\"autia  lr, rscratch1\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-    __ authenticate_return_address(exception_pc, rscratch1);\n+    __ authenticate_return_address(exception_pc, rscratch1, rfp);\n@@ -437,1 +437,1 @@\n-  __ protect_return_address(exception_pc, rscratch1);\n+  __ protect_return_address(exception_pc, rscratch1, rfp);\n@@ -453,1 +453,1 @@\n-  __ protect_return_address(r0, rscratch1);\n+  __ protect_return_address(r0, rscratch1, rfp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  address sender_pc = (address) *(sender_sp-1);\n+  address sender_pc = ContinuationHelper::return_address_at(sender_sp - 1, false \/* on_heap *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,12 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  \/\/ Skip PAC authentication for return address at frames on the heap.\n+  return on_heap ? pauth_strip_pointer(*(address*)sp)\n+                 : pauth_strip_verifiable(*(address*)sp, sp - 1, JavaThread::current());\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  \/\/ Skip PAC signing for return address at frames on the heap.\n+  *(address*)sp = on_heap ? pc\n+                          : pauth_sign_return_address(pc, sp - 1, JavaThread::current());\n+}\n+\n@@ -83,1 +95,1 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(sp - frame::sender_sp_ret_address_offset(), f.is_heap_frame());\n@@ -111,0 +123,1 @@\n+  \/\/ Always used in assertions. Just strip it.\n@@ -112,1 +125,1 @@\n-  return *pc_addr;\n+  return pauth_strip_pointer(*pc_addr);\n@@ -117,1 +130,3 @@\n-  *pc_addr = pc;\n+  \/\/ Skip PAC signing for frames on the heap.\n+  *pc_addr = f.is_heap_frame() ? pc\n+                               : pauth_sign_return_address(pc, f.sp() - 2, JavaThread::current());\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n-\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], this->fp(), thread);\n@@ -161,1 +160,3 @@\n-      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n+      \/\/ Note: PAC authentication may fail in case broken frame is passed in.\n+      \/\/ Just strip it for now.\n+      sender_pc = pauth_strip_pointer((address) *(sender_sp - 1));\n@@ -279,3 +280,2 @@\n-  address signing_sp = (((address*) sp())[-2]);\n-  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n-  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n+  address signed_pc = pauth_sign_return_address(pc, sp() - 2, JavaThread::cast(thread));\n+  address pc_old = pauth_strip_verifiable(*pc_addr, sp() - 2, JavaThread::cast(thread));\n@@ -476,1 +476,1 @@\n-  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), this->fp(), map->thread());\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -154,1 +154,5 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, sp, *(intptr_t**)(sp - frame::sender_sp_offset), *(address*)(sp - 1)) {}\n+inline frame::frame(intptr_t* sp)\n+  : frame(sp,\n+          sp,\n+          *(intptr_t**)(sp - frame::sender_sp_offset),\n+          pauth_strip_verifiable(*(address*)(sp - 1), sp - 2, JavaThread::current())) {}\n@@ -420,1 +424,1 @@\n-  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp - 1), l_sender_sp - 2, map->thread());\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5942,1 +5942,1 @@\n-void MacroAssembler::enter(bool strip_ret_addr) {\n+void MacroAssembler::enter(bool strip_ret_addr, Register thread) {\n@@ -5948,1 +5948,1 @@\n-  protect_return_address();\n+  protect_return_address(thread);\n@@ -5953,1 +5953,1 @@\n-void MacroAssembler::leave() {\n+void MacroAssembler::leave(Register thread) {\n@@ -5956,1 +5956,1 @@\n-  authenticate_return_address();\n+  authenticate_return_address(thread);\n@@ -5966,1 +5966,22 @@\n-\/\/ Uses the FP as the modifier.\n+\/\/ Uses relative SP as the modifier.\n+\/\/ Note that relative SP = signing SP - initial SP, where\n+\/\/   signing SP is the lowest address of the frame record where LR is saved, and\n+\/\/   initial SP is thread->last_continuation()->entry_sp().\n+\/\/\n+\/\/                  |          |\n+\/\/                  |==========|\n+\/\/                  |          |  \/\/ Continuation.run\n+\/\/                  |          |\n+\/\/                  |==========|\\\n+\/\/                  |          | | ContinuationEntry          Address\n+\/\/                  |          | |                             high\n+\/\/  initial SP ---> |==========|\/                                |\n+\/\/                  |          |                                 |\n+\/\/                  | ...      |                                \\|\/\n+\/\/                  |          |                                low\n+\/\/                  |==========|\\\n+\/\/                  |  LR      | |\n+\/\/                  |  FP      | | frame record\n+\/\/  signing SP ---> |----------|\/\n+\/\/                  |          |\n+\/\/                  |          |\n@@ -5968,1 +5989,3 @@\n-void MacroAssembler::protect_return_address() {\n+\/\/ Note that initial SP is zero for non-virtual thread.\n+\/\/\n+void MacroAssembler::protect_return_address(Register thread) {\n@@ -5971,4 +5994,9 @@\n-    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n-    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n-    \/\/ match, so instead explicitly use the FP.\n-    pacia(lr, rfp);\n+    if (thread == noreg) {\n+      paciasp();\n+    } else {\n+      stp(rscratch1, zr, Address(pre(sp, -2 * wordSize)));\n+      ldr(rscratch1, Address(thread, JavaThread::cont_entry_offset()));\n+      sub(rscratch1, sp, rscratch1);\n+      pacia(lr, rscratch1);\n+      ldp(rscratch1, zr, Address(post(sp, 2 * wordSize)));\n+    }\n@@ -5980,2 +6008,2 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses relative SP as the modifier.\n+\/\/ Note that signing SP = base + offset.\n@@ -5983,1 +6011,1 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::protect_return_address(Register return_reg, Register tmp, Register base, int offset) {\n@@ -5985,1 +6013,0 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n@@ -5987,2 +6014,4 @@\n-    ldr(temp_reg, Address(rfp));\n-    pacia(return_reg, temp_reg);\n+    ldr(tmp, Address(rthread, JavaThread::cont_entry_offset()));\n+    sub(tmp, base, tmp);\n+    add(tmp, tmp, offset);\n+    pacia(return_reg, tmp);\n@@ -5993,0 +6022,5 @@\n+\/\/ Uses relative SP as the modifier.\n+\/\/ Note that relative SP = signing SP - initial SP, where\n+\/\/   signing SP is the lowest address of the frame record where LR is saved, and\n+\/\/   initial SP is thread->last_continuation()->entry_sp().\n+\/\/ Note that initial SP is zero for non-virtual thread.\n@@ -5994,1 +6028,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg) {\n+void MacroAssembler::authenticate_return_address(Register thread) {\n@@ -5996,2 +6030,10 @@\n-    autia(return_reg, rfp);\n-    check_return_address(return_reg);\n+    if (thread == noreg) {\n+      autiasp();\n+    } else {\n+      stp(rscratch1, zr, Address(pre(sp, -2 * wordSize)));\n+      ldr(rscratch1, Address(thread, JavaThread::cont_entry_offset()));\n+      sub(rscratch1, sp, rscratch1);\n+      autia(lr, rscratch1);\n+      ldp(rscratch1, zr, Address(post(sp, 2 * wordSize)));\n+    }\n+    check_return_address();\n@@ -6003,2 +6045,2 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses relative SP as the modifier.\n+\/\/ Note that signing SP = base + offset.\n@@ -6006,1 +6048,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::authenticate_return_address(Register return_reg, Register tmp, Register base, int offset) {\n@@ -6008,3 +6050,4 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    autia(return_reg, temp_reg);\n+    ldr(tmp, Address(rthread, JavaThread::cont_entry_offset()));\n+    sub(tmp, base, tmp);\n+    add(tmp, tmp, offset);\n+    autia(return_reg, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":68,"deletions":25,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -715,2 +715,2 @@\n-  void enter(bool strip_ret_addr = false);\n-  void leave();\n+  void enter(bool strip_ret_addr = false, Register thread = rthread);\n+  void leave(Register thread = rthread);\n@@ -719,4 +719,4 @@\n-  void protect_return_address();\n-  void protect_return_address(Register return_reg, Register temp_reg);\n-  void authenticate_return_address(Register return_reg = lr);\n-  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void protect_return_address(Register thread = rthread);\n+  void protect_return_address(Register return_reg, Register tmp, Register base, int offset = 0);\n+  void authenticate_return_address(Register thread = rthread);\n+  void authenticate_return_address(Register return_reg, Register tmp, Register base, int offset = 0);\n@@ -724,1 +724,1 @@\n-  void check_return_address(Register return_reg=lr) PRODUCT_RETURN;\n+  void check_return_address(Register return_reg = lr) PRODUCT_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/continuation.hpp\"\n@@ -80,1 +81,3 @@\n-inline address pauth_strip_verifiable(address ret_addr, address modifier) {\n+inline address pauth_strip_verifiable(address ret_addr,\n+                                      intptr_t* signing_sp,\n+                                      JavaThread* thread) {\n@@ -82,1 +85,1 @@\n-    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr, modifier);)\n+    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr, signing_sp, thread);)\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -393,1 +393,3 @@\n-  __ authenticate_return_address(c_rarg1, rscratch1);\n+  \/\/ Note that registers r0~r29 and v0~v31 (with T1D arrangement) are saved on\n+  \/\/ stack by push_CPU_state(), using 30+32=62 * wordSize stack space.\n+  __ authenticate_return_address(c_rarg1, rscratch1, sp, 62 * wordSize);\n@@ -1170,0 +1172,1 @@\n+      __ authenticate_return_address(c_rarg1, rscratch1, rfp);\n@@ -2335,1 +2338,1 @@\n-  __ protect_return_address(r3, rscratch1);\n+  __ protect_return_address(r3, rscratch1, rfp);\n@@ -2441,3 +2444,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3)\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2658,3 +2659,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3) frame\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2806,1 +2805,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20, rscratch1, rfp);\n@@ -2847,1 +2846,1 @@\n-    __ authenticate_return_address(r20, rscratch1);\n+    __ authenticate_return_address(r20, rscratch1, rfp);\n@@ -2862,1 +2861,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20, rscratch1, rfp);\n@@ -3077,1 +3076,1 @@\n-  __ authenticate_return_address(r3);\n+  __ authenticate_return_address(r3, rscratch1, sp, -2 * wordSize);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"pauth_aarch64.hpp\"\n@@ -55,1 +56,2 @@\n-  return *(address*)(_sp - 1);\n+  \/\/ Just strip it for frames on the heap.\n+  return pauth_strip_pointer(*(address*)(_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-    __ enter();\n+    __ enter(false \/* strip_ret_addr *\/, c_rarg7 \/* thread *\/);\n@@ -375,1 +375,1 @@\n-    __ leave();\n+    __ leave(c_rarg7 \/* thread *\/);\n@@ -7011,0 +7011,1 @@\n+      __ authenticate_return_address(c_rarg1, rscratch1, rfp);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -856,1 +856,1 @@\n-  __ protect_return_address();\n+  __ protect_return_address(lr, rscratch1, sp, 10 * wordSize);\n@@ -1827,1 +1827,1 @@\n-    __ authenticate_return_address(c_rarg1, rscratch1);\n+    __ authenticate_return_address(c_rarg1, rscratch1, rfp);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2019, 2023, Arm Limited. All rights reserved.\n@@ -208,1 +208,1 @@\n-  __ enter(); \/\/ set up frame\n+  __ enter(false \/* strip_ret_addr *\/, noreg \/* thread *\/); \/\/ set up frame\n@@ -304,1 +304,1 @@\n-  __ leave();\n+  __ leave(noreg \/* thread *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -448,3 +448,2 @@\n-    \/\/ 1) this code has been built with branch-protection,\n-    \/\/ 2) the CPU\/OS supports it, and\n-    \/\/ 3) incompatible VMContinuations isn't enabled.\n+    \/\/ 1) this code has been built with branch-protection and\n+    \/\/ 2) the CPU\/OS supports it\n@@ -455,3 +454,0 @@\n-    } else if (VMContinuations) {\n-      \/\/ Not currently compatible with continuation freeze\/thaw.\n-      warning(\"ROP-protection is incompatible with VMContinuations. Disabling ROP-protection.\");\n@@ -472,6 +468,0 @@\n-\n-    \/\/ The frame pointer must be preserved for ROP protection.\n-    if (FLAG_IS_DEFAULT(PreserveFramePointer) == false && PreserveFramePointer == false ) {\n-      vm_exit_during_initialization(err_msg(\"PreserveFramePointer cannot be disabled for ROP-protection\"));\n-    }\n-    PreserveFramePointer = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,8 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,8 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,8 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,8 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+inline address ContinuationHelper::return_address_at(intptr_t* sp, bool on_heap) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp, address pc, bool on_heap) {\n+  *(address*)sp = pc;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,3 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr,\n+                                         intptr_t* signing_sp,\n+                                         JavaThread* thread) {\n@@ -41,1 +43,3 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr,\n+                                                 intptr_t* signing_sp,\n+                                                 JavaThread* thread) {\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -49,1 +49,1 @@\n-\/\/ Sign a return value, using the given modifier.\n+\/\/ Sign a return value, using relative SP as the modifier.\n@@ -51,1 +51,3 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr,\n+                                         intptr_t* signing_sp,\n+                                         JavaThread* thread) {\n@@ -55,0 +57,4 @@\n+    intptr_t* initial_sp = (intptr_t*) Continuation::get_continuation_entry_for_sp(thread, signing_sp);\n+    uint64_t modifier = initial_sp == nullptr\n+                        ? (uint64_t) signing_sp\n+                        : (uint64_t) signing_sp - (uint64_t) initial_sp;\n@@ -56,1 +62,1 @@\n-    register address r16 __asm(\"r16\") = sp;\n+    register uint64_t r16 __asm(\"r16\") = modifier;\n@@ -63,1 +69,1 @@\n-\/\/ Authenticate a return value, using the given modifier.\n+\/\/ Authenticate a return value, using relative SP as the modifier.\n@@ -65,1 +71,3 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr,\n+                                                 intptr_t* signing_sp,\n+                                                 JavaThread* thread) {\n@@ -67,0 +75,4 @@\n+    intptr_t* initial_sp = (intptr_t*) Continuation::get_continuation_entry_for_sp(thread, signing_sp);\n+    uint64_t modifier = initial_sp == nullptr\n+                        ? (uint64_t) signing_sp\n+                        : (uint64_t) signing_sp - (uint64_t) initial_sp;\n@@ -68,1 +80,1 @@\n-    register address r16 __asm(\"r16\") = sp;\n+    register uint64_t r16 __asm(\"r16\") = modifier;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,3 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr,\n+                                         intptr_t* signing_sp,\n+                                         JavaThread* thread) {\n@@ -41,1 +43,3 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr,\n+                                                 intptr_t* signing_sp,\n+                                                 JavaThread* thread) {\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1567,1 +1567,1 @@\n-  \/\/ A better way of doing it would be authenticate in the caller by adding a\n+  \/\/ A better way of doing it would be authenticating in the caller by adding a\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -137,1 +138,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(sp - frame::sender_sp_ret_address_offset(),\n+                                                     false \/* on_heap *\/);\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(sp - frame::sender_sp_ret_address_offset(), false \/* on_heap *\/);\n@@ -595,1 +595,1 @@\n-    assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+    assert(ContinuationHelper::return_address_at(chunk->sp_address() - frame::sender_sp_ret_address_offset(), true \/* on_heap *\/) == chunk->pc(), \"\");\n@@ -609,1 +609,1 @@\n-    assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n+    assert(ContinuationHelper::return_address_at(bottom_sp - frame::sender_sp_ret_address_offset(), false \/* on_heap *\/) == StubRoutines::cont_returnBarrier(),\n@@ -678,1 +678,1 @@\n-  assert(_empty || *(address*)(_orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+  assert(_empty || ContinuationHelper::return_address_at(_orig_chunk_sp - frame::sender_sp_ret_address_offset(), true \/* on_heap *\/) == chunk->pc(), \"\");\n@@ -689,2 +689,2 @@\n-  assert(_empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n-  *(address*)(chunk_bottom_sp - frame::sender_sp_ret_address_offset()) = chunk->pc();\n+  assert(_empty || ContinuationHelper::return_address_at(chunk_bottom_sp - frame::sender_sp_ret_address_offset(), true \/* on_heap *\/) == StubRoutines::cont_returnBarrier(), \"\");\n+  ContinuationHelper::patch_return_address_at(chunk_bottom_sp - frame::sender_sp_ret_address_offset(), chunk->pc(), true \/* on_heap *\/);\n@@ -695,1 +695,1 @@\n-  chunk->set_pc(*(address*)(_cont_stack_top - frame::sender_sp_ret_address_offset()));\n+  chunk->set_pc(ContinuationHelper::return_address_at(_cont_stack_top - frame::sender_sp_ret_address_offset(), false \/* on_heap *\/));\n@@ -1849,1 +1849,1 @@\n-    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+    assert(f.pc() == ContinuationHelper::return_address_at(chunk_sp + frame_size - frame::sender_sp_ret_address_offset(), true \/* on_heap *\/), \"unexpected pc\");\n@@ -1869,1 +1869,1 @@\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  ContinuationHelper::patch_return_address_at(sp - frame::sender_sp_ret_address_offset(), pc, false \/* on_heap *\/);\n@@ -1936,0 +1936,10 @@\n+#ifdef TARGET_ARCH_aarch64\n+  {\n+    \/\/ ROP protection: the return address of topmost frame may be set but not\n+    \/\/ signed by freeze_slow() since it's on the heap then. Hence, resign it here.\n+    intptr_t* sp = rs.sp() - frame::sender_sp_ret_address_offset();\n+    address pc = pauth_strip_pointer(*(address*)sp);\n+    *(address*)sp = pauth_sign_return_address(pc, sp - 1, JavaThread::current());\n+  }\n+#endif\n+\n@@ -2406,1 +2416,0 @@\n-  address pc0 = *(address*)(sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+  static inline address return_address_at(intptr_t* sp, bool on_heap);\n+  static inline void patch_return_address_at(intptr_t* sp, address pc, bool on_heap);\n+\n@@ -71,1 +74,1 @@\n-  static address return_pc(const frame& f) { return *return_pc_address(f); }\n+  static address return_pc(const frame& f);\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,4 @@\n+inline address ContinuationHelper::Frame::return_pc(const frame& f) {\n+  return return_address_at((intptr_t *)return_pc_address(f), f.is_heap_frame());\n+}\n+\n@@ -78,1 +82,1 @@\n-  return *return_pc_address(f);\n+  return return_address_at((intptr_t *)return_pc_address(f), f.is_heap_frame());\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n@@ -258,1 +258,6 @@\n-            code.emitInt(0xdac103be);  \/\/ pacia x30, x29\n+            \/\/ Note that hard coded value 1424 denotes the byte\n+            \/\/ offset of field _cont_entry in JavaThread object.\n+            code.emitInt(0xf942cb88);  \/\/ ldr x8, [x28, #1424]\n+            code.emitInt(0xcb2863e8);  \/\/ sub x8, sp, x8\n+            code.emitInt(0xd1004108);  \/\/ sub x8, x8, #16\n+            code.emitInt(0xdac1011e);  \/\/ pacia x30, x8\n@@ -260,2 +265,2 @@\n-        code.emitInt(0xa9be7bfd);  \/\/ stp x29, x30, [sp, #-32]!\n-        code.emitInt(0x910003fd);  \/\/ mov x29, sp\n+        code.emitInt(0xa9bf7bfd);      \/\/ stp x29, x30, [sp, #-16]!\n+        code.emitInt(0x910003fd);      \/\/ mov x29, sp\n@@ -471,2 +476,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -474,1 +479,6 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            \/\/ Note that hard coded value 1424 denotes the byte\n+            \/\/ offset of field _cont_entry in JavaThread object.\n+            code.emitInt(0xf942cb88);  \/\/ ldr x8, [x28, #1424]\n+            code.emitInt(0xcb2863e8);  \/\/ sub x8, sp, x8\n+            code.emitInt(0xd1004108);  \/\/ sub x8, x8, #16\n+            code.emitInt(0xdac1111e);  \/\/ autia x30, x8\n@@ -482,2 +492,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -485,1 +495,6 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            \/\/ Note that hard coded value 1424 denotes the byte\n+            \/\/ offset of field _cont_entry in JavaThread object.\n+            code.emitInt(0xf942cb88);  \/\/ ldr x8, [x28, #1424]\n+            code.emitInt(0xcb2863e8);  \/\/ sub x8, sp, x8\n+            code.emitInt(0xd1004108);  \/\/ sub x8, x8, #16\n+            code.emitInt(0xdac1111e);  \/\/ autia x30, x8\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"}]}