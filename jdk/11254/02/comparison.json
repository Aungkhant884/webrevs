{"files":[{"patch":"@@ -602,5 +602,2 @@\n-  \/\/ Ask ServiceThread to release the OopHandles\n-  ServiceThread::add_oop_handle_release(_threadObj);\n-  ServiceThread::add_oop_handle_release(_vthread);\n-  ServiceThread::add_oop_handle_release(_jvmti_vthread);\n-  ServiceThread::add_oop_handle_release(_extentLocalCache);\n+  \/\/ Enqueue OopHandles for release by the service thread.\n+  add_oop_handles_for_release();\n@@ -2076,0 +2073,54 @@\n+\n+\/\/ Deferred OopHandle release support.\n+\n+class OopHandleList : public CHeapObj<mtInternal> {\n+  static const int _count = 4;\n+  OopHandle _handles[_count];\n+  OopHandleList* _next;\n+  int _index;\n+ public:\n+  OopHandleList(OopHandleList* next) : _next(next), _index(0) {}\n+  void add(OopHandle h) {\n+    assert(_index < _count, \"too many additions\");\n+    _handles[_index++] = h;\n+  }\n+  ~OopHandleList() {\n+    assert(_index == _count, \"usage error\");\n+    for (int i = 0; i < _index; i++) {\n+      _handles[i].release(JavaThread::thread_oop_storage());\n+    }\n+  }\n+  OopHandleList* next() const { return _next; }\n+};\n+\n+OopHandleList* JavaThread::_oop_handle_list = nullptr;\n+\n+\/\/ Called by the ServiceThread to do the work of releasing\n+\/\/ the OopHandles.\n+void JavaThread::release_oop_handles() {\n+  OopHandleList* list;\n+  {\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    list = _oop_handle_list;\n+    _oop_handle_list = nullptr;\n+  }\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"cannot be called at a safepoint\");\n+\n+  while (list != nullptr) {\n+    OopHandleList* l = list;\n+    list = l->next();\n+    delete l;\n+  }\n+}\n+\n+\/\/ Add our OopHandles for later release.\n+void JavaThread::add_oop_handles_for_release() {\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  OopHandleList* new_head = new OopHandleList(_oop_handle_list);\n+  new_head->add(_threadObj);\n+  new_head->add(_vthread);\n+  new_head->add(_jvmti_vthread);\n+  new_head->add(_extentLocalCache);\n+  _oop_handle_list = new_head;\n+  Service_lock->notify_all();\n+}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":56,"deletions":5,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+class OopHandleList;\n@@ -84,0 +85,1 @@\n+  friend class ServiceThread; \/\/ for deferred OopHandle release access\n@@ -87,0 +89,4 @@\n+\n+  \/\/ All references to Java objects managed via OopHandles. These\n+  \/\/ have to be released by the ServiceThread after the JavaThread has\n+  \/\/ terminated - see add_oop_handles_for_release().\n@@ -1171,0 +1177,14 @@\n+\n+  \/\/ Deferred OopHandle release support\n+ private:\n+  \/\/ List of OopHandles to be released - guarded by the Service_lock.\n+  static OopHandleList* _oop_handle_list;\n+  \/\/ Add our OopHandles to the list for the service thread to release.\n+  void add_oop_handles_for_release();\n+  \/\/ Called by the ServiceThread to release the OopHandles.\n+  static void release_oop_handles();\n+  \/\/ Called by the ServiceThread to poll if there are any OopHandles to release.\n+  \/\/ Called when holding the Service_lock.\n+  static bool has_oop_handles_to_release() {\n+    return _oop_handle_list != nullptr;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -62,30 +62,0 @@\n-\/\/ Defer releasing JavaThread OopHandle to the ServiceThread\n-class OopHandleList : public CHeapObj<mtInternal> {\n-  OopHandle      _handle;\n-  OopHandleList* _next;\n- public:\n-   OopHandleList(OopHandle h, OopHandleList* next) : _handle(h), _next(next) {}\n-   ~OopHandleList() {\n-     _handle.release(JavaThread::thread_oop_storage());\n-   }\n-   OopHandleList* next() const { return _next; }\n-};\n-\n-static OopHandleList* _oop_handle_list = NULL;\n-\n-static void release_oop_handles() {\n-  OopHandleList* list;\n-  {\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-    list = _oop_handle_list;\n-    _oop_handle_list = NULL;\n-  }\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"cannot be called at a safepoint\");\n-\n-  while (list != NULL) {\n-    OopHandleList* l = list;\n-    list = l->next();\n-    delete l;\n-  }\n-}\n-\n@@ -155,1 +125,1 @@\n-              (oop_handles_to_release = (_oop_handle_list != NULL)) |\n+              (oop_handles_to_release = JavaThread::has_oop_handles_to_release()) |\n@@ -218,1 +188,1 @@\n-      release_oop_handles();\n+      JavaThread::release_oop_handles();\n@@ -264,7 +234,0 @@\n-\n-void ServiceThread::add_oop_handle_release(OopHandle handle) {\n-  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-  OopHandleList* new_head = new OopHandleList(handle, _oop_handle_list);\n-  _oop_handle_list = new_head;\n-  Service_lock->notify_all();\n-}\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  static void add_oop_handle_release(OopHandle handle);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}