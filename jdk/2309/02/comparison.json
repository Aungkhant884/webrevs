{"files":[{"patch":"@@ -218,0 +218,9 @@\n+\/\/ Only used by oldgen allocation.\n+bool MutableSpace::needs_expand(size_t word_size) const {\n+  assert_lock_strong(ExpandHeap_lock);\n+  \/\/ Holding the lock means end is stable.  So while top may be advancing\n+  \/\/ via concurrent allocations, there is no need to order the reads of top\n+  \/\/ and end here, unlike in cas_allocate.\n+  return pointer_delta(end(), top()) < word_size;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -145,0 +145,5 @@\n+  \/\/ Return true if this space needs to be expanded in order to satisfy an\n+  \/\/ allocation request of the indicated size.  Concurrent allocations and\n+  \/\/ resizes may change the result of a later call.  Used by oldgen allocator.\n+  \/\/ precondition: holding ExpandHeap_lock\n+  bool needs_expand(size_t word_size) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,2 +181,15 @@\n-HeapWord* PSOldGen::expand_and_cas_allocate(size_t word_size) {\n-  expand(word_size*HeapWordSize);\n+bool PSOldGen::expand_for_allocate(size_t word_size) {\n+  assert(word_size > 0, \"allocating zero words?\");\n+  bool result = true;\n+  {\n+    MutexLocker x(ExpandHeap_lock);\n+    \/\/ Avoid \"expand storms\" by rechecking available space after obtaining\n+    \/\/ the lock, because another thread may have already made sufficient\n+    \/\/ space available.  If insufficient space available, that will remain\n+    \/\/ true until we expand, since we have the lock.  Other threads may take\n+    \/\/ the space we need before we can allocate it, regardless of whether we\n+    \/\/ expand.  That's okay, we'll just try expanding again.\n+    if (object_space()->needs_expand(word_size)) {\n+      result = expand(word_size*HeapWordSize);\n+    }\n+  }\n@@ -186,1 +199,1 @@\n-  return cas_allocate_noexpand(word_size);\n+  return result;\n@@ -189,5 +202,4 @@\n-void PSOldGen::expand(size_t bytes) {\n-  if (bytes == 0) {\n-    return;\n-  }\n-  MutexLocker x(ExpandHeap_lock);\n+bool PSOldGen::expand(size_t bytes) {\n+  assert_lock_strong(ExpandHeap_lock);\n+  assert_locked_or_safepoint(Heap_lock);\n+  assert(bytes > 0, \"precondition\");\n@@ -203,7 +215,5 @@\n-  if (aligned_bytes == 0){\n-    \/\/ The alignment caused the number of bytes to wrap.  An expand_by(0) will\n-    \/\/ return true with the implication that and expansion was done when it\n-    \/\/ was not.  A call to expand implies a best effort to expand by \"bytes\"\n-    \/\/ but not a guarantee.  Align down to give a best effort.  This is likely\n-    \/\/ the most that the generation can expand since it has some capacity to\n-    \/\/ start with.\n+  if (aligned_bytes == 0) {\n+    \/\/ The alignment caused the number of bytes to wrap.  A call to expand\n+    \/\/ implies a best effort to expand by \"bytes\" but not a guarantee.  Align\n+    \/\/ down to give a best effort.  This is likely the most that the generation\n+    \/\/ can expand since it has some capacity to start with.\n@@ -227,0 +237,1 @@\n+  return success;\n@@ -232,3 +243,1 @@\n-  if (bytes == 0) {\n-    return true;  \/\/ That's what virtual_space()->expand_by(0) would return\n-  }\n+  assert(bytes > 0, \"precondition\");\n@@ -271,1 +280,1 @@\n-  bool result = true;\n+  bool result = false;\n@@ -326,0 +335,1 @@\n+    MutexLocker x(ExpandHeap_lock);\n@@ -329,1 +339,0 @@\n-    \/\/ shrink doesn't grab this lock, expand does. Is that right?\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  HeapWord* expand_and_cas_allocate(size_t word_size);\n-  void expand(size_t bytes);\n+  bool expand_for_allocate(size_t word_size);\n+  bool expand(size_t bytes);\n@@ -138,2 +138,6 @@\n-    HeapWord* res = cas_allocate_noexpand(word_size);\n-    return (res == NULL) ? expand_and_cas_allocate(word_size) : res;\n+    HeapWord* res;\n+    do {\n+      res = cas_allocate_noexpand(word_size);\n+      \/\/ Retry failed allocation if expand succeeds.\n+    } while ((res == nullptr) && expand_for_allocate(word_size));\n+    return res;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}