{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -37,0 +38,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -43,0 +45,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -44,0 +47,3 @@\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +52,1 @@\n+import java.util.List;\n@@ -66,0 +73,1 @@\n+        function = stripNames(function);\n@@ -85,0 +93,1 @@\n+        function = stripNames(function);\n@@ -128,0 +137,26 @@\n+\n+    private static MemoryLayout stripNames(MemoryLayout ml) {\n+        \/\/ we don't care about transferring alignment and byte order here\n+        \/\/ since the linker already restricts those such that they will always be the same\n+        return switch (ml) {\n+            case StructLayout sl -> MemoryLayout.structLayout(stripNames(sl.memberLayouts()));\n+            case UnionLayout ul -> MemoryLayout.unionLayout(stripNames(ul.memberLayouts()));\n+            case SequenceLayout sl -> MemoryLayout.sequenceLayout(sl.elementCount(), stripNames(sl.elementLayout()));\n+            case AddressLayout al -> al.targetLayout()\n+                    .map(tl -> al.withoutName().withTargetLayout(stripNames(tl)))\n+                    .orElse(al.withoutName());\n+            default -> ml.withoutName(); \/\/ ValueLayout and PaddingLayout\n+        };\n+    }\n+\n+    private static MemoryLayout[] stripNames(List<MemoryLayout> layouts) {\n+        return layouts.stream()\n+                .map(AbstractLinker::stripNames)\n+                .toArray(MemoryLayout[]::new);\n+    }\n+\n+    private static FunctionDescriptor stripNames(FunctionDescriptor function) {\n+        return function.returnLayout()\n+                .map(rl -> FunctionDescriptor.of(stripNames(rl), stripNames(function.argumentLayouts())))\n+                .orElseGet(() -> FunctionDescriptor.ofVoid(stripNames(function.argumentLayouts())));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+import static java.lang.foreign.MemoryLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.assertSame;\n@@ -42,2 +46,4 @@\n-    @Test\n-    public void testLinkerOptionsCache() {\n+    record LinkRequest(FunctionDescriptor descriptor, Linker.Option... options) {}\n+\n+    @Test(dataProvider = \"notSameCases\")\n+    public void testLinkerOptionsCache(LinkRequest l1, LinkRequest l2) {\n@@ -45,3 +51,2 @@\n-        FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(C_INT, C_INT);\n-        MethodHandle mh1 = linker.downcallHandle(descriptor);\n-        MethodHandle mh2 = linker.downcallHandle(descriptor, Linker.Option.firstVariadicArg(1));\n+        MethodHandle mh1 = linker.downcallHandle(l1.descriptor(), l1.options());\n+        MethodHandle mh2 = linker.downcallHandle(l2.descriptor(), l2.options());\n@@ -52,0 +57,49 @@\n+    @DataProvider\n+    public static Object[][] notSameCases() {\n+        FunctionDescriptor fd_II_V = FunctionDescriptor.ofVoid(C_INT, C_INT);\n+        return new Object[][]{\n+            {new LinkRequest(fd_II_V), new LinkRequest(fd_II_V, Linker.Option.firstVariadicArg(1))},\n+            {new LinkRequest(FunctionDescriptor.ofVoid(JAVA_SHORT)), new LinkRequest(FunctionDescriptor.ofVoid(JAVA_CHAR))},\n+            {new LinkRequest(FunctionDescriptor.ofVoid(JAVA_SHORT)), new LinkRequest(FunctionDescriptor.ofVoid(JAVA_CHAR))},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"namedDescriptors\")\n+    public void testNamedLinkerCache(FunctionDescriptor f1, FunctionDescriptor f2) {\n+        Linker linker = Linker.nativeLinker();\n+        MethodHandle mh1 = linker.downcallHandle(f1);\n+        MethodHandle mh2 = linker.downcallHandle(f2);\n+        \/\/ assert that these are the same link request, even though layout names differ\n+        assertSame(mh1, mh2);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] namedDescriptors() {\n+        return new Object[][]{\n+            { FunctionDescriptor.ofVoid(C_INT),\n+                    FunctionDescriptor.ofVoid(C_INT.withName(\"x\")) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT).withName(\"x\")) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(32).withName(\"x\"), C_LONG_LONG)) },\n+            { FunctionDescriptor.ofVoid(structLayout(sequenceLayout(1, C_INT))),\n+                    FunctionDescriptor.ofVoid(structLayout(sequenceLayout(1, C_INT).withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(structLayout(sequenceLayout(1, C_INT))),\n+                    FunctionDescriptor.ofVoid(structLayout(sequenceLayout(1, C_INT.withName(\"x\")))) },\n+            { FunctionDescriptor.ofVoid(unionLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(unionLayout(C_INT).withName(\"x\")) },\n+            { FunctionDescriptor.ofVoid(unionLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(unionLayout(C_INT.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(C_POINTER),\n+                    FunctionDescriptor.ofVoid(C_POINTER.withName(\"x\")) },\n+            { FunctionDescriptor.ofVoid(C_POINTER.withTargetLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(C_POINTER.withTargetLayout(C_INT.withName(\"x\"))) },\n+            { FunctionDescriptor.ofVoid(C_POINTER.withTargetLayout(C_INT)),\n+                    FunctionDescriptor.ofVoid(C_POINTER.withName(\"x\").withTargetLayout(C_INT.withName(\"x\"))) },\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"}]}