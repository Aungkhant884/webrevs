{"files":[{"patch":"@@ -1943,1 +1943,1 @@\n-  MonitorLocker ml(G1OldGCCount_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(G1OldGCCount_lock);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1382,1 +1382,1 @@\n-      MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+      MutexLocker x(ParGCRareEvent_lock);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-      MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+      MutexLocker x(ParGCRareEvent_lock);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker x(ParGCRareEvent_lock);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -536,2 +536,1 @@\n-        MutexLocker x(ParGCRareEvent_lock,\n-          Mutex::_no_safepoint_check_flag);\n+        MutexLocker x(ParGCRareEvent_lock);\n@@ -608,2 +607,1 @@\n-          MutexLocker x(ParGCRareEvent_lock,\n-            Mutex::_no_safepoint_check_flag);\n+          MutexLocker x(ParGCRareEvent_lock);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(monitor());\n@@ -157,1 +157,1 @@\n-  MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(monitor());\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCBreakpoints.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  MonitorLocker ml(ConcurrentGCBreakpoints::monitor(), Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(ConcurrentGCBreakpoints::monitor());\n","filename":"src\/hotspot\/share\/gc\/z\/zBreakpoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,3 +80,2 @@\n-  assert(!thread->is_active_Java_thread() || _rank <= nosafepoint,\n-         \"This lock should always have a safepoint check for Java threads: %s\",\n-         name());\n+  assert(_rank <= nosafepoint,\n+         \"This lock should always have a safepoint check for Java threads: %s\", name());\n@@ -232,3 +231,2 @@\n-  JavaThread* const self = JavaThread::current();\n-  \/\/ Safepoint checking logically implies an active JavaThread.\n-  assert(self->is_active_Java_thread(), \"invariant\");\n+  Thread* const self = Thread::current();\n+  bool is_active_Java_thread = self->is_active_Java_thread();\n@@ -249,1 +247,3 @@\n-  InFlightMutexRelease ifmr(this);\n+  if (is_active_Java_thread) {\n+    JavaThread* jt = JavaThread::cast(self);\n+    InFlightMutexRelease ifmr(this);\n@@ -251,3 +251,3 @@\n-  {\n-    ThreadBlockInVMPreprocess<InFlightMutexRelease> tbivmdc(self, ifmr);\n-    OSThreadWaitState osts(self->osthread(), false \/* not Object.wait() *\/);\n+    {\n+      ThreadBlockInVMPreprocess<InFlightMutexRelease> tbivmdc(jt, ifmr);\n+      OSThreadWaitState osts(jt->osthread(), false \/* not Object.wait() *\/);\n@@ -255,2 +255,2 @@\n-    wait_status = _lock.wait(timeout);\n-  }\n+      wait_status = _lock.wait(timeout);\n+    }\n@@ -258,5 +258,8 @@\n-  if (ifmr.not_released()) {\n-    \/\/ Not unlocked by ~ThreadBlockInVMPreprocess\n-    assert_owner(NULL);\n-    \/\/ Conceptually reestablish ownership of the lock.\n-    set_owner(self);\n+    if (ifmr.not_released()) {\n+      \/\/ Not unlocked by ~ThreadBlockInVMPreprocess\n+      assert_owner(NULL);\n+      \/\/ Conceptually reestablish ownership of the lock.\n+      set_owner(self);\n+    } else {\n+      lock(self);\n+    }\n@@ -264,1 +267,6 @@\n-    lock(self);\n+    \/\/ wait without a safepoint check for NonJavaThread\n+    \/\/ The lock was specified as safepoint checking so this is the version\n+    \/\/ of wait that is called but NonJavaThreads don't participate in the\n+    \/\/ safepoint protocol.\n+    wait_status = _lock.wait(timeout);\n+    set_owner(self);\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(PeriodicTask_lock);\n@@ -288,1 +288,1 @@\n-    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker mu(Terminator_lock);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  MutexLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(PeriodicTask_lock);\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -355,4 +355,1 @@\n-  MonitorLocker ml(VMOperation_lock,\n-                   Thread::current()->is_Java_thread() ?\n-                     Mutex::_safepoint_check_flag :\n-                     Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(VMOperation_lock);\n@@ -443,1 +440,1 @@\n-  MonitorLocker ml_op_lock(VMOperation_lock, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml_op_lock(VMOperation_lock);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}