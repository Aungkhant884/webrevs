{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,9 +84,29 @@\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-        \/\/ Class tracking not initialized, nobody's interested.\n-        debugMonitorExit(classTrackLock);\n-        return NULL;\n-    }\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorExit(classTrackLock);\n+    struct bag* new_bag = NULL;\n+    struct bag* deleted = NULL;\n+    jboolean retry = JNI_FALSE;\n+    do {\n+      \/\/ Avoid unnecessary allocations when class track has yet been activated.\n+      if (deletedSignatures != NULL) {\n+        \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n+         *\n+         * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n+         * It is dangerous to call them (via bagCreateBag\/bagDestroyBag())while holding monitor(s),\n+         * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n+         * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n+         * which can lead to deadlock.\n+         *\/\n+        new_bag = bagCreateBag(sizeof(char*), 10);\n+      }\n+      debugMonitorEnter(classTrackLock);\n+      deleted = deletedSignatures;\n+      if (deletedSignatures != NULL) {\n+        if (new_bag != NULL) {\n+          deletedSignatures = new_bag;\n+          new_bag = NULL;\n+        } else {\n+          retry = JNI_TRUE;\n+        }\n+      }\n+      debugMonitorExit(classTrackLock);\n+    } while (retry == JNI_TRUE);\n+    bagDestroyBag(new_bag);\n@@ -197,0 +217,3 @@\n+    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n@@ -198,1 +221,1 @@\n-    deletedSignatures = bagCreateBag(sizeof(char*), 1000);\n+    deletedSignatures = new_bag;\n@@ -216,0 +239,1 @@\n+    struct bag* to_delete = NULL;\n@@ -219,2 +243,1 @@\n-        bagEnumerateOver(deletedSignatures, cleanDeleted, NULL);\n-        bagDestroyBag(deletedSignatures);\n+        to_delete = deletedSignatures;\n@@ -225,0 +248,6 @@\n+    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    if (to_delete != NULL) {\n+      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n+      bagDestroyBag(to_delete);\n+    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"}]}