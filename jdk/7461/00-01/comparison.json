{"files":[{"patch":"@@ -59,8 +59,0 @@\n-\/*\n- * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n- * It is dangerous to call them (via bagCreateBag\/bagDestroyBag())while holding monitor(s),\n- * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and its event\n- * handler may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n- * which can lead to deadlock.\n- *\/\n-\n@@ -92,18 +84,28 @@\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-        \/\/ Class tracking not initialized, nobody's interested.\n-        debugMonitorExit(classTrackLock);\n-        return NULL;\n-    }\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = NULL;\n-    debugMonitorExit(classTrackLock);\n-\n-    \/\/ Allocate new bag outside classTrackLock lock to avoid deadlock\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-      deletedSignatures = new_bag;\n-      new_bag = NULL;\n-    }\n-    debugMonitorExit(classTrackLock);\n+    struct bag* new_bag = NULL;\n+    struct bag* deleted = NULL;\n+    jboolean retry = JNI_FALSE;\n+    do {\n+      \/\/ Avoid unnecessary allocations when class track has yet been activated.\n+      if (deletedSignatures != NULL) {\n+        \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n+         *\n+         * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n+         * It is dangerous to call them (via bagCreateBag\/bagDestroyBag())while holding monitor(s),\n+         * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n+         * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n+         * which can lead to deadlock.\n+         *\/\n+        new_bag = bagCreateBag(sizeof(char*), 10);\n+      }\n+      debugMonitorEnter(classTrackLock);\n+      deleted = deletedSignatures;\n+      if (deletedSignatures != NULL) {\n+        if (new_bag != NULL) {\n+          deletedSignatures = new_bag;\n+          new_bag = NULL;\n+        } else {\n+          retry = JNI_TRUE;\n+        }\n+      }\n+      debugMonitorExit(classTrackLock);\n+    } while (retry == JNI_TRUE);\n@@ -215,0 +217,2 @@\n+    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n@@ -239,1 +243,0 @@\n-        bagEnumerateOver(deletedSignatures, cleanDeleted, NULL);\n@@ -245,1 +248,6 @@\n-    bagDestroyBag(to_delete);\n+    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    if (to_delete != NULL) {\n+      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n+      bagDestroyBag(to_delete);\n+    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":36,"deletions":28,"binary":false,"changes":64,"status":"modified"}]}