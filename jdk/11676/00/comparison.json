{"files":[{"patch":"@@ -116,11 +116,0 @@\n-  \/\/ The kinds of precision a CardTable may offer.\n-  enum PrecisionStyle {\n-    Precise,\n-    ObjHeadPreciseArray\n-  };\n-\n-  \/\/ Tells what style of precision this card table offers.\n-  PrecisionStyle precision() {\n-    return ObjHeadPreciseArray; \/\/ Only one supported for now.\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -454,1 +454,1 @@\n-  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, precision(), gen_boundary);\n+  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, gen_boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,14 +54,12 @@\n-      if (_precision == CardTable::ObjHeadPreciseArray) {\n-        if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-          \/\/ An arrayOop is starting on the dirty card - since we do exact\n-          \/\/ store checks for objArrays we are done.\n-        } else {\n-          \/\/ Otherwise, it is possible that the object starting on the dirty\n-          \/\/ card spans the entire card, and that the store happened on a\n-          \/\/ later card.  Figure out where the object ends.\n-          \/\/ Use the block_size() method of the space over which\n-          \/\/ the iteration is being done.  That space (e.g. CMS) may have\n-          \/\/ specific requirements on object sizes which will\n-          \/\/ be reflected in the block_size() method.\n-          top = top_obj + cast_to_oop(top_obj)->size();\n-        }\n+      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+        \/\/ An arrayOop is starting on the dirty card - since we do exact\n+        \/\/ store checks for objArrays we are done.\n+      } else {\n+        \/\/ Otherwise, it is possible that the object starting on the dirty\n+        \/\/ card spans the entire card, and that the store happened on a\n+        \/\/ later card.  Figure out where the object ends.\n+        \/\/ Use the block_size() method of the space over which\n+        \/\/ the iteration is being done.  That space (e.g. CMS) may have\n+        \/\/ specific requirements on object sizes which will\n+        \/\/ be reflected in the block_size() method.\n+        top = top_obj + cast_to_oop(top_obj)->size();\n@@ -118,6 +116,1 @@\n-  assert(_precision == CardTable::ObjHeadPreciseArray ||\n-         _precision == CardTable::Precise,\n-         \"Only ones we deal with for now.\");\n-\n-  assert(_precision != CardTable::ObjHeadPreciseArray ||\n-         _last_bottom == NULL || top <= _last_bottom,\n+  assert(_last_bottom == NULL || top <= _last_bottom,\n@@ -139,3 +132,1 @@\n-  if (_precision == CardTable::ObjHeadPreciseArray &&\n-      _min_done != NULL &&\n-      _min_done < top) {\n+  if (_min_done != NULL && _min_done < top) {\n@@ -151,3 +142,1 @@\n-         (_precision != CardTable::ObjHeadPreciseArray ||\n-          _min_done == NULL ||\n-          top <= _min_done),\n+         (_min_done == NULL || top <= _min_done),\n@@ -167,12 +156,10 @@\n-    if (_precision == CardTable::ObjHeadPreciseArray) {\n-      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-        \/\/ An arrayOop is starting on the dirty card - since we do exact\n-        \/\/ store checks for objArrays we are done.\n-      } else {\n-        \/\/ Otherwise, it is possible that the object starting on the dirty\n-        \/\/ card spans the entire card, and that the store happened on a\n-        \/\/ later card.  Figure out where the object ends.\n-        assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-          \"Block size and object size mismatch\");\n-        top = top_obj + cast_to_oop(top_obj)->size();\n-      }\n+    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+      \/\/ An arrayOop is starting on the dirty card - since we do exact\n+      \/\/ store checks for objArrays we are done.\n+    } else {\n+      \/\/ Otherwise, it is possible that the object starting on the dirty\n+      \/\/ card spans the entire card, and that the store happened on a\n+      \/\/ later card.  Figure out where the object ends.\n+      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n+        \"Block size and object size mismatch\");\n+      top = top_obj + cast_to_oop(top_obj)->size();\n@@ -238,1 +225,0 @@\n-                             CardTable::PrecisionStyle precision,\n@@ -240,1 +226,1 @@\n-  return new ContiguousSpaceDCTOC(this, cl, precision, boundary);\n+  return new ContiguousSpaceDCTOC(this, cl, boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":26,"deletions":40,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -243,1 +243,0 @@\n-  CardTable::PrecisionStyle _precision;\n@@ -246,2 +245,2 @@\n-  HeapWord* _min_done;          \/\/ ObjHeadPreciseArray precision requires\n-                                \/\/ a downwards traversal; this is the\n+  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n+                                \/\/ imprecise write barrier; this is the\n@@ -271,1 +270,0 @@\n-                        CardTable::PrecisionStyle precision,\n@@ -273,1 +271,1 @@\n-    _cl(cl), _sp(sp), _precision(precision), _boundary(boundary),\n+    _cl(cl), _sp(sp), _boundary(boundary),\n@@ -470,1 +468,0 @@\n-                                     CardTable::PrecisionStyle precision,\n@@ -547,1 +544,0 @@\n-                       CardTable::PrecisionStyle precision,\n@@ -549,1 +545,1 @@\n-    DirtyCardToOopClosure(sp, cl, precision, boundary)\n+    DirtyCardToOopClosure(sp, cl, boundary)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -238,2 +238,0 @@\n-  declare_constant(CardTable::Precise)                                      \\\n-  declare_constant(CardTable::ObjHeadPreciseArray)                          \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}