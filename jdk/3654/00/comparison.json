{"files":[{"patch":"@@ -453,2 +453,0 @@\n-\n-#ifdef ASSERT\n@@ -459,1 +457,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -77,1 +77,2 @@\n-#endif\n+  _reused(C->comp_arena()),\n+#endif \/\/ !PRODUCT\n@@ -1101,3 +1102,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1108,3 +1107,1 @@\n-#ifdef ASSERT\n-              _new2old_map.map(m->_idx, n);\n-#endif\n+              NOT_PRODUCT(record_new2old(m, n);)\n@@ -1168,3 +1165,1 @@\n-#ifdef ASSERT\n-          _new2old_map.map(m->_idx, n);\n-#endif\n+          NOT_PRODUCT(record_new2old(m, n));\n@@ -1502,4 +1497,2 @@\n-#ifdef ASSERT\n-  _old2new_map.map(n->_idx, m);\n-  _new2old_map.map(m->_idx, (Node*)n);\n-#endif\n+  \/\/ New-to-old mapping is done in ReduceInst, to cover complex instructions.\n+  NOT_PRODUCT(_old2new_map.map(n->_idx, m);)\n@@ -1762,0 +1755,1 @@\n+  NOT_PRODUCT(record_new2old(mach, leaf);)\n@@ -1830,3 +1824,1 @@\n-#ifdef ASSERT\n-    _new2old_map.map(ex->_idx, s->_leaf);\n-#endif\n+    NOT_PRODUCT(record_new2old(ex, s->_leaf);)\n@@ -2430,1 +2422,11 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+void Matcher::record_new2old(Node* newn, Node* old) {\n+  _new2old_map.map(newn->_idx, old);\n+  if (!_reused.test_set(old->_igv_idx)) {\n+    \/\/ Reuse the Ideal-level IGV identifier so that the node can be tracked\n+    \/\/ across matching. If there are multiple machine nodes expanded from the\n+    \/\/ same Ideal node, only one will reuse its IGV identifier.\n+    newn->_igv_idx = old->_igv_idx;\n+  }\n+}\n+\n@@ -2435,1 +2437,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -138,2 +138,5 @@\n-  debug_only(Node_Array _old2new_map;)   \/\/ Map roots of ideal-trees to machine-roots\n-  debug_only(Node_Array _new2old_map;)   \/\/ Maps machine nodes back to ideal\n+#ifndef PRODUCT\n+  Node_Array _old2new_map;    \/\/ Map roots of ideal-trees to machine-roots\n+  Node_Array _new2old_map;    \/\/ Maps machine nodes back to ideal\n+  VectorSet _reused;          \/\/ Ideal IGV identifiers reused by machine nodes\n+#endif \/\/ !PRODUCT\n@@ -559,1 +562,4 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n+  \/\/ Record mach-to-Ideal mapping, reusing the Ideal IGV identifier if possible.\n+  void record_new2old(Node* newn, Node* old);\n+\n@@ -565,1 +571,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -326,3 +326,5 @@\n-  \/\/ IGV node identifier. It is similar to Node::_debug_idx in that it is unique\n-  \/\/ across all compilation phases, but different in that it is initialized in\n-  \/\/ each compilation, for stability.\n+  \/\/ IGV node identifier. Two nodes, possibly in different compilation phases,\n+  \/\/ have the same IGV identifier if (and only if) they are the very same node\n+  \/\/ (same memory address) or one is \"derived\" from the other (by e.g.\n+  \/\/ renumbering or matching). This identifier makes it possible to follow the\n+  \/\/ entire lifetime of a node in IGV even if its C2 identifier (_idx) changes.\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}