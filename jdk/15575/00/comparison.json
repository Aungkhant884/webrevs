{"files":[{"patch":"@@ -339,2 +339,1 @@\n-     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n-     * on the given {@opcode}.\n+     * referenced by the {@code which}.\n@@ -343,1 +342,1 @@\n-     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * has not yet been rewritten, or {@code which} is not a valid index for\n@@ -345,0 +344,3 @@\n+     *\n+     * @param which  for INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}, must be {@code cpci}. For all other bytecodes,\n+     *               must be {@code rawIndex}\n@@ -346,2 +348,2 @@\n-    String lookupNameInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n-        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n+    String lookupNameInPool(HotSpotConstantPool constantPool, int which, int opcode) {\n+        return lookupNameInPool(constantPool, constantPool.getConstantPoolPointer(), which, opcode);\n@@ -350,1 +352,1 @@\n-    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n+    private native String lookupNameInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which, int opcode);\n@@ -354,2 +356,1 @@\n-     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n-     * on the given {@opcode}.\n+     * referenced by the {@code which}.\n@@ -358,1 +359,1 @@\n-     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * has not yet been rewritten, or {@code which} is not a valid index for\n@@ -360,0 +361,3 @@\n+     *\n+     * @param which  for INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}, must be {@code cpci}. For all other bytecodes,\n+     *               must be {@code rawIndex}\n@@ -361,2 +365,2 @@\n-    String lookupSignatureInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n-        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n+    String lookupSignatureInPool(HotSpotConstantPool constantPool, int which, int opcode) {\n+        return lookupSignatureInPool(constantPool, constantPool.getConstantPoolPointer(), which, opcode);\n@@ -365,1 +369,1 @@\n-    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n+    private native String lookupSignatureInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which, int opcode);\n@@ -369,1 +373,1 @@\n-     * referenced by the {@code rawIndex}. The meaning of {@code rawIndex} is dependent\n+     * referenced by the {@code which}. The meaning of {@code which} is dependent\n@@ -373,1 +377,1 @@\n-     * has not yet been rewritten, or {@code rawIndex} is not a valid index for\n+     * has not yet been rewritten, or {@code which} is not a valid index for\n@@ -375,0 +379,3 @@\n+     *\n+     * @param which  for INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}, must be {@code cpci}. For all other bytecodes,\n+     *               must be {@code rawIndex}\n@@ -376,2 +383,2 @@\n-    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int rawIndex, int opcode) {\n-        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), rawIndex, opcode);\n+    int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int which, int opcode) {\n+        return lookupKlassRefIndexInPool(constantPool, constantPool.getConstantPoolPointer(), which, opcode);\n@@ -380,1 +387,1 @@\n-    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex, int opcode);\n+    private native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int which, int opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -399,12 +399,0 @@\n-    \/**\n-     * Gets the name of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by another\n-     * entry denoted by {@code which}.\n-     *\n-     * @param rawIndex rewritten index in the bytecode stream\n-     * @param opcode the opcode of the instruction for which the lookup is being performed\n-     * @return name as {@link String}\n-     *\/\n-    private String getNameOf(int rawIndex, int opcode) {\n-        return compilerToVM().lookupNameInPool(this, rawIndex, opcode);\n-    }\n-\n@@ -424,11 +412,0 @@\n-    \/**\n-     * Gets the signature of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by\n-     * another entry denoted by {@code which}.\n-     *\n-     * @param rawIndex rewritten index in the bytecode stream\n-     * @param opcode the opcode of the instruction for which the lookup is being performed\n-     * @return signature as {@link String}\n-     *\/\n-    private String getSignatureOf(int rawIndex, int opcode) {\n-        return compilerToVM().lookupSignatureInPool(this, rawIndex, opcode);\n-    }\n@@ -452,1 +429,2 @@\n-     * @param rawIndex rewritten index in the bytecode stream\n+     * @param which  for INVOKE{VIRTUAL,SPECIAL,STATIC,INTERFACE}, must be {@code cpci}. For all other bytecodes,\n+     *               must be {@code rawIndex}\n@@ -456,2 +434,2 @@\n-    private int getKlassRefIndexAt(int rawIndex, int opcode) {\n-        return compilerToVM().lookupKlassRefIndexInPool(this, rawIndex, opcode);\n+    private int getKlassRefIndexAt(int which, int opcode) {\n+        return compilerToVM().lookupKlassRefIndexInPool(this, which, opcode);\n@@ -722,2 +700,10 @@\n-        final int cpci = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n-        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, cpci, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n+        int which; \/\/ interpretation depends on opcode\n+        if (opcode == Bytecodes.INVOKEDYNAMIC) {\n+            if (!isInvokedynamicIndex(rawIndex)) {\n+                throw new IllegalArgumentException(\"expected a raw index for INVOKEDYNAMIC but got \" + rawIndex);\n+            }\n+            which = rawIndex;\n+        } else {\n+            which = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);\n+        }\n+        final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, which, (byte) opcode, (HotSpotResolvedJavaMethodImpl) caller);\n@@ -728,2 +714,2 @@\n-            String name = getNameOf(cpci, opcode);\n-            HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(cpci, opcode));\n+            String name = compilerToVM().lookupNameInPool(this, which, opcode);\n+            HotSpotSignature signature = new HotSpotSignature(runtime(), compilerToVM().lookupSignatureInPool(this, which, opcode));\n@@ -733,1 +719,1 @@\n-                final int klassIndex = getKlassRefIndexAt(cpci, opcode);\n+                final int klassIndex = getKlassRefIndexAt(which, opcode);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":17,"deletions":31,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -163,0 +163,5 @@\n+    \/\/ We never call this method, so its indy is never resolved.\n+    static String concatString3_never_call(String a, String b) {\n+        return a + b;\n+    }\n+\n@@ -187,1 +192,1 @@\n-    public void lookupAppendixTest_dynamic(String methodName) throws Exception {\n+    private void lookupAppendixTest_dynamic(String methodName) throws Exception {\n@@ -212,1 +217,1 @@\n-    public void lookupAppendixTest_virtual() throws Exception {\n+    private void lookupAppendixTest_virtual() throws Exception {\n@@ -236,0 +241,87 @@\n+\n+    static void invokeVirtual(Object o) {\n+        o.hashCode();\n+    }\n+\n+    @Test\n+    public void lookupMethodTest_dynamic() throws Exception {\n+        concatString1(\"aaa\", \"bbb\"); \/\/ force the indy to be resolved\n+\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\");\n+        ResolvedJavaMethod m = type.findMethod(\"concatString1\", methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected:\n+        \/\/ aload_0;\n+        \/\/ aload_1;\n+        \/\/ invokedynamic ...StringConcatFactory.makeConcatWithConstants...\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(8, bytecode.length);\n+        Assert.assertEquals(ALOAD_0, beU1(bytecode, 0));\n+        Assert.assertEquals(ALOAD_1, beU1(bytecode, 1));\n+        Assert.assertEquals(INVOKEDYNAMIC, beU1(bytecode, 2));\n+\n+        \/\/ Note: internally HotSpot stores the indy index as a native int32, but m.getCode() byte-swaps all such\n+        \/\/ indices so they appear to be big-endian.\n+        int rawIndex = beS4(bytecode, 3);\n+        System.out.println(\"rawIndex = \" + rawIndex);\n+        JavaMethod callee = m.getConstantPool().lookupMethod(rawIndex, INVOKEDYNAMIC, \/*caller=*\/m);\n+        System.out.println(\"callee = \" + callee);\n+        Assert.assertTrue(callee.toString().equals(\"HotSpotMethod<Invokers$Holder.linkToTargetMethod(Object, Object, Object)>\"),\n+                          \"wrong method: \" + callee);\n+    }\n+\n+    @Test\n+    public void lookupMethodTest_dynamic_unresolved() throws Exception {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\");\n+        ResolvedJavaMethod m = type.findMethod(\"concatString3_never_call\", methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected:\n+        \/\/ aload_0;\n+        \/\/ aload_1;\n+        \/\/ invokedynamic ...StringConcatFactory.makeConcatWithConstants...\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(8, bytecode.length);\n+        Assert.assertEquals(ALOAD_0, beU1(bytecode, 0));\n+        Assert.assertEquals(ALOAD_1, beU1(bytecode, 1));\n+        Assert.assertEquals(INVOKEDYNAMIC, beU1(bytecode, 2));\n+\n+        \/\/ Note: internally HotSpot stores the indy index as a native int32, but m.getCode() byte-swaps all such\n+        \/\/ indices so they appear to be big-endian.\n+        int rawIndex = beS4(bytecode, 3);\n+        System.out.println(\"rawIndex = \" + rawIndex);\n+        JavaMethod callee = m.getConstantPool().lookupMethod(rawIndex, INVOKEDYNAMIC, \/*caller=*\/m);\n+        System.out.println(\"callee = \" + callee);\n+        Assert.assertTrue(callee.toString().startsWith(\"jdk.vm.ci.meta.UnresolvedJavaMethod\"),\n+                          \"wrong method: \" + callee);\n+    }\n+\n+    @Test\n+    public void lookupMethodTest_virtual() throws Exception {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType type = metaAccess.lookupJavaType(ConstantPoolTest.class);\n+        Signature methodSig = metaAccess.parseMethodDescriptor(\"(Ljava\/lang\/Object;)V\");\n+        ResolvedJavaMethod m = type.findMethod(\"invokeVirtual\", methodSig);\n+        Assert.assertNotNull(m);\n+\n+        \/\/ Expected\n+        \/\/ 0: aload_0\n+        \/\/ 1: invokevirtual #rawIndex \/\/ Method Method java\/lang\/Object.hashCode:()I\n+        byte[] bytecode = m.getCode();\n+        Assert.assertNotNull(bytecode);\n+        Assert.assertEquals(ALOAD_0, beU1(bytecode, 0));\n+        Assert.assertEquals(INVOKEVIRTUAL, beU1(bytecode, 1));\n+        int rawIndex = beU2(bytecode, 2);\n+        System.out.println(\"rawIndex = \" + rawIndex);\n+        JavaMethod callee = m.getConstantPool().lookupMethod(rawIndex, INVOKEVIRTUAL, \/*caller=*\/m);\n+        System.out.println(\"callee = \" + callee);\n+        Assert.assertTrue(callee.toString().equals(\"HotSpotMethod<Object.hashCode()>\"),\n+                          \"wrong method: \" + callee);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/ConstantPoolTest.java","additions":94,"deletions":2,"binary":false,"changes":96,"status":"modified"}]}