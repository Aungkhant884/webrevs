{"files":[{"patch":"@@ -186,1 +186,0 @@\n-      biasedLocking.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3770,4 +3770,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3844,4 +3840,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -8869,5 +8861,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3278,2 +3278,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2580,4 +2580,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -2586,1 +2582,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -334,5 +334,0 @@\n-  \/\/ Need a scratch register for biased locking\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -347,1 +342,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -64,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -85,5 +84,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n-  }\n-\n@@ -125,4 +119,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-    addmw(Address(rscratch2, 0), 1, rscratch1);\n-  }\n@@ -139,6 +129,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -150,4 +134,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -182,7 +164,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -63,1 +62,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -757,4 +756,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, done, &slow_case);\n-    }\n-\n@@ -772,11 +767,1 @@\n-    if (PrintBiasedLockingStatistics) {\n-      Label fast;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, fast, &fail);\n-      bind(fast);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-      b(done);\n-      bind(fail);\n-    } else {\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n-    }\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n@@ -819,6 +804,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      br(Assembler::NE, slow_case);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-    }\n@@ -875,4 +854,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3838,5 +3665,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":178,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -108,14 +108,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg is killed.\n-  \/\/ tmp_reg must be supplied and must not be rscratch1 or rscratch2\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n-\n@@ -850,2 +836,0 @@\n-  void load_prototype_header(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1776,4 +1776,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1927,5 +1923,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3556,5 +3556,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5457,1 +5457,0 @@\n-    \/\/ used by biased locking only. Requires a membar.\n@@ -8957,1 +8956,0 @@\n-  predicate(!(UseBiasedLocking && !UseOptoBiasInlining));\n@@ -8969,16 +8967,0 @@\n-instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,\n-                                  iRegP scratch, iRegP scratch3) %{\n-  match(Set pcc (FastLock object box));\n-  predicate(UseBiasedLocking && !UseOptoBiasInlining);\n-\n-  effect(TEMP scratch, TEMP scratch2, TEMP scratch3);\n-  ins_cost(DEFAULT_COST*5);\n-\n-  format %{ \"FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);\n-  %}\n-  ins_pipe(long_memory_op);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    __ unlock_object(R2, R1, R0, Rtemp, *stub->entry());\n+    __ unlock_object(R2, R1, R0, *stub->entry());\n@@ -2432,2 +2432,0 @@\n-  Register tmp = op->scratch_opr()->is_illegal() ? noreg :\n-                 op->scratch_opr()->as_pointer_register();\n@@ -2439,1 +2437,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n@@ -2444,1 +2442,1 @@\n-    __ unlock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,8 +415,0 @@\n-  \/\/ Need a scratch register for biased locking on arm\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if(UseBiasedLocking) {\n-    scratch = new_pointer_register();\n-  } else {\n-    scratch = atomicLockOpr();\n-  }\n-\n@@ -429,1 +421,1 @@\n-  monitor_enter(obj.result(), lock, hdr, scratch,\n+  monitor_enter(obj.result(), lock, hdr, LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -93,5 +92,1 @@\n-  if(UseBiasedLocking && !len->is_valid()) {\n-    ldr(tmp, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    mov(tmp, (intptr_t)markWord::prototype().value());\n-  }\n+  mov(tmp, (intptr_t)markWord::prototype().value());\n@@ -190,3 +185,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj,\n-                                   Register disp_hdr, Register tmp1,\n-                                   Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -197,1 +190,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp1, tmp2);\n+  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n@@ -214,4 +207,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr\/*scratched*\/, tmp1, false, tmp2, done, slow_case);\n-  }\n-\n@@ -251,7 +240,0 @@\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics) {\n-    cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n@@ -263,5 +245,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj,\n-                                      Register disp_hdr, Register tmp,\n-                                      Label& slow_case) {\n-  \/\/ Note: this method is not using its 'tmp' argument\n-\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -276,5 +254,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n@@ -289,4 +262,2 @@\n-  if(!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, obj_offset));\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2, Register scratch3) {\n+void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2) {\n@@ -100,8 +100,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    assert(scratch3 != noreg, \"need extra temporary for -XX:-UseOptoBiasInlining\");\n-    biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);\n-    \/\/ Fall through if lock not biased otherwise branch to done\n-  }\n-\n-  \/\/ Invariant: Rmark loaded below does not contain biased lock pattern\n-\n@@ -151,4 +143,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(Roop, Rscratch, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  void fast_lock(Register obj, Register box, Register scratch, Register scratch2, Register scratch3 = noreg);\n+  void fast_lock(Register obj, Register box, Register scratch, Register scratch2);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -893,5 +892,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(Robj, Rmark\/*scratched*\/, R0, false, Rtemp, done, slow_case);\n-    }\n-\n-\n@@ -915,6 +909,0 @@\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/!PRODUCT\n-\n@@ -965,7 +953,0 @@\n-\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(eq, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/ !PRODUCT\n-\n@@ -1013,4 +994,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(Robj, Rmark, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1291,215 +1290,0 @@\n-\n-\/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-\/\/ The slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-void MacroAssembler::biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                                 Register tmp, Label& slow_case, int* counter_addr) {\n-\n-  cas_for_lock_acquire(old_mark_reg, new_mark_reg, obj_reg, tmp, slow_case);\n-#ifdef ASSERT\n-  breakpoint(ne); \/\/ Fallthrough only on success\n-#endif\n-#ifndef PRODUCT\n-  if (counter_addr != NULL) {\n-    cond_atomic_inc32(al, counter_addr);\n-  }\n-#endif \/\/ !PRODUCT\n-}\n-\n-void MacroAssembler::biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Register tmp2,\n-                                          Label& done, Label& slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  \/\/ obj_reg must be preserved (at least) if the bias locking fails\n-  \/\/ tmp_reg is a temporary register\n-  \/\/ swap_reg was used as a temporary but contained a value\n-  \/\/   that was used afterwards in some call pathes. Callers\n-  \/\/   have been fixed so that swap_reg no longer needs to be\n-  \/\/   saved.\n-  \/\/ Rtemp in no longer scratched\n-\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);\n-  guarantee(swap_reg!=tmp_reg, \"invariant\");\n-  assert(tmp_reg != noreg, \"must supply tmp_reg\");\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics && (counters == NULL)) {\n-    counters = BiasedLocking::counters();\n-  }\n-#endif\n-\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-\n-  \/\/ On MP platform loads could return 'stale' values in some cases.\n-  \/\/ That is acceptable since either CAS or slow case path is taken in the worst case.\n-\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-\n-  b(cas_label, ne);\n-\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_klass(tmp_reg, obj_reg);\n-  ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));\n-  orr(tmp_reg, tmp_reg, Rthread);\n-  eor(tmp_reg, tmp_reg, swap_reg);\n-\n-  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n-\n-#ifndef PRODUCT\n-  if (counters != NULL) {\n-    cond_atomic_inc32(eq, counters->biased_lock_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  b(done, eq);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  tst(tmp_reg, markWord::biased_lock_mask_in_place);\n-  b(try_revoke_bias, ne);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  tst(tmp_reg, markWord::epoch_mask_in_place);\n-  b(try_rebias, ne);\n-\n-  \/\/ tmp_reg has the age, epoch and pattern bits cleared\n-  \/\/ The remaining (owner) bits are (Thread ^ current_owner)\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-\n-  \/\/ Note that we know the owner is not ourself. Hence, success can\n-  \/\/ only happen when the owner bits is 0\n-\n-  \/\/ until the assembler can be made smarter, we need to make some assumptions about the values\n-  \/\/ so we can optimize this:\n-  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n-\n-  mov(swap_reg, AsmOperand(swap_reg, lsl, 23));\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n-\n-  orr(tmp_reg, swap_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->anonymously_biased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_rebias);\n-\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Set them to Rthread.\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  orr(tmp_reg, tmp_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->rebiased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Clear them\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, cas_label,\n-        (counters != NULL) ? counters->revoked_lock_entry_count_addr() : NULL);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-\n-  bind(cas_label);\n-}\n-\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-  andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-  b(done, eq);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":216,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -362,23 +360,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be supplied.\n-  \/\/ tmp_reg must be supplied.\n-  \/\/ Done label is branched to with condition code EQ set if the lock is\n-  \/\/ biased and we acquired it. Slow case label is branched to with\n-  \/\/ condition code NE set if the lock is biased but we failed to acquire\n-  \/\/ it. Otherwise fall through.\n-  \/\/ Notes:\n-  \/\/ - swap_reg and tmp_reg are scratched\n-  \/\/ - Rtemp was (implicitly) scratched and can now be specified as the tmp2\n-  void biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Register tmp2,\n-                            Label& done, Label& slow_case,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit(Register obj_reg, Register temp_reg, Label& done);\n-\n-  \/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-  \/\/ Optional slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-  void biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                     Register tmp, Label& slow_case, int* counter_addr);\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -865,5 +865,0 @@\n-    if (UseBiasedLocking) {\n-      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n-    }\n-\n@@ -1154,1 +1149,1 @@\n-  Label slow_lock, slow_lock_biased, lock_done, fast_lock;\n+  Label slow_lock, lock_done, fast_lock;\n@@ -1161,4 +1156,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_enter(sync_obj, tmp, disp_hdr\/*scratched*\/, false, Rtemp, lock_done, slow_lock_biased);\n-    }\n-\n@@ -1245,6 +1236,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_exit(sync_obj, Rtemp, unlock_done);\n-      \/\/ disp_hdr may not have been saved on entry with biased locking\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n@@ -1306,5 +1291,0 @@\n-    if(UseBiasedLocking) {\n-      __ bind(slow_lock_biased);\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3970,5 +3970,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,2 +97,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,13 +351,0 @@\n-\n-bool VM_Version::use_biased_locking() {\n-  get_os_cpu_info();\n-  \/\/ The cost of CAS on uniprocessor ARM v6 and later is low compared to the\n-  \/\/ overhead related to slightly longer Biased Locking execution path.\n-  \/\/ Testing shows no improvement when running with Biased Locking enabled\n-  \/\/ on an ARMv6 and higher uniprocessor systems.  The situation is different on\n-  \/\/ ARMv5 and MP systems.\n-  \/\/\n-  \/\/ Therefore the Biased Locking is enabled on ARMv5 and ARM MP only.\n-  \/\/\n-  return (!os::is_MP() && (arm_arch() > 5)) ? false : true;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -118,4 +117,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &slow_int);\n-  }\n-\n@@ -167,6 +162,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load the object out of the BasicObjectLock.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-    biased_locking_exit(CCR0, Roop, R0, done);\n-  }\n@@ -177,5 +166,4 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-  }\n+\n+  \/\/ Load object.\n+  ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -225,5 +213,1 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    ld(t1, in_bytes(Klass::prototype_header_offset()), klass);\n-  } else {\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -946,4 +946,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &slow_case);\n-    }\n-\n@@ -1051,7 +1047,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ The object address from the monitor is in object.\n-      ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-      biased_locking_exit(CCR0, object, displaced_header, free_slot);\n-    }\n-\n@@ -1073,1 +1062,1 @@\n-    if (!UseBiasedLocking) { ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor); }\n+    ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -2076,212 +2075,0 @@\n-\/\/ Supports temp2_reg = R0.\n-void MacroAssembler::biased_locking_enter(ConditionRegister cr_reg, Register obj_reg,\n-                                          Register mark_reg, Register temp_reg,\n-                                          Register temp2_reg, Label& done, Label* slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-#ifdef ASSERT\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-#endif\n-\n-  Label cas_label;\n-\n-  \/\/ Branch to done if fast path fails and no slow_case provided.\n-  Label *slow_case_int = (slow_case != NULL) ? slow_case : &done;\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::total_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-\n-  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  bne(cr_reg, cas_label);\n-\n-  load_klass(temp_reg, obj_reg);\n-\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, R16_thread, temp_reg);\n-  xorr(temp_reg, mark_reg, temp_reg);\n-  andr(temp_reg, temp_reg, temp2_reg);\n-  cmpdi(cr_reg, temp_reg, 0);\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::biased_lock_entry_count_addr());\n-    lwzx(mark_reg, temp2_reg);\n-    addi(mark_reg, mark_reg, 1);\n-    stwx(mark_reg, temp2_reg);\n-    \/\/ restore mark_reg\n-    ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-    bind(l);\n-  }\n-  beq(cr_reg, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp2_reg, 0);\n-  bne(cr_reg, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-\n-  int shift_amount = 64 - markWord::epoch_shift;\n-  \/\/ rotate epoch bits to right (little) end and set other bits to 0\n-  \/\/ [ big part | epoch | little part ] -> [ 0..0 | epoch ]\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n-  \/\/ branch if epoch bits are != 0, i.e. they differ, because the epoch has been incremented\n-  bne(CCR0, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n-                                markWord::age_mask_in_place |\n-                                markWord::epoch_mask_in_place));\n-  orr(temp_reg, R16_thread, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-           \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-           \/*where=*\/obj_reg,\n-           MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::anonymously_biased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  load_klass(temp_reg, obj_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp2_reg, R16_thread, temp2_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, temp2_reg, temp_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-                 noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_klass(temp_reg, obj_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp_reg, temp_reg, temp2_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n-  ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-    bind(l);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit (ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-\n-  ld(temp_reg, 0, mark_addr);\n-  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  beq(cr_reg, done);\n-}\n-\n@@ -2698,1 +2485,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2705,1 +2491,1 @@\n-  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -2723,4 +2509,4 @@\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);      \/\/ Reload in transaction, conflicts need to be tracked.\n-  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n-  beq(flag, DONE_LABEL);                                    \/\/ all done if unlocked\n+  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);   \/\/ Reload in transaction, conflicts need to be tracked.\n+  andi(R0, mark_word, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);             \/\/ bits = 01 unlocked\n+  beq(flag, DONE_LABEL);                                 \/\/ all done if unlocked\n@@ -2840,1 +2626,0 @@\n-                                               bool try_bias,\n@@ -2861,4 +2646,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(flag, oop, displaced_header, temp, current_header, cont);\n-  }\n-\n@@ -2967,1 +2748,1 @@\n-                                                 bool try_bias, bool use_rtm) {\n+                                                 bool use_rtm) {\n@@ -2973,4 +2754,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(flag, oop, current_header, cont);\n-  }\n-\n@@ -2979,1 +2756,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2981,6 +2757,6 @@\n-    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);      \/\/ fetch markword\n-    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n-    bne(flag, L_regular_unlock);                                   \/\/ else RegularLock\n-    tend_();                                                       \/\/ otherwise end...\n-    b(cont);                                                       \/\/ ... and we're done\n+    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);   \/\/ fetch markword\n+    andi(R0, current_header, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                  \/\/ bits = 01 unlocked\n+    bne(flag, L_regular_unlock);                                \/\/ else RegularLock\n+    tend_();                                                    \/\/ otherwise end...\n+    b(cont);                                                    \/\/ ... and we're done\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":12,"deletions":236,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -592,18 +592,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(ConditionRegister cr_reg, Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done);\n-\n@@ -658,1 +640,0 @@\n-                                 bool try_bias = UseBiasedLocking,\n@@ -666,1 +647,1 @@\n-                                   bool try_bias = UseBiasedLocking, bool use_rtm = false);\n+                                   bool use_rtm = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -12120,2 +12120,1 @@\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0,\n-                                 UseBiasedLocking && !UseOptoBiasInlining);\n+                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n@@ -12139,1 +12138,0 @@\n-                                 \/*Biased Locking*\/ false,\n@@ -12142,1 +12140,1 @@\n-                                 \/*TM*\/ true, ra_->C->profile_rtm());\n+                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n@@ -12159,1 +12157,0 @@\n-                                   UseBiasedLocking && !UseOptoBiasInlining,\n@@ -12177,1 +12174,1 @@\n-                                   \/*Biased Locking*\/ false, \/*TM*\/ true);\n+                                   \/*RTM*\/ true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2157,8 +2157,0 @@\n-#   ifdef ASSERT\n-    if (UseBiasedLocking) {\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ std(r_box, 0, r_box);\n-    }\n-#   endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3796,5 +3796,1 @@\n-    if (UseBiasedLocking) {\n-      __ ld(Rscratch, in_bytes(Klass::prototype_header_offset()), RinstanceKlass);\n-    } else {\n-      __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n-    }\n+    __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,5 +381,1 @@\n-    \/\/ If CPU or OS do not support TM:\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n+    \/\/ If CPU or OS do not support RTM:\n@@ -402,2 +398,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -547,21 +541,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention. With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -96,3 +96,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -100,4 +99,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr, Z_R1_scratch, Z_R0_scratch, done, &slow_case);\n-  }\n-\n@@ -113,7 +108,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Unimplemented();\n-#if 0\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-#endif\n-  }\n@@ -153,6 +141,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -163,4 +145,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ Load object.\n+  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -196,7 +176,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1);\n-    z_lg(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t.\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t.\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1008,4 +1007,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(object, displaced_header, Z_R1, Z_R0, done, &slow_case);\n-  }\n-\n@@ -1119,6 +1114,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ The object address from the monitor is in object.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    biased_locking_exit(object, displaced_header, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3131,188 +3130,1 @@\n-\/\/ Semantics are dependent on the slow_case label:\n-\/\/   If the slow_case label is not NULL, failure to biased-lock the object\n-\/\/   transfers control to the location of the slow_case label. If the\n-\/\/   object could be biased-locked, control is transferred to the done label.\n-\/\/   The condition code is unpredictable.\n-\/\/\n-\/\/   If the slow_case label is NULL, failure to biased-lock the object results\n-\/\/   in a transfer of control to the done label with a condition code of not_equal.\n-\/\/   If the biased-lock could be successfully obtained, control is transfered to\n-\/\/   the done label with a condition code of equal.\n-\/\/   It is mandatory to react on the condition code At the done label.\n-\/\/\n-void MacroAssembler::biased_locking_enter(Register  obj_reg,\n-                                          Register  mark_reg,\n-                                          Register  temp_reg,\n-                                          Register  temp2_reg,    \/\/ May be Z_RO!\n-                                          Label    &done,\n-                                          Label    *slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-\n-  Label cas_label; \/\/ Try, if implemented, CAS locking. Fall thru to slow path otherwise.\n-\n-  BLOCK_COMMENT(\"biased_locking_enter {\");\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid.\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits.\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-  z_lr(temp_reg, mark_reg);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_brne(cas_label);  \/\/ Try cas if object is not biased, i.e. cannot be biased locked.\n-\n-  load_prototype_header(temp_reg, obj_reg);\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-\n-  z_ogr(temp_reg, Z_thread);\n-  z_xgr(temp_reg, mark_reg);\n-  z_ngr(temp_reg, temp2_reg);\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);\n-    \/\/ Restore mark_reg.\n-    z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-  }\n-  branch_optimized(Assembler::bcondEqual, done);  \/\/ Biased lock obtained, return success.\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-  Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_brnaz(try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n-  z_brnaz(try_rebias);\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n-         markWord::epoch_mask_in_place);\n-  z_lgr(temp_reg, Z_thread);\n-  z_llgfr(mark_reg, mark_reg);\n-  z_ogr(temp_reg, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),\n-                         temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case); \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  branch_optimized(Assembler::bcondAlways, done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-  load_prototype_header(temp_reg, obj_reg);\n-  z_llgfr(mark_reg, mark_reg);\n-\n-  z_ogr(temp_reg, Z_thread);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case);  \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  z_bru(done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_prototype_header(temp_reg, obj_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    \/\/ z_cgr(mark_reg, temp2_reg);\n-    increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-\n-  bind(cas_label);\n-  BLOCK_COMMENT(\"} biased_locking_enter\");\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  BLOCK_COMMENT(\"biased_locking_exit {\");\n-\n-  z_lg(temp_reg, 0, mark_addr);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_bre(done);\n-  BLOCK_COMMENT(\"} biased_locking_exit\");\n-}\n-\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3337,4 +3149,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);\n-  }\n-\n@@ -3405,1 +3213,1 @@\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3415,4 +3223,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(oop, currentHeader, done);\n-  }\n-\n@@ -3836,6 +3640,0 @@\n-void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {\n-  assert_different_registers(Rheader, Rsrc_oop);\n-  load_klass(Rheader, Rsrc_oop);\n-  z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":204,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -721,20 +721,3 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(Register mark_addr, Register temp_reg, Label& done);\n-\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n+\n+  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n+  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n@@ -785,1 +768,0 @@\n-  void load_prototype_header(Register Rheader, Register Rsrc_oop);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -9812,2 +9812,1 @@\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                             UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n@@ -9821,1 +9820,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);  \/\/ emitted code depends on UseBiasedLocking being on\/off.\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n@@ -9823,2 +9822,1 @@\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                               UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1876,7 +1876,0 @@\n-#ifdef ASSERT\n-    if (UseBiasedLocking)\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ z_stg(r_box, 0, r_box);\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3816,8 +3816,2 @@\n-    if (UseBiasedLocking) {\n-      Register prototype = RobjectFields;\n-      __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));\n-      __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));\n-    } else {\n-      __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n-                     (long)markWord::prototype().value());\n-    }\n+    __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n+                   (long)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3515,4 +3515,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -3521,1 +3517,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -291,5 +291,0 @@\n-  \/\/ Need a scratch register for biased locking on x86\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -304,1 +299,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -41,1 +40,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -64,5 +63,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n-  }\n-\n@@ -81,4 +75,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-  }\n@@ -119,6 +109,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -131,4 +115,3 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -162,8 +145,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -54,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -237,1 +236,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -247,1 +245,1 @@\n-  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -262,2 +260,2 @@\n-  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);         \/\/ bits = 01 unlocked\n@@ -450,1 +448,0 @@\n-                                 BiasedLockingCounters* counters,\n@@ -465,4 +462,0 @@\n-  if (counters != NULL) {\n-    atomic_incl(ExternalAddress((address)counters->total_entry_count_addr()), scrReg);\n-  }\n-\n@@ -476,3 +469,0 @@\n-  \/\/ * biased\n-  \/\/    -- by Self\n-  \/\/    -- by other\n@@ -496,10 +486,0 @@\n-  \/\/ it's stack-locked, biased or neutral\n-  \/\/ TODO: optimize away redundant LDs of obj->mark and improve the markword triage\n-  \/\/ order to reduce the number of conditional branches in the most common cases.\n-  \/\/ Beware -- there's a subtle invariant that fetch of the markword\n-  \/\/ at [FETCH], below, will never observe a biased encoding (*101b).\n-  \/\/ If this invariant is not held we risk exclusion (safety) failure.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_enter(boxReg, objReg, tmpReg, scrReg, cx1Reg, false, DONE_LABEL, NULL, counters);\n-  }\n-\n@@ -515,1 +495,1 @@\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n@@ -523,4 +503,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -536,4 +512,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -662,6 +634,0 @@\n-  \/\/ Critically, the biased locking test must have precedence over\n-  \/\/ and appear before the (box->dhw == 0) recursive stack-lock test.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(objReg, tmpReg, DONE_LABEL);\n-  }\n-\n@@ -670,1 +636,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -673,2 +638,2 @@\n-    andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n-    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+    andptr(tmpReg, markWord::lock_mask_in_place);                     \/\/ look at 2 lock bits\n+    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 01 unlocked\n@@ -741,1 +706,1 @@\n-  \/\/ It's not inflated and it's not recursively stack-locked and it's not biased.\n+  \/\/ It's not inflated and it's not recursively stack-locked.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":42,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-                 BiasedLockingCounters* counters,\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1208,2 +1207,1 @@\n-    const Register tmp_reg = rbx; \/\/ Will be passed to biased_locking_enter to avoid a\n-                                  \/\/ problematic case where tmp_reg = no_reg.\n+    const Register tmp_reg = rbx;\n@@ -1230,4 +1228,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);\n-    }\n-\n@@ -1248,4 +1242,0 @@\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1288,5 +1278,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1344,4 +1329,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1283,194 +1282,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          Register tmp_reg2,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert(swap_reg == rax, \"swap_reg must be rax for cmpxchgq\");\n-  assert(tmp_reg != noreg, \"tmp_reg must be supplied\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  NOT_LP64( Address saved_mark_addr(lock_reg, 0); )\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL) {\n-    counters = BiasedLocking::counters();\n-  }\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    movptr(swap_reg, mark_addr);\n-  }\n-  movptr(tmp_reg, swap_reg);\n-  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::notEqual, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-#ifndef _LP64\n-  \/\/ Note that because there is no current thread register on x86_32 we\n-  \/\/ need to store off the mark word we read out of the object to\n-  \/\/ avoid reloading it and needing to recheck invariants below. This\n-  \/\/ store is unfortunate but it makes the overall code shorter and\n-  \/\/ simpler.\n-  movptr(saved_mark_addr, swap_reg);\n-#endif\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-  xorptr(tmp_reg, swap_reg);\n-  Register header_reg = tmp_reg;\n-#else\n-  xorptr(tmp_reg, swap_reg);\n-  get_thread(swap_reg);\n-  xorptr(swap_reg, tmp_reg);\n-  Register header_reg = swap_reg;\n-#endif\n-  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->biased_lock_entry_count_addr()));\n-  }\n-  jcc(Assembler::equal, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  testptr(header_reg, markWord::biased_lock_mask_in_place);\n-  jcc(Assembler::notZero, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  testptr(header_reg, markWord::epoch_mask_in_place);\n-  jccb(Assembler::notZero, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  andptr(swap_reg,\n-         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-#ifdef _LP64\n-  movptr(tmp_reg, swap_reg);\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(tmp_reg);\n-  orptr(tmp_reg, swap_reg);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->anonymously_biased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(swap_reg);\n-  orptr(tmp_reg, swap_reg);\n-  movptr(swap_reg, saved_mark_addr);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->rebiased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->revoked_lock_entry_count_addr()));\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::equal, done);\n-}\n-\n@@ -4735,5 +4540,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n-  load_klass(dst, src, tmp);\n-  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":200,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -359,2 +359,0 @@\n-  void load_prototype_header(Register dst, Register src, Register tmp);\n-\n@@ -676,15 +674,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be rax, and is killed.\n-  \/\/ tmp_reg is optional. If it is supplied (i.e., != noreg) it will\n-  \/\/ be killed; if not supplied, push\/pop will be used internally to\n-  \/\/ allocate a temporary (inefficient, avoid if possible).\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            Register tmp_reg2, bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Check if biased and fall through to runtime if so\n-    __ testptr(result, markWord::biased_lock_bit_in_place);\n-    __ jcc(Assembler::notZero, slowCase);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1826,5 +1826,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ Note that oop_handle_reg is trashed during this call\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1863,5 +1858,0 @@\n-\n-    if (UseBiasedLocking) {\n-      \/\/ Re-fetch oop_handle_reg as we trashed it above\n-      __ movptr(oop_handle_reg, Address(rsp, wordSize));\n-    }\n@@ -1996,4 +1986,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, rbx, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2073,4 +2073,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -2227,5 +2223,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4026,9 +4026,3 @@\n-    if (UseBiasedLocking) {\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-    } else {\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),\n-                (intptr_t)markWord::prototype().value()); \/\/ header\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-    }\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+              (intptr_t)markWord::prototype().value()); \/\/ header\n+    __ pop(rcx);   \/\/ get saved klass back in the register.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1015,4 +1015,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n@@ -1026,2 +1022,0 @@\n-      \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-      \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1065,2 +1059,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1739,21 +1731,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention.  With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -750,3 +750,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -13670,1 +13670,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -13685,1 +13685,1 @@\n-                 $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -12910,1 +12910,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -12925,1 +12925,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  AD.addInclude(AD._CPP_file, \"runtime\/biasedLocking.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1529,1 +1529,0 @@\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_counters = _counters;\\n\", cnt);\n@@ -3944,1 +3943,0 @@\n-    fprintf(fp_cpp, \"%s node->_counters = _leaf->as_FastLock()->counters();\\n\", indent);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -140,2 +140,0 @@\n-  assert(!p->mark().has_bias_pattern(),\n-         \"this object should never have been locked\");  \/\/ so identity_hash won't safepoin\n@@ -419,5 +417,1 @@\n-    if (UseBiasedLocking) {\n-      oopDesc::set_mark(mem, k->prototype_header());\n-    } else {\n-      oopDesc::set_mark(mem, markWord::prototype());\n-    }\n+    oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2084,1 +2084,0 @@\n-      ik->set_prototype_header(markWord::prototype());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,2 +272,1 @@\n-  \/\/ locate the owner and stack slot for the BasicLock so that we can\n-  \/\/ properly revoke the bias of the owner if necessary. They are\n+  \/\/ locate the owner and stack slot for the BasicLock. They are\n@@ -278,5 +277,2 @@\n-  \/\/ sharing between platforms. Note that currently biased locking\n-  \/\/ will never cause Class instances to be biased but this code\n-  \/\/ handles the static synchronized case as well.\n-  \/\/ JVMTI's GetLocalInstance() also uses these offsets to find the receiver\n-  \/\/ for non-static native wrapper frames.\n+  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+  \/\/ offsets to find the receiver for non-static native wrapper frames.\n@@ -739,1 +735,1 @@\n-  \/\/ UseBiasedLocking support\n+  \/\/ JVMTI's GetLocalInstance() support\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -189,4 +188,0 @@\n-  \/\/ We should save the marks of the currently locked biased monitors.\n-  \/\/ The marking doesn't preserve the marks of biased objects.\n-  BiasedLocking::preserve_marks();\n-\n@@ -219,2 +214,0 @@\n-  BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,4 +111,1 @@\n-      \/\/ since it will be restored by preserved marks. There is an exception\n-      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n-      \/\/ even if the mark-word is used. This is no problem since\n-      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      \/\/ since it will be restored by preserved marks.\n@@ -119,3 +116,2 @@\n-      assert(object->mark() == markWord::prototype_for_klass(object->klass()) || \/\/ Correct mark\n-             object->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-             (UseBiasedLocking && object->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n+             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -123,1 +119,1 @@\n-             p2i(object), object->mark().value(), markWord::prototype_for_klass(object->klass()).value());\n+             p2i(object), object->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,3 +83,2 @@\n-    assert(obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ Correct mark\n-           obj->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-           (UseBiasedLocking && obj->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n+           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -87,1 +86,1 @@\n-           p2i(obj), obj->mark().value(), markWord::prototype_for_klass(obj->klass()).value());\n+           p2i(obj), obj->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -86,3 +86,1 @@\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark().has_bias_pattern()),\n-           \/\/ not gc marked?\n+           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -442,2 +441,1 @@\n-                                          bool is_tlab, bool run_verification, bool clear_soft_refs,\n-                                          bool restore_marks_for_biased_locking) {\n+                                          bool is_tlab, bool run_verification, bool clear_soft_refs) {\n@@ -464,8 +462,0 @@\n-  if (restore_marks_for_biased_locking) {\n-    \/\/ We perform this mark word preservation work lazily\n-    \/\/ because it's only at this point that we know whether we\n-    \/\/ absolutely have to do it; we want to avoid doing it for\n-    \/\/ scavenge-only collections where it's unnecessary\n-    BiasedLocking::preserve_marks();\n-  }\n-\n@@ -575,2 +565,1 @@\n-                       do_clear_all_soft_refs,\n-                       false);\n+                       do_clear_all_soft_refs);\n@@ -635,2 +624,1 @@\n-                       do_clear_all_soft_refs,\n-                       true);\n+                       do_clear_all_soft_refs);\n@@ -658,2 +646,0 @@\n-    BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,1 @@\n-                          bool run_verification, bool clear_soft_refs,\n-                          bool restore_marks_for_biased_locking);\n+                          bool run_verification, bool clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -385,6 +385,2 @@\n-  if (UseBiasedLocking) {\n-    oopDesc::set_mark(mem, _klass->prototype_header());\n-  } else {\n-    \/\/ May be bootstrapping\n-    oopDesc::set_mark(mem, markWord::prototype());\n-  }\n+  \/\/ May be bootstrapping\n+  oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -185,1 +184,0 @@\n-    BiasedLocking::preserve_marks();\n@@ -233,1 +231,0 @@\n-    BiasedLocking::restore_marks();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -730,3 +729,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -1037,21 +1033,0 @@\n-\n-  if (osr_nm != NULL) {\n-    \/\/ We may need to do on-stack replacement which requires that no\n-    \/\/ monitors in the activation are biased because their\n-    \/\/ BasicObjectLocks will need to migrate during OSR. Force\n-    \/\/ unbiasing of all monitors in the activation now (even though\n-    \/\/ the OSR nmethod might be invalidated) because we don't have a\n-    \/\/ safepoint opportunity later once the migration begins.\n-    if (UseBiasedLocking) {\n-      ResourceMark rm;\n-      GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-      for( BasicObjectLock *kptr = last_frame.monitor_end();\n-           kptr < last_frame.monitor_begin();\n-           kptr = last_frame.next_monitor(kptr) ) {\n-        if( kptr->obj() != NULL ) {\n-          objects_to_revoke->append(Handle(current, kptr->obj()));\n-        }\n-      }\n-      BiasedLocking::revoke(objects_to_revoke, current);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -579,1 +579,0 @@\n-        \/\/ Monitor not filled in frame manager any longer as this caused race condition with biased locking.\n@@ -583,2 +582,0 @@\n-        assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -679,2 +676,0 @@\n-      assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1522,2 +1517,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1556,2 +1549,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1880,1 +1871,0 @@\n-              assert(!UseBiasedLocking, \"Not implemented\");\n@@ -2686,2 +2676,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -2754,2 +2742,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,19 +73,0 @@\n-  <Event name=\"BiasedLockRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Revocation\" description=\"Revoked bias of object\" thread=\"true\"\n-    stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-    <Field type=\"Thread\" name=\"previousOwner\" label=\"Previous Owner\" description=\"Thread owning the bias before revocation\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockSelfRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Self Revocation\" description=\"Revoked bias of object biased towards own thread\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockClassRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Class Revocation\" description=\"Revoked biases for all instances of a class\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"revokedClass\" label=\"Revoked Class\" description=\"Class whose biased locks were revoked\" \/>\n-    <Field type=\"boolean\" name=\"disableBiasing\" label=\"Disable Further Biasing\" description=\"Whether further biasing for instances of this class will be allowed\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-  <\/Event>\n-\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  do_bool_flag(UseBiasedLocking)                                           \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -651,1 +650,0 @@\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n@@ -653,1 +651,0 @@\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -658,1 +655,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  LOG_TAG(biasedlocking) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -511,6 +510,0 @@\n-\n-  \/\/ Set biased locking bit for all instances of this class; it will be\n-  \/\/ cleared if revocation occurs too often for this type\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n@@ -2533,5 +2526,0 @@\n-  \/\/ Initialize current biased locking state.\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n-\n@@ -2541,1 +2529,0 @@\n-    set_prototype_header(markWord::prototype());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-                           _prototype_header(markWord::prototype()),\n@@ -715,4 +714,0 @@\n-int Klass::atomic_incr_biased_lock_revocation_count() {\n-  return (int) Atomic::add(&_biased_lock_revocation_count, 1);\n-}\n-\n@@ -747,2 +742,0 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -162,6 +162,0 @@\n-  \/\/ Biased locking implementation and statistics\n-  \/\/ (the 64-bit chunk goes first, to avoid some fragmentation)\n-  jlong    _last_biased_lock_bulk_revocation_time;\n-  markWord _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n-  jint     _biased_lock_revocation_count;\n-\n@@ -648,24 +642,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Note: the prototype header is always set up to be at least the\n-  \/\/ prototype markWord. If biased locking is enabled it may further be\n-  \/\/ biasable and have an epoch.\n-  markWord prototype_header() const      { return _prototype_header; }\n-\n-  \/\/ NOTE: once instances of this klass are floating around in the\n-  \/\/ system, this header must only be updated at a safepoint.\n-  \/\/ NOTE 2: currently we only ever set the prototype header to the\n-  \/\/ biasable prototype for instanceKlasses. There is no technical\n-  \/\/ reason why it could not be done for arrayKlasses aside from\n-  \/\/ wanting to reduce the initial scope of this optimization. There\n-  \/\/ are potential problems in setting the bias pattern for\n-  \/\/ JVM-internal oops.\n-  inline void set_prototype_header(markWord header);\n-  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n-\n-  int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }\n-  \/\/ Atomically increments biased_lock_revocation_count and returns updated value\n-  int atomic_incr_biased_lock_revocation_count();\n-  void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }\n-  jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }\n-  void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-inline void Klass::set_prototype_header(markWord header) {\n-  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n-  _prototype_header = header;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-    \/\/ Biased bit is 3rd rightmost bit\n-    if (is_neutral()) {   \/\/ last bits = 001\n+    if (is_neutral()) {   \/\/ last bits = 01\n@@ -91,4 +90,0 @@\n-    } else if (has_bias_pattern()) {  \/\/ last bits = 101\n-      st->print(\"is_biased\");\n-      JavaThread* jt = biased_locker();\n-      st->print(\" biased_locker=\" INTPTR_FORMAT \" epoch=%d\", p2i(jt), bias_epoch());\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,1 @@\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n@@ -44,2 +43,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n@@ -52,28 +50,0 @@\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n@@ -83,1 +53,1 @@\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [header          | 01]  unlocked           regular object header\n@@ -131,2 +101,2 @@\n-  static const int biased_lock_bits               = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;\n+  static const int first_unused_gap_bits          = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n@@ -134,2 +104,1 @@\n-  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n-  static const int epoch_bits                     = 2;\n+  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n@@ -137,2 +106,0 @@\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n@@ -140,5 +107,2 @@\n-  static const int biased_lock_shift              = lock_bits;\n-  static const int age_shift                      = lock_bits + biased_lock_bits;\n-  static const int unused_gap_shift               = age_shift + age_bits;\n-  static const int hash_shift                     = unused_gap_shift + unused_gap_bits;\n-  static const int epoch_shift                    = hash_shift;\n+  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n+  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n@@ -148,3 +112,0 @@\n-  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);\n-  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift;\n-  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift;\n@@ -153,3 +114,0 @@\n-  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);\n-  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\n-\n@@ -159,3 +117,0 @@\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  static const size_t biased_lock_alignment       = 2 << (epoch_shift + epoch_bits);\n-\n@@ -166,1 +121,0 @@\n-  static const uintptr_t biased_lock_pattern      = 5;\n@@ -174,2 +128,0 @@\n-  static const int max_bias_epoch                 = epoch_mask;\n-\n@@ -179,38 +131,0 @@\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markWord set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markWord incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markWord biased_locking_prototype() {\n-    return markWord( biased_lock_pattern );\n-  }\n-\n@@ -222,1 +136,1 @@\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n@@ -227,1 +141,3 @@\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+  bool is_neutral()  const {\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n+  }\n@@ -242,1 +158,3 @@\n-  inline bool must_be_preserved(const oopDesc* obj) const;\n+  bool must_be_preserved(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -246,16 +164,3 @@\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n+  bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -308,7 +213,0 @@\n-  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n-    uintptr_t tmp = (uintptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return markWord(tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n@@ -344,3 +242,0 @@\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markWord prototype_for_klass(const Klass* klass);\n-\n@@ -354,1 +249,1 @@\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":125,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n-#define SHARE_OOPS_MARKWORD_INLINE_HPP\n-\n-#include \"oops\/markWord.hpp\"\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    if (has_bias_pattern()) {\n-      \/\/ Will reset bias at end of collection\n-      \/\/ Mark words of biased and currently locked objects are preserved separately\n-      return false;\n-    }\n-    markWord prototype_header = prototype_for_klass(obj->klass());\n-    if (prototype_header.has_bias_pattern()) {\n-      \/\/ Individual instance which has its bias revoked; must return\n-      \/\/ true for correctness\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure during scavenge?\n-inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    \/\/ We don't explicitly save off the mark words of biased and\n-    \/\/ currently-locked objects during scavenges, so if during a\n-    \/\/ promotion failure we encounter either a biased mark word or a\n-    \/\/ klass which still has a biasable prototype header, we have to\n-    \/\/ preserve the mark word. This results in oversaving, but promotion\n-    \/\/ failures are rare, and this avoids adding more complex logic to\n-    \/\/ the scavengers to call new variants of\n-    \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-    \/\/ of a scavenge when a promotion failure has first been detected.\n-    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-inline markWord markWord::prototype_for_klass(const Klass* klass) {\n-  markWord prototype_header = klass->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-\n-  return prototype_header;\n-}\n-\n-#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -236,1 +236,0 @@\n-  inline bool has_bias_pattern() const;\n@@ -286,2 +285,0 @@\n-  \/\/ NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a\n-  \/\/ safepoint if called on a biased object. Calling code must be aware of that.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -78,1 +78,1 @@\n-  set_mark(markWord::prototype_for_klass(klass()));\n+  set_mark(markWord::prototype());\n@@ -257,4 +257,0 @@\n-bool oopDesc::has_bias_pattern() const {\n-  return mark().has_bias_pattern();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -451,4 +451,0 @@\n-  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n-          \"(Deprecated) Print per-lock-site statistics of biased locking \"  \\\n-          \"in JVM\")                                                         \\\n-                                                                            \\\n@@ -510,3 +506,0 @@\n-  product(bool, UseOptoBiasInlining, true,                                  \\\n-          \"(Deprecated) Generate biased locking code in C2 ideal graph\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1673,7 +1673,1 @@\n-  if (UseBiasedLocking && Opcode() == Op_Allocate) {\n-    Node* klass_node = in(AllocateNode::KlassNode);\n-    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n-    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n-  } else {\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n-  }\n+  mark_node = phase->MakeConX(markWord::prototype().value());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3498,4 +3498,0 @@\n-  if (UseBiasedLocking && PrintPreciseBiasedLockingStatistics) {\n-    \/\/ Create the counters for this fast lock.\n-    flock->create_lock_counter(sync_jvms()); \/\/ sync_jvms used to get current bci\n-  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3813,1 +3813,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,9 +161,0 @@\n-\/\/\n-\/\/ Create a counter which counts the number of times this lock is acquired\n-\/\/\n-void FastLockNode::create_lock_counter(JVMState* state) {\n-  BiasedLockingNamedCounter* blnc = (BiasedLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::BiasedLockingCounter);\n-  _counters = blnc->counters();\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class BiasedLockingCounters;\n@@ -77,1 +76,0 @@\n-  BiasedLockingCounters*        _counters;\n@@ -85,1 +83,0 @@\n-    _counters = NULL;\n@@ -102,1 +99,0 @@\n-  void create_lock_counter(JVMState* s);\n@@ -104,1 +100,0 @@\n-  BiasedLockingCounters*        counters() const { return _counters; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class BiasedLockingCounters;\n@@ -798,1 +797,0 @@\n-  BiasedLockingCounters*        _counters;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2167,80 +2167,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/*\n-     *  See the full description in MacroAssembler::biased_locking_enter().\n-     *\n-     *  if( (mark_word & biased_lock_mask) == biased_lock_pattern ) {\n-     *    \/\/ The object is biased.\n-     *    proto_node = klass->prototype_header;\n-     *    o_node = thread | proto_node;\n-     *    x_node = o_node ^ mark_word;\n-     *    if( (x_node & ~age_mask) == 0 ) { \/\/ Biased to the current thread ?\n-     *      \/\/ Done.\n-     *    } else {\n-     *      if( (x_node & biased_lock_mask) != 0 ) {\n-     *        \/\/ The klass's prototype header is no longer biased.\n-     *        cas(&mark_word, mark_word, proto_node)\n-     *        goto cas_lock;\n-     *      } else {\n-     *        \/\/ The klass's prototype header is still biased.\n-     *        if( (x_node & epoch_mask) != 0 ) { \/\/ Expired epoch?\n-     *          old = mark_word;\n-     *          new = o_node;\n-     *        } else {\n-     *          \/\/ Different thread or anonymous biased.\n-     *          old = mark_word & (epoch_mask | age_mask | biased_lock_mask);\n-     *          new = thread | old;\n-     *        }\n-     *        \/\/ Try to rebias.\n-     *        if( cas(&mark_word, old, new) == 0 ) {\n-     *          \/\/ Done.\n-     *        } else {\n-     *          goto slow_path; \/\/ Failed.\n-     *        }\n-     *      }\n-     *    }\n-     *  } else {\n-     *    \/\/ The object is not biased.\n-     *    cas_lock:\n-     *    if( FastLock(obj) == 0 ) {\n-     *      \/\/ Done.\n-     *    } else {\n-     *      slow_path:\n-     *      OptoRuntime::complete_monitor_locking_Java(obj);\n-     *    }\n-     *  }\n-     *\/\n-\n-    region  = new RegionNode(5);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    Node* fast_lock_region  = new RegionNode(3);\n-    Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ First, check mark word for the biased lock pattern.\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-\n-    \/\/ Get fast path - mark word has the biased lock pattern.\n-    ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern, true);\n-    \/\/ fast_lock_region->in(1) is set to slow path.\n-    fast_lock_mem_phi->init_req(1, mem);\n-\n-    \/\/ Now check that the lock is biased to the current thread and has\n-    \/\/ the same epoch and bias as Klass::_prototype_header.\n-\n-    \/\/ Special-case a fresh allocation to avoid building nodes:\n-    Node* klass_node = AllocateNode::Ideal_klass(obj, &_igvn);\n-    if (klass_node == NULL) {\n-      Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n-#ifdef _LP64\n-      if (UseCompressedClassPointers && klass_node->is_DecodeNKlass()) {\n-        assert(klass_node->in(1)->Opcode() == Op_LoadNKlass, \"sanity\");\n-        klass_node->in(1)->init_req(0, ctrl);\n-      } else\n-#endif\n-      klass_node->init_req(0, ctrl);\n-    }\n-    Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X->basic_type());\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -2248,109 +2171,3 @@\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));\n-    Node* x_node = transform_later(new XorXNode(o_node, mark_node));\n-\n-    \/\/ Get slow path - mark word does NOT match the value.\n-    STATIC_ASSERT(markWord::age_mask_in_place <= INT_MAX);\n-    Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,\n-                                      (~(int)markWord::age_mask_in_place), 0);\n-    \/\/ region->in(3) is set to fast path - the object is biased to the current thread.\n-    mem_phi->init_req(3, mem);\n-\n-\n-    \/\/ Mark word does NOT match the value (thread | Klass::_prototype_header).\n-\n-\n-    \/\/ First, check biased pattern.\n-    \/\/ Get fast path - _prototype_header has the same biased lock pattern.\n-    ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,\n-                          markWord::biased_lock_mask_in_place, 0, true);\n-\n-    not_biased_ctrl = fast_lock_region->in(2); \/\/ Slow path\n-    \/\/ fast_lock_region->in(2) - the prototype header is no longer biased\n-    \/\/ and we have to revoke the bias on this object.\n-    \/\/ We are going to try to reset the mark of this object to the prototype\n-    \/\/ value and fall through to the CAS-based locking scheme.\n-    Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-    Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,\n-                                          proto_node, mark_node);\n-    transform_later(cas);\n-    Node* proj = transform_later(new SCMemProjNode(cas));\n-    fast_lock_mem_phi->init_req(2, proj);\n-\n-\n-    \/\/ Second, check epoch bits.\n-    Node* rebiased_region  = new RegionNode(3);\n-    Node* old_phi = new PhiNode( rebiased_region, TypeX_X);\n-    Node* new_phi = new PhiNode( rebiased_region, TypeX_X);\n-\n-    \/\/ Get slow path - mark word does NOT match epoch bits.\n-    Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,\n-                                      markWord::epoch_mask_in_place, 0);\n-    \/\/ The epoch of the current bias is not valid, attempt to rebias the object\n-    \/\/ toward the current thread.\n-    rebiased_region->init_req(2, epoch_ctrl);\n-    old_phi->init_req(2, mark_node);\n-    new_phi->init_req(2, o_node);\n-\n-    \/\/ rebiased_region->in(1) is set to fast path.\n-    \/\/ The epoch of the current bias is still valid but we know\n-    \/\/ nothing about the owner; it might be set or it might be clear.\n-    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place |\n-                             markWord::epoch_mask_in_place);\n-    Node* old = transform_later(new AndXNode(mark_node, cmask));\n-    cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* new_mark = transform_later(new OrXNode(cast_thread, old));\n-    old_phi->init_req(1, old);\n-    new_phi->init_req(1, new_mark);\n-\n-    transform_later(rebiased_region);\n-    transform_later(old_phi);\n-    transform_later(new_phi);\n-\n-    \/\/ Try to acquire the bias of the object using an atomic operation.\n-    \/\/ If this fails we will go in to the runtime to revoke the object's bias.\n-    cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);\n-    transform_later(cas);\n-    proj = transform_later(new SCMemProjNode(cas));\n-\n-    \/\/ Get slow path - Failed to CAS.\n-    not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);\n-    mem_phi->init_req(4, proj);\n-    \/\/ region->in(4) is set to fast path - the object is rebiased to the current thread.\n-\n-    \/\/ Failed to CAS.\n-    slow_path  = new RegionNode(3);\n-    Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    slow_path->init_req(1, not_biased_ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(1, proj);\n-\n-    \/\/ Call CAS-based locking scheme (FastLock node).\n-\n-    transform_later(fast_lock_region);\n-    transform_later(fast_lock_mem_phi);\n-\n-    \/\/ Get slow path - FastLock failed to lock the object.\n-    ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, fast_lock_mem_phi);\n-    \/\/ region->in(2) is set to fast path - the object is locked to the current thread.\n-\n-    slow_path->init_req(2, ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(2, fast_lock_mem_phi);\n-\n-    transform_later(slow_path);\n-    transform_later(slow_mem);\n-    \/\/ Reset lock's memory edge.\n-    lock->set_req(TypeFunc::Memory, slow_mem);\n-\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Optimize test; set region slot 2\n-    slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, mem);\n-  }\n+  \/\/ Optimize test; set region slot 2\n+  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  mem_phi->init_req(2, mem);\n@@ -2406,17 +2223,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/\/ Check for biased locking unlock case, which is a no-op.\n-    \/\/ See the full description in MacroAssembler::biased_locking_exit().\n-    region  = new RegionNode(4);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-    mem_phi->init_req(3, mem);\n-\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    ctrl = opt_bits_test(ctrl, region, 3, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern);\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-  }\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":206,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2770,3 +2770,1 @@\n-    \/\/ With biased locking we're no longer guaranteed that a monitor\n-    \/\/ enter operation contains a serializing instruction.\n-    if ((xop == Op_FastLock) && !UseBiasedLocking) {\n+    if (xop == Op_FastLock) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1601,6 +1601,0 @@\n-    } else if (c->tag() == NamedCounter::BiasedLockingCounter) {\n-      BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)->counters();\n-      if (blc->nonzero()) {\n-        tty->print_cr(\"%s\", c->name());\n-        blc->print_on(tty);\n-      }\n@@ -1657,3 +1651,1 @@\n-  if (tag == NamedCounter::BiasedLockingCounter) {\n-    c = new BiasedLockingNamedCounter(st.as_string());\n-  } else if (tag == NamedCounter::RTMLockingCounter) {\n+  if (tag == NamedCounter::RTMLockingCounter) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -66,1 +65,0 @@\n-    BiasedLockingCounter,\n@@ -103,12 +101,0 @@\n-class BiasedLockingNamedCounter : public NamedCounter {\n- private:\n-  BiasedLockingCounters _counters;\n-\n- public:\n-  BiasedLockingNamedCounter(const char *n) :\n-    NamedCounter(n, BiasedLockingCounter), _counters() {}\n-\n-  BiasedLockingCounters* counters() { return &_counters; }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1877,3 +1877,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorLNode\n-#define StoreXConditionalNode StoreLConditionalNode\n+\/\/ For shenandoahSupport\n@@ -1925,3 +1923,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorINode\n-#define StoreXConditionalNode StoreIConditionalNode\n+\/\/ For shenandoahSupport\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -973,3 +972,0 @@\n-    \/\/ Revoke any biases before querying the mark word\n-    BiasedLocking::revoke_at_safepoint(hobj);\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1401,4 +1400,0 @@\n-\n-  if (UseBiasedLocking) {\n-    BiasedLocking::preserve_marks();\n-  }\n@@ -1427,4 +1422,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::restore_marks();\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2020,0 +2020,46 @@\n+WB_ENTRY(jboolean, WB_HandshakeReadMonitors(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class ReadMonitorsClosure : public HandshakeClosure {\n+    jboolean _executed;\n+\n+    void do_thread(Thread* th) {\n+      JavaThread* jt = th->as_Java_thread();\n+      ResourceMark rm;\n+\n+      GrowableArray<MonitorInfo*>* info = new GrowableArray<MonitorInfo*>();\n+\n+      if (!jt->has_last_Java_frame()) {\n+        return;\n+      }\n+      RegisterMap rmap(jt);\n+      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != NULL; vf = vf->java_sender()) {\n+        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n+        if (monitors != NULL) {\n+          int len = monitors->length();\n+          \/\/ Walk monitors youngest to oldest\n+          for (int i = len - 1; i >= 0; i--) {\n+            MonitorInfo* mon_info = monitors->at(i);\n+            if (mon_info->eliminated()) continue;\n+            oop owner = mon_info->owner();\n+            if (owner != NULL) {\n+              info->append(mon_info);\n+            }\n+          }\n+        }\n+      }\n+      _executed = true;\n+    }\n+\n+   public:\n+    ReadMonitorsClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n+    jboolean executed() const { return _executed; }\n+  };\n+\n+  ReadMonitorsClosure rmc;\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    Handshake::execute(&rmc, target);\n+  }\n+  return rmc.executed();\n+WB_END\n+\n@@ -2566,0 +2612,1 @@\n+  {CC\"handshakeReadMonitors\", CC\"(Ljava\/lang\/Thread;)Z\", (void*)&WB_HandshakeReadMonitors },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,0 @@\n-  \/\/ ARCH specific policy for the BiasedLocking\n-  static bool use_biased_locking()  { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3106,4 +3106,0 @@\n-    \/\/ Disable biased locking now as it interferes with the clean up of\n-    \/\/ the archived Klasses and Java string objects (at dump time only).\n-    UseBiasedLocking = false;\n-\n@@ -4023,20 +4019,0 @@\n-  \/\/ Turn off biased locking for locking debug mode flags,\n-  \/\/ which are subtly different from each other but neither works with\n-  \/\/ biased locking\n-  if (UseHeavyMonitors\n-#ifdef COMPILER1\n-      || !UseFastLocking\n-#endif \/\/ COMPILER1\n-#if INCLUDE_JVMCI\n-      || !JVMCIUseFastLocking\n-#endif\n-    ) {\n-    if (!FLAG_IS_DEFAULT(UseBiasedLocking) && UseBiasedLocking) {\n-      \/\/ flag set to true on command line; warn the user that they\n-      \/\/ can't enable biased locking here\n-      warning(\"Biased Locking is not supported with locking debug flags\"\n-              \"; ignoring UseBiasedLocking flag.\" );\n-    }\n-    UseBiasedLocking = false;\n-  }\n-\n@@ -4046,1 +4022,0 @@\n-  FLAG_SET_DEFAULT(UseBiasedLocking, false);\n@@ -4077,7 +4052,0 @@\n-  \/\/ Apply CPU specific policy for the BiasedLocking\n-  if (UseBiasedLocking) {\n-    if (!VM_Version::use_biased_locking() &&\n-        !(FLAG_IS_CMDLINE(UseBiasedLocking))) {\n-      UseBiasedLocking = false;\n-    }\n-  }\n@@ -4085,4 +4053,0 @@\n-  if (!UseBiasedLocking) {\n-    UseOptoBiasInlining = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,995 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/support\/jfrThreadId.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/basicLock.hpp\"\n-#include \"runtime\/biasedLocking.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/safepointMechanism.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-#include \"runtime\/vframe.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-\n-\n-static bool _biased_locking_enabled = false;\n-BiasedLockingCounters BiasedLocking::_counters;\n-\n-static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n-static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n-\n-static void enable_biased_locking(InstanceKlass* k) {\n-  k->set_prototype_header(markWord::biased_locking_prototype());\n-}\n-\n-static void enable_biased_locking() {\n-  _biased_locking_enabled = true;\n-  log_info(biasedlocking)(\"Biased locking enabled\");\n-}\n-\n-class VM_EnableBiasedLocking: public VM_Operation {\n- public:\n-  VM_EnableBiasedLocking() {}\n-  VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }\n-\n-  void doit() {\n-    \/\/ Iterate the class loader data dictionaries enabling biased locking for all\n-    \/\/ currently loaded classes.\n-    ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);\n-    \/\/ Indicate that future instances should enable it as well\n-    enable_biased_locking();\n-  }\n-\n-  bool allow_nested_vm_operations() const        { return false; }\n-};\n-\n-\n-\/\/ One-shot PeriodicTask subclass for enabling biased locking\n-class EnableBiasedLockingTask : public PeriodicTask {\n- public:\n-  EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}\n-\n-  virtual void task() {\n-    VM_EnableBiasedLocking op;\n-    VMThread::execute(&op);\n-\n-    \/\/ Reclaim our storage and disenroll ourself\n-    delete this;\n-  }\n-};\n-\n-\n-void BiasedLocking::init() {\n-  \/\/ If biased locking is enabled and BiasedLockingStartupDelay is set,\n-  \/\/ schedule a task to fire after the specified delay which turns on\n-  \/\/ biased locking for all currently loaded classes as well as future\n-  \/\/ ones. This could be a workaround for startup time regressions\n-  \/\/ due to large number of safepoints being taken during VM startup for\n-  \/\/ bias revocation.\n-  if (UseBiasedLocking) {\n-    if (BiasedLockingStartupDelay > 0) {\n-      EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);\n-      task->enroll();\n-    } else {\n-      enable_biased_locking();\n-    }\n-  }\n-}\n-\n-\n-bool BiasedLocking::enabled() {\n-  assert(UseBiasedLocking, \"precondition\");\n-  \/\/ We check \"BiasedLockingStartupDelay == 0\" here to cover the\n-  \/\/ possibility of calls to BiasedLocking::enabled() before\n-  \/\/ BiasedLocking::init().\n-  return _biased_locking_enabled || BiasedLockingStartupDelay == 0;\n-}\n-\n-\n-\/\/ Returns MonitorInfos for all objects locked on this thread in youngest to oldest order\n-static GrowableArray<MonitorInfo*>* get_or_compute_monitor_info(JavaThread* thread) {\n-  GrowableArray<MonitorInfo*>* info = thread->cached_monitor_info();\n-  if (info != NULL) {\n-    return info;\n-  }\n-\n-  info = new GrowableArray<MonitorInfo*>();\n-\n-  \/\/ It's possible for the thread to not have any Java frames on it,\n-  \/\/ i.e., if it's the main thread and it's already returned from main()\n-  if (thread->has_last_Java_frame()) {\n-    RegisterMap rm(thread);\n-    for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-      GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-      if (monitors != NULL) {\n-        int len = monitors->length();\n-        \/\/ Walk monitors youngest to oldest\n-        for (int i = len - 1; i >= 0; i--) {\n-          MonitorInfo* mon_info = monitors->at(i);\n-          if (mon_info->eliminated()) continue;\n-          oop owner = mon_info->owner();\n-          if (owner != NULL) {\n-            info->append(mon_info);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  thread->set_cached_monitor_info(info);\n-  return info;\n-}\n-\n-\n-\/\/ After the call, *biased_locker will be set to obj->mark()->biased_locker() if biased_locker != NULL,\n-\/\/ AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).\n-void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  markWord mark = obj->mark();\n-  if (!mark.has_bias_pattern()) {\n-    if (log_is_enabled(Info, biasedlocking)) {\n-      ResourceMark rm;\n-      log_info(biasedlocking)(\"  (Skipping revocation of object \" INTPTR_FORMAT\n-                              \", mark \" INTPTR_FORMAT \", type %s\"\n-                              \", requesting thread \" INTPTR_FORMAT\n-                              \" because it's no longer biased)\",\n-                              p2i((void *)obj), mark.value(),\n-                              obj->klass()->external_name(),\n-                              (intptr_t) requesting_thread);\n-    }\n-    return;\n-  }\n-\n-  uint age = mark.age();\n-  markWord unbiased_prototype = markWord::prototype().set_age(age);\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    ResourceMark rm;\n-    log_info(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \", mark \"\n-                            INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                            \", requesting thread \" INTPTR_FORMAT,\n-                            p2i((void *)obj),\n-                            mark.value(),\n-                            obj->klass()->external_name(),\n-                            obj->klass()->prototype_header().value(),\n-                            (intptr_t) requesting_thread);\n-  } else {\n-    ResourceMark rm;\n-    log_trace(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \" , mark \"\n-                             INTPTR_FORMAT \" , type %s , prototype header \" INTPTR_FORMAT\n-                             \" , requesting thread \" INTPTR_FORMAT,\n-                             p2i((void *)obj),\n-                             mark.value(),\n-                             obj->klass()->external_name(),\n-                             obj->klass()->prototype_header().value(),\n-                             (intptr_t) requesting_thread);\n-  }\n-\n-  JavaThread* biased_thread = mark.biased_locker();\n-  if (biased_thread == NULL) {\n-    \/\/ Object is anonymously biased. We can get here if, for\n-    \/\/ example, we revoke the bias due to an identity hash code\n-    \/\/ being computed for an object.\n-    obj->set_mark(unbiased_prototype);\n-\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    }\n-    return;\n-  }\n-\n-  \/\/ Handle case where the thread toward which the object was biased has exited\n-  bool thread_is_alive = false;\n-  if (requesting_thread == biased_thread) {\n-    thread_is_alive = true;\n-  } else {\n-    ThreadsListHandle tlh;\n-    thread_is_alive = tlh.includes(biased_thread);\n-  }\n-  if (!thread_is_alive) {\n-    obj->set_mark(unbiased_prototype);\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                              PTR_FORMAT \")\", p2i(biased_thread));\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-    }\n-    return;\n-  }\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    log_info(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                            PTR_FORMAT \")\", p2i(biased_thread));\n-  } else {\n-    log_trace(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-  }\n-\n-  \/\/ Thread owning bias is alive.\n-  \/\/ Check to see whether it currently owns the lock and, if so,\n-  \/\/ write down the needed displaced headers to the thread's stack.\n-  \/\/ Otherwise, restore the object's header either to the unlocked\n-  \/\/ or unbiased state.\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    }\n-  } else {\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    }\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  \/\/ If requested, return information on which thread held the bias\n-  if (biased_locker != NULL) {\n-    *biased_locker = biased_thread;\n-  }\n-}\n-\n-\n-enum HeuristicsResult {\n-  HR_NOT_BIASED    = 1,\n-  HR_SINGLE_REVOKE = 2,\n-  HR_BULK_REBIAS   = 3,\n-  HR_BULK_REVOKE   = 4\n-};\n-\n-\n-static HeuristicsResult update_heuristics(oop o) {\n-  markWord mark = o->mark();\n-  if (!mark.has_bias_pattern()) {\n-    return HR_NOT_BIASED;\n-  }\n-\n-  \/\/ Heuristics to attempt to throttle the number of revocations.\n-  \/\/ Stages:\n-  \/\/ 1. Revoke the biases of all objects in the heap of this type,\n-  \/\/    but allow rebiasing of those objects if unlocked.\n-  \/\/ 2. Revoke the biases of all objects in the heap of this type\n-  \/\/    and don't allow rebiasing of these objects. Disable\n-  \/\/    allocation of objects of that type with the bias bit set.\n-  Klass* k = o->klass();\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  jlong last_bulk_revocation_time = k->last_biased_lock_bulk_revocation_time();\n-  int revocation_count = k->biased_lock_revocation_count();\n-  if ((revocation_count >= BiasedLockingBulkRebiasThreshold) &&\n-      (revocation_count <  BiasedLockingBulkRevokeThreshold) &&\n-      (last_bulk_revocation_time != 0) &&\n-      (cur_time - last_bulk_revocation_time >= BiasedLockingDecayTime)) {\n-    \/\/ This is the first revocation we've seen in a while of an\n-    \/\/ object of this type since the last time we performed a bulk\n-    \/\/ rebiasing operation. The application is allocating objects in\n-    \/\/ bulk which are biased toward a thread and then handing them\n-    \/\/ off to another thread. We can cope with this allocation\n-    \/\/ pattern via the bulk rebiasing mechanism so we reset the\n-    \/\/ klass's revocation count rather than allow it to increase\n-    \/\/ monotonically. If we see the need to perform another bulk\n-    \/\/ rebias operation later, we will, and if subsequently we see\n-    \/\/ many more revocation operations in a short period of time we\n-    \/\/ will completely disable biasing for this type.\n-    k->set_biased_lock_revocation_count(0);\n-    revocation_count = 0;\n-  }\n-\n-  \/\/ Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold\n-  if (revocation_count <= BiasedLockingBulkRevokeThreshold) {\n-    revocation_count = k->atomic_incr_biased_lock_revocation_count();\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRevokeThreshold) {\n-    return HR_BULK_REVOKE;\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRebiasThreshold) {\n-    return HR_BULK_REBIAS;\n-  }\n-\n-  return HR_SINGLE_REVOKE;\n-}\n-\n-\n-void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  log_info(biasedlocking)(\"* Beginning bulk revocation (kind == %s) because of object \"\n-                          INTPTR_FORMAT \" , mark \" INTPTR_FORMAT \" , type %s\",\n-                          (bulk_rebias ? \"rebias\" : \"revoke\"),\n-                          p2i((void *) o),\n-                          o->mark().value(),\n-                          o->klass()->external_name());\n-\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  o->klass()->set_last_biased_lock_bulk_revocation_time(cur_time);\n-\n-  Klass* k_o = o->klass();\n-  Klass* klass = k_o;\n-\n-  {\n-    JavaThreadIteratorWithHandle jtiwh;\n-\n-    if (bulk_rebias) {\n-      \/\/ Use the epoch in the klass of the object to implicitly revoke\n-      \/\/ all biases of objects of this data type and force them to be\n-      \/\/ reacquired. However, we also need to walk the stacks of all\n-      \/\/ threads and update the headers of lightweight locked objects\n-      \/\/ with biases to have the current epoch.\n-\n-      \/\/ If the prototype header doesn't have the bias pattern, don't\n-      \/\/ try to update the epoch -- assume another VM operation came in\n-      \/\/ and reset the header to the unbiased state, which will\n-      \/\/ implicitly cause all existing biases to be revoked\n-      if (klass->prototype_header().has_bias_pattern()) {\n-        int prev_epoch = klass->prototype_header().bias_epoch();\n-        klass->set_prototype_header(klass->prototype_header().incr_bias_epoch());\n-        int cur_epoch = klass->prototype_header().bias_epoch();\n-\n-        \/\/ Now walk all threads' stacks and adjust epochs of any biased\n-        \/\/ and locked objects of this data type we encounter\n-        for (; JavaThread *thr = jtiwh.next(); ) {\n-          GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-          for (int i = 0; i < cached_monitor_info->length(); i++) {\n-            MonitorInfo* mon_info = cached_monitor_info->at(i);\n-            oop owner = mon_info->owner();\n-            markWord mark = owner->mark();\n-            if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-              \/\/ We might have encountered this object already in the case of recursive locking\n-              assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n-              owner->set_mark(mark.set_bias_epoch(cur_epoch));\n-            }\n-          }\n-        }\n-      }\n-\n-      \/\/ At this point we're done. All we have to do is potentially\n-      \/\/ adjust the header of the given object to revoke its bias.\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    } else {\n-      if (log_is_enabled(Info, biasedlocking)) {\n-        ResourceMark rm;\n-        log_info(biasedlocking)(\"* Disabling biased locking for type %s\", klass->external_name());\n-      }\n-\n-      \/\/ Disable biased locking for this data type. Not only will this\n-      \/\/ cause future instances to not be biased, but existing biased\n-      \/\/ instances will notice that this implicitly caused their biases\n-      \/\/ to be revoked.\n-      klass->set_prototype_header(markWord::prototype());\n-\n-      \/\/ Now walk all threads' stacks and forcibly revoke the biases of\n-      \/\/ any locked and biased objects of this data type we encounter.\n-      for (; JavaThread *thr = jtiwh.next(); ) {\n-        GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-        for (int i = 0; i < cached_monitor_info->length(); i++) {\n-          MonitorInfo* mon_info = cached_monitor_info->at(i);\n-          oop owner = mon_info->owner();\n-          markWord mark = owner->mark();\n-          if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-            single_revoke_at_safepoint(owner, true, requesting_thread, NULL);\n-          }\n-        }\n-      }\n-\n-      \/\/ Must force the bias of the passed object to be forcibly revoked\n-      \/\/ as well to ensure guarantees to callers\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    }\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n-  log_info(biasedlocking)(\"* Ending bulk revocation\");\n-\n-  assert(!o->mark().has_bias_pattern(), \"bug in bulk bias revocation\");\n-}\n-\n-\n-static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {\n-  if (thread != NULL) {\n-    thread->set_cached_monitor_info(NULL);\n-  } else {\n-    \/\/ Walk the thread list clearing out the cached monitors\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-      thr->set_cached_monitor_info(NULL);\n-    }\n-  }\n-}\n-\n-\n-class VM_BulkRevokeBias : public VM_Operation {\n-private:\n-  Handle* _obj;\n-  JavaThread* _requesting_thread;\n-  bool _bulk_rebias;\n-  uint64_t _safepoint_id;\n-\n-public:\n-  VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,\n-                    bool bulk_rebias)\n-    : _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _bulk_rebias(bulk_rebias)\n-    , _safepoint_id(0) {}\n-\n-  virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }\n-\n-  virtual void doit() {\n-    BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);\n-    _safepoint_id = SafepointSynchronize::safepoint_id();\n-    clean_up_cached_monitor_info();\n-  }\n-\n-  bool is_bulk_rebias() const {\n-    return _bulk_rebias;\n-  }\n-\n-  uint64_t safepoint_id() const {\n-    return _safepoint_id;\n-  }\n-};\n-\n-\n-class RevokeOneBias : public HandshakeClosure {\n-protected:\n-  Handle _obj;\n-  JavaThread* _requesting_thread;\n-  JavaThread* _biased_locker;\n-  BiasedLocking::Condition _status_code;\n-  traceid _biased_locker_id;\n-  bool _executed;\n-\n-public:\n-  RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)\n-    : HandshakeClosure(\"RevokeOneBias\")\n-    , _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _biased_locker(biased_locker)\n-    , _status_code(BiasedLocking::NOT_BIASED)\n-    , _biased_locker_id(0)\n-    , _executed(false) {}\n-\n-  bool executed() { return _executed; }\n-\n-  void do_thread(Thread* target) {\n-    assert(target == _biased_locker, \"Wrong thread\");\n-    _executed = true;\n-\n-    oop o = _obj();\n-    markWord mark = o->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    markWord prototype = o->klass()->prototype_header();\n-    if (!prototype.has_bias_pattern()) {\n-      \/\/ This object has a stale bias from before the handshake\n-      \/\/ was requested. If we fail this race, the object's bias\n-      \/\/ has been revoked by another thread so we simply return.\n-      markWord biased_value = mark;\n-      mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-      assert(!o->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-      if (biased_value == mark) {\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-      }\n-      return;\n-    }\n-\n-    if (_biased_locker == mark.biased_locker()) {\n-      if (mark.bias_epoch() == prototype.bias_epoch()) {\n-        \/\/ Epoch is still valid. This means biaser could be currently\n-        \/\/ synchronized on this object. We must walk its stack looking\n-        \/\/ for monitor records associated with this object and change\n-        \/\/ them to be stack locks if any are found.\n-        ResourceMark rm;\n-        BiasedLocking::walk_stack_and_revoke(o, _biased_locker);\n-        _biased_locker->set_cached_monitor_info(NULL);\n-        assert(!o->mark().has_bias_pattern(), \"invariant\");\n-        _biased_locker_id = JFR_THREAD_ID(_biased_locker);\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-        return;\n-      } else {\n-        markWord biased_value = mark;\n-        mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (mark == biased_value || !mark.has_bias_pattern()) {\n-          assert(!o->mark().has_bias_pattern(), \"should be revoked\");\n-          _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;\n-          return;\n-        }\n-      }\n-    }\n-\n-    _status_code = BiasedLocking::NOT_REVOKED;\n-  }\n-\n-  BiasedLocking::Condition status_code() const {\n-    return _status_code;\n-  }\n-\n-  traceid biased_locker() const {\n-    return _biased_locker_id;\n-  }\n-};\n-\n-\n-static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->commit();\n-}\n-\n-static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->set_safepointId(0);\n-  event->set_previousOwner(op->biased_locker());\n-  event->commit();\n-}\n-\n-static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_revokedClass(k);\n-  event->set_disableBiasing(!op->is_bulk_rebias());\n-  event->set_safepointId(op->safepoint_id());\n-  event->commit();\n-}\n-\n-\n-BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {\n-\n-  EventBiasedLockRevocation event;\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(handshakes_count_addr());\n-  }\n-  log_info(biasedlocking, handshake)(\"JavaThread \" INTPTR_FORMAT \" handshaking JavaThread \"\n-                                     INTPTR_FORMAT \" to revoke object \" INTPTR_FORMAT, p2i(requester),\n-                                     p2i(biaser), p2i(obj()));\n-\n-  RevokeOneBias revoke(obj, requester, biaser);\n-  Handshake::execute(&revoke, biaser);\n-  if (revoke.status_code() == NOT_REVOKED) {\n-    return NOT_REVOKED;\n-  }\n-  if (revoke.executed()) {\n-    log_info(biasedlocking, handshake)(\"Handshake revocation for object \" INTPTR_FORMAT \" succeeded. Bias was %srevoked\",\n-                                       p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? \"\" : \"already \"));\n-    if (event.should_commit() && revoke.status_code() == BIAS_REVOKED) {\n-      post_revocation_event(&event, obj->klass(), &revoke);\n-    }\n-    assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-    return revoke.status_code();\n-  } else {\n-    \/\/ Thread was not alive.\n-    \/\/ Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly\n-    \/\/ created JavaThread (that happens to get the same memory address as biaser) synchronizing\n-    \/\/ on this object.\n-    {\n-      MutexLocker ml(Threads_lock);\n-      markWord mark = obj->mark();\n-      \/\/ Check if somebody else was able to revoke it before biased thread exited.\n-      if (!mark.has_bias_pattern()) {\n-        return NOT_BIASED;\n-      }\n-      ThreadsListHandle tlh;\n-      markWord prototype = obj->klass()->prototype_header();\n-      if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) && biaser == mark.biased_locker() &&\n-                                            prototype.bias_epoch() == mark.bias_epoch())) {\n-        obj->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (event.should_commit()) {\n-          post_revocation_event(&event, obj->klass(), &revoke);\n-        }\n-        assert(!obj->mark().has_bias_pattern(), \"bias should be revoked by now\");\n-        return BIAS_REVOKED;\n-      }\n-    }\n-  }\n-\n-  return NOT_REVOKED;\n-}\n-\n-\n-\/\/ Caller should have instantiated a ResourceMark object before calling this method\n-void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {\n-  Thread* cur = Thread::current();\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"this should always be executed outside safepoints\");\n-  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n-\n-  markWord mark = obj->mark();\n-  assert(mark.biased_locker() == biased_locker &&\n-         obj->klass()->prototype_header().bias_epoch() == mark.bias_epoch(), \"invariant\");\n-\n-  log_trace(biasedlocking)(\"JavaThread(\" INTPTR_FORMAT \") revoking object \" INTPTR_FORMAT \", mark \"\n-                           INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                           \", biaser \" INTPTR_FORMAT \" %s\",\n-                           p2i(cur),\n-                           p2i(obj),\n-                           mark.value(),\n-                           obj->klass()->external_name(),\n-                           obj->klass()->prototype_header().value(),\n-                           p2i(biased_locker),\n-                           cur != biased_locker ? \"\" : \"(walking own stack)\");\n-\n-  markWord unbiased_prototype = markWord::prototype().set_age(obj->mark().age());\n-\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_locker);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-  } else {\n-    log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  assert(!obj->mark().has_bias_pattern(), \"must not be biased\");\n-}\n-\n-void BiasedLocking::revoke_own_lock(JavaThread* current, Handle obj) {\n-  markWord mark = obj->mark();\n-\n-  if (!mark.has_bias_pattern()) {\n-    return;\n-  }\n-\n-  Klass *k = obj->klass();\n-  assert(mark.biased_locker() == current &&\n-         k->prototype_header().bias_epoch() == mark.bias_epoch(), \"Revoke failed, unhandled biased lock state\");\n-  ResourceMark rm(current);\n-  log_info(biasedlocking)(\"Revoking bias by walking my own stack:\");\n-  EventBiasedLockSelfRevocation event;\n-  BiasedLocking::walk_stack_and_revoke(obj(), current);\n-  current->set_cached_monitor_info(NULL);\n-  assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-  if (event.should_commit()) {\n-    post_self_revocation_event(&event, k);\n-  }\n-}\n-\n-void BiasedLocking::revoke(JavaThread* current, Handle obj) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"must not be called while at safepoint\");\n-\n-  while (true) {\n-    \/\/ We can revoke the biases of anonymously-biased objects\n-    \/\/ efficiently enough that we should not cause these revocations to\n-    \/\/ update the heuristics because doing so may cause unwanted bulk\n-    \/\/ revocations (which are expensive) to occur.\n-    markWord mark = obj->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    if (mark.is_biased_anonymously()) {\n-      \/\/ We are probably trying to revoke the bias of this object due to\n-      \/\/ an identity hash code computation. Try to revoke the bias\n-      \/\/ without a safepoint. This is possible if we can successfully\n-      \/\/ compare-and-exchange an unbiased header into the mark word of\n-      \/\/ the object, meaning that no other thread has raced to acquire\n-      \/\/ the bias of the object.\n-      markWord biased_value       = mark;\n-      markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-      markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-      if (res_mark == biased_value) {\n-        return;\n-      }\n-      mark = res_mark;  \/\/ Refresh mark with the latest value.\n-    } else {\n-      Klass* k = obj->klass();\n-      markWord prototype_header = k->prototype_header();\n-      if (!prototype_header.has_bias_pattern()) {\n-        \/\/ This object has a stale bias from before the bulk revocation\n-        \/\/ for this data type occurred. It's pointless to update the\n-        \/\/ heuristics at this point so simply update the header with a\n-        \/\/ CAS. If we fail this race, the object's bias has been revoked\n-        \/\/ by another thread so we simply return and let the caller deal\n-        \/\/ with it.\n-        obj->cas_set_mark(prototype_header.set_age(mark.age()), mark);\n-        assert(!obj->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-        return;\n-      } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {\n-        \/\/ The epoch of this biasing has expired indicating that the\n-        \/\/ object is effectively unbiased. We can revoke the bias of this\n-        \/\/ object efficiently enough with a CAS that we shouldn't update the\n-        \/\/ heuristics. This is normally done in the assembly code but we\n-        \/\/ can reach this point due to various points in the runtime\n-        \/\/ needing to revoke biases.\n-        markWord res_mark;\n-        markWord biased_value       = mark;\n-        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-        res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-        if (res_mark == biased_value) {\n-          return;\n-        }\n-        mark = res_mark;  \/\/ Refresh mark with the latest value.\n-      }\n-    }\n-\n-    HeuristicsResult heuristics = update_heuristics(obj());\n-    if (heuristics == HR_NOT_BIASED) {\n-      return;\n-    } else if (heuristics == HR_SINGLE_REVOKE) {\n-      JavaThread *blt = mark.biased_locker();\n-      assert(blt != NULL, \"invariant\");\n-      if (blt == current) {\n-        \/\/ A thread is trying to revoke the bias of an object biased\n-        \/\/ toward it, again likely due to an identity hash code\n-        \/\/ computation. We can again avoid a safepoint\/handshake in this case\n-        \/\/ since we are only going to walk our own stack. There are no\n-        \/\/ races with revocations occurring in other threads because we\n-        \/\/ reach no safepoints in the revocation path.\n-        EventBiasedLockSelfRevocation event;\n-        ResourceMark rm(current);\n-        walk_stack_and_revoke(obj(), blt);\n-        blt->set_cached_monitor_info(NULL);\n-        assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-        if (event.should_commit()) {\n-          post_self_revocation_event(&event, obj->klass());\n-        }\n-        return;\n-      } else {\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, current, blt);\n-        if (cond != NOT_REVOKED) {\n-          return;\n-        }\n-      }\n-    } else {\n-      assert((heuristics == HR_BULK_REVOKE) ||\n-         (heuristics == HR_BULK_REBIAS), \"?\");\n-      EventBiasedLockClassRevocation event;\n-      VM_BulkRevokeBias bulk_revoke(&obj, current, (heuristics == HR_BULK_REBIAS));\n-      VMThread::execute(&bulk_revoke);\n-      if (event.should_commit()) {\n-        post_class_revocation_event(&event, obj->klass(), &bulk_revoke);\n-      }\n-      return;\n-    }\n-  }\n-}\n-\n-\/\/ All objects in objs should be locked by biaser\n-void BiasedLocking::revoke(GrowableArray<Handle>* objs, JavaThread *biaser) {\n-  bool clean_my_cache = false;\n-  for (int i = 0; i < objs->length(); i++) {\n-    oop obj = (objs->at(i))();\n-    markWord mark = obj->mark();\n-    if (mark.has_bias_pattern()) {\n-      walk_stack_and_revoke(obj, biaser);\n-      clean_my_cache = true;\n-    }\n-  }\n-  if (clean_my_cache) {\n-    clean_up_cached_monitor_info(biaser);\n-  }\n-}\n-\n-\n-void BiasedLocking::revoke_at_safepoint(Handle h_obj) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-  oop obj = h_obj();\n-  HeuristicsResult heuristics = update_heuristics(obj);\n-  if (heuristics == HR_SINGLE_REVOKE) {\n-    JavaThread* biased_locker = NULL;\n-    single_revoke_at_safepoint(obj, false, NULL, &biased_locker);\n-    if (biased_locker) {\n-      clean_up_cached_monitor_info(biased_locker);\n-    }\n-  } else if ((heuristics == HR_BULK_REBIAS) ||\n-             (heuristics == HR_BULK_REVOKE)) {\n-    bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);\n-    clean_up_cached_monitor_info();\n-  }\n-}\n-\n-\n-void BiasedLocking::preserve_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-\n-  assert(_preserved_oop_stack  == NULL, \"double initialization\");\n-  assert(_preserved_mark_stack == NULL, \"double initialization\");\n-\n-  \/\/ In order to reduce the number of mark words preserved during GC\n-  \/\/ due to the presence of biased locking, we reinitialize most mark\n-  \/\/ words to the class's prototype during GC -- even those which have\n-  \/\/ a currently valid bias owner. One important situation where we\n-  \/\/ must not clobber a bias is when a biased object is currently\n-  \/\/ locked. To handle this case we iterate over the currently-locked\n-  \/\/ monitors in a prepass and, if they are biased, preserve their\n-  \/\/ mark words here. This should be a relatively small set of objects\n-  \/\/ especially compared to the number of objects in the heap.\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(10, mtGC);\n-  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<Handle>(10, mtGC);\n-\n-  Thread* cur = Thread::current();\n-  ResourceMark rm(cur);\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    if (thread->has_last_Java_frame()) {\n-      RegisterMap rm(thread);\n-      for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-        if (monitors != NULL) {\n-          int len = monitors->length();\n-          \/\/ Walk monitors youngest to oldest\n-          for (int i = len - 1; i >= 0; i--) {\n-            MonitorInfo* mon_info = monitors->at(i);\n-            if (mon_info->owner_is_scalar_replaced()) continue;\n-            oop owner = mon_info->owner();\n-            if (owner != NULL) {\n-              markWord mark = owner->mark();\n-              if (mark.has_bias_pattern()) {\n-                _preserved_oop_stack->push(Handle(cur, owner));\n-                _preserved_mark_stack->push(mark);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\n-void BiasedLocking::restore_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(_preserved_oop_stack  != NULL, \"double free\");\n-  assert(_preserved_mark_stack != NULL, \"double free\");\n-\n-  int len = _preserved_oop_stack->length();\n-  for (int i = 0; i < len; i++) {\n-    Handle owner = _preserved_oop_stack->at(i);\n-    markWord mark = _preserved_mark_stack->at(i);\n-    owner->set_mark(mark);\n-  }\n-\n-  delete _preserved_oop_stack;\n-  _preserved_oop_stack = NULL;\n-  delete _preserved_mark_stack;\n-  _preserved_mark_stack = NULL;\n-}\n-\n-\n-int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }\n-int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }\n-int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }\n-int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }\n-int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }\n-int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }\n-int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }\n-int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }\n-\n-\n-\/\/ BiasedLockingCounters\n-\n-int BiasedLockingCounters::slow_path_entry_count() const {\n-  if (_slow_path_entry_count != 0) {\n-    return _slow_path_entry_count;\n-  }\n-  int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +\n-            _rebiased_lock_entry_count + _revoked_lock_entry_count +\n-            _fast_path_entry_count;\n-\n-  return _total_entry_count - sum;\n-}\n-\n-void BiasedLockingCounters::print_on(outputStream* st) const {\n-  tty->print_cr(\"# total entries: %d\", _total_entry_count);\n-  tty->print_cr(\"# biased lock entries: %d\", _biased_lock_entry_count);\n-  tty->print_cr(\"# anonymously biased lock entries: %d\", _anonymously_biased_lock_entry_count);\n-  tty->print_cr(\"# rebiased lock entries: %d\", _rebiased_lock_entry_count);\n-  tty->print_cr(\"# revoked lock entries: %d\", _revoked_lock_entry_count);\n-  tty->print_cr(\"# handshakes entries: %d\", _handshakes_count);\n-  tty->print_cr(\"# fast path lock entries: %d\", _fast_path_entry_count);\n-  tty->print_cr(\"# slow path lock entries: %d\", slow_path_entry_count());\n-}\n-\n-void BiasedLockingCounters::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":0,"deletions":995,"binary":false,"changes":995,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP\n-#define SHARE_RUNTIME_BIASEDLOCKING_HPP\n-\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ This class describes operations to implement Store-Free Biased\n-\/\/ Locking. The high-level properties of the scheme are similar to\n-\/\/ IBM's lock reservation, Dice-Moir-Scherer QR locks, and other biased\n-\/\/ locking mechanisms. The principal difference is in the handling of\n-\/\/ recursive locking which is how this technique achieves a more\n-\/\/ efficient fast path than these other schemes.\n-\/\/\n-\/\/ The basic observation is that in HotSpot's current fast locking\n-\/\/ scheme, recursive locking (in the fast path) causes no update to\n-\/\/ the object header. The recursion is described simply by stack\n-\/\/ records containing a specific value (NULL). Only the last unlock by\n-\/\/ a given thread causes an update to the object header.\n-\/\/\n-\/\/ This observation, coupled with the fact that HotSpot only compiles\n-\/\/ methods for which monitor matching is obeyed (and which therefore\n-\/\/ can not throw IllegalMonitorStateException), implies that we can\n-\/\/ completely eliminate modifications to the object header for\n-\/\/ recursive locking in compiled code, and perform similar recursion\n-\/\/ checks and throwing of IllegalMonitorStateException in the\n-\/\/ interpreter with little or no impact on the performance of the fast\n-\/\/ path.\n-\/\/\n-\/\/ The basic algorithm is as follows (note, see below for more details\n-\/\/ and information). A pattern in the low three bits is reserved in\n-\/\/ the object header to indicate whether biasing of a given object's\n-\/\/ lock is currently being done or is allowed at all.  If the bias\n-\/\/ pattern is present, the contents of the rest of the header are\n-\/\/ either the JavaThread* of the thread to which the lock is biased,\n-\/\/ or NULL, indicating that the lock is \"anonymously biased\". The\n-\/\/ first thread which locks an anonymously biased object biases the\n-\/\/ lock toward that thread. If another thread subsequently attempts to\n-\/\/ lock the same object, the bias is revoked.\n-\/\/\n-\/\/ Because there are no updates to the object header at all during\n-\/\/ recursive locking while the lock is biased, the biased lock entry\n-\/\/ code is simply a test of the object header's value. If this test\n-\/\/ succeeds, the lock has been acquired by the thread. If this test\n-\/\/ fails, a bit test is done to see whether the bias bit is still\n-\/\/ set. If not, we fall back to HotSpot's original CAS-based locking\n-\/\/ scheme. If it is set, we attempt to CAS in a bias toward this\n-\/\/ thread. The latter operation is expected to be the rarest operation\n-\/\/ performed on these locks. We optimistically expect the biased lock\n-\/\/ entry to hit most of the time, and want the CAS-based fallthrough\n-\/\/ to occur quickly in the situations where the bias has been revoked.\n-\/\/\n-\/\/ Revocation of the lock's bias is fairly straightforward. We want to\n-\/\/ restore the object's header and stack-based BasicObjectLocks and\n-\/\/ BasicLocks to the state they would have been in had the object been\n-\/\/ locked by HotSpot's usual fast locking scheme. To do this, we execute\n-\/\/ a handshake with the JavaThread that biased the lock. Inside the\n-\/\/ handshake we walk the biaser stack searching for all of the lock\n-\/\/ records corresponding to this object, in particular the first \/ \"highest\"\n-\/\/ record. We fill in the highest lock record with the object's displaced\n-\/\/ header (which is a well-known value given that we don't maintain an\n-\/\/ identity hash nor age bits for the object while it's in the biased\n-\/\/ state) and all other lock records with 0, the value for recursive locks.\n-\/\/ Alternatively, we can revoke the bias of an object inside a safepoint\n-\/\/ if we are already in one and we detect that we need to perform a\n-\/\/ revocation.\n-\/\/\n-\/\/ This scheme can not handle transfers of biases of single objects\n-\/\/ from thread to thread efficiently, but it can handle bulk transfers\n-\/\/ of such biases, which is a usage pattern showing up in some\n-\/\/ applications and benchmarks. We implement \"bulk rebias\" and \"bulk\n-\/\/ revoke\" operations using a \"bias epoch\" on a per-data-type basis.\n-\/\/ If too many bias revocations are occurring for a particular data\n-\/\/ type, the bias epoch for the data type is incremented at a\n-\/\/ safepoint, effectively meaning that all previous biases are\n-\/\/ invalid. The fast path locking case checks for an invalid epoch in\n-\/\/ the object header and attempts to rebias the object with a CAS if\n-\/\/ found, avoiding safepoints or bulk heap sweeps (the latter which\n-\/\/ was used in a prior version of this algorithm and did not scale\n-\/\/ well). If too many bias revocations persist, biasing is completely\n-\/\/ disabled for the data type by resetting the prototype header to the\n-\/\/ unbiased markWord. The fast-path locking code checks to see whether\n-\/\/ the instance's bias pattern differs from the prototype header's and\n-\/\/ causes the bias to be revoked without reaching a safepoint or,\n-\/\/ again, a bulk heap sweep.\n-\n-\/\/ Biased locking counters\n-class BiasedLockingCounters {\n- private:\n-  int _total_entry_count;\n-  int _biased_lock_entry_count;\n-  int _anonymously_biased_lock_entry_count;\n-  int _rebiased_lock_entry_count;\n-  int _revoked_lock_entry_count;\n-  int _handshakes_count;\n-  int _fast_path_entry_count;\n-  int _slow_path_entry_count;\n-\n- public:\n-  BiasedLockingCounters() :\n-    _total_entry_count(0),\n-    _biased_lock_entry_count(0),\n-    _anonymously_biased_lock_entry_count(0),\n-    _rebiased_lock_entry_count(0),\n-    _revoked_lock_entry_count(0),\n-    _handshakes_count(0),\n-    _fast_path_entry_count(0),\n-    _slow_path_entry_count(0) {}\n-\n-  int slow_path_entry_count() const; \/\/ Compute this field if necessary\n-\n-  int* total_entry_count_addr()                   { return &_total_entry_count; }\n-  int* biased_lock_entry_count_addr()             { return &_biased_lock_entry_count; }\n-  int* anonymously_biased_lock_entry_count_addr() { return &_anonymously_biased_lock_entry_count; }\n-  int* rebiased_lock_entry_count_addr()           { return &_rebiased_lock_entry_count; }\n-  int* revoked_lock_entry_count_addr()            { return &_revoked_lock_entry_count; }\n-  int* handshakes_count_addr()                    { return &_handshakes_count; }\n-  int* fast_path_entry_count_addr()               { return &_fast_path_entry_count; }\n-  int* slow_path_entry_count_addr()               { return &_slow_path_entry_count; }\n-\n-  bool nonzero() { return _total_entry_count > 0; }\n-\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-};\n-\n-\n-class BiasedLocking : AllStatic {\n-friend class VM_BulkRevokeBias;\n-friend class RevokeOneBias;\n-\n-private:\n-  static BiasedLockingCounters _counters;\n-\n-public:\n-  static int* total_entry_count_addr();\n-  static int* biased_lock_entry_count_addr();\n-  static int* anonymously_biased_lock_entry_count_addr();\n-  static int* rebiased_lock_entry_count_addr();\n-  static int* revoked_lock_entry_count_addr();\n-  static int* handshakes_count_addr();\n-  static int* fast_path_entry_count_addr();\n-  static int* slow_path_entry_count_addr();\n-\n-  enum Condition {\n-    NOT_BIASED = 1,\n-    BIAS_REVOKED = 2,\n-    NOT_REVOKED = 3\n-  };\n-\n-private:\n-  static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);\n-  static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);\n-  static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);\n-  static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);\n-\n-public:\n-  \/\/ This initialization routine should only be called once and\n-  \/\/ schedules a PeriodicTask to turn on biased locking a few seconds\n-  \/\/ into the VM run to avoid startup time regressions\n-  static void init();\n-\n-  \/\/ This provides a global switch for leaving biased locking disabled\n-  \/\/ for the first part of a run and enabling it later\n-  static bool enabled();\n-\n-  \/\/ This should be called by JavaThreads to revoke the bias of an object\n-  static void revoke(JavaThread* current, Handle obj);\n-\n-  \/\/ This must only be called by a JavaThread to revoke the bias of an owned object.\n-  static void revoke_own_lock(JavaThread* current, Handle obj);\n-\n-  static void revoke_at_safepoint(Handle obj);\n-\n-  \/\/ These are used by deoptimization to ensure that monitors on the stack\n-  \/\/ can be migrated\n-  static void revoke(GrowableArray<Handle>* objs, JavaThread *biaser);\n-\n-  static void print_counters() { _counters.print(); }\n-  static BiasedLockingCounters* counters() { return &_counters; }\n-\n-  \/\/ These routines are GC-related and should not be called by end\n-  \/\/ users. GCs which do not do preservation of mark words do not need\n-  \/\/ to call these routines.\n-  static void preserve_marks();\n-  static void restore_marks();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_BIASEDLOCKING_HPP\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -314,3 +313,0 @@\n-  \/\/ Revoke biases of objects with eliminated locks in the given frame.\n-  Deoptimization::revoke_for_object_deoptimization(deoptee_thread, deoptee, &map, thread);\n-\n@@ -386,4 +382,0 @@\n-  \/\/ Revoke biases, done with in java state.\n-  \/\/ No safepoints allowed after this\n-  revoke_from_deopt_handler(current, deoptee, &map);\n-\n@@ -1445,10 +1437,1 @@\n-        if (UseBiasedLocking && mark.has_bias_pattern()) {\n-          \/\/ New allocated objects may have the mark set to anonymously biased.\n-          \/\/ Also the deoptimized method may called methods with synchronization\n-          \/\/ where the thread-local object is bias locked to the current thread.\n-          assert(mark.is_biased_anonymously() ||\n-                 mark.biased_locker() == deoptee_thread, \"should be locked to current thread\");\n-          \/\/ Reset mark word to unbiased prototype.\n-          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-          obj->set_mark(unbiased_prototype);\n-        } else if (exec_mode == Unpack_none) {\n+        if (exec_mode == Unpack_none) {\n@@ -1457,2 +1440,1 @@\n-            \/\/ a callee frame. In this case the bias was revoked before in revoke_for_object_deoptimization().\n-            \/\/ Make the lock in the callee a recursive lock and restore the displaced header.\n+            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n@@ -1598,92 +1580,0 @@\n-static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke,\n-                             bool only_eliminated) {\n-  GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n-  Thread* thread = Thread::current();\n-  for (int i = 0; i < monitors->length(); i++) {\n-    MonitorInfo* mon_info = monitors->at(i);\n-    if (mon_info->eliminated() == only_eliminated &&\n-        !mon_info->owner_is_scalar_replaced() &&\n-        mon_info->owner() != NULL) {\n-      objects_to_revoke->append(Handle(thread, mon_info->owner()));\n-    }\n-  }\n-}\n-\n-static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread,\n-                                    frame fr, RegisterMap* map, bool only_eliminated) {\n-  \/\/ Unfortunately we don't have a RegisterMap available in most of\n-  \/\/ the places we want to call this routine so we need to walk the\n-  \/\/ stack again to update the register map.\n-  if (map == NULL || !map->update_map()) {\n-    StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n-    bool found = false;\n-    while (!found && !sfs.is_done()) {\n-      frame* cur = sfs.current();\n-      sfs.next();\n-      found = cur->id() == fr.id();\n-    }\n-    assert(found, \"frame to be deoptimized not found on target thread's stack\");\n-    map = sfs.register_map();\n-  }\n-\n-  vframe* vf = vframe::new_vframe(&fr, map, thread);\n-  compiledVFrame* cvf = compiledVFrame::cast(vf);\n-  \/\/ Revoke monitors' biases in all scopes\n-  while (!cvf->is_top()) {\n-    collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-    cvf = compiledVFrame::cast(cvf->sender());\n-  }\n-  collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-}\n-\n-void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  assert(thread == Thread::current(), \"should be\");\n-  ResourceMark rm(thread);\n-  HandleMark hm(thread);\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  get_monitors_from_stack(objects_to_revoke, thread, fr, map, false);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    BiasedLocking::revoke_own_lock(thread, objects_to_revoke->at(i));\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n-\/\/ Revoke the bias of objects with eliminated locking to prepare subsequent relocking.\n-void Deoptimization::revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                                      RegisterMap* map, JavaThread* thread) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n-  \/\/ Collect monitors but only those with eliminated locking.\n-  get_monitors_from_stack(objects_to_revoke, deoptee_thread, fr, map, true);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    markWord mark = obj->mark();\n-    if (!mark.has_bias_pattern() ||\n-        mark.is_biased_anonymously() || \/\/ eliminated locking does not bias an object if it wasn't before\n-        !obj->klass()->prototype_header().has_bias_pattern() || \/\/ bulk revoke ignores eliminated monitors\n-        (obj->klass()->prototype_header().bias_epoch() != mark.bias_epoch())) { \/\/ bulk rebias ignores eliminated monitors\n-      \/\/ We reach here regularly if there's just eliminated locking on obj.\n-      \/\/ We must not call BiasedLocking::revoke_own_lock() in this case, as we\n-      \/\/ would hit assertions because it is a prerequisite that there has to be\n-      \/\/ non-eliminated locking on obj by deoptee_thread.\n-      \/\/ Luckily we don't have to revoke here because obj has to be a\n-      \/\/ non-escaping obj and can be relocked without revoking the bias. See\n-      \/\/ Deoptimization::relock_objects().\n-      continue;\n-    }\n-    BiasedLocking::revoke(thread, objects_to_revoke->at(i));\n-    assert(!objects_to_revoke->at(i)->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n@@ -1926,1 +1816,0 @@\n-  \/\/ We need to update the map if we have biased locking.\n@@ -1931,1 +1820,1 @@\n-  RegisterMap reg_map(current, UseBiasedLocking);\n+  RegisterMap reg_map(current, false);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":114,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -154,7 +154,0 @@\n- private:\n-  \/\/ Revoke biased locks at deopt.\n-  static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);\n-\n-  static void revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                               RegisterMap* map, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,56 +68,0 @@\n-JVMFlag::Error BiasedLockingBulkRebiasThresholdFunc(intx value, bool verbose) {\n-  if (value > BiasedLockingBulkRevokeThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRevokeThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingStartupDelayFunc(intx value, bool verbose) {\n-  if ((value % PeriodicTask::interval_gran) != 0) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingStartupDelay (\" INTX_FORMAT \") must be \"\n-                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n-                        value, PeriodicTask::interval_gran);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingBulkRevokeThresholdFunc(intx value, bool verbose) {\n-  if (value < BiasedLockingBulkRebiasThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else if ((double)value\/(double)BiasedLockingDecayTime > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingDecayTimeFunc(intx value, bool verbose) {\n-  if (BiasedLockingBulkRebiasThreshold\/(double)value > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        BiasedLockingBulkRebiasThreshold, value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,0 @@\n-  f(intx,   BiasedLockingBulkRebiasThresholdFunc)     \\\n-  f(intx,   BiasedLockingStartupDelayFunc)            \\\n-  f(intx,   BiasedLockingBulkRevokeThresholdFunc)     \\\n-  f(intx,   BiasedLockingDecayTimeFunc)               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-  \/\/ native methods so that biased locking can revoke the receiver's\n-  \/\/ bias if necessary.  This is also used by JVMTI's GetLocalInstance method\n+  \/\/ native methods. Used by JVMTI's GetLocalInstance method\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -797,31 +797,0 @@\n-  product(bool, UseBiasedLocking, false,                                    \\\n-          \"(Deprecated) Enable biased locking in JVM\")                      \\\n-                                                                            \\\n-  product(intx, BiasedLockingStartupDelay, 0,                               \\\n-          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n-          \"biased locking\")                                                 \\\n-          range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \\\n-          constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \\\n-                                                                            \\\n-  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n-          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"try to rebias all objects in the heap of that type\")             \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"permanently revoke biases of all objects in the heap of that \"   \\\n-          \"type\")                                                           \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingDecayTime, 25000,                              \\\n-          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n-          \"rebiasing of a type after previous bulk rebias\")                 \\\n-          range(500, max_intx)                                              \\\n-          constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -250,1 +249,1 @@\n-  if (PrintLockStatistics || PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintLockStatistics || PrintPreciseRTMLockingStatistics) {\n@@ -336,4 +335,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n-\n@@ -378,1 +373,1 @@\n-  if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintPreciseRTMLockingStatistics) {\n@@ -382,3 +377,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -2121,3 +2120,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -303,1 +302,1 @@\n-  \/\/ biased locking and any other IMS exception states take the slow-path\n+  \/\/ other IMS exception states take the slow-path\n@@ -352,2 +351,1 @@\n-    \/\/ Biased Locking in the object's header, the second check is for\n-    \/\/ stack-locking in the object's header, the third check is for\n+    \/\/ stack-locking in the object's header, the second check is for\n@@ -367,1 +365,0 @@\n-  \/\/ -- perform bias revocation, or\n@@ -434,4 +431,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-  }\n-\n@@ -439,2 +432,0 @@\n-  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n-\n@@ -475,3 +466,0 @@\n-  \/\/ We cannot check for Biased Locking if we are racing an inflation.\n-  assert(mark == markWord::INFLATING() ||\n-         !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -538,5 +526,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -552,5 +535,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -578,4 +556,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -598,6 +572,0 @@\n-  if (UseBiasedLocking) {\n-    Handle h_obj(current, obj);\n-    BiasedLocking::revoke(current, h_obj);\n-    obj = h_obj();\n-  }\n-  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -641,4 +609,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -667,4 +631,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -680,4 +640,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -699,4 +655,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -849,19 +801,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ NOTE: many places throughout the JVM do not expect a safepoint\n-    \/\/ to be taken here. However, we only ever bias Java instances and all\n-    \/\/ of the call sites of identity_hash that might revoke biases have\n-    \/\/ been checked to make sure they can handle a safepoint. The\n-    \/\/ added check of the bias pattern is to avoid useless calls to\n-    \/\/ thread-local storage.\n-    if (obj->mark().has_bias_pattern()) {\n-      \/\/ Handle for oop obj in case of STW safepoint\n-      Handle hobj(current, obj);\n-      if (SafepointSynchronize::is_at_safepoint()) {\n-        BiasedLocking::revoke_at_safepoint(hobj);\n-      } else {\n-        BiasedLocking::revoke(current->as_Java_thread(), hobj);\n-      }\n-      obj = hobj();\n-      assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-    }\n-  }\n@@ -875,3 +808,0 @@\n-    \/\/ object should remain ineligible for biased locking\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n-\n@@ -988,5 +918,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, h_obj);\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1016,9 +941,0 @@\n-  if (UseBiasedLocking) {\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke_at_safepoint(h_obj);\n-    } else {\n-      BiasedLocking::revoke(JavaThread::current(), h_obj);\n-    }\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1205,1 +1121,0 @@\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -1212,1 +1127,0 @@\n-    \/\/ *  BIASED       - Illegal.  We should never see this\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":88,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -187,1 +186,0 @@\n-\/\/ Support for forcing alignment of thread objects for biased locking\n@@ -189,19 +187,1 @@\n-  if (UseBiasedLocking) {\n-    const size_t alignment = markWord::biased_lock_alignment;\n-    size_t aligned_size = size + (alignment - sizeof(intptr_t));\n-    void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)\n-                                          : AllocateHeap(aligned_size, flags, CURRENT_PC,\n-                                                         AllocFailStrategy::RETURN_NULL);\n-    void* aligned_addr     = align_up(real_malloc_addr, alignment);\n-    assert(((uintptr_t) aligned_addr + (uintptr_t) size) <=\n-           ((uintptr_t) real_malloc_addr + (uintptr_t) aligned_size),\n-           \"JavaThread alignment code overflowed allocated storage\");\n-    if (aligned_addr != real_malloc_addr) {\n-      log_info(biasedlocking)(\"Aligned thread \" INTPTR_FORMAT \" to \" INTPTR_FORMAT,\n-                              p2i(real_malloc_addr),\n-                              p2i(aligned_addr));\n-    }\n-    ((Thread*) aligned_addr)->_real_malloc_address = real_malloc_addr;\n-    return aligned_addr;\n-  } else {\n-    return throw_excpt? AllocateHeap(size, flags, CURRENT_PC)\n+  return throw_excpt ? AllocateHeap(size, flags, CURRENT_PC)\n@@ -209,1 +189,0 @@\n-  }\n@@ -213,5 +192,1 @@\n-  if (UseBiasedLocking) {\n-    FreeHeap(((Thread*) p)->_real_malloc_address);\n-  } else {\n-    FreeHeap(p);\n-  }\n+  FreeHeap(p);\n@@ -291,8 +266,0 @@\n-#ifdef ASSERT\n-  if (UseBiasedLocking) {\n-    assert(is_aligned(this, markWord::biased_lock_alignment), \"forced alignment of thread object failed\");\n-    assert(this == _real_malloc_address ||\n-           this == align_up(_real_malloc_address, markWord::biased_lock_alignment),\n-           \"bug in forced alignment of thread objects\");\n-  }\n-#endif \/\/ ASSERT\n@@ -1082,1 +1049,0 @@\n-  _cached_monitor_info(nullptr),\n@@ -3051,2 +3017,0 @@\n-  BiasedLocking::init();\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -167,3 +167,0 @@\n-  \/\/ Support for forcing alignment of thread objects for biased locking\n-  void*       _real_malloc_address;\n-\n@@ -1554,3 +1551,0 @@\n-  \/\/ Biased locking support\n- private:\n-  GrowableArray<MonitorInfo*>* _cached_monitor_info;\n@@ -1558,3 +1552,0 @@\n-  GrowableArray<MonitorInfo*>* cached_monitor_info() { return _cached_monitor_info; }\n-  void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() == NULL || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,3 +235,2 @@\n-    \/\/ This monitor is really only needed for UseBiasedLocking, but\n-    \/\/ return it in all cases for now as it might be useful for stack\n-    \/\/ traces and tools as well\n+    \/\/ This monitor is not really needed but return it for now as it might be\n+    \/\/ useful for stack traces and tools\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-  template(EnableBiasedLocking)                   \\\n-  template(BulkRevokeBias)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -2632,1 +2631,0 @@\n-  declare_constant(markWord::biased_lock_bits)                            \\\n@@ -2637,1 +2635,0 @@\n-  declare_constant(markWord::biased_lock_shift)                           \\\n@@ -2643,3 +2640,0 @@\n-  declare_constant(markWord::biased_lock_mask)                            \\\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n-  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n@@ -2648,2 +2642,0 @@\n-  declare_constant(markWord::epoch_mask)                                  \\\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -2652,1 +2644,0 @@\n-  declare_constant(markWord::biased_lock_alignment)                       \\\n@@ -2658,1 +2649,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\\-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 18\\-ea\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]17\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]18\\f[R]) and a limited number of previous releases, detailed in the\n@@ -3943,10 +3943,0 @@\n-.TP\n-.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n-Enables the use of biased locking.\n-Some applications with significant amounts of uncontended\n-synchronization may attain significant speedups with this flag enabled,\n-but applications with certain patterns of locking may see slowdowns.\n-.RS\n-.PP\n-By default, this option is disabled.\n-.RE\n@@ -3967,0 +3957,10 @@\n+.TP\n+.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n+Enables the use of biased locking.\n+Some applications with significant amounts of uncontended\n+synchronization may attain significant speedups with this flag enabled,\n+but applications with certain patterns of locking may see slowdowns.\n+.RS\n+.PP\n+By default, this option is disabled.\n+.RE\n@@ -4881,8 +4881,0 @@\n-\\f[CB]TraceBiasedLocking\\f[R]\n-T}@T{\n-\\f[CB]\\-Xlog:biasedlocking=\\f[R]\\f[I]level\\f[R]\n-T}@T{\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]trace\\f[R] for additional information.\n-T}\n-T{\n","filename":"src\/java.base\/share\/man\/java.1","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n@@ -56,1 +55,0 @@\n-    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n@@ -61,3 +59,0 @@\n-    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n@@ -68,1 +63,0 @@\n-    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n@@ -73,1 +67,0 @@\n-    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n@@ -86,1 +79,0 @@\n-  private static long biasedLockBits;\n@@ -91,1 +83,0 @@\n-  private static long biasedLockShift;\n@@ -97,3 +88,0 @@\n-  private static long biasedLockMask;\n-  private static long biasedLockMaskInPlace;\n-  private static long biasedLockBitInPlace;\n@@ -104,1 +92,0 @@\n-  private static long biasedLockAlignment;\n@@ -110,1 +97,0 @@\n-  private static long biasedLockPattern;\n@@ -136,22 +122,0 @@\n-  \/\/ Biased locking accessors\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchoronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  public boolean hasBiasPattern() {\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);\n-  }\n-\n-  public JavaThread biasedLocker() {\n-    Threads threads = VM.getVM().getThreads();\n-    Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace & ageMaskInPlace));\n-    return threads.createJavaThreadWrapper(addr);\n-  }\n-\n-  \/\/ Indicates that the mark gas the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  public boolean isBiasedAnonymously() {\n-    return hasBiasPattern() && (biasedLocker() == null);\n-  }\n-\n@@ -163,1 +127,1 @@\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);\n+    return (Bits.maskBitsLong(value(), lockMaskInPlace) == unlockedValue);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -926,5 +926,1 @@\n-        if (isArray()) {\n-            return config.arrayPrototypeMarkWord();\n-        } else {\n-            return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);\n-        }\n+        return config.prototypeMarkWord();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -155,1 +154,1 @@\n-    long arrayPrototypeMarkWord() {\n+    long prototypeMarkWord() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-class ScopedDisabledBiasedLocking {\n-  bool _orig;\n-public:\n-  ScopedDisabledBiasedLocking() : _orig(UseBiasedLocking) { UseBiasedLocking = false; }\n-  ~ScopedDisabledBiasedLocking() { UseBiasedLocking = _orig; }\n-};\n-\n@@ -59,4 +52,0 @@\n-  \/\/ Need to disable biased locking to easily\n-  \/\/ create oops that \"must_be_preseved\"\n-  ScopedDisabledBiasedLocking dbl;\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -54,6 +53,0 @@\n-static void assert_not_test_pattern(Handle object, const char* pattern) {\n-  stringStream st;\n-  object->print_on(&st);\n-  ASSERT_FALSE(test_pattern(&st, pattern)) << pattern << \" found in \" << st.as_string();\n-}\n-\n@@ -96,21 +89,1 @@\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    \/\/ Can't test this with biased locking disabled.\n-    \/\/ Biased locking is initially enabled for this java.lang.Byte object.\n-    assert_test_pattern(h_obj, \"is_biased\");\n-\n-    \/\/ Lock using biased locking.\n-    BasicObjectLock lock;\n-    lock.set_obj(obj);\n-    markWord prototype_header = obj->klass()->prototype_header();\n-    markWord mark = obj->mark();\n-    markWord biased_mark = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n-    obj->set_mark(biased_mark);\n-    \/\/ Look for the biased_locker in markWord, not prototype_header.\n-#ifdef _LP64\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x0000000000000000\");\n-#else\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x00000000\");\n-#endif\n-  }\n-\n-  \/\/ Same thread tries to lock it again.\n+  \/\/ Thread tries to lock it.\n@@ -121,2 +94,0 @@\n-\n-  \/\/ This is no longer biased, because ObjectLocker revokes the bias.\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-\n-serviceability\/sa\/ClhsdbJstackXcompStress.java 8268570 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,5 +107,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8268570 generic-all\n-serviceability\/attach\/RemovingUnixDomainSocketTest.java 8268570 generic-all\n-serviceability\/sa\/TestJhsdbJstackLock.java 8268570 generic-all\n-serviceability\/sa\/JhsdbThreadInfoTest.java 8268570 generic-all\n-\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8062950\n- * @requires vm.flavor == \"server\"\n- * @library \/test\/lib\n- * @run driver compiler.c2.Test8062950\n- *\/\n-\n-package compiler.c2;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class Test8062950 {\n-    private static final String CLASSNAME = \"DoesNotExist\";\n-    public static void main(String[] args) throws Exception {\n-        ProcessTools.executeTestJvm(\"-Xcomp\",\n-                                    \"-XX:-TieredCompilation\",\n-                                    \"-XX:-UseOptoBiasInlining\",\n-                                    CLASSNAME)\n-                    .shouldHaveExitValue(1)\n-                    .shouldContain(\"Error: Could not find or load main class \" + CLASSNAME)\n-                    .shouldNotContain(\"A fatal error has been detected\")\n-                    .shouldNotContain(\"Internal Error\")\n-                    .shouldNotContain(\"HotSpot Virtual Machine Error\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8062950.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8217990\n- * @summary With -XX:+UseOptoBiasInlining loading the markword is replaced by 0L if EliminateLocks is disabled. assert(dmw->is_neutral()) failed: invariant fails.\n- * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n- *\n- * @library \/test\/lib \/test\/hotspot\/jtreg\n- *\n- * @build sun.hotspot.WhiteBox\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *                   -XX:CompileCommand=compileonly,*.TestUseOptoBiasInliningWithoutEliminateLocks::dontinline_testMethod\n- *                   -XX:CompileCommand=dontinline,*::dontinline_*\n- *                   -XX:-EliminateLocks\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                   -Xbatch\n- *                   -XX:-TieredCompilation\n- *                   compiler.c2.TestUseOptoBiasInliningWithoutEliminateLocks\n- *\/\n-\n-package compiler.c2;\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class TestUseOptoBiasInliningWithoutEliminateLocks {\n-\n-    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) {\n-        new TestUseOptoBiasInliningWithoutEliminateLocks().run();\n-    }\n-\n-    public boolean warmupDone;\n-\n-    public void run() {\n-        for(int i = 0; i < 30000; i++) {\n-            dontinline_testMethod();\n-        }\n-        warmupDone = true;\n-        dontinline_testMethod();\n-    }\n-\n-    public void dontinline_testMethod() {\n-        PointXY l1 = new PointXY(4.0f, 2.0f);\n-        synchronized (l1) {\n-            dontinline_deopt();\n-        }\n-    }\n-\n-    public void dontinline_deopt() {\n-        if (warmupDone) {\n-            WB.deoptimizeFrames(false);\n-        }\n-    }\n-\n-    static class PointXY {\n-\n-        public float fritz;\n-        public float felix;\n-\n-        public PointXY(float fritz_param, float felix_param) {\n-            this.fritz = fritz_param;\n-\/\/            this.felix = felix_param;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUseOptoBiasInliningWithoutEliminateLocks.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -42,2 +42,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n@@ -60,2 +58,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-    protected static final String RTM_BIASED_LOCKING_WARNING\n-            = \"Biased locking is not supported with RTM locking; \"\n-            + \"ignoring UseBiasedLocking flag\";\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMLocking and UseBiasedLocking\n- *          options combination on CPU, OS, and VM with rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionWithBiasedLocking\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionWithBiasedLocking {\n-\n-    public void runTestCases() throws Throwable {\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_BIASED_LOCKING_WARNING;\n-        String shouldPassMessage = \"JVM startup should pass with both \"\n-                + \"-XX:+UseRTMLocking and \"\n-                + \"-XX:-UseBiasedLocking flags set without any warnings\";\n-        \/\/ verify that we will not get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                shouldPassMessage, ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:-UseBiasedLocking\");\n-\n-        \/\/ verify that we will get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null,\n-                \"JVM startup should pass when both -XX:+UseRTMLocking and \"\n-                        + \"-XX:+UseBiasedLocking flags set\",\n-                \"Flags -XX:+UseRTMLocking\"\n-                        + \" and -XX:+UseBiasedLocking conflicts. \"\n-                        + \"Warning should be shown.\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-        \/\/ verify that UseBiasedLocking is false when we use rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseBiasedLocking\",\n-                \"false\",\n-                \"Value of option 'UseBiasedLocking' should be false if\"\n-                        + \"-XX:+UseRTMLocking flag set.\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can't turn on biased locking when\n-        \/\/ using rtm locking\n-        CommandLineOptionTest\n-                .verifyOptionValueForSameVM(\n-                        \"UseBiasedLocking\",\n-                        \"false\",\n-                        \"Value of option 'UseBiasedLocking' should be false if\"\n-                                + \"both -XX:+UseRTMLocking and \"\n-                                + \"-XX:+UseBiasedLocking flags set.\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionWithBiasedLocking().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionWithBiasedLocking.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8032011\n- * @summary biased locking's revoke_bias locks monitor in compiled frame with eliminated lock\n- *\n- * @run main\/othervm -XX:-UseOnStackReplacement\n- *      -XX:CompileCommand=dontinline,compiler.uncommontrap.TestLockEliminatedAtDeopt$A::m2\n- *      -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0\n- *      compiler.uncommontrap.TestLockEliminatedAtDeopt\n- *\/\n-\n-package compiler.uncommontrap;\n-\n-public class TestLockEliminatedAtDeopt {\n-\n-    static class A {\n-        void m() {\n-        }\n-\n-        \/\/ This lock is not eliminated but biased to main thread on\n-        \/\/ first call\n-        synchronized void m2(boolean trap) {\n-            if (trap) {\n-                new B();\n-            }\n-        }\n-    }\n-\n-    static class B extends A {\n-        void m() {\n-        }\n-    }\n-\n-    static void m1(boolean trap) {\n-        A a = new A();\n-        \/\/ This lock is eliminated by c2\n-        synchronized(a) {\n-            a.m2(trap);\n-            a.m();\n-        }\n-    }\n-\n-     public static void main(String[] args) {\n-        for (int i = 0; i < 20000; i++) {\n-            m1(false);\n-        }\n-        \/\/ Trigger uncommon trap in A.m2() (class unloaded) and\n-        \/\/ deoptimization of m1() (CHA invalidated). Uncommon trap\n-        \/\/ code locks monitor in m1's frame where's it's eliminated.\n-        m1(true);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestLockEliminatedAtDeopt.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -XX:NewSize=10m -XX:+FullGCALot -XX:FullGCALotInterval=120 -XX:+UseBiasedLocking gc.TestFullGCALot\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:BiasedLockingStartupDelay=4000 -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n+ * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n","filename":"test\/hotspot\/jtreg\/runtime\/7167069\/PrintAsFlag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,7 +45,3 @@\n-        {\"-Xint\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xint\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:+UseOptoBiasInlining\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:-UseOptoBiasInlining\"}\n+        {\"-Xint\"},\n+        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\"},\n+        {\"-Xcomp\", \"-XX:-TieredCompilation\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnValueBasedClassTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-            \/\/ i = 1 -- dump with agent = disable BiasedLocking\n-            \/\/ i = 2 -- dump with agent = enable BiasedLocking\n+            \/\/ i = 1 -- dump with agent\n@@ -67,1 +66,0 @@\n-            String biasedLock = (i != 2) ? \"-showversion\" : \"-XX:+UseBiasedLocking\";\n@@ -72,1 +70,1 @@\n-                                    agentArg, agentArg2, biasedLock);\n+                                    agentArg, agentArg2);\n@@ -79,1 +77,1 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2, biasedLock,\n+                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeDirectTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot HandshakeDirectTest\n@@ -38,0 +39,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +44,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 500000;\n+    static final int DIRECT_HANDSHAKES_MARK = 300000;\n@@ -44,1 +46,0 @@\n-    static Semaphore[] handshakeSem = new Semaphore[WORKING_THREADS];\n@@ -46,1 +47,0 @@\n-    static boolean[] isBiased = new boolean[WORKING_THREADS];\n@@ -52,0 +52,1 @@\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -53,10 +54,3 @@\n-        while (true) {\n-            try {\n-                if (!isBiased[me]) {\n-                    handshakeSem[me].acquire();\n-                    synchronized(locks[me]) {\n-                        isBiased[me] = true;\n-                    }\n-                    handshakeSem[me].release();\n-                }\n-\n+        while (handshakeCount.get() < DIRECT_HANDSHAKES_MARK) {\n+            boolean walked = false;\n+            synchronized(locks[me]) {\n@@ -69,13 +63,5 @@\n-                handshakeSem[handshakee].acquire();\n-                if (isBiased[handshakee]) {\n-                    \/\/ Revoke biased lock\n-                    synchronized(locks[handshakee]) {\n-                        handshakeCount.incrementAndGet();\n-                    }\n-                    \/\/ Create new lock to be biased\n-                    locks[handshakee] = new Object();\n-                    isBiased[handshakee] = false;\n-                }\n-                handshakeSem[handshakee].release();\n-                if (handshakeCount.get() >= DIRECT_HANDSHAKES_MARK) {\n-                    break;\n+                \/\/ Inflate locks[handshakee] if possible\n+                System.identityHashCode(locks[handshakee]);\n+                walked = wb.handshakeReadMonitors(workingThreads[handshakee]);\n+                if (walked) {\n+                    handshakeCount.incrementAndGet();\n@@ -83,2 +69,0 @@\n-            } catch(InterruptedException ie) {\n-                throw new Error(\"Unexpected interrupt\");\n@@ -86,0 +70,1 @@\n+            locks[me] = new Object();\n@@ -92,5 +77,0 @@\n-        \/\/ Initialize semaphores\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            handshakeSem[i] = new Semaphore(1);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":15,"deletions":35,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149383\n- * @summary -Xlog:biasedlocking should have logging from statements in the source code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver BiasedLockingTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BiasedLockingTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Biased locking enabled\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[biasedlocking]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                                  \"-Xlog:biasedlocking\",\n-                                                                  \"-XX:BiasedLockingStartupDelay=0\",\n-                                                                  InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-Xlog:biasedlocking=off\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) {\n-            System.out.println(\"Biased Locking test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BiasedLockingTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorStackDepthInfo\/GetOwnedMonitorStackDepthInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -124,1 +124,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -135,1 +135,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-                    \"InvocationCounter::count_increment\",\n-                    \"markWord::epoch_mask_in_place\"));\n+                    \"InvocationCounter::count_increment\"));\n@@ -96,1 +95,0 @@\n-        \/\/ longConstant markWord::biased_lock_bits 1\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -52,1 +52,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -60,1 +60,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -68,25 +68,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -103,1 +79,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -235,1 +211,0 @@\n-        new EARelockingSimple_2Target()                                                     .run();\n@@ -241,2 +216,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3Target()                             .run();\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4Target()                             .run();\n@@ -352,1 +325,0 @@\n-        new EARelockingSimple_2()                                                     .run(this);\n@@ -358,2 +330,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3()                             .run(this);\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4()                             .run(this);\n@@ -796,2 +766,0 @@\n-    public static final long BiasedLockingBulkRebiasThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRebiasThreshold\");\n-    public static final long BiasedLockingBulkRevokeThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRevokeThreshold\");\n@@ -812,2 +780,0 @@\n-    public volatile Object biasToBeRevoked;\n-\n@@ -1057,40 +1023,0 @@\n-    \/**\n-     * Trigger bulk rebiasing for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRebiasAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRebiasThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Trigger bulk revoke of biases for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRevokeAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRevokeThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n@@ -1767,32 +1693,0 @@\n-\/**\n- * Test if the bias of an object O that escapes globally is revoked correctly if local objects\n- * escape through JVMTI. O is referenced by field l0.\n- * This tests a regression of a previous version of the implementation.\n- *\/\n-class EARelockingSimple_2 extends EATestCaseBaseDebugger {\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingSimple_2Target extends EATestCaseBaseTarget {\n-\n-    public XYVal l0;\n-\n-    public void dontinline_testMethod() {\n-        l0 = new XYVal(4, 2);         \/\/ GobalEscape\n-        XYVal l1 = new XYVal(4, 2);\n-        synchronized (l0) {\n-            synchronized (l1) {\n-                dontinline_brkpt();\n-            }\n-        }\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -1997,99 +1891,0 @@\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}.\n- * A bulk rebias operation is triggered at a position where all locks on the local object referenced\n- * by l1 are eliminated. This leaves the object with an outdated biased locking epoch which has to be\n- * considered when relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_3Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRebiasAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_3}.\n- * But instead of a bulk rebias a bulk revoke operation is triggered.\n- * This leaves the object with a stale bias as the prototype header of its calls lost its bias\n- * pattern in the bulk revoke which has to be considered during relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_4Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRevokeAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":5,"deletions":210,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -1,305 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.runtime;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.*;\n-import java.util.concurrent.FutureTask;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents\n- *\/\n-public class TestBiasedLockRevocationEvents {\n-\n-    public static void main(String[] args) throws Throwable {\n-        testSingleRevocation();\n-        testBulkRevocation();\n-        testSelfRevocation();\n-        testExitedThreadRevocation();\n-        testBulkRevocationNoRebias();\n-        testRevocationSafepointIdCorrelation();\n-    }\n-\n-    \/\/ Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.\n-    \/\/ Using a value that will hit the first threshold once, and the second one the next time.\n-    private static final int BULK_REVOKE_THRESHOLD = 25;\n-\n-    static void touch(Object lock) {\n-        synchronized(lock) {\n-        }\n-    }\n-\n-    static Thread triggerRevocation(int numRevokes, Class<?> lockClass) throws Throwable {\n-        Object[] locks = new Object[numRevokes];\n-        for (int i = 0; i < locks.length; ++i) {\n-            locks[i] = lockClass.getDeclaredConstructor().newInstance();\n-            touch(locks[i]);\n-        }\n-\n-        Thread biasBreaker = new Thread(\"BiasBreaker\") {\n-            @Override\n-            public void run() {\n-                for (Object lock : locks) {\n-                    touch(lock);\n-                }\n-            }\n-        };\n-\n-        biasBreaker.start();\n-        biasBreaker.join();\n-\n-        return biasBreaker;\n-    }\n-\n-    \/\/ Basic stack trace validation, checking the name of the leaf method\n-    static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {\n-        List<RecordedFrame> frames = stackTrace.getFrames();\n-        Asserts.assertFalse(frames.isEmpty());\n-        String name = frames.get(0).getMethod().getName();\n-        Asserts.assertEquals(name, leafMethodName);\n-    }\n-\n-    \/\/ Validates that the given stack trace refers to lock.touch(); in triggerRevocation\n-    static void validateStackTrace(RecordedStackTrace stackTrace) {\n-        validateStackTrace(stackTrace, \"touch\");\n-    }\n-\n-    \/\/ Retrieve all biased lock revocation events related to the provided lock class, sorted by start time\n-    static List<RecordedEvent> getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class<?> lockClass) throws Throwable {\n-        return Events.fromRecording(recording).stream()\n-                .filter(e -> e.getEventType().getName().equals(eventTypeName))\n-                .filter(e -> ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))\n-                .sorted(Comparator.comparing(RecordedEvent::getStartTime))\n-                .collect(Collectors.toList());\n-    }\n-\n-    static void testSingleRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(1, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertEventThread(event, \"previousOwner\", Thread.currentThread());\n-\n-        RecordedClass lockClass = event.getValue(\"lockClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertField(event, \"disableBiasing\").equal(false);\n-\n-        RecordedClass lockClass = event.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testSelfRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockSelfRevocation);\n-        recording.start();\n-\n-        MyLock l = new MyLock();\n-        touch(l);\n-        Thread.holdsLock(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-\n-        validateStackTrace(event.getStackTrace(), \"holdsLock\");\n-    }\n-\n-    static void testExitedThreadRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        FutureTask<MyLock> lockerTask = new FutureTask<>(() -> {\n-           MyLock l = new MyLock();\n-           touch(l);\n-           return l;\n-        });\n-\n-        Thread locker = new Thread(lockerTask, \"BiasLocker\");\n-        locker.start();\n-        locker.join();\n-\n-        \/\/ Even after joining, the VM has a bit more work to do before the thread is actually removed\n-        \/\/ from the threads list. Ensure that this has happened before proceeding.\n-        while (true) {\n-            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-            OutputAnalyzer oa = jcmd.execute(\"Thread.print\", true);\n-            String lockerThreadFound = oa.firstMatch(\"BiasLocker\");\n-            if (lockerThreadFound == null) {\n-                break;\n-            }\n-        };\n-\n-        MyLock l = lockerTask.get();\n-        touch(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-        \/\/ Previous owner will usually be null, but can also be a thread that\n-        \/\/ was created after the BiasLocker thread exited due to address reuse.\n-        RecordedThread prevOwner = event.getValue(\"previousOwner\");\n-        if (prevOwner != null) {\n-            Asserts.assertNE(prevOwner.getJavaName(), \"BiasLocker\");\n-        }\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocationNoRebias() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-        Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 2);\n-\n-        \/\/ The rebias event should occur before the noRebias one\n-        RecordedEvent eventRebias = events.get(0);\n-        RecordedEvent eventNoRebias = events.get(1);\n-\n-        Events.assertEventThread(eventRebias, biasBreaker0);\n-        Events.assertField(eventRebias, \"disableBiasing\").equal(false);\n-\n-        Events.assertEventThread(eventNoRebias, biasBreaker1);\n-        Events.assertField(eventNoRebias, \"disableBiasing\").equal(true);\n-\n-        RecordedClass lockClassRebias = eventRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());\n-        RecordedClass lockClassNoRebias = eventNoRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(eventRebias.getStackTrace());\n-        validateStackTrace(eventNoRebias.getStackTrace());\n-    }\n-\n-    static void testRevocationSafepointIdCorrelation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.enable(EventNames.ExecuteVMOperation);\n-        recording.start();\n-\n-        triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-\n-        \/\/ Determine which safepoints included bulk revocation VM operations\n-        Set<Long> vmOperationsBulk = new HashSet<>();\n-\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {\n-                String operation = event.getValue(\"operation\");\n-                Long safepointId = event.getValue(\"safepointId\");\n-\n-                if (operation.equals(\"BulkRevokeBias\")) {\n-                    vmOperationsBulk.add(safepointId);\n-                }\n-            }\n-        }\n-\n-        int bulkRevokeCount = 0;\n-\n-        \/\/ Match all revoke events to a corresponding VMOperation event\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {\n-                Long safepointId = event.getValue(\"safepointId\");\n-                String lockClass = ((RecordedClass)event.getValue(\"revokedClass\")).getName();\n-                if (lockClass.toString().equals(MyLock.class.getName())) {\n-                    Asserts.assertTrue(vmOperationsBulk.contains(safepointId));\n-                    bulkRevokeCount++;\n-                }\n-            }\n-        }\n-\n-        Asserts.assertGT(bulkRevokeCount, 0);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBiasedLockRevocationEvents.java","additions":0,"deletions":305,"binary":false,"changes":305,"status":"deleted"},{"patch":"@@ -83,3 +83,0 @@\n-    public final static String BiasedLockRevocation = PREFIX + \"BiasedLockRevocation\";\n-    public final static String BiasedLockSelfRevocation = PREFIX + \"BiasedLockSelfRevocation\";\n-    public final static String BiasedLockClassRevocation = PREFIX + \"BiasedLockClassRevocation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+  public native boolean handshakeReadMonitors(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,12 +113,0 @@\n-    \/**\n-     * Same as {@link #testRecursiveSynchronization()} but the first call\n-     * to this method will generate the identity hashcode for this object\n-     * which effectively disables biased locking as they occupy the same\n-     * bits in the object header.\n-     *\/\n-    @Benchmark\n-    public void testRecursiveSynchronizationNoBias() {\n-        System.identityHashCode(this);\n-        factorial = fact(10);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}