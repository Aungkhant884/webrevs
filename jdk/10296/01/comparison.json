{"files":[{"patch":"@@ -1169,2 +1169,2 @@\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps) {\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n@@ -1179,1 +1179,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_oopmaps, open_heap_oopmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n@@ -1185,1 +1185,1 @@\n-                                        closed_heap_oopmaps,\n+                                        closed_heap_bitmaps,\n@@ -1190,1 +1190,1 @@\n-                                        open_heap_oopmaps,\n+                                        open_heap_bitmaps,\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-struct ArchiveHeapOopmapInfo;\n+struct ArchiveHeapBitmapInfo;\n@@ -409,2 +409,2 @@\n-                     GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps);\n+                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n+                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    fill_failed_loaded_region();\n+    fill_failed_loaded_heap();\n@@ -83,1 +83,0 @@\n-  SystemDictionaryShared::update_archived_mirror_native_pointers();\n@@ -174,1 +173,1 @@\n-                                             int num_loaded_regions) {\n+                                                    int num_loaded_regions) {\n@@ -317,1 +316,1 @@\n-      \/\/ in fill_failed_loaded_region(), and it will eventually be GC'ed.\n+      \/\/ in fill_failed_loaded_heap(), and it will eventually be GC'ed.\n@@ -342,0 +341,1 @@\n+    r->set_mapped_base((char*)load_address);\n@@ -395,5 +395,5 @@\n-    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n-    HeapWord* top    = (HeapWord*)_loaded_heap_top;\n-\n-    MemRegion archive_space = MemRegion(bottom, top);\n-    Universe::heap()->complete_loaded_archive_space(archive_space);\n+    \/\/ These operations are needed only when the heap is loaded (not mapped).\n+    finish_loaded_heap();\n+    if (VerifyArchivedFields > 0) {\n+      verify_loaded_heap();\n+    }\n@@ -401,0 +401,2 @@\n+  patch_native_pointers();\n+}\n@@ -402,3 +404,7 @@\n-  if (VerifyArchivedFields <= 0 || !is_loaded()) {\n-    return;\n-  }\n+void ArchiveHeapLoader::finish_loaded_heap() {\n+  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+  HeapWord* top    = (HeapWord*)_loaded_heap_top;\n+\n+  MemRegion archive_space = MemRegion(bottom, top);\n+  Universe::heap()->complete_loaded_archive_space(archive_space);\n+}\n@@ -406,0 +412,1 @@\n+void ArchiveHeapLoader::verify_loaded_heap() {\n@@ -427,1 +434,1 @@\n-void ArchiveHeapLoader::fill_failed_loaded_region() {\n+void ArchiveHeapLoader::fill_failed_loaded_heap() {\n@@ -437,0 +444,35 @@\n+class PatchNativePointers: public BitMapClosure {\n+  Metadata** _start;\n+\n+ public:\n+  PatchNativePointers(Metadata** start) : _start(start) {}\n+\n+  bool do_bit(size_t offset) {\n+    Metadata** p = _start + offset;\n+    *p = (Metadata*)(address(*p) + MetaspaceShared::relocation_delta());\n+    \/\/ Currently we have only Klass pointers in heap objects.\n+    \/\/ This needs to be relaxed when we support other types of native\n+    \/\/ pointers such as Method.\n+    assert(((Klass*)(*p))->is_klass(), \"must be\");\n+    return true;\n+  }\n+};\n+\n+void ArchiveHeapLoader::patch_native_pointers() {\n+  if (MetaspaceShared::relocation_delta() == 0) {\n+    return;\n+  }\n+\n+  for (int i = MetaspaceShared::first_archive_heap_region;\n+       i <= MetaspaceShared::last_archive_heap_region; i++) {\n+    FileMapRegion* r = FileMapInfo::current_info()->space_at(i);\n+    if (r->mapped_base() != NULL) {\n+      if (MetaspaceShared::relocation_delta() != 0 && r->has_ptrmap()) {\n+        log_info(cds, heap)(\"Patching native pointers in heap region %d\", i);\n+        BitMapView bm = r->ptrmap_view();\n+        PatchNativePointers patcher((Metadata**)r->mapped_base());\n+        bm.iterate(&patcher);\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -149,1 +149,4 @@\n-  static void fill_failed_loaded_region();\n+  static void patch_native_pointers();\n+  static void finish_loaded_heap();\n+  static void verify_loaded_heap();\n+  static void fill_failed_loaded_heap();\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1495,0 +1495,23 @@\n+void FileMapRegion::init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap) {\n+  _oopmap_offset = oopmap._bm_region_offset;\n+  _oopmap_size_in_bits = oopmap._size_in_bits;\n+\n+  _ptrmap_offset = ptrmap._bm_region_offset;\n+  _ptrmap_size_in_bits = ptrmap._size_in_bits;\n+}\n+\n+BitMapView FileMapRegion::bitmap_view(bool is_oopmap) {\n+  char* bitmap_base = FileMapInfo::current_info()->map_bitmap_region();\n+  bitmap_base += is_oopmap ? _oopmap_offset : _ptrmap_offset;\n+  size_t size_in_bits = is_oopmap ? _oopmap_size_in_bits : _ptrmap_size_in_bits;\n+  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n+}\n+\n+BitMapView FileMapRegion::oopmap_view() {\n+  return bitmap_view(true);\n+}\n+\n+BitMapView FileMapRegion::ptrmap_view() {\n+  assert(has_ptrmap(), \"must be\");\n+  return bitmap_view(false);\n+}\n@@ -1569,4 +1592,4 @@\n-size_t FileMapInfo::set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_size) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    oopmaps->at(i)._offset = curr_size;\n-    curr_size += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_size) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    bitmaps->at(i)._bm_region_offset = curr_size;\n+    curr_size += bitmaps->at(i)._size_in_bytes;\n@@ -1577,4 +1600,4 @@\n-size_t FileMapInfo::write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_offset, char* buffer) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    memcpy(buffer + curr_offset, oopmaps->at(i)._oopmap, oopmaps->at(i)._oopmap_size_in_bytes);\n-    curr_offset += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_offset, char* buffer) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    memcpy(buffer + curr_offset, bitmaps->at(i)._map, bitmaps->at(i)._size_in_bytes);\n+    curr_offset += bitmaps->at(i)._size_in_bytes;\n@@ -1586,2 +1609,2 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -1592,3 +1615,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_in_bytes = set_oopmaps_offset(closed_oopmaps, size_in_bytes);\n-    size_in_bytes = set_oopmaps_offset(open_oopmaps, size_in_bytes);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_in_bytes = set_bitmaps_offset(closed_bitmaps, size_in_bytes);\n+    size_in_bytes = set_bitmaps_offset(open_bitmaps, size_in_bytes);\n@@ -1601,3 +1624,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_t curr_offset = write_oopmaps(closed_oopmaps, ptrmap->size_in_bytes(), buffer);\n-    write_oopmaps(open_oopmaps, curr_offset, buffer);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_t curr_offset = write_bitmaps(closed_bitmaps, ptrmap->size_in_bytes(), buffer);\n+    write_bitmaps(open_bitmaps, curr_offset, buffer);\n@@ -1642,1 +1665,1 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -1668,2 +1691,4 @@\n-      space_at(region_idx)->init_oopmap(oopmaps->at(i)._offset,\n-                                        oopmaps->at(i)._oopmap_size_in_bits);\n+      int oopmap_idx = i * 2;\n+      int ptrmap_idx = i * 2 + 1;\n+      space_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n+                                         bitmaps->at(ptrmap_idx));\n@@ -2310,0 +2335,2 @@\n+\n+    si->set_mapped_base(base);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+class BitMapView;\n@@ -105,5 +106,5 @@\n-struct ArchiveHeapOopmapInfo {\n-  address _oopmap;               \/\/ bitmap for relocating embedded oops\n-  size_t  _offset;               \/\/ this oopmap is stored at this offset from the bottom of the BM region\n-  size_t  _oopmap_size_in_bits;\n-  size_t  _oopmap_size_in_bytes;\n+struct ArchiveHeapBitmapInfo {\n+  address _map;               \/\/ bitmap for relocating embedded oops\n+  size_t  _bm_region_offset;  \/\/ this bitmap is stored at this offset from the bottom of the BM region\n+  size_t  _size_in_bits;\n+  size_t  _size_in_bytes;\n@@ -140,0 +141,1 @@\n+  BitMapView bitmap_view(bool is_oopmap);\n@@ -159,1 +161,1 @@\n-  char*  mapped_base()              const { assert_is_not_heap_region(); return _mapped_base; }\n+  char*  mapped_base()              const { return _mapped_base; }\n@@ -173,5 +175,4 @@\n-\n-  void init_oopmap(size_t oopmap_offset, size_t size_in_bits) {\n-    _oopmap_offset = oopmap_offset;\n-    _oopmap_size_in_bits = size_in_bits;\n-  }\n+  void init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap);\n+  BitMapView oopmap_view();\n+  BitMapView ptrmap_view();\n+  bool has_ptrmap()                  { return _ptrmap_size_in_bits != 0; }\n@@ -447,2 +448,2 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                            GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -451,1 +452,1 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -576,2 +577,2 @@\n-  static size_t set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_size);\n-  static size_t write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_offset, char* buffer);\n+  static size_t set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_size);\n+  static size_t write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_offset, char* buffer);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n@@ -323,0 +324,1 @@\n+    mark_native_pointers(obj, archived_oop);\n@@ -356,0 +358,26 @@\n+void HeapShared::mark_native_pointers(oop orig_obj, oop archived_obj) {\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    mark_one_native_pointer(archived_obj, java_lang_Class::klass_offset());\n+    mark_one_native_pointer(archived_obj, java_lang_Class::array_klass_offset());\n+  }\n+}\n+\n+void HeapShared::mark_one_native_pointer(oop archived_obj, int offset) {\n+  Metadata* ptr = archived_obj->metadata_field_acquire(offset);\n+  if (ptr != NULL) {\n+    \/\/ Set the native pointer to the requested address (at runtime, if the metadata\n+    \/\/ is mapped at the default location, it will be at this address).\n+    address buffer_addr = ArchiveBuilder::current()->get_buffered_addr((address)ptr);\n+    address requested_addr = ArchiveBuilder::current()->to_requested(buffer_addr);\n+    archived_obj->metadata_field_put(offset, (Metadata*)requested_addr);\n+\n+    \/\/ Remember this pointer. At runtime, if the metadata is mapped at a non-default\n+    \/\/ location, the pointer needs to be patched (see ArchiveHeapLoader::patch_native_pointers()).\n+    _native_pointers->append(archived_obj->field_addr<Metadata*>(offset));\n+\n+    log_debug(cds, heap, mirror)(\n+        \"Marked metadata field at %d: \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+         offset, p2i(ptr), p2i(requested_addr));\n+  }\n+}\n+\n@@ -1634,0 +1662,1 @@\n+    _native_pointers = new GrowableArrayCHeap<Metadata**, mtClassShared>(2048);\n@@ -1799,0 +1828,29 @@\n+\n+ResourceBitMap HeapShared::calculate_ptrmap(MemRegion region) {\n+  size_t num_bits = region.byte_size() \/ sizeof(Metadata*);\n+  ResourceBitMap oopmap(num_bits);\n+\n+  Metadata** start = (Metadata**)region.start();\n+  Metadata** end   = (Metadata**)region.end();\n+\n+  int num_non_null_ptrs = 0;\n+  int len = _native_pointers->length();\n+  for (int i = 0; i < len; i++) {\n+    Metadata** p = _native_pointers->at(i);\n+    if (start <= p && p < end) {\n+      assert(*p != NULL, \"must be non-null\");\n+      num_non_null_ptrs ++;\n+      size_t idx = p - start;\n+      oopmap.set_bit(idx);\n+    }\n+  }\n+\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers out of \"\n+                      SIZE_FORMAT \" possible locations\", num_non_null_ptrs, num_bits);\n+  if (num_non_null_ptrs > 0) {\n+    return oopmap;\n+  } else {\n+    return ResourceBitMap(0);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  static GrowableArrayCHeap<Metadata**, mtClassShared>* _native_pointers;\n@@ -315,0 +316,2 @@\n+  static void mark_native_pointers(oop orig_obj, oop archived_obj);\n+  static void mark_one_native_pointer(oop archived_obj, int offset);\n@@ -363,1 +366,2 @@\n-  static ResourceBitMap calculate_oopmap(MemRegion region);\n+  static ResourceBitMap calculate_oopmap(MemRegion region); \/\/ marks all the oop pointers\n+  static ResourceBitMap calculate_ptrmap(MemRegion region); \/\/ marks all the native pointers\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -441,2 +441,2 @@\n-  GrowableArray<ArchiveHeapOopmapInfo> *_closed_heap_oopmaps;\n-  GrowableArray<ArchiveHeapOopmapInfo> *_open_heap_oopmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_closed_heap_bitmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_open_heap_bitmaps;\n@@ -445,3 +445,5 @@\n-  void dump_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                 GrowableArray<ArchiveHeapOopmapInfo>* oopmaps);\n+  void dump_heap_bitmaps() NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                         GrowableArray<ArchiveHeapBitmapInfo>* bitmaps);\n+  void dump_one_heap_bitmap(MemRegion region, GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                            ResourceBitMap bitmap, bool is_oopmap);\n@@ -460,2 +462,2 @@\n-    _closed_heap_oopmaps(NULL),\n-    _open_heap_oopmaps(NULL) {}\n+    _closed_heap_bitmaps(NULL),\n+    _open_heap_bitmaps(NULL) {}\n@@ -507,1 +509,1 @@\n-  dump_heap_oopmaps();\n+  dump_heap_bitmaps();\n@@ -569,2 +571,2 @@\n-                        _closed_heap_oopmaps,\n-                        _open_heap_oopmaps);\n+                        _closed_heap_bitmaps,\n+                        _open_heap_bitmaps);\n@@ -894,1 +896,1 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps() {\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps() {\n@@ -896,2 +898,2 @@\n-    _closed_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_closed_heap_regions, _closed_heap_oopmaps);\n+    _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_closed_heap_regions, _closed_heap_bitmaps);\n@@ -899,2 +901,2 @@\n-    _open_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_open_heap_regions, _open_heap_oopmaps);\n+    _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_open_heap_regions, _open_heap_bitmaps);\n@@ -904,18 +906,8 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                                   GrowableArray<ArchiveHeapOopmapInfo>* oopmaps) {\n-  for (int i=0; i<regions->length(); i++) {\n-    ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions->at(i));\n-    size_t size_in_bits = oopmap.size();\n-    size_t size_in_bytes = oopmap.size_in_bytes();\n-    uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    oopmap.write_to(buffer, size_in_bytes);\n-    log_info(cds, heap)(\"Oopmap = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n-                        INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n-                        p2i(buffer), size_in_bytes,\n-                        p2i(regions->at(i).start()), regions->at(i).byte_size());\n-\n-    ArchiveHeapOopmapInfo info;\n-    info._oopmap = (address)buffer;\n-    info._oopmap_size_in_bits = size_in_bits;\n-    info._oopmap_size_in_bytes = size_in_bytes;\n-    oopmaps->append(info);\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                                                   GrowableArray<ArchiveHeapBitmapInfo>* bitmaps) {\n+  for (int i = 0; i < regions->length(); i++) {\n+    MemRegion region = regions->at(i);\n+    ResourceBitMap oopmap = HeapShared::calculate_oopmap(region);\n+    ResourceBitMap ptrmap = HeapShared::calculate_ptrmap(region);\n+    dump_one_heap_bitmap(region, bitmaps, oopmap, true);\n+    dump_one_heap_bitmap(region, bitmaps, ptrmap, false);\n@@ -924,0 +916,29 @@\n+\n+void VM_PopulateDumpSharedSpace::dump_one_heap_bitmap(MemRegion region,\n+                                                      GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                                                      ResourceBitMap bitmap, bool is_oopmap) {\n+  size_t size_in_bits = bitmap.size();\n+  size_t size_in_bytes;\n+  uintptr_t* buffer;\n+\n+  if (size_in_bits > 0) {\n+    size_in_bytes = bitmap.size_in_bytes();\n+    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n+    bitmap.write_to(buffer, size_in_bytes);\n+  } else {\n+    size_in_bytes = 0;\n+    buffer = NULL;\n+  }\n+\n+  log_info(cds, heap)(\"%s = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n+                      INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n+                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n+                      p2i(buffer), size_in_bytes,\n+                      p2i(region.start()), region.byte_size());\n+\n+  ArchiveHeapBitmapInfo info;\n+  info._map = (address)buffer;\n+  info._size_in_bits = size_in_bits;\n+  info._size_in_bytes = size_in_bytes;\n+  bitmaps->append(info);\n+}\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":54,"deletions":33,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1120,15 +1120,0 @@\n-static void set_klass_field_in_archived_mirror(oop mirror_obj, int offset, Klass* k) {\n-  assert(java_lang_Class::is_instance(mirror_obj), \"must be\");\n-  \/\/ this is the copy of k in the output buffer\n-  Klass* copy = ArchiveBuilder::get_buffered_klass(k);\n-\n-  \/\/ This is the address of k, if the archive is loaded at the requested location\n-  Klass* def = ArchiveBuilder::current()->to_requested(copy);\n-\n-  log_debug(cds, heap, mirror)(\n-      \"Relocate mirror metadata field at %d from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-      offset, p2i(k), p2i(def));\n-\n-  mirror_obj->metadata_field_put(offset, def);\n-}\n-\n@@ -1145,5 +1130,0 @@\n-      Klass *ak = (Klass*)(archived_m->metadata_field(_array_klass_offset));\n-      assert(ak != NULL || t == T_VOID, \"should not be NULL\");\n-      if (ak != NULL) {\n-        set_klass_field_in_archived_mirror(archived_m, _array_klass_offset, ak);\n-      }\n@@ -1263,11 +1243,0 @@\n-  \/\/ The archived mirror's field at _klass_offset is still pointing to the original\n-  \/\/ klass. Updated the field in the archived mirror to point to the relocated\n-  \/\/ klass in the archive.\n-  set_klass_field_in_archived_mirror(archived_mirror, _klass_offset, as_Klass(mirror));\n-\n-  \/\/ The field at _array_klass_offset is pointing to the original one dimension\n-  \/\/ higher array klass if exists. Relocate the pointer.\n-  Klass *arr = array_klass_acquire(mirror);\n-  if (arr != NULL) {\n-    set_klass_field_in_archived_mirror(archived_mirror, _array_klass_offset, arr);\n-  }\n@@ -1277,27 +1246,0 @@\n-void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {\n-  if (MetaspaceShared::relocation_delta() != 0) {\n-    assert(archived_mirror->metadata_field(_klass_offset) == NULL, \"must be for primitive class\");\n-\n-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-    if (ak != NULL) {\n-      archived_mirror->metadata_field_put(_array_klass_offset,\n-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-    }\n-  }\n-}\n-\n-void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {\n-  assert(MetaspaceShared::relocation_delta() != 0, \"must be\");\n-\n-  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n-  archived_mirror->metadata_field_put(_klass_offset,\n-      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n-\n-  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-  if (ak != NULL) {\n-    archived_mirror->metadata_field_put(_array_klass_offset,\n-        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -256,2 +256,0 @@\n-  static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1551,70 +1551,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-class ArchivedMirrorPatcher {\n-protected:\n-  static void update(Klass* k) {\n-    if (k->has_archived_mirror_index()) {\n-      oop m = k->archived_java_mirror();\n-      if (m != NULL) {\n-        java_lang_Class::update_archived_mirror_native_pointers(m);\n-      }\n-    }\n-  }\n-\n-public:\n-  static void update_array_klasses(Klass* ak) {\n-    while (ak != NULL) {\n-      update(ak);\n-      ak = ArrayKlass::cast(ak)->higher_dimension();\n-    }\n-  }\n-\n-  void do_value(const RunTimeClassInfo* info) {\n-    InstanceKlass* ik = info->_klass;\n-    update(ik);\n-    update_array_klasses(ik->array_klasses());\n-  }\n-};\n-\n-class ArchivedLambdaMirrorPatcher : public ArchivedMirrorPatcher {\n-public:\n-  void do_value(const RunTimeLambdaProxyClassInfo* info) {\n-    InstanceKlass* ik = info->proxy_klass_head();\n-    while (ik != NULL) {\n-      update(ik);\n-      Klass* k = ik->next_link();\n-      ik = (k != NULL) ? InstanceKlass::cast(k) : NULL;\n-    }\n-  }\n-};\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {\n-  ArchivedMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict) {\n-  ArchivedLambdaMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers() {\n-  if (!ArchiveHeapLoader::are_archived_mirrors_available()) {\n-    return;\n-  }\n-  if (MetaspaceShared::relocation_delta() == 0) {\n-    return;\n-  }\n-  \/\/ mirrors are not archived for the classes in the dynamic archive\n-  update_archived_mirror_native_pointers_for(&_static_archive._builtin_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._unregistered_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._lambda_proxy_class_dictionary);\n-\n-  for (int t = T_BOOLEAN; t <= T_LONG; t++) {\n-    Klass* k = Universe::typeArrayKlassObj((BasicType)t);\n-    ArchivedMirrorPatcher::update_array_klasses(k);\n-  }\n-  ArchivedMirrorPatcher::update_array_klasses(Universe::fillerArrayKlassObj());\n-}\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -349,8 +349,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-private:\n-  static void update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict);\n-  static void update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict);\n-public:\n-  static void update_archived_mirror_native_pointers() NOT_CDS_RETURN;\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 14\n+#define CURRENT_CDS_ARCHIVE_VERSION 15\n@@ -58,1 +58,2 @@\n-  size_t  _oopmap_offset;     \/\/ Bitmap for relocating embedded oops (offset from SharedBaseAddress).\n+  size_t  _oopmap_offset;     \/\/ Bitmap for relocating oop fields in archived heap objects.\n+                              \/\/ (The base address is the bottom of the BM region)\n@@ -60,0 +61,3 @@\n+  size_t  _ptrmap_offset;     \/\/ Bitmap for relocating native pointer fields in archived heap objects.\n+                              \/\/ (The base address is the bottom of the BM region).\n+  size_t  _ptrmap_size_in_bits;\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -261,3 +261,0 @@\n-      if (mirror_oop != NULL) { \/\/ may be null if archived heap is disabled\n-        java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);\n-      }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,0 +94,14 @@\n+        System.out.println(\"2. Exec with \" + execGC + \" and test ArchiveRelocationMode\");\n+        out = TestCommon.exec(helloJar,\n+                              execGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds,cds+heap\",\n+                              \"-XX:ArchiveRelocationMode=1\", \/\/ always relocate shared metadata\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        if (dumpGC.equals(G1)) {\n+            out.shouldContain(\"Patching native pointers in heap region\");\n+        }\n+        out.shouldHaveExitValue(0);\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestSerialGCWithCDS.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}