{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.HexFormat;\n@@ -105,1 +106,1 @@\n-                + textLength + \" text lenght; \" + AADLength + \" AAD length; \"\n+                + textLength + \" text length; \" + AADLength + \" AAD length; \"\n@@ -242,1 +243,1 @@\n-            int txtOffset, int lenght, int offset, AlgorithmParameters params)\n+            int txtOffset, int length, int offset, AlgorithmParameters params)\n@@ -247,1 +248,1 @@\n-        byte[] outputText = cipher.doFinal(text, txtOffset, lenght);\n+        byte[] outputText = cipher.doFinal(text, txtOffset, length);\n@@ -255,1 +256,1 @@\n-        int off = anotherCipher.update(text, txtOffset, lenght, text, myoff);\n+        int off = anotherCipher.update(text, txtOffset, length, text, myoff);\n@@ -262,1 +263,1 @@\n-                jdk.test.lib.Convert.byteArrayToHexString(outputText) + \"\\n\" +\n+                HexFormat.of().withUpperCase().formatHex(outputText) + \"\\n\" +\n@@ -264,2 +265,2 @@\n-                jdk.test.lib.Convert.byteArrayToHexString(text) + \"\\n\" +\n-                    \"lenght \" + lenght);\n+                HexFormat.of().withUpperCase().formatHex(text) + \"\\n\" +\n+                \"length \" + length);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/SameBuffer.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,29 +115,0 @@\n-\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    static private void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    static private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/Blowfish\/BlowfishTestVector.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,3 @@\n-            key = Convert.hexStringToByteArray(Objects.requireNonNull(keyStr));\n-            nonce = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(nonceStr));\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(Objects.requireNonNull(keyStr));\n+            nonce = hex.parseHex(Objects.requireNonNull(nonceStr));\n@@ -61,6 +61,3 @@\n-            input = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(inputStr));\n-            aad = (aadStr != null) ?\n-                Convert.hexStringToByteArray(aadStr) : null;\n-            expOutput = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(outStr));\n+            input = hex.parseHex(Objects.requireNonNull(inputStr));\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(Objects.requireNonNull(outStr));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20KAT.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -38,2 +39,0 @@\n-import jdk.test.lib.Utils;\n-\n@@ -47,1 +46,1 @@\n-                    Utils.toByteArray(\"100000000000000000000000\"), 0));\n+                    HexFormat.of().parseHex(\"100000000000000000000000\"), 0));\n@@ -68,1 +67,1 @@\n-        System.out.println(\"Key: \" + Utils.toHexString(keyValue));\n+        System.out.println(\"Key: \" + HexFormat.of().formatHex(keyValue));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20KeyGeneratorTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @build jdk.test.lib.Convert\n@@ -42,1 +41,0 @@\n-import jdk.test.lib.Convert;\n@@ -79,3 +77,3 @@\n-            key = Convert.hexStringToByteArray(Objects.requireNonNull(keyStr));\n-            nonce = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(nonceStr));\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(keyStr);\n+            nonce = hex.parseHex(nonceStr);\n@@ -92,6 +90,3 @@\n-            input = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(inputStr));\n-            aad = (aadStr != null) ?\n-                Convert.hexStringToByteArray(aadStr) : null;\n-            expOutput = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(outStr));\n+            input = hex.parseHex(inputStr);\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(outStr);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20NoReuse.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @build jdk.test.lib.Convert\n@@ -56,3 +55,3 @@\n-            key = Convert.hexStringToByteArray(Objects.requireNonNull(keyStr));\n-            nonce = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(nonceStr));\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(keyStr);\n+            nonce = hex.parseHex(nonceStr);\n@@ -69,6 +68,3 @@\n-            input = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(inputStr));\n-            aad = (aadStr != null) ?\n-                Convert.hexStringToByteArray(aadStr) : null;\n-            expOutput = Convert.hexStringToByteArray(\n-                    Objects.requireNonNull(outStr));\n+            input = hex.parseHex(inputStr);\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(outStr);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20Poly1305ParamTest.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.HexFormat;\n@@ -49,1 +50,1 @@\n-            = Utils.toByteArray(\"012345670123456701234567\");\n+            = HexFormat.of().parseHex(\"012345670123456701234567\");\n@@ -51,2 +52,1 @@\n-            Utils.toByteArray(\n-                    \"0123456701234567012345670123456701234567012345670123456701234567\"),\n+            HexFormat.of().parseHex(\"0123456701234567012345670123456701234567012345670123456701234567\"),\n@@ -168,1 +168,1 @@\n-        byte[] expectedPlainttext = Utils.toByteArray(\"01234567\");\n+        byte[] expectedPlainttext = HexFormat.of().parseHex(\"01234567\");\n@@ -183,1 +183,1 @@\n-        byte[] aad = Utils.toByteArray(\"0000\");\n+        byte[] aad = HexFormat.of().parseHex(\"0000\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/ChaCha20CipherUnitTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.HexFormat;\n@@ -54,0 +55,4 @@\n+\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX_FORMATTER = HexFormat.ofDelimiter(\":\").withUpperCase();\n+\n@@ -212,2 +217,2 @@\n-        System.out.println(\"Alice secret: \" + toHexString(aliceSharedSecret));\n-        System.out.println(\"Bob secret: \" + toHexString(bobSharedSecret));\n+        System.out.println(\"Alice secret: \" + HEX_FORMATTER.formatHex(aliceSharedSecret));\n+        System.out.println(\"Bob secret: \" + HEX_FORMATTER.formatHex(bobSharedSecret));\n@@ -265,17 +270,0 @@\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyAgreement\/DHKeyAgreement2.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.HexFormat;\n@@ -50,0 +51,3 @@\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX_FORMATTER = HexFormat.ofDelimiter(\":\").withUpperCase();\n+\n@@ -123,1 +127,1 @@\n-        System.out.println(\"Alice secret: \" + toHexString(aliceSharedSecret));\n+        System.out.println(\"Alice secret: \" + HEX_FORMATTER.formatHex(aliceSharedSecret));\n@@ -127,1 +131,1 @@\n-        System.out.println(\"Bob secret: \" + toHexString(bobSharedSecret));\n+        System.out.println(\"Bob secret: \" + HEX_FORMATTER.formatHex(bobSharedSecret));\n@@ -131,1 +135,1 @@\n-        System.out.println(\"Carol secret: \" + toHexString(carolSharedSecret));\n+        System.out.println(\"Carol secret: \" + HEX_FORMATTER.formatHex(carolSharedSecret));\n@@ -170,17 +174,0 @@\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyAgreement\/DHKeyAgreement3.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+    \/\/ Hex formatter to upper case with \"\" delimiter\n+    private static final HexFormat HEX_FORMATTER = HexFormat.of();\n@@ -54,1 +56,1 @@\n-        new TestVector(5, \"password\", fromHexString(\"1234567878563412\"),\n+        new TestVector(5, \"password\", HEX_FORMATTER.parseHex(\"1234567878563412\"),\n@@ -64,1 +66,1 @@\n-        new TestVector(50, fromHexString(\"f09d849e\"),\n+        new TestVector(50, HEX_FORMATTER.parseHex(\"f09d849e\"),\n@@ -86,2 +88,2 @@\n-                if (!tv.expectedVals[j].equals(toHexString(derivedKey))) {\n-                    System.out.println(\"got:      \" + toHexString(derivedKey));\n+                if (!tv.expectedVals[j].equals(HEX_FORMATTER.formatHex(derivedKey))) {\n+                    System.out.println(\"got:      \" + HEX_FORMATTER.formatHex(derivedKey));\n@@ -112,25 +114,0 @@\n-   private static String toHexString(byte[] bytes) {\n-        String mapping = \"0123456789abcdef\";\n-        StringBuilder sb = new StringBuilder(bytes.length*2);\n-        for (int i = 0; i < bytes.length; i++) {\n-            int low = bytes[i] & 0x0f;\n-            int high = ((bytes[i] >> 4) & 0x0f);\n-            char[] res = new char[2];\n-            res[0] = mapping.charAt(high);\n-            res[1] = mapping.charAt(low);\n-            sb.append(res);\n-        }\n-        return sb.toString();\n-    }\n-    private static byte[] fromHexString(String value) {\n-        byte[] bytes = new byte[value.length()\/2];\n-        String mapping = \"0123456789abcdef\";\n-        StringBuilder sb = new StringBuilder(bytes.length*2);\n-        for (int i = 0; i < bytes.length; i++) {\n-            String high = value.substring(2*i, 2*i+1);\n-            String low = value.substring(2*i+1, 2*i+2);\n-            bytes[i] = (byte) ((mapping.indexOf(high) << 4) +\n-                               mapping.indexOf(low));\n-        }\n-        return bytes;\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyFactory\/PBKDF2HmacSHA1FactoryTest.java","additions":7,"deletions":30,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.HexFormat;\n@@ -50,0 +51,2 @@\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX_FORMATTER = HexFormat.ofDelimiter(\":\").withUpperCase();\n@@ -77,1 +80,1 @@\n-        System.out.println(\"shared secret:\\n\" + toHexString(sharedSecret));\n+        System.out.println(\"shared secret:\\n\" + HEX_FORMATTER.formatHex(sharedSecret));\n@@ -93,1 +96,1 @@\n-            \"tls premaster secret:\\n\" + toHexString(tlsPremasterSecret));\n+            \"tls premaster secret:\\n\" + HEX_FORMATTER.formatHex(tlsPremasterSecret));\n@@ -110,29 +113,0 @@\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    private void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestLeadingZeroes.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @build jdk.test.lib.Convert\n@@ -58,0 +57,1 @@\n+import java.util.HexFormat;\n@@ -61,1 +61,0 @@\n-import jdk.test.lib.Convert;\n@@ -232,3 +231,3 @@\n-            throw new RuntimeException(String.format(\"Actual array: %s, \"\n-                    + \"Expected array:%s\", Convert.byteArrayToHexString(actual),\n-                    Convert.byteArrayToHexString(expected)));\n+            throw new RuntimeException(String.format(\"Actual array: %s, Expected array:%s\",\n+                    HexFormat.of().withUpperCase().formatHex(actual),\n+                    HexFormat.of().withUpperCase().formatHex(expected)));\n","filename":"test\/jdk\/java\/security\/KeyAgreement\/KeySizeTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n- * @build jdk.test.lib.Convert\n@@ -61,0 +60,1 @@\n+import java.util.HexFormat;\n@@ -62,1 +62,0 @@\n-import jdk.test.lib.Convert;\n@@ -131,2 +130,2 @@\n-                    Convert.byteArrayToHexString(encoded),\n-                    Convert.byteArrayToHexString(modified), e.getMessage());\n+                    HexFormat.of().withUpperCase().formatHex(encoded),\n+                    HexFormat.of().withUpperCase().formatHex(modified), e.getMessage());\n@@ -146,2 +145,2 @@\n-                    Convert.byteArrayToHexString(encoded),\n-                    Convert.byteArrayToHexString(modified), e.getMessage());\n+                    HexFormat.of().withUpperCase().formatHex(encoded),\n+                    HexFormat.of().withUpperCase().formatHex(modified), e.getMessage());\n","filename":"test\/jdk\/java\/security\/KeyAgreement\/NegativeTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @build jdk.test.lib.Convert\n@@ -35,0 +34,1 @@\n+import java.util.HexFormat;\n@@ -41,1 +41,0 @@\n-import jdk.test.lib.Convert;\n@@ -49,2 +48,2 @@\n-    private static final byte[] EXP_OUT = Convert.hexStringToByteArray(\n-            \"4B007901B765489ABEAD49D926F721D065A429C1\");\n+    private static final byte[] EXP_OUT =\n+            HexFormat.of().parseHex(\"4B007901B765489ABEAD49D926F721D065A429C1\");\n@@ -65,1 +64,1 @@\n-                    Convert.byteArrayToHexString(secKey1.getEncoded()));\n+                    HexFormat.of().withUpperCase().formatHex(secKey1.getEncoded()));\n@@ -71,1 +70,1 @@\n-                    Convert.byteArrayToHexString(EXP_OUT));\n+                    HexFormat.of().withUpperCase().formatHex(EXP_OUT));\n","filename":"test\/jdk\/javax\/crypto\/SecretKeyFactory\/SecKeyFacSunJCEPrf.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import jdk.test.lib.Convert;\n-\n@@ -82,4 +80,2 @@\n-            System.out.println(\"expect: \"\n-                    + Convert.byteArrayToHexString(expected));\n-            System.out.println(\"actual: \"\n-                    + Convert.byteArrayToHexString(actual));\n+            System.out.println(\"expect: \" + HexFormat.of().withUpperCase().formatHex(expected));\n+            System.out.println(\"actual: \" + HexFormat.of().withUpperCase().formatHex(actual));\n@@ -96,4 +92,5 @@\n-        byte[] privateKey = Convert.hexStringToByteArray(privateKeyStr);\n-        byte[] msg = Convert.hexStringToByteArray(msgStr);\n-        byte[] k = Convert.hexStringToByteArray(kStr);\n-        byte[] expectedSig = Convert.hexStringToByteArray(sigStr);\n+        HexFormat hex = HexFormat.of();\n+        byte[] privateKey = hex.parseHex(privateKeyStr);\n+        byte[] msg = hex.parseHex(msgStr);\n+        byte[] k = hex.parseHex(kStr);\n+        byte[] expectedSig = hex.parseHex(sigStr);\n","filename":"test\/jdk\/sun\/security\/ec\/SignatureDigestTruncate.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            byte[] bytes = Convert.hexStringToByteArray(checkHex(hex));\n+            byte[] bytes = HexFormat.of().parseHex(checkHex(hex));\n@@ -82,1 +82,1 @@\n-            this.expSig = Convert.hexStringToByteArray(r + s);\n+            this.expSig = HexFormat.of().parseHex(r + s);\n","filename":"test\/jdk\/sun\/security\/ec\/SignatureKAT.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import java.util.HexFormat;\n+\n@@ -217,2 +219,2 @@\n-                    + \"Expected array:%s\", Convert.byteArrayToHexString(actual),\n-                    Convert.byteArrayToHexString(expected)));\n+                    + \"Expected array:%s\", HexFormat.of().withUpperCase().formatHex(actual),\n+                    HexFormat.of().withUpperCase().formatHex(expected)));\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSAKeySize.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.test.lib.Convert;\n+import java.util.HexFormat;\n@@ -44,1 +44,0 @@\n- * @build jdk.test.lib.Convert\n@@ -141,1 +140,1 @@\n-                        Convert.byteArrayToHexString(context));\n+                        HexFormat.of().withUpperCase().formatHex(context));\n@@ -222,2 +221,2 @@\n-                        Convert.byteArrayToHexString(context),\n-                        Convert.byteArrayToHexString(initContext),\n+                        HexFormat.of().withUpperCase().formatHex(context),\n+                        HexFormat.of().withUpperCase().formatHex(initContext),\n@@ -256,2 +255,2 @@\n-                    + \"Expected array:%s\", Convert.byteArrayToHexString(actual),\n-                    Convert.byteArrayToHexString(expected)));\n+                    + \"Expected array:%s\", HexFormat.of().withUpperCase().formatHex(actual),\n+                    HexFormat.of().withUpperCase().formatHex(expected)));\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSANegativeTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.test.lib.Convert;\n+import java.util.HexFormat;\n@@ -81,1 +81,1 @@\n-                        name, preHash, Convert.byteArrayToHexString(context));\n+                        name, preHash, HexFormat.of().withUpperCase().formatHex(context));\n@@ -132,2 +132,2 @@\n-                        Convert.byteArrayToHexString(context),\n-                        Convert.byteArrayToHexString(initContext),\n+                        HexFormat.of().withUpperCase().formatHex(context),\n+                        HexFormat.of().withUpperCase().formatHex(initContext),\n@@ -168,2 +168,2 @@\n-                    + \"Expected array:%s\", Convert.byteArrayToHexString(actual),\n-                    Convert.byteArrayToHexString(expected)));\n+                    + \"Expected array:%s\", HexFormat.of().withUpperCase().formatHex(actual),\n+                    HexFormat.of().withUpperCase().formatHex(expected)));\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSAParamSpec.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.test.lib.Convert;\n+import java.util.HexFormat;\n@@ -352,2 +352,2 @@\n-                    + \"Expected array:%s\", Convert.byteArrayToHexString(actual),\n-                    Convert.byteArrayToHexString(expected)));\n+                    + \"Expected array:%s\", HexFormat.of().withUpperCase().formatHex(actual),\n+                    HexFormat.of().withUpperCase().formatHex(expected)));\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSATest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import jdk.test.lib.Convert;\n-\n@@ -101,1 +99,1 @@\n-        byte[] encodedKey = Convert.hexStringToByteArray(key);\n+        byte[] encodedKey = HexFormat.of().parseHex(key);\n@@ -128,1 +126,1 @@\n-        byte[] encodedKey = Convert.hexStringToByteArray(privKeys.get(algName));\n+        byte[] encodedKey = HexFormat.of().parseHex(privKeys.get(algName));\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdECKeyFormat.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        byte[] context = Convert.hexStringToByteArray(\"666f6f\");\n+        byte[] context = HexFormat.of().parseHex(\"666f6f\");\n@@ -127,1 +127,1 @@\n-       context = Convert.hexStringToByteArray(\"626172\");\n+       context = HexFormat.of().parseHex(\"626172\");\n@@ -135,1 +135,1 @@\n-        context = Convert.hexStringToByteArray(\"666f6f\");\n+        context = HexFormat.of().parseHex(\"666f6f\");\n@@ -143,1 +143,1 @@\n-        context = Convert.hexStringToByteArray(\"666f6f\");\n+        context = HexFormat.of().parseHex(\"666f6f\");\n@@ -182,1 +182,1 @@\n-        context = Convert.hexStringToByteArray(\"666f6f\");\n+        context = HexFormat.of().parseHex(\"666f6f\");\n@@ -328,1 +328,1 @@\n-        byte[] privKeyBytes = Convert.hexStringToByteArray(privateKey);\n+        byte[] privKeyBytes = HexFormat.of().parseHex(privateKey);\n@@ -330,1 +330,1 @@\n-        byte[] msgBytes = Convert.hexStringToByteArray(message);\n+        byte[] msgBytes = HexFormat.of().parseHex(message);\n@@ -345,2 +345,1 @@\n-        if (!Arrays.equals(computedSig,\n-            Convert.hexStringToByteArray(signature))) {\n+        if (!Arrays.equals(computedSig, HexFormat.of().parseHex(signature))) {\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/TestEdDSA.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @build jdk.test.lib.Convert\n@@ -42,0 +41,2 @@\n+import java.util.HexFormat;\n+\n@@ -43,1 +44,0 @@\n-import jdk.test.lib.Convert;\n@@ -74,2 +74,2 @@\n-        byte[] msgBytes = Convert.hexStringToByteArray(msg);\n-        byte[] digestBytes = Convert.hexStringToByteArray(digest);\n+        byte[] msgBytes = HexFormat.of().parseHex(msg);\n+        byte[] digestBytes = HexFormat.of().parseHex(digest);\n@@ -181,3 +181,4 @@\n-        byte[] privKeyBytes = Convert.hexStringToByteArray(privateKey);\n-        byte[] pubKeyBytes = Convert.hexStringToByteArray(publicKey);\n-        byte[] msgBytes = Convert.hexStringToByteArray(message);\n+        HexFormat hex = HexFormat.of();\n+        byte[] privKeyBytes = hex.parseHex(privateKey);\n+        byte[] pubKeyBytes = hex.parseHex(publicKey);\n+        byte[] msgBytes = hex.parseHex(message);\n@@ -185,2 +186,1 @@\n-        if (!Arrays.equals(computedSig,\n-                           Convert.hexStringToByteArray(signature))) {\n+        if (!Arrays.equals(computedSig, hex.parseHex(signature))) {\n@@ -188,1 +188,1 @@\n-                Convert.byteArrayToHexString(computedSig) + \" != \" + signature);\n+                HexFormat.of().withUpperCase().formatHex(computedSig) + \" != \" + signature);\n@@ -265,1 +265,1 @@\n-            \"fffffffffffffffffffffffffffffffffffffffffffffffffff00\");\n+            \"ffffffffffffffffffffffffffffffffffffffffffffffffffff00\");\n@@ -280,1 +280,1 @@\n-        byte[] encodedPoint = Convert.hexStringToByteArray(pointStr);\n+        byte[] encodedPoint = HexFormat.of().parseHex(pointStr);\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/TestEdOps.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-import java.math.BigInteger;\n+import java.util.HexFormat;\n+\n@@ -39,0 +40,2 @@\n+import jdk.test.lib.hexdump.ASN1Formatter;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -337,1 +340,1 @@\n-        byte[] a_pri_ba = Convert.hexStringToByteArray(a_pri);\n+        byte[] a_pri_ba = HexFormat.of().parseHex(a_pri);\n@@ -340,1 +343,1 @@\n-        byte[] b_pub_ba = Convert.hexStringToByteArray(b_pub);\n+        byte[] b_pub_ba = HexFormat.of().parseHex(b_pub);\n@@ -349,1 +352,1 @@\n-        byte[] expectedResult = Convert.hexStringToByteArray(result);\n+        byte[] expectedResult = HexFormat.of().parseHex(result);\n@@ -352,1 +355,1 @@\n-                + Convert.byteArrayToHexString(sharedSecret));\n+                + HexFormat.of().withUpperCase().formatHex(sharedSecret));\n@@ -363,1 +366,1 @@\n-            Convert.hexStringToByteArray(a_pri));\n+            HexFormat.of().parseHex(a_pri));\n@@ -372,1 +375,4 @@\n-            Convert.byteArrayToHexString(encodedPrivateKey));\n+            HexFormat.of().withUpperCase().formatHex(encodedPrivateKey));\n+        System.out.println(HexPrinter.simple()\n+                .formatter(ASN1Formatter.formatter())\n+                .toString(encodedPrivateKey));\n@@ -375,2 +381,4 @@\n-            Convert.byteArrayToHexString(encodedPublicKey));\n-\n+            HexFormat.of().withUpperCase().formatHex(encodedPublicKey));\n+        System.out.println(HexPrinter.simple()\n+                .formatter(ASN1Formatter.formatter())\n+                .toString(encodedPublicKey));\n@@ -382,1 +390,1 @@\n-        byte[] expectedResult = Convert.hexStringToByteArray(result);\n+        byte[] expectedResult = HexFormat.of().parseHex(result);\n@@ -385,1 +393,1 @@\n-                + Convert.byteArrayToHexString(sharedSecret));\n+                + HexFormat.of().withUpperCase().formatHex(sharedSecret));\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/TestXDH.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -98,3 +98,3 @@\n-        byte[] a = Convert.hexStringToByteArray(a_str);\n-        byte[] b = Convert.hexStringToByteArray(b_str);\n-        byte[] expectedResult = Convert.hexStringToByteArray(result_str);\n+        byte[] a = HexFormat.of().parseHex(a_str);\n+        byte[] b = HexFormat.of().parseHex(b_str);\n+        byte[] expectedResult = HexFormat.of().parseHex(result_str);\n@@ -121,3 +121,3 @@\n-        byte[] k_in = Convert.hexStringToByteArray(k_in_str);\n-        byte[] u_in = Convert.hexStringToByteArray(u_in_str);\n-        byte[] u_out_expected = Convert.hexStringToByteArray(u_out_str);\n+        byte[] k_in = HexFormat.of().parseHex(k_in_str);\n+        byte[] u_in = HexFormat.of().parseHex(u_in_str);\n+        byte[] u_out_expected = HexFormat.of().parseHex(u_out_str);\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/TestXECOps.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import jdk.test.lib.Convert;\n@@ -98,1 +97,1 @@\n-            byte[] value = Convert.hexStringToByteArray(tok.nextToken());\n+            byte[] value = HexFormat.of().parseHex(tok.nextToken());\n@@ -120,2 +119,2 @@\n-                        + Convert.byteArrayToHexString(curEntry.k)\n-                        + \", computed k: \" + Convert.byteArrayToHexString(k));\n+                        + HexFormat.of().withUpperCase().formatHex(curEntry.k)\n+                        + \", computed k: \" + HexFormat.of().withUpperCase().formatHex(k));\n@@ -125,2 +124,2 @@\n-                     + Convert.byteArrayToHexString(curEntry.u)\n-                     + \", computed u: \" + Convert.byteArrayToHexString(u));\n+                     + HexFormat.of().withUpperCase().formatHex(curEntry.u)\n+                     + \", computed u: \" + HexFormat.of().withUpperCase().formatHex(u));\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/XECIterative.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @build jdk.test.lib.Convert\n@@ -42,1 +41,1 @@\n-import jdk.test.lib.Convert;\n+import java.util.HexFormat;\n@@ -101,1 +100,1 @@\n-        byte[] encodedKey = Convert.hexStringToByteArray(key);\n+        byte[] encodedKey = HexFormat.of().parseHex(key);\n@@ -128,1 +127,1 @@\n-        byte[] encodedKey = Convert.hexStringToByteArray(privKeys.get(algName));\n+        byte[] encodedKey = HexFormat.of().parseHex(privKeys.get(algName));\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/XECKeyFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.util.HexFormat;\n@@ -219,13 +220,1 @@\n-        StringBuffer sb = new StringBuffer(bs.length * 2);\n-        for(byte b: bs) {\n-            char c = (char)((b+256)%256);\n-            if (c \/ 16 < 10)\n-                sb.append((char)(c\/16+'0'));\n-            else\n-                sb.append((char)(c\/16-10+'a'));\n-            if (c % 16 < 10)\n-                sb.append((char)(c%16+'0'));\n-            else\n-                sb.append((char)(c%16-10+'a'));\n-        }\n-        return new String(sb);\n+        return HexFormat.of().formatHex(bs);\n@@ -236,6 +225,1 @@\n-        int len = in.length()\/2;\n-        byte[] out = new byte[len];\n-        for (int i=0; i<len; i++) {\n-            out[i] = (byte)Integer.parseInt(in.substring(i*2, i*2+2), 16);\n-        }\n-        return out;\n+        return HexFormat.of().parseHex(in);\n","filename":"test\/jdk\/sun\/security\/krb5\/RFC396xTest.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -411,2 +411,2 @@\n-                    hex(md5.digest(data)),\n-                    hex(sha256.digest(data)));\n+                    HexFormat.of().withUpperCase().formatHex(md5.digest(data)),\n+                    HexFormat.of().withUpperCase().formatHex(sha256.digest(data)));\n@@ -416,11 +416,0 @@\n-    \/\/ Returns a compact hexdump for a byte array\n-    private static String hex(byte[] hash) {\n-        char[] h = new char[hash.length * 2];\n-        char[] hexConst = \"0123456789ABCDEF\".toCharArray();\n-        for (int i=0; i<hash.length; i++) {\n-            h[2*i] = hexConst[(hash[i]&0xff)>>4];\n-            h[2*i+1] = hexConst[hash[i]&0xf];\n-        }\n-        return new String(h);\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/ReplayCacheTestProc.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.HexFormat;\n@@ -193,5 +194,1 @@\n-        byte[] data = new byte[var.length()\/2];\n-        for (int i=0; i<data.length; i++) {\n-            data[i] = Integer.valueOf(var.substring(2*i,2*i+2), 16).byteValue();\n-        }\n-        return data;\n+        return HexFormat.of().parseHex(var);\n","filename":"test\/jdk\/sun\/security\/krb5\/etype\/KerberosAesSha2.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.HexFormat;\n@@ -63,0 +64,3 @@\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX = HexFormat.ofDelimiter(\":\").withUpperCase();\n+\n@@ -282,1 +286,1 @@\n-        String checksum = toHexString(md.digest(data));\n+        String checksum = HEX.formatHex(md.digest(data));\n@@ -371,1 +375,1 @@\n-        return fingerprint.equals(toHexString(digest));\n+        return fingerprint.equals(HEX.formatHex(digest));\n@@ -374,11 +378,0 @@\n-    private static String toHexString(byte[] block) {\n-        StringBuilder buf = new StringBuilder();\n-        int len = block.length;\n-        for (int i = 0; i < len; i++) {\n-            buf.append(String.format(\"%02X\", block[i]));\n-            if (i < len - 1) {\n-                buf.append(\":\");\n-            }\n-        }\n-        return buf.toString();\n-    }\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.HexFormat;\n@@ -41,1 +42,2 @@\n-import jdk.test.lib.Utils;\n+import jdk.test.lib.hexdump.ASN1Formatter;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -55,1 +57,1 @@\n-    static final byte[] EXPECTED = Utils.toByteArray(\n+    static final byte[] EXPECTED = HexFormat.of().parseHex(\n@@ -73,1 +75,3 @@\n-                Utils.toHexString(encodedKey));\n+                HexPrinter.simple()\n+                        .formatter(ASN1Formatter.formatter())\n+                        .toString(encodedKey));\n@@ -85,1 +89,3 @@\n-                Utils.toHexString(encodedOutput));\n+                HexPrinter.simple()\n+                        .formatter(ASN1Formatter.formatter())\n+                        .toString(encodedOutput));\n@@ -109,1 +115,1 @@\n-            byte[] add = Utils.toByteArray(field);\n+            byte[] add = HexFormat.of().parseHex(field);\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.HexFormat;\n@@ -54,0 +55,3 @@\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX = HexFormat.ofDelimiter(\":\").withUpperCase();\n+\n@@ -77,1 +81,1 @@\n-        System.out.println(\"shared secret:\\n\" + toHexString(sharedSecret));\n+        System.out.println(\"shared secret:\\n\" + HEX.formatHex(sharedSecret));\n@@ -93,1 +97,1 @@\n-            \"tls premaster secret:\\n\" + toHexString(tlsPremasterSecret));\n+            \"tls premaster secret:\\n\" + HEX.formatHex(tlsPremasterSecret));\n@@ -110,29 +114,0 @@\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    private void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,4 @@\n-    private final static byte[] data1Raw = b(\"0102030405060708090a0b0c0d0e0f10111213\");\n-    private final static byte[] data1SHA = b(\"00:e2:5f:c9:1c:8f:d6:8c:6a:dc:c6:bd:f0:46:60:5e:a2:cd:8d:ad\");\n+    private final static byte[] data1Raw = HexFormat.of()\n+            .parseHex(\"0102030405060708090a0b0c0d0e0f10111213\");\n+    private final static byte[] data1SHA = HexFormat.ofDelimiter(\":\")\n+            .parseHex(\"00:e2:5f:c9:1c:8f:d6:8c:6a:dc:c6:bd:f0:46:60:5e:a2:cd:8d:ad\");\n@@ -79,2 +81,4 @@\n-    private final static byte[] sig1a = b(\"30:2d:02:14:53:06:3f:7d:ec:48:3c:99:17:9a:2c:a9:4d:e8:00:da:70:fb:35:d7:02:15:00:92:6a:39:6b:15:63:2f:e7:32:90:35:bf:af:47:55:e7:ff:33:a5:13\");\n-    private final static byte[] sig1b = b(\"30:2c:02:14:53:06:3f:7d:ec:48:3c:99:17:9a:2c:a9:4d:e8:00:da:70:fb:35:d7:02:14:92:6a:39:6b:15:63:2f:e7:32:90:35:bf:af:47:55:e7:ff:33:a5:13\");\n+    private final static byte[] sig1a = HexFormat.ofDelimiter(\":\")\n+            .parseHex(\"30:2d:02:14:53:06:3f:7d:ec:48:3c:99:17:9a:2c:a9:4d:e8:00:da:70:fb:35:d7:02:15:00:92:6a:39:6b:15:63:2f:e7:32:90:35:bf:af:47:55:e7:ff:33:a5:13\");\n+    private final static byte[] sig1b = HexFormat.ofDelimiter(\":\")\n+            .parseHex(\"30:2c:02:14:53:06:3f:7d:ec:48:3c:99:17:9a:2c:a9:4d:e8:00:da:70:fb:35:d7:02:14:92:6a:39:6b:15:63:2f:e7:32:90:35:bf:af:47:55:e7:ff:33:a5:13\");\n@@ -84,1 +88,2 @@\n-    private final static byte[] data2SHA = b(\"da:39:a3:ee:5e:6b:4b:0d:32:55:bf:ef:95:60:18:90:af:d8:07:09\");\n+    private final static byte[] data2SHA = HexFormat.ofDelimiter(\":\")\n+            .parseHex(\"da:39:a3:ee:5e:6b:4b:0d:32:55:bf:ef:95:60:18:90:af:d8:07:09\");\n@@ -185,58 +190,0 @@\n-\n-    private final static char[] hexDigits = \"0123456789abcdef\".toCharArray();\n-\n-    public static String toString(byte[] b) {\n-        StringBuffer sb = new StringBuffer(b.length * 3);\n-        for (int i = 0; i < b.length; i++) {\n-            int k = b[i] & 0xff;\n-            if (i != 0) {\n-                sb.append(':');\n-            }\n-            sb.append(hexDigits[k >>> 4]);\n-            sb.append(hexDigits[k & 0xf]);\n-        }\n-        return sb.toString();\n-    }\n-\n-    public static byte[] parse(String s) {\n-        try {\n-            int n = s.length();\n-            ByteArrayOutputStream out = new ByteArrayOutputStream(n \/ 3);\n-            StringReader r = new StringReader(s);\n-            while (true) {\n-                int b1 = nextNibble(r);\n-                if (b1 < 0) {\n-                    break;\n-                }\n-                int b2 = nextNibble(r);\n-                if (b2 < 0) {\n-                    throw new RuntimeException(\"Invalid string \" + s);\n-                }\n-                int b = (b1 << 4) | b2;\n-                out.write(b);\n-            }\n-            return out.toByteArray();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static byte[] b(String s) {\n-        return parse(s);\n-    }\n-\n-    private static int nextNibble(StringReader r) throws IOException {\n-        while (true) {\n-            int ch = r.read();\n-            if (ch == -1) {\n-                return -1;\n-            } else if ((ch >= '0') && (ch <= '9')) {\n-                return ch - '0';\n-            } else if ((ch >= 'a') && (ch <= 'f')) {\n-                return ch - 'a' + 10;\n-            } else if ((ch >= 'A') && (ch <= 'F')) {\n-                return ch - 'A' + 10;\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/provider\/DSA\/TestDSA.java","additions":11,"deletions":64,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,56 +39,1 @@\n-    private final static char[] hexDigits = \"0123456789abcdef\".toCharArray();\n-\n-    public static String toString(byte[] b) {\n-        StringBuffer sb = new StringBuffer(b.length * 3);\n-        for (int i = 0; i < b.length; i++) {\n-            int k = b[i] & 0xff;\n-            if (i != 0) {\n-                sb.append(':');\n-            }\n-            sb.append(hexDigits[k >>> 4]);\n-            sb.append(hexDigits[k & 0xf]);\n-        }\n-        return sb.toString();\n-    }\n-\n-    public static byte[] parse(String s) {\n-        try {\n-            int n = s.length();\n-            ByteArrayOutputStream out = new ByteArrayOutputStream(n \/ 3);\n-            StringReader r = new StringReader(s);\n-            while (true) {\n-                int b1 = nextNibble(r);\n-                if (b1 < 0) {\n-                    break;\n-                }\n-                int b2 = nextNibble(r);\n-                if (b2 < 0) {\n-                    throw new RuntimeException(\"Invalid string \" + s);\n-                }\n-                int b = (b1 << 4) | b2;\n-                out.write(b);\n-            }\n-            return out.toByteArray();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static byte[] b(String s) {\n-        return parse(s);\n-    }\n-\n-    private static int nextNibble(StringReader r) throws IOException {\n-        while (true) {\n-            int ch = r.read();\n-            if (ch == -1) {\n-                return -1;\n-            } else if ((ch >= '0') && (ch <= '9')) {\n-                return ch - '0';\n-            } else if ((ch >= 'a') && (ch <= 'f')) {\n-                return ch - 'a' + 10;\n-            } else if ((ch >= 'A') && (ch <= 'F')) {\n-                return ch - 'A' + 10;\n-            }\n-        }\n-    }\n+    private static final HexFormat HEX = HexFormat.ofDelimiter(\":\");\n@@ -121,1 +66,1 @@\n-                    System.out.println(\"data: \" + DigestKAT.toString(data));\n+                    System.out.println(\"data: \" + HEX.formatHex(data));\n@@ -123,2 +68,2 @@\n-                System.out.println(\"dig:  \" + DigestKAT.toString(digest));\n-                System.out.println(\"out:  \" + DigestKAT.toString(myDigest));\n+                System.out.println(\"dig:  \" + HEX.formatHex(digest));\n+                System.out.println(\"out:  \" + HEX.formatHex(myDigest));\n@@ -140,1 +85,2 @@\n-        return new DigestTest(alg, data, parse(digest));\n+        HexFormat hex = (digest.indexOf(':') < 0) ? HexFormat.of() : HexFormat.ofDelimiter(\":\");\n+        return new DigestTest(alg, data, hex.parseHex(digest));\n","filename":"test\/jdk\/sun\/security\/provider\/MessageDigest\/DigestKAT.java","additions":7,"deletions":61,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -39,24 +40,0 @@\n-    \/\/ utility method for converting byte array to hex string\n-    static String toHexString(byte[] array) {\n-        StringBuilder sb = new StringBuilder(array.length * 2);\n-        for (byte b : array) {\n-            \/\/ The single digits 0123456789abcdef get a leading 0\n-            if ((b >= 0x00) && (b < 0x10)) {\n-                sb.append('0');\n-            }\n-            sb.append(Integer.toHexString(b & 0xff));\n-        }\n-        return sb.toString();\n-    }\n-\n-    \/\/ utility method for converting hex string to byte array\n-    static byte[] toByteArray(String s) {\n-        byte[] bytes = new byte[s.length() \/ 2];\n-        for (int i = 0; i < bytes.length; i++) {\n-            int index = i * 2;\n-            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n-            bytes[i] = (byte) v;\n-        }\n-        return bytes;\n-    }\n-\n@@ -118,3 +95,3 @@\n-        BigInteger n = new BigInteger(1, toByteArray(mod));\n-        BigInteger e = new BigInteger(1, toByteArray(pubExp));\n-        BigInteger d = new BigInteger(1, toByteArray(privExp));\n+        BigInteger n = new BigInteger(1, HexFormat.of().parseHex(mod));\n+        BigInteger e = new BigInteger(1, HexFormat.of().parseHex(pubExp));\n+        BigInteger d = new BigInteger(1, HexFormat.of().parseHex(privExp));\n","filename":"test\/jdk\/sun\/security\/rsa\/SigRecord.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -103,2 +104,2 @@\n-            byte[] msgBytes = SigRecord.toByteArray(v.msg);\n-            byte[] expSigBytes = SigRecord.toByteArray(v.sig);\n+            byte[] msgBytes = HexFormat.of().parseHex(v.msg);\n+            byte[] expSigBytes = HexFormat.of().parseHex(v.sig);\n@@ -117,1 +118,1 @@\n-                System.out.println(\"\\tActual Sig   = \" + SigRecord.toHexString(actualSigBytes));\n+                System.out.println(\"\\tActual Sig   = \" + HexFormat.of().formatHex(actualSigBytes));\n","filename":"test\/jdk\/sun\/security\/rsa\/TestSigGen15.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.HexFormat;\n@@ -39,24 +40,0 @@\n-    \/\/ utility method for converting byte array to hex string\n-    static String toHexString(byte[] array) {\n-        StringBuilder sb = new StringBuilder(array.length * 2);\n-        for (byte b : array) {\n-            \/\/ The single digits 0123456789abcdef get a leading 0\n-            if ((b >= 0x00) && (b < 0x10)) {\n-                sb.append('0');\n-            }\n-            sb.append(Integer.toHexString(b & 0xff));\n-        }\n-        return sb.toString();\n-    }\n-\n-    \/\/ utility method for converting hex string to byte array\n-    static byte[] toByteArray(String s) {\n-        byte[] bytes = new byte[s.length() \/ 2];\n-        for (int i = 0; i < bytes.length; i++) {\n-            int index = i * 2;\n-            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n-            bytes[i] = (byte) v;\n-        }\n-        return bytes;\n-    }\n-\n@@ -123,3 +100,3 @@\n-        BigInteger n = new BigInteger(1, toByteArray(mod));\n-        BigInteger e = new BigInteger(1, toByteArray(pubExp));\n-        BigInteger d = new BigInteger(1, toByteArray(privExp));\n+        BigInteger n = new BigInteger(1, HexFormat.of().parseHex(mod));\n+        BigInteger e = new BigInteger(1, HexFormat.of().parseHex(pubExp));\n+        BigInteger d = new BigInteger(1, HexFormat.of().parseHex(privExp));\n","filename":"test\/jdk\/sun\/security\/rsa\/pss\/SigRecord.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileInputStream;\n@@ -28,1 +25,0 @@\n-import java.io.InputStreamReader;\n@@ -31,2 +27,1 @@\n-import java.security.interfaces.*;\n-import java.util.ArrayList;\n+import java.util.HexFormat;\n@@ -53,1 +48,1 @@\n-            this.srcBytes = SigRecord.toByteArray(srcString);\n+            this.srcBytes = HexFormat.of().parseHex(srcString);\n@@ -123,2 +118,2 @@\n-            byte[] msgBytes = SigRecord.toByteArray(v.msg);\n-            byte[] expSigBytes = SigRecord.toByteArray(v.sig);\n+            byte[] msgBytes = HexFormat.of().parseHex(v.msg);\n+            byte[] expSigBytes = HexFormat.of().parseHex(v.sig);\n@@ -148,1 +143,1 @@\n-                System.out.println(\"\\tActual Sig   = \" + SigRecord.toHexString(actualSigBytes));\n+                System.out.println(\"\\tActual Sig   = \" + HexFormat.of().formatHex(actualSigBytes));\n","filename":"test\/jdk\/sun\/security\/rsa\/pss\/TestSigGenPSS.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-                    + byteArrayToHexString(testResult) + \" != \"\n-                    + byteArrayToHexString(baselineResult));\n+                    + HexFormat.of().withUpperCase().formatHex(testResult) + \" != \"\n+                    + HexFormat.of().withUpperCase().formatHex(baselineResult));\n@@ -205,10 +205,0 @@\n-    static String byteArrayToHexString(byte[] arr) {\n-        StringBuilder result = new StringBuilder();\n-        for (int i = 0; i < arr.length; ++i) {\n-            byte curVal = arr[i];\n-            result.append(Character.forDigit(curVal >> 4 & 0xF, 16));\n-            result.append(Character.forDigit(curVal & 0xF, 16));\n-        }\n-        return result.toString();\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/util\/math\/TestIntegerModuloP.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -31,0 +32,2 @@\n+import jdk.test.lib.hexdump.ASN1Formatter;\n+import jdk.test.lib.hexdump.HexPrinter;\n@@ -34,0 +37,2 @@\n+import java.util.HexFormat;\n+\n@@ -35,0 +40,3 @@\n+    \/\/ Hex formatter to upper case with \":\" delimiter\n+    private static final HexFormat HEX = HexFormat.ofDelimiter(\":\").withUpperCase();\n+\n@@ -53,1 +61,4 @@\n-        System.out.println(toHexString(ba));\n+        System.out.println(HEX.formatHex(ba));\n+        System.out.println(HexPrinter.simple()\n+                .formatter(ASN1Formatter.formatter())\n+                .toString(ba));\n@@ -79,1 +90,4 @@\n-        System.out.println(toHexString(ba));\n+        System.out.println(HEX.formatHex(ba));\n+        System.out.println(HexPrinter.simple()\n+                .formatter(ASN1Formatter.formatter())\n+                .toString(ba));\n@@ -99,1 +113,4 @@\n-        System.out.println(toHexString(ba));\n+        System.out.println(HEX.formatHex(ba));\n+        System.out.println(HexPrinter.simple()\n+                .formatter(ASN1Formatter.formatter())\n+                .toString(ba));\n@@ -105,29 +122,0 @@\n-\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    private static void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private static String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-            byte2hex(block[i], buf);\n-            if (i < len-1) {\n-                buf.append(\":\");\n-            }\n-        }\n-        return buf.toString();\n-    }\n","filename":"test\/jdk\/sun\/security\/x509\/X500Name\/DerValueConstructor.java","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.HexFormat;\n@@ -36,11 +37,0 @@\n-    \/\/ Convert from a byte array to a hexadecimal representation as a string.\n-    public static String byteArrayToHexString(byte[] arr) {\n-        StringBuilder result = new StringBuilder();\n-        for (int i = 0; i < arr.length; ++i) {\n-            byte curVal = arr[i];\n-            result.append(Character.forDigit(curVal >> 4 & 0xF, 16));\n-            result.append(Character.forDigit(curVal & 0xF, 16));\n-        }\n-        return result.toString();\n-    }\n-\n@@ -54,11 +44,0 @@\n-    \/\/ Convert a hexadecimal string to a byte array\n-    public static byte[] hexStringToByteArray(String str) {\n-        byte[] result = new byte[str.length() \/ 2];\n-        for (int i = 0; i < result.length; i++) {\n-            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n-            result[i] <<= 4;\n-            result[i] += Character.digit(str.charAt(2 * i + 1), 16);\n-        }\n-        return result;\n-    }\n-\n@@ -95,1 +74,1 @@\n-        return byteArrayToEdPoint(hexStringToByteArray(str));\n+        return byteArrayToEdPoint(HexFormat.of().parseHex(str));\n","filename":"test\/lib\/jdk\/test\/lib\/Convert.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.HexFormat;\n@@ -465,2 +466,0 @@\n-    private static final char[] hexArray = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n-\n@@ -472,0 +471,2 @@\n+     * @deprecated replaced by {@link java.util.HexFormat#ofDelimiter(String)\n+     * HexFormat.ofDelimiter(\" \").format (byte[], char)}.\n@@ -473,0 +474,1 @@\n+     @Deprecated\n@@ -474,9 +476,1 @@\n-         char[] hexView = new char[bytes.length * 3 - 1];\n-         for (int i = 0; i < bytes.length - 1; i++) {\n-             hexView[i * 3] = hexArray[(bytes[i] >> 4) & 0x0F];\n-             hexView[i * 3 + 1] = hexArray[bytes[i] & 0x0F];\n-             hexView[i * 3 + 2] = ' ';\n-         }\n-         hexView[hexView.length - 2] = hexArray[(bytes[bytes.length - 1] >> 4) & 0x0F];\n-         hexView[hexView.length - 1] = hexArray[bytes[bytes.length - 1] & 0x0F];\n-         return new String(hexView);\n+         return HexFormat.ofDelimiter(\" \").withUpperCase().formatHex(bytes);\n@@ -492,7 +486,1 @@\n-         int length = hex.length();\n-         byte[] bytes = new byte[length \/ 2];\n-         for (int i = 0; i < length; i += 2) {\n-             bytes[i \/ 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)\n-                     + Character.digit(hex.charAt(i + 1), 16));\n-         }\n-         return bytes;\n+         return HexFormat.of().parseHex(hex);\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"}]}