{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2061 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"ci\/ciEnv.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/javaThreadStatus.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/scopeDesc.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/tlab_globals.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/verifyOopClosure.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiThreadState.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n+#include \"runtime\/threadCritical.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/threadStatisticalInfo.hpp\"\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n+#include \"runtime\/vframe_hp.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"services\/threadService.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/dtrace.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/preserveException.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#endif\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n+\/\/ Set by os layer.\n+size_t      JavaThread::_stack_size_at_create = 0;\n+\n+#ifdef DTRACE_ENABLED\n+\n+\/\/ Only bother with this argument setup if dtrace is available\n+\n+  #define HOTSPOT_THREAD_PROBE_start HOTSPOT_THREAD_START\n+  #define HOTSPOT_THREAD_PROBE_stop HOTSPOT_THREAD_STOP\n+\n+  #define DTRACE_THREAD_PROBE(probe, javathread)                           \\\n+    {                                                                      \\\n+      ResourceMark rm(this);                                               \\\n+      int len = 0;                                                         \\\n+      const char* name = (javathread)->name();                             \\\n+      len = strlen(name);                                                  \\\n+      HOTSPOT_THREAD_PROBE_##probe(\/* probe = start, stop *\/               \\\n+        (char *) name, len,                                                \\\n+        java_lang_Thread::thread_id((javathread)->threadObj()),            \\\n+        (uintptr_t) (javathread)->osthread()->thread_id(),                 \\\n+        java_lang_Thread::is_daemon((javathread)->threadObj()));           \\\n+    }\n+\n+#else \/\/  ndef DTRACE_ENABLED\n+\n+  #define DTRACE_THREAD_PROBE(probe, javathread)\n+\n+#endif \/\/ ndef DTRACE_ENABLED\n+\n+void JavaThread::smr_delete() {\n+  if (_on_thread_list) {\n+    ThreadsSMRSupport::smr_delete(this);\n+  } else {\n+    delete this;\n+  }\n+}\n+\n+\/\/ Initialized by VMThread at vm_global_init\n+OopStorage* JavaThread::_thread_oop_storage = NULL;\n+\n+OopStorage* JavaThread::thread_oop_storage() {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  return _thread_oop_storage;\n+}\n+\n+void JavaThread::set_threadOopHandles(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _threadObj   = OopHandle(_thread_oop_storage, p);\n+  _vthread     = OopHandle(_thread_oop_storage, p);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n+  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+}\n+\n+oop JavaThread::threadObj() const {\n+  Thread* current = Thread::current_or_null_safe();\n+  assert(current != nullptr, \"cannot be called by a detached thread\");\n+  guarantee(current != this || JavaThread::cast(current)->is_oop_safe(),\n+            \"current cannot touch oops after its GC barrier is detached.\");\n+  return _threadObj.resolve();\n+}\n+\n+oop JavaThread::vthread() const {\n+  return _vthread.resolve();\n+}\n+\n+void JavaThread::set_vthread(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _vthread.replace(p);\n+}\n+\n+oop JavaThread::jvmti_vthread() const {\n+  return _jvmti_vthread.resolve();\n+}\n+\n+void JavaThread::set_jvmti_vthread(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _jvmti_vthread.replace(p);\n+}\n+\n+oop JavaThread::extentLocalCache() const {\n+  return _extentLocalCache.resolve();\n+}\n+\n+void JavaThread::set_extentLocalCache(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _extentLocalCache.replace(p);\n+}\n+\n+void JavaThread::allocate_threadObj(Handle thread_group, const char* thread_name,\n+                                    bool daemon, TRAPS) {\n+  assert(thread_group.not_null(), \"thread group should be specified\");\n+  assert(threadObj() == NULL, \"should only create Java thread object once\");\n+\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n+  assert(ik->is_initialized(), \"must be\");\n+  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n+\n+  \/\/ We are called from jni_AttachCurrentThread\/jni_AttachCurrentThreadAsDaemon.\n+  \/\/ We cannot use JavaCalls::construct_new_instance because the java.lang.Thread\n+  \/\/ constructor calls Thread.current(), which must be set here.\n+  java_lang_Thread::set_thread(thread_oop(), this);\n+  set_threadOopHandles(thread_oop());\n+\n+  JavaValue result(T_VOID);\n+  if (thread_name != NULL) {\n+    Handle name = java_lang_String::create_from_str(thread_name, CHECK);\n+    \/\/ Thread gets assigned specified name and null target\n+    JavaCalls::call_special(&result,\n+                            thread_oop,\n+                            ik,\n+                            vmSymbols::object_initializer_name(),\n+                            vmSymbols::threadgroup_string_void_signature(),\n+                            thread_group,\n+                            name,\n+                            THREAD);\n+  } else {\n+    \/\/ Thread gets assigned name \"Thread-nnn\" and null target\n+    \/\/ (java.lang.Thread doesn't have a constructor taking only a ThreadGroup argument)\n+    JavaCalls::call_special(&result,\n+                            thread_oop,\n+                            ik,\n+                            vmSymbols::object_initializer_name(),\n+                            vmSymbols::threadgroup_runnable_void_signature(),\n+                            thread_group,\n+                            Handle(),\n+                            THREAD);\n+  }\n+  os::set_priority(this, NormPriority);\n+\n+  if (daemon) {\n+    java_lang_Thread::set_daemon(thread_oop());\n+  }\n+}\n+\n+\/\/ ======= JavaThread ========\n+\n+#if INCLUDE_JVMCI\n+\n+jlong* JavaThread::_jvmci_old_thread_counters;\n+\n+bool jvmci_counters_include(JavaThread* thread) {\n+  return !JVMCICountersExcludeCompiler || !thread->is_Compiler_thread();\n+}\n+\n+void JavaThread::collect_counters(jlong* array, int length) {\n+  assert(length == JVMCICounterSize, \"wrong value\");\n+  for (int i = 0; i < length; i++) {\n+    array[i] = _jvmci_old_thread_counters[i];\n+  }\n+  for (JavaThread* tp : ThreadsListHandle()) {\n+    if (jvmci_counters_include(tp)) {\n+      for (int i = 0; i < length; i++) {\n+        array[i] += tp->_jvmci_counters[i];\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {\n+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n+  if (new_counters == NULL) {\n+    return NULL;\n+  }\n+  if (old_counters == NULL) {\n+    old_counters = new_counters;\n+    memset(old_counters, 0, sizeof(jlong) * new_size);\n+  } else {\n+    for (int i = 0; i < MIN2((int) current_size, new_size); i++) {\n+      new_counters[i] = old_counters[i];\n+    }\n+    if (new_size > current_size) {\n+      memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));\n+    }\n+    FREE_C_HEAP_ARRAY(jlong, old_counters);\n+  }\n+  return new_counters;\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+bool JavaThread::resize_counters(int current_size, int new_size) {\n+  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n+  if (new_counters == NULL) {\n+    return false;\n+  } else {\n+    _jvmci_counters = new_counters;\n+    return true;\n+  }\n+}\n+\n+class VM_JVMCIResizeCounters : public VM_Operation {\n+ private:\n+  int _new_size;\n+  bool _failed;\n+\n+ public:\n+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n+  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n+  bool allow_nested_vm_operations() const        { return true; }\n+  void doit() {\n+    \/\/ Resize the old thread counters array\n+    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n+    if (new_counters == NULL) {\n+      _failed = true;\n+      return;\n+    } else {\n+      JavaThread::_jvmci_old_thread_counters = new_counters;\n+    }\n+\n+    \/\/ Now resize each threads array\n+    for (JavaThread* tp : ThreadsListHandle()) {\n+      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n+        _failed = true;\n+        break;\n+      }\n+    }\n+    if (!_failed) {\n+      JVMCICounterSize = _new_size;\n+    }\n+  }\n+\n+  bool failed() { return _failed; }\n+};\n+\n+bool JavaThread::resize_all_jvmci_counters(int new_size) {\n+  VM_JVMCIResizeCounters op(new_size);\n+  VMThread::execute(&op);\n+  return !op.failed();\n+}\n+\n+#endif \/\/ INCLUDE_JVMCI\n+\n+#ifdef ASSERT\n+\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n+void JavaThread::check_possible_safepoint() {\n+  if (_no_safepoint_count > 0) {\n+    print_owned_locks();\n+    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n+  }\n+#ifdef CHECK_UNHANDLED_OOPS\n+  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n+  clear_unhandled_oops();\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n+\n+  \/\/ Macos\/aarch64 should be in the right state for safepoint (e.g.\n+  \/\/ deoptimization needs WXWrite).  Crashes caused by the wrong state rarely\n+  \/\/ happens in practice, making such issues hard to find and reproduce.\n+#if defined(__APPLE__) && defined(AARCH64)\n+  if (AssertWXAtThreadSync) {\n+    assert_wx_state(WXWrite);\n+  }\n+#endif\n+}\n+\n+void JavaThread::check_for_valid_safepoint_state() {\n+  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n+  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n+  \/\/ are held.\n+  check_possible_safepoint();\n+\n+  if (thread_state() != _thread_in_vm) {\n+    fatal(\"LEAF method calling lock?\");\n+  }\n+\n+  if (GCALotAtAllSafepoints) {\n+    \/\/ We could enter a safepoint here and thus have a gc\n+    InterfaceSupport::check_gc_alot();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+\/\/ A JavaThread is a normal Java thread\n+\n+JavaThread::JavaThread() :\n+  \/\/ Initialize fields\n+\n+  _in_asgct(false),\n+  _on_thread_list(false),\n+  DEBUG_ONLY(_java_call_counter(0) COMMA)\n+  _entry_point(nullptr),\n+  _deopt_mark(nullptr),\n+  _deopt_nmethod(nullptr),\n+  _vframe_array_head(nullptr),\n+  _vframe_array_last(nullptr),\n+  _jvmti_deferred_updates(nullptr),\n+  _callee_target(nullptr),\n+  _vm_result(nullptr),\n+  _vm_result_2(nullptr),\n+\n+  _current_pending_monitor(NULL),\n+  _current_pending_monitor_is_from_java(true),\n+  _current_waiting_monitor(NULL),\n+  _active_handles(NULL),\n+  _free_handle_block(NULL),\n+  _Stalled(0),\n+\n+  _monitor_chunks(nullptr),\n+\n+  _suspend_flags(0),\n+\n+  _thread_state(_thread_new),\n+  _saved_exception_pc(nullptr),\n+#ifdef ASSERT\n+  _no_safepoint_count(0),\n+  _visited_for_critical_count(false),\n+#endif\n+\n+  _terminated(_not_terminated),\n+  _in_deopt_handler(0),\n+  _doing_unsafe_access(false),\n+  _do_not_unlock_if_synchronized(false),\n+#if INCLUDE_JVMTI\n+  _carrier_thread_suspended(false),\n+  _is_in_VTMS_transition(false),\n+#ifdef ASSERT\n+  _is_VTMS_transition_disabler(false),\n+#endif\n+#endif\n+  _jni_attach_state(_not_attaching_via_jni),\n+#if INCLUDE_JVMCI\n+  _pending_deoptimization(-1),\n+  _pending_monitorenter(false),\n+  _pending_transfer_to_interpreter(false),\n+  _in_retryable_allocation(false),\n+  _pending_failed_speculation(0),\n+  _jvmci{nullptr},\n+  _libjvmci_runtime(nullptr),\n+  _jvmci_counters(nullptr),\n+  _jvmci_reserved0(0),\n+  _jvmci_reserved1(0),\n+  _jvmci_reserved_oop0(nullptr),\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  _exception_oop(oop()),\n+  _exception_pc(0),\n+  _exception_handler_pc(0),\n+  _is_method_handle_return(0),\n+\n+  _jni_active_critical(0),\n+  _pending_jni_exception_check_fn(nullptr),\n+  _depth_first_number(0),\n+\n+  \/\/ JVMTI PopFrame support\n+  _popframe_condition(popframe_inactive),\n+  _frames_to_pop_failed_realloc(0),\n+\n+  _cont_entry(nullptr),\n+  _cont_fastpath(0),\n+  _cont_fastpath_thread_state(1),\n+  _held_monitor_count(0),\n+\n+  _handshake(this),\n+\n+  _popframe_preserved_args(nullptr),\n+  _popframe_preserved_args_size(0),\n+\n+  _jvmti_thread_state(nullptr),\n+  _interp_only_mode(0),\n+  _should_post_on_exceptions_flag(JNI_FALSE),\n+  _thread_stat(new ThreadStatistics()),\n+\n+  _parker(),\n+\n+  _class_to_be_initialized(nullptr),\n+\n+  _SleepEvent(ParkEvent::Allocate(this))\n+{\n+  set_jni_functions(jni_functions());\n+\n+#if INCLUDE_JVMCI\n+  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n+  if (JVMCICounterSize > 0) {\n+    resize_counters(0, (int) JVMCICounterSize);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Setup safepoint state info for this thread\n+  ThreadSafepointState::create(this);\n+\n+  SafepointMechanism::initialize_header(this);\n+\n+  set_requires_cross_modify_fence(false);\n+\n+  pd_initialize();\n+  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n+}\n+\n+JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n+  if (is_attaching_via_jni) {\n+    _jni_attach_state = _attaching_via_jni;\n+  }\n+}\n+\n+\n+\/\/ interrupt support\n+\n+void JavaThread::interrupt() {\n+  \/\/ All callers should have 'this' thread protected by a\n+  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n+  \/\/ itself.\n+  debug_only(check_for_dangling_thread_pointer(this);)\n+\n+  \/\/ For Windows _interrupt_event\n+  WINDOWS_ONLY(osthread()->set_interrupted(true);)\n+\n+  \/\/ For Thread.sleep\n+  _SleepEvent->unpark();\n+\n+  \/\/ For JSR166 LockSupport.park\n+  parker()->unpark();\n+\n+  \/\/ For ObjectMonitor and JvmtiRawMonitor\n+  _ParkEvent->unpark();\n+}\n+\n+\n+bool JavaThread::is_interrupted(bool clear_interrupted) {\n+  debug_only(check_for_dangling_thread_pointer(this);)\n+\n+  if (_threadObj.peek() == NULL) {\n+    \/\/ If there is no j.l.Thread then it is impossible to have\n+    \/\/ been interrupted. We can find NULL during VM initialization\n+    \/\/ or when a JNI thread is still in the process of attaching.\n+    \/\/ In such cases this must be the current thread.\n+    assert(this == Thread::current(), \"invariant\");\n+    return false;\n+  }\n+\n+  bool interrupted = java_lang_Thread::interrupted(threadObj());\n+\n+  \/\/ NOTE that since there is no \"lock\" around the interrupt and\n+  \/\/ is_interrupted operations, there is the possibility that the\n+  \/\/ interrupted flag will be \"false\" but that the\n+  \/\/ low-level events will be in the signaled state. This is\n+  \/\/ intentional. The effect of this is that Object.wait() and\n+  \/\/ LockSupport.park() will appear to have a spurious wakeup, which\n+  \/\/ is allowed and not harmful, and the possibility is so rare that\n+  \/\/ it is not worth the added complexity to add yet another lock.\n+  \/\/ For the sleep event an explicit reset is performed on entry\n+  \/\/ to JavaThread::sleep, so there is no early return. It has also been\n+  \/\/ recommended not to put the interrupted flag into the \"event\"\n+  \/\/ structure because it hides the issue.\n+  \/\/ Also, because there is no lock, we must only clear the interrupt\n+  \/\/ state if we are going to report that we were interrupted; otherwise\n+  \/\/ an interrupt that happens just after we read the field would be lost.\n+  if (interrupted && clear_interrupted) {\n+    assert(this == Thread::current(), \"only the current thread can clear\");\n+    java_lang_Thread::set_interrupted(threadObj(), false);\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+  }\n+\n+  return interrupted;\n+}\n+\n+void JavaThread::block_if_vm_exited() {\n+  if (_terminated == _vm_exited) {\n+    \/\/ _vm_exited is set at safepoint, and Threads_lock is never released\n+    \/\/ we will block here forever.\n+    \/\/ Here we can be doing a jump from a safe state to an unsafe state without\n+    \/\/ proper transition, but it happens after the final safepoint has begun.\n+    set_thread_state(_thread_in_vm);\n+    Threads_lock->lock();\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n+  _jni_attach_state = _not_attaching_via_jni;\n+  set_entry_point(entry_point);\n+  \/\/ Create the native thread itself.\n+  \/\/ %note runtime_23\n+  os::ThreadType thr_type = os::java_thread;\n+  thr_type = entry_point == &CompilerThread::thread_entry ? os::compiler_thread :\n+                                                            os::java_thread;\n+  os::create_thread(this, thr_type, stack_sz);\n+  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n+  \/\/ We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n+  \/\/ may hold a lock and all locks must be unlocked before throwing the exception (throwing\n+  \/\/ the exception consists of creating the exception object & initializing it, initialization\n+  \/\/ will leave the VM via a JavaCall and then all locks must be unlocked).\n+  \/\/\n+  \/\/ The thread is still suspended when we reach here. Thread must be explicit started\n+  \/\/ by creator! Furthermore, the thread must also explicitly be added to the Threads list\n+  \/\/ by calling Threads:add. The reason why this is not done here, is because the thread\n+  \/\/ object must be fully initialized (take a look at JVM_Start)\n+}\n+\n+JavaThread::~JavaThread() {\n+\n+  \/\/ Ask ServiceThread to release the threadObj OopHandle\n+  ServiceThread::add_oop_handle_release(_threadObj);\n+  ServiceThread::add_oop_handle_release(_vthread);\n+  ServiceThread::add_oop_handle_release(_jvmti_vthread);\n+\n+  \/\/ Return the sleep event to the free list\n+  ParkEvent::Release(_SleepEvent);\n+  _SleepEvent = NULL;\n+\n+  \/\/ Free any remaining  previous UnrollBlock\n+  vframeArray* old_array = vframe_array_last();\n+\n+  if (old_array != NULL) {\n+    Deoptimization::UnrollBlock* old_info = old_array->unroll_block();\n+    old_array->set_unroll_block(NULL);\n+    delete old_info;\n+    delete old_array;\n+  }\n+\n+  JvmtiDeferredUpdates* updates = deferred_updates();\n+  if (updates != NULL) {\n+    \/\/ This can only happen if thread is destroyed before deoptimization occurs.\n+    assert(updates->count() > 0, \"Updates holder not deleted\");\n+    \/\/ free deferred updates.\n+    delete updates;\n+    set_deferred_updates(NULL);\n+  }\n+\n+  \/\/ All Java related clean up happens in exit\n+  ThreadSafepointState::destroy(this);\n+  if (_thread_stat != NULL) delete _thread_stat;\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    FREE_C_HEAP_ARRAY(jlong, _jvmci_counters);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+}\n+\n+\n+\/\/ First JavaThread specific code executed by a new Java thread.\n+void JavaThread::pre_run() {\n+  \/\/ empty - see comments in run()\n+}\n+\n+\/\/ The main routine called by a new Java thread. This isn't overridden\n+\/\/ by subclasses, instead different subclasses define a different \"entry_point\"\n+\/\/ which defines the actual logic for that kind of thread.\n+void JavaThread::run() {\n+  \/\/ initialize thread-local alloc buffer related fields\n+  initialize_tlab();\n+\n+  _stack_overflow_state.create_stack_guard_pages();\n+\n+  cache_global_variables();\n+\n+  \/\/ Thread is now sufficiently initialized to be handled by the safepoint code as being\n+  \/\/ in the VM. Change thread state from _thread_new to _thread_in_vm\n+  assert(this->thread_state() == _thread_new, \"wrong thread state\");\n+  set_thread_state(_thread_in_vm);\n+\n+  \/\/ Before a thread is on the threads list it is always safe, so after leaving the\n+  \/\/ _thread_new we should emit a instruction barrier. The distance to modified code\n+  \/\/ from here is probably far enough, but this is consistent and safe.\n+  OrderAccess::cross_modify_fence();\n+\n+  assert(JavaThread::current() == this, \"sanity check\");\n+  assert(!Thread::current()->owns_locks(), \"sanity check\");\n+\n+  DTRACE_THREAD_PROBE(start, this);\n+\n+  \/\/ This operation might block. We call that after all safepoint checks for a new thread has\n+  \/\/ been completed.\n+  set_active_handles(JNIHandleBlock::allocate_block());\n+\n+  if (JvmtiExport::should_post_thread_life()) {\n+    JvmtiExport::post_thread_start(this);\n+\n+  }\n+\n+  \/\/ We call another function to do the rest so we are sure that the stack addresses used\n+  \/\/ from there will be lower than the stack base just computed.\n+  thread_main_inner();\n+}\n+\n+void JavaThread::thread_main_inner() {\n+  assert(JavaThread::current() == this, \"sanity check\");\n+  assert(_threadObj.peek() != NULL, \"just checking\");\n+\n+  \/\/ Execute thread entry point unless this thread has a pending exception\n+  \/\/ or has been stopped before starting.\n+  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception() &&\n+      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+    {\n+      ResourceMark rm(this);\n+      this->set_native_thread_name(this->name());\n+    }\n+    HandleMark hm(this);\n+    this->entry_point()(this, this);\n+  }\n+\n+  DTRACE_THREAD_PROBE(stop, this);\n+\n+  \/\/ Cleanup is handled in post_run()\n+}\n+\n+\/\/ Shared teardown for all JavaThreads\n+void JavaThread::post_run() {\n+  this->exit(false);\n+  this->unregister_thread_stack_with_NMT();\n+  \/\/ Defer deletion to here to ensure 'this' is still referenceable in call_run\n+  \/\/ for any shared tear-down.\n+  this->smr_delete();\n+}\n+\n+static void ensure_join(JavaThread* thread) {\n+  \/\/ We do not need to grab the Threads_lock, since we are operating on ourself.\n+  Handle threadObj(thread, thread->threadObj());\n+  assert(threadObj.not_null(), \"java thread object must exist\");\n+  ObjectLocker lock(threadObj, thread);\n+  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  thread->clear_pending_exception();\n+  \/\/ Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.\n+  java_lang_Thread::set_thread_status(threadObj(), JavaThreadStatus::TERMINATED);\n+  \/\/ Clear the native thread instance - this makes isAlive return false and allows the join()\n+  \/\/ to complete once we've done the notify_all below\n+  java_lang_Thread::set_thread(threadObj(), NULL);\n+  lock.notify_all(thread);\n+  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  thread->clear_pending_exception();\n+}\n+\n+static bool is_daemon(oop threadObj) {\n+  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n+}\n+\n+\/\/ For any new cleanup additions, please check to see if they need to be applied to\n+\/\/ cleanup_failed_attach_current_thread as well.\n+void JavaThread::exit(bool destroy_vm, ExitType exit_type) {\n+  assert(this == JavaThread::current(), \"thread consistency check\");\n+  assert(!is_exiting(), \"should not be exiting or terminated already\");\n+\n+  elapsedTimer _timer_exit_phase1;\n+  elapsedTimer _timer_exit_phase2;\n+  elapsedTimer _timer_exit_phase3;\n+  elapsedTimer _timer_exit_phase4;\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase1.start();\n+  }\n+\n+  HandleMark hm(this);\n+  Handle uncaught_exception(this, this->pending_exception());\n+  this->clear_pending_exception();\n+  Handle threadObj(this, this->threadObj());\n+  assert(threadObj.not_null(), \"Java thread object should be created\");\n+\n+  if (!destroy_vm) {\n+    if (uncaught_exception.not_null()) {\n+      EXCEPTION_MARK;\n+      \/\/ Call method Thread.dispatchUncaughtException().\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::dispatchUncaughtException_name(),\n+                              vmSymbols::throwable_void_signature(),\n+                              uncaught_exception,\n+                              THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        ResourceMark rm(this);\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"\\nException: %s thrown from the UncaughtExceptionHandler\"\n+                    \" in thread \\\"%s\\\"\\n\",\n+                    pending_exception()->klass()->external_name(),\n+                    name());\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n+    }\n+\n+    if (!is_Compiler_thread()) {\n+      \/\/ We have finished executing user-defined Java code and now have to do the\n+      \/\/ implementation specific clean-up by calling Thread.exit(). We prevent any\n+      \/\/ asynchronous exceptions from being delivered while in Thread.exit()\n+      \/\/ to ensure the clean-up is not corrupted.\n+      NoAsyncExceptionDeliveryMark _no_async(this);\n+\n+      EXCEPTION_MARK;\n+      JavaValue result(T_VOID);\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::exit_method_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+\n+    \/\/ notify JVMTI\n+    if (JvmtiExport::should_post_thread_life()) {\n+      JvmtiExport::post_thread_end(this);\n+    }\n+  } else {\n+    \/\/ before_exit() has already posted JVMTI THREAD_END events\n+  }\n+\n+  \/\/ Cleanup any pending async exception now since we cannot access oops after\n+  \/\/ BarrierSet::barrier_set()->on_thread_detach() has been executed.\n+  if (has_async_exception_condition()) {\n+    handshake_state()->clean_async_exception_operation();\n+  }\n+\n+  \/\/ The careful dance between thread suspension and exit is handled here.\n+  \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n+  \/\/ we can just put in the exiting state and it will be correctly handled.\n+  \/\/ Also, no more async exceptions will be added to the queue after this point.\n+  set_terminated(_thread_exiting);\n+  ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase1.stop();\n+    _timer_exit_phase2.start();\n+  }\n+\n+  \/\/ Capture daemon status before the thread is marked as terminated.\n+  bool daemon = is_daemon(threadObj());\n+\n+  \/\/ Notify waiters on thread object. This has to be done after exit() is called\n+  \/\/ on the thread (if the thread is the last thread in a daemon ThreadGroup the\n+  \/\/ group should have the destroyed bit set before waiters are notified).\n+  ensure_join(this);\n+  assert(!this->has_pending_exception(), \"ensure_join should have cleared\");\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase2.stop();\n+    _timer_exit_phase3.start();\n+  }\n+  \/\/ 6282335 JNI DetachCurrentThread spec states that all Java monitors\n+  \/\/ held by this thread must be released. The spec does not distinguish\n+  \/\/ between JNI-acquired and regular Java monitors. We can only see\n+  \/\/ regular Java monitors here if monitor enter-exit matching is broken.\n+  \/\/\n+  \/\/ ensure_join() ignores IllegalThreadStateExceptions, and so does\n+  \/\/ ObjectSynchronizer::release_monitors_owned_by_thread().\n+  if (exit_type == jni_detach) {\n+    \/\/ Sanity check even though JNI DetachCurrentThread() would have\n+    \/\/ returned JNI_ERR if there was a Java frame. JavaThread exit\n+    \/\/ should be done executing Java code by the time we get here.\n+    assert(!this->has_last_Java_frame(),\n+           \"should not have a Java frame when detaching or exiting\");\n+    ObjectSynchronizer::release_monitors_owned_by_thread(this);\n+    assert(!this->has_pending_exception(), \"release_monitors should have cleared\");\n+  }\n+\n+  assert(!Continuations::enabled() || this->held_monitor_count() == 0, \"held monitor count should be zero\");\n+\n+  \/\/ These things needs to be done while we are still a Java Thread. Make sure that thread\n+  \/\/ is in a consistent state, in case GC happens\n+  JFR_ONLY(Jfr::on_thread_exit(this);)\n+\n+  if (active_handles() != NULL) {\n+    JNIHandleBlock* block = active_handles();\n+    set_active_handles(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  if (free_handle_block() != NULL) {\n+    JNIHandleBlock* block = free_handle_block();\n+    set_free_handle_block(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  \/\/ These have to be removed while this is still a valid thread.\n+  _stack_overflow_state.remove_stack_guard_pages();\n+\n+  if (UseTLAB) {\n+    tlab().retire();\n+  }\n+\n+  if (JvmtiEnv::environments_might_exist()) {\n+    JvmtiExport::cleanup_thread(this);\n+  }\n+\n+  \/\/ We need to cache the thread name for logging purposes below as once\n+  \/\/ we have called on_thread_detach this thread must not access any oops.\n+  char* thread_name = NULL;\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    ResourceMark rm(this);\n+    thread_name = os::strdup(name());\n+  }\n+\n+  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n+    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n+    os::current_thread_id());\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase3.stop();\n+    _timer_exit_phase4.start();\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    if (jvmci_counters_include(this)) {\n+      for (int i = 0; i < JVMCICounterSize; i++) {\n+        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n+  \/\/ Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread.\n+  \/\/ We call BarrierSet::barrier_set()->on_thread_detach() here so no touching of oops after this point.\n+  Threads::remove(this, daemon);\n+\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    _timer_exit_phase4.stop();\n+    log_debug(os, thread, timer)(\"name='%s'\"\n+                                 \", exit-phase1=\" JLONG_FORMAT\n+                                 \", exit-phase2=\" JLONG_FORMAT\n+                                 \", exit-phase3=\" JLONG_FORMAT\n+                                 \", exit-phase4=\" JLONG_FORMAT,\n+                                 thread_name,\n+                                 _timer_exit_phase1.milliseconds(),\n+                                 _timer_exit_phase2.milliseconds(),\n+                                 _timer_exit_phase3.milliseconds(),\n+                                 _timer_exit_phase4.milliseconds());\n+    os::free(thread_name);\n+  }\n+}\n+\n+void JavaThread::cleanup_failed_attach_current_thread(bool is_daemon) {\n+  if (active_handles() != NULL) {\n+    JNIHandleBlock* block = active_handles();\n+    set_active_handles(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  if (free_handle_block() != NULL) {\n+    JNIHandleBlock* block = free_handle_block();\n+    set_free_handle_block(NULL);\n+    JNIHandleBlock::release_block(block);\n+  }\n+\n+  \/\/ These have to be removed while this is still a valid thread.\n+  _stack_overflow_state.remove_stack_guard_pages();\n+\n+  if (UseTLAB) {\n+    tlab().retire();\n+  }\n+\n+  Threads::remove(this, is_daemon);\n+  this->smr_delete();\n+}\n+\n+JavaThread* JavaThread::active() {\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    return JavaThread::cast(thread);\n+  } else {\n+    assert(thread->is_VM_thread(), \"this must be a vm thread\");\n+    VM_Operation* op = ((VMThread*) thread)->vm_operation();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n+    return ret;\n+  }\n+}\n+\n+bool JavaThread::is_lock_owned(address adr) const {\n+  if (Thread::is_lock_owned(adr)) return true;\n+\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    if (chunk->contains(adr)) return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool JavaThread::is_lock_owned_current(address adr) const {\n+  address stack_end = _stack_base - _stack_size;\n+  const ContinuationEntry* ce = vthread_continuation();\n+  address stack_base = ce != nullptr ? (address)ce->entry_sp() : _stack_base;\n+  if (stack_base > adr && adr >= stack_end) {\n+    return true;\n+  }\n+\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    if (chunk->contains(adr)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool JavaThread::is_lock_owned_carrier(address adr) const {\n+  assert(is_vthread_mounted(), \"\");\n+  address stack_end = _stack_base - _stack_size;\n+  address stack_base = (address)vthread_continuation()->entry_sp();\n+  return stack_base > adr && adr >= stack_end;\n+}\n+\n+oop JavaThread::exception_oop() const {\n+  return Atomic::load(&_exception_oop);\n+}\n+\n+void JavaThread::set_exception_oop(oop o) {\n+  Atomic::store(&_exception_oop, o);\n+}\n+\n+void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n+  chunk->set_next(monitor_chunks());\n+  set_monitor_chunks(chunk);\n+}\n+\n+void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n+  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n+  if (monitor_chunks() == chunk) {\n+    set_monitor_chunks(chunk->next());\n+  } else {\n+    MonitorChunk* prev = monitor_chunks();\n+    while (prev->next() != chunk) prev = prev->next();\n+    prev->set_next(chunk->next());\n+  }\n+}\n+\n+void JavaThread::handle_special_runtime_exit_condition() {\n+  if (is_obj_deopt_suspend()) {\n+    frame_anchor()->make_walkable();\n+    wait_for_object_deoptimization();\n+  }\n+  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n+}\n+\n+\n+\/\/ Asynchronous exceptions support\n+\/\/\n+void JavaThread::handle_async_exception(oop java_throwable) {\n+  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(!is_at_poll_safepoint(), \"should have never called this method\");\n+\n+  if (has_last_Java_frame()) {\n+    frame f = last_frame();\n+    if (f.is_runtime_frame()) {\n+      \/\/ If the topmost frame is a runtime stub, then we are calling into\n+      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n+      \/\/ must deoptimize the caller before continuing, as the compiled exception\n+      \/\/ handler table may not be valid.\n+      RegisterMap reg_map(this, false);\n+      frame compiled_frame = f.sender(&reg_map);\n+      if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n+        Deoptimization::deoptimize(this, compiled_frame);\n+      }\n+    }\n+  }\n+\n+  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n+  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n+\n+    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+    set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+    \/\/ Clear any extent-local bindings on ThreadDeath\n+    set_extentLocalCache(NULL);\n+    oop threadOop = threadObj();\n+    assert(threadOop != NULL, \"must be\");\n+    java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+    LogTarget(Info, exceptions) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+      if (has_last_Java_frame()) {\n+        frame f = last_frame();\n+        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n+      }\n+      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+    }\n+  }\n+}\n+\n+void JavaThread::install_async_exception(AsyncExceptionHandshake* aeh) {\n+  \/\/ Do not throw asynchronous exceptions against the compiler thread\n+  \/\/ or if the thread is already exiting.\n+  if (!can_call_java() || is_exiting()) {\n+    delete aeh;\n+    return;\n+  }\n+\n+  \/\/ Don't install a new pending async exception if there is already\n+  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n+  \/\/ wait()\/sleep()\/park() and return.\n+  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n+    java_lang_Thread::set_interrupted(threadObj(), true);\n+    this->interrupt();\n+    delete aeh;\n+    return;\n+  }\n+\n+  oop exception = aeh->exception();\n+  Handshake::execute(aeh, this);  \/\/ Install asynchronous handshake\n+\n+  ResourceMark rm;\n+  if (log_is_enabled(Info, exceptions)) {\n+    log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n+                         InstanceKlass::cast(exception->klass())->external_name());\n+  }\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception->klass()->external_name());\n+\n+  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n+  java_lang_Thread::set_interrupted(threadObj(), true);\n+  this->interrupt();\n+}\n+\n+class InstallAsyncExceptionHandshake : public HandshakeClosure {\n+  AsyncExceptionHandshake* _aeh;\n+public:\n+  InstallAsyncExceptionHandshake(AsyncExceptionHandshake* aeh) :\n+    HandshakeClosure(\"InstallAsyncException\"), _aeh(aeh) {}\n+  ~InstallAsyncExceptionHandshake() {\n+    \/\/ If InstallAsyncExceptionHandshake was never executed we need to clean up _aeh.\n+    delete _aeh;\n+  }\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = JavaThread::cast(thr);\n+    target->install_async_exception(_aeh);\n+    _aeh = nullptr;\n+  }\n+};\n+\n+void JavaThread::send_async_exception(JavaThread* target, oop java_throwable) {\n+  OopHandle e(Universe::vm_global(), java_throwable);\n+  InstallAsyncExceptionHandshake iaeh(new AsyncExceptionHandshake(e));\n+  Handshake::execute(&iaeh, target);\n+}\n+\n+#if INCLUDE_JVMTI\n+void JavaThread::set_is_in_VTMS_transition(bool val) {\n+  _is_in_VTMS_transition = val;\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::set_is_VTMS_transition_disabler(bool val) {\n+  _is_VTMS_transition_disabler = val;\n+}\n+#endif\n+#endif\n+\n+\/\/ External suspension mechanism.\n+\/\/\n+\/\/ Guarantees on return (for a valid target thread):\n+\/\/   - Target thread will not execute any new bytecode.\n+\/\/   - Target thread will not enter any new monitors.\n+\/\/\n+bool JavaThread::java_suspend() {\n+#if INCLUDE_JVMTI\n+  \/\/ Suspending a JavaThread in VTMS transition or disabling VTMS transitions can cause deadlocks.\n+  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n+  assert(!is_VTMS_transition_disabler(), \"no suspend allowed for VTMS transition disablers\");\n+#endif\n+\n+  guarantee(Thread::is_JavaThread_protected(\/* target *\/ this),\n+            \"target JavaThread is not protected in calling context.\");\n+  return this->handshake_state()->suspend();\n+}\n+\n+bool JavaThread::java_resume() {\n+  guarantee(Thread::is_JavaThread_protected_by_TLH(\/* target *\/ this),\n+            \"missing ThreadsListHandle in calling context.\");\n+  return this->handshake_state()->resume();\n+}\n+\n+\/\/ Wait for another thread to perform object reallocation and relocking on behalf of\n+\/\/ this thread. The current thread is required to change to _thread_blocked in order\n+\/\/ to be seen to be safepoint\/handshake safe whilst suspended and only after becoming\n+\/\/ handshake safe, the other thread can complete the handshake used to synchronize\n+\/\/ with this thread and then perform the reallocation and relocking.\n+\/\/ See EscapeBarrier::sync_and_suspend_*()\n+\n+void JavaThread::wait_for_object_deoptimization() {\n+  assert(!has_last_Java_frame() || frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(this == Thread::current(), \"invariant\");\n+\n+  bool spin_wait = os::is_MP();\n+  do {\n+    ThreadBlockInVM tbivm(this, true \/* allow_suspend *\/);\n+    \/\/ Wait for object deoptimization if requested.\n+    if (spin_wait) {\n+      \/\/ A single deoptimization is typically very short. Microbenchmarks\n+      \/\/ showed 5% better performance when spinning.\n+      const uint spin_limit = 10 * SpinYield::default_spin_limit;\n+      SpinYield spin(spin_limit);\n+      for (uint i = 0; is_obj_deopt_suspend() && i < spin_limit; i++) {\n+        spin.wait();\n+      }\n+      \/\/ Spin just once\n+      spin_wait = false;\n+    } else {\n+      MonitorLocker ml(this, EscapeBarrier_lock, Monitor::_no_safepoint_check_flag);\n+      if (is_obj_deopt_suspend()) {\n+        ml.wait();\n+      }\n+    }\n+    \/\/ A handshake for obj. deoptimization suspend could have been processed so\n+    \/\/ we must check after processing.\n+  } while (is_obj_deopt_suspend());\n+}\n+\n+#ifdef ASSERT\n+\/\/ Verify the JavaThread has not yet been published in the Threads::list, and\n+\/\/ hence doesn't need protection from concurrent access at this stage.\n+void JavaThread::verify_not_published() {\n+  \/\/ Cannot create a ThreadsListHandle here and check !tlh.includes(this)\n+  \/\/ since an unpublished JavaThread doesn't participate in the\n+  \/\/ Thread-SMR protocol for keeping a ThreadsList alive.\n+  assert(!on_thread_list(), \"JavaThread shouldn't have been published yet!\");\n+}\n+#endif\n+\n+\/\/ Slow path when the native==>Java barriers detect a safepoint\/handshake is\n+\/\/ pending, when _suspend_flags is non-zero or when we need to process a stack\n+\/\/ watermark. Also check for pending async exceptions (except unsafe access error).\n+\/\/ Note only the native==>Java barriers can call this function when thread state\n+\/\/ is _thread_in_native_trans.\n+void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n+  assert(thread->thread_state() == _thread_in_native_trans, \"wrong state\");\n+  assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->Java transition\");\n+\n+  thread->set_thread_state(_thread_in_vm);\n+\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n+\n+  \/\/ After returning from native, it could be that the stack frames are not\n+  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n+  \/\/ barrier, which will trap unsafe stack frames.\n+  StackWatermarkSet::before_unwind(thread);\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Deoptimization\n+\/\/ Function for testing deoptimization\n+void JavaThread::deoptimize() {\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n+  bool deopt = false;           \/\/ Dump stack only if a deopt actually happens.\n+  bool only_at = strlen(DeoptimizeOnlyAt) > 0;\n+  \/\/ Iterate over all frames in the thread and deoptimize\n+  for (; !fst.is_done(); fst.next()) {\n+    if (fst.current()->can_be_deoptimized()) {\n+\n+      if (only_at) {\n+        \/\/ Deoptimize only at particular bcis.  DeoptimizeOnlyAt\n+        \/\/ consists of comma or carriage return separated numbers so\n+        \/\/ search for the current bci in that string.\n+        address pc = fst.current()->pc();\n+        nmethod* nm =  (nmethod*) fst.current()->cb();\n+        ScopeDesc* sd = nm->scope_desc_at(pc);\n+        char buffer[8];\n+        jio_snprintf(buffer, sizeof(buffer), \"%d\", sd->bci());\n+        size_t len = strlen(buffer);\n+        const char * found = strstr(DeoptimizeOnlyAt, buffer);\n+        while (found != NULL) {\n+          if ((found[len] == ',' || found[len] == '\\n' || found[len] == '\\0') &&\n+              (found == DeoptimizeOnlyAt || found[-1] == ',' || found[-1] == '\\n')) {\n+            \/\/ Check that the bci found is bracketed by terminators.\n+            break;\n+          }\n+          found = strstr(found + 1, buffer);\n+        }\n+        if (!found) {\n+          continue;\n+        }\n+      }\n+\n+      if (DebugDeoptimization && !deopt) {\n+        deopt = true; \/\/ One-time only print before deopt\n+        tty->print_cr(\"[BEFORE Deoptimization]\");\n+        trace_frames();\n+        trace_stack();\n+      }\n+      Deoptimization::deoptimize(this, *fst.current());\n+    }\n+  }\n+\n+  if (DebugDeoptimization && deopt) {\n+    tty->print_cr(\"[AFTER Deoptimization]\");\n+    trace_frames();\n+  }\n+}\n+\n+\n+\/\/ Make zombies\n+void JavaThread::make_zombies() {\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    if (fst.current()->can_be_deoptimized()) {\n+      \/\/ it is a Java nmethod\n+      nmethod* nm = CodeCache::find_nmethod(fst.current()->pc());\n+      nm->make_not_entrant();\n+    }\n+  }\n+}\n+#endif \/\/ PRODUCT\n+\n+\n+void JavaThread::deoptimize_marked_methods() {\n+  if (!has_last_Java_frame()) return;\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n+  for (; !fst.is_done(); fst.next()) {\n+    if (fst.current()->should_be_deoptimized()) {\n+      Deoptimization::deoptimize(this, *fst.current());\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n+         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n+}\n+#endif\n+\n+\/\/ Push on a new block of JNI handles.\n+void JavaThread::push_jni_handle_block() {\n+  \/\/ Allocate a new block for JNI handles.\n+  \/\/ Inlined code from jni_PushLocalFrame()\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(this);\n+  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  new_handles->set_pop_frame_link(old_handles);  \/\/ make sure java handles get gc'd.\n+  set_active_handles(new_handles);\n+}\n+\n+\/\/ Pop off the current block of JNI handles.\n+void JavaThread::pop_jni_handle_block() {\n+  \/\/ Release our JNI handle block\n+  JNIHandleBlock* old_handles = active_handles();\n+  JNIHandleBlock* new_handles = old_handles->pop_frame_link();\n+  assert(new_handles != nullptr, \"should never set active handles to null\");\n+  set_active_handles(new_handles);\n+  old_handles->set_pop_frame_link(NULL);\n+  JNIHandleBlock::release_block(old_handles, this);\n+}\n+\n+void JavaThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  \/\/ Verify that the deferred card marks have been flushed.\n+  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n+\n+  \/\/ Traverse the GCHandles\n+  Thread::oops_do_no_frames(f, cf);\n+\n+  if (active_handles() != NULL) {\n+    active_handles()->oops_do(f);\n+  }\n+\n+  DEBUG_ONLY(verify_frame_info();)\n+\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the monitor chunks\n+    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+      chunk->oops_do(f);\n+    }\n+  }\n+\n+  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n+  \/\/ If we have deferred set_locals there might be oops waiting to be\n+  \/\/ written\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      list->at(i)->oops_do(f);\n+    }\n+  }\n+\n+  \/\/ Traverse instance variables at the end since the GC may be moving things\n+  \/\/ around using this function\n+  f->do_oop((oop*) &_vm_result);\n+  f->do_oop((oop*) &_exception_oop);\n+#if INCLUDE_JVMCI\n+  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+#endif\n+\n+  if (jvmti_thread_state() != NULL) {\n+    jvmti_thread_state()->oops_do(f, cf);\n+  }\n+}\n+\n+void JavaThread::oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  if (!has_last_Java_frame()) {\n+    return;\n+  }\n+  \/\/ Finish any pending lazy GC activity for the frames\n+  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  \/\/ Traverse the execution stack\n+  for (StackFrameStream fst(this, true \/* update *\/, false \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    fst.current()->oops_do(f, cf, fst.register_map());\n+  }\n+}\n+\n+#ifdef ASSERT\n+void JavaThread::verify_states_for_handshake() {\n+  \/\/ This checks that the thread has a correct frame state during a handshake.\n+  verify_frame_info();\n+}\n+#endif\n+\n+void JavaThread::nmethods_do(CodeBlobClosure* cf) {\n+  DEBUG_ONLY(verify_frame_info();)\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n+\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the execution stack\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+      fst.current()->nmethods_do(cf);\n+    }\n+  }\n+\n+  if (jvmti_thread_state() != NULL) {\n+    jvmti_thread_state()->nmethods_do(cf);\n+  }\n+}\n+\n+void JavaThread::metadata_do(MetadataClosure* f) {\n+  if (has_last_Java_frame()) {\n+    \/\/ Traverse the execution stack to call f() on the methods in the stack\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+      fst.current()->metadata_do(f);\n+    }\n+  } else if (is_Compiler_thread()) {\n+    \/\/ need to walk ciMetadata in current compile tasks to keep alive.\n+    CompilerThread* ct = (CompilerThread*)this;\n+    if (ct->env() != NULL) {\n+      ct->env()->metadata_do(f);\n+    }\n+    CompileTask* task = ct->task();\n+    if (task != NULL) {\n+      task->metadata_do(f);\n+    }\n+  }\n+}\n+\n+\/\/ Printing\n+const char* _get_thread_state_name(JavaThreadState _thread_state) {\n+  switch (_thread_state) {\n+  case _thread_uninitialized:     return \"_thread_uninitialized\";\n+  case _thread_new:               return \"_thread_new\";\n+  case _thread_new_trans:         return \"_thread_new_trans\";\n+  case _thread_in_native:         return \"_thread_in_native\";\n+  case _thread_in_native_trans:   return \"_thread_in_native_trans\";\n+  case _thread_in_vm:             return \"_thread_in_vm\";\n+  case _thread_in_vm_trans:       return \"_thread_in_vm_trans\";\n+  case _thread_in_Java:           return \"_thread_in_Java\";\n+  case _thread_in_Java_trans:     return \"_thread_in_Java_trans\";\n+  case _thread_blocked:           return \"_thread_blocked\";\n+  case _thread_blocked_trans:     return \"_thread_blocked_trans\";\n+  default:                        return \"unknown thread state\";\n+  }\n+}\n+\n+void JavaThread::print_thread_state_on(outputStream *st) const {\n+  st->print_cr(\"   JavaThread state: %s\", _get_thread_state_name(_thread_state));\n+}\n+\n+const char* JavaThread::thread_state_name() const {\n+  return _get_thread_state_name(_thread_state);\n+}\n+\n+\/\/ Called by Threads::print() for VM_PrintThreads operation\n+void JavaThread::print_on(outputStream *st, bool print_extended_info) const {\n+  st->print_raw(\"\\\"\");\n+  st->print_raw(name());\n+  st->print_raw(\"\\\" \");\n+  oop thread_oop = threadObj();\n+  if (thread_oop != NULL) {\n+    st->print(\"#\" INT64_FORMAT \" [%ld] \", (int64_t)java_lang_Thread::thread_id(thread_oop), (long) osthread()->thread_id());\n+    if (java_lang_Thread::is_daemon(thread_oop))  st->print(\"daemon \");\n+    st->print(\"prio=%d \", java_lang_Thread::priority(thread_oop));\n+  }\n+  Thread::print_on(st, print_extended_info);\n+  \/\/ print guess for valid stack memory region (assume 4K pages); helps lock debugging\n+  st->print_cr(\"[\" INTPTR_FORMAT \"]\", (intptr_t)last_Java_sp() & ~right_n_bits(12));\n+  if (thread_oop != NULL) {\n+    if (is_vthread_mounted()) {\n+      oop vt = vthread();\n+      assert(vt != NULL, \"\");\n+      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n+    } else {\n+      st->print_cr(\"   java.lang.Thread.State: %s\", java_lang_Thread::thread_status_name(thread_oop));\n+    }\n+  }\n+#ifndef PRODUCT\n+  _safepoint_state->print_on(st);\n+#endif \/\/ PRODUCT\n+  if (is_Compiler_thread()) {\n+    CompileTask *task = ((CompilerThread*)this)->task();\n+    if (task != NULL) {\n+      st->print(\"   Compiling: \");\n+      task->print(st, NULL, true, false);\n+    } else {\n+      st->print(\"   No compile task\");\n+    }\n+    st->cr();\n+  }\n+}\n+\n+void JavaThread::print() const { print_on(tty); }\n+\n+void JavaThread::print_name_on_error(outputStream* st, char *buf, int buflen) const {\n+  st->print(\"%s\", get_thread_name_string(buf, buflen));\n+}\n+\n+\/\/ Called by fatal error handler. The difference between this and\n+\/\/ JavaThread::print() is that we can't grab lock or allocate memory.\n+void JavaThread::print_on_error(outputStream* st, char *buf, int buflen) const {\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n+  Thread* current = Thread::current_or_null_safe();\n+  assert(current != nullptr, \"cannot be called by a detached thread\");\n+  if (!current->is_Java_thread() || JavaThread::cast(current)->is_oop_safe()) {\n+    \/\/ Only access threadObj() if current thread is not a JavaThread\n+    \/\/ or if it is a JavaThread that can safely access oops.\n+    oop thread_obj = threadObj();\n+    if (thread_obj != nullptr) {\n+      if (java_lang_Thread::is_daemon(thread_obj)) st->print(\" daemon\");\n+    }\n+  }\n+  st->print(\" [\");\n+  st->print(\"%s\", _get_thread_state_name(_thread_state));\n+  if (osthread()) {\n+    st->print(\", id=%d\", osthread()->thread_id());\n+  }\n+  st->print(\", stack(\" PTR_FORMAT \",\" PTR_FORMAT \")\",\n+            p2i(stack_end()), p2i(stack_base()));\n+  st->print(\"]\");\n+\n+  ThreadsSMRSupport::print_info_on(this, st);\n+  return;\n+}\n+\n+\n+\/\/ Verification\n+\n+void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n+  \/\/ ignore if there is no stack\n+  if (!has_last_Java_frame()) return;\n+  \/\/ traverse the stack frames. Starts from top frame.\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    frame* fr = fst.current();\n+    f(fr, fst.register_map());\n+  }\n+}\n+\n+static void frame_verify(frame* f, const RegisterMap *map) { f->verify(map); }\n+\n+void JavaThread::verify() {\n+  \/\/ Verify oops in the thread.\n+  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+\n+  \/\/ Verify the stack frames.\n+  frames_do(frame_verify);\n+}\n+\n+\/\/ CR 6300358 (sub-CR 2137150)\n+\/\/ Most callers of this method assume that it can't return NULL but a\n+\/\/ thread may not have a name whilst it is in the process of attaching to\n+\/\/ the VM - see CR 6412693, and there are places where a JavaThread can be\n+\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n+\/\/ if vm exit occurs during initialization). These cases can all be accounted\n+\/\/ for such that this method never returns NULL.\n+const char* JavaThread::name() const  {\n+  if (Thread::is_JavaThread_protected(\/* target *\/ this)) {\n+    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n+    return get_thread_name_string();\n+  }\n+\n+  \/\/ The target JavaThread is not protected so we return the default:\n+  return Thread::name();\n+}\n+\n+\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n+\/\/ descriptive string if there is no set name.\n+const char* JavaThread::get_thread_name_string(char* buf, int buflen) const {\n+  const char* name_str;\n+#ifdef ASSERT\n+  Thread* current = Thread::current_or_null_safe();\n+  assert(current != nullptr, \"cannot be called by a detached thread\");\n+  if (!current->is_Java_thread() || JavaThread::cast(current)->is_oop_safe()) {\n+    \/\/ Only access threadObj() if current thread is not a JavaThread\n+    \/\/ or if it is a JavaThread that can safely access oops.\n+#endif\n+    oop thread_obj = threadObj();\n+    if (thread_obj != NULL) {\n+      oop name = java_lang_Thread::name(thread_obj);\n+      if (name != NULL) {\n+        if (buf == NULL) {\n+          name_str = java_lang_String::as_utf8_string(name);\n+        } else {\n+          name_str = java_lang_String::as_utf8_string(name, buf, buflen);\n+        }\n+      } else if (is_attaching_via_jni()) { \/\/ workaround for 6412693 - see 6404306\n+        name_str = \"<no-name - thread is attaching>\";\n+      } else {\n+        name_str = \"<un-named>\";\n+      }\n+    } else {\n+      name_str = Thread::name();\n+    }\n+#ifdef ASSERT\n+  } else {\n+    \/\/ Current JavaThread has exited...\n+    if (current == this) {\n+      \/\/ ... and is asking about itself:\n+      name_str = \"<no-name - current JavaThread has exited>\";\n+    } else {\n+      \/\/ ... and it can't safely determine this JavaThread's name so\n+      \/\/ use the default thread name.\n+      name_str = Thread::name();\n+    }\n+  }\n+#endif\n+  assert(name_str != NULL, \"unexpected NULL thread name\");\n+  return name_str;\n+}\n+\n+\/\/ Helper to extract the name from the thread oop for logging.\n+const char* JavaThread::name_for(oop thread_obj) {\n+  assert(thread_obj != NULL, \"precondition\");\n+  oop name = java_lang_Thread::name(thread_obj);\n+  const char* name_str;\n+  if (name != NULL) {\n+    name_str = java_lang_String::as_utf8_string(name);\n+  } else {\n+    name_str = \"<un-named>\";\n+  }\n+  return name_str;\n+}\n+\n+void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {\n+\n+  assert(Threads_lock->owner() == Thread::current(), \"must have threads lock\");\n+  assert(NoPriority <= prio && prio <= MaxPriority, \"sanity check\");\n+  \/\/ Link Java Thread object <-> C++ Thread\n+\n+  \/\/ Get the C++ thread object (an oop) from the JNI handle (a jthread)\n+  \/\/ and put it into a new Handle.  The Handle \"thread_oop\" can then\n+  \/\/ be used to pass the C++ thread object to other methods.\n+\n+  \/\/ Set the Java level thread object (jthread) field of the\n+  \/\/ new thread (a JavaThread *) to C++ thread object using the\n+  \/\/ \"thread_oop\" handle.\n+\n+  \/\/ Set the thread field (a JavaThread *) of the\n+  \/\/ oop representing the java_lang_Thread to the new thread (a JavaThread *).\n+\n+  Handle thread_oop(Thread::current(),\n+                    JNIHandles::resolve_non_null(jni_thread));\n+  assert(InstanceKlass::cast(thread_oop->klass())->is_linked(),\n+         \"must be initialized\");\n+  set_threadOopHandles(thread_oop());\n+  java_lang_Thread::set_thread(thread_oop(), this);\n+\n+  if (prio == NoPriority) {\n+    prio = java_lang_Thread::priority(thread_oop());\n+    assert(prio != NoPriority, \"A valid priority should be present\");\n+  }\n+\n+  \/\/ Push the Java priority down to the native thread; needs Threads_lock\n+  Thread::set_priority(this, prio);\n+\n+  \/\/ Add the new thread to the Threads list and set it in motion.\n+  \/\/ We must have threads lock in order to call Threads::add.\n+  \/\/ It is crucial that we do not block before the thread is\n+  \/\/ added to the Threads list for if a GC happens, then the java_thread oop\n+  \/\/ will not be visited by GC.\n+  Threads::add(this);\n+}\n+\n+oop JavaThread::current_park_blocker() {\n+  \/\/ Support for JSR-166 locks\n+  oop thread_oop = threadObj();\n+  if (thread_oop != NULL) {\n+    return java_lang_Thread::park_blocker(thread_oop);\n+  }\n+  return NULL;\n+}\n+\n+\n+void JavaThread::print_stack_on(outputStream* st) {\n+  if (!has_last_Java_frame()) return;\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  RegisterMap reg_map(this, true, true);\n+  vframe* start_vf = platform_thread_last_java_vframe(&reg_map);\n+  int count = 0;\n+  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+    if (f->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(f);\n+      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n+\n+      \/\/ Print out lock information\n+      if (JavaMonitorsInStackTrace) {\n+        jvf->print_lock_info_on(st, count);\n+      }\n+    } else {\n+      \/\/ Ignore non-Java frames\n+    }\n+\n+    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n+    count++;\n+    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n+  }\n+}\n+\n+#if INCLUDE_JVMTI\n+\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n+JvmtiThreadState* JavaThread::rebind_to_jvmti_thread_state_of(oop thread_oop) {\n+  set_jvmti_vthread(thread_oop);\n+\n+  \/\/ unbind current JvmtiThreadState from JavaThread\n+  JvmtiThreadState::unbind_from(jvmti_thread_state(), this);\n+\n+  \/\/ bind new JvmtiThreadState to JavaThread\n+  JvmtiThreadState::bind_to(java_lang_Thread::jvmti_thread_state(thread_oop), this);\n+\n+  return jvmti_thread_state();\n+}\n+#endif\n+\n+\/\/ JVMTI PopFrame support\n+void JavaThread::popframe_preserve_args(ByteSize size_in_bytes, void* start) {\n+  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n+  if (in_bytes(size_in_bytes) != 0) {\n+    _popframe_preserved_args = NEW_C_HEAP_ARRAY(char, in_bytes(size_in_bytes), mtThread);\n+    _popframe_preserved_args_size = in_bytes(size_in_bytes);\n+    Copy::conjoint_jbytes(start, _popframe_preserved_args, _popframe_preserved_args_size);\n+  }\n+}\n+\n+void* JavaThread::popframe_preserved_args() {\n+  return _popframe_preserved_args;\n+}\n+\n+ByteSize JavaThread::popframe_preserved_args_size() {\n+  return in_ByteSize(_popframe_preserved_args_size);\n+}\n+\n+WordSize JavaThread::popframe_preserved_args_size_in_words() {\n+  int sz = in_bytes(popframe_preserved_args_size());\n+  assert(sz % wordSize == 0, \"argument size must be multiple of wordSize\");\n+  return in_WordSize(sz \/ wordSize);\n+}\n+\n+void JavaThread::popframe_free_preserved_args() {\n+  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n+  FREE_C_HEAP_ARRAY(char, (char*)_popframe_preserved_args);\n+  _popframe_preserved_args = NULL;\n+  _popframe_preserved_args_size = 0;\n+}\n+\n+#ifndef PRODUCT\n+\n+void JavaThread::trace_frames() {\n+  tty->print_cr(\"[Describe stack]\");\n+  int frame_no = 1;\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    tty->print(\"  %d. \", frame_no++);\n+    fst.current()->print_value_on(tty, this);\n+    tty->cr();\n+  }\n+}\n+\n+class PrintAndVerifyOopClosure: public OopClosure {\n+ protected:\n+  template <class T> inline void do_oop_work(T* p) {\n+    oop obj = RawAccess<>::oop_load(p);\n+    if (obj == NULL) return;\n+    tty->print(INTPTR_FORMAT \": \", p2i(p));\n+    if (oopDesc::is_oop_or_null(obj)) {\n+      if (obj->is_objArray()) {\n+        tty->print_cr(\"valid objArray: \" INTPTR_FORMAT, p2i(obj));\n+      } else {\n+        obj->print();\n+      }\n+    } else {\n+      tty->print_cr(\"invalid oop: \" INTPTR_FORMAT, p2i(obj));\n+    }\n+    tty->cr();\n+  }\n+ public:\n+  virtual void do_oop(oop* p) { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)  { do_oop_work(p); }\n+};\n+\n+#ifdef ASSERT\n+\/\/ Print or validate the layout of stack frames\n+void JavaThread::print_frame_layout(int depth, bool validate_only) {\n+  ResourceMark rm;\n+  PreserveExceptionMark pm(this);\n+  FrameValues values;\n+  int frame_no = 0;\n+  for (StackFrameStream fst(this, true, true, true); !fst.is_done(); fst.next()) {\n+    fst.current()->describe(values, ++frame_no, fst.register_map());\n+    if (depth == frame_no) break;\n+  }\n+  Continuation::describe(values);\n+  if (validate_only) {\n+    values.validate();\n+  } else {\n+    tty->print_cr(\"[Describe stack layout]\");\n+    values.print(this);\n+  }\n+}\n+#endif\n+\n+void JavaThread::trace_stack_from(vframe* start_vf) {\n+  ResourceMark rm;\n+  int vframe_no = 1;\n+  for (vframe* f = start_vf; f; f = f->sender()) {\n+    if (f->is_java_frame()) {\n+      javaVFrame::cast(f)->print_activation(vframe_no++);\n+    } else {\n+      f->print();\n+    }\n+    if (vframe_no > StackPrintLimit) {\n+      tty->print_cr(\"...<more frames>...\");\n+      return;\n+    }\n+  }\n+}\n+\n+\n+void JavaThread::trace_stack() {\n+  if (!has_last_Java_frame()) return;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+  RegisterMap reg_map(this, true, true);\n+  trace_stack_from(last_java_vframe(&reg_map));\n+}\n+\n+\n+#endif \/\/ PRODUCT\n+\n+void JavaThread::inc_held_monitor_count() {\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  _held_monitor_count++;\n+}\n+\n+void JavaThread::dec_held_monitor_count() {\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  assert(_held_monitor_count > 0, \"\");\n+  _held_monitor_count--;\n+}\n+\n+frame JavaThread::vthread_last_frame() {\n+  assert (is_vthread_mounted(), \"Virtual thread not mounted\");\n+  return last_frame();\n+}\n+\n+frame JavaThread::carrier_last_frame(RegisterMap* reg_map) {\n+  const ContinuationEntry* entry = vthread_continuation();\n+  guarantee (entry != NULL, \"Not a carrier thread\");\n+  frame f = entry->to_frame();\n+  if (reg_map->process_frames()) {\n+    entry->flush_stack_processing(this);\n+  }\n+  entry->update_register_map(reg_map);\n+  return f.sender(reg_map);\n+}\n+\n+frame JavaThread::platform_thread_last_frame(RegisterMap* reg_map) {\n+  return is_vthread_mounted() ? carrier_last_frame(reg_map) : last_frame();\n+}\n+\n+javaVFrame* JavaThread::last_java_vframe(const frame f, RegisterMap *reg_map) {\n+  assert(reg_map != NULL, \"a map must be given\");\n+  for (vframe* vf = vframe::new_vframe(&f, reg_map, this); vf; vf = vf->sender()) {\n+    if (vf->is_java_frame()) return javaVFrame::cast(vf);\n+  }\n+  return NULL;\n+}\n+\n+oop JavaThread::get_continuation() const {\n+  assert(threadObj() != nullptr, \"must be set\");\n+  return java_lang_Thread::continuation(threadObj());\n+}\n+\n+Klass* JavaThread::security_get_caller_class(int depth) {\n+  ResetNoHandleMark rnhm;\n+  HandleMark hm(Thread::current());\n+\n+  vframeStream vfst(this);\n+  vfst.security_get_caller_frame(depth);\n+  if (!vfst.at_end()) {\n+    return vfst.method()->method_holder();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ java.lang.Thread.sleep support\n+\/\/ Returns true if sleep time elapsed as expected, and false\n+\/\/ if the thread was interrupted.\n+bool JavaThread::sleep(jlong millis) {\n+  assert(this == Thread::current(),  \"thread consistency check\");\n+\n+  ParkEvent * const slp = this->_SleepEvent;\n+  \/\/ Because there can be races with thread interruption sending an unpark()\n+  \/\/ to the event, we explicitly reset it here to avoid an immediate return.\n+  \/\/ The actual interrupt state will be checked before we park().\n+  slp->reset();\n+  \/\/ Thread interruption establishes a happens-before ordering in the\n+  \/\/ Java Memory Model, so we need to ensure we synchronize with the\n+  \/\/ interrupt state.\n+  OrderAccess::fence();\n+\n+  jlong prevtime = os::javaTimeNanos();\n+\n+  for (;;) {\n+    \/\/ interruption has precedence over timing out\n+    if (this->is_interrupted(true)) {\n+      return false;\n+    }\n+\n+    if (millis <= 0) {\n+      return true;\n+    }\n+\n+    {\n+      ThreadBlockInVM tbivm(this);\n+      OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n+      slp->park(millis);\n+    }\n+\n+    \/\/ Update elapsed time tracking\n+    jlong newtime = os::javaTimeNanos();\n+    if (newtime - prevtime < 0) {\n+      \/\/ time moving backwards, should only happen if no monotonic clock\n+      \/\/ not a guarantee() because JVM should not abort on kernel\/glibc bugs\n+      assert(false,\n+             \"unexpected time moving backwards detected in JavaThread::sleep()\");\n+    } else {\n+      millis -= (newtime - prevtime) \/ NANOSECS_PER_MILLISEC;\n+    }\n+    prevtime = newtime;\n+  }\n+}\n+\n+\/\/ Last thread running calls java.lang.Shutdown.shutdown()\n+void JavaThread::invoke_shutdown_hooks() {\n+  HandleMark hm(this);\n+\n+  \/\/ We could get here with a pending exception, if so clear it now or\n+  \/\/ it will cause MetaspaceShared::link_shared_classes to\n+  \/\/ fail for dynamic dump.\n+  if (this->has_pending_exception()) {\n+    this->clear_pending_exception();\n+  }\n+\n+#if INCLUDE_CDS\n+  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n+  \/\/ Same operation is being done in JVM_BeforeHalt for handling the\n+  \/\/ case where the application calls System.exit().\n+  if (DynamicArchive::should_dump_at_vm_exit()) {\n+    DynamicArchive::prepare_for_dump_at_exit();\n+  }\n+#endif\n+\n+  EXCEPTION_MARK;\n+  Klass* shutdown_klass =\n+    SystemDictionary::resolve_or_null(vmSymbols::java_lang_Shutdown(),\n+                                      THREAD);\n+  if (shutdown_klass != NULL) {\n+    \/\/ SystemDictionary::resolve_or_null will return null if there was\n+    \/\/ an exception.  If we cannot load the Shutdown class, just don't\n+    \/\/ call Shutdown.shutdown() at all.  This will mean the shutdown hooks\n+    \/\/ won't be run.  Note that if a shutdown hook was registered,\n+    \/\/ the Shutdown class would have already been loaded\n+    \/\/ (Runtime.addShutdownHook will load it).\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result,\n+                           shutdown_klass,\n+                           vmSymbols::shutdown_name(),\n+                           vmSymbols::void_method_signature(),\n+                           THREAD);\n+  }\n+  CLEAR_PENDING_EXCEPTION;\n+}\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n+\n+\/\/ Helper function to create the java.lang.Thread object for a\n+\/\/ VM-internal thread. The thread will have the given name, and be\n+\/\/ a member of the \"system\" ThreadGroup.\n+Handle JavaThread::create_system_thread_object(const char* name,\n+                                               bool is_visible, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n+\n+  \/\/ Initialize thread_oop to put it into the system threadGroup.\n+  \/\/ This is done by calling the Thread(ThreadGroup group, String name) constructor.\n+  Handle thread_group(THREAD, Universe::system_thread_group());\n+  Handle thread_oop =\n+    JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n+                                      vmSymbols::threadgroup_string_void_signature(),\n+                                      thread_group,\n+                                      string,\n+                                      CHECK_NH);\n+\n+  return thread_oop;\n+}\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadOopHandles(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2061,"deletions":0,"binary":false,"changes":2061,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -1406,1 +1406,1 @@\n-           callee_method->method_holder()->is_reentrant_initialization(current),\n+           callee_method->method_holder()->is_init_thread(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -604,2 +604,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/ActalisCA.java  8224768 generic-all\n-\n@@ -674,1 +672,0 @@\n-javax\/swing\/Popup\/TaskbarPositionTest.java 8065097 macosx-all,linux-all\n@@ -684,1 +681,0 @@\n-javax\/swing\/JTable\/8236907\/LastVisibleRow.java 8284619 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}