{"files":[{"patch":"@@ -24,0 +24,3 @@\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.util.FileUtils;\n+\n@@ -44,0 +47,1 @@\n+ * @library \/test\/lib\n@@ -50,0 +54,1 @@\n+    private static final Random GEN  = RandomFactory.getRandom();\n@@ -58,2 +63,1 @@\n-        Path p = Files.createTempFile(\"test\", \".dat\");\n-        Files.delete(p); \/\/ re-create as sparse\n+        Path p = FileUtils.createSparseTempFile(\"test\", \".dat\");\n@@ -62,1 +66,1 @@\n-        try (FileChannel fc = FileChannel.open(p, CREATE_NEW, SPARSE, WRITE)) {\n+        try (FileChannel fc = FileChannel.open(p, WRITE)) {\n@@ -64,1 +68,0 @@\n-            Random r = new Random(System.nanoTime());\n@@ -66,1 +69,1 @@\n-            r.nextBytes(b);\n+            GEN.nextBytes(b);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n-import java.io.File;\n-import java.io.DataOutputStream;\n-import java.io.FileOutputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterOutputStream;\n@@ -37,1 +36,1 @@\n-import java.io.RandomAccessFile;\n+import java.io.OutputStream;\n@@ -50,0 +49,2 @@\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.util.FileUtils;\n@@ -55,0 +56,1 @@\n+    private static final Random GEN  = RandomFactory.getRandom();\n@@ -57,2 +59,1 @@\n-        Path src = Files.createTempFile(\"src\", \".dat\");\n-        Files.delete(src); \/\/ need CREATE_NEW to make the file sparse\n+        Path src = FileUtils.createSparseTempFile(\"src\", \".dat\");\n@@ -80,2 +81,1 @@\n-        try (FileChannel fc = FileChannel.open(src, StandardOpenOption.CREATE_NEW,\n-                StandardOpenOption.SPARSE, StandardOpenOption.WRITE)) {\n+        try (FileChannel fc = FileChannel.open(src, StandardOpenOption.WRITE)) {\n@@ -83,1 +83,0 @@\n-            Random r = new Random(System.nanoTime());\n@@ -85,1 +84,1 @@\n-            r.nextBytes(b);\n+            GEN.nextBytes(b);\n@@ -134,22 +133,52 @@\n-        File file = File.createTempFile(\"dst\", \".dat\");\n-        file.deleteOnExit();\n-        try (FileChannel srcCh = FileChannel.open(src)) {\n-            \/\/ The FileOutputStream is wrapped so that newChannel() does not\n-            \/\/ return a FileChannelImpl and so make a faster path be taken.\n-            try (DataOutputStream stream =\n-                new DataOutputStream(new FileOutputStream(file))) {\n-                try (WritableByteChannel wbc = Channels.newChannel(stream)) {\n-                    long n;\n-                    if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n-                        throw new RuntimeException(\"Too few bytes transferred: \" +\n-                            n + \" < \" + LENGTH);\n-\n-                    System.out.println(\"Transferred \" + n + \" bytes\");\n-\n-                    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n-                    raf.seek(BASE);\n-                    byte[] b = new byte[EXTRA];\n-                    raf.read(b);\n-                    if (!Arrays.equals(b, expected))\n-                        throw new RuntimeException(\"Unexpected values\");\n-                }\n+        \/\/ transfer src to channel that is not FileChannelImpl\n+        try (FileChannel srcCh = FileChannel.open(src);\n+             ByteArrayOutputStream baos = new ByteArrayOutputStream(EXTRA);\n+             OutputStream os = new SkipBytesStream(baos, BASE);\n+             WritableByteChannel wbc = Channels.newChannel(os)){\n+\n+            long n;\n+            if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n+                throw new RuntimeException(\"Too few bytes transferred: \" +\n+                        n + \" < \" + LENGTH);\n+\n+            System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+            byte[] b = baos.toByteArray();\n+            if (!Arrays.equals(b, expected))\n+                throw new RuntimeException(\"Unexpected values\");\n+        }\n+    }\n+\n+    \/**\n+     * Stream that discards the first bytesToSkip bytes, then passes through\n+     *\/\n+    static class SkipBytesStream extends FilterOutputStream {\n+\n+        private long bytesToSkip;\n+\n+        public SkipBytesStream(OutputStream out, long bytesToSkip) {\n+            super(out);\n+            this.bytesToSkip = bytesToSkip;\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            if (bytesToSkip > 0) {\n+                bytesToSkip--;\n+            } else {\n+                super.write(b);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            \/\/ check copied from FilterOutputStream\n+            if ((off | len | (b.length - (len + off)) | (off + len)) < 0)\n+                throw new IndexOutOfBoundsException();\n+\n+            if (bytesToSkip >= len) {\n+                bytesToSkip -= len;\n+            } else {\n+                int skip = (int)bytesToSkip;\n+                bytesToSkip = 0;\n+                super.write(b, off + skip, len - skip);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer2GPlus.java","additions":62,"deletions":33,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -31,3 +32,0 @@\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -35,1 +33,0 @@\n-import java.io.OutputStreamWriter;\n@@ -37,1 +34,0 @@\n-import java.io.RandomAccessFile;\n@@ -40,0 +36,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -41,1 +40,0 @@\n-import java.nio.file.FileAlreadyExistsException;\n@@ -44,0 +42,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -54,3 +53,2 @@\n-        File source = File.createTempFile(\"blah\", null);\n-        source.delete(); \/\/ need CREATE_NEW to make the file sparse\n-        source.deleteOnExit();\n+        Path source = FileUtils.createSparseTempFile(\"blah\", null);\n+        source.toFile().deleteOnExit();\n@@ -61,2 +59,1 @@\n-        try (FileChannel fc = FileChannel.open(source.toPath(),\n-                StandardOpenOption.CREATE_NEW, StandardOpenOption.SPARSE,\n+        try (FileChannel fc = FileChannel.open(source,\n@@ -70,2 +67,2 @@\n-        File sink = File.createTempFile(\"sink\", null);\n-        sink.deleteOnExit();\n+        Path sink = Files.createTempFile(\"sink\", null);\n+        sink.toFile().deleteOnExit();\n@@ -73,2 +70,4 @@\n-        FileInputStream fis = new FileInputStream(source);\n-        FileChannel sourceChannel = fis.getChannel();\n+        try (FileChannel sourceChannel = FileChannel.open(source,\n+                     StandardOpenOption.READ);\n+             FileChannel sinkChannel = FileChannel.open(sink,\n+                     StandardOpenOption.WRITE)) {\n@@ -76,8 +75,6 @@\n-        RandomAccessFile raf = new RandomAccessFile(sink, \"rw\");\n-        FileChannel sinkChannel = raf.getChannel();\n-\n-        long bytesWritten = sourceChannel.transferTo(testSize -40, 10,\n-                                                     sinkChannel);\n-        if (bytesWritten != 10) {\n-            throw new RuntimeException(\"Transfer test 4 failed \" +\n-                                       bytesWritten);\n+            long bytesWritten = sourceChannel.transferTo(testSize - 40, 10,\n+                    sinkChannel);\n+            if (bytesWritten != 10) {\n+                throw new RuntimeException(\"Transfer test 4 failed \" +\n+                        bytesWritten);\n+            }\n@@ -85,2 +82,0 @@\n-        sourceChannel.close();\n-        sinkChannel.close();\n@@ -88,2 +83,2 @@\n-        source.delete();\n-        sink.delete();\n+        Files.delete(source);\n+        Files.delete(sink);\n@@ -96,2 +91,2 @@\n-        File source = File.createTempFile(\"blech\", null);\n-        source.deleteOnExit();\n+        Path source = Files.createTempFile(\"blech\", null);\n+        source.toFile().deleteOnExit();\n@@ -101,17 +96,2 @@\n-        File sink = null;\n-        FileChannel fc = null;\n-        while (fc == null) {\n-            sink = File.createTempFile(\"sink\", null);\n-            \/\/ re-create as a sparse file\n-            sink.delete();\n-            try {\n-                fc = FileChannel.open(sink.toPath(),\n-                                      StandardOpenOption.CREATE_NEW,\n-                                      StandardOpenOption.WRITE,\n-                                      StandardOpenOption.SPARSE);\n-            } catch (FileAlreadyExistsException ignore) {\n-                \/\/ someone else got it\n-            }\n-        }\n-        sink.deleteOnExit();\n-\n+        Path sink = FileUtils.createSparseTempFile(\"sink\", null);\n+        sink.toFile().deleteOnExit();\n@@ -119,1 +99,1 @@\n-        try {\n+        try (FileChannel fc = FileChannel.open(sink, StandardOpenOption.WRITE)){\n@@ -131,2 +111,0 @@\n-        } finally {\n-            fc.close();\n@@ -136,12 +114,7 @@\n-        FileChannel sourceChannel = new FileInputStream(source).getChannel();\n-        try {\n-            FileChannel sinkChannel = new RandomAccessFile(sink, \"rw\").getChannel();\n-            try {\n-                long bytesWritten = sinkChannel.transferFrom(sourceChannel,\n-                                                             testSize - 40, 10);\n-                if (bytesWritten != 10) {\n-                    throw new RuntimeException(\"Transfer test 5 failed \" +\n-                                               bytesWritten);\n-                }\n-            } finally {\n-                sinkChannel.close();\n+        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);\n+             FileChannel sinkChannel = FileChannel.open(sink, StandardOpenOption.WRITE)) {\n+            long bytesWritten = sinkChannel.transferFrom(sourceChannel,\n+                    testSize - 40, 10);\n+            if (bytesWritten != 10) {\n+                throw new RuntimeException(\"Transfer test 5 failed \" +\n+                        bytesWritten);\n@@ -149,2 +122,0 @@\n-        } finally {\n-            sourceChannel.close();\n@@ -153,2 +124,2 @@\n-        source.delete();\n-        sink.delete();\n+        Files.delete(source);\n+        Files.delete(sink);\n@@ -160,9 +131,7 @@\n-    private static void initTestFile(File blah, long size) throws Exception {\n-        if (blah.exists())\n-            blah.delete();\n-        FileOutputStream fos = new FileOutputStream(blah);\n-        BufferedWriter awriter\n-            = new BufferedWriter(new OutputStreamWriter(fos, \"8859_1\"));\n-\n-        for(int i=0; i<size; i++) {\n-            awriter.write(\"e\");\n+    private static void initTestFile(Path blah, long size) throws Exception {\n+        try (BufferedWriter awriter = Files.newBufferedWriter(blah,\n+                StandardCharsets.ISO_8859_1)) {\n+\n+            for (int i = 0; i < size; i++) {\n+                awriter.write(\"e\");\n+            }\n@@ -170,2 +139,0 @@\n-        awriter.flush();\n-        awriter.close();\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer4GBFile.java","additions":44,"deletions":77,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -30,1 +31,0 @@\n-import java.io.File;\n@@ -39,0 +39,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,0 +44,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -55,4 +58,2 @@\n-\n-        File file = File.createTempFile(\"source\", null);\n-        file.delete(); \/\/ need CREATE_NEW to make the file sparse\n-        file.deleteOnExit();\n+        Path file = FileUtils.createSparseTempFile(\"source\", null);\n+        file.toFile().deleteOnExit();\n@@ -62,2 +63,1 @@\n-        FileChannel fc = FileChannel.open(file.toPath(),\n-                StandardOpenOption.CREATE_NEW, StandardOpenOption.SPARSE,\n+        FileChannel fc = FileChannel.open(file,\n@@ -153,1 +153,1 @@\n-            file.delete();\n+            Files.delete(file);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferTo6GBFile.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -39,0 +40,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -428,0 +430,11 @@\n+\n+    public static Path createSparseTempFile(String prefix, String suffix) throws IOException {\n+        Path file = Files.createTempFile(prefix, suffix);\n+        Files.delete(file); \/\/ need CREATE_NEW to make the file sparse\n+\n+        FileChannel fc = FileChannel.open(file,\n+                StandardOpenOption.CREATE_NEW, StandardOpenOption.SPARSE,\n+                StandardOpenOption.WRITE);\n+        fc.close();\n+        return file;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}