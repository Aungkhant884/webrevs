{"files":[{"patch":"@@ -24,0 +24,3 @@\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.util.FileUtils;\n+\n@@ -27,1 +30,0 @@\n-import java.io.File;\n@@ -31,0 +33,1 @@\n+import java.nio.file.Files;\n@@ -32,0 +35,3 @@\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n@@ -41,1 +47,2 @@\n- * @run main\/othervm\/timeout=240 LargeMapTest\n+ * @library \/test\/lib\n+ * @run main\/othervm LargeMapTest\n@@ -44,4 +51,4 @@\n-    private static final String FILE = \"test.dat\";\n-    private static final long LENGTH = 8000000000L;\n-    private static final long OFFSET = 3704800000L;\n-    private static final int  BUFSIZ = 100000;\n+    private static final long LENGTH = (1L << 32) + 512;\n+    private static final int  EXTRA  = 1024;\n+    private static final long BASE   = LENGTH - EXTRA;\n+    private static final Random GEN  = RandomFactory.getRandom();\n@@ -54,1 +61,3 @@\n-        Path p = Path.of(FILE);\n+        System.out.println(\"  Writing large file...\");\n+        long t0 = System.nanoTime();\n+        Path p = FileUtils.createSparseTempFile(\"test\", \".dat\");\n@@ -56,3 +65,10 @@\n-        try (FileChannel fc = FileChannel.open(p, CREATE, WRITE)) {\n-            fc.position(LENGTH - 1);\n-            fc.write(ByteBuffer.wrap(new byte[] {27}));\n+        ByteBuffer bb;\n+        try (FileChannel fc = FileChannel.open(p, WRITE)) {\n+            fc.position(BASE);\n+            byte[] b = new byte[EXTRA];\n+            GEN.nextBytes(b);\n+            bb = ByteBuffer.wrap(b);\n+            fc.write(bb);\n+            long t1 = System.nanoTime();\n+            System.out.printf(\"  Wrote large file in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n@@ -60,0 +76,1 @@\n+        bb.rewind();\n@@ -61,5 +78,1 @@\n-        long offset = OFFSET;\n-        ByteBuffer bb = ByteBuffer.allocateDirect(BUFSIZ);\n-\n-        try (FileChannel fc = FileChannel.open(p, READ, WRITE);) {\n-            MemorySegment mbb = MemorySegment.ofBuffer(bb);\n+        try (FileChannel fc = FileChannel.open(p, READ, WRITE)) {\n@@ -69,8 +82,3 @@\n-\n-            final int interval = BUFSIZ*1000;\n-            while (offset < LENGTH) {\n-                if (offset % interval == 0)\n-                    System.out.println(\"offset: \" + offset);\n-                MemorySegment target = mappedMemorySegment.asSlice(offset, BUFSIZ);\n-                offset = offset + BUFSIZ;\n-                target.copyFrom(mbb);\n+            MemorySegment target = mappedMemorySegment.asSlice(BASE, EXTRA);\n+            if (!target.asByteBuffer().equals(bb)) {\n+                throw new RuntimeException(\"Expected buffers to be equal\");\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -59,0 +60,1 @@\n+        long t0 = System.nanoTime();\n@@ -60,0 +62,4 @@\n+        long t1 = System.nanoTime();\n+        out.printf(\"Test file %s initialized in %d ns (%d ms) %n\",\n+                blah, t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+        t0 = t1;\n@@ -61,1 +67,0 @@\n-            out.println(\"Test file \" + blah + \" initialized\");\n@@ -63,1 +68,4 @@\n-            out.println(\"Zero size: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"Zero size: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+            t0 = t1;\n@@ -65,1 +73,4 @@\n-            out.println(\"Read: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"Read: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+            t0 = t1;\n@@ -67,1 +78,4 @@\n-            out.println(\"Write: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"Write: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+            t0 = t1;\n@@ -69,1 +83,4 @@\n-            out.println(\"High offset: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"High offset: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+            t0 = t1;\n@@ -71,1 +88,4 @@\n-            out.println(\"Force: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"Force: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+            t0 = t1;\n@@ -73,1 +93,3 @@\n-            out.println(\"Exceptions: OK\");\n+            t1 = System.nanoTime();\n+            out.printf(\"Exceptions: done in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n@@ -198,15 +220,11 @@\n-        for (int x=0; x<50; x++) {\n-            try (RandomAccessFile raf = new RandomAccessFile(blah, \"rw\")) {\n-                FileChannel fc = raf.getChannel();\n-                final int BLOCK_SIZE = 64;\n-                final int BLOCK_COUNT = (4096 * 2)\/ BLOCK_SIZE;\n-                int offset = 0;\n-                MappedByteBuffer b = fc.map(MapMode.READ_WRITE,\n-                                            0, BLOCK_SIZE * (BLOCK_COUNT + 1));\n-\n-                for (int blocks = 0; blocks < BLOCK_COUNT; blocks++) {\n-                    for (int i = 0; i < BLOCK_SIZE; i++) {\n-                        b.put(offset + i, (byte)('0' + i));\n-                    }\n-                    b.force(offset, BLOCK_SIZE);\n-                    offset += BLOCK_SIZE;\n+        try (RandomAccessFile raf = new RandomAccessFile(blah, \"rw\")) {\n+            FileChannel fc = raf.getChannel();\n+            final int BLOCK_SIZE = 64;\n+            final int BLOCK_COUNT = (4096 * 2)\/ BLOCK_SIZE;\n+            int offset = 0;\n+            MappedByteBuffer b = fc.map(MapMode.READ_WRITE,\n+                                        0, BLOCK_SIZE * (BLOCK_COUNT + 1));\n+\n+            for (int blocks = 0; blocks < BLOCK_COUNT; blocks++) {\n+                for (int i = 0; i < BLOCK_SIZE; i++) {\n+                    b.put(offset + i, (byte)('0' + i));\n@@ -214,0 +232,3 @@\n+                b.force(offset, BLOCK_SIZE);\n+                offset += BLOCK_SIZE;\n+            }\n@@ -215,10 +236,10 @@\n-                Exception exc = null;\n-                try {\n-                    \/\/ start and end are out of range\n-                    b.force(offset + BLOCK_SIZE, BLOCK_SIZE);\n-                } catch (IndexOutOfBoundsException e) {\n-                    exc = e;\n-                }\n-                if (exc == null) {\n-                    throw new RuntimeException(\"expected Exception for force beyond buffer extent\");\n-                }\n+            Exception exc = null;\n+            try {\n+                \/\/ start and end are out of range\n+                b.force(offset + BLOCK_SIZE, BLOCK_SIZE);\n+            } catch (IndexOutOfBoundsException e) {\n+                exc = e;\n+            }\n+            if (exc == null) {\n+                throw new RuntimeException(\"expected Exception for force beyond buffer extent\");\n+            }\n@@ -226,10 +247,9 @@\n-                exc = null;\n-                try {\n-                    \/\/ start is in range but end is out of range\n-                    b.force(offset, 2 * BLOCK_SIZE);\n-                } catch (IndexOutOfBoundsException e) {\n-                    exc = e;\n-                }\n-                if (exc == null) {\n-                    throw new RuntimeException(\"expected Exception for force beyond write limit\");\n-                }\n+            exc = null;\n+            try {\n+                \/\/ start is in range but end is out of range\n+                b.force(offset, 2 * BLOCK_SIZE);\n+            } catch (IndexOutOfBoundsException e) {\n+                exc = e;\n+            }\n+            if (exc == null) {\n+                throw new RuntimeException(\"expected Exception for force beyond write limit\");\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapTest.java","additions":63,"deletions":43,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n-import java.io.File;\n-import java.io.DataOutputStream;\n-import java.io.FileOutputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterOutputStream;\n@@ -37,1 +36,1 @@\n-import java.io.RandomAccessFile;\n+import java.io.OutputStream;\n@@ -47,0 +46,2 @@\n+import java.util.concurrent.TimeUnit;\n+\n@@ -48,0 +49,2 @@\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.util.FileUtils;\n@@ -53,0 +56,1 @@\n+    private static final Random GEN  = RandomFactory.getRandom();\n@@ -55,1 +59,1 @@\n-        Path src = Files.createTempFile(\"src\", \".dat\");\n+        Path src = FileUtils.createSparseTempFile(\"src\", \".dat\");\n@@ -57,0 +61,1 @@\n+        long t0 = System.nanoTime();\n@@ -58,0 +63,4 @@\n+        long t1 = System.nanoTime();\n+        System.out.printf(\"  Wrote large file in %d ns (%d ms) %n\",\n+                t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+        t0 = t1;\n@@ -59,0 +68,4 @@\n+        t1 = System.nanoTime();\n+        System.out.printf(\"  Copied to file channel in %d ns (%d ms) %n\",\n+                t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+        t0 = t1;\n@@ -60,0 +73,3 @@\n+        t1 = System.nanoTime();\n+        System.out.printf(\"  Copied to byte channel in %d ns (%d ms) %n\",\n+                t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n@@ -65,8 +81,7 @@\n-        RandomAccessFile raf = new RandomAccessFile(src.toString(), \"rw\");\n-        raf.setLength(LENGTH);\n-        raf.seek(BASE);\n-        Random r = new Random(System.nanoTime());\n-        byte[] b = new byte[EXTRA];\n-        r.nextBytes(b);\n-        raf.write(b);\n-        return b;\n+        try (FileChannel fc = FileChannel.open(src, StandardOpenOption.WRITE)) {\n+            fc.position(BASE);\n+            byte[] b = new byte[EXTRA];\n+            GEN.nextBytes(b);\n+            fc.write(ByteBuffer.wrap(b));\n+            return b;\n+        }\n@@ -118,22 +133,52 @@\n-        File file = File.createTempFile(\"dst\", \".dat\");\n-        file.deleteOnExit();\n-        try (FileChannel srcCh = FileChannel.open(src)) {\n-            \/\/ The FileOutputStream is wrapped so that newChannel() does not\n-            \/\/ return a FileChannelImpl and so make a faster path be taken.\n-            try (DataOutputStream stream =\n-                new DataOutputStream(new FileOutputStream(file))) {\n-                try (WritableByteChannel wbc = Channels.newChannel(stream)) {\n-                    long n;\n-                    if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n-                        throw new RuntimeException(\"Too few bytes transferred: \" +\n-                            n + \" < \" + LENGTH);\n-\n-                    System.out.println(\"Transferred \" + n + \" bytes\");\n-\n-                    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n-                    raf.seek(BASE);\n-                    byte[] b = new byte[EXTRA];\n-                    raf.read(b);\n-                    if (!Arrays.equals(b, expected))\n-                        throw new RuntimeException(\"Unexpected values\");\n-                }\n+        \/\/ transfer src to channel that is not FileChannelImpl\n+        try (FileChannel srcCh = FileChannel.open(src);\n+             ByteArrayOutputStream baos = new ByteArrayOutputStream(EXTRA);\n+             OutputStream os = new SkipBytesStream(baos, BASE);\n+             WritableByteChannel wbc = Channels.newChannel(os)){\n+\n+            long n;\n+            if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n+                throw new RuntimeException(\"Too few bytes transferred: \" +\n+                        n + \" < \" + LENGTH);\n+\n+            System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+            byte[] b = baos.toByteArray();\n+            if (!Arrays.equals(b, expected))\n+                throw new RuntimeException(\"Unexpected values\");\n+        }\n+    }\n+\n+    \/**\n+     * Stream that discards the first bytesToSkip bytes, then passes through\n+     *\/\n+    static class SkipBytesStream extends FilterOutputStream {\n+\n+        private long bytesToSkip;\n+\n+        public SkipBytesStream(OutputStream out, long bytesToSkip) {\n+            super(out);\n+            this.bytesToSkip = bytesToSkip;\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            if (bytesToSkip > 0) {\n+                bytesToSkip--;\n+            } else {\n+                super.write(b);\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            \/\/ check copied from FilterOutputStream\n+            if ((off | len | (b.length - (len + off)) | (off + len)) < 0)\n+                throw new IndexOutOfBoundsException();\n+\n+            if (bytesToSkip >= len) {\n+                bytesToSkip -= len;\n+            } else {\n+                int skip = (int)bytesToSkip;\n+                bytesToSkip = 0;\n+                super.write(b, off + skip, len - skip);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer2GPlus.java","additions":81,"deletions":36,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -31,3 +32,0 @@\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -35,1 +33,0 @@\n-import java.io.OutputStreamWriter;\n@@ -37,1 +34,0 @@\n-import java.io.RandomAccessFile;\n@@ -40,0 +36,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -41,1 +40,0 @@\n-import java.nio.file.FileAlreadyExistsException;\n@@ -44,0 +42,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -54,2 +53,2 @@\n-        File source = File.createTempFile(\"blah\", null);\n-        source.deleteOnExit();\n+        Path source = FileUtils.createSparseTempFile(\"blah\", null);\n+        source.toFile().deleteOnExit();\n@@ -57,3 +56,1 @@\n-        initTestFile(source, 10);\n-        RandomAccessFile raf = new RandomAccessFile(source, \"rw\");\n-        FileChannel fc = raf.getChannel();\n+\n@@ -62,10 +59,7 @@\n-        fc.write(ByteBuffer.wrap(\"Use the source!\".getBytes()), testSize - 40);\n-        long t1 = System.nanoTime();\n-        out.printf(\"  Wrote large file in %d ns (%d ms) %n\",\n-            t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n-\n-        fc.close();\n-        raf.close();\n-\n-        File sink = File.createTempFile(\"sink\", null);\n-        sink.deleteOnExit();\n+        try (FileChannel fc = FileChannel.open(source,\n+                StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            fc.write(ByteBuffer.wrap(\"Use the source!\".getBytes()), testSize - 40);\n+            long t1 = System.nanoTime();\n+            out.printf(\"  Wrote large file in %d ns (%d ms) %n\",\n+                    t1 - t0, TimeUnit.NANOSECONDS.toMillis(t1 - t0));\n+        }\n@@ -73,2 +67,2 @@\n-        FileInputStream fis = new FileInputStream(source);\n-        FileChannel sourceChannel = fis.getChannel();\n+        Path sink = Files.createTempFile(\"sink\", null);\n+        sink.toFile().deleteOnExit();\n@@ -76,2 +70,4 @@\n-        raf = new RandomAccessFile(sink, \"rw\");\n-        FileChannel sinkChannel = raf.getChannel();\n+        try (FileChannel sourceChannel = FileChannel.open(source,\n+                     StandardOpenOption.READ);\n+             FileChannel sinkChannel = FileChannel.open(sink,\n+                     StandardOpenOption.WRITE)) {\n@@ -79,5 +75,6 @@\n-        long bytesWritten = sourceChannel.transferTo(testSize -40, 10,\n-                                                     sinkChannel);\n-        if (bytesWritten != 10) {\n-            throw new RuntimeException(\"Transfer test 4 failed \" +\n-                                       bytesWritten);\n+            long bytesWritten = sourceChannel.transferTo(testSize - 40, 10,\n+                    sinkChannel);\n+            if (bytesWritten != 10) {\n+                throw new RuntimeException(\"Transfer test 4 failed \" +\n+                        bytesWritten);\n+            }\n@@ -85,2 +82,0 @@\n-        sourceChannel.close();\n-        sinkChannel.close();\n@@ -88,2 +83,2 @@\n-        source.delete();\n-        sink.delete();\n+        Files.delete(source);\n+        Files.delete(sink);\n@@ -96,2 +91,2 @@\n-        File source = File.createTempFile(\"blech\", null);\n-        source.deleteOnExit();\n+        Path source = Files.createTempFile(\"blech\", null);\n+        source.toFile().deleteOnExit();\n@@ -101,17 +96,2 @@\n-        File sink = null;\n-        FileChannel fc = null;\n-        while (fc == null) {\n-            sink = File.createTempFile(\"sink\", null);\n-            \/\/ re-create as a sparse file\n-            sink.delete();\n-            try {\n-                fc = FileChannel.open(sink.toPath(),\n-                                      StandardOpenOption.CREATE_NEW,\n-                                      StandardOpenOption.WRITE,\n-                                      StandardOpenOption.SPARSE);\n-            } catch (FileAlreadyExistsException ignore) {\n-                \/\/ someone else got it\n-            }\n-        }\n-        sink.deleteOnExit();\n-\n+        Path sink = FileUtils.createSparseTempFile(\"sink\", null);\n+        sink.toFile().deleteOnExit();\n@@ -119,1 +99,1 @@\n-        try {\n+        try (FileChannel fc = FileChannel.open(sink, StandardOpenOption.WRITE)){\n@@ -131,2 +111,0 @@\n-        } finally {\n-            fc.close();\n@@ -136,12 +114,7 @@\n-        FileChannel sourceChannel = new FileInputStream(source).getChannel();\n-        try {\n-            FileChannel sinkChannel = new RandomAccessFile(sink, \"rw\").getChannel();\n-            try {\n-                long bytesWritten = sinkChannel.transferFrom(sourceChannel,\n-                                                             testSize - 40, 10);\n-                if (bytesWritten != 10) {\n-                    throw new RuntimeException(\"Transfer test 5 failed \" +\n-                                               bytesWritten);\n-                }\n-            } finally {\n-                sinkChannel.close();\n+        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);\n+             FileChannel sinkChannel = FileChannel.open(sink, StandardOpenOption.WRITE)) {\n+            long bytesWritten = sinkChannel.transferFrom(sourceChannel,\n+                    testSize - 40, 10);\n+            if (bytesWritten != 10) {\n+                throw new RuntimeException(\"Transfer test 5 failed \" +\n+                        bytesWritten);\n@@ -149,2 +122,0 @@\n-        } finally {\n-            sourceChannel.close();\n@@ -153,2 +124,2 @@\n-        source.delete();\n-        sink.delete();\n+        Files.delete(source);\n+        Files.delete(sink);\n@@ -160,9 +131,7 @@\n-    private static void initTestFile(File blah, long size) throws Exception {\n-        if (blah.exists())\n-            blah.delete();\n-        FileOutputStream fos = new FileOutputStream(blah);\n-        BufferedWriter awriter\n-            = new BufferedWriter(new OutputStreamWriter(fos, \"8859_1\"));\n-\n-        for(int i=0; i<size; i++) {\n-            awriter.write(\"e\");\n+    private static void initTestFile(Path blah, long size) throws Exception {\n+        try (BufferedWriter awriter = Files.newBufferedWriter(blah,\n+                StandardCharsets.ISO_8859_1)) {\n+\n+            for (int i = 0; i < size; i++) {\n+                awriter.write(\"e\");\n+            }\n@@ -170,2 +139,0 @@\n-        awriter.flush();\n-        awriter.close();\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer4GBFile.java","additions":51,"deletions":84,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -30,1 +31,0 @@\n-import java.io.File;\n@@ -33,1 +33,0 @@\n-import java.io.RandomAccessFile;\n@@ -40,0 +39,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -42,0 +44,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -55,6 +58,2 @@\n-\n-        File file = File.createTempFile(\"source\", null);\n-        file.deleteOnExit();\n-\n-        RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n-        FileChannel fc = raf.getChannel();\n+        Path file = FileUtils.createSparseTempFile(\"source\", null);\n+        file.toFile().deleteOnExit();\n@@ -64,0 +63,2 @@\n+        FileChannel fc = FileChannel.open(file,\n+                StandardOpenOption.READ, StandardOpenOption.WRITE);\n@@ -152,1 +153,1 @@\n-            file.delete();\n+            Files.delete(file);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferTo6GBFile.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -39,0 +40,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -428,0 +430,11 @@\n+\n+    public static Path createSparseTempFile(String prefix, String suffix) throws IOException {\n+        Path file = Files.createTempFile(prefix, suffix);\n+        Files.delete(file); \/\/ need CREATE_NEW to make the file sparse\n+\n+        FileChannel fc = FileChannel.open(file,\n+                StandardOpenOption.CREATE_NEW, StandardOpenOption.SPARSE,\n+                StandardOpenOption.WRITE);\n+        fc.close();\n+        return file;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}