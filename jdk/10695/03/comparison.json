{"files":[{"patch":"@@ -368,1 +368,1 @@\n-  C->print_method(CompilerPhaseType::PHASE_MACHANALYSIS, 4);\n+  C->print_method(CompilerPhaseType::PHASE_MACH_ANALYSIS, 4);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n+  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n+  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n+  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n@@ -39,2 +43,0 @@\n-  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n-  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n@@ -42,0 +44,7 @@\n+  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n+  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n+  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n@@ -50,0 +59,2 @@\n+  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n+  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n@@ -51,7 +62,0 @@\n-  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n-  flags(FINAL_CODE,                   \"Final Code\") \\\n-  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n-  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n-  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n-  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n-  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n@@ -60,8 +64,3 @@\n-  flags(MACHANALYSIS,                 \"After mach analysis\") \\\n-  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n-  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n-  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n-  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n-  flags(CALL_CATCH_CLEANUP,           \"Call catch cleanup\") \\\n-  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n-  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n+  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n+  flags(MACH_ANALYSIS,                \"After mach analysis\") \\\n+  flags(FINAL_CODE,                   \"Final Code\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    @IR(counts = {IRNode.Max_I, \"1\",\n+    @IR(counts = {IRNode.MAX_I, \"1\",\n@@ -81,1 +81,1 @@\n-    @IR(counts = {IRNode.Min_I, \"1\",\n+    @IR(counts = {IRNode.MIN_I, \"1\",\n@@ -92,1 +92,1 @@\n-    @IR(failOn = {IRNode.Max_I})\n+    @IR(failOn = {IRNode.MAX_I})\n@@ -100,1 +100,1 @@\n-    @IR(failOn = {IRNode.Min_I})\n+    @IR(failOn = {IRNode.MIN_I})\n@@ -109,1 +109,1 @@\n-    @IR(failOn = {IRNode.Max_I})\n+    @IR(failOn = {IRNode.MAX_I})\n@@ -115,1 +115,1 @@\n-    @IR(failOn = {IRNode.Min_I})\n+    @IR(failOn = {IRNode.MIN_I})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MaxMinINodeIdealizationTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -67,1 +67,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -92,1 +92,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -117,1 +117,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -147,1 +147,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -176,1 +176,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n@@ -206,1 +206,1 @@\n-    @IR(counts = { IRNode.LONGCOUNTEDLOOP, \"1\", IRNode.IF, \"1\" })\n+    @IR(counts = {IRNode.LONG_COUNTED_LOOP, \"1\", IRNode.IF, \"1\" })\n@@ -234,1 +234,1 @@\n-    @IR(counts = { IRNode.LONGCOUNTEDLOOP, \"1\", IRNode.IF, \"1\" })\n+    @IR(counts = {IRNode.LONG_COUNTED_LOOP, \"1\", IRNode.IF, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestCountedLoopPhiValue.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,4 +45,4 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = { IRNode.SAFEPOINT, IRNode.OUTERSTRIPMINEDLOOP })\n-    @IR(applyIf = { \"LoopStripMiningIter\", \"1\" }, counts = { IRNode.SAFEPOINT, \"1\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n-    @IR(applyIf = { \"LoopStripMiningIter\", \"> 1\" }, counts = { IRNode.SAFEPOINT, \"1\", IRNode.OUTERSTRIPMINEDLOOP, \"1\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = { IRNode.SAFEPOINT, IRNode.OUTER_STRIP_MINED_LOOP})\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"1\" }, counts = { IRNode.SAFEPOINT, \"1\" }, failOn = { IRNode.OUTER_STRIP_MINED_LOOP})\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"> 1\" }, counts = {IRNode.SAFEPOINT, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestCountedLoopSafepoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Objects;\n@@ -45,1 +44,1 @@\n-    @IR(applyIf = { \"DuplicateBackedge\", \"true\" }, counts = { IRNode.LOOP, \"1\", IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(applyIf = { \"DuplicateBackedge\", \"true\" }, counts = {IRNode.LOOP, \"1\", IRNode.COUNTED_LOOP, \"1\" })\n@@ -47,1 +46,1 @@\n-    @IR(applyIf = { \"DuplicateBackedge\", \"false\" }, failOn = { IRNode.COUNTEDLOOP })\n+    @IR(applyIf = { \"DuplicateBackedge\", \"false\" }, failOn = { IRNode.COUNTED_LOOP})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDuplicateBackedge.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -80,1 +80,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -86,1 +86,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -92,1 +92,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -98,1 +98,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -104,1 +104,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -110,1 +110,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -116,1 +116,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -122,1 +122,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -128,1 +128,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -134,1 +134,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -140,1 +140,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -146,1 +146,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -152,1 +152,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -158,1 +158,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n@@ -164,1 +164,1 @@\n-    @IR(counts = {IRNode.CMOVEI, \"1\"})\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -56,1 +56,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -66,1 +66,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -78,2 +78,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -87,2 +87,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -98,2 +98,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -110,2 +110,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -119,2 +119,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n@@ -130,2 +130,2 @@\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = { IRNode.COUNTEDLOOP, \"1\" })\n-    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = { IRNode.COUNTEDLOOP, IRNode.LOOP })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"0\" }, counts = {IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(applyIf = { \"LoopUnrollLimit\", \"> 0\" }, failOn = {IRNode.COUNTED_LOOP, IRNode.LOOP })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFewIterationsCountedLoop.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -48,1 +48,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -69,1 +69,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -87,1 +87,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -105,1 +105,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -121,1 +121,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -138,1 +138,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -155,1 +155,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -171,1 +171,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -187,1 +187,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -203,1 +203,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -219,1 +219,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n@@ -235,1 +235,1 @@\n-    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    @IR(failOn = { IRNode.COUNTED_LOOP})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.test.lib.Utils;\n-import java.util.Random;\n@@ -60,1 +58,1 @@\n-    @IR(counts = { IRNode.COUNTEDLOOP, \"2\" })\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSkeletonPredicates.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = {IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n@@ -71,2 +71,2 @@\n-    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n-    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = {IRNode.COUNTED_LOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTER_STRIP_MINED_LOOP})\n@@ -100,1 +100,1 @@\n-    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = {IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestStripMiningDropsSafepoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static compiler.lib.ir_framework.IRNode.*;\n+\n@@ -37,4 +39,0 @@\n-    private static final String CMP_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n-    private static final String CMPU_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Cmp(U|UL)\" + \".*)+(\\\\s){2}===.*)\";\n-    private static final String ADD_REGEX = \"(\\\\d+(\\\\s){2}(\" + \"Add(I|L)\" + \".*)+(\\\\s){2}===.*)\";\n-\n@@ -87,2 +85,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -94,2 +92,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -101,2 +99,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -108,2 +106,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -115,2 +113,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -122,2 +120,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -153,2 +151,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -160,2 +158,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -167,2 +165,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -174,2 +172,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -181,2 +179,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -188,2 +186,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_I, ADD_I})\n+    @IR(counts = {CMP_U, \"1\"})\n@@ -217,2 +215,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -224,2 +222,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -231,2 +229,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -238,2 +236,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -245,2 +243,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -252,2 +250,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -283,2 +281,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -290,2 +288,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -297,2 +295,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -304,2 +302,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -311,2 +309,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n@@ -318,2 +316,2 @@\n-    @IR(failOn = {CMP_REGEX, ADD_REGEX})\n-    @IR(counts = {CMPU_REGEX, \"1\"})\n+    @IR(failOn = {CMP_L, ADD_L})\n+    @IR(counts = {CMP_UL, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestUnsignedComparison.java","additions":51,"deletions":53,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -106,1 +106,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -114,1 +114,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -122,1 +122,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -130,1 +130,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -138,1 +138,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -146,1 +146,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -154,1 +154,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -162,1 +162,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n@@ -170,1 +170,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVE_VD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.CALL})\n@@ -52,1 +52,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.CALL})\n@@ -61,1 +61,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.TRAP})\n@@ -71,1 +71,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.TRAP})\n@@ -82,1 +82,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.TRAP})\n@@ -110,1 +110,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.TRAP})\n@@ -122,1 +122,1 @@\n-    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTED_LOOP, IRNode.COUNTED_LOOP_MAIN, IRNode.TRAP})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/loopOpts\/LoopIdealizationTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @IR(counts = {\"RShiftI\", \" > 0 \", \"AndI\", \" > 0\"})\n+    @IR(counts = {IRNode.RSHIFT_I, \" > 0 \", IRNode.AND_I, \" > 0\"})\n@@ -70,1 +70,1 @@\n-    @IR(counts = {\"URShiftI\", \" > 0 \"})\n+    @IR(counts = {IRNode.URSHIFT_I, \" > 0 \"})\n@@ -85,1 +85,1 @@\n-    @IR(counts = {\"CompressBits\", \" > 0 \", \"AndI\" , \" > 0 \"})\n+    @IR(counts = {IRNode.COMPRESS_BITS, \" > 0 \", IRNode.AND_I , \" > 0 \"})\n@@ -100,1 +100,1 @@\n-    @IR(counts = {\"RShiftL\", \" > 0 \", \"AndL\", \" > 0\"})\n+    @IR(counts = {IRNode.RSHIFT_L, \" > 0 \", IRNode.AND_L, \" > 0\"})\n@@ -115,1 +115,1 @@\n-    @IR(counts = {\"URShiftL\", \" > 0 \"})\n+    @IR(counts = {IRNode.URSHIFT_L, \" > 0 \"})\n@@ -130,1 +130,1 @@\n-    @IR(counts = {\"CompressBits\", \" > 0 \", \"AndL\" , \" > 0 \"})\n+    @IR(counts = {IRNode.COMPRESS_BITS, \" > 0 \", IRNode.AND_L , \" > 0 \"})\n@@ -145,1 +145,1 @@\n-    @IR(counts = {\"LShiftI\", \" > 0 \", \"AndI\", \" > 0\"})\n+    @IR(counts = {IRNode.LSHIFT_I, \" > 0 \", IRNode.AND_I, \" > 0\"})\n@@ -160,1 +160,1 @@\n-    @IR(counts = {\"LShiftI\", \" > 0 \"})\n+    @IR(counts = {IRNode.LSHIFT_I, \" > 0 \"})\n@@ -175,1 +175,1 @@\n-    @IR(counts = {\"AndI\" , \" > 0 \"})\n+    @IR(counts = {IRNode.AND_I , \" > 0 \"})\n@@ -190,1 +190,1 @@\n-    @IR(counts = {\"LShiftL\", \" > 0 \", \"AndL\", \" > 0\"})\n+    @IR(counts = {IRNode.LSHIFT_L, \" > 0 \", IRNode.AND_L, \" > 0\"})\n@@ -205,1 +205,1 @@\n-    @IR(counts = {\"LShiftL\", \" > 0 \"})\n+    @IR(counts = {IRNode.LSHIFT_L, \" > 0 \"})\n@@ -220,1 +220,1 @@\n-    @IR(counts = {\"AndL\" , \" > 0 \"})\n+    @IR(counts = {IRNode.AND_L , \" > 0 \"})\n@@ -237,1 +237,1 @@\n-    @IR(counts = {\"CompressBits\", \" > 0 \"})\n+    @IR(counts = {IRNode.COMPRESS_BITS, \" > 0 \"})\n@@ -253,1 +253,1 @@\n-    @IR(counts = {\"CompressBits\", \" > 0 \"})\n+    @IR(counts = {IRNode.COMPRESS_BITS, \" > 0 \"})\n@@ -269,1 +269,1 @@\n-    @IR(counts = {\"ExpandBits\", \" > 0 \"})\n+    @IR(counts = {IRNode.EXPAND_BITS, \" > 0 \"})\n@@ -285,1 +285,1 @@\n-    @IR(counts = {\"ExpandBits\", \" > 0 \"})\n+    @IR(counts = {IRNode.EXPAND_BITS, \" > 0 \"})\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestBitShuffleOpers.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    @IR(counts = {\"IsFiniteD\", \">= 1\"}) \/\/ At least one IsFiniteD node is generated if intrinsic is used\n+    @IR(counts = {IRNode.IS_FINITE_D, \">= 1\"}) \/\/ At least one IsFiniteD node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleIsFinite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    @IR(counts = {\"IsInfiniteD\", \">= 1\"}) \/\/ At least one IsInfiniteD node is generated if intrinsic is used\n+    @IR(counts = {IRNode.IS_INFINITE_D, \">= 1\"}) \/\/ At least one IsInfiniteD node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestDoubleIsInfinite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    @IR(counts = {\"IsFiniteF\", \">= 1\"}) \/\/ At least one IsFiniteF node is generated if intrinsic is used\n+    @IR(counts = {IRNode.IS_FINITE_F\", \">= 1\"}) \/\/ At least one IsFiniteF node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatIsFinite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    @IR(counts = {\"IsInfiniteF\", \">= 1\"}) \/\/ At least one IsInfiniteF node is generated if intrinsic is used\n+    @IR(counts = {IRNode.IS_INFINITE_F, \">= 1\"}) \/\/ At least one IsInfiniteF node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestFloatIsInfinite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    @IR(counts = {\"UDivI\", \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_I, \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n@@ -90,1 +90,1 @@\n-    @IR(counts = {\"UModI\", \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UMOD_I, \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n@@ -105,1 +105,1 @@\n-    @IR(counts = {\"UDivModI\", \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_MOD_I, \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    @IR(counts = {\"UDivL\", \">= 1\"}) \/\/ Atleast one UDivL node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_L, \">= 1\"}) \/\/ At least one UDivL node is generated if intrinsic is used\n@@ -128,1 +128,1 @@\n-    @IR(counts = {\"UModL\", \">= 1\"}) \/\/ Atleast one UModL node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UMOD_L, \">= 1\"}) \/\/ At least one UModL node is generated if intrinsic is used\n@@ -143,1 +143,1 @@\n-    @IR(counts = {\"UDivModL\", \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_MOD_L, \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * This enum represents all available compile phases on which an IR matching can be done. There is a 1:1 mapping\n+ * between IGV phases as specified in phasetype.hpp.  Compile phases which are normally not emitted by C2 like FAILURE\n+ * or DEBUG are not listed. This enum should be kept in sync with phasetye.hpp.\n+ *\n+ * <p>\n+ * There are two additional compile phases PRINT_IDEAL and PRINT_OPTO_ASSEMBLY. PRINT_IDEAL is the output that is printed\n+ * when using -XX:+PrintIdeal and PRINT_OPTO_ASSEMBLY when using -XX:+PrintOptoAssembly. For simplicity, these two flags\n+ * are treated as a separated compile phase as well.\n+ *\/\n+public enum CompilePhase {\n+    DEFAULT(\"For IR node placeholder strings as defined in class IRNode only\"),\n+\n+    BEFORE_STRINGOPTS(\"Before StringOpts\"),\n+    AFTER_STRINGOPTS(\"After StringOpts\"),\n+    BEFORE_REMOVEUSELESS(\"Before RemoveUseless\"),\n+    AFTER_PARSING(\"After Parsing\"),\n+    ITER_GVN1(\"Iter GVN 1\"),\n+    INCREMENTAL_INLINE_STEP(\"Incremental Inline Step\"),\n+    INCREMENTAL_INLINE_CLEANUP(\"Incremental Inline Cleanup\"),\n+    INCREMENTAL_INLINE(\"Incremental Inline\"),\n+    INCREMENTAL_BOXING_INLINE(\"Incremental Boxing Inline\"),\n+    EXPAND_VUNBOX(\"Expand VectorUnbox\"),\n+    SCALARIZE_VBOX(\"Scalarize VectorBox\"),\n+    INLINE_VECTOR_REBOX(\"Inline Vector Rebox Calls\"),\n+    EXPAND_VBOX(\"Expand VectorBox\"),\n+    ELIMINATE_VBOX_ALLOC(\"Eliminate VectorBoxAllocate\"),\n+    ITER_GVN_BEFORE_EA(\"Iter GVN before EA\"),\n+    ITER_GVN_AFTER_VECTOR(\"Iter GVN after vector box elimination\"),\n+    BEFORE_BEAUTIFY_LOOPS(\"Before beautify loops\"),\n+    AFTER_BEAUTIFY_LOOPS(\"After beautify loops\"),\n+    \/\/ Match on very first BEFORE_CLOOPS phase (there could be multiple phases for multiple loops in the code).\n+    BEFORE_CLOOPS(\"Before CountedLoop\", RegexType.IDEAL_INDEPENDENT, ActionOnRepeat.KEEP_FIRST),\n+    AFTER_CLOOPS(\"After CountedLoop\"),\n+    PHASEIDEAL_BEFORE_EA(\"PhaseIdealLoop before EA\"),\n+    AFTER_EA(\"After Escape Analysis\"),\n+    ITER_GVN_AFTER_EA(\"Iter GVN after EA\"),\n+    ITER_GVN_AFTER_ELIMINATION(\"Iter GVN after eliminating allocations and locks\"),\n+    PHASEIDEALLOOP1(\"PhaseIdealLoop 1\"),\n+    PHASEIDEALLOOP2(\"PhaseIdealLoop 2\"),\n+    PHASEIDEALLOOP3(\"PhaseIdealLoop 3\"),\n+    CCP1(\"PhaseCCP 1\"),\n+    ITER_GVN2(\"Iter GVN 2\"),\n+    PHASEIDEALLOOP_ITERATIONS(\"PhaseIdealLoop iterations\"),\n+    MACRO_EXPANSION(\"Macro expand\"),\n+    BARRIER_EXPANSION(\"Barrier expand\"),\n+    OPTIMIZE_FINISHED(\"Optimize finished\"),\n+    PRINT_IDEAL(\"PrintIdeal\"),\n+    BEFORE_MATCHING(\"Before matching\"),\n+    MATCHING(\"After matching\", RegexType.MACH),\n+    MACH_ANALYSIS(\"After mach analysis\", RegexType.MACH),\n+    GLOBAL_CODE_MOTION(\"Global code motion\", RegexType.MACH),\n+    FINAL_CODE(\"Final Code\", RegexType.MACH),\n+    END(\"End\"),\n+\n+    PRINT_OPTO_ASSEMBLY(\"PrintOptoAssembly\", RegexType.OPTO_ASSEMBLY),\n+    ;\n+\n+    private static final Map<String, CompilePhase> PHASES_BY_PARSED_NAME = new HashMap<>();\n+\n+    static {\n+        for (CompilePhase phase : CompilePhase.values()) {\n+            if (phase == PRINT_IDEAL) {\n+                PHASES_BY_PARSED_NAME.put(\"print_ideal\", phase);\n+            } else {\n+                PHASES_BY_PARSED_NAME.put(phase.name(), phase);\n+            }\n+        }\n+    }\n+    private enum ActionOnRepeat {\n+        KEEP_FIRST, KEEP_LAST\n+    }\n+\n+    private final String name;\n+    private final RegexType regexType;\n+    private final ActionOnRepeat actionOnRepeat;\n+\n+    CompilePhase(String name) {\n+        this.name = name;\n+        this.regexType = RegexType.IDEAL_INDEPENDENT;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType, ActionOnRepeat actionOnRepeat) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = actionOnRepeat;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public RegexType regexType() {\n+        return regexType;\n+    }\n+\n+    public static CompilePhase forName(String phaseName) {\n+        CompilePhase phase = PHASES_BY_PARSED_NAME.get(phaseName);\n+        TestFramework.check(phase != null, \"Could not find phase with name \\\"\" + phaseName + \"\\\"\");\n+        return phase;\n+    }\n+\n+    public boolean overrideRepeatedPhase() {\n+        return actionOnRepeat == ActionOnRepeat.KEEP_LAST;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -87,0 +88,9 @@\n+    \/**\n+     * Define a list of {@link CompilePhase} enums to apply the IR rule constraint attributes {@link #failOn()} and\/or\n+     * {@link #counts()} on. By default, IR matching is applied on the predefined default phase of an IR node\n+     * placeholder string as defined in {@link IRNode}. For non-IR node constraints (i.e. user-defined regexes with no\n+     * definition in {@link IRNode}), a compile phase must explicitly be set. Otherwise, a {@link TestFormatException}\n+     * is reported.\n+     *\/\n+    CompilePhase[] phase() default { CompilePhase.DEFAULT };\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n-import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.driver.irmatching.mapping.*;\n+import compiler.lib.ir_framework.shared.CheckedTestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -31,2 +33,2 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -35,1 +37,19 @@\n- * This class provides default regex strings that can be used in {@link IR @IR} annotations to specify IR constraints.\n+ * This class specifies IR node placeholder strings (also referred to as just \"IR nodes\") with mappings to regexes\n+ * depending on the selected compile phases. The mappings are stored in {@link #IR_NODE_MAPPINGS}. Each IR node\n+ * placeholder string is mapped to a {@link IRNodeMapEntry} instance defined in\n+ * {@link compiler.lib.ir_framework.driver.irmatching.mapping}.\n+ *\n+ * <p>\n+ * IR node placeholder strings can be used in {@link IR#failOn()} and\/or {@link IR#counts()} attributes to define IR\n+ * constraints. They usually represent a single C2 IR node or a group of them.\n+ *\n+ * <p>\n+ * Each IR node placeholder string is accompanied by a static block that defines an IR node placeholder to regex(es)\n+ * mapping. The IR framework will automatically replace each IR node placeholder string in a user defined test with a\n+ * regex depending on the selected compile phases in {@link IR#phase} and the provided mapping.\n+ *\n+ * <p>\n+ * Each mapping must define a default compile phase which is applied when the user does not explicitly set the\n+ * {@link IR#phase()} attribute or when directly using {@link CompilePhase#DEFAULT}. In this case, the IR framework\n+ * falls back on the default compile phase of any {@link IRNodeMapEntry}.\n+ *\n@@ -37,1 +57,1 @@\n- * There are two types of default regexes:\n+ * The IR framework reports a {@link TestFormatException} if:\n@@ -39,4 +59,3 @@\n- *     <li><p>Standalone regexes: Use them directly.<\/li>\n- *     <li><p>Composite regexes: Their names contain \"{@code _OF}\" and expect another string in a list in\n- *            {@link IR#failOn()} and {@link IR#counts()}. They cannot be use as standalone regex and will result in a\n- *            {@link TestFormatException} when doing so.<\/li>\n+ *     <li><p> A user test specifies a compile phase for which no mapping is defined in this class.<\/li>\n+ *     <li><p> An IR node placeholder string is either missing a mapping or does not provide a regex for a specified\n+ *             compile phase in {@link IR#phase}.\n@@ -45,1 +64,9 @@\n- * @see IR\n+ * <p>\n+ * There are two types of IR nodes:\n+ * <ul>\n+ *     <li><p>Normal IR nodes: The IR node placeholder string is directly replaced by a regex.<\/li>\n+ *     <li><p>Composite IR nodes:  The IR node placeholder string contains an additional {@link #COMPOSITE_PREFIX}.\n+ *                                 Using this IR node expects another user provided string in the constraint list of\n+ *                                 {@link IR#failOn()} and {@link IR#counts()}. They cannot be used as normal IR nodes.\n+ *                                 Trying to do so will result in a format violation error.<\/li>\n+ * <\/ul>\n@@ -48,0 +75,10 @@\n+    \/**\n+     * Prefix for normal IR nodes.\n+     *\/\n+    private static final String PREFIX = \"_#\";\n+    \/**\n+     * Prefix for composite IR nodes.\n+     *\/\n+    private static final String COMPOSITE_PREFIX = PREFIX + \"C#\";\n+    private static final String POSTFIX = \"#_\";\n+\n@@ -51,2 +88,0 @@\n-    private static final String COMPOSITE_PREFIX = \"#PRE#\"; \/\/ Prefix for regexes that require an additional user-defined string.\n-    private static final String IS_REPLACED = \"#IS_REPLACED#\"; \/\/ Is replaced by an additional user-defined string.\n@@ -56,4 +91,164 @@\n-    public static final String ALLOC = \"(.*precise .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n-    public static final String ALLOC_ARRAY = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n-    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+    public static final String IS_REPLACED = \"#IS_REPLACED#\"; \/\/ Is replaced by an additional user-defined string.\n+\n+\n+    \/**\n+     * IR placeholder string to regex-for-compile-phase map.\n+     *\/\n+    private static final Map<String, IRNodeMapEntry> IR_NODE_MAPPINGS = new HashMap<>();\n+\n+    \/*\n+     * Start of IR placeholder string definitions followed by a static block defining the regex-for-compile-phase mapping.\n+     * An IR node placeholder string must start with PREFIX for normal IR nodes or COMPOSITE_PREFIX for composite IR\n+     * nodes (see class description above).\n+     *\n+     * An IR node definition looks like this:\n+     *\n+     * public static final String IR_NODE = [PREFIX|COMPOSITE_PREFIX] + \"IR_NODE\" + POSTFIX;\n+     * static {\n+     *    \/\/ Define IR_NODE to regex-for-compile-phase mapping. Create a new IRNodeMapEntry object and add it to\n+     *    \/\/ IR_NODE_MAPPINGS. This can be done by using the helper methods defined after all IR node placeholder string\n+     *    \/\/ definitions.\n+     * }\n+     *\/\n+\n+    public static final String ABS_D = PREFIX + \"ABS_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_D, \"AbsD\");\n+    }\n+\n+    public static final String ABS_F = PREFIX + \"ABS_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_F, \"AbsF\");\n+    }\n+\n+    public static final String ABS_I = PREFIX + \"ABS_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_I, \"AbsI\");\n+    }\n+\n+    public static final String ABS_L = PREFIX + \"ABS_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_L, \"AbsL\");\n+    }\n+    public static final String ADD = PREFIX + \"ADD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD, \"Add(I|L|F|D|P)\");\n+    }\n+\n+    public static final String ADD_I = PREFIX + \"ADD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_I, \"AddI\");\n+    }\n+\n+    public static final String ADD_L = PREFIX + \"ADD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_L, \"AddL\");\n+    }\n+\n+    public static final String ADD_VD = PREFIX + \"ADD_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VD, \"AddVD\");\n+    }\n+\n+    public static final String ADD_VI = PREFIX + \"ADD_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VI, \"AddVI\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VD = PREFIX + \"ADD_REDUCTION_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VD, \"AddReductionVD\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VF = PREFIX + \"ADD_REDUCTION_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VF, \"AddReductionVF\");\n+    }\n+\n+    public static final String ALLOC = PREFIX + \"ALLOC\" + POSTFIX;\n+    static {\n+        String idealIndependentRegex = START + \"Allocate\" + MID + END;\n+        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        allocNodes(ALLOC, idealIndependentRegex, optoRegex);\n+    }\n+\n+    public static final String ALLOC_OF = COMPOSITE_PREFIX + \"ALLOC_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        optoOnly(ALLOC_OF, regex);\n+    }\n+\n+    public static final String ALLOC_ARRAY = PREFIX + \"ALLOC_ARRAY\" + POSTFIX;\n+    static {\n+        String idealIndependentRegex = START + \"AllocateArray\" + MID + END;\n+        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        allocNodes(ALLOC_ARRAY, idealIndependentRegex, optoRegex);\n+    }\n+\n+    public static final String ALLOC_ARRAY_OF = COMPOSITE_PREFIX + \"ALLOC_ARRAY_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*LGHI.*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        optoOnly(ALLOC_ARRAY_OF, regex);\n+    }\n+\n+    public static final String AND = PREFIX + \"AND\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND, \"And(I|L)\");\n+    }\n+\n+    public static final String AND_I = PREFIX + \"AND_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_I, \"AndI\");\n+    }\n+\n+    public static final String AND_L = PREFIX + \"AND_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_L, \"AndL\");\n+    }\n+\n+    public static final String AND_V = PREFIX + \"AND_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_V, \"AndV\");\n+    }\n+\n+    public static final String AND_V_MASK = PREFIX + \"AND_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(AND_V_MASK, \"AndVMask\");\n+    }\n+\n+    public static final String CALL = PREFIX + \"CALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CALL, \"Call.*Java\");\n+    }\n+\n+    public static final String CALL_OF_METHOD = COMPOSITE_PREFIX + \"CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(CALL_OF_METHOD, \"Call.*Java\");\n+    }\n+\n+    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + \"STATIC_CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(STATIC_CALL_OF_METHOD, \"CallStaticJava\");\n+    }\n+\n+    public static final String CAST_II = PREFIX + \"CAST_II\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CAST_II, \"CastII\");\n+    }\n+\n+    public static final String CAST_LL = PREFIX + \"CAST_LL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CAST_LL, \"CastLL\");\n+    }\n+\n+    public static final String CHECKCAST_ARRAY = PREFIX + \"CHECKCAST_ARRAY\" + POSTFIX;\n+    static {\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        optoOnly(CHECKCAST_ARRAY, regex);\n+    }\n+\n+    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"CHECKCAST_ARRAY_OF\" + POSTFIX;\n+    static {\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        optoOnly(CHECKCAST_ARRAY_OF, regex);\n+    }\n@@ -61,2 +256,0 @@\n-    public static final String CHECKCAST_ARRAY = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n-    public static final String CHECKCAST_ARRAY_OF = COMPOSITE_PREFIX + \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n@@ -64,72 +257,140 @@\n-    public static final String CHECKCAST_ARRAYCOPY = \"(.*((?i:call_leaf_nofp,runtime)|CALL,\\\\s?runtime leaf nofp|BCTRL.*.leaf call).*checkcast_arraycopy.*\" + END;\n-\n-    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n-\n-    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n-    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n-    public static final String STORE_C = START + \"StoreC\" + MID + END;\n-    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n-    public static final String STORE_L = START + \"StoreL\" + MID + END;\n-    public static final String STORE_F = START + \"StoreF\" + MID + END;\n-    public static final String STORE_D = START + \"StoreD\" + MID + END;\n-    public static final String STORE_P = START + \"StoreP\" + MID + END;\n-    public static final String STORE_N = START + \"StoreN\" + MID + END;\n-    public static final String STORE_VECTOR = START + \"StoreVector\" + MID + END;\n-    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreB\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreC\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreI\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreL\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreF\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreD\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreP\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreN\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n-\n-    public static final String LOAD = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + END;\n-    public static final String LOAD_B = START + \"LoadB\" + MID + END;\n-    public static final String LOAD_UB = START + \"LoadUB\" + MID + END; \/\/ Load from boolean\n-    public static final String LOAD_S = START + \"LoadS\" + MID + END;\n-    public static final String LOAD_US = START + \"LoadUS\" + MID + END; \/\/ Load from char\n-    public static final String LOAD_I = START + \"LoadI\" + MID + END;\n-    public static final String LOAD_L = START + \"LoadL\" + MID + END;\n-    public static final String LOAD_F = START + \"LoadF\" + MID + END;\n-    public static final String LOAD_D = START + \"LoadD\" + MID + END;\n-    public static final String LOAD_P = START + \"LoadP\" + MID + END;\n-    public static final String LOAD_N = START + \"LoadN\" + MID + END;\n-    public static final String LOAD_VECTOR = START + \"LoadVector\" + MID + END;\n-    public static final String LOAD_OF_CLASS = COMPOSITE_PREFIX + START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\"+  IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_B_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_UB_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUB\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_S_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_US_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadUS\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_I_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadI\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_L_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadL\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_F_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadF\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_D_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadD\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_P_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadP\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_N_OF_CLASS = COMPOSITE_PREFIX + START + \"LoadN\" + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n-    public static final String LOAD_OF_FIELD = COMPOSITE_PREFIX + START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n-    public static final String LOAD_KLASS  = START + \"LoadK\" + MID + END;\n-\n-    public static final String LOOP   = START + \"Loop\" + MID + END;\n-    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + END;\n-    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n-    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n-    public static final String LONGCOUNTEDLOOP = START + \"LongCountedLoop\\\\b\" + MID + END;\n-    public static final String IF = START + \"If\\\\b\" + MID + END;\n-\n-    public static final String CALL = START + \"Call.*Java\" + MID + END;\n-    public static final String CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"Call.*Java\" + MID + IS_REPLACED + \" \" +  END;\n-    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallDynamicJava\" + MID + IS_REPLACED + \" \" + END;\n-    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallStaticJava\" + MID + IS_REPLACED + \" \" +  END;\n-    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n-    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n-    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n-    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n-    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n-    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n-    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n-    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n-    public static final String INTRINSIC_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic\" + END;\n-    public static final String DIV_BY_ZERO_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*div0_check\" + END;\n+    public static final String CHECKCAST_ARRAYCOPY = PREFIX + \"CHECKCAST_ARRAYCOPY\" + POSTFIX;\n+    static {\n+        String regex = \"(.*((?i:call_leaf_nofp,runtime)|CALL,\\\\s?runtime leaf nofp|BCTRL.*.leaf call).*checkcast_arraycopy.*\" + END;\n+        optoOnly(CHECKCAST_ARRAYCOPY, regex);\n+    }\n+\n+    public static final String CLASS_CHECK_TRAP = PREFIX + \"CLASS_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(CLASS_CHECK_TRAP, \"class_check\");\n+    }\n+\n+    public static final String CMOVE_I = PREFIX + \"CMOVE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_I, \"CMoveI\");\n+    }\n+\n+    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VD, \"CMoveVD\");\n+    }\n+\n+    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VF, \"CMoveVF\");\n+    }\n+\n+    public static final String CMP_I = PREFIX + \"CMP_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_I, \"CmpI\");\n+    }\n+\n+    public static final String CMP_L = PREFIX + \"CMP_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_L, \"CmpL\");\n+    }\n+\n+    public static final String CMP_U = PREFIX + \"CMP_U\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+    }\n+\n+    public static final String CMP_U3 = PREFIX + \"CMP_U3\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_U3, \"CmpU3\");\n+    }\n+\n+    public static final String CMP_UL = PREFIX + \"CMP_UL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_UL, \"CmpUL\");\n+    }\n+\n+    public static final String CMP_UL3 = PREFIX + \"CMP_UL3\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_UL3, \"CmpUL3\");\n+    }\n+\n+    public static final String COMPRESS_BITS = PREFIX + \"COMPRESS_BITS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COMPRESS_BITS, \"CompressBits\");\n+    }\n+\n+    public static final String CONV_I2L = PREFIX + \"CONV_I2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_I2L, \"ConvI2L\");\n+    }\n+\n+    public static final String CONV_L2I = PREFIX + \"CONV_L2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_L2I, \"ConvL2I\");\n+    }\n+\n+    public static final String CON_I = PREFIX + \"CON_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_I, \"ConI\");\n+    }\n+\n+    public static final String CON_L = PREFIX + \"CON_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_L, \"ConL\");\n+    }\n+\n+    public static final String COUNTED_LOOP = PREFIX + \"COUNTED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"CountedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(COUNTED_LOOP, regex);\n+    }\n+\n+    public static final String COUNTED_LOOP_MAIN = PREFIX + \"COUNTED_LOOP_MAIN\" + POSTFIX;\n+    static {\n+        String regex = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+        fromAfterCountedLoops(COUNTED_LOOP_MAIN, regex);\n+    }\n+\n+    public static final String DIV = PREFIX + \"DIV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV, \"Div(I|L|F|D)\");\n+    }\n+\n+    public static final String DIV_BY_ZERO_TRAP = PREFIX + \"DIV_BY_ZERO_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(DIV_BY_ZERO_TRAP, \"div0_check\");\n+    }\n+\n+    public static final String DIV_L = PREFIX + \"DIV_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_L, \"DivL\");\n+    }\n+\n+    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + \"DYNAMIC_CALL_OF_METHOD\" + POSTFIX;\n+    static {\n+        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\");\n+    }\n+\n+    public static final String EXPAND_BITS = PREFIX + \"EXPAND_BITS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(EXPAND_BITS, \"ExpandBits\");\n+    }\n+\n+    public static final String FAST_LOCK = PREFIX + \"FAST_LOCK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FAST_LOCK, \"FastLock\");\n+    }\n+\n+    public static final String FAST_UNLOCK = PREFIX + \"FAST_UNLOCK\" + POSTFIX;\n+    static {\n+        String regex = START + \"FastUnlock\" + MID + END;\n+        fromMacroToBeforeMatching(FAST_UNLOCK, regex);\n+    }\n+\n+    public static final String FIELD_ACCESS = PREFIX + \"FIELD_ACCESS\" + POSTFIX;\n+    static {\n+        String regex = \"(.*Field: *\" + END;\n+        optoOnly(FIELD_ACCESS, regex);\n+    }\n+\n+    public static final String IF = PREFIX + \"IF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IF, \"If\\\\b\");\n+    }\n+\n@@ -137,97 +398,769 @@\n-    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n-\n-    public static final String SCOPE_OBJECT = \"(.*# ScObj.*\" + END;\n-    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n-    public static final String MEMBAR_STORESTORE = START + \"MemBarStoreStore\" + MID + END;\n-    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n-\n-    public static final String CMOVEI = START + \"CMoveI\" + MID + END;\n-    public static final String CMOVEVF = START + \"CMoveVF\" + MID + END;\n-    public static final String CMOVEVD = START + \"CMoveVD\" + MID + END;\n-    public static final String ABS_I = START + \"AbsI\" + MID + END;\n-    public static final String ABS_L = START + \"AbsL\" + MID + END;\n-    public static final String ABS_F = START + \"AbsF\" + MID + END;\n-    public static final String ABS_D = START + \"AbsD\" + MID + END;\n-    public static final String AND = START + \"And(I|L)\" + MID + END;\n-    public static final String AND_I = START + \"AndI\" + MID + END;\n-    public static final String AND_L = START + \"AndL\" + MID + END;\n-    public static final String XOR = START + \"Xor(I|L)\" + MID + END;\n-    public static final String XOR_I = START + \"XorI\" + MID + END;\n-    public static final String XOR_L = START + \"XorL\" + MID + END;\n-    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n-    public static final String LSHIFT_I = START + \"LShiftI\" + MID + END;\n-    public static final String LSHIFT_L = START + \"LShiftL\" + MID + END;\n-    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n-    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n-    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n-    public static final String RSHIFT_VB = START + \"RShiftVB\" + MID + END;\n-    public static final String RSHIFT_VS = START + \"RShiftVS\" + MID + END;\n-    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n-    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n-    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n-    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n-    public static final String ADD_I = START + \"AddI\" + MID + END;\n-    public static final String ADD_L = START + \"AddL\" + MID + END;\n-    public static final String ADD_VD = START + \"AddVD\" + MID + END;\n-    public static final String ADD_VI = START + \"AddVI\" + MID + END;\n-    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n-    public static final String SUB_I = START + \"SubI\" + MID + END;\n-    public static final String SUB_L = START + \"SubL\" + MID + END;\n-    public static final String SUB_F = START + \"SubF\" + MID + END;\n-    public static final String SUB_D = START + \"SubD\" + MID + END;\n-    public static final String CMP_U = START + \"CmpU\" + MID + END;\n-    public static final String CMP_UL = START + \"CmpUL\" + MID + END;\n-    public static final String CMP_U3 = START + \"CmpU3\" + MID + END;\n-    public static final String CMP_UL3 = START + \"CmpUL3\" + MID + END;\n-    public static final String CMP_I = START + \"CmpI\" + MID + END;\n-    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n-    public static final String MUL_I = START + \"MulI\" + MID + END;\n-    public static final String MUL_L = START + \"MulL\" + MID + END;\n-    public static final String MUL_F = START + \"MulF\" + MID + END;\n-    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n-    public static final String DIV_L = START + \"DivL\" + MID + END;\n-    public static final String CON_I = START + \"ConI\" + MID + END;\n-    public static final String CON_L = START + \"ConL\" + MID + END;\n-    public static final String CONV_I2L = START + \"ConvI2L\" + MID + END;\n-    public static final String CONV_L2I = START + \"ConvL2I\" + MID + END;\n-    public static final String CAST_II = START + \"CastII\" + MID + END;\n-    public static final String CAST_LL = START + \"CastLL\" + MID + END;\n-    public static final String POPCOUNT_L = START + \"PopCountL\" + MID + END;\n-    public static final String PHI = START + \"Phi\" + MID + END;\n-\n-    public static final String AND_V = START + \"AndV\" + MID + END;\n-    public static final String OR_V = START + \"OrV\" + MID + END;\n-    public static final String XOR_V = START + \"XorV\" + MID + END;\n-    public static final String AND_V_MASK = START + \"AndVMask\" + MID + END;\n-    public static final String OR_V_MASK = START + \"OrVMask\" + MID + END;\n-    public static final String XOR_V_MASK = START + \"XorVMask\" + MID + END;\n-\n-    public static final String VECTOR_MASK_CAST = START + \"VectorMaskCast\" + MID + END;\n-    public static final String VECTOR_CAST_B2X = START + \"VectorCastB2X\" + MID + END;\n-    public static final String VECTOR_CAST_S2X = START + \"VectorCastS2X\" + MID + END;\n-    public static final String VECTOR_CAST_I2X = START + \"VectorCastI2X\" + MID + END;\n-    public static final String VECTOR_CAST_L2X = START + \"VectorCastL2X\" + MID + END;\n-    public static final String VECTOR_CAST_F2X = START + \"VectorCastF2X\" + MID + END;\n-    public static final String VECTOR_CAST_D2X = START + \"VectorCastD2X\" + MID + END;\n-    public static final String VECTOR_UCAST_B2X = START + \"VectorUCastB2X\" + MID + END;\n-    public static final String VECTOR_UCAST_S2X = START + \"VectorUCastS2X\" + MID + END;\n-    public static final String VECTOR_UCAST_I2X = START + \"VectorUCastI2X\" + MID + END;\n-    public static final String VECTOR_REINTERPRET = START + \"VectorReinterpret\" + MID + END;\n-    public static final String VECTOR_BLEND = START + \"VectorBlend\" + MID + END;\n-    public static final String REVERSE_BYTES_V = START + \"ReverseBytesV\" + MID + END;\n-\n-    public static final String Min_I = START + \"MinI\" + MID + END;\n-    public static final String Max_I = START + \"MaxI\" + MID + END;\n-    public static final String Min_V = START + \"MinV\" + MID + END;\n-    public static final String Max_V = START + \"MaxV\" + MID + END;\n-    public static final String MUL_VL = START + \"MulVL\" + MID + END;\n-\n-    public static final String ADD_REDUCTION_VF = START + \"AddReductionVF\" + MID + END;\n-    public static final String ADD_REDUCTION_VD = START + \"AddReductionVD\" + MID + END;\n-    public static final String MUL_REDUCTION_VF = START + \"MulReductionVF\" + MID + END;\n-    public static final String MUL_REDUCTION_VD = START + \"MulReductionVD\" + MID + END;\n-\n-    public static final String FAST_LOCK   = START + \"FastLock\" + MID + END;\n-    public static final String FAST_UNLOCK = START + \"FastUnlock\" + MID + END;\n-\n-    public static final String POPULATE_INDEX = START + \"PopulateIndex\" + MID + END;\n+    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = PREFIX + \"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\"intrinsic_or_type_checked_inlining\");\n+    }\n+\n+    public static final String INTRINSIC_TRAP = PREFIX + \"INTRINSIC_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(INTRINSIC_TRAP,\"intrinsic\");\n+    }\n+\n+    \/\/ Is only supported on riscv64.\n+    public static final String IS_FINITE_D = PREFIX + \"IS_FINITE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_FINITE_D, \"IsFiniteD\");\n+    }\n+\n+    \/\/ Is only supported on riscv64.\n+    public static final String IS_FINITE_F = PREFIX + \"IS_FINITE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_FINITE_F, \"IsFiniteF\");\n+    }\n+\n+    public static final String IS_INFINITE_D = PREFIX + \"IS_INFINITE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_INFINITE_D, \"IsInfiniteD\");\n+    }\n+\n+    public static final String IS_INFINITE_F = PREFIX + \"IS_INFINITE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(IS_INFINITE_F, \"IsInfiniteF\");\n+    }\n+\n+    public static final String LOAD = PREFIX + \"LOAD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String LOAD_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_OF_CLASS, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String LOAD_B = PREFIX + \"LOAD_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_B, \"LoadB\");\n+    }\n+\n+    public static final String LOAD_B_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_B_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\");\n+    }\n+\n+    public static final String LOAD_D = PREFIX + \"LOAD_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_D, \"LoadD\");\n+    }\n+\n+    public static final String LOAD_D_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_D_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\");\n+    }\n+\n+    public static final String LOAD_F = PREFIX + \"LOAD_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_F, \"LoadF\");\n+    }\n+\n+    public static final String LOAD_F_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_F_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\");\n+    }\n+\n+    public static final String LOAD_I = PREFIX + \"LOAD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_I, \"LoadI\");\n+    }\n+\n+    public static final String LOAD_I_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_I_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\");\n+    }\n+\n+    public static final String LOAD_KLASS = PREFIX + \"LOAD_KLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_KLASS, \"LoadKlass\");\n+    }\n+\n+    public static final String LOAD_L = PREFIX + \"LOAD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_L, \"LoadL\");\n+    }\n+\n+    public static final String LOAD_L_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_L_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\");\n+    }\n+\n+    public static final String LOAD_N = PREFIX + \"LOAD_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_N, \"LoadN\");\n+    }\n+\n+    public static final String LOAD_N_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_N_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\");\n+    }\n+\n+    public static final String LOAD_OF_FIELD = COMPOSITE_PREFIX + \"LOAD_OF_FIELD\" + POSTFIX;\n+    static {\n+        String regex = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+        beforeMatching(LOAD_OF_FIELD, regex);\n+    }\n+\n+    public static final String LOAD_P = PREFIX + \"LOAD_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_P, \"LoadP\");\n+    }\n+\n+    public static final String LOAD_P_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_P_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\");\n+    }\n+\n+    public static final String LOAD_S = PREFIX + \"LOAD_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_S, \"LoadS\");\n+    }\n+\n+    public static final String LOAD_S_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_S_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\");\n+    }\n+\n+    public static final String LOAD_UB = PREFIX + \"LOAD_UB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_UB, \"LoadUB\");\n+    }\n+\n+    public static final String LOAD_UB_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_UB_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\");\n+    }\n+\n+    public static final String LOAD_US = PREFIX + \"LOAD_US\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_US, \"LoadUS\");\n+    }\n+\n+    public static final String LOAD_US_OF_CLASS = COMPOSITE_PREFIX + \"LOAD_US_OF_CLASS\" + POSTFIX;\n+    static {\n+        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\");\n+    }\n+\n+    public static final String LOAD_VECTOR = PREFIX + \"LOAD_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR, \"LoadVector\");\n+    }\n+\n+    public static final String LOAD_VECTOR_GATHER = PREFIX + \"LOAD_VECTOR_GATHER\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_GATHER, \"LoadVectorGather\");\n+    }\n+\n+    public static final String LOAD_VECTOR_GATHER_MASKED = PREFIX + \"LOAD_VECTOR_GATHER_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_GATHER_MASKED, \"LoadVectorGatherMasked\");\n+    }\n+\n+    public static final String LONG_COUNTED_LOOP = PREFIX + \"LONG_COUNTED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"LongCountedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(LONG_COUNTED_LOOP, regex);\n+    }\n+\n+    public static final String LOOP = PREFIX + \"LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"Loop\" + MID + END;\n+        fromBeforeCountedLoops(LOOP, regex);\n+    }\n+\n+    public static final String LSHIFT = PREFIX + \"LSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT, \"LShift(I|L)\");\n+    }\n+\n+    public static final String LSHIFT_I = PREFIX + \"LSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_I, \"LShiftI\");\n+    }\n+\n+    public static final String LSHIFT_L = PREFIX + \"LSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_L, \"LShiftL\");\n+    }\n+\n+    public static final String MACRO_LOGIC_V = PREFIX + \"MACRO_LOGIC_V\" + POSTFIX;\n+    static {\n+        afterBarrierExpansionToBeforeMatching(MACRO_LOGIC_V, \"MacroLogicV\");\n+    }\n+\n+    public static final String MAX_I = PREFIX + \"MAX_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_I, \"MaxI\");\n+    }\n+\n+    public static final String MAX_V = PREFIX + \"MAX_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_V, \"MaxV\");\n+    }\n+\n+    public static final String MEMBAR = PREFIX + \"MEMBAR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR, \"MemBar\");\n+    }\n+\n+    public static final String MEMBAR_STORESTORE = PREFIX + \"MEMBAR_STORESTORE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_STORESTORE, \"MemBarStoreStore\");\n+    }\n+\n+    public static final String MIN_I = PREFIX + \"MIN_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_I, \"MinI\");\n+    }\n+\n+    public static final String MIN_V = PREFIX + \"MIN_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_V, \"MinV\");\n+    }\n+\n+    public static final String MUL = PREFIX + \"MUL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL, \"Mul(I|L|F|D)\");\n+    }\n+\n+    public static final String MUL_D = PREFIX + \"MUL_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_D, \"MulD\");\n+    }\n+\n+    public static final String MUL_F = PREFIX + \"MUL_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_F, \"MulF\");\n+    }\n+\n+    public static final String MUL_I = PREFIX + \"MUL_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_I, \"MulI\");\n+    }\n+\n+    public static final String MUL_L = PREFIX + \"MUL_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_L, \"MulL\");\n+    }\n+\n+    public static final String MUL_VL = PREFIX + \"MUL_VL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VL, \"MulVL\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VD = PREFIX + \"MUL_REDUCTION_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VD, \"MulReductionVD\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VF = PREFIX + \"MUL_REDUCTION_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VF, \"MulReductionVF\");\n+    }\n+\n+    public static final String NULL_ASSERT_TRAP = PREFIX + \"NULL_ASSERT_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(NULL_ASSERT_TRAP,\"null_assert\");\n+    }\n+\n+    public static final String NULL_CHECK_TRAP = PREFIX + \"NULL_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(NULL_CHECK_TRAP,\"null_check\");\n+    }\n+\n+    public static final String OR_V = PREFIX + \"OR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_V, \"OrV\");\n+    }\n+\n+    public static final String OR_V_MASK = PREFIX + \"OR_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(OR_V_MASK, \"OrVMask\");\n+    }\n+\n+    public static final String OUTER_STRIP_MINED_LOOP = PREFIX + \"OUTER_STRIP_MINED_LOOP\" + POSTFIX;\n+    static {\n+        String regex = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n+        fromAfterCountedLoops(OUTER_STRIP_MINED_LOOP, regex);\n+    }\n+\n+    public static final String PHI = PREFIX + \"PHI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PHI, \"Phi\");\n+    }\n+\n+    public static final String POPCOUNT_L = PREFIX + \"POPCOUNT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(POPCOUNT_L, \"PopCountL\");\n+    }\n+\n+    public static final String POPCOUNT_VL = PREFIX + \"POPCOUNT_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(POPCOUNT_VL, \"PopCountVL\");\n+    }\n+\n+    public static final String POPULATE_INDEX = PREFIX + \"POPULATE_INDEX\" + POSTFIX;\n+    static {\n+        String regex = START + \"PopulateIndex\" + MID + END;\n+        IR_NODE_MAPPINGS.put(POPULATE_INDEX, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                       CompilePhase.AFTER_CLOOPS,\n+                                                                       CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String PREDICATE_TRAP = PREFIX + \"PREDICATE_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(PREDICATE_TRAP,\"predicate\");\n+    }\n+\n+    public static final String RANGE_CHECK_TRAP = PREFIX + \"RANGE_CHECK_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(RANGE_CHECK_TRAP,\"range_check\");\n+    }\n+\n+    public static final String REVERSE_BYTES_V = PREFIX + \"REVERSE_BYTES_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_BYTES_V, \"ReverseBytesV\");\n+    }\n+\n+    public static final String REVERSE_I = PREFIX + \"REVERSE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_I, \"ReverseI\");\n+    }\n+\n+    public static final String REVERSE_L = PREFIX + \"REVERSE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_L, \"ReverseL\");\n+    }\n+\n+    public static final String REVERSE_V = PREFIX + \"REVERSE_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REVERSE_V, \"ReverseV\");\n+    }\n+\n+    public static final String ROUND_VD = PREFIX + \"ROUND_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_VD, \"RoundVD\");\n+    }\n+\n+    public static final String ROUND_VF = PREFIX + \"ROUND_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_VF, \"RoundVF\");\n+    }\n+\n+    public static final String RSHIFT = PREFIX + \"RSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT, \"RShift(I|L)\");\n+    }\n+\n+    public static final String RSHIFT_I = PREFIX + \"RSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_I, \"RShiftI\");\n+    }\n+\n+    public static final String RSHIFT_L = PREFIX + \"RSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_L, \"RShiftL\");\n+    }\n+\n+    public static final String RSHIFT_VB = PREFIX + \"RSHIFT_VB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_VB, \"RShiftVB\");\n+    }\n+\n+    public static final String RSHIFT_VS = PREFIX + \"RSHIFT_VS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_VS, \"RShiftVS\");\n+    }\n+\n+    public static final String SAFEPOINT = PREFIX + \"SAFEPOINT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SAFEPOINT, \"SafePoint\");\n+    }\n+\n+    public static final String SCOPE_OBJECT = PREFIX + \"SCOPE_OBJECT\" + POSTFIX;\n+    static {\n+        String regex = \"(.*# ScObj.*\" + END;\n+        optoOnly(SCOPE_OBJECT, regex);\n+    }\n+\n+    public static final String SIGNUM_VD = PREFIX + \"SIGNUM_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SIGNUM_VD, \"SignumVD\");\n+    }\n+\n+    public static final String SIGNUM_VF = PREFIX + \"SIGNUM_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SIGNUM_VF, \"SignumVF\");\n+    }\n+\n+    public static final String STORE = PREFIX + \"STORE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE, \"Store(B|C|S|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String STORE_B = PREFIX + \"STORE_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_B, \"StoreB\");\n+    }\n+\n+    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + \"STORE_B_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\");\n+    }\n+\n+    public static final String STORE_C = PREFIX + \"STORE_C\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_C, \"StoreC\");\n+    }\n+\n+    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + \"STORE_C_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\");\n+    }\n+\n+    public static final String STORE_D = PREFIX + \"STORE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_D, \"StoreD\");\n+    }\n+\n+    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + \"STORE_D_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\");\n+    }\n+\n+    public static final String STORE_F = PREFIX + \"STORE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_F, \"StoreF\");\n+    }\n+\n+    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + \"STORE_F_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\");\n+    }\n+\n+    public static final String STORE_I = PREFIX + \"STORE_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_I, \"StoreI\");\n+    }\n+\n+    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + \"STORE_I_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\");\n+    }\n+\n+    public static final String STORE_L = PREFIX + \"STORE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_L, \"StoreL\");\n+    }\n+\n+    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + \"STORE_L_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\");\n+    }\n+\n+    public static final String STORE_N = PREFIX + \"STORE_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_N, \"StoreN\");\n+    }\n+\n+    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + \"STORE_N_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\");\n+    }\n+\n+    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + \"STORE_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_OF_CLASS, \"Store(B|C|S|I|L|F|D|P|N)\");\n+    }\n+\n+    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + \"STORE_OF_FIELD\" + POSTFIX;\n+    static {\n+        String regex = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+        beforeMatching(STORE_OF_FIELD, regex);\n+    }\n+\n+    public static final String STORE_P = PREFIX + \"STORE_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_P, \"StoreP\");\n+    }\n+\n+    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + \"STORE_P_OF_CLASS\" + POSTFIX;\n+    static {\n+        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\");\n+    }\n+\n+    public static final String STORE_VECTOR = PREFIX + \"STORE_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR, \"StoreVector\");\n+    }\n+\n+    public static final String STORE_VECTOR_SCATTER = PREFIX + \"STORE_VECTOR_SCATTER\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_SCATTER, \"StoreVectorScatter\");\n+    }\n+\n+    public static final String STORE_VECTOR_SCATTER_MASKED = PREFIX + \"STORE_VECTOR_SCATTER_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_SCATTER_MASKED, \"StoreVectorScatterMasked\");\n+    }\n+\n+    public static final String SUB = PREFIX + \"SUB\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D)\");\n+    }\n+\n+    public static final String SUB_D = PREFIX + \"SUB_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_D, \"SubD\");\n+    }\n+\n+    public static final String SUB_F = PREFIX + \"SUB_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_F, \"SubF\");\n+    }\n+\n+    public static final String SUB_I = PREFIX + \"SUB_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_I, \"SubI\");\n+    }\n+\n+    public static final String SUB_L = PREFIX + \"SUB_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_L, \"SubL\");\n+    }\n+\n+    public static final String TRAP = PREFIX + \"TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(TRAP,\"reason\");\n+    }\n+\n+    public static final String UDIV_I = PREFIX + \"UDIV_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_I, \"UDivI\");\n+    }\n+\n+    public static final String UDIV_L = PREFIX + \"UDIV_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_L, \"UDivL\");\n+    }\n+\n+    public static final String UDIV_MOD_I = PREFIX + \"UDIV_MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_MOD_I, \"UDivModI\");\n+    }\n+\n+    public static final String UDIV_MOD_L = PREFIX + \"UDIV_MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UDIV_MOD_L, \"UDivModL\");\n+    }\n+\n+    public static final String UMOD_I = PREFIX + \"UMOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMOD_I, \"UModI\");\n+    }\n+\n+    public static final String UMOD_L = PREFIX + \"UMOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMOD_L, \"UModL\");\n+    }\n+\n+    public static final String UNHANDLED_TRAP = PREFIX + \"UNHANDLED_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNHANDLED_TRAP,\"unhandled\");\n+    }\n+\n+    public static final String UNSTABLE_IF_TRAP = PREFIX + \"UNSTABLE_IF_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNSTABLE_IF_TRAP,\"unstable_if\");\n+    }\n+\n+    public static final String URSHIFT = PREFIX + \"URSHIFT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT, \"URShift(B|S|I|L)\");\n+    }\n+\n+    public static final String URSHIFT_B = PREFIX + \"URSHIFT_B\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_B, \"URShiftB\");\n+    }\n+\n+    public static final String URSHIFT_I = PREFIX + \"URSHIFT_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_I, \"URShiftI\");\n+    }\n+\n+    public static final String URSHIFT_L = PREFIX + \"URSHIFT_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_L, \"URShiftL\");\n+    }\n+\n+    public static final String URSHIFT_S = PREFIX + \"URSHIFT_S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_S, \"URShiftS\");\n+    }\n+\n+    public static final String VAND_NOT_I = PREFIX + \"VAND_NOT_I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_I, \"vand_notI\");\n+    }\n+\n+    public static final String VAND_NOT_L = PREFIX + \"VAND_NOT_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VAND_NOT_L, \"vand_notL\");\n+    }\n+\n+    public static final String VECTOR_BLEND = PREFIX + \"VECTOR_BLEND\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_BLEND, \"VectorBlend\");\n+    }\n+\n+    public static final String VECTOR_CAST_B2X = PREFIX + \"VECTOR_CAST_B2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_B2X, \"VectorCastB2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_D2X = PREFIX + \"VECTOR_CAST_D2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_D2X, \"VectorCastD2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_F2X = PREFIX + \"VECTOR_CAST_F2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_F2X, \"VectorCastF2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_I2X = PREFIX + \"VECTOR_CAST_I2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_I2X, \"VectorCastI2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_L2X = PREFIX + \"VECTOR_CAST_L2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_L2X, \"VectorCastL2X\");\n+    }\n+\n+    public static final String VECTOR_CAST_S2X = PREFIX + \"VECTOR_CAST_S2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_CAST_S2X, \"VectorCastS2X\");\n+    }\n+\n+    public static final String VECTOR_MASK_CAST = PREFIX + \"VECTOR_MASK_CAST\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CAST, \"VectorMaskCast\");\n+    }\n+\n+    public static final String VECTOR_REINTERPRET = PREFIX + \"VECTOR_REINTERPRET\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_REINTERPRET, \"VectorReinterpret\");\n+    }\n+\n+    public static final String VECTOR_UCAST_B2X = PREFIX + \"VECTOR_UCAST_B2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_B2X, \"VectorUCastB2X\");\n+    }\n+\n+    public static final String VECTOR_UCAST_I2X = PREFIX + \"VECTOR_UCAST_I2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_I2X, \"VectorUCastI2X\");\n+    }\n+\n+    public static final String VECTOR_UCAST_S2X = PREFIX + \"VECTOR_UCAST_S2X\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_UCAST_S2X, \"VectorUCastS2X\");\n+    }\n+\n+    public static final String VFABD = PREFIX + \"VFABD\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFABD, \"vfabd\");\n+    }\n+\n+    public static final String VFABD_MASKED = PREFIX + \"VFABD_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFABD_MASKED, \"vfabd_masked\");\n+    }\n+\n+    public static final String VFMSB_MASKED = PREFIX + \"VFMSB_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFMSB_MASKED, \"vfmsb_masked\");\n+    }\n+\n+    public static final String VFNMAD_MASKED = PREFIX + \"VFNMAD_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFNMAD_MASKED, \"vfnmad_masked\");\n+    }\n+\n+    public static final String VFNMSB_MASKED = PREFIX + \"VFNMSB_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VFNMSB_MASKED, \"vfnmsb_masked\");\n+    }\n+\n+    public static final String VMASK_AND_NOT_L = PREFIX + \"VMASK_AND_NOT_L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_AND_NOT_L, \"vmask_and_notL\");\n+    }\n+\n+    public static final String VMLA = PREFIX + \"VMLA\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLA, \"vmla\");\n+    }\n+\n+    public static final String VMLA_MASKED = PREFIX + \"VMLA_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLA_MASKED, \"vmla_masked\");\n+    }\n+\n+    public static final String VMLS = PREFIX + \"VMLS\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLS, \"vmls\");\n+    }\n+\n+    public static final String VMLS_MASKED = PREFIX + \"VMLS_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMLS_MASKED, \"vmls_masked\");\n+    }\n+\n+    public static final String VNOT_I_MASKED = PREFIX + \"VNOT_I_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VNOT_I_MASKED, \"vnotI_masked\");\n+    }\n+\n+    public static final String VNOT_L_MASKED = PREFIX + \"VNOT_L_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VNOT_L_MASKED, \"vnotL_masked\");\n+    }\n+\n+    public static final String XOR = PREFIX + \"XOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR, \"Xor(I|L)\");\n+    }\n+\n+    public static final String XOR_I = PREFIX + \"XOR_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_I, \"XorI\");\n+    }\n+\n+    public static final String XOR_L = PREFIX + \"XOR_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_L, \"XorL\");\n+    }\n+\n+    public static final String XOR_V = PREFIX + \"XOR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V, \"XorV\");\n+    }\n+\n+    public static final String XOR_V_MASK = PREFIX + \"XOR_V_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V_MASK, \"XorVMask\");\n+    }\n+\n+    \/*\n+     * Utility methods to set up IR_NODE_MAPPINGS.\n+     *\/\n@@ -236,1 +1169,2 @@\n-     * Called by {@link IRMatcher} to merge special composite nodes together with additional user-defined input.\n+     * Apply {@code regex} on all machine independent ideal graph phases up to and including\n+     * {@link CompilePhase#BEFORE_MATCHING}.\n@@ -238,14 +1172,138 @@\n-    public static List<String> mergeNodes(String[] nodes) {\n-        List<String> mergedNodes = new ArrayList<>();\n-        for (int i = 0; i < nodes.length; i += 2) {\n-            String node = nodes[i];\n-            if (node.startsWith(COMPOSITE_PREFIX)) {\n-                if (i + 1 == nodes.length) {\n-                    reportMissingCompositeValue(node, i);\n-                }\n-                \/\/ Replace placeholder with user defined string.\n-                node = node.substring(COMPOSITE_PREFIX.length()).replaceAll(IS_REPLACED, nodes[i + 1]);\n-            } else {\n-                i--; \/\/ No composite node, do not increment by 2.\n-            }\n-            mergedNodes.add(node);\n+    private static void beforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}.\n+     *\/\n+    private static void beforeMatchingNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    private static void allocNodes(String irNode, String idealRegex, String optoRegex) {\n+        Map<PhaseInterval, String> intervalToRegexMap = new HashMap<>();\n+        intervalToRegexMap.put(new PhaseInterval(CompilePhase.BEFORE_REMOVEUSELESS, CompilePhase.PHASEIDEALLOOP_ITERATIONS),\n+                               idealRegex);\n+        intervalToRegexMap.put(new PhaseInterval(CompilePhase.PRINT_OPTO_ASSEMBLY), optoRegex);\n+        MultiPhaseRangeEntry entry = new MultiPhaseRangeEntry(CompilePhase.PRINT_OPTO_ASSEMBLY, intervalToRegexMap);\n+        IR_NODE_MAPPINGS.put(irNode, entry);\n+    }\n+\n+    private static void callOfNodes(String irNodePlaceholder, String callRegex) {\n+        String regex = START + callRegex + MID + IS_REPLACED + \" \" +  END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all machine dependant ideal graph phases (i.e. on the mach graph) starting from\n+     * {@link CompilePhase#MATCHING}.\n+     *\/\n+    private static void optoOnly(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.OPTO_ASSEMBLY, regex));\n+    }\n+\n+    private static void machOnly(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.MACH, regex));\n+    }\n+\n+    private static void machOnlyNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.MACH, regex));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#AFTER_CLOOPS}.\n+     *\/\n+    private static void fromAfterCountedLoops(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.AFTER_CLOOPS,\n+                                                                          CompilePhase.FINAL_CODE));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS}.\n+     *\/\n+    private static void fromBeforeCountedLoops(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.BEFORE_CLOOPS,\n+                                                                          CompilePhase.FINAL_CODE));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS} up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}\n+     *\/\n+    private static void fromMacroToBeforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.MACRO_EXPANSION,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_CLOOPS} up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}\n+     *\/\n+    private static void afterBarrierExpansionToBeforeMatching(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.OPTIMIZE_FINISHED,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    private static void trapNodes(String irNodePlaceholder, String trapReason) {\n+        String regex = START + \"CallStaticJava\" + MID + \"uncommon_trap.*\" + trapReason + END;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#PHASEIDEALLOOP1} which is the\n+     * first phase that could contain vector nodes from super word.\n+     *\/\n+    private static void superWordNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                          CompilePhase.PHASEIDEALLOOP1,\n+                                                                          CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+\n+    \/*\n+     * Methods used internally by the IR framework.\n+     *\/\n+\n+    \/**\n+     * Is {@code irNodeString} an IR node placeholder string?\n+     *\/\n+    public static boolean isIRNode(String irNodeString) {\n+        return irNodeString.startsWith(PREFIX);\n+    }\n+\n+    \/**\n+     * Is {@code irCompositeNodeString} an IR composite node placeholder string?\n+     *\/\n+    public static boolean isCompositeIRNode(String irCompositeNodeString) {\n+        return irCompositeNodeString.startsWith(COMPOSITE_PREFIX);\n+    }\n+\n+    \/**\n+     * Returns \"IRNode.XYZ\", where XYZ is one of the IR node placeholder variable names defined above.\n+     *\/\n+    public static String getIRNodeAccessString(String irNodeString) {\n+        int prefixLength;\n+        if (isCompositeIRNode(irNodeString)) {\n+            TestFramework.check(irNodeString.length() > COMPOSITE_PREFIX.length() + POSTFIX.length(),\n+                                \"Invalid composite node placeholder: \" + irNodeString);\n+            prefixLength = COMPOSITE_PREFIX.length();\n+        } else {\n+            prefixLength = PREFIX.length();\n@@ -253,1 +1311,1 @@\n-        return mergedNodes;\n+        return \"IRNode.\" + irNodeString.substring(prefixLength, irNodeString.length() - POSTFIX.length());\n@@ -257,2 +1315,2 @@\n-     * Is default regex supported on current platform, used VM build, etc.?\n-     * Throws a {@link CheckedTestFrameworkException} if the default regex is unsupported.\n+     * Is this IR node supported on current platform, used VM build, etc.?\n+     * Throws a {@link CheckedTestFrameworkException} if the IR node is unsupported.\n@@ -260,1 +1318,1 @@\n-    public static void checkDefaultRegexSupported(String node) throws CheckedTestFrameworkException {\n+    public static void checkIRNodeSupported(String node) throws CheckedTestFrameworkException {\n@@ -264,1 +1322,2 @@\n-                    throw new CheckedTestFrameworkException(\"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP is unsupported in builds without JVMCI.\");\n+                    throw new CheckedTestFrameworkException(\"INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP is unsupported \" +\n+                                                            \"in builds without JVMCI.\");\n@@ -272,1 +1331,6 @@\n-            \/\/ default: do nothing -> default regex is supported\n+            case IS_FINITE_D, IS_FINITE_F -> {\n+                if (!Platform.isRISCV64()) {\n+                    throw new CheckedTestFrameworkException(\"IS_FINITE_* is only supported on riscv64.\");\n+                }\n+            }\n+            \/\/ default: do nothing -> IR node is supported and can be used by the user.\n@@ -277,1 +1341,26 @@\n-     * Mapping from string variable value to string variable name for better error reporting.\n+     * Get the regex of an IR node for a specific compile phase. If {@code irNode} is not an IR node placeholder string\n+     * or if there is no regex specified for {@code compilePhase}, a {@link TestFormatException} is reported.\n+     *\/\n+    public static String getRegexForCompilePhase(String irNode, CompilePhase compilePhase) {\n+        IRNodeMapEntry entry = IR_NODE_MAPPINGS.get(irNode);\n+        String failMsg = \"IR Node \\\"\" + irNode + \"\\\" defined in class IRNode has no regex\/compiler phase mapping \" +\n+                         \"(i.e. no static initializer block that adds a mapping entry to IRNode.IR_NODE_MAPPINGS).\" +\n+                         System.lineSeparator() +\n+                         \"   Have you just created the entry \\\"\" + irNode + \"\\\" in class IRNode and forgot to add a \" +\n+                         \"mapping?\" + System.lineSeparator() +\n+                         \"   Violation\";\n+        TestFormat.checkNoReport(entry != null, failMsg);\n+        String regex = entry.regexForCompilePhase(compilePhase);\n+        failMsg = \"IR Node \\\"\" + irNode + \"\\\" defined in class IRNode has no regex defined for compile phase \"\n+                  + compilePhase + \".\" + System.lineSeparator() +\n+                  \"   If you think this compile phase should be supported, update the mapping for \\\"\" + irNode +\n+                  \"\\\" in class IRNode (i.e the static initializer block immediately following the definition of \\\"\" +\n+                  irNode + \"\\\").\" + System.lineSeparator() +\n+                  \"   Violation\";\n+        TestFormat.checkNoReport(regex != null, failMsg);\n+        return regex;\n+    }\n+\n+    \/**\n+     * Get the default phase of an IR node. If {@code irNode} is not an IR node placeholder string, a\n+     * {@link TestFormatException} is reported.\n@@ -279,30 +1368,13 @@\n-    private static void reportMissingCompositeValue(String node, int i) {\n-        String varName = switch (node) {\n-            case ALLOC_OF -> \"ALLOC_OF\";\n-            case ALLOC_ARRAY_OF -> \"ALLOC_ARRAY_OF\";\n-            case CHECKCAST_ARRAY_OF -> \"CHECKCAST_ARRAY_OF\";\n-            case STORE_OF_CLASS -> \"STORE_OF_CLASS\";\n-            case STORE_B_OF_CLASS -> \"STORE_B_OF_CLASS\";\n-            case STORE_C_OF_CLASS -> \"STORE_C_OF_CLASS\";\n-            case STORE_D_OF_CLASS -> \"STORE_D_OF_CLASS\";\n-            case STORE_F_OF_CLASS -> \"STORE_F_OF_CLASS\";\n-            case STORE_I_OF_CLASS -> \"STORE_I_OF_CLASS\";\n-            case STORE_L_OF_CLASS -> \"STORE_L_OF_CLASS\";\n-            case STORE_N_OF_CLASS -> \"STORE_N_OF_CLASS\";\n-            case STORE_P_OF_CLASS -> \"STORE_P_OF_CLASS\";\n-            case STORE_OF_FIELD -> \"STORE_OF_FIELD\";\n-            case LOAD_OF_CLASS -> \"LOAD_OF_CLASS\";\n-            case LOAD_B_OF_CLASS -> \"LOAD_B_OF_CLASS\";\n-            case LOAD_UB_OF_CLASS -> \"LOAD_UB_OF_CLASS\";\n-            case LOAD_D_OF_CLASS -> \"LOAD_D_OF_CLASS\";\n-            case LOAD_F_OF_CLASS -> \"LOAD_F_OF_CLASS\";\n-            case LOAD_I_OF_CLASS -> \"LOAD_I_OF_CLASS\";\n-            case LOAD_L_OF_CLASS -> \"LOAD_L_OF_CLASS\";\n-            case LOAD_N_OF_CLASS -> \"LOAD_N_OF_CLASS\";\n-            case LOAD_P_OF_CLASS -> \"LOAD_P_OF_CLASS\";\n-            case LOAD_S_OF_CLASS -> \"LOAD_S_OF_CLASS\";\n-            case LOAD_US_OF_CLASS -> \"LOAD_US_OF_CLASS\";\n-            case LOAD_OF_FIELD -> \"LOAD_OF_FIELD\";\n-            default -> throw new TestFrameworkException(\"Missing variable mapping for \" + node);\n-        };\n-        TestFormat.fail(\"Must provide additional value at index \" + (i + 1) + \" right after \" + varName);\n+    public static CompilePhase getDefaultPhase(String irNode) {\n+        IRNodeMapEntry entry = IR_NODE_MAPPINGS.get(irNode);\n+        String failMsg = \"\\\"\" + irNode + \"\\\" is not an IR node defined in class IRNode and \" +\n+                         \"has therefore no default compile phase specified.\" + System.lineSeparator() +\n+                         \"   If your regex represents a C2 IR node, consider adding an entry to class IRNode together \" +\n+                         \"with a static initializer block that adds a mapping to IRNode.IR_NODE_MAPPINGS.\" +\n+                         System.lineSeparator() +\n+                         \"   Otherwise, set the @IR \\\"phase\\\" attribute to a compile phase different from \" +\n+                         \"CompilePhase.DEFAULT to explicitly tell the IR framework on which compile phase your rule\" +\n+                         \" should be applied on.\" + System.lineSeparator() +\n+                         \"   Violation\";\n+        TestFormat.checkNoReport(entry != null, failMsg);\n+        return entry.defaultCompilePhase();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1312,"deletions":240,"binary":false,"changes":1552,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n+This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags `-XX:+PrintIdeal`, `-XX:CompileCommand=PrintIdealPhase` and\/or `-XX:+PrintOptoAssembly`. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n@@ -54,1 +54,1 @@\n-The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. For simplicity, we will refer to the \"IR\" or \"IR matching\" when actually meaning the combined output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ for a C2 compilation.\n+The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of `-XX:+PrintIdeal`, `-XX:+PrintOptoAssembly` and\/or on specific compile phases emitted by the compile command `-XX:CompileCommand=PrintIdealPhase` which supports the same set of compile phases as the Ideal Graph Visualizer (IGV).\n@@ -56,1 +56,1 @@\n-The user has the possibility to add an additional `@IR` annotation to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify a constraint\/rule on the compiled IR shape. The `@IR` annotation provides two kinds of regex checks:\n+The user has the possibility to add one or more `@IR` annotations to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify regex constraints\/rules on the compiled IR shape of any compile phase (for simplicity, the framework treats the output of `-XX:+PrintIdeal` and `-XX:+PrintOptoAssembly` as a separate compile phase next to the compile phases emitted by `-XX:CompileCommand=PrintIdealPhase`).\n@@ -58,2 +58,2 @@\n- - A `failOn` check that verifies that the provided regex is not matched in the C2 IR.\n- - A `counts` check that verifies that the provided regex is matched a user defined number of times in the C2 IR.\n+#### Pre-defined Regexes for IR Nodes\n+To perform a matching on a C2 IR node, the user can directly use the `public static final` strings defined in class [IRNode](.\/IRNode.java) which mostly represent either a real IR node or group of IR nodes as found in the C2 compiler as node classes (there are rare exceptions). These strings represent special placeholder strings (referred to as \"IR placeholder string\" or just \"IR node\") which are replaced by the framework by regexes depending on which compile phases (defined with attribute `phase` in [@IR](.\/IR.java)) the IR rule should be applied on. If an IR node placeholder string cannot be used for a specific compile phase (e.g. the IR node does not exist in this phase), a format violation will be reported.\n@@ -61,1 +61,1 @@\n-A regex can either be a custom string or any of the default regexes provided by the framework in [IRNode](.\/IRNode.java) for some commonly used IR nodes (also provides the possibility of composite regexes).\n+The exact mapping from an IR node placeholder string to regexes for different compile phases together with a default phase (see next section) is defined in a static block directly below the corresponding IR node placeholder string in [IRNode](.\/IRNode.java).\n@@ -63,1 +63,2 @@\n-An IR verification cannot always be performed. For example, a JTreg test could be run with _-Xint_ or not a debug build (_-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ are debug build flags). But also CI tier testing could add additional JTreg VM and Javaoptions flags which could make an IR rule unstable.\n+#### Composite IR Nodes\n+There are also special composite IR node placeholder strings which expect an additional user defined string which are then inserted in the final regex. For example, `IRNode.STORE_OF_FIELD` matches any store to the user defined field name. In the following `@IR` rule, we fail because we have a store to `iFld`:\n@@ -65,1 +66,7 @@\n-In general, the framework will only perform IR verification if the used VM flags allow a C2 compilation and if non-critical additional JTreg VM and Javaoptions are provided (see whiteflag list in [TestFramework](.\/TestFramework.java)). The user test code, however, can specify any flags which still allow an IR verification to be performed if a C2 compilation is done (expected flags by user defined `@IR` annotations).\n+```\n+@Test\n+@IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"})\n+public void test() {\n+    iFld = 34;\n+}\n+```\n@@ -67,1 +74,1 @@\n-An `@IR` annotation allows additional preconditions\/restrictions on the currently present VM flags to enable or disable rules when certain flags are present or have a specific value (see `applyIfXX` properties of an `@IR` annotation). If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction.\n+#### User-defined Regexes\n@@ -69,1 +76,33 @@\n-More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/IRExample.java) and [TestIRMatching](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java) (an internal framework test).\n+The user can also directly specify user-defined regexes in combination with a required compile phase (there is no default compile phase known by the framework for custom regexes). If such a user-defined regex represents a not yet supported C2 IR node, it is highly encouraged to directly add a new IR node placeholder string definition to [IRNode](.\/IRNode.java) for it instead together with a static regex mapping block.\n+\n+#### Default Compile Phase\n+When not specifying any compile phase with `phase` in [@IR](.\/IR.java) (or explicitly setting `CompilePhase.DEFAULT`), the framework will perform IR matching on a default compile phase which for most IR nodes is `CompilePhase.PRINT_IDEAL` (output of flag `-XX:+PrintIdeal`, the state of the machine independent ideal graph after applying optimizations). The default phase for each IR node is defined in the static regex mapping block below each IR node placeholder string in [IRNode](.\/IRNode.java).\n+\n+#### Two Kinds of IR Checks\n+The [@IR](.\/IR.java) annotation provides two kinds of checks:\n+\n+ - `failOn`: A list of one or more IR nodes\/user-defined regexes which are not allowed to occur in any compilation output of any compile phase.\n+ - `counts`: A list of one or more \"IR node\/user-defined regex - counter\" pairs which specify how often each IR node\/user-defined regex should be matched on the compilation output of each compile phase.\n+\n+#### Disable\/Enable IR Rules based on VM Flags\n+One might also want to restrict the application of certain `@IR` rules depending on the used flags in the test VM. These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted in `JTREG_WHITE_LIST_FLAGS` in [TestFramework](.\/TestFramework.java) (i.e. have no unexpected impact on the IR except if the flag simulates a specific machine setup like `UseAVX={1,2,3}` etc.) to enable an IR verification by the framework. The `@IR` rules thus have an option to restrict their application:\n+\n+- `applyIf`: Only apply a rule if a flag has the specified value\/range of values.\n+- `applyIfNot`: Only apply a rule if a flag has **not** a specified value\/range of values\n+               (inverse of `applyIf`).\n+- `applyIfAnd`: Only apply a rule if **all** flags have the specified value\/range of values.\n+- `applyIfOr`:  Only apply a rule if **at least one** flag has the specified value\/range of values.\n+\n+#### Disable\/Enable IR Rules based on available CPU Features\n+Sometimes, an `@IR` rule should only be applied if a certain CPU feature is present. This can be done with\n+the attributes `applyIfCPUFeatureXXX` in [@IR](.\/IR.java) which follow the same logic as the `applyIfXXX` methods for flags in the previous section. If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction. An example with `applyIfCPUFeatureXXX` can be found in [TestCPUFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestCPUFeatureCheck.java) (internal framework test).\n+\n+#### Implicitly Skipping IR Verification\n+An IR verification cannot always be performed. Certain VM flags explicitly disable IR verification, change the IR shape in unexpected ways letting IR rules fail or even make IR verification impossible:\n+\n+- `-DVerifyIR=false` is used\n+- The test is run with a non-debug build.\n+- `-Xcomp`, `-Xint`, `-XX:-UseCompile`, `-XX:CompileThreshold`, `-DFlipC1C2=true`, or `-DExcludeRandom=true` are used.\n+- JTreg specifies non-whitelisted flags as VM and\/or Javaoptions (could change the IR in unexpected ways).\n+\n+More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/IRExample.java), [TestIRMatching](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java) (internal framework test), and [TestPhaseIRMatching](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java) (internal framework test).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Enum to denote the regex type of the associated {@link CompilePhase}.\n+ *\n+ * @see CompilePhase\n+ *\/\n+public enum RegexType {\n+    IDEAL_INDEPENDENT, MACH, OPTO_ASSEMBLY\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RegexType.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -31,0 +31,2 @@\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n@@ -108,0 +110,1 @@\n+     * <p>\n@@ -304,2 +307,2 @@\n-        TestFormat.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n-                         \"A scenario cannot be null\");\n+        TestFormat.checkAndReport(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n+                                  \"A scenario cannot be null\");\n@@ -313,1 +316,1 @@\n-            TestFormat.check(scenarioIndices.add(scenarioIndex),\n+            TestFormat.checkNoThrow(scenarioIndices.add(scenarioIndex),\n@@ -317,0 +320,1 @@\n+        TestFormat.throwIfAnyFailures();\n@@ -328,0 +332,1 @@\n+        checkIRRuleCompilePhasesFormat();\n@@ -337,1 +342,0 @@\n-                System.out.println(\"Compilation(s) of failed match(es):\");\n@@ -347,0 +351,11 @@\n+    private void checkIRRuleCompilePhasesFormat() {\n+        for (Method method : testClass.getDeclaredMethods()) {\n+            for (IR irAnno : method.getAnnotationsByType(IR.class)) {\n+                TestFormat.checkNoThrow(irAnno.phase().length > 0,\n+                                        \"@IR rule \" + irAnno + \" must specify a non-empty list of compile \" +\n+                                        \"phases \\\"phase\\\" at \" + method);\n+            }\n+        }\n+        TestFormat.throwIfAnyFailures();\n+    }\n+\n@@ -378,1 +393,1 @@\n-        TestFormat.check(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n+        TestFormat.checkAndReport(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n@@ -628,2 +643,3 @@\n-                System.out.println((scenario != null ? \"Scenario #\" + scenario.getIndex() + \" - \" : \"\")\n-                                   + \"Compilation(s) of failed matche(s):\");\n+                if (scenario != null) {\n+                    System.out.println(\"Scenario #\" + scenario.getIndex());\n+                }\n@@ -711,1 +727,1 @@\n-        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class) != null);\n+        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class).length > 0);\n@@ -732,1 +748,5 @@\n-                new IRMatcher(testVMProcess.getHotspotPidFileName(), testVMProcess.getIrEncoding(), testClass);\n+                MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n+                Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                                             testVMProcess.getIrEncoding());\n+                IRMatcher matcher = new IRMatcher(testClassMatchable);\n+                matcher.match();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-                          + FlagVM.TEST_VM_FLAGS_FILE_POSTFIX;\n+                          + FlagVM.FILE_POSTFIX;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+\n+import java.util.Map;\n+\n+\/**\n+ * This class provides information about the compilation output of a compile phase for an {@link IRMethod}.\n+ *\/\n+public class Compilation {\n+    private final Map<CompilePhase, String> compilationOutputMap;\n+\n+    public Compilation(Map<CompilePhase, String> compilationOutputMap) {\n+        this.compilationOutputMap = compilationOutputMap;\n+    }\n+\n+    \/**\n+     * Is there a compilation output for {@code compilePhase}?\n+     *\/\n+    public boolean hasOutput(CompilePhase compilePhase) {\n+        return compilationOutputMap.containsKey(compilePhase);\n+    }\n+\n+    \/**\n+     * Get the compilation output for non-default compile phase {@code phase} or an empty string if no output was found\n+     * in the hotspot_pid* file for this compile phase.\n+     *\/\n+    public String output(CompilePhase compilePhase) {\n+        TestFramework.check(compilePhase != CompilePhase.DEFAULT, \"cannot query for DEFAULT\");\n+        return compilationOutputMap.getOrDefault(compilePhase, \"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/Compilation.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * Class to build the compilation output of IR matching failures.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-class CompilationOutputBuilder {\n-\n-    public static String build(List<IRMethodMatchResult> results) {\n-        StringBuilder compilationsBuilder = new StringBuilder();\n-        for (IRMethodMatchResult result : results) {\n-            if (result.fail()) {\n-                compilationsBuilder.append(buildMatchedCompilationMessage(result));\n-            }\n-        }\n-        return compilationsBuilder.toString();\n-    }\n-\n-    private static String buildMatchedCompilationMessage(IRMethodMatchResult result) {\n-        return result.getMatchedCompilationOutput() + System.lineSeparator() + System.lineSeparator();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/CompilationOutputBuilder.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -26,6 +26,3 @@\n-import compiler.lib.ir_framework.*;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n-import compiler.lib.ir_framework.driver.irmatching.parser.IRMethodParser;\n-\n-import java.util.*;\n+import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.report.CompilationOutputBuilder;\n+import compiler.lib.ir_framework.driver.irmatching.report.FailureMessageBuilder;\n@@ -34,1 +31,4 @@\n- * This class parses the hotspot_pid* file of the test VM to match all applicable @IR rules afterwards.\n+ * This class performs IR matching on the prepared {@link TestClass} object parsed by {@link MethodCompilationParser}.\n+ * All applicable @IR rules are matched with all their defined compilation phases. If there are any IR matching failures,\n+ * an {@link IRViolationException} is reported which provides a formatted failure message and the compilation outputs\n+ * of the failed compilation phases.\n@@ -38,0 +38,1 @@\n+    private final Matchable testClass;\n@@ -39,6 +40,2 @@\n-    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n-        IRMethodParser irMethodParser = new IRMethodParser(testClass);\n-        Collection<IRMethod> irMethods = irMethodParser.parse(hotspotPidFileName, irEncoding);\n-        if (irMethods != null) {\n-            applyIRRules(irMethods);\n-        }\n+    public IRMatcher(Matchable testClass) {\n+        this.testClass = testClass;\n@@ -48,1 +45,1 @@\n-     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link IRMethodParser}.\n+     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link MethodCompilationParser}.\n@@ -50,13 +47,2 @@\n-    private void applyIRRules(Collection<IRMethod> irMethods) {\n-        List<IRMethodMatchResult> results = new ArrayList<>();\n-        irMethods.forEach(irMethod -> applyIRRule(irMethod, results));\n-        if (!results.isEmpty()) {\n-            reportFailures(results);\n-        }\n-    }\n-\n-    private void applyIRRule(IRMethod irMethod, List<IRMethodMatchResult> results) {\n-        if (TestFramework.VERBOSE) {\n-            printMethodOutput(irMethod);\n-        }\n-        IRMethodMatchResult result = irMethod.applyIRRules();\n+    public void match() {\n+        MatchResult result = testClass.match();\n@@ -64,1 +50,1 @@\n-            results.add(result);\n+            reportFailures(result);\n@@ -68,5 +54,0 @@\n-    private void printMethodOutput(IRMethod irMethod) {\n-        System.out.println(\"Output of \" + irMethod.getOutput() + \":\");\n-        System.out.println(irMethod.getOutput());\n-    }\n-\n@@ -74,5 +55,3 @@\n-     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n-     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n-     * in both outputs then the entire output is reported. Throws IRViolationException from which the compilation\n-     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n-     * failures.\n+     * Report all IR violations in a pretty format to the user by throwing an {@link IRViolationException}. This includes\n+     * an exact description of the failure (method, rule, compile phase, check attribute, and constraint) and the\n+     * associated compile phase output of the failure.\n@@ -80,4 +59,4 @@\n-    private void reportFailures(List<IRMethodMatchResult> results) {\n-        Collections.sort(results); \/\/ Alphabetically\n-        throwIfNoSafepointWhilePrinting(IRMatcherFailureMessageBuilder.build(results),\n-                                        CompilationOutputBuilder.build(results));\n+    private void reportFailures(MatchResult result) {\n+        String failureMsg = new FailureMessageBuilder(result).build();\n+        String compilationOutput =  new CompilationOutputBuilder(result).build();\n+        throwIfNoSafepointWhilePrinting(failureMsg, compilationOutput);\n@@ -86,3 +65,5 @@\n-    \/\/ In some very rare cases, the VM output to regex match on contains \"<!-- safepoint while printing -->\"\n-    \/\/ (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n-    \/\/ Do not throw an exception in this case (i.e. bailout).\n+    \/**\n+     * In some very rare cases, the hotspot_pid* file to IR match on contains \"<!-- safepoint while printing -->\"\n+     * (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n+     * Do not throw an exception in this case (i.e. bailout).\n+     *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcher.java","additions":26,"deletions":45,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * Class to build the failure message output of IR matching failures.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-class IRMatcherFailureMessageBuilder {\n-\n-    public static String build(List<IRMethodMatchResult> results) {\n-        StringBuilder failuresBuilder = new StringBuilder();\n-        failuresBuilder.append(buildHeaderMessage(results));\n-        int failureNumber = 1;\n-        for (IRMethodMatchResult irMethodResult : results) {\n-            if (irMethodResult.fail()) {\n-                failuresBuilder.append(buildIRMethodFailureMessage(failureNumber, irMethodResult));\n-                failureNumber++;\n-            }\n-        }\n-        failuresBuilder.append(buildFooterMessage());\n-        return failuresBuilder.toString();\n-    }\n-\n-    private static String buildHeaderMessage(List<IRMethodMatchResult> results) {\n-        int failedIRRulesCount = getFailedIRRulesCount(results);\n-        long failedMethodCount = getFailedMethodCount(results);\n-        return \"One or more @IR rules failed:\" + System.lineSeparator() + System.lineSeparator()\n-               + \"Failed IR Rules (\" + failedIRRulesCount + \") of Methods (\" + failedMethodCount + \")\"\n-               + System.lineSeparator()\n-               +  \"-\".repeat(32 + digitCount(failedIRRulesCount) + digitCount(failedMethodCount))\n-               + System.lineSeparator();\n-    }\n-\n-    private static int getFailedIRRulesCount(List<IRMethodMatchResult> results) {\n-        return results.stream().map(IRMethodMatchResult::getFailedIRRuleCount).reduce(0, Integer::sum);\n-    }\n-\n-    private static long getFailedMethodCount(List<IRMethodMatchResult> results) {\n-        return results.stream().filter(IRMethodMatchResult::fail).count();\n-    }\n-\n-    private static int digitCount(long digit) {\n-        return String.valueOf(digit).length();\n-    }\n-\n-    private static String buildIRMethodFailureMessage(int failureNumber, IRMethodMatchResult result) {\n-        return failureNumber + \")\" + result.buildFailureMessage() + System.lineSeparator();\n-    }\n-\n-    private static String buildFooterMessage() {\n-        return \">>> Check stdout for compilation output of the failed methods\" + System.lineSeparator() + System.lineSeparator();\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcherFailureMessageBuilder.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -26,0 +26,3 @@\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n@@ -27,2 +30,4 @@\n- * Interface used by all classes which represent a IR match result. A result should also provide a failure message\n- * in a pretty format to be used by the {@link IRMatcher}.\n+ * This interface is implemented by all classes which represent an IR match result of a {@link Matchable} class.\n+ * A match result class accepts a {@link MatchResultVisitor} to visit the result (i.e. for reporting etc.).\n+ * The visitor is responsible to call {@link #accept(MatchResultVisitor)} of the children match results by using\n+ * {@link AcceptChildren#accept(MatchResultVisitor)}.\n@@ -32,1 +37,1 @@\n-     * Does this match result represent a failure?\n+     * Does this match result represent an IR match failure?\n@@ -37,1 +42,2 @@\n-     * Builds a failure message in a pretty format to be used by the IR matching failure reporting.\n+     * Allow a {@link MatchResultVisitor} to visit the match result which in turn invokes the visit methods of the\n+     * visitor.\n@@ -39,1 +45,1 @@\n-    String buildFailureMessage();\n+    void accept(MatchResultVisitor visitor);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/MatchResult.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+\/**\n+ * This interface is implemented by all classes on which an IR matching request can be performed.\n+ *\/\n+public interface Matchable {\n+    \/**\n+     * Apply matching on this IR matching entity class.\n+     *\/\n+    MatchResult match();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/Matchable.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/**\n+ * This class performs matching on a collection of {@link Matchable} objects. It returns a list of {@link MatchResult}\n+ * objects which failed or an empty list of there was not failure.\n+ *\/\n+public class MatchableMatcher {\n+    private final Collection<? extends Matchable> matchables;\n+\n+    public MatchableMatcher(Collection<? extends Matchable> matchables) {\n+        this.matchables = matchables;\n+    }\n+\n+    public List<MatchResult> match() {\n+        List<MatchResult> results = new ArrayList<>();\n+        for (Matchable matchable : matchables) {\n+            MatchResult matchResult = matchable.match();\n+            if (matchResult.fail()) {\n+                results.add(matchResult);\n+            }\n+        }\n+        return results;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/MatchableMatcher.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.SuccessResult;\n+\n+\/**\n+ * Test class that does not contain any applicable {@link IR @IR} annotations and therefore does not fail. It simply\n+ * returns a {@link SuccessResult} object when being matched.\n+ *\/\n+public class NonIRTestClass implements Matchable {\n+\n+    @Override\n+    public MatchResult match() {\n+        return SuccessResult.getInstance();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/NonIRTestClass.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-\/**\n- * Enum to describe what kind of compilation output that was matched for a method during IR matching.\n- *\n- * @see IRRuleMatchResult\n- *\/\n-public enum OutputMatch {\n-    \/**\n-     * There was no compilation output. Should not happen and results in a failure.\n-     *\/\n-    NONE,\n-    \/**\n-     * Matched on PrintIdeal.\n-     *\/\n-    IDEAL,\n-    \/**\n-     * Matched on PrintOptoAssembly.\n-     *\/\n-    OPTO_ASSEMBLY,\n-    \/**\n-     * Matched on PrintIdeal and PrintOptoAssembly.\n-     *\/\n-    BOTH\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/OutputMatch.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n+\n+import java.util.SortedSet;\n+\n+\/**\n+ * This class represents the user defined test class with which the IR framework was started (the class containing all\n+ * the {@link Test @Test}\/{@link IR @IR} annotated methods).\n+ *\n+ * @see Test\n+ * @see IRMethod\n+ * @see TestClassMatchResult\n+ *\/\n+public class TestClass implements Matchable {\n+    private final MatchableMatcher matcher;\n+\n+    public TestClass(SortedSet<IRMethodMatchable> irMethods) {\n+        TestFramework.check(!irMethods.isEmpty(), \"must not be empty\");\n+        this.matcher = new MatchableMatcher(irMethods);\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        return new TestClassMatchResult(matcher.match());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/TestClass.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a matching result of a {@link TestClass}. It contains all IR method results, sorted by\n+ * method names.\n+ *\n+ * @see TestClass\n+ *\/\n+public class TestClassMatchResult implements MatchResult {\n+    private final AcceptChildren acceptChildren;\n+    private final boolean failed;\n+\n+    public TestClassMatchResult(List<MatchResult> matchResults) {\n+        this.acceptChildren = new AcceptChildren(matchResults);\n+        this.failed = !matchResults.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return failed;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitTestClass(acceptChildren);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/TestClassMatchResult.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * Base class to build the failure message output for an IR method.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-abstract class FailureMessageBuilder {\n-    protected final IRMethod irMethod;\n-\n-    public FailureMessageBuilder(IRMethod irMethod) {\n-        this.irMethod = irMethod;\n-    }\n-\n-    abstract public String build();\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/FailureMessageBuilder.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import compiler.lib.ir_framework.CompilePhase;\n@@ -27,1 +28,5 @@\n-import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.MatchableMatcher;\n@@ -29,1 +34,2 @@\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -36,1 +42,6 @@\n- * Helper class to store information about a method that needs to be IR matched.\n+ * This class represents a {@link Test @Test} annotated method that has an associated non-empty list of applicable\n+ * {@link IR @IR} rules.\n+ *\n+ * @see IR\n+ * @see IRRule\n+ * @see IRMethodMatchResult\n@@ -38,1 +49,1 @@\n-public class IRMethod {\n+public class IRMethod implements IRMethodMatchable {\n@@ -40,5 +51,1 @@\n-    private final List<IRRule> irRules;\n-    private final StringBuilder outputBuilder;\n-    private String output;\n-    private String idealOutput;\n-    private String optoAssemblyOutput;\n+    private final MatchableMatcher matcher;\n@@ -46,1 +53,1 @@\n-    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos, Compilation compilation) {\n@@ -48,8 +55,1 @@\n-        this.irRules = new ArrayList<>();\n-        for (int i : ruleIds) {\n-            irRules.add(new IRRule(this, i, irAnnos[i - 1]));\n-        }\n-        this.outputBuilder = new StringBuilder();\n-        this.output = \"\";\n-        this.idealOutput = \"\";\n-        this.optoAssemblyOutput = \"\";\n+        this.matcher = new MatchableMatcher(createIRRules(method, ruleIds, irAnnos, compilation));\n@@ -58,13 +58,11 @@\n-    public Method getMethod() {\n-        return method;\n-    }\n-\n-\n-    \/**\n-     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n-     * Only keep the very last one by overriding 'output'.\n-     *\/\n-    public void setIdealOutput(String idealOutput) {\n-        outputBuilder.setLength(0);\n-        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n-        outputBuilder.append(this.idealOutput);\n+    private List<Matchable> createIRRules(Method method, int[] ruleIds, IR[] irAnnos, Compilation compilation) {\n+        List<Matchable> irRules = new ArrayList<>();\n+        for (int ruleId : ruleIds) {\n+            try {\n+                irRules.add(new IRRule(ruleId, irAnnos[ruleId - 1], compilation));\n+            } catch (TestFormatException e) {\n+                String postfixErrorMsg = \" for IR rule \" + ruleId + \" at \" + method + \".\";\n+                TestFormat.failNoThrow(e.getMessage() + postfixErrorMsg);\n+            }\n+        }\n+        return irRules;\n@@ -74,1 +72,1 @@\n-     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     * Used only for sorting.\n@@ -76,16 +74,3 @@\n-    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n-        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n-        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n-        output = outputBuilder.toString();\n-    }\n-\n-    public String getOutput() {\n-        return output;\n-    }\n-\n-    public String getIdealOutput() {\n-        return idealOutput;\n-    }\n-\n-    public String getOptoAssemblyOutput() {\n-        return optoAssemblyOutput;\n+    @Override\n+    public String name() {\n+        return method.getName();\n@@ -95,1 +80,2 @@\n-     * Apply all IR rules of this IR method.\n+     * Apply all IR rules of this method for each of the specified (or implied in case of\n+     * {@link CompilePhase#DEFAULT}) compile phases.\n@@ -97,18 +83,3 @@\n-    public IRMethodMatchResult applyIRRules() {\n-        TestFramework.check(!irRules.isEmpty(), \"IRMethod cannot be created if there are no IR rules to apply\");\n-        List<IRRuleMatchResult> results = new ArrayList<>();\n-        if (!output.isEmpty()) {\n-            return getNormalMatchResult(results);\n-        } else {\n-            return new MissingCompilationResult(this, irRules.size());\n-        }\n-    }\n-\n-    private NormalMatchResult getNormalMatchResult(List<IRRuleMatchResult> results) {\n-        for (IRRule irRule : irRules) {\n-            IRRuleMatchResult result = irRule.applyCheckAttribute();\n-            if (result.fail()) {\n-                results.add(result);\n-            }\n-        }\n-        return new NormalMatchResult(this, results);\n+    @Override\n+    public MatchResult match() {\n+        return new IRMethodMatchResult(method, matcher.match());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethod.java","additions":38,"deletions":67,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -27,1 +27,5 @@\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n@@ -30,1 +34,2 @@\n- * This base class represents an IR matching result of all IR rules of a method.\n+ * This class represents a matching result of an {@link IRMethod}. It contains a list of all IR rule match results\n+ * which could have been applied on different compile phases.\n@@ -32,1 +37,0 @@\n- * @see IRRuleMatchResult\n@@ -35,2 +39,5 @@\n-abstract public class IRMethodMatchResult implements Comparable<IRMethodMatchResult>, MatchResult {\n-    protected final IRMethod irMethod;\n+public class IRMethodMatchResult implements MatchResult {\n+    private final AcceptChildren acceptChildren;\n+    private final boolean failed;\n+    private final Method method;\n+    private final int failedIRRules;\n@@ -38,2 +45,5 @@\n-    IRMethodMatchResult(IRMethod irMethod) {\n-        this.irMethod = irMethod;\n+    public IRMethodMatchResult(Method method, List<MatchResult> matchResults) {\n+        this.acceptChildren = new AcceptChildren(matchResults);\n+        this.failed = !matchResults.isEmpty();\n+        this.method = method;\n+        this.failedIRRules = matchResults.size();\n@@ -42,3 +52,4 @@\n-    abstract public String getMatchedCompilationOutput();\n-\n-    abstract public int getFailedIRRuleCount();\n+    @Override\n+    public boolean fail() {\n+        return failed;\n+    }\n@@ -46,3 +57,0 @@\n-    \/**\n-     * Used to sort the failed IR methods alphabetically.\n-     *\/\n@@ -50,2 +58,2 @@\n-    public int compareTo(IRMethodMatchResult other) {\n-        return this.irMethod.getMethod().getName().compareTo(other.irMethod.getMethod().getName());\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitIRMethod(acceptChildren, method, failedIRRules);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethodMatchResult.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+\n+\/**\n+ * Interface for all matchable objects related to IR methods. These objects are sorted by the method name.\n+ *\n+ * @see IRMethod\n+ * @see NotCompiledIRMethod\n+ *\/\n+public interface IRMethodMatchable extends Matchable, Comparable<IRMethodMatchable> {\n+    String name();\n+\n+    \/**\n+     * Sort by method name.\n+     *\/\n+    @Override\n+    default int compareTo(IRMethodMatchable other) {\n+        return this.name().compareTo(other.name());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethodMatchable.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-import compiler.lib.ir_framework.shared.TestFrameworkException;\n-\n-import java.util.List;\n-\n-\/**\n- * Class to build the compilation output for an IR method.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-class MatchedCompilationOutputBuilder {\n-    private final IRMethod irMethod;\n-    private final OutputMatch outputMatch;\n-\n-    public MatchedCompilationOutputBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n-        this.irMethod = irMethod;\n-        this.outputMatch = getOutputMatch(irRulesMatchResults);\n-    }\n-\n-    private OutputMatch getOutputMatch(List<IRRuleMatchResult> irRulesMatchResults) {\n-        OutputMatch outputMatch;\n-        if (allMatchesOn(irRulesMatchResults, OutputMatch.IDEAL)) {\n-            outputMatch = OutputMatch.IDEAL;\n-        } else if (allMatchesOn(irRulesMatchResults, OutputMatch.OPTO_ASSEMBLY)) {\n-            outputMatch = OutputMatch.OPTO_ASSEMBLY;\n-        } else {\n-            outputMatch = OutputMatch.BOTH;\n-        }\n-        return outputMatch;\n-    }\n-\n-    private boolean allMatchesOn(List<IRRuleMatchResult> irRulesMatchResults, OutputMatch outputMatch) {\n-        return irRulesMatchResults.stream().allMatch(r -> r.getOutputMatch() == outputMatch);\n-    }\n-\n-    public String build() {\n-        StringBuilder builder = new StringBuilder();\n-        builder.append(getMethodLine());\n-        switch (outputMatch) {\n-            case IDEAL -> builder.append(irMethod.getIdealOutput());\n-            case OPTO_ASSEMBLY -> builder.append(irMethod.getOptoAssemblyOutput());\n-            case BOTH -> builder.append(irMethod.getOutput());\n-            default -> throw new TestFrameworkException(\"found unexpected OutputMatch \" + outputMatch.name());\n-        }\n-        return builder.toString();\n-    }\n-\n-    private String getMethodLine() {\n-        return \">>> Compilation of \" + irMethod.getMethod() + \":\" + System.lineSeparator();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MatchedCompilationOutputBuilder.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * Class to build the failure message output for an IR method with a missing compilation output.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-class MissingCompilationMessageBuilder extends FailureMessageBuilder {\n-\n-    public MissingCompilationMessageBuilder(IRMethod irMethod) {\n-        super(irMethod);\n-    }\n-\n-    @Override\n-    public String build() {\n-        return getMethodLine() + getMissingCompilationMessage();\n-    }\n-\n-    private String getMissingCompilationMessage() {\n-        return \"   * Method was not compiled. Did you specify any compiler directives preventing a compilation \"\n-               + \"or used a @Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 \"\n-               + \"compilation by \" + \"invoking the test enough times.\";\n-    }\n-    private String getMethodLine() {\n-        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationMessageBuilder.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-\/**\n- * This class represents an IR matching result where the compilation output was empty.\n- *\n- * @see IRRuleMatchResult\n- * @see IRMethod\n- *\/\n-public class MissingCompilationResult extends IRMethodMatchResult {\n-    private final int failedIRRules;\n-    private final MissingCompilationMessageBuilder failureMessageBuilder;\n-\n-    MissingCompilationResult(IRMethod irMethod, int failedIRRules) {\n-        super(irMethod);\n-        this.failedIRRules = failedIRRules;\n-        this.failureMessageBuilder = new MissingCompilationMessageBuilder(irMethod);\n-    }\n-\n-    @Override\n-    public boolean fail() {\n-        return true;\n-    }\n-\n-    @Override\n-    public String getMatchedCompilationOutput() {\n-        return \"<empty>\";\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return failureMessageBuilder.build();\n-    }\n-\n-    private String getMethodLine() {\n-        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n-    }\n-\n-    @Override\n-    public int getFailedIRRuleCount() {\n-        return failedIRRules;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationResult.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Class to build the failure message output for an IR method for failed IR rules.\n- *\n- * @see IRMethodMatchResult\n- *\/\n-class NormalFailureMessageBuilder extends FailureMessageBuilder {\n-    private final List<IRRuleMatchResult> irRulesMatchResults;\n-\n-    public NormalFailureMessageBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n-        super(irMethod);\n-        this.irRulesMatchResults = irRulesMatchResults.stream()\n-                                                      .filter(IRRuleMatchResult::fail)\n-                                                      .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public String build() {\n-        return getMethodLine() + getIRRulesFailureMessage();\n-    }\n-\n-    private String getMethodLine() {\n-        int failures = irRulesMatchResults.size();\n-        return \" Method \\\"\" + irMethod.getMethod() + \"\\\" - [Failed IR rules: \" + failures + \"]:\"\n-               + System.lineSeparator();\n-    }\n-\n-    private String getIRRulesFailureMessage() {\n-        StringBuilder failMsg = new StringBuilder();\n-        for (IRRuleMatchResult irRuleResult : irRulesMatchResults) {\n-            failMsg.append(irRuleResult.buildFailureMessage());\n-        }\n-        return failMsg.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalFailureMessageBuilder.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irmethod;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * This class represents a normal IR matching result of all IR rules of a method.\n- *\n- * @see IRRuleMatchResult\n- * @see IRMethod\n- *\/\n-class NormalMatchResult extends IRMethodMatchResult {\n-    private final List<IRRuleMatchResult> irRulesMatchResults;\n-    private final NormalFailureMessageBuilder failureMessageBuilder;\n-    private final MatchedCompilationOutputBuilder matchedCompilationOutputBuilder;\n-\n-    NormalMatchResult(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n-        super(irMethod);\n-        this.irRulesMatchResults = irRulesMatchResults;\n-        this.failureMessageBuilder = new NormalFailureMessageBuilder(irMethod, irRulesMatchResults);\n-        this.matchedCompilationOutputBuilder = new MatchedCompilationOutputBuilder(irMethod, irRulesMatchResults);\n-    }\n-\n-    @Override\n-    public boolean fail() {\n-        return !irRulesMatchResults.isEmpty();\n-    }\n-\n-    @Override\n-    public String getMatchedCompilationOutput() {\n-        return matchedCompilationOutputBuilder.build();\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return failureMessageBuilder.build();\n-    }\n-\n-    @Override\n-    public int getFailedIRRuleCount() {\n-        return irRulesMatchResults.size();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalMatchResult.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunMode;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class represents a special IR method which was not compiled by the IR framework. This could happen when a\n+ * method is not invoked enough times by a {@link Run @Run} method in {@link RunMode#STANDALONE} mode to be C2 compiled.\n+ *\n+ * @see IR\n+ * @see Run\n+ *\/\n+public class NotCompiledIRMethod implements IRMethodMatchable {\n+    private final Method method;\n+    private final int ruleCount;\n+\n+    public NotCompiledIRMethod(Method method, int ruleCount) {\n+        this.method = method;\n+        this.ruleCount = ruleCount;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return method.getName();\n+    }\n+\n+    \/**\n+     * Directly return a {@link NotCompiledIRMethodMatchResult} as we do not need to match IR rules individually.\n+     *\/\n+    @Override\n+    public NotCompiledIRMethodMatchResult match() {\n+        return new NotCompiledIRMethodMatchResult(method, ruleCount);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompiledIRMethod.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunMode;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class represents a special matching result of an IR method where the compilation output was completely empty.\n+ * This could happen when using {@link RunMode#STANDALONE} in a {@link Run @Run} method.\n+ *\n+ * @see NotCompiledIRMethod\n+ * @see Run\n+ *\/\n+public class NotCompiledIRMethodMatchResult implements MatchResult {\n+    private final Method method;\n+    private final int failedIRRules;\n+\n+    public NotCompiledIRMethodMatchResult(Method method, int failedIRRules) {\n+        this.method = method;\n+        this.failedIRRules = failedIRRules;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitMethodNotCompiled(method, failedIRRules);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NotCompiledIRMethodMatchResult.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-\n-\/**\n- * Base class representing a check attribute of an IR rule.\n- *\n- * @see IR\n- *\/\n-abstract class CheckAttribute {\n-\n-    abstract public CheckAttributeMatchResult apply(String compilation);\n-\n-    protected List<String> getMatchedNodes(Matcher m) {\n-        List<String> matches = new ArrayList<>();\n-        do {\n-            matches.add(m.group());\n-        } while (m.find());\n-        return matches;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttribute.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n-\n-import java.util.List;\n-\n-\/**\n- * Base class representing a result of an applied check attribute of an IR rule.\n- *\n- * @see IR\n- *\/\n-abstract class CheckAttributeMatchResult implements MatchResult {\n-    protected List<RegexFailure> regexFailures = null;\n-\n-    @Override\n-    public boolean fail() {\n-        return regexFailures != null;\n-    }\n-\n-    public int getMatchesCount() {\n-        if (fail()) {\n-            return regexFailures.stream().map(RegexFailure::getMatchesCount).reduce(0, Integer::sum);\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n-    protected String collectRegexFailureMessages() {\n-        StringBuilder failMsg = new StringBuilder();\n-        for (RegexFailure regexFailure : regexFailures) {\n-            failMsg.append(regexFailure.buildFailureMessage());\n-        }\n-        return failMsg.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttributeMatchResult.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-import compiler.lib.ir_framework.shared.Comparison;\n-import compiler.lib.ir_framework.shared.ComparisonConstraintParser;\n-import compiler.lib.ir_framework.shared.TestFormat;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.MatchResult;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Class representing a counts attribute of an IR rule.\n- *\n- * @see IR#counts()\n- *\/\n-class Counts extends CheckAttribute {\n-    public List<Constraint> constraints;\n-\n-    private Counts(List<Constraint> constraints) {\n-        this.constraints = constraints;\n-    }\n-\n-    public static Counts create(List<String> nodesWithCountConstraint, IRRule irRule) {\n-        List<Constraint> constraints = new ArrayList<>();\n-        int nodeId = 1;\n-        for (int i = 0; i < nodesWithCountConstraint.size(); i += 2, nodeId++) {\n-            String node = nodesWithCountConstraint.get(i);\n-            TestFormat.check(i + 1 < nodesWithCountConstraint.size(),\n-                             \"Missing count \" + getPostfixErrorMsg(irRule, node));\n-            String countConstraint = nodesWithCountConstraint.get(i + 1);\n-            Comparison<Integer> comparison = parseComparison(irRule, node, countConstraint);\n-            constraints.add(new Constraint(node, comparison, nodeId));\n-        }\n-        return new Counts(constraints);\n-    }\n-\n-    private static String getPostfixErrorMsg(IRRule irRule, String node) {\n-        return \"for IR rule \" + irRule.getRuleId() + \", node \\\"\" + node + \"\\\" at \" + irRule.getMethod();\n-    }\n-\n-    private static Comparison<Integer> parseComparison(IRRule irRule, String node, String constraint) {\n-        String postfixErrorMsg = \"in count constraint \" + getPostfixErrorMsg(irRule, node);\n-        return ComparisonConstraintParser.parse(constraint, Integer::parseInt, postfixErrorMsg);\n-    }\n-\n-    @Override\n-    public CheckAttributeMatchResult apply(String compilation) {\n-        CountsMatchResult result = new CountsMatchResult();\n-        checkConstraints(result, compilation);\n-        return result;\n-    }\n-\n-    private void checkConstraints(CountsMatchResult result, String compilation) {\n-        for (Constraint constraint : constraints) {\n-            checkConstraint(result, compilation, constraint);\n-        }\n-    }\n-\n-    private void checkConstraint(CountsMatchResult result, String compilation, Constraint constraint) {\n-        List<String> countsMatches = getCountsMatches(compilation, constraint);\n-        Comparison<Integer> comparison = constraint.comparison;\n-        if (!comparison.compare(countsMatches.size())) {\n-            result.addFailure(createRegexFailure(countsMatches, constraint));\n-        }\n-    }\n-\n-    private List<String> getCountsMatches(String compilation, Constraint constraint) {\n-        Pattern pattern = Pattern.compile(constraint.nodeRegex);\n-        Matcher matcher = pattern.matcher(compilation);\n-        return matcher.results().map(MatchResult::group).collect(Collectors.toList());\n-    }\n-\n-    private CountsRegexFailure createRegexFailure(List<String> countsMatches, Constraint constraint) {\n-        return new CountsRegexFailure(constraint.nodeRegex, constraint.nodeId, countsMatches.size(), constraint.comparison,\n-                                      countsMatches);\n-    }\n-\n-    static class Constraint {\n-        final String nodeRegex;\n-        final Comparison<Integer> comparison;\n-        private final int nodeId;\n-\n-        Constraint(String nodeRegex, Comparison<Integer> comparison, int nodeId) {\n-            this.nodeRegex = nodeRegex;\n-            this.comparison = comparison;\n-            this.nodeId = nodeId;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/Counts.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.util.ArrayList;\n-\n-\/**\n- * Class representing a result of an applied counts attribute of an IR rule.\n- *\n- * @see IR#counts()\n- *\/\n-class CountsMatchResult extends CheckAttributeMatchResult {\n-\n-    public void addFailure(RegexFailure regexFailure) {\n-        if (regexFailures == null) {\n-            regexFailures = new ArrayList<>();\n-        }\n-        regexFailures.add(regexFailure);\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return \"     - counts: Graph contains wrong number of nodes:\" + System.lineSeparator()\n-               + collectRegexFailureMessages();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsMatchResult.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.shared.Comparison;\n-\n-import java.util.List;\n-\n-\/**\n- * This class represents an IR matching failure of a regex of a counts attribute of an IR rule.\n- *\n- * @see Counts\n- *\/\n-class CountsRegexFailure extends RegexFailure {\n-    String failedComparison;\n-\n-    public CountsRegexFailure(String nodeRegex, int nodeId, int foundValue, Comparison<Integer> comparison,\n-                              List<String> matches) {\n-        super(nodeRegex, nodeId, matches);\n-        this.failedComparison = \"[found] \" + foundValue + \" \" + comparison.getComparator() + \" \"\n-                                + comparison.getGivenValue() + \" [given]\";\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return getRegexLine()\n-               + getFailedComparison()\n-               + getMatchedNodesBlock();\n-    }\n-\n-    private String getFailedComparison() {\n-        return \"         - Failed comparison: \" + failedComparison + System.lineSeparator();\n-    }\n-\n-    @Override\n-    protected String getMatchedNodesBlock() {\n-        if (matches.isEmpty()) {\n-            return getEmptyNodeMatchesLine();\n-        } else {\n-            return super.getMatchedNodesBlock();\n-        }\n-    }\n-\n-    private String getEmptyNodeMatchesLine() {\n-        return getMatchedNodesWhiteSpace() + \"- No nodes matched!\" + System.lineSeparator();\n-    }\n-\n-    @Override\n-    protected String getMatchedPrefix() {\n-        return \"Matched\";\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsRegexFailure.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Class representing a failOn attribute of an IR rule.\n- *\n- * @see IR#failOn()\n- *\/\n-class FailOn extends CheckAttribute {\n-    private final Pattern quickPattern;\n-    private final List<String> nodes;\n-\n-    public FailOn(List<String> nodes) {\n-        this.nodes = nodes;\n-        this.quickPattern = Pattern.compile(String.join(\"|\", nodes));\n-    }\n-\n-    @Override\n-    public CheckAttributeMatchResult apply(String compilation) {\n-        FailOnMatchResult result = new FailOnMatchResult();\n-        Matcher matcher = quickPattern.matcher(compilation);\n-        if (matcher.find()) {\n-            result.setFailures(createFailOnFailures(compilation));\n-        }\n-        return result;\n-    }\n-\n-    private List<RegexFailure> createFailOnFailures(String compilation) {\n-        List<RegexFailure> regexFailures = new ArrayList<>();\n-        for (int i = 0; i < nodes.size(); i++) {\n-            checkNode(regexFailures, compilation, nodes.get(i), i + 1);\n-        }\n-        return regexFailures;\n-    }\n-\n-    private void checkNode(List<RegexFailure> regexFailures, String compilation, String node, int nodeId) {\n-        Pattern p = Pattern.compile(node);\n-        Matcher m = p.matcher(compilation);\n-        if (m.find()) {\n-            List<String> matches = getMatchedNodes(m);\n-            regexFailures.add(new FailOnRegexFailure(node, nodeId, matches));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOn.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.util.List;\n-\n-\/**\n- * Class representing a result of an applied failOn attribute of an IR rule.\n- *\n- * @see IR#failOn()\n- *\/\n-class FailOnMatchResult extends CheckAttributeMatchResult {\n-    public void setFailures(List<RegexFailure> regexFailures) {\n-        this.regexFailures = regexFailures;\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return \"     - failOn: Graph contains forbidden nodes:\" + System.lineSeparator()\n-               + collectRegexFailureMessages();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnMatchResult.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import java.util.List;\n-\n-\/**\n- * This class represents an IR matching failure of a regex of a failOn attribute of an IR rule.\n- *\n- * @see FailOn\n- *\/\n-class FailOnRegexFailure extends RegexFailure {\n-\n-    public FailOnRegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n-        super(nodeRegex, nodeId, matches);\n-    }\n-\n-    @Override\n-    public String buildFailureMessage() {\n-        return getRegexLine()\n-               + getMatchedNodesBlock();\n-    }\n-\n-    @Override\n-    protected String getMatchedPrefix() {\n-        return \"Matched forbidden\";\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnRegexFailure.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -28,9 +28,15 @@\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n-import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n-import compiler.lib.ir_framework.shared.*;\n-\n-import java.lang.reflect.Method;\n-import java.util.function.Consumer;\n-\n-public class IRRule {\n-    private final IRMethod irMethod;\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.MatchableMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.phase.CompilePhaseIRRule;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.phase.CompilePhaseIRRuleBuilder;\n+\n+\/**\n+ * This class represents a generic {@link IR @IR} rule of an IR method. It contains a list of compile phase specific\n+ * IR rule versions where {@link IRNode} placeholder strings of are replaced by regexes associated with the compile phase.\n+ *\n+ * @see CompilePhaseIRRule\n+ * @see IRRuleMatchResult\n+ *\/\n+public class IRRule implements Matchable {\n@@ -39,2 +45,1 @@\n-    private final FailOn failOn;\n-    private final Counts counts;\n+    private final MatchableMatcher matcher;\n@@ -42,2 +47,1 @@\n-    public IRRule(IRMethod irMethod, int ruleId, IR irAnno) {\n-        this.irMethod = irMethod;\n+    public IRRule(int ruleId, IR irAnno, Compilation compilation) {\n@@ -46,95 +50,1 @@\n-        this.failOn = initFailOn(irAnno);\n-        this.counts = initCounts(irAnno);\n-    }\n-\n-    private Counts initCounts(IR irAnno) {\n-        String[] countsConstraints = irAnno.counts();\n-        if (countsConstraints.length != 0) {\n-            try {\n-                return Counts.create(IRNode.mergeNodes(countsConstraints), this);\n-            } catch (TestFormatException e) {\n-                \/\/ Logged and reported later. Continue.\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private FailOn initFailOn(IR irAnno) {\n-        String[] failOnNodes = irAnno.failOn();\n-        if (failOnNodes.length != 0) {\n-            return new FailOn(IRNode.mergeNodes(failOnNodes));\n-        }\n-        return null;\n-    }\n-\n-    public int getRuleId() {\n-        return ruleId;\n-    }\n-\n-    public IR getIRAnno() {\n-        return irAnno;\n-    }\n-\n-    public Method getMethod() {\n-        return irMethod.getMethod();\n-    }\n-\n-    \/**\n-     * Apply this IR rule by checking any failOn and counts attributes.\n-     *\/\n-    public IRRuleMatchResult applyCheckAttribute() {\n-        IRRuleMatchResult result = new IRRuleMatchResult(this);\n-        if (failOn != null) {\n-            applyCheckAttribute(failOn, result, result::setFailOnFailures);\n-        }\n-        if (counts != null) {\n-            applyCheckAttribute(counts, result, result::setCountsFailures);\n-        }\n-        return result;\n-    }\n-\n-    private void applyCheckAttribute(CheckAttribute checkAttribute, IRRuleMatchResult result,\n-                                     Consumer<CheckAttributeMatchResult> setFailures) {\n-        CheckAttributeMatchResult checkAttributeResult = checkAttribute.apply(irMethod.getOutput());\n-        if (checkAttributeResult.fail()) {\n-            setFailures.accept(checkAttributeResult);\n-            result.updateOutputMatch(getOutputMatch(checkAttribute, checkAttributeResult));\n-        }\n-    }\n-\n-    \/**\n-     * Determine how the output was matched by reapplying the check attribute for the PrintIdeal and PrintOptoAssembly\n-     * output separately.\n-     *\/\n-    private OutputMatch getOutputMatch(CheckAttribute checkAttribute, CheckAttributeMatchResult checkAttributeResult) {\n-        int totalMatches = checkAttributeResult.getMatchesCount();\n-        int idealFailuresCount = getMatchesCount(checkAttribute, irMethod.getIdealOutput());\n-        int optoAssemblyFailuresCount = getMatchesCount(checkAttribute, irMethod.getOptoAssemblyOutput());\n-        return findOutputMatch(totalMatches, idealFailuresCount, optoAssemblyFailuresCount);\n-    }\n-\n-    private int getMatchesCount(CheckAttribute checkAttribute, String compilation) {\n-        CheckAttributeMatchResult result = checkAttribute.apply(compilation);\n-        return result.getMatchesCount();\n-    }\n-\n-    \/**\n-     * Compare different counts to find out, on what output a failure was matched.\n-     *\/\n-    private OutputMatch findOutputMatch(int totalMatches, int idealFailuresCount, int optoAssemblyFailuresCount) {\n-        if (totalMatches == 0\n-            || someRegexMatchOnlyEntireOutput(totalMatches, idealFailuresCount, optoAssemblyFailuresCount)\n-            || anyMatchOnIdealAndOptoAssembly(idealFailuresCount, optoAssemblyFailuresCount)) {\n-            return OutputMatch.BOTH;\n-        } else if (optoAssemblyFailuresCount == 0) {\n-            return OutputMatch.IDEAL;\n-        } else {\n-            return OutputMatch.OPTO_ASSEMBLY;\n-        }\n-    }\n-\n-    \/**\n-     * Do we have a regex that is only matched on the entire ideal + opto assembly output?\n-     *\/\n-    private boolean someRegexMatchOnlyEntireOutput(int totalCount, int idealFailuresCount, int optoAssemblyFailuresCount) {\n-        return totalCount != idealFailuresCount + optoAssemblyFailuresCount;\n+        this.matcher = new MatchableMatcher(new CompilePhaseIRRuleBuilder(irAnno, compilation).build());\n@@ -143,5 +53,3 @@\n-    \/**\n-     * Do we have a match on ideal and opto assembly for this rule?\n-     *\/\n-    private boolean anyMatchOnIdealAndOptoAssembly(int idealFailuresCount, int optoAssemblyFailuresCount) {\n-        return idealFailuresCount > 0 && optoAssemblyFailuresCount > 0;\n+    @Override\n+    public MatchResult match() {\n+        return new IRRuleMatchResult(ruleId, irAnno, matcher.match());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRule.java","additions":21,"deletions":113,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n@@ -28,1 +29,5 @@\n-import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.phase.CompilePhaseIRRuleMatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.util.List;\n@@ -31,1 +36,3 @@\n- * This class represents an IR matching result of an IR rule.\n+ * This class represents a match result of an {@link IRRule} (applied to all compile phases specified in\n+ * {@link IR#phase()}). The {@link CompilePhaseIRRuleMatchResult} are kept in the definition order of the compile phases\n+ * in {@link CompilePhase}.\n@@ -33,1 +40,0 @@\n- * @see CheckAttributeMatchResult\n@@ -37,17 +43,4 @@\n-    private final IRRule irRule;\n-    private CheckAttributeMatchResult failOnFailures = null;\n-    private CheckAttributeMatchResult countsFailures = null;\n-    private OutputMatch outputMatch;\n-\n-    public IRRuleMatchResult(IRRule irRule) {\n-        this.irRule = irRule;\n-        this.outputMatch = OutputMatch.NONE;\n-    }\n-\n-    private boolean hasFailOnFailures() {\n-        return failOnFailures != null;\n-    }\n-\n-    public void setFailOnFailures(CheckAttributeMatchResult failOnFailures) {\n-        this.failOnFailures = failOnFailures;\n-    }\n+    private final AcceptChildren acceptChildren;\n+    private final boolean failed;\n+    private final int irRuleId;\n+    private final IR irAnno;\n@@ -55,10 +48,5 @@\n-    private boolean hasCountsFailures() {\n-        return countsFailures != null;\n-    }\n-\n-    public void setCountsFailures(CheckAttributeMatchResult countsFailures) {\n-        this.countsFailures = countsFailures;\n-    }\n-\n-    public OutputMatch getOutputMatch() {\n-        return outputMatch;\n+    public IRRuleMatchResult(int irRuleId, IR irAnno, List<MatchResult> matchResults) {\n+        this.acceptChildren = new AcceptChildren(matchResults);\n+        this.failed = !matchResults.isEmpty();\n+        this.irRuleId = irRuleId;\n+        this.irAnno = irAnno;\n@@ -69,1 +57,1 @@\n-        return failOnFailures != null || countsFailures != null;\n+        return failed;\n@@ -72,14 +60,0 @@\n-    public void updateOutputMatch(OutputMatch newOutputMatch) {\n-        TestFramework.check(newOutputMatch != OutputMatch.NONE, \"must be valid state\");\n-        switch (outputMatch) {\n-            case NONE -> outputMatch = newOutputMatch;\n-            case IDEAL -> outputMatch = newOutputMatch != OutputMatch.IDEAL\n-                    ? OutputMatch.BOTH : OutputMatch.IDEAL;\n-            case OPTO_ASSEMBLY -> outputMatch = newOutputMatch != OutputMatch.OPTO_ASSEMBLY\n-                    ? OutputMatch.BOTH : OutputMatch.OPTO_ASSEMBLY;\n-        }\n-    }\n-\n-    \/**\n-     * Build a failure message based on the collected failures of this object.\n-     *\/\n@@ -87,14 +61,2 @@\n-    public String buildFailureMessage() {\n-        StringBuilder failMsg = new StringBuilder();\n-        failMsg.append(getIRRuleLine());\n-        if (hasFailOnFailures()) {\n-            failMsg.append(failOnFailures.buildFailureMessage());\n-        }\n-        if (hasCountsFailures()) {\n-            failMsg.append(countsFailures.buildFailureMessage());\n-        }\n-        return failMsg.toString();\n-    }\n-\n-    private String getIRRuleLine() {\n-        return \"   * @IR rule \" + irRule.getRuleId() + \": \\\"\" + irRule.getIRAnno() + \"\\\"\" + System.lineSeparator();\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitIRRule(acceptChildren, irRuleId, irAnno);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRuleMatchResult.java","additions":22,"deletions":60,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.irrule;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Base class representing an IR matching failure of a regex of a check attribute of an IR rule.\n- *\n- * @see CheckAttributeMatchResult\n- * @see CheckAttribute\n- * @see IRRule\n- *\/\n-abstract class RegexFailure {\n-    protected final String nodeRegex;\n-    protected final int nodeId;\n-    protected final List<String> matches;\n-\n-    public RegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n-        this.nodeRegex = nodeRegex;\n-        this.nodeId = nodeId;\n-        this.matches = addWhiteSpacePrefixForEachLine(matches);\n-    }\n-\n-    private List<String> addWhiteSpacePrefixForEachLine(List<String> matches) {\n-        return matches\n-                .stream()\n-                .map(s -> s.replaceAll(System.lineSeparator(), System.lineSeparator()\n-                                                               + getMatchedNodesItemWhiteSpace() + \"  \"))\n-                .collect(Collectors.toList());\n-    }\n-\n-    abstract public String buildFailureMessage();\n-\n-    public int getMatchesCount() {\n-        return matches.size();\n-    }\n-\n-    protected String getRegexLine() {\n-        return \"       * Regex \" + nodeId + \": \" + nodeRegex + System.lineSeparator();\n-    }\n-\n-    protected String getMatchedNodesBlock() {\n-        return getMatchedNodesHeader() + getMatchesNodeLines();\n-    }\n-\n-    protected String getMatchedNodesHeader() {\n-        int matchCount = matches.size();\n-        return \"\" + getMatchedNodesWhiteSpace() + \"- \" + getMatchedPrefix() + \" node\"\n-               + (matchCount != 1 ? \"s (\" + matchCount + \")\" : \"\") + \":\" + System.lineSeparator();\n-    }\n-\n-    protected String getMatchedNodesWhiteSpace() {\n-        return \"         \";\n-    }\n-\n-    abstract protected String getMatchedPrefix();\n-\n-    protected String getMatchesNodeLines() {\n-        StringBuilder builder = new StringBuilder();\n-        matches.forEach(match -> builder.append(getMatchedNodesItemWhiteSpace()).append(\"* \").append(match).append(System.lineSeparator()));\n-        return builder.toString();\n-    }\n-\n-    private String getMatchedNodesItemWhiteSpace() {\n-        return \"           \";\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/RegexFailure.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.MatchableMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a fully parsed check attribute of an IR rule for a compile phase that is ready to be IR matched\n+ * on. This class is part of {@link FailOn} and\/or {@link Counts}.\n+ *\n+ * @see FailOn\n+ * @see Counts\n+ * @see Constraint\n+ * @see CheckAttributeMatchResult\n+ *\/\n+class CheckAttribute implements Matchable {\n+    private final MatchableMatcher matcher;\n+    private final CheckAttributeType checkAttributeType;\n+\n+    public CheckAttribute(CheckAttributeType checkAttributeType, List<Constraint> constraints) {\n+        this.matcher = new MatchableMatcher(constraints);\n+        this.checkAttributeType = checkAttributeType;\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        return new CheckAttributeMatchResult(checkAttributeType, matcher.match());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/CheckAttribute.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a match result of a {@link CheckAttribute} (i.e. either from {@link IR#failOn} or\n+ * {@link IR#counts}). The type of check attribute is defined by {@link CheckAttributeType}.\n+ *\n+ * @see CheckAttribute\n+ * @see CheckAttributeType\n+ *\/\n+public class CheckAttributeMatchResult implements MatchResult {\n+    private final AcceptChildren acceptChildren;\n+    private final boolean failed;\n+    private final CheckAttributeType checkAttributeType;\n+\n+    CheckAttributeMatchResult(CheckAttributeType checkAttributeType, List<MatchResult> matchResults) {\n+        this.acceptChildren = new AcceptChildren(matchResults);\n+        this.failed = !matchResults.isEmpty();\n+        this.checkAttributeType = checkAttributeType;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return failed;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitCheckAttribute(acceptChildren, checkAttributeType);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/CheckAttributeMatchResult.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute;\n+\n+\/**\n+ * This enum denotes the check attribute type of a check attribute.\n+ *\n+ * @see CheckAttribute\n+ * @see CheckAttributeMatchResult\n+ *\/\n+public enum CheckAttributeType {\n+    FAIL_ON, COUNTS\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/CheckAttributeType.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a fully parsed {@link IR#counts()} attribute of an IR rule for a compile phase that is ready\n+ * to be IR matched on.\n+ *\n+ * @see IR#counts()\n+ *\/\n+public class Counts implements Matchable {\n+    private final CheckAttribute checkAttribute;\n+\n+    public Counts(List<Constraint> constraints) {\n+        this.checkAttribute = new CheckAttribute(CheckAttributeType.COUNTS, constraints);\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        return checkAttribute.match();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/Counts.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.SuccessResult;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents a fully parsed {@link IR#failOn()} attribute of an IR rule for a compile phase that is ready\n+ * to be IR matched on. This class provides a quick check regex by simply looking for any occurrence of any constraint\n+ * regex. Only if that fails, we need to check each constraint individually to report which one failed.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+public class FailOn implements Matchable {\n+    private final Matchable checkAttribute;\n+\n+    private final List<Constraint> constraints;\n+    private final String compilationOutput;\n+\n+    public FailOn(List<Constraint> constraints, String compilationOutput) {\n+        this.checkAttribute = new CheckAttribute(CheckAttributeType.FAIL_ON, constraints);\n+        this.constraints = constraints;\n+        this.compilationOutput = compilationOutput;\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        if (hasNoMatchQuick()) {\n+            return SuccessResult.getInstance();\n+        }\n+        return checkAttribute.match();\n+    }\n+\n+    \/**\n+     * Quick check: Look for any occurrence of any regex by creating the following pattern to match against:\n+     * \"regex_1|regex_2|...|regex_n\"\n+     *\/\n+    private boolean hasNoMatchQuick() {\n+        String patternString = constraints.stream().map(Constraint::nodeRegex).collect(Collectors.joining(\"|\"));\n+        Pattern pattern = Pattern.compile(String.join(\"|\", patternString));\n+        Matcher matcher = pattern.matcher(compilationOutput);\n+        return !matcher.find();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/FailOn.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.ConstraintAction;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+\n+import java.util.*;\n+\n+\/**\n+ * This class reads the check attribute strings as found in ({@link IR#failOn()} or {@link IR#counts()}) and groups them\n+ * into constraints. For each constraint, a {@link ConstraintAction} is performed which creates an object. These objects\n+ * are then returned to the caller.\n+ *\n+ * @see IR#failOn()\n+ * @see IR#counts()\n+ * @see ConstraintAction\n+ *\/\n+public class CheckAttributeReader<R> {\n+    private final ListIterator<String> iterator;\n+    private final ConstraintAction<R> constraintAction;\n+\n+    public CheckAttributeReader(String[] checkAttributeStrings, ConstraintAction<R> constraintAction) {\n+        this.iterator = Arrays.stream(checkAttributeStrings).toList().listIterator();\n+        this.constraintAction = constraintAction;\n+    }\n+\n+    public void read(Collection<R> result) {\n+        int index = 1;\n+        while (iterator.hasNext()) {\n+            String node = iterator.next();\n+            CheckAttributeString userPostfix = readUserPostfix(node);\n+            RawIRNode rawIRNode = new RawIRNode(node, userPostfix);\n+            result.add(constraintAction.apply(iterator, rawIRNode, index++));\n+        }\n+    }\n+\n+    public final CheckAttributeString readUserPostfix(String node) {\n+        if (IRNode.isCompositeIRNode(node)) {\n+            String irNode = IRNode.getIRNodeAccessString(node);\n+            int nextIndex = iterator.nextIndex();\n+            TestFormat.checkNoReport(iterator.hasNext(), \"Must provide additional value at index \" +\n+                                                         nextIndex + \" right after \" + irNode);\n+            CheckAttributeString userPostfix = new CheckAttributeString(iterator.next());\n+            TestFormat.checkNoReport(userPostfix.isValidUserPostfix(), \"Provided empty string for composite node \" +\n+                                                                       irNode + \" at index \" + nextIndex);\n+            return userPostfix;\n+        } else {\n+            return CheckAttributeString.invalid();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/CheckAttributeReader.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+\/**\n+ * This class represents a single string found in a check attribute of an {@link IR} annotation.\n+ *\n+ * @see IR\n+ *\/\n+record CheckAttributeString(String value) {\n+    private static final CheckAttributeString INVALID = new CheckAttributeString(\"\");\n+\n+    public boolean isValid() {\n+        return this != INVALID;\n+    }\n+\n+    public boolean isValidUserPostfix() {\n+        return !value.isEmpty();\n+    }\n+\n+    public static CheckAttributeString invalid() {\n+        return INVALID;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/CheckAttributeString.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.ConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.CreateRawConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.DefaultPhaseConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * This class parses the check attribute strings of ({@link IR#failOn()} or {@link IR#counts()}) as found in a\n+ * {@link IR @IR} annotation without replacing placeholder IR strings, yet. For each constraint (i.e. all consecutive\n+ * strings in the check attribute that eventually form a constraint) we apply a {@link ConstraintAction} which defines\n+ * the action that is performed for the constraint.\n+ *\n+ * @see IR#failOn()\n+ * @see IR#counts()\n+ * @see ConstraintAction\n+ *\/\n+ public class CheckAttributeStrings {\n+    private final String[] checkAttributeStrings;\n+\n+    public CheckAttributeStrings(String[] checkAttributeStrings) {\n+        this.checkAttributeStrings = checkAttributeStrings;\n+    }\n+\n+    \/**\n+     * Walk over the check attribute strings as found in the {@link IR} annotation and create {@link RawConstraint}\n+     * objects for them. Return them in a list.\n+     *\/\n+    public final List<RawConstraint> createRawConstraints(CreateRawConstraintAction createRawConstraintAction) {\n+        CheckAttributeReader<RawConstraint> reader = new CheckAttributeReader<>(checkAttributeStrings,\n+                                                                                createRawConstraintAction);\n+        List<RawConstraint> rawConstraints = new ArrayList<>();\n+        reader.read(rawConstraints);\n+        return rawConstraints;\n+    }\n+\n+    \/**\n+     * Walk over the check attribute strings as found in the {@link IR annotation} and return the default phase for\n+     * {@link IRNode} constraints.\n+     *\/\n+    public final Set<CompilePhase> parseDefaultCompilePhases(DefaultPhaseConstraintAction defaultPhaseConstraintAction) {\n+        Set<CompilePhase> compilePhases = new HashSet<>();\n+        CheckAttributeReader<CompilePhase> reader = new CheckAttributeReader<>(checkAttributeStrings,\n+                                                                               defaultPhaseConstraintAction);\n+        reader.read(compilePhases);\n+        return compilePhases;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/CheckAttributeStrings.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * Interface offering different parsing operations on the raw strings as found in {@link IR} check attributes.\n+ *\/\n+public interface RawCheckAttribute {\n+    List<RawConstraint> createRawConstraints();\n+\n+    Set<CompilePhase> parseDefaultCompilePhases();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawCheckAttribute.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.CreateRawCountsConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.DefaultPhaseCountsConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * This class offers different parsing operations on the raw strings as found in a {@link IR#counts()} check attribute.\n+ *\n+ * @see IR#counts\n+ *\/\n+public class RawCounts implements RawCheckAttribute {\n+    private final CheckAttributeStrings checkAttributeStrings;\n+\n+    public RawCounts(String[] checkAttributeStrings) {\n+        this.checkAttributeStrings = new CheckAttributeStrings(checkAttributeStrings);\n+    }\n+\n+    @Override\n+    public List<RawConstraint> createRawConstraints() {\n+        return checkAttributeStrings.createRawConstraints(new CreateRawCountsConstraintAction());\n+    }\n+\n+    @Override\n+    public Set<CompilePhase> parseDefaultCompilePhases() {\n+        return checkAttributeStrings.parseDefaultCompilePhases(new DefaultPhaseCountsConstraintAction());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawCounts.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.CreateRawFailOnConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action.DefaultPhaseFailOnConstraintAction;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * This class offers different parsing operations on the raw strings as found in a {@link IR#failOn()} check attribute.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+public class RawFailOn implements RawCheckAttribute {\n+    private final CheckAttributeStrings checkAttributeStrings;\n+\n+    public RawFailOn(String[] checkAttributeStrings) {\n+        this.checkAttributeStrings = new CheckAttributeStrings(checkAttributeStrings);\n+    }\n+\n+    @Override\n+    public List<RawConstraint> createRawConstraints() {\n+        return checkAttributeStrings.createRawConstraints(new CreateRawFailOnConstraintAction());\n+    }\n+\n+    @Override\n+    public Set<CompilePhase> parseDefaultCompilePhases() {\n+        return checkAttributeStrings.parseDefaultCompilePhases(new DefaultPhaseFailOnConstraintAction());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawFailOn.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IRNode;\n+\n+\/**\n+ * This class represents a \"raw IR node\" as read from a check attribute. It has a node part that either represents an\n+ * {@link IRNode} placeholder string or a user defined regex. In the former case, we could additionally have a user\n+ * postfix string. This raw IR node is not specific to any compile phase (i.e. the IR node placeholder is not replaced\n+ * by an actual regex, yet, and thus is named \"raw\").\n+ *\n+ * @see IRNode\n+ *\/\n+public class RawIRNode {\n+    private final String node;\n+    private final CheckAttributeString userPostfix;\n+\n+    public RawIRNode(String node, CheckAttributeString userPostfix) {\n+        this.node = node;\n+        this.userPostfix = userPostfix;\n+    }\n+\n+    public String irNodePlaceholder() {\n+        return IRNode.getIRNodeAccessString(node);\n+    }\n+\n+    public CompilePhase defaultCompilePhase() {\n+        return IRNode.getDefaultPhase(node);\n+    }\n+\n+    public String regex(CompilePhase compilePhase) {\n+        String nodeRegex = node;\n+        if (IRNode.isIRNode(node)) {\n+            nodeRegex = IRNode.getRegexForCompilePhase(node, compilePhase);\n+            if (userPostfix.isValid()) {\n+                nodeRegex = nodeRegex.replaceAll(IRNode.IS_REPLACED, userPostfix.value());\n+            }\n+        }\n+        return nodeRegex;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * Interface describing an action that can performed when reading a constraint of an {@link IR} check attribute. The\n+ * action creates a new object and returns it.\n+ *\/\n+public interface ConstraintAction<R> {\n+    R apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintId);\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/ConstraintAction.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.shared.Comparison;\n+import compiler.lib.ir_framework.shared.ComparisonConstraintParser;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * This class represents a count string of a {@link IR} check attribute.\n+ *\/\n+class CountString {\n+    private final ListIterator<String> iterator;\n+    private final RawIRNode rawIRNode;\n+\n+    public CountString(ListIterator<String> iterator, RawIRNode rawIRNode) {\n+        this.iterator = iterator;\n+        this.rawIRNode = rawIRNode;\n+    }\n+\n+    public Comparison<Integer> parse() {\n+        TestFormat.checkNoReport(iterator.hasNext(), \"Missing count for node \" + rawIRNode.irNodePlaceholder());\n+        String countsString = iterator.next();\n+        try {\n+            return ComparisonConstraintParser.parse(countsString, CountString::parsePositiveInt);\n+        } catch (TestFormatException e) {\n+            String irNodeString = rawIRNode.irNodePlaceholder();\n+            throw new TestFormatException(e.getMessage() + \", node \" + irNodeString + \", in count string \\\"\" + countsString + \"\\\"\");\n+        }\n+    }\n+\n+    public static int parsePositiveInt(String s) {\n+        int result = Integer.parseInt(s);\n+        if (result < 0) {\n+            throw new NumberFormatException(\"cannot be negative\");\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/CountString.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * Interface describing an action which creates a {@link RawConstraint}.\n+ *\/\n+public interface CreateRawConstraintAction extends ConstraintAction<RawConstraint> {\n+    @Override\n+    RawConstraint apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintId);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/CreateRawConstraintAction.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawCountsConstraint;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * This action class creates a {@link RawCountsConstraint}.\n+ *\/\n+public class CreateRawCountsConstraintAction implements CreateRawConstraintAction {\n+    @Override\n+    public RawConstraint apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintIndex) {\n+        Comparison<Integer> comparison = new CountString(iterator, rawIRNode).parse();\n+        return new RawCountsConstraint(rawIRNode, comparison, constraintIndex);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/CreateRawCountsConstraintAction.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawFailOnConstraint;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * This action class creates a {@link RawConstraint}.\n+ *\/\n+public class CreateRawFailOnConstraintAction implements CreateRawConstraintAction {\n+    @Override\n+    public RawConstraint apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintIndex) {\n+        return new RawFailOnConstraint(rawIRNode, constraintIndex);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/CreateRawFailOnConstraintAction.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * Interface describing an action which fetches the default {@link CompilePhase} of an {@link IRNode}.\n+ *\/\n+public interface DefaultPhaseConstraintAction extends ConstraintAction<CompilePhase> {\n+    @Override\n+    CompilePhase apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintId);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/DefaultPhaseConstraintAction.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * This class fetches the default {@link CompilePhase} of an {@link IRNode} of a {@link IR#failOn} check attribute.\n+ *\/\n+public class DefaultPhaseCountsConstraintAction implements DefaultPhaseConstraintAction {\n+    @Override\n+    public CompilePhase apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintId) {\n+        new CountString(iterator, rawIRNode).parse();\n+        return rawIRNode.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/DefaultPhaseCountsConstraintAction.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.action;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+\n+import java.util.ListIterator;\n+\n+\/**\n+ * This class fetches the default {@link CompilePhase} of an {@link IRNode} of a {@link IR#counts} check attribute.\n+ *\/\n+public class DefaultPhaseFailOnConstraintAction implements DefaultPhaseConstraintAction {\n+    @Override\n+    public CompilePhase apply(ListIterator<String> iterator, RawIRNode rawIRNode, int constraintId) {\n+        return rawIRNode.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/action\/DefaultPhaseFailOnConstraintAction.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.FailOn;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents a single constraint of a check attribute of an IR rule for a compile phase. It stores a\n+ * ready to be used regex for a compile phase (i.e. all {@link IRNode} placeholder strings are updated and composite nodes\n+ * merged) which can be used for matching. A {@link ConstraintCheck} decides if the matching on the constraint fails.\n+ *\n+ * @see FailOn\n+ *\/\n+public class Constraint implements Matchable {\n+    private final ConstraintCheck constraintCheck;\n+    private final String nodeRegex;\n+    private final String compilationOutput;\n+\n+    private Constraint(ConstraintCheck constraintCheck, String nodeRegex, String compilationOutput) {\n+        this.constraintCheck = constraintCheck;\n+        this.nodeRegex = nodeRegex;\n+        this.compilationOutput = compilationOutput;\n+    }\n+\n+    public static Constraint createFailOn(String nodeRegex, int constraintId, String compilationOutput) {\n+        return new Constraint(new FailOnConstraintCheck(nodeRegex, constraintId), nodeRegex, compilationOutput);\n+    }\n+\n+    public static Constraint createCounts(String nodeRegex, int constraintId, Comparison<Integer> comparison,\n+                                          String compilationOutput) {\n+        return new Constraint(new CountsConstraintCheck(nodeRegex, constraintId, comparison), nodeRegex, compilationOutput);\n+    }\n+\n+    public String nodeRegex() {\n+        return nodeRegex;\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        List<String> matchedNodes = matchNodes(compilationOutput);\n+        return constraintCheck.check(matchedNodes);\n+    }\n+\n+    private List<String> matchNodes(String compilationOutput) {\n+        Pattern pattern = Pattern.compile(nodeRegex);\n+        Matcher matcher = pattern.matcher(compilationOutput);\n+        return matcher.results().map(java.util.regex.MatchResult::group).collect(Collectors.toList());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/Constraint.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Interface to represent a check on a single {@link Constraint}.\n+ *\/\n+interface ConstraintCheck {\n+    MatchResult check(List<String> matchedNodes);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/ConstraintCheck.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Interface representing a match result of a {@link Constraint} on a compile phase output which failed.\n+ *\n+ * @see Constraint\n+ *\/\n+public interface ConstraintFailure extends MatchResult {\n+    @Override\n+    default boolean fail() {\n+        return true;\n+    }\n+    String nodeRegex();\n+    int constraintId();\n+    List<String> matchedNodes();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/ConstraintFailure.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class provides a check on a single {@link IR#counts()} {@link Constraint}.\n+ *\n+ * @see Constraint\n+ *\/\n+class CountsConstraintCheck implements ConstraintCheck {\n+    private final String nodeRegex;\n+    private final int constraintId; \/\/ constraint indices start at 1.\n+    private final Comparison<Integer> comparison;\n+\n+    public CountsConstraintCheck(String nodeRegex, int constraintId, Comparison<Integer> comparison) {\n+        this.comparison = comparison;\n+        this.nodeRegex = nodeRegex;\n+        this.constraintId = constraintId;\n+    }\n+\n+    @Override\n+    public MatchResult check(List<String> matchedNodes) {\n+        if (!comparison.compare(matchedNodes.size())) {\n+            return new CountsConstraintFailure(nodeRegex, constraintId, matchedNodes, comparison);\n+        }\n+        return SuccessResult.getInstance();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/CountsConstraintCheck.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.Counts;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a failed match result of a counts {@link Constraint} on a compile phase output.\n+ *\n+ * @see Constraint\n+ * @see Counts\n+ *\/\n+public record CountsConstraintFailure(String nodeRegex, int constraintId, List<String> matchedNodes,\n+                                      Comparison<Integer> comparison) implements ConstraintFailure {\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitCountsConstraint(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/CountsConstraintFailure.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class provides a check on a single {@link IR#failOn()} {@link Constraint}.\n+ *\n+ * @see Constraint\n+ *\/\n+class FailOnConstraintCheck implements ConstraintCheck {\n+    private final String nodeRegex;\n+    private final int constraintId; \/\/ constraint indices start at 1.\n+\n+    public FailOnConstraintCheck(String nodeRegex, int constraintId) {\n+        this.nodeRegex = nodeRegex;\n+        this.constraintId = constraintId;\n+    }\n+\n+    @Override\n+    public MatchResult check(List<String> matchedNodes) {\n+        if (!matchedNodes.isEmpty()) {\n+            return new FailOnConstraintFailure(nodeRegex, constraintId, matchedNodes);\n+        }\n+        return SuccessResult.getInstance();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/FailOnConstraintCheck.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.Counts;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a failed match result of a failOn {@link Constraint} on a compile phase output.\n+ *\n+ * @see Constraint\n+ * @see Counts\n+ *\/\n+public record FailOnConstraintFailure(String nodeRegex, int constraintId, List<String> matchedNodes)\n+        implements ConstraintFailure {\n+    public FailOnConstraintFailure {\n+        TestFramework.check(!matchedNodes.isEmpty(), \"must have at least one matched node\");\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitFailOnConstraint(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/FailOnConstraintFailure.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+\/**\n+ * This class represents a successful match result of any {@link Matchable} object.\n+ *\/\n+public class SuccessResult implements MatchResult {\n+    private static final SuccessResult INSTANCE = new SuccessResult();\n+\n+    private SuccessResult() {}\n+\n+    public static SuccessResult getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        \/\/ Must not be visited.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/SuccessResult.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+\n+\/**\n+ * Interface to represent a single raw constraint as found in the {@link IR @IR} annotation (i.e. {@link IRNode}\n+ * placeholder strings are not replaced by regexes, yet). A raw constraint can be parsed into a {@link Constraint} by\n+ * calling {@link #parse(CompilePhase, String)}. This replaces the IR node placeholder strings by actual regexes and\n+ * merges composite nodes together.\n+ *\n+ * @see Constraint\n+ *\/\n+public interface RawConstraint {\n+    CompilePhase defaultCompilePhase();\n+    Constraint parse(CompilePhase compilePhase, String compilationOutput);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawConstraint.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw;\n+\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+\/**\n+ * This class represents a raw constraint of a {@link IR#counts()} attribute.\n+ *\n+ * @see IR#counts()\n+ *\/\n+public class RawCountsConstraint implements RawConstraint {\n+    private final RawIRNode rawIRNode;\n+    private final int constraintIndex;\n+    private final Comparison<Integer> comparison;\n+\n+    public RawCountsConstraint(RawIRNode rawIRNode, Comparison<Integer> comparison, int constraintIndex) {\n+        this.rawIRNode = rawIRNode;\n+        this.constraintIndex = constraintIndex;\n+        this.comparison = comparison;\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return rawIRNode.defaultCompilePhase();\n+    }\n+\n+    @Override\n+    public Constraint parse(CompilePhase compilePhase, String compilationOutput) {\n+        TestFramework.check(compilePhase != CompilePhase.DEFAULT, \"must not be default\");\n+        return Constraint.createCounts(rawIRNode.regex(compilePhase), constraintIndex, comparison, compilationOutput);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawCountsConstraint.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawIRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+\n+\/**\n+ * This class represents a raw constraint of a {@link IR#failOn()} attribute.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+public class RawFailOnConstraint implements RawConstraint {\n+    private final RawIRNode rawIRNode;\n+    private final int constraintIndex;\n+\n+    public RawFailOnConstraint(RawIRNode rawIRNode, int constraintIndex) {\n+        this.rawIRNode = rawIRNode;\n+        this.constraintIndex = constraintIndex;\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return rawIRNode.defaultCompilePhase();\n+    }\n+\n+    @Override\n+    public Constraint parse(CompilePhase compilePhase, String compilationOutput) {\n+        TestFramework.check(compilePhase != CompilePhase.DEFAULT, \"must not be default\");\n+        return Constraint.createFailOn(rawIRNode.regex(compilePhase), constraintIndex, compilationOutput);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawFailOnConstraint.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.MatchableMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.Counts;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.FailOn;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents an IR rule of an IR method for a specific compile phase. It contains fully parsed (i.e.\n+ * all placeholder strings of {@link IRNode} replaced and composite nodes merged) {@link FailOn} and\/or {@link Counts}\n+ * check attributes which are ready to be matched on.\n+ *\n+ * @see FailOn\n+ * @see Counts\n+ * @see CompilePhaseIRRuleMatchResult\n+ *\/\n+public class CompilePhaseIRRule implements CompilePhaseIRRuleMatchable {\n+    private final CompilePhase compilePhase;\n+    private final MatchableMatcher matcher;\n+    private final String compilationOutput;\n+\n+    public CompilePhaseIRRule(CompilePhase compilePhase, List<Matchable> checkAttributes, String compilationOutput) {\n+        this.compilePhase = compilePhase;\n+        this.matcher = new MatchableMatcher(checkAttributes);\n+        this.compilationOutput = compilationOutput;\n+    }\n+\n+    @Override\n+    public MatchResult match() {\n+        return new CompilePhaseIRRuleMatchResult(compilePhase, compilationOutput, matcher.match());\n+    }\n+\n+    @Override\n+    public CompilePhase compilePhase() {\n+        return compilePhase;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseIRRule.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.Counts;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.FailOn;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawCounts;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawFailOn;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+\n+import java.util.*;\n+\n+\/**\n+ * This class creates a list of {@link CompilePhaseIRRule} for each specified compile phase in {@link IR#phase()} of an\n+ * IR rule. Default compile phases of {@link IRNode} placeholder strings as found in {@link RawConstraint} objects are\n+ * replaced by the actual default phases. The resulting parsed {@link Constraint} objects which now belong to a\n+ * non-default compile phase are moved to the check attribute matchables which represent these compile phases.\n+ *\n+ * @see CompilePhaseIRRule\n+ *\/\n+public class CompilePhaseIRRuleBuilder {\n+    private final IR irAnno;\n+    private final List<RawConstraint> rawFailOnConstraints;\n+    private final List<RawConstraint> rawCountsConstraints;\n+    private final Compilation compilation;\n+    private final SortedSet<CompilePhaseIRRuleMatchable> compilePhaseIRRules = new TreeSet<>();\n+\n+    public CompilePhaseIRRuleBuilder(IR irAnno, Compilation compilation) {\n+        this.irAnno = irAnno;\n+        this.compilation = compilation;\n+        this.rawFailOnConstraints = new RawFailOn(irAnno.failOn()).createRawConstraints();\n+        this.rawCountsConstraints = new RawCounts(irAnno.counts()).createRawConstraints();\n+    }\n+\n+    public SortedSet<CompilePhaseIRRuleMatchable> build() {\n+        CompilePhase[] compilePhases = irAnno.phase();\n+        TestFormat.checkNoReport(new HashSet<>(List.of(compilePhases)).size() == compilePhases.length,\n+                                 \"Cannot specify a compile phase twice\");\n+        for (CompilePhase compilePhase : compilePhases) {\n+            if (compilePhase == CompilePhase.DEFAULT) {\n+                createCompilePhaseIRRulesForDefault();\n+            } else {\n+                createCompilePhaseIRRule(compilePhase);\n+            }\n+        }\n+        return compilePhaseIRRules;\n+    }\n+\n+    private void createCompilePhaseIRRulesForDefault() {\n+        DefaultPhaseRawConstraintParser parser = new DefaultPhaseRawConstraintParser(compilation);\n+        Map<CompilePhase, List<Matchable>> checkAttributesForCompilePhase =\n+                parser.parse(rawFailOnConstraints, rawCountsConstraints);\n+        checkAttributesForCompilePhase.forEach((compilePhase, constraints) -> {\n+            if (compilation.hasOutput(compilePhase)) {\n+                compilePhaseIRRules.add(new CompilePhaseIRRule(compilePhase, constraints,\n+                                                               compilation.output(compilePhase)));\n+            } else {\n+                compilePhaseIRRules.add(new CompilePhaseNoCompilationIRRule(compilePhase));\n+            }\n+        });\n+    }\n+\n+    private void createCompilePhaseIRRule(CompilePhase compilePhase) {\n+        List<Constraint> failOnConstraints = parseRawConstraints(rawFailOnConstraints, compilePhase);\n+        List<Constraint> countsConstraints = parseRawConstraints(rawCountsConstraints, compilePhase);\n+        if (compilation.hasOutput(compilePhase)) {\n+            createValidCompilePhaseIRRule(compilePhase, failOnConstraints, countsConstraints);\n+        } else {\n+            compilePhaseIRRules.add(new CompilePhaseNoCompilationIRRule(compilePhase));\n+        }\n+    }\n+\n+    private void createValidCompilePhaseIRRule(CompilePhase compilePhase, List<Constraint> failOnConstraints,\n+                                               List<Constraint> countsConstraints) {\n+        String compilationOutput = compilation.output(compilePhase);\n+        List<Matchable> checkAttributes = new ArrayList<>();\n+        if (!failOnConstraints.isEmpty()) {\n+            checkAttributes.add(new FailOn(failOnConstraints, compilationOutput));\n+        }\n+\n+        if (!countsConstraints.isEmpty()) {\n+            checkAttributes.add(new Counts(countsConstraints));\n+        }\n+        compilePhaseIRRules.add(new CompilePhaseIRRule(compilePhase, checkAttributes, compilation.output(compilePhase)));\n+    }\n+\n+    private List<Constraint> parseRawConstraints(List<RawConstraint> rawConstraints,\n+                                                 CompilePhase compilePhase) {\n+        List<Constraint> constraintResultList = new ArrayList<>();\n+        for (RawConstraint rawConstraint : rawConstraints) {\n+            constraintResultList.add(rawConstraint.parse(compilePhase, compilation.output(compilePhase)));\n+        }\n+        return constraintResultList;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseIRRuleBuilder.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a match result of a {@link CompilePhaseIRRule} (i.e. an IR rule applied on a compile phase).\n+ *\n+ * @see CompilePhaseIRRule\n+ *\/\n+public class CompilePhaseIRRuleMatchResult implements MatchResult {\n+    private final AcceptChildren acceptChildren;\n+    private final boolean failed;\n+    private final CompilePhase compilePhase;\n+    private final String compilationOutput;\n+\n+    public CompilePhaseIRRuleMatchResult(CompilePhase compilePhase, String compilationOutput,\n+                                         List<MatchResult> matchResults) {\n+        this.acceptChildren = new AcceptChildren(matchResults);\n+        this.failed = !matchResults.isEmpty();\n+        this.compilePhase = compilePhase;\n+        this.compilationOutput = compilationOutput;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return failed;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitCompilePhaseIRRule(acceptChildren, compilePhase, compilationOutput);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseIRRuleMatchResult.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+\n+\/**\n+ * Interface for all matchable objects related to compile phase IR rules.\n+ *\n+ * @see CompilePhaseIRRule\n+ * @see CompilePhaseNoCompilationIRRule\n+ *\/\n+public interface CompilePhaseIRRuleMatchable extends Matchable, Comparable<CompilePhaseIRRuleMatchable> {\n+    CompilePhase compilePhase();\n+\n+    \/**\n+     * Sort by compile phase enum definition order.\n+     *\/\n+    @Override\n+    default int compareTo(CompilePhaseIRRuleMatchable other) {\n+        return this.compilePhase().compareTo(other.compilePhase());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseIRRuleMatchable.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+\/**\n+ * This class represents a special compile phase IR rule where no compilation output was found for the associated\n+ * compile phase. This could happen, if the user-defined test code does not exercise the code path that emits this\n+ * compile phase.\n+ *\n+ * @see CompilePhaseNoCompilationIRRuleMatchResult\n+ *\/\n+public record CompilePhaseNoCompilationIRRule(CompilePhase compilePhase) implements CompilePhaseIRRuleMatchable {\n+\n+    @Override\n+    public MatchResult match() {\n+        return new CompilePhaseNoCompilationIRRuleMatchResult(compilePhase);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseNoCompilationIRRule.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+\/**\n+ * This class represents a special match result of {@link CompilePhaseNoCompilationIRRule} where the compilation output\n+ * for the compile phase was empty.\n+ *\n+ * @see CompilePhaseNoCompilationIRRule\n+ *\/\n+public record CompilePhaseNoCompilationIRRuleMatchResult(CompilePhase compilePhase) implements MatchResult {\n+\n+    @Override\n+    public boolean fail() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        visitor.visitNoCompilePhaseCompilation(compilePhase);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/CompilePhaseNoCompilationIRRuleMatchResult.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule.phase;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.Counts;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.FailOn;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.Constraint;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.raw.RawConstraint;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class creates {@link FailOn} and {@link Counts} objects for the default compile phase by parsing the raw\n+ * constraints. Each {@link RawConstraint} has a well-defined default phase. This class collects all parsed\n+ * {@link Constraint} objects for a compile phase in order to create {@link FailOn} and {@link Counts} objects with them.\n+ *\/\n+class DefaultPhaseRawConstraintParser {\n+    private final Compilation compilation;\n+\n+    public DefaultPhaseRawConstraintParser(Compilation compilation) {\n+        this.compilation = compilation;\n+    }\n+\n+    public Map<CompilePhase, List<Matchable>> parse(List<RawConstraint> rawFailOnConstraints,\n+                                                    List<RawConstraint> rawCountsConstraints) {\n+        Map<CompilePhase, Matchable> failOnForCompilePhase = parseRawConstraints(rawFailOnConstraints,\n+                                                                                 CheckAttributeType.FAIL_ON);\n+        Map<CompilePhase, Matchable> countsForCompilePhase = parseRawConstraints(rawCountsConstraints,\n+                                                                                 CheckAttributeType.COUNTS);\n+        return mergeCheckAttributesForCompilePhase(failOnForCompilePhase, countsForCompilePhase);\n+    }\n+\n+    private Map<CompilePhase, Matchable> parseRawConstraints(List<RawConstraint> rawConstraints,\n+                                                             CheckAttributeType checkAttributeType) {\n+        Map<CompilePhase, List<Constraint>> matchableForCompilePhase = new HashMap<>();\n+        for (RawConstraint rawConstraint : rawConstraints) {\n+            CompilePhase compilePhase = rawConstraint.defaultCompilePhase();\n+            List<Constraint> checkAttribute =\n+                    matchableForCompilePhase.computeIfAbsent(compilePhase, k -> new ArrayList<>());\n+            checkAttribute.add(rawConstraint.parse(compilePhase, compilation.output(compilePhase)));\n+        }\n+        return replaceConstraintsWithCheckAttribute(matchableForCompilePhase, checkAttributeType);\n+    }\n+\n+    private Map<CompilePhase, Matchable>\n+    replaceConstraintsWithCheckAttribute(Map<CompilePhase, List<Constraint>> matchableForCompilePhase,\n+                                         CheckAttributeType checkAttributeType) {\n+        return matchableForCompilePhase\n+                .entrySet()\n+                .stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey,\n+                                          entry -> createCheckAttribute(checkAttributeType,\n+                                                                        entry.getKey(), entry.getValue())));\n+    }\n+\n+    private Matchable createCheckAttribute(CheckAttributeType checkAttributeType, CompilePhase compilePhase,\n+                                           List<Constraint> constraints) {\n+        switch (checkAttributeType) {\n+            case FAIL_ON -> {\n+                return new FailOn(constraints, compilation.output(compilePhase));\n+            }\n+            case COUNTS -> {\n+                return new Counts(constraints);\n+            }\n+            default -> throw new TestFrameworkException(\"unsupported: \" + checkAttributeType);\n+        }\n+    }\n+\n+    private static Map<CompilePhase, List<Matchable>>\n+    mergeCheckAttributesForCompilePhase(Map<CompilePhase, Matchable> failOnForCompilePhase,\n+                                        Map<CompilePhase, Matchable> countsForCompilePhase) {\n+        Map<CompilePhase, List<Matchable>> result = new HashMap<>();\n+        addCheckAttribute(failOnForCompilePhase, result);\n+        addCheckAttribute(countsForCompilePhase, result);\n+        return result;\n+    }\n+\n+    private static void addCheckAttribute(Map<CompilePhase, Matchable> failOnForCompilePhase,\n+                                          Map<CompilePhase, List<Matchable>> result) {\n+        failOnForCompilePhase.forEach((compilePhase, matchable) -> {\n+            List<Matchable> list = result.computeIfAbsent(compilePhase, k -> new ArrayList<>());\n+            list.add(matchable);\n+        });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/phase\/DefaultPhaseRawConstraintParser.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+\n+\/**\n+ * This interface represents an IR node mapping entry in {@code IR_NODE_MAPPINGS} in {@link IRNode}. Each entry must\n+ * return a regex for a {@link CompilePhase} or null if it does not support the compile phase. Additionally, a default\n+ * compile phase must be specified to fall back to when a user test specifies {@link CompilePhase#DEFAULT} in\n+ * {@link IR#phase} or does not provide the {@link IR#phase} attribute.\n+ *\n+ * @see IRNode\n+ * @see CompilePhase\n+ *\/\n+public interface IRNodeMapEntry {\n+    \/**\n+     * Return the regex string which shall be used by the IR framework when matching on {@code compilePhase}.\n+     *\/\n+    String regexForCompilePhase(CompilePhase compilePhase);\n+\n+    \/**\n+     * Return the default compile phase that shall be used for an {@link IRNode} placeholeder string when the user test\n+     * specifies {@link CompilePhase#DEFAULT}.\n+     *\/\n+    CompilePhase defaultCompilePhase();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/IRNodeMapEntry.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to different regexes depending on the compile phase.\n+ * This is done by providing a specific {@link PhaseInterval} (i.e. a continuous compile phase range) for each regex.\n+ * If there is only one {@link PhaseInterval}, a {@link SinglePhaseRangeEntry} should be used.\n+ *\n+ * @see PhaseInterval\n+ * @see SinglePhaseRangeEntry\n+ *\/\n+public class MultiPhaseRangeEntry implements IRNodeMapEntry {\n+    private final Map<PhaseInterval, String> intervalToRegex;\n+    private final CompilePhase defaultCompilePhase;\n+\n+    public MultiPhaseRangeEntry(CompilePhase defaultCompilePhase, Map<PhaseInterval, String> intervalToRegex) {\n+        checkOverlap(new ArrayList<>(intervalToRegex.keySet()));\n+        this.intervalToRegex = intervalToRegex;\n+        this.defaultCompilePhase = defaultCompilePhase;\n+    }\n+\n+    \/**\n+     * Checks that there is no compile phase overlap of any {@link PhaseInterval} objects in {@code phaseRanges}.\n+     *\/\n+    private static void checkOverlap(List<PhaseInterval> phaseRanges) {\n+        \/\/ Sort ascending by start field of phase range.\n+        phaseRanges.sort((i1, i2) -> i1.start().ordinal() - i2.end().ordinal());\n+        for (int i = 1; i < phaseRanges.size(); i++) {\n+            if (phaseRanges.get(i - 1).startIndex() > phaseRanges.get(i).endIndex()) {\n+                \/\/ Previous phase range ends after start of current phase range -> overlap\n+                throw new OverlappingPhaseRangesException(phaseRanges.get(i - 1), phaseRanges.get(i));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        for (var entry : intervalToRegex.entrySet()) {\n+            PhaseInterval interval = entry.getKey();\n+            if (interval.includes(compilePhase)) {\n+                return entry.getValue();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return defaultCompilePhase;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/MultiPhaseRangeEntry.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+\/**\n+ * Exception that is thrown if two {@link PhaseInterval} ranges overlap in {@link MultiPhaseRangeEntry}.\n+ *\n+ * @see PhaseInterval\n+ * @see MultiPhaseRangeEntry\n+ *\/\n+class OverlappingPhaseRangesException extends RuntimeException {\n+    public OverlappingPhaseRangesException(PhaseInterval entry, PhaseInterval entry2) {\n+        super(\"The following two PhaseRangeEntry objects overlap which is forbidden:\" + System.lineSeparator() + \"- \"\n+              + entry + System.lineSeparator() + \"- \" + entry2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/OverlappingPhaseRangesException.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a compile phase interval\/range on the ordering found in {@link CompilePhase}. The interval is\n+ * defined as [start, end] (including start and end).\n+ *\n+ * @see CompilePhase\n+ *\/\n+public class PhaseInterval {\n+    private final CompilePhase start;\n+    private final CompilePhase end;\n+\n+    \/**\n+     * Create an interval that represents a singleton set (i.e. an interval that only contains a single compile phase).\n+     *\/\n+    public PhaseInterval(CompilePhase singlePhase) {\n+        this.start = singlePhase;\n+        this.end = singlePhase;\n+    }\n+\n+    public PhaseInterval(CompilePhase start, CompilePhase end) {\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    public int startIndex() {\n+        return start.ordinal();\n+    }\n+\n+    public int endIndex() {\n+        return end.ordinal();\n+    }\n+\n+    public CompilePhase start() {\n+        return start;\n+    }\n+\n+    public CompilePhase end() {\n+        return end;\n+    }\n+\n+    public boolean includes(CompilePhase phase) {\n+        \/\/ start <= phase <= end\n+        return phase.compareTo(start) >= 0 && phase.compareTo(end) <= 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[\" + start + \", \" + end + \"]\";\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/PhaseInterval.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.RegexType;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for all compile phases whose\n+ * {@link CompilePhase#regexType()} match the specified {@link RegexType} for this entry.\n+ *\/\n+public class RegexTypeEntry implements IRNodeMapEntry {\n+    private final SingleRegexEntry singleRegexEntry;\n+    private final RegexType regexType;\n+\n+    public RegexTypeEntry(RegexType regexType, String regex) {\n+        this.regexType = regexType;\n+        CompilePhase defaultCompilePhase = switch (regexType) {\n+            case IDEAL_INDEPENDENT -> CompilePhase.PRINT_IDEAL;\n+            case MACH -> CompilePhase.FINAL_CODE;\n+            case OPTO_ASSEMBLY -> CompilePhase.PRINT_OPTO_ASSEMBLY;\n+        };\n+        this.singleRegexEntry = new SingleRegexEntry(defaultCompilePhase, regex);\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        if (compilePhase.regexType() == regexType) {\n+            return singleRegexEntry.regex();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return singleRegexEntry.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/RegexTypeEntry.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that is only applicable for a single compile phase. This phase\n+ * also represents the default phase when the user specifies {@link CompilePhase#DEFAULT}.\n+ *\/\n+public class SinglePhaseEntry implements IRNodeMapEntry {\n+    private final SingleRegexEntry singleRegexEntry;\n+\n+    public SinglePhaseEntry(CompilePhase defaultCompilePhase, String regex) {\n+        this.singleRegexEntry = new SingleRegexEntry(defaultCompilePhase, regex);\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        if (compilePhase == defaultCompilePhase()) {\n+            return singleRegexEntry.regex();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return singleRegexEntry.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/SinglePhaseEntry.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for multiple continuous compile\n+ * phases (i.e. follow each other immediately in the order defined in {@link CompilePhase}). This is done by providing\n+ * a start and an end compile phase which is put into a {@link PhaseInterval}. An IR node mapping to different regexes\n+ * for different intervals should use {@link MultiPhaseRangeEntry}.\n+ *\n+ * @see CompilePhase\n+ * @see PhaseInterval\n+ * @see MultiPhaseRangeEntry\n+ *\/\n+public class SinglePhaseRangeEntry implements IRNodeMapEntry {\n+    private final SingleRegexEntry singleRegexEntry;\n+    private final PhaseInterval interval;\n+\n+    public SinglePhaseRangeEntry(CompilePhase defaultCompilePhase, String regex, CompilePhase start, CompilePhase end) {\n+        this.interval = new PhaseInterval(start, end);\n+        this.singleRegexEntry = new SingleRegexEntry(defaultCompilePhase, regex);\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        if (interval.includes(compilePhase)) {\n+            \/\/ start <= phase <= end\n+            return singleRegexEntry.regex();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return singleRegexEntry.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/SinglePhaseRangeEntry.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for multiple compile phases.\n+ * If the IR node is only applicable to a single compile phase, a {@link SinglePhaseEntry} should be used.\n+ *\/\n+record SingleRegexEntry(CompilePhase defaultCompilePhase, String regex) {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/SingleRegexEntry.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import compiler.lib.ir_framework.driver.irmatching.TestClass;\n@@ -28,0 +29,2 @@\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n+import compiler.lib.ir_framework.shared.TestFormat;\n@@ -33,1 +36,0 @@\n-import java.util.Collection;\n@@ -36,0 +38,2 @@\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n@@ -38,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +45,2 @@\n- * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class from the hotspot_pid* file and add them\n- * to the collection of {@link IRMethod} created by {@link IREncodingParser}.\n+ * Class to parse the ideal compile phases and PrintOptoAssembly outputs of the test class from the hotspot_pid* file\n+ * of all methods collected by {@link IREncodingParser}.\n@@ -50,1 +55,5 @@\n-    private Map<String, IRMethod> compilationsMap;\n+    \/**\n+     * \"Method name\" -> TestMethod map created by {@link IREncodingParser} which contains an entry for each method that\n+     * needs to be IR matched on.\n+     *\/\n+    private final Map<String, TestMethod> testMethodMap;\n@@ -52,1 +61,1 @@\n-    public HotSpotPidFileParser(String testClass) {\n+    public HotSpotPidFileParser(String testClass, Map<String, TestMethod> testMethodMap) {\n@@ -54,4 +63,1 @@\n-    }\n-\n-    public void setCompilationsMap(Map<String, IRMethod> compilationsMap) {\n-        this.compilationsMap = compilationsMap;\n+        this.testMethodMap = testMethodMap;\n@@ -61,2 +67,2 @@\n-     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly outputs for all\n-     * methods of the test class that need to be IR matched (found in compilations map).\n+     * Parse the hotspot_pid*.log file from the test VM. Read the ideal compile phase and PrintOptoAssembly outputs for\n+     * all methods defined by the IR encoding.\n@@ -64,1 +70,1 @@\n-    public Collection<IRMethod> parseCompilations(String hotspotPidFileName) {\n+    public TestClass parse(String hotspotPidFileName) {\n@@ -66,2 +72,6 @@\n-            processFileLines(hotspotPidFileName);\n-            return compilationsMap.values();\n+            parseHotSpotFile(hotspotPidFileName);\n+            SortedSet<IRMethodMatchable> irMethods = testMethodMap.values().stream()\n+                                                                  .map(TestMethod::createIRMethod)\n+                                                                  .collect(Collectors.toCollection(TreeSet::new));\n+            TestFormat.throwIfAnyFailures();\n+            return new TestClass(irMethods);\n@@ -75,2 +85,2 @@\n-    private void processFileLines(String hotspotPidFileName) throws IOException {\n-        Map<Integer, IRMethod> compileIdMap = new HashMap<>();\n+    private void parseHotSpotFile(String hotspotPidFileName) throws IOException {\n+        Map<Integer, TestMethod> compileIdMap = new HashMap<>();\n@@ -90,1 +100,1 @@\n-    private void processMethodBlock(Map<Integer, IRMethod> compileIdMap, Line line, BlockOutputReader blockOutputReader)\n+    private void processMethodBlock(Map<Integer, TestMethod> compileIdMap, Line line, BlockOutputReader blockOutputReader)\n@@ -95,1 +105,1 @@\n-            \/\/ dumping the PrintIdeal\/PrintOptoAssembly output.\n+            \/\/ dumping the ideal compile phase\/PrintOptoAssembly output.\n@@ -101,1 +111,1 @@\n-    private void parseTestMethodCompileId(Map<Integer, IRMethod> compileIdMap, String line) {\n+    private void parseTestMethodCompileId(Map<Integer, TestMethod> compileIdMap, String line) {\n@@ -104,2 +114,1 @@\n-            int compileId = getCompileId(line);\n-            compileIdMap.put(compileId, getIrMethod(methodName));\n+            compileIdMap.put(getCompileId(line), getTestMethod(methodName));\n@@ -119,1 +128,1 @@\n-        return compilationsMap.containsKey(testMethodName);\n+        return testMethodMap.containsKey(testMethodName);\n@@ -122,2 +131,5 @@\n-    private IRMethod getIrMethod(String testMethodName) {\n-        return compilationsMap.get(testMethodName);\n+    private TestMethod getTestMethod(String testMethodName) {\n+        TestMethod testMethod = testMethodMap.get(testMethodName);\n+        testMethod.clearOutput();\n+        testMethod.setCompiled();\n+        return testMethod;\n@@ -137,1 +149,1 @@\n-    private boolean isTestMethodBlockStart(Line line, Map<Integer, IRMethod> compileIdMap) {\n+    private boolean isTestMethodBlockStart(Line line, Map<Integer, TestMethod> compileIdMap) {\n@@ -141,1 +153,1 @@\n-    private boolean isTestClassMethodBlock(Line line, Map<Integer, IRMethod> compileIdMap) {\n+    private boolean isTestClassMethodBlock(Line line, Map<Integer, TestMethod> compileIdMap) {\n@@ -145,3 +157,3 @@\n-    public void setIRMethodOutput(String blockOutput, Line blockStartLine, Map<Integer, IRMethod> compileIdMap) {\n-        IRMethod irMethod = compileIdMap.get(getCompileId(blockStartLine.getLine()));\n-        setIRMethodOutput(blockOutput, blockStartLine, irMethod);\n+    private void setIRMethodOutput(String blockOutput, Line blockStartLine, Map<Integer, TestMethod> compileIdMap) {\n+        TestMethod testMethod = compileIdMap.get(getCompileId(blockStartLine.getLine()));\n+        setIRMethodOutput(blockOutput, blockStartLine, testMethod);\n@@ -150,1 +162,1 @@\n-    private void setIRMethodOutput(String blockOutput, Line blockStartLine, IRMethod irMethod) {\n+    private void setIRMethodOutput(String blockOutput, Line blockStartLine, TestMethod testMethod) {\n@@ -152,1 +164,1 @@\n-            irMethod.setIdealOutput(blockOutput);\n+            testMethod.setIdealOutput(blockOutput, blockStartLine.getCompilePhase());\n@@ -154,1 +166,1 @@\n-            irMethod.setOptoAssemblyOutput(blockOutput);\n+            testMethod.setOptoAssemblyOutput(blockOutput);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/HotSpotPidFileParser.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n@@ -40,1 +39,1 @@\n- * Class to parse the IR encoding emitted by the test VM and creating {@link IRMethod} objects for each entry.\n+ * Class to parse the IR encoding emitted by the test VM and creating {@link TestMethod} objects for each entry.\n@@ -42,1 +41,1 @@\n- * @see IRMethod\n+ * @see TestMethod\n@@ -50,1 +49,1 @@\n-    private final Map<String, IRMethod> compilations;\n+    private final Map<String, TestMethod> testMethodMap;\n@@ -55,1 +54,1 @@\n-        this.compilations = new HashMap<>();\n+        this.testMethodMap = new HashMap<>();\n@@ -58,1 +57,5 @@\n-    public Map<String, IRMethod> parseIRMethods(String irEncoding) {\n+    \/**\n+     * Parse the IR encoding passed as parameter and return a \"test name\" -> TestMethod map that contains an entry\n+     * for each method that needs to be IR matched on.\n+     *\/\n+    public Map<String, TestMethod> parse(String irEncoding) {\n@@ -63,1 +66,1 @@\n-        createCompilationsMap(irEncoding, testClass);\n+        createTestMethodMap(irEncoding, testClass);\n@@ -66,1 +69,1 @@\n-        return compilations;\n+        return testMethodMap;\n@@ -70,1 +73,2 @@\n-     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n+     * Sets up a map testname -> TestMethod map. The TestMethod object will later be filled with the ideal and opto\n+     * assembly output in {@link HotSpotPidFileParser}.\n@@ -72,1 +76,1 @@\n-    private void createCompilationsMap(String irEncoding, Class<?> testClass) {\n+    private void createTestMethodMap(String irEncoding, Class<?> testClass) {\n@@ -74,1 +78,1 @@\n-        createIRMethodsWithEncoding(testClass, irRulesMap);\n+        createTestMethodsWithEncoding(testClass, irRulesMap);\n@@ -125,1 +129,1 @@\n-    private void createIRMethodsWithEncoding(Class<?> testClass, Map<String, int[]> irRulesMap) {\n+    private void createTestMethodsWithEncoding(Class<?> testClass, Map<String, int[]> irRulesMap) {\n@@ -133,1 +137,1 @@\n-                    compilations.put(m.getName(), new IRMethod(m, irRuleIds, irAnnos));\n+                    testMethodMap.put(m.getName(), new TestMethod(m, irRuleIds));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IREncodingParser.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n-\n-import java.util.Collection;\n-import java.util.Map;\n-\n-\/**\n- * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class and store them into a collection\n- * of dedicated IRMethod objects used throughout IR matching.\n- *\n- * @see IRMethod\n- *\/\n-public class IRMethodParser {\n-    private final IREncodingParser irEncodingParser;\n-    private final HotSpotPidFileParser hotSpotPidFileParser;\n-\n-    public IRMethodParser(Class<?> testClass) {\n-        this.irEncodingParser = new IREncodingParser(testClass);\n-        this.hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName());\n-    }\n-\n-    \/**\n-     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n-     * Return null if there are no applicable @IR rules in any method of the test class.\n-     *\/\n-    public Collection<IRMethod> parse(String hotspotPidFileName, String irEncoding) {\n-        Map<String, IRMethod> compilationsMap = irEncodingParser.parseIRMethods(irEncoding);\n-        if (!compilationsMap.isEmpty()) {\n-            hotSpotPidFileParser.setCompilationsMap(compilationsMap);\n-            return hotSpotPidFileParser.parseCompilations(hotspotPidFileName);\n-        }\n-        return null;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodParser.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -26,0 +26,3 @@\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.TestFramework;\n+\n@@ -34,0 +37,1 @@\n+    private static final Pattern IDEAL_COMPILE_PHASE_PATTERN = Pattern.compile(\"<ideal.*compile_phase='(.*)'>\");\n@@ -60,1 +64,7 @@\n-}\n+\n+    public CompilePhase getCompilePhase() {\n+        Matcher m = IDEAL_COMPILE_PHASE_PATTERN.matcher(line);\n+        TestFramework.check(m.find(), \"must always find \\\"compile_phase\\\" in ideal entry in \" + line);\n+        return CompilePhase.forName(m.group(1));\n+    }\n+ }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Line.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.NonIRTestClass;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+\n+import java.util.Map;\n+\n+\/**\n+ * Class to parse the ideal compile phase and PrintOptoAssembly outputs of the test class and store them into a\n+ * collection of dedicated IRMethod objects used throughout IR matching.\n+ *\n+ * @see IRMethod\n+ *\/\n+public class MethodCompilationParser {\n+    private final Class<?> testClass;\n+\n+    public MethodCompilationParser(Class<?> testClass) {\n+        this.testClass = testClass;\n+    }\n+\n+    \/**\n+     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n+     * Return a default\/empty TestClass object if there are no applicable @IR rules in any method of the test class.\n+     *\/\n+    public Matchable parse(String hotspotPidFileName, String irEncoding) {\n+        IREncodingParser irEncodingParser = new IREncodingParser(testClass);\n+        Map<String, TestMethod> testMethodMap = irEncodingParser.parse(irEncoding);\n+        if (!testMethodMap.isEmpty()) {\n+            HotSpotPidFileParser hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName(), testMethodMap);\n+            return hotSpotPidFileParser.parse(hotspotPidFileName);\n+        }\n+        return new NonIRTestClass();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/MethodCompilationParser.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.Compilation;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchable;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.NotCompiledIRMethod;\n+\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+\/**\n+ * This class represents a test method that is incrementally updated with new information parsed by {@link IREncodingParser}\n+ * and {@link HotSpotPidFileParser}. Once the parsers are finished, an {@link IRMethod} object can be fetched from the\n+ * collected data with {@link TestMethod#createIRMethod()}.\n+ *\n+ * @see IREncodingParser\n+ * @see HotSpotPidFileParser\n+ * @see IRMethod\n+ *\/\n+public class TestMethod {\n+    private final Method method;\n+    private final int[] irRuleIds;\n+    private final Map<CompilePhase, String> compilationOutputMap;\n+    private boolean compiled; \/\/ Was this method compiled (i.e. found in hotspot_pid* file?)\n+\n+    public TestMethod(Method m, int[] irRuleIds) {\n+        this.method = m;\n+        this.irRuleIds = irRuleIds;\n+        this.compilationOutputMap = new LinkedHashMap<>(); \/\/ Keep order of insertion\n+        this.compiled = false;\n+    }\n+\n+    public void setCompiled() {\n+        this.compiled = true;\n+    }\n+\n+    public IRMethodMatchable createIRMethod() {\n+        IR[] irAnnos = method.getAnnotationsByType(IR.class);\n+        TestFramework.check(irAnnos.length > 0, \"must have at least one IR rule\");\n+        TestFramework.check(irRuleIds.length > 0, \"must have at least one IR rule\");\n+        if (compiled) {\n+            return new IRMethod(method, irRuleIds, irAnnos, new Compilation(compilationOutputMap));\n+        } else {\n+            return new NotCompiledIRMethod(method, irRuleIds.length);\n+        }\n+    }\n+\n+    \/**\n+     * Clear the collected ideal and opto assembly output of all phases. This is necessary when having multiple\n+     * compilations of the same method. We only want to keep the very last compilation which is the one requested by\n+     * the framework.\n+     *\/\n+    public void clearOutput() {\n+        compilationOutputMap.clear();\n+    }\n+\n+    \/**\n+     * We might parse multiple C2 compilations of this method. Only keep the very last one by overriding the outputMap.\n+     *\/\n+    public void setIdealOutput(String idealOutput, CompilePhase compilePhase) {\n+        String idealOutputWithHeader = \"> Phase \\\"\" + compilePhase.getName()+ \"\\\":\" + System.lineSeparator()\n+                                       + idealOutput;\n+        if (!compilationOutputMap.containsKey(compilePhase) || compilePhase.overrideRepeatedPhase()) {\n+            compilationOutputMap.put(compilePhase, idealOutputWithHeader);\n+        }\n+    }\n+\n+    \/**\n+     * We might parse multiple C2 compilations of this method. Only keep the very last one by overriding the outputMap.\n+     *\/\n+    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n+        optoAssemblyOutput = \"> Phase \\\"PrintOptoAssembly\\\":\" + System.lineSeparator() + optoAssemblyOutput;\n+        compilationOutputMap.put(CompilePhase.PRINT_OPTO_ASSEMBLY, optoAssemblyOutput);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethod.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.FailOnConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class collects the compilation output of each compile phase that was part of an IR matching failure by visiting\n+ * each match result element. Multiple compile phase compilation outputs for a single method are collected in the same\n+ * order as specified in {@link CompilePhase}.\n+ *\/\n+public class CompilationOutputBuilder implements MatchResultVisitor {\n+    private final StringBuilder output;\n+    private final MatchResult testClassMatchResult;\n+    private final SortedMap<CompilePhase, String> failedCompilePhases = new TreeMap<>();\n+    private int methodIndex;\n+    \/**\n+     * Number of collected distinct compile phases.\n+     *\/\n+    private int compilePhaseCount = 0;\n+\n+    public CompilationOutputBuilder(MatchResult testClassMatchResult) {\n+        this.output = new StringBuilder();\n+        this.testClassMatchResult = testClassMatchResult;\n+    }\n+\n+    @Override\n+    public void visitTestClass(AcceptChildren acceptChildren) {\n+        acceptChildren.accept(this);\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(\"Compilation\");\n+        if (compilePhaseCount > 1) {\n+            builder.append(\"s (\").append(compilePhaseCount).append(\")\");\n+        }\n+        builder.append(\" of Failed Method\");\n+        int failedIRMethods = methodIndex;\n+        if (failedIRMethods > 1) {\n+            builder.append(\"s (\").append(failedIRMethods).append(\")\");\n+        }\n+        builder.append(System.lineSeparator())\n+               .append(getTitleSeparator(failedIRMethods))\n+               .append(System.lineSeparator());\n+        output.insert(0, builder);\n+    }\n+\n+    private String getTitleSeparator(int failedIRMethods) {\n+        int failedMethodDashes = failedIRMethods > 1 ? digitCount(failedIRMethods) + 4 : 0;\n+        int compilePhaseDashes = compilePhaseCount > 1 ? digitCount(compilePhaseCount) + 4 : 0;\n+        return \"-\".repeat(28 + compilePhaseDashes + failedMethodDashes);\n+    }\n+\n+    @Override\n+    public void visitIRMethod(AcceptChildren acceptChildren, Method method, int failedIRRules) {\n+        acceptChildren.accept(this);\n+        appendIRMethodHeader(method);\n+        appendMatchedCompilationOutputOfPhases();\n+        failedCompilePhases.clear();\n+    }\n+\n+    private void appendMethodIndex() {\n+        methodIndex++;\n+        if (methodIndex > 1) {\n+            output.append(System.lineSeparator());\n+        }\n+        output.append(methodIndex).append(\") \");\n+    }\n+\n+    private void appendIRMethodHeader(Method method) {\n+        appendMethodIndex();\n+        output.append(\"Compilation\");\n+        if (failedCompilePhases.size() > 1) {\n+            output.append(\"s (\").append(failedCompilePhases.size()).append(\")\");\n+        }\n+        output.append(\" of \\\"\").append(method).append(\"\\\":\")\n+              .append(System.lineSeparator());\n+    }\n+\n+    private void appendMatchedCompilationOutputOfPhases() {\n+        output.append(failedCompilePhases.values()\n+                                         .stream()\n+                                         .collect(Collectors.joining(System.lineSeparator())));\n+    }\n+\n+    @Override\n+    public void visitMethodNotCompiled(Method method, int failedIRRules) {\n+        appendIRMethodHeader(method);\n+        compilePhaseCount++; \/\/ Count this as one phase\n+        output.append(\"<empty>\").append(System.lineSeparator());\n+    }\n+\n+    @Override\n+    public void visitIRRule(AcceptChildren acceptChildren, int irRuleId, IR irAnno) {\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitCompilePhaseIRRule(AcceptChildren acceptChildren, CompilePhase compilePhase, String compilationOutput) {\n+        if (!failedCompilePhases.containsKey(compilePhase)) {\n+            failedCompilePhases.put(compilePhase, compilationOutput);\n+            compilePhaseCount++;\n+        }\n+        \/\/ No need to visit check attributes\n+    }\n+\n+    @Override\n+    public void visitNoCompilePhaseCompilation(CompilePhase compilePhase) {\n+        if (!failedCompilePhases.containsKey(compilePhase)) {\n+            failedCompilePhases.put(compilePhase,\n+                                    \"> Phase \\\"\" + compilePhase.getName() + \"\\\":\" + System.lineSeparator() + \"<empty>\" +\n+                                    System.lineSeparator());\n+            compilePhaseCount++;\n+        }\n+    }\n+\n+    @Override\n+    public void visitCheckAttribute(AcceptChildren acceptChildren, CheckAttributeType checkAttributeType) {}\n+\n+    @Override\n+    public void visitFailOnConstraint(FailOnConstraintFailure failOnConstraintFailure) {}\n+\n+    @Override\n+    public void visitCountsConstraint(CountsConstraintFailure countsConstraintFailure) {}\n+\n+    public String build() {\n+        testClassMatchResult.accept(this);\n+        return output.toString();\n+    }\n+\n+    private static int digitCount(int digit) {\n+        return String.valueOf(digit).length();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/CompilationOutputBuilder.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.ConstraintFailure;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class creates a failure message for a failed constraint.\n+ *\/\n+public class ConstraintFailureMessageBuilder {\n+    private final String nodeRegex;\n+    private final int constraintId;\n+    private final List<String> matchedNodes;\n+    private final Indentation indentation;\n+\n+    public ConstraintFailureMessageBuilder(ConstraintFailure constraintFailure, Indentation indentation) {\n+        this.nodeRegex = constraintFailure.nodeRegex();\n+        this.constraintId = constraintFailure.constraintId();\n+        this.matchedNodes = constraintFailure.matchedNodes();\n+        this.indentation = indentation;\n+    }\n+\n+    public String buildConstraintHeader() {\n+        return indentation + \"* Constraint \"\n+               + constraintId + \": \\\"\" + nodeRegex + \"\\\"\"\n+               + System.lineSeparator();\n+    }\n+\n+    public String buildMatchedNodesMessage(String matchedPrefix) {\n+        indentation.add();\n+        String header = buildMatchedNodesHeader(matchedPrefix);\n+        String body = buildMatchedNodesBody();\n+        indentation.sub();\n+        return header + body;\n+    }\n+\n+    private String buildMatchedNodesHeader(String matchedPrefix) {\n+        int matchCount = matchedNodes.size();\n+        return indentation + \"- \" + matchedPrefix + \" node\" + (matchCount > 1 ? \"s (\" + matchCount + \")\" : \"\") + \":\"\n+               + System.lineSeparator();\n+    }\n+\n+    private String buildMatchedNodesBody() {\n+        indentation.add();\n+        StringBuilder builder = new StringBuilder();\n+        List<String> matches = addWhiteSpacePrefixForEachLine(matchedNodes);\n+        matches.forEach(match -> builder.append(indentation)\n+                                        .append(\"* \").append(match).append(System.lineSeparator()));\n+        indentation.sub();\n+        return builder.toString();\n+    }\n+\n+    private List<String> addWhiteSpacePrefixForEachLine(List<String> matches) {\n+        indentation.add();\n+        List<String> lines = indentation.prependForLines(matches);\n+        indentation.sub();\n+        return lines;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/ConstraintFailureMessageBuilder.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+\/**\n+ * This class creates a failure message for a {@link IR#counts} constraint failure.\n+ *\/\n+public class CountsConstraintFailureMessageBuilder {\n+    private final ConstraintFailureMessageBuilder constrainFailureMessageBuilder;\n+    private final Comparison<Integer> comparison;\n+    private final int matchedNodesSize;\n+    private final Indentation indentation;\n+\n+    public CountsConstraintFailureMessageBuilder(CountsConstraintFailure countsConstraintMatchResult,\n+                                                 Indentation indentation) {\n+        this.constrainFailureMessageBuilder = new ConstraintFailureMessageBuilder(countsConstraintMatchResult,\n+                                                                                  indentation);\n+        this.comparison = countsConstraintMatchResult.comparison();\n+        this.matchedNodesSize = countsConstraintMatchResult.matchedNodes().size();\n+        this.indentation = indentation;\n+    }\n+\n+    public String build() {\n+        String header = constrainFailureMessageBuilder.buildConstraintHeader();\n+        indentation.add();\n+        String body = buildFailedComparisonMessage() + buildMatchedCountsNodesMessage();\n+        indentation.sub();\n+        return header + body;\n+    }\n+\n+    private String buildFailedComparisonMessage() {\n+        String failedComparison = \"[found] \" + matchedNodesSize + \" \"\n+                                  + comparison.getComparator() + \" \" + comparison.getGivenValue() + \" [given]\";\n+        return indentation + \"- Failed comparison: \" + failedComparison + System.lineSeparator();\n+    }\n+\n+    private String buildMatchedCountsNodesMessage() {\n+        if (matchedNodesSize == 0) {\n+            return buildEmptyNodeMatchesMessage();\n+        } else {\n+            return constrainFailureMessageBuilder.buildMatchedNodesMessage(\"Matched\");\n+        }\n+    }\n+\n+    private String buildEmptyNodeMatchesMessage() {\n+        return indentation + \"- No nodes matched!\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/CountsConstraintFailureMessageBuilder.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.FailOnConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Visitor to collect the number of IR method and IR rule failures.\n+ *\/\n+class FailCountVisitor implements MatchResultVisitor {\n+    private int irMethodCount;\n+    private int irRuleCount;\n+\n+    @Override\n+    public void visitTestClass(AcceptChildren acceptChildren) {\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitIRMethod(AcceptChildren acceptChildren, Method method, int failedIRRules) {\n+        irMethodCount++;\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitIRRule(AcceptChildren acceptChildren, int irRuleId, IR irAnno) {\n+        irRuleCount++;\n+        \/\/ Do not need to visit compile phase IR rules\n+    }\n+\n+    @Override\n+    public void visitMethodNotCompiled(Method method, int failedIRRules) {\n+        irMethodCount++;\n+        irRuleCount += failedIRRules;\n+    }\n+\n+    public int getIrRuleCount() {\n+        return irRuleCount;\n+    }\n+\n+    public int getIrMethodCount() {\n+        return irMethodCount;\n+    }\n+\n+    @Override\n+    public void visitCompilePhaseIRRule(AcceptChildren acceptChildren, CompilePhase compilePhase, String compilationOutput) {}\n+\n+    @Override\n+    public void visitNoCompilePhaseCompilation(CompilePhase compilePhase) {}\n+\n+    @Override\n+    public void visitCheckAttribute(AcceptChildren acceptChildren, CheckAttributeType checkAttributeType) {}\n+\n+    @Override\n+    public void visitFailOnConstraint(FailOnConstraintFailure failOnConstraintFailure) {}\n+\n+    @Override\n+    public void visitCountsConstraint(CountsConstraintFailure countsConstraintFailure) {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/FailCountVisitor.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.FailOnConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class creates the complete failure message of each IR matching failure by visiting each match result element.\n+ *\/\n+public class FailureMessageBuilder implements MatchResultVisitor {\n+    private final StringBuilder msg;\n+    private final MatchResult testClassMatchResult;\n+    private Indentation indentation;\n+    private int methodIndex = 0;\n+\n+    public FailureMessageBuilder(MatchResult testClassMatchResult) {\n+        this.msg = new StringBuilder();\n+        this.testClassMatchResult = testClassMatchResult;\n+    }\n+\n+    @Override\n+    public void visitTestClass(AcceptChildren acceptChildren) {\n+        FailCountVisitor failCountVisitor = new FailCountVisitor();\n+        testClassMatchResult.accept(failCountVisitor);\n+        int failedMethodCount = failCountVisitor.getIrMethodCount();\n+        int failedIRRulesCount = failCountVisitor.getIrRuleCount();\n+        msg.append(\"One or more @IR rules failed:\")\n+           .append(System.lineSeparator())\n+           .append(System.lineSeparator())\n+           .append(\"Failed IR Rules (\").append(failedIRRulesCount).append(\") of Methods (\").append(failedMethodCount)\n+           .append(\")\").append(System.lineSeparator())\n+           .append(getTitleSeparator(failedMethodCount, failedIRRulesCount))\n+           .append(System.lineSeparator());\n+        acceptChildren.accept(this);\n+    }\n+\n+    private static String getTitleSeparator(int failedMethodCount, int failedIRRulesCount) {\n+        return \"-\".repeat(32 + digitCount(failedIRRulesCount) + digitCount(failedMethodCount));\n+    }\n+\n+    @Override\n+    public void visitIRMethod(AcceptChildren acceptChildren, Method method, int failedIRRules) {\n+        appendIRMethodHeader(method, failedIRRules);\n+        acceptChildren.accept(this);\n+    }\n+\n+    private void appendIRMethodHeader(Method method, int failedIRRules) {\n+        methodIndex++;\n+        indentation = new Indentation(digitCount(methodIndex));\n+        if (methodIndex > 1) {\n+            msg.append(System.lineSeparator());\n+        }\n+        msg.append(methodIndex).append(\") \");\n+        msg.append(\"Method \\\"\").append(method)\n+           .append(\"\\\" - [Failed IR rules: \").append(failedIRRules).append(\"]:\")\n+           .append(System.lineSeparator());\n+    }\n+\n+    @Override\n+    public void visitMethodNotCompiled(Method method, int failedIRRules) {\n+        appendIRMethodHeader(method, failedIRRules);\n+        indentation.add();\n+        msg.append(indentation)\n+           .append(\"* Method was not compiled. Did you specify a @Run method in STANDALONE mode? In this case, make \" +\n+                   \"sure to always trigger a C2 compilation by invoking the test enough times.\")\n+           .append(System.lineSeparator());\n+        indentation.sub();\n+    }\n+\n+    @Override\n+    public void visitIRRule(AcceptChildren acceptChildren, int irRuleId, IR irAnno) {\n+        indentation.add();\n+        msg.append(indentation).append(\"* @IR rule \").append(irRuleId).append(\": \\\"\")\n+           .append(irAnno).append(\"\\\"\").append(System.lineSeparator());\n+        acceptChildren.accept(this);\n+        indentation.sub();\n+    }\n+\n+    @Override\n+    public void visitCompilePhaseIRRule(AcceptChildren acceptChildren, CompilePhase compilePhase, String compilationOutput) {\n+        indentation.add();\n+        appendCompilePhaseIRRule(compilePhase);\n+        acceptChildren.accept(this);\n+        indentation.sub();\n+    }\n+\n+    private void appendCompilePhaseIRRule(CompilePhase compilePhase) {\n+        msg.append(indentation)\n+           .append(\"> Phase \\\"\").append(compilePhase.getName()).append(\"\\\":\")\n+           .append(System.lineSeparator());\n+    }\n+\n+    @Override\n+    public void visitNoCompilePhaseCompilation(CompilePhase compilePhase) {\n+        indentation.add();\n+        appendCompilePhaseIRRule(compilePhase);\n+        indentation.add();\n+        msg.append(indentation)\n+           .append(\"- NO compilation output found for this phase! Make sure this phase is emitted or remove it from \")\n+           .append(\"the list of compile phases in the @IR rule to match on.\")\n+           .append(System.lineSeparator());\n+        indentation.sub();\n+        indentation.sub();\n+    }\n+\n+    @Override\n+    public void visitCheckAttribute(AcceptChildren acceptChildren, CheckAttributeType checkAttributeType) {\n+        indentation.add();\n+        String checkAttributeFailureMsg;\n+        switch (checkAttributeType) {\n+            case FAIL_ON -> checkAttributeFailureMsg = \"failOn: Graph contains forbidden nodes\";\n+            case COUNTS -> checkAttributeFailureMsg = \"counts: Graph contains wrong number of nodes\";\n+            default ->\n+                    throw new IllegalStateException(\"Unexpected value: \" + checkAttributeType);\n+        }\n+        msg.append(indentation).append(\"- \").append(checkAttributeFailureMsg)\n+           .append(\":\").append(System.lineSeparator());\n+        acceptChildren.accept(this);\n+        indentation.sub();\n+    }\n+\n+    @Override\n+    public void visitFailOnConstraint(FailOnConstraintFailure matchResult) {\n+        indentation.add();\n+        ConstraintFailureMessageBuilder constrainFailureMessageBuilder =\n+                new ConstraintFailureMessageBuilder(matchResult, indentation);\n+        String failureMessage = constrainFailureMessageBuilder.buildConstraintHeader() +\n+                                constrainFailureMessageBuilder.buildMatchedNodesMessage(\"Matched forbidden\");\n+        msg.append(failureMessage);\n+        indentation.sub();\n+    }\n+\n+    @Override\n+    public void visitCountsConstraint(CountsConstraintFailure matchResult) {\n+        indentation.add();\n+        msg.append(new CountsConstraintFailureMessageBuilder(matchResult, indentation).build());\n+        indentation.sub();\n+    }\n+\n+    public String build() {\n+        testClassMatchResult.accept(this);\n+        msg.append(System.lineSeparator())\n+           .append(\">>> Check stdout for compilation output of the failed methods\")\n+           .append(System.lineSeparator()).append(System.lineSeparator());\n+        return msg.toString();\n+    }\n+\n+    private static int digitCount(int digit) {\n+        return String.valueOf(digit).length();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/FailureMessageBuilder.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.report;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Class used by {@link FailureMessageBuilder} to handle indentations in the failure message. Each indentation level\n+ * equals 2 whitespaces.\n+ *\/\n+class Indentation {\n+    private static final int LEVEL_SIZE = 2;\n+    private int indentation;\n+\n+    public Indentation(int initialIndentation) {\n+        this.indentation = initialIndentation;\n+    }\n+\n+    public void add() {\n+        indentation += LEVEL_SIZE;\n+    }\n+\n+    public void sub() {\n+        indentation -= LEVEL_SIZE;\n+    }\n+\n+    public List<String> prependForLines(List<String> lines) {\n+        return lines.stream()\n+                    .map(s -> s.replaceAll(System.lineSeparator(), System.lineSeparator() + this))\n+                    .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \" \".repeat(indentation);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/report\/Indentation.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.visitor;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * This class invokes {@link MatchResult#accept(MatchResultVisitor)} on all failed match results (i.e. children) inside\n+ * a {@link MatchResult} object to visit them.\n+ *\/\n+public class AcceptChildren implements Consumer<MatchResultVisitor> {\n+    private final Collection<? extends MatchResult> matchResults;\n+\n+    public AcceptChildren(List<MatchResult> matchResults) {\n+        this.matchResults = matchResults;\n+    }\n+\n+    @Override\n+    public void accept(MatchResultVisitor visitor) {\n+        for (MatchResult result : matchResults) {\n+            if (result.fail()) {\n+                result.accept(visitor);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/visitor\/AcceptChildren.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.visitor;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.FailOnConstraintFailure;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This interface specifies visit methods for each {@link MatchResult} class must be implemented a by a concrete visitor.\n+ *\/\n+public interface MatchResultVisitor {\n+    void visitTestClass(AcceptChildren acceptChildren);\n+    void visitIRMethod(AcceptChildren acceptChildren, Method method, int failedIRRules);\n+    void visitMethodNotCompiled(Method method, int failedIRRules);\n+    void visitIRRule(AcceptChildren acceptChildren, int irRuleId, IR irAnno);\n+    void visitCompilePhaseIRRule(AcceptChildren acceptChildren, CompilePhase compilePhase, String compilationOutput);\n+    void visitNoCompilePhaseCompilation(CompilePhase compilePhase);\n+    void visitCheckAttribute(AcceptChildren acceptChildren, CheckAttributeType checkAttributeType);\n+    void visitFailOnConstraint(FailOnConstraintFailure failOnConstraintFailure);\n+    void visitCountsConstraint(CountsConstraintFailure countsConstraintFailure);\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/visitor\/MatchResultVisitor.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+\/**\n+ * This class collects all unique compile phases associated with all {@link IR @IR} annotations of a method.\n+ * If {@link CompilePhase#DEFAULT} is found, then we look up the default compile phases of all {@link IRNode}\n+ * placeholder strings.\n+ *\n+ * @see FlagVM\n+ * @see CompilerDirectivesFlagBuilder\n+ *\/\n+class CompilePhaseCollector {\n+\n+    \/**\n+     * Returns a map \"method name -> compile phases set\" that can be used by {@link CompilerDirectivesFlagBuilder}.\n+     *\/\n+    public static Map<String, Set<CompilePhase>> collect(Class<?> testClass) {\n+        Map<String, Set<CompilePhase>> methodNameToCompilePhasesMap = new HashMap<>();\n+        List<Method> irAnnotatedMethods = getIRAnnotatedMethods(testClass);\n+        try {\n+            for (Method method : irAnnotatedMethods) {\n+                methodNameToCompilePhasesMap.put(testClass.getCanonicalName() + \"::\" + method.getName(),\n+                                                 collectCompilePhases(method));\n+            }\n+        } catch (TestFormatException e) {\n+            \/\/ Create default map and let the IR matcher report the format failures later in the driver VM.\n+            return createDefaultMap(testClass);\n+        }\n+        return methodNameToCompilePhasesMap;\n+    }\n+\n+    private static Set<CompilePhase> collectCompilePhases(Method method) {\n+        return new MethodCompilePhaseCollector(method).collect();\n+    }\n+\n+    private static List<Method> getIRAnnotatedMethods(Class<?> testClass) {\n+        return Arrays.stream(testClass.getDeclaredMethods()).filter(m -> m.getAnnotationsByType(IR.class).length > 0).toList();\n+    }\n+\n+    \/**\n+     * Creates a default map that just contains PrintIdeal and PrintOptoAssembly.\n+     *\/\n+    private static Map<String, Set<CompilePhase>> createDefaultMap(Class<?> testClass) {\n+        Map<String, Set<CompilePhase>> defaultMap = new HashMap<>();\n+        HashSet<CompilePhase> defaultSet = new HashSet<>();\n+        defaultSet.add(CompilePhase.PRINT_IDEAL);\n+        defaultSet.add(CompilePhase.PRINT_OPTO_ASSEMBLY);\n+        defaultMap.put(testClass.getCanonicalName() + \"::*\", defaultSet);\n+        return defaultMap;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/CompilePhaseCollector.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class uses {@link CompilePhaseCollector} to collect all compile phases in order to write a compile command file\n+ * with the required compile commands for each method such that the {@link TestVM} only prints the output required by\n+ * the {@link IRMatcher} to perform IR matching.\n+ *\n+ * @see FlagVM\n+ * @see CompilePhaseCollector\n+ *\/\n+class CompilerDirectivesFlagBuilder {\n+    private final Map<String, Set<CompilePhase>> methodsToCompilePhasesMap;\n+    private int directivesCount = 0;\n+    public CompilerDirectivesFlagBuilder(Class<?> testClass) {\n+        methodsToCompilePhasesMap = CompilePhaseCollector.collect(testClass);\n+    }\n+\n+    public List<String> build() {\n+        List<String> flags = new ArrayList<>();\n+        flags.add(\"-XX:CompilerDirectivesFile=\" + FlagVM.TEST_VM_COMPILE_COMMANDS_FILE);\n+        writeDirectivesFile();\n+        flags.add(\"-XX:CompilerDirectivesLimit=\" + directivesCount + 1);\n+        return flags;\n+    }\n+\n+    private void writeDirectivesFile() {\n+        try (var writer = Files.newBufferedWriter(Paths.get(FlagVM.TEST_VM_COMPILE_COMMANDS_FILE))) {\n+            writer.write(\"[\" + System.lineSeparator());\n+            writeBody(writer);\n+            writer.write(\"]\" + System.lineSeparator());\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while writing to file \" + FlagVM.TEST_VM_COMPILE_COMMANDS_FILE, e);\n+        }\n+    }\n+\n+    private void writeBody(BufferedWriter writer) throws IOException {\n+        String methodEntries = methodsToCompilePhasesMap.entrySet()\n+                                                        .stream()\n+                                                        .map(e -> writeMethodDirectives(e.getKey(), e.getValue()))\n+                                                        .collect(Collectors.joining(\",\" + System.lineSeparator()));\n+        writer.write(methodEntries + System.lineSeparator());\n+    }\n+\n+    private String writeMethodDirectives(String methodName, Set<CompilePhase> compilePhases) {\n+        directivesCount++;\n+        StringBuilder builder = new StringBuilder();\n+        appendLine(builder, \"{\", 1);\n+        appendLine(builder, \"match : \\\"\" + methodName + \"\\\",\", 2);\n+        appendLine(builder, \"log : true,\", 2);\n+        appendPrintIdeal(compilePhases, builder);\n+        appendPrintOptoAssembly(compilePhases, builder);\n+        appendRemainingCompilePhases(compilePhases, builder);\n+        append(builder, \"}\", 1);\n+        return builder.toString();\n+    }\n+\n+    private static void appendPrintIdeal(Set<CompilePhase> compilePhases, StringBuilder builder) {\n+        if (compilePhases.remove(CompilePhase.PRINT_IDEAL)) {\n+            appendLine(builder, \"PrintIdeal : true,\", 2);\n+        }\n+    }\n+\n+    private static void appendPrintOptoAssembly(Set<CompilePhase> compilePhases, StringBuilder builder) {\n+        if (compilePhases.remove(CompilePhase.PRINT_OPTO_ASSEMBLY)) {\n+            appendLine(builder, \"PrintOptoAssembly : true,\", 2);\n+        }\n+    }\n+\n+    private static void appendRemainingCompilePhases(Set<CompilePhase> compilePhases, StringBuilder builder) {\n+        if (!compilePhases.isEmpty()) {\n+            appendLine(builder, \"PrintIdealPhase : \\\"\" + compilePhases\n+                    .stream()\n+                    .map(Enum::name)\n+                    .collect(Collectors.joining(\",\")) + \"\\\"\", 2);\n+        }\n+    }\n+\n+    private static void appendLine(StringBuilder builder, String s, int indentLevel) {\n+        append(builder, s, indentLevel);\n+        builder.append(System.lineSeparator());\n+    }\n+\n+    private static void append(StringBuilder builder, String s, int indentLevel) {\n+        builder.append(\"  \".repeat(indentLevel)).append(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/CompilerDirectivesFlagBuilder.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    public static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n+    public static final String FILE_POSTFIX = \".log\";\n@@ -49,0 +49,1 @@\n+    public static final String TEST_VM_COMPILE_COMMANDS_PREFIX = \"test-vm-compile-commands-pid-\";\n@@ -50,1 +51,2 @@\n-    private static final String TEST_VM_FLAGS_FILE;\n+    public static final String TEST_VM_FLAGS_FILE;\n+    public static final String TEST_VM_COMPILE_COMMANDS_FILE;\n@@ -56,1 +58,2 @@\n-            TEST_VM_FLAGS_FILE = TEST_VM_FLAGS_FILE_PREFIX + ProcessTools.getProcessId() + TEST_VM_FLAGS_FILE_POSTFIX;\n+            TEST_VM_FLAGS_FILE = TEST_VM_FLAGS_FILE_PREFIX + ProcessTools.getProcessId() + FILE_POSTFIX;\n+            TEST_VM_COMPILE_COMMANDS_FILE = TEST_VM_COMPILE_COMMANDS_PREFIX + ProcessTools.getProcessId() + FILE_POSTFIX;\n@@ -78,4 +81,0 @@\n-    private static String[] getPrintFlags() {\n-        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n-    }\n-\n@@ -118,9 +117,1 @@\n-            \/\/ Add print flags for IR verification\n-            cmds.addAll(Arrays.asList(getPrintFlags()));\n-            cmds.add(\"-XX:+LogCompilation\");\n-            cmds.add(\"-XX:CompileCommand=log,\" + testClass.getCanonicalName() + \"::*\");\n-            addBoolOptionForClass(cmds, testClass, \"PrintIdeal\");\n-            addBoolOptionForClass(cmds, testClass, \"PrintOptoAssembly\");\n-            \/\/ Always trap for exception throwing to not confuse IR verification\n-            cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n-            cmds.add(\"-DShouldDoIRVerification=true\");\n+            addIRVerificationFlags(cmds, testClass);\n@@ -133,2 +124,12 @@\n-    private static void addBoolOptionForClass(ArrayList<String> cmds, Class<?> testClass, String option) {\n-        cmds.add(\"-XX:CompileCommand=option,\" + testClass.getCanonicalName() + \"::*,bool,\" + option + \",true\");\n+    private static void addIRVerificationFlags(ArrayList<String> cmds, Class<?> testClass) {\n+        cmds.addAll(Arrays.asList(getPrintFlags()));\n+        cmds.add(\"-XX:+LogCompilation\");\n+        CompilerDirectivesFlagBuilder compilerDirectivesFlagBuilder = new CompilerDirectivesFlagBuilder(testClass);\n+        cmds.addAll(compilerDirectivesFlagBuilder.build());\n+        \/\/ Always trap for exception throwing to not confuse IR verification\n+        cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n+        cmds.add(\"-DShouldDoIRVerification=true\");\n+    }\n+\n+    private static String[] getPrintFlags() {\n+        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/FlagVM.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawCheckAttribute;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawCounts;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.parsing.RawFailOn;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ * This class collects the compile phases of a method by parsing all {@link IR @IR} annotations.\n+ *\n+ * @see CompilePhaseCollector\n+ *\/\n+class MethodCompilePhaseCollector {\n+    private final Set<CompilePhase> compilePhases = new HashSet<>();\n+    private final Method method;\n+\n+    public MethodCompilePhaseCollector(Method method) {\n+        this.method = method;\n+    }\n+\n+    public Set<CompilePhase> collect() {\n+        IR[] irAnnos = method.getAnnotationsByType(IR.class);\n+        for (IR irAnno : irAnnos) {\n+            collectCompilePhases(irAnno);\n+        }\n+        return compilePhases;\n+    }\n+\n+    \/**\n+     * Collect the compile phases for {@code irAnno} by looking at the {@link IR#phase()} attribute. If we find\n+     * {@link CompilePhase#DEFAULT}, we collect the default compile phases of all IR nodes in each constraint as\n+     * specified in {@link IRNode}. If we find a user defined IR node (not specified in {@link IRNode}) or a\n+     * duplicated compile phase, we throw a {@link TestFormatException}.\n+     *\/\n+    public void collectCompilePhases(IR irAnno) {\n+        for (CompilePhase compilePhase : irAnno.phase()) {\n+            if (compilePhase == CompilePhase.DEFAULT) {\n+                addDefaultPhasesForConstraint(new RawFailOn(irAnno.failOn()));\n+                addDefaultPhasesForConstraint(new RawCounts(irAnno.counts()));\n+            } else {\n+                compilePhases.add(compilePhase);\n+            }\n+        }\n+    }\n+\n+    private void addDefaultPhasesForConstraint(RawCheckAttribute rawCheckAttribute) {\n+        compilePhases.addAll(rawCheckAttribute.parseDefaultCompilePhases());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/MethodCompilePhaseCollector.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.IR;\n+\n@@ -27,1 +29,0 @@\n-import java.util.function.Function;\n@@ -30,1 +31,4 @@\n- * Comparison result of parsing a constraint with {@link ComparisonConstraintParser#parse(String, Function, String)}.\n+ * Comparison result of parsing a {@link IR#counts} constraint with {@link ComparisonConstraintParser}\n+ *\n+ * @see ComparisonConstraintParser\n+ * @see IR#counts\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/Comparison.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public class ComparisonConstraintParser<T extends Comparable<T>> {\n+public class ComparisonConstraintParser {\n@@ -38,2 +38,1 @@\n-    public static <T extends Comparable<T>> Comparison<T> parse(String constraint, Function<String, T> parseFunction,\n-                                                                String postfixErrorMsg) {\n+    public static <T extends Comparable<T>> Comparison<T> parse(String constraint, Function<String, T> parseFunction) {\n@@ -43,2 +42,1 @@\n-            TestFormat.fail(\"Provided empty value \" + postfixErrorMsg);\n-            throw new UnreachableCodeException();\n+            throw new TestFormatException(\"Provided empty value\");\n@@ -46,2 +44,1 @@\n-            TestFormat.fail(\"Provided empty value after comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n-            throw new UnreachableCodeException();\n+            throw new TestFormatException(\"Provided empty value after comparator \\\"\" + e.getComparator() + \"\\\"\");\n@@ -49,2 +46,1 @@\n-            TestFormat.fail(\"Provided invalid comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n-            throw new UnreachableCodeException();\n+            throw new TestFormatException(\"Provided invalid comparator \\\"\" + e.getComparator() + \"\\\"\");\n@@ -56,3 +52,1 @@\n-            TestFormat.fail(\"Provided invalid value \\\"\" + e.getInvalidValue() + \"\\\"\"\n-                                   + comparator + \" \" + postfixErrorMsg);\n-            throw new UnreachableCodeException();\n+            throw new TestFormatException(\"Provided invalid value \\\"\" + e.getInvalidValue() + \"\\\"\" + comparator);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ComparisonConstraintParser.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,7 @@\n+    public static void checkAndReport(boolean test, String failureMessage) {\n+        if (!test) {\n+            FAILURES.add(failureMessage);\n+            throwIfAnyFailures();\n+        }\n+    }\n+\n@@ -47,0 +54,6 @@\n+    public static void checkNoReport(boolean test, String failureMessage) {\n+        if (!test) {\n+            throw new TestFormatException(failureMessage);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.shared;\n-\n-\/**\n- * The error reporting of the IR framework is throwing exceptions unconditionally in separate methods. The calling methods,\n- * however, do not see these exceptions. As a result, Java and\/or some IDEs could complain about impossible states\n- * (e.g. uninitialized variables, null pointer dereferences etc. even though an exception will be thrown earlier).\n- * To avoid that, throw an instance of this class instead.\n- *\/\n-class UnreachableCodeException extends RuntimeException {\n-    public UnreachableCodeException() {\n-        super(\"Unreachable code\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/UnreachableCodeException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -26,1 +26,3 @@\n-import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.TestFramework;\n@@ -36,1 +38,0 @@\n-import java.util.HashSet;\n@@ -105,1 +106,1 @@\n-        if (isDefaultRegexUnsupported(irAnno)) {\n+        if (isIRNodeUnsupported(irAnno)) {\n@@ -161,1 +162,1 @@\n-            TestFormat.checkNoThrow((irAnno.applyIfCPUFeatureAnd().length % 2) == 0 && irAnno.applyIfCPUFeatureAnd().length >= 2,\n+            TestFormat.checkNoThrow(irAnno.applyIfCPUFeatureAnd().length % 2 == 0,\n@@ -166,1 +167,1 @@\n-            TestFormat.checkNoThrow((irAnno.applyIfCPUFeatureOr().length % 2) == 0 && irAnno.applyIfCPUFeatureOr().length >= 2,\n+            TestFormat.checkNoThrow(irAnno.applyIfCPUFeatureOr().length % 2 == 0,\n@@ -178,1 +179,1 @@\n-    private boolean isDefaultRegexUnsupported(IR irAnno) {\n+    private boolean isIRNodeUnsupported(IR irAnno) {\n@@ -181,1 +182,1 @@\n-                IRNode.checkDefaultRegexSupported(s);\n+                IRNode.checkIRNodeSupported(s);\n@@ -184,1 +185,1 @@\n-                IRNode.checkDefaultRegexSupported(s);\n+                IRNode.checkIRNodeSupported(s);\n@@ -320,2 +321,1 @@\n-            String postFixErrorMsg = \"for \" + kind + \" based flag \\\"\" + flag + \"\\\"\" + failAt();\n-            Comparison<T> comparison = ComparisonConstraintParser.parse(value, parseFunction, postFixErrorMsg);\n+            Comparison<T> comparison = ComparisonConstraintParser.parse(value, parseFunction);\n@@ -325,0 +325,2 @@\n+            String postFixErrorMsg = \" for \" + kind + \" based flag \\\"\" + flag + \"\\\"\" + failAt();\n+            TestFormat.failNoThrow(e.getMessage() + postFixErrorMsg);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -366,1 +366,3 @@\n-                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation. \"\n+                                    + \"For debugging purposes, -DIgnoreCompilerControls=true can be used to temporarly \"\n+                                    + \"ignore @ForceCompileClassInitializer annotations.\");\n@@ -506,1 +508,2 @@\n-                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class) && !m.isAnnotationPresent(IRs.class),\n+                                            \"Found @IR annotation on non-@Test method \" + m);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    @IR(counts = { \"vand_notI\", \" >= 1\" })\n+    @IR(counts = { IRNode.VAND_NOT_I, \" >= 1\" })\n@@ -101,1 +101,2 @@\n-    @IR(counts = { \"and_notL\", \" >= 1\" })\n+    @IR(counts = { IRNode.VAND_NOT_L, \" >= 1\" }, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(counts = { IRNode.VMASK_AND_NOT_L, \" >= 1\" }, applyIf = {\"UseSVE\", \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\" , \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -97,1 +97,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\" , \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -135,1 +135,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -141,1 +141,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -147,1 +147,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -185,1 +185,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -190,1 +190,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -195,1 +195,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -233,1 +233,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -238,1 +238,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -243,1 +243,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -283,1 +283,1 @@\n-    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {IRNode.AND_V, \" > 0 \", IRNode.XOR_V, \" > 0 \"})\n@@ -288,1 +288,1 @@\n-    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {IRNode.AND_V, \" > 0 \", IRNode.XOR_V, \" > 0 \"})\n@@ -293,1 +293,1 @@\n-    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {\"AndV\", \" > 0 \", \"XorV\", \" > 0 \"})\n+    @IR(applyIfAnd = {\"UseAVX\", \"3\", \"UseSSE\", \" > 3 \"}, counts = {IRNode.AND_V, \" > 0 \", IRNode.XOR_V, \" > 0 \"})\n@@ -331,1 +331,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -336,1 +336,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -341,1 +341,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -379,1 +379,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -384,1 +384,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -389,1 +389,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -428,1 +428,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -433,1 +433,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -438,1 +438,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -476,1 +476,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -481,1 +481,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -486,1 +486,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -529,1 +529,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n@@ -534,1 +534,1 @@\n-    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"MacroLogicV\", \" > 0 \"})\n+    @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.MACRO_LOGIC_V, \" > 0 \"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestMaskedMacroLogicVector.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    @IR(counts = {\"vmla\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLA, \"> 0\"})\n@@ -132,1 +132,1 @@\n-    @IR(counts = {\"vmla\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLA, \"> 0\"})\n@@ -151,1 +151,1 @@\n-    @IR(counts = {\"vmla\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLA, \"> 0\"})\n@@ -170,1 +170,1 @@\n-    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {\"vmla\", \"> 0\"})\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {IRNode.VMLA, \"> 0\"})\n@@ -189,1 +189,1 @@\n-    @IR(counts = {\"vmls\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLS, \"> 0\"})\n@@ -208,1 +208,1 @@\n-    @IR(counts = {\"vmls\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLS, \"> 0\"})\n@@ -227,1 +227,1 @@\n-    @IR(counts = {\"vmls\", \"> 0\"})\n+    @IR(counts = {IRNode.VMLS, \"> 0\"})\n@@ -246,1 +246,1 @@\n-    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {\"vmls\", \"> 0\"})\n+    @IR(applyIf = {\"UseSVE\", \" > 0\"}, counts = {IRNode.VMLS, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMulAddSub.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    @IR(counts = {\"vfabd\", \"> 0\"})\n+    @IR(counts = {IRNode.VFABD, \"> 0\"})\n@@ -103,1 +103,1 @@\n-    @IR(counts = {\"vfabd_masked\", \"> 0\"}, applyIf = {\"UseSVE\", \"> 0\"})\n+    @IR(counts = {IRNode.VFABD_MASKED, \"> 0\"}, applyIf = {\"UseSVE\", \"> 0\"})\n@@ -126,1 +126,1 @@\n-    @IR(counts = {\"vfabd\", \"> 0\"})\n+    @IR(counts = {IRNode.VFABD, \"> 0\"})\n@@ -144,1 +144,1 @@\n-    @IR(counts = {\"vfabd_masked\", \"> 0\"}, applyIf = {\"UseSVE\", \"> 0\"})\n+    @IR(counts = {IRNode.VFABD_MASKED, \"> 0\"}, applyIf = {\"UseSVE\", \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorAbsDiffTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    @IR(counts = { \"vmla_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLA_MASKED, \">= 1\" })\n@@ -240,1 +240,1 @@\n-    @IR(counts = { \"vmls_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLS_MASKED, \">= 1\" })\n@@ -253,1 +253,1 @@\n-    @IR(counts = { \"vmla_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLA_MASKED, \">= 1\" })\n@@ -266,1 +266,1 @@\n-    @IR(counts = { \"vmls_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLS_MASKED, \">= 1\" })\n@@ -279,1 +279,1 @@\n-    @IR(counts = { \"vmla_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLA_MASKED, \">= 1\" })\n@@ -292,1 +292,1 @@\n-    @IR(counts = { \"vmls_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLS_MASKED, \">= 1\" })\n@@ -305,1 +305,1 @@\n-    @IR(counts = { \"vmla_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLA_MASKED, \">= 1\" })\n@@ -318,1 +318,1 @@\n-    @IR(counts = { \"vmls_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VMLS_MASKED, \">= 1\" })\n@@ -331,1 +331,1 @@\n-    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFMSB_MASKED, \">= 1\" })\n@@ -344,1 +344,1 @@\n-    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFNMAD_MASKED, \">= 1\" })\n@@ -357,1 +357,1 @@\n-    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFNMSB_MASKED, \">= 1\" })\n@@ -370,1 +370,1 @@\n-    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFMSB_MASKED, \">= 1\" })\n@@ -383,1 +383,1 @@\n-    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFNMAD_MASKED, \">= 1\" })\n@@ -396,1 +396,1 @@\n-    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VFNMSB_MASKED, \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    @IR(counts = { \"LoadVectorGather\", \">= 1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" })\n@@ -102,1 +102,1 @@\n-    @IR(counts = { \"LoadVectorGatherMasked\", \">= 1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" })\n@@ -117,1 +117,1 @@\n-    @IR(counts = { \"StoreVectorScatter\", \">= 1\" })\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" })\n@@ -131,1 +131,1 @@\n-    @IR(counts = { \"StoreVectorScatterMasked\", \">= 1\" })\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @IR(counts = { \"vnotI_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VNOT_I_MASKED, \">= 1\" })\n@@ -98,1 +98,1 @@\n-    @IR(counts = { \"vnotL_masked\", \">= 1\" })\n+    @IR(counts = { IRNode.VNOT_L_MASKED, \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskedNotTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.MIN_V, \" >0 \"})\n@@ -77,1 +77,1 @@\n-    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.MIN_V, \" >0 \"})\n@@ -88,1 +88,1 @@\n-    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.MAX_V, \" >0 \"})\n@@ -99,1 +99,1 @@\n-    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.MAX_V, \" >0 \"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestAutoVecIntMinMax.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    @IR(counts = {\"PopCountVL\", \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n+    @IR(counts = {IRNode.POPCOUNT_VL, \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {\"ReverseV\" , \" > 0 \"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {IRNode.REVERSE_V , \" > 0 \"})\n@@ -92,1 +92,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseL\"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V , IRNode.REVERSE_L})\n@@ -108,1 +108,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseL\"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V , IRNode.REVERSE_L})\n@@ -124,1 +124,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {\"ReverseV\" , \" > 0 \"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, counts = {IRNode.REVERSE_V, \"> 0\"})\n@@ -140,1 +140,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseI\"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n@@ -156,1 +156,1 @@\n-  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {\"ReverseV\" , \"ReverseI\"})\n+  @IR(applyIfCPUFeature={\"avx2\", \"true\"}, failOn = {IRNode.REVERSE_V, IRNode.REVERSE_I})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBitsVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+  @IR(counts = {IRNode.REVERSE_BYTES_V, \"> 0\"})\n@@ -94,1 +94,1 @@\n-  @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+  @IR(counts = {IRNode.REVERSE_BYTES_V, \"> 0\"})\n@@ -110,1 +110,1 @@\n-  @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+  @IR(counts = {IRNode.REVERSE_BYTES_V, \"> 0\"})\n@@ -126,1 +126,1 @@\n-  @IR(counts = {\"ReverseBytesV\" , \" > 0 \"})\n+  @IR(counts = {IRNode.REVERSE_BYTES_V, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBytes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  @IR(counts = {\"RoundVD\" , \" > 0 \"})\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"})\n@@ -76,1 +76,1 @@\n-  @IR(counts = {\"RoundVF\" , \" > 0 \"})\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectAArch64.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"RoundVD\" , \" > 0 \"})\n+  @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {IRNode.ROUND_VD, \" > 0 \"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  @IR(counts = {\"SignumVD\" , \" > 0 \"})\n+  @IR(counts = {IRNode.SIGNUM_VD, \"> 0\"})\n@@ -74,1 +74,1 @@\n-  @IR(counts = {\"SignumVF\" , \" > 0 \"})\n+  @IR(counts = {IRNode.SIGNUM_VF, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSignumVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,31 +37,4 @@\n- * Multiple @IR rules can be specified at @Test methods. The framework performs a regex based match on the PrintIdeal\n- * and PrintOptoAssembly of the run test VM. Some default string regexes for IR nodes are defined in the framework\n- * IRNode class. There are two kinds of checks:\n- * <ul>\n- *     <li><p>{@link IR#failOn}: One or more (IR node) regexes that are not allowed to occur in the IR (neither in\n- *                               PrintIdeal nor in PrintOptoAssembly)<\/li>\n- *     <li><p>{@link IR#counts}: One or more regexes-count pairs specifies how often an (IR node) regex must be found in\n- *                               PrintIdeal and PrintOptoAssembly.<\/li>\n- * <\/ul>\n- * <p>\n- *\n- * One might also want to restrict the application of certain @IR rules depending on the used flags in the test VM.\n- * These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted (see\n- * {@link TestFramework}) most of them should not have an impact on the IR except for different GC flags which should\n- * be considered) to enable a verification by the framework (see below). The @IR rules thus have an option to restrict\n- * their application:\n- * <ul>\n- *     <li><p>{@link IR#applyIf}: Only apply a rule if a flag has a certain value<\/li>\n- *     <li><p>{@link IR#applyIfNot}: Only apply a rule if a flag has NOT a certain value (inverse of applyIf)<\/li>\n- *     <li><p>{@link IR#applyIfAnd}: Only apply a rule if all flags have the specified value<\/li>\n- *     <li><p>{@link IR#applyIfOr}: Only apply a rule if at least one flag has the specified value<\/li>\n- * <\/ul>\n- * <p>\n- *\n- * The framework, however, does not perform the verification if:\n- * <ul>\n- *     <li><p>-DVerifyIR=false is used<\/li>\n- *     <li><p>The test is run with a non-debug build<\/li>\n- *     <li><p>-Xcomp, -Xint, -XX:-UseCompile, -XX:CompileThreshold, -DFlipC1C2=true, or -DExcludeRandom=true are used.<\/li>\n- *     <li><p>JTreg specifies non-whitelisted flags as VM and\/or Javaoptions (could change the IR in an unexpected way)<\/li>\n- * <\/ul>\n+ * The file shows some examples how IR verification can be done by using the {@link IR @IR} annotation. Additional\n+ * comments are provided at the IR rules to explain their purpose. A more detailed and complete description about\n+ * IR verification and the possibilities to write IR tests with {@link IR @IR} annotations can be found in the\n+ * IR framework README.md file.\n@@ -73,1 +46,0 @@\n-\/\/ This test is expected to fail when run with JTreg.\n@@ -77,1 +49,1 @@\n-        TestFramework.run(); \/\/ First run tests from IRExample\n+        TestFramework.run(); \/\/ First run tests from IRExample. No failure.\n@@ -79,1 +51,1 @@\n-            TestFramework.run(FailingExamples.class); \/\/ Secondly, run tests from FailingExamples\n+            TestFramework.run(FailingExamples.class); \/\/ Secondly, run tests from FailingExamples. Expected to fail.\n@@ -87,1 +59,1 @@\n-    \/\/ Rules with failOn constraint which all pass\n+    \/\/ Rules with failOn constraint which all pass.\n@@ -89,5 +61,6 @@\n-    @IR(failOn = IRNode.LOAD) \/\/ 1 default regex\n-    @IR(failOn = {IRNode.LOAD, IRNode.LOOP}) \/\/ 2 default regexes\n-    @IR(failOn = {IRNode.LOAD, \"some regex that does not occur\"}) \/\/ 1 default regex and a user-defined regex\n-    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n-    \/\/ second string specifying an additional required information.\n+    @IR(failOn = IRNode.LOAD) \/\/ 1 (pre-defined) IR node\n+    @IR(failOn = {IRNode.LOAD, IRNode.LOOP}) \/\/ 2 IR nodes\n+    @IR(failOn = {IRNode.LOAD, \"some regex that does not occur\"}, \/\/ 1 IR node with a user-defined regex\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ Rule with special configurable IR nodes. All IR nodes with a \"_OF\" postfix expect a second string specifying an\n+    \/\/ additional required information.\n@@ -104,1 +77,1 @@\n-    \/\/ Rules with counts constraint which all pass\n+    \/\/ Rules with counts constraint which all pass.\n@@ -106,1 +79,1 @@\n-    @IR(counts = {IRNode.STORE, \"2\"}) \/\/ 1 default regex\n+    @IR(counts = {IRNode.STORE, \"2\"}) \/\/ 1 (pre-defined) IR node\n@@ -109,1 +82,1 @@\n-                  IRNode.LOAD, \"0\"}) \/\/ 2 default regexes\n+                  IRNode.LOAD, \"0\"}) \/\/ 2 IR nodes\n@@ -111,3 +84,4 @@\n-                  \"some regex that does not occur\", \"0\"}) \/\/ 1 default regex and a user-defined regex\n-    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n-    \/\/ second string specifying an additional required information.\n+                  \"some regex that does not occur\", \"0\"}, \/\/ 1 IR node and a user-defined regex\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ Rule with special configurable IR nodes. All IR nodes with a \"_OF\" postfix expect a second string specifying an\n+    \/\/ additional required information.\n@@ -122,1 +96,1 @@\n-    \/\/ @IR rules can also specify both type of checks in the same rule\n+    \/\/ @IR rules can also specify both type of checks in the same rule.\n@@ -133,0 +107,15 @@\n+\n+    \/\/ Rules on compile phases.\n+    @Test\n+    \/\/ Apply IR matching on default phase which is PrintOptoAssembly for ALLOC and PrintIdeal for LOAD\n+    @IR(failOn = {IRNode.ALLOC, IRNode.LOAD})\n+    \/\/ Apply IR matching on compile phase AFTER_PARSING.\n+    @IR(failOn = {IRNode.ALLOC, IRNode.LOAD}, phase = CompilePhase.AFTER_PARSING)\n+    \/\/ Apply IR matching on compile phase AFTER_PARSING and CCP1.\n+    @IR(counts = {IRNode.ALLOC, \"0\", IRNode.STORE_I, \"1\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.CCP1})\n+    \/\/ Apply IR matching on compile phase BEFORE_MATCHING by using a custom regex. In this case, a compile phase must\n+    \/\/ be specified as there is no default compile phase for user defined regexes.\n+    @IR(failOn = \"LoadI\", phase = CompilePhase.BEFORE_MATCHING)\n+    public void compilePhases() {\n+        iFld = 42;\n+    }\n@@ -145,1 +134,1 @@\n-    @IR(failOn = {\"LoadI\"}) \/\/ LoadI can be found in PrintIdeal letting the rule fail\n+    @IR(failOn = {\"LoadI\"}, phase = CompilePhase.PRINT_IDEAL) \/\/ LoadI can be found in PrintIdeal letting the rule fail\n@@ -153,1 +142,1 @@\n-    \/\/ Rules with counts constraint which all fail\n+    \/\/ Rules with counts constraint which all fail.\n@@ -156,1 +145,1 @@\n-    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ equivalent to failOn = IRNode.LOAD, there is 1 load\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ Equivalent to failOn = IRNode.LOAD, there is 1 load\n@@ -158,1 +147,1 @@\n-                  IRNode.LOAD, \"1\"}) \/\/ first constraint holds (there is 1 load) but 2 stores, letting this rule fail\n+                  IRNode.LOAD, \"1\"}) \/\/ First constraint holds (there is 1 load) but 2 stores, letting this rule fail\n@@ -160,4 +149,5 @@\n-                  IRNode.STORE, \"1\"}) \/\/ order does not matter\n-    @IR(counts = {\"some regex that does not occur\", \"1\"}) \/\/ user-defined regex does not occur once\n-    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n-    \/\/ second string specifying an additional required information.\n+                  IRNode.STORE, \"1\"}) \/\/ Order does not matter\n+    @IR(counts = {\"some regex that does not occur\", \"1\"},\n+        phase = CompilePhase.PRINT_IDEAL) \/\/ user-defined regex does not occur once in PrintIdeal output\n+    \/\/ Rule with special configurable IR nodes. All IR nodes with a \"_OF\" postfix expect a second string specifying an\n+    \/\/ additional required information.\n@@ -171,0 +161,20 @@\n+\n+    \/\/ Rules on compile phases which fail\n+    @Test\n+    \/\/ The compile phase BEFORE_STRINGOPTS will not be emitted for this method, resulting in an IR matching failure.\n+    @IR(failOn = IRNode.LOAD_I, phase = CompilePhase.BEFORE_STRINGOPTS)\n+    \/\/ The compile phase BEFORE_STRINGOPTS and AFTER_PARSING will not be emitted for this method. The other phases will\n+    \/\/ match on STORE_I. This results in a failure for each compile phase. The compile phase input will be sorted by\n+    \/\/ the order in which the compile phases are sorted in the enum class CompilePhase.\n+    @IR(failOn = IRNode.STORE_I, phase = {CompilePhase.BEFORE_MATCHING, CompilePhase.CCP1, CompilePhase.BEFORE_STRINGOPTS,\n+                                         CompilePhase.AFTER_CLOOPS, CompilePhase.AFTER_PARSING})\n+    \/\/ Apply IR matching on compile phase AFTER_PARSING and ITER_GVN1. After parsing, we have 2 stores and we fail\n+    \/\/ for compile phase AFTER_PARSING. However, once IGVN is over, we were able to optimize one store away, leaving\n+    \/\/ us with only 1 store and we do not fail with compile phase ITER_GVN1.\n+    @IR(counts = {IRNode.STORE_I, \"1\"},\n+        phase = {CompilePhase.AFTER_PARSING, \/\/ Fails\n+                 CompilePhase.ITER_GVN1}) \/\/ Works\n+    public void badCompilePhases() {\n+        iFld2 = 42;\n+        iFld2 = 42 + iFld2; \/\/ Removed in first IGVN iteration and replaced by iFld2 = 84\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":65,"deletions":55,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import compiler.lib.ir_framework.*;\n@@ -28,0 +27,1 @@\n+import compiler.lib.ir_framework.*;\n@@ -51,0 +51,1 @@\n+        checkPreFlagVM();\n@@ -59,0 +60,1 @@\n+        expectTestFormatException(BadIRAnnotationBeforeFlagVM.class);\n@@ -60,0 +62,2 @@\n+        expectTestFormatException(BadIRAnnotationsAfterTestVM.class);\n+        expectTestFormatException(BadIRNodeForPhase.class);\n@@ -65,0 +69,56 @@\n+    \/**\n+     * Format failures before flag VM\n+     *\/\n+    private static void checkPreFlagVM() {\n+        try {\n+            new TestFramework().setDefaultWarmup(-1);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch(Exception e) {\n+            assertViolationCount(e, 1);\n+        }\n+        try {\n+            new TestFramework().addScenarios((Scenario)null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch(Exception e) {\n+            assertViolationCount(e, 1);\n+        }\n+        try {\n+            new TestFramework().addScenarios((Scenario[])null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch(Exception e) {\n+            assertViolationCount(e, 1);\n+        }\n+        try {\n+            new TestFramework().addScenarios(new Scenario(1), null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch(Exception e) {\n+            assertViolationCount(e, 1);\n+        }\n+        try {\n+            new TestFramework().addScenarios(new Scenario(1), new Scenario(1), new Scenario(1));\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch(Exception e) {\n+            assertViolationCount(e, 2);\n+        }\n+    }\n+\n+    private static void assertViolationCount(Exception e, int violationCount) {\n+        assertTestFormatException(e);\n+        getViolationCount(e.getMessage());\n+        Asserts.assertEQ(violationCount, getViolationCount(e.getMessage()));\n+    }\n+\n+    private static void assertTestFormatException(Exception e) {\n+        if (!(e instanceof TestFormatException)) {\n+            e.printStackTrace();\n+            Asserts.fail(\"Unexpected exception\", e);\n+        }\n+    }\n+\n+    private static int getViolationCount(String msg) {\n+        Pattern pattern = Pattern.compile(\"Violations \\\\((\\\\d+)\\\\)\");\n+        Matcher matcher = pattern.matcher(msg);\n+        Asserts.assertTrue(matcher.find(), \"Could not find violations in\" + System.lineSeparator() + msg);\n+        return Integer.parseInt(matcher.group(1));\n+    }\n+\n@@ -73,14 +133,1 @@\n-            if (!(e instanceof TestFormatException)) {\n-                e.printStackTrace();\n-                Asserts.fail(\"Unexpected exception\", e);\n-            }\n-            String msg = e.getMessage();\n-            Violations violations = getViolations(clazz, helpers);\n-            violations.getFailedMethods().forEach(\n-                    f -> Asserts.assertTrue(msg.contains(f),\n-                                            \"Could not find \" + f + \" in violations\" + System.lineSeparator() + msg));\n-            Pattern pattern = Pattern.compile(\"Violations \\\\((\\\\d+)\\\\)\");\n-            Matcher matcher = pattern.matcher(msg);\n-            Asserts.assertTrue(matcher.find(), \"Could not find violations in\" + System.lineSeparator() + msg);\n-            int violationCount = Integer.parseInt(matcher.group(1));\n-            Asserts.assertEQ(violationCount, violations.getViolationCount(), msg);\n+            checkException(clazz, e, helpers);\n@@ -92,0 +139,11 @@\n+    private static void checkException(Class<?> clazz, Exception e, Class<?>[] helpers) {\n+        assertTestFormatException(e);\n+        String msg = e.getMessage();\n+        Violations violations = getViolations(clazz, helpers);\n+        violations.getFailedMethods().forEach(\n+                m -> Asserts.assertTrue(msg.contains(m),\n+                                        \"Could not find method \\\"\" + m + \"\\\" in violations\" + System.lineSeparator() + msg));\n+        int violationCount = getViolationCount(msg);\n+        Asserts.assertEQ(violationCount, violations.getViolationCount(), msg);\n+    }\n+\n@@ -652,0 +710,8 @@\n+\n+class BadIRAnnotationBeforeFlagVM {\n+\n+    @Test\n+    @IR(failOn = IRNode.CALL, phase = {})\n+    public void emptyCompilePhases() {}\n+}\n+\n@@ -656,0 +722,4 @@\n+    @IR(failOn = IRNode.CALL)\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtNonTest2() {}\n+\n@@ -668,1 +738,10 @@\n-    @Check(test = \"test2\")\n+    @Run(test = \"test2\")\n+    @IR(failOn = IRNode.CALL)\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtRun2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test3() {}\n+\n+    @Check(test = \"test3\")\n@@ -672,0 +751,9 @@\n+    @NoFail\n+    @Test\n+    public void test4() {}\n+\n+    @Check(test = \"test4\")\n+    @IR(failOn = IRNode.CALL)\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtCheck2() {}\n+\n@@ -898,0 +986,143 @@\n+class BadIRAnnotationsAfterTestVM {\n+    @Test\n+    @FailCount(4)\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"\"})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"\", IRNode.LOAD_B_OF_CLASS, \"\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"\", \"3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"\", \"3\", IRNode.LOAD_B_OF_CLASS, \"\", \"3\"})\n+    public void emtpyUserProvidedPostfix() {}\n+\n+    @Test\n+    @FailCount(2)\n+    @IR(counts = {IRNode.STORE})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\"})\n+    public void missingCountString() {}\n+\n+    @Test\n+    @FailCount(45)\n+    @IR(counts = {IRNode.STORE, IRNode.STORE})\n+    @IR(counts = {IRNode.STORE, IRNode.STORE, IRNode.STORE, IRNode.STORE})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", IRNode.STORE})\n+    @IR(counts = {IRNode.STORE, \"\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"\"})\n+    @IR(counts = {IRNode.STORE, \"<\"})\n+    @IR(counts = {IRNode.STORE, \"!\"})\n+    @IR(counts = {IRNode.STORE, \"!3\"})\n+    @IR(counts = {IRNode.STORE, \"==\"})\n+    @IR(counts = {IRNode.STORE, \"-45\"})\n+    @IR(counts = {IRNode.STORE, \"3.0\"})\n+    @IR(counts = {IRNode.STORE, \"a3\"})\n+    @IR(counts = {IRNode.STORE, \"0x1\"})\n+    @IR(counts = {IRNode.STORE, \">-45\"})\n+    @IR(counts = {IRNode.STORE, \">3.0\"})\n+    @IR(counts = {IRNode.STORE, \">a3\"})\n+    @IR(counts = {IRNode.STORE, \">0x1\"})\n+    @IR(counts = {IRNode.STORE, \"> -45\"})\n+    @IR(counts = {IRNode.STORE, \"> 3.0\"})\n+    @IR(counts = {IRNode.STORE, \"> a3\"})\n+    @IR(counts = {IRNode.STORE, \"> 0x1\"})\n+    @IR(counts = {IRNode.STORE, \" > -45\"})\n+    @IR(counts = {IRNode.STORE, \" > 3.0\"})\n+    @IR(counts = {IRNode.STORE, \" > a3\"})\n+    @IR(counts = {IRNode.STORE, \" > 0x1\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"<\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"!\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"!3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"==\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"-45\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"3.0\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"a3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"0x1\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \">-45\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \">3.0\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \">a3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \">0x1\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"> -45\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"> 3.0\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"> a3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"> 0x1\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \" > -45\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \" > 3.0\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \" > a3\"})\n+    @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \" > 0x1\"})\n+    public void wrongCountString() {}\n+}\n+\n+class BadIRNodeForPhase {\n+    @Test\n+    @FailCount(5)\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY, phase = CompilePhase.AFTER_PARSING)\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY, phase = CompilePhase.OPTIMIZE_FINISHED)\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY, phase = CompilePhase.PRINT_IDEAL)\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY, phase = CompilePhase.PRINT_OPTO_ASSEMBLY) \/\/ works\n+    @IR(failOn = IRNode.FIELD_ACCESS, phase = CompilePhase.FINAL_CODE)\n+    @IR(failOn = IRNode.FIELD_ACCESS, phase = {CompilePhase.PRINT_OPTO_ASSEMBLY, CompilePhase.DEFAULT}) \/\/ works\n+    @IR(failOn = IRNode.FIELD_ACCESS, phase = {CompilePhase.PRINT_OPTO_ASSEMBLY, CompilePhase.DEFAULT, CompilePhase.PRINT_IDEAL})\n+    public void machNode() {}\n+\n+    @Test\n+    @FailCount(2)\n+    @IR(failOn = IRNode.STORE, phase = {CompilePhase.AFTER_PARSING, CompilePhase.AFTER_PARSING})\n+    @IR(counts = {IRNode.STORE, \"0\"}, phase = {CompilePhase.AFTER_PARSING, CompilePhase.DEFAULT, CompilePhase.AFTER_PARSING})\n+    public void duplicatedPhase() {}\n+\n+    @Test\n+    @FailCount(4)\n+    @IR(failOn = IRNode.ALLOC, phase = {CompilePhase.FINAL_CODE, CompilePhase.MACRO_EXPANSION})\n+    @IR(failOn = IRNode.ALLOC, phase = CompilePhase.PRINT_IDEAL)\n+    @IR(failOn = IRNode.ALLOC, phase = {CompilePhase.ITER_GVN1, CompilePhase.AFTER_PARSING,\n+                                        CompilePhase.PRINT_OPTO_ASSEMBLY}) \/\/ works\n+    @IR(failOn = IRNode.ALLOC_ARRAY, phase = {CompilePhase.FINAL_CODE, CompilePhase.MACRO_EXPANSION})\n+    @IR(failOn = IRNode.ALLOC_ARRAY, phase = CompilePhase.PRINT_IDEAL)\n+    @IR(failOn = IRNode.ALLOC_ARRAY, phase = {CompilePhase.ITER_GVN1, CompilePhase.AFTER_PARSING,\n+                                        CompilePhase.PRINT_OPTO_ASSEMBLY}) \/\/ works\n+    public void alloc() {}\n+\n+    @Test\n+    @FailCount(9)\n+    @IR(failOn = IRNode.LOOP, phase = CompilePhase.BEFORE_BEAUTIFY_LOOPS)\n+    @IR(failOn = IRNode.COUNTED_LOOP, phase = CompilePhase.BEFORE_BEAUTIFY_LOOPS)\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN, phase = CompilePhase.BEFORE_BEAUTIFY_LOOPS)\n+    @IR(failOn = IRNode.LOOP, phase = {CompilePhase.FINAL_CODE, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.COUNTED_LOOP, phase = {CompilePhase.FINAL_CODE, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN, phase = {CompilePhase.FINAL_CODE, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.LOOP, phase = {CompilePhase.OPTIMIZE_FINISHED, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.COUNTED_LOOP, phase = {CompilePhase.OPTIMIZE_FINISHED, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN, phase = {CompilePhase.OPTIMIZE_FINISHED, CompilePhase.BEFORE_BEAUTIFY_LOOPS})\n+    @IR(failOn = IRNode.LOOP, phase = CompilePhase.FINAL_CODE) \/\/ works\n+    @IR(failOn = IRNode.COUNTED_LOOP, phase = CompilePhase.FINAL_CODE) \/\/ works\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN, phase = CompilePhase.FINAL_CODE) \/\/ works\n+    public void loops() {}\n+\n+    @Test\n+    @FailCount(6)\n+    @IR(failOn = IRNode.LOAD_VECTOR, phase = CompilePhase.BEFORE_REMOVEUSELESS) \/\/ works\n+    @IR(failOn = IRNode.STORE_VECTOR, phase = CompilePhase.BEFORE_REMOVEUSELESS) \/\/ works\n+    @IR(failOn = IRNode.VECTOR_CAST_B2X, phase = CompilePhase.BEFORE_REMOVEUSELESS) \/\/ works\n+    @IR(failOn = IRNode.LOAD_VECTOR, phase = CompilePhase.BEFORE_MATCHING) \/\/ works\n+    @IR(failOn = IRNode.STORE_VECTOR, phase = CompilePhase.BEFORE_MATCHING) \/\/ works\n+    @IR(failOn = IRNode.VECTOR_CAST_B2X, phase = CompilePhase.BEFORE_MATCHING) \/\/ works\n+    @IR(failOn = IRNode.LOAD_VECTOR, phase = {CompilePhase.MATCHING, CompilePhase.MATCHING})\n+    @IR(failOn = IRNode.STORE_VECTOR, phase = {CompilePhase.MATCHING, CompilePhase.MATCHING})\n+    @IR(failOn = IRNode.VECTOR_CAST_B2X, phase = {CompilePhase.MATCHING, CompilePhase.MATCHING})\n+    @IR(failOn = IRNode.LOAD_VECTOR, phase = CompilePhase.FINAL_CODE)\n+    @IR(failOn = IRNode.STORE_VECTOR, phase = CompilePhase.FINAL_CODE)\n+    @IR(failOn = IRNode.VECTOR_CAST_B2X, phase = CompilePhase.FINAL_CODE)\n+    public void vector() {}\n+\n+    @Test\n+    @IR(failOn = \"notAnIRNode\")\n+    public void noDefaultSpecified() {}\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTED_LOOP, phase = CompilePhase.BEFORE_REMOVEUSELESS)\n+    public void noRegexSpecifiedForPhase() {}\n+\n+    @Test\n+    @FailCount(2)\n+    @IR(failOn = \"_#asdf#_\", phase = CompilePhase.BEFORE_REMOVEUSELESS)\n+    @IR(failOn = \"_#asdf#_\")\n+    public void noIRNodeMapping() {}\n+\n+}\n+\n@@ -985,1 +1216,1 @@\n-\/\/ All classes with such an annotation have exactly one violation with the clas name in it.\n+\/\/ All classes with such an annotation have exactly one violation with the class name in it.\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBadFormat.java","additions":249,"deletions":18,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n@@ -45,1 +42,1 @@\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=option,ir_framework.tests.TestDIgnoreCompilerControls::test2,bool,PrintInlining,true\",\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=PrintInlining,ir_framework.tests.TestDIgnoreCompilerControls::test2,true\",\n@@ -51,1 +48,1 @@\n-            TestFramework.runWithFlags(\"-XX:CompileCommand=option,ir_framework.tests.TestDIgnoreCompilerControls::test2,bool,PrintInlining,true\",\n+            TestFramework.runWithFlags(\"-XX:CompileCommand=PrintInlining,ir_framework.tests.TestDIgnoreCompilerControls::test2,true\",\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestDIgnoreCompilerControls.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -243,1 +243,4 @@\n-                Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n+                Pattern pattern = Pattern.compile(compilationPrefix() + \".*both\\\\d.*\\\\R> Phase \\\"\"\n+                                                  + CompilePhase.PRINT_IDEAL.getName()\n+                                                  + \"\\\":(?:(?!PrintOpto|\" + compilationPrefix()\n+                                                  + \")[\\\\S\\\\s])+PrintOptoAssembly\");\n@@ -247,1 +250,2 @@\n-                    failures.append(\"- Could not find all both() methods, expected 7 but found \").append(bothCount).append(System.lineSeparator());\n+                    failures.append(\"- Could not find all both() methods, expected 7 but found \").append(bothCount)\n+                            .append(System.lineSeparator());\n@@ -249,1 +253,3 @@\n-                pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                pattern = Pattern.compile(compilationPrefix() + \".*ideal\\\\d.*\\\\R> Phase \\\"\"\n+                                          + CompilePhase.PRINT_IDEAL.getName()\n+                                          + \"\\\":(?:(?!\" + compilationPrefix() + \")[\\\\S\\\\s])+\");\n@@ -260,1 +266,2 @@\n-                    failures.append(\"- Could not find all ideal() methods, expected 7 but found \").append(count).append(System.lineSeparator());\n+                    failures.append(\"- Could not find all ideal() methods, expected 7 but found \").append(count)\n+                            .append(System.lineSeparator());\n@@ -262,1 +269,2 @@\n-                pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                pattern = Pattern.compile(compilationPrefix() + \".*opto\\\\d.*\\\\R> Phase \\\"PrintOptoAssembly\\\":(?:(?!\"\n+                                          + compilationPrefix()  + \")[\\\\S\\\\s])+\");\n@@ -327,1 +335,0 @@\n-                Exception e = entry.getKey();\n@@ -386,1 +393,5 @@\n-    public static void findIrIds(String output, String method, int... numbers) {\n+    private static String compilationPrefix() {\n+        return \"\\\\d\\\\) Compilation\";\n+    }\n+\n+    private static void findIrIds(String output, String method, int... numbers) {\n@@ -963,2 +974,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -973,2 +984,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -983,2 +994,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -995,2 +1006,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN) \/\/ fails\n@@ -1006,2 +1017,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -1247,0 +1258,1 @@\n+    private Object obj;\n@@ -1249,1 +1261,3 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\")\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = {\"call\"},\n+        phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1257,1 +1271,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP + \"|\" + \"call\")\n+    @IR(failOn = \"CountedLoop|call\",\n+        phase = {CompilePhase.PRINT_IDEAL, CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1265,2 +1280,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = \"call\", phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1274,1 +1289,3 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\", \"0\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"0\"})\n+    @IR(counts = {\"call\", \"0\"},\n+        phase = {CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1282,1 +1299,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP + \"|\" + \"call\", \"1\"})\n+    @IR(counts = {\"CountedLoop|call\", \"10\"},\n+        phase = {CompilePhase.PRINT_IDEAL, CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1290,2 +1308,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"0\"})\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"0\"})\n+    @IR(counts = {\"call\", \"0\"}, phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1299,2 +1317,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(counts = {\"call\", \"0\"}, phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1308,1 +1326,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1316,1 +1334,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1325,1 +1343,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1334,1 +1352,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1343,1 +1361,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1352,1 +1370,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1360,2 +1378,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"5\"})\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"5\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1369,1 +1387,1 @@\n-    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.ALLOC)\n@@ -1371,3 +1389,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1377,2 +1393,2 @@\n-    @IR(failOn = \"call\")\n-    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    @IR(failOn = IRNode.ALLOC)\n+    @IR(failOn = IRNode.STORE_F) \/\/ not fail\n@@ -1380,3 +1396,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1386,2 +1400,2 @@\n-    @IR(failOn = \"call\")\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"1\"}) \/\/ not fail\n+    @IR(failOn = IRNode.ALLOC)\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\"}) \/\/ not fail\n@@ -1390,1 +1404,1 @@\n-            dontInline();\n+            obj = new Object();\n@@ -1395,1 +1409,1 @@\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1397,3 +1411,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1403,2 +1415,2 @@\n-    @IR(failOn = IRNode.STORE) \/\/ not fail\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(failOn = IRNode.STORE_F) \/\/ not fail\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1406,3 +1418,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1412,2 +1422,2 @@\n-    @IR(counts = {IRNode.STORE, \"0\"}) \/\/ not fail\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.STORE_F, \"0\"}) \/\/ not fail\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1415,3 +1425,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1421,2 +1429,2 @@\n-    @IR(counts = {\"call\", \"10\"})\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.ALLOC, \"10\"})\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1424,3 +1432,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1617,1 +1623,1 @@\n-                                   \".*Regex \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n+                                   \".*Constraint \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n@@ -1620,1 +1626,1 @@\n-                                   \".*Regex \\\\d+:.*\\\\R.*Expected.*\");\n+                                   \".*Constraint \\\\d+:.*\\\\R.*Expected.*\");\n@@ -1640,1 +1646,1 @@\n-            pattern = Pattern.compile(\"Regex \" + regexIndex + \":.*\");\n+            pattern = Pattern.compile(\"Constraint \" + regexIndex + \":.*\");\n@@ -1643,1 +1649,1 @@\n-                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Regex \" + regexIndex);\n+                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Constraint \" + regexIndex);\n@@ -1646,2 +1652,2 @@\n-                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Regex \" + regexIndex);\n-                String[] splitRegex = categoryString.split(\"Regex \");\n+                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Constraint \" + regexIndex);\n+                String[] splitRegex = categoryString.split(\"Constraint \");\n@@ -1655,1 +1661,1 @@\n-                                               errorPrefix() + \" could not find all matches at Regex \" + regexIndex);\n+                                               errorPrefix() + \" could not find all matches at Constraint \" + regexIndex);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":79,"deletions":73,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.FlagVMProcess;\n+import compiler.lib.ir_framework.driver.TestVMProcess;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.Matchable;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.checkattribute.CheckAttributeType;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.CountsConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.constraint.FailOnConstraintFailure;\n+import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.AcceptChildren;\n+import compiler.lib.ir_framework.driver.irmatching.visitor.MatchResultVisitor;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * @test\n+ * @bug 8280378\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler1.enabled & vm.compiler2.enabled & vm.flagless\n+ * @summary Test IR matcher with different default IR nodes and compile phases.\n+ *          Normally, the framework should be called with driver.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                               -XX:+WhiteBoxAPI ir_framework.tests.TestPhaseIRMatching\n+ *\/\n+public class TestPhaseIRMatching {\n+\n+    public static void main(String[] args) {\n+        run(Basics.class);\n+        run(NoCompilationOutput.class);\n+    }\n+\n+    private static void run(Class<?> testClass) {\n+        List<String> noAdditionalFlags = new ArrayList<>();\n+        FlagVMProcess flagVMProcess = new FlagVMProcess(testClass, noAdditionalFlags);\n+        List<String> testVMFlags = flagVMProcess.getTestVMFlags();\n+        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1);\n+        MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n+        Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                                     testVMProcess.getIrEncoding());\n+        MatchResult result = testClassMatchable.match();\n+        List<Failure> expectedFails = new ExpectedFailsBuilder().build(testClass);\n+        List<Failure> foundFailures = new FailureBuilder().build(result);\n+        if (!expectedFails.equals(foundFailures)) {\n+            reportFailure(expectedFails, foundFailures);\n+        }\n+    }\n+\n+    private static void reportFailure(List<Failure> expectedFails, List<Failure> foundFailures) {\n+        List<Failure> originalExpected = new ArrayList<>(expectedFails);\n+        expectedFails.removeAll(foundFailures);\n+        foundFailures.removeAll(originalExpected);\n+        System.out.println(\"\\\"Expected Failures\\\" WITHOUT \\\"Found Failures\\\":\");\n+        if (expectedFails.isEmpty()) {\n+            System.out.println(\"[]\");\n+        } else {\n+            expectedFails.forEach(System.out::println);\n+        }\n+        System.out.println(\"\\\"Found Failures\\\" WITHOUT \\\"Expected Failures\\\":\");\n+        if (foundFailures.isEmpty()) {\n+            System.out.println(\"[]\");\n+        } else {\n+            foundFailures.forEach(System.out::println);\n+        }\n+        Asserts.fail(\"did not find the same failures\");\n+    }\n+\n+}\n+\n+class Basics {\n+    int i;\n+    long l;\n+    Object obj;\n+    Object obj2;\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE, phase = {CompilePhase.DEFAULT, CompilePhase.PRINT_IDEAL})\n+    @ExpectedFailure(ruleId = 1, failOn = 1) \/\/ Only one failure - remove duplicated phases after mapping DEFAULT\n+    public void removeDuplicates() {\n+        i = 34;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.ALLOC, IRNode.COUNTED_LOOP},\n+        counts = {IRNode.STORE, \"3\", IRNode.ALLOC, \"1\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_IDEAL, failOn = 1, counts = {1, 3})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, counts = 2)\n+\n+    @IR(failOn = {IRNode.STORE, IRNode.ALLOC, IRNode.COUNTED_LOOP})\n+    @ExpectedFailure(ruleId = 2, phase = CompilePhase.PRINT_IDEAL, failOn = 1)\n+\n+    @IR(counts = {IRNode.STORE, \"3\", IRNode.ALLOC, \"1\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 3, phase = CompilePhase.PRINT_IDEAL, counts = {1, 3})\n+    @ExpectedFailure(ruleId = 3, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, counts = 2)\n+\n+    @IR(counts = {IRNode.STORE_I, \"2\"})\n+    @ExpectedFailure(ruleId = 4, phase = CompilePhase.PRINT_IDEAL, counts = 1)\n+    public void defaultOnIdeal() {\n+        i = 34;\n+        l = 34;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_F, IRNode.ALLOC, IRNode.COUNTED_LOOP},\n+        counts = {IRNode.STORE_F, \"3\", IRNode.ALLOC, \"1\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = 2)\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_IDEAL, counts = {1, 3})\n+\n+    @IR(failOn = {IRNode.STORE_F, IRNode.ALLOC, IRNode.COUNTED_LOOP})\n+    @ExpectedFailure(ruleId = 2, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = 2)\n+\n+    @IR(counts = {IRNode.STORE_F, \"3\", IRNode.ALLOC, \"1\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 3, phase = CompilePhase.PRINT_IDEAL, counts = {1, 3})\n+\n+    @IR(failOn = {IRNode.STORE_F, IRNode.ALLOC, IRNode.COUNTED_LOOP},\n+        counts = {IRNode.STORE_F, \"3\", IRNode.ALLOC, \"2\", IRNode.COUNTED_LOOP, \"2\"})\n+\n+    @ExpectedFailure(ruleId = 4, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = 2, counts = 2)\n+    @ExpectedFailure(ruleId = 4, phase = CompilePhase.PRINT_IDEAL, counts = {1, 3})\n+\n+    @IR(counts = {IRNode.ALLOC, \"2\"})\n+    @ExpectedFailure(ruleId = 5, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, counts = 1)\n+    public Object defaultOnOptoAssembly() {\n+        return new Object();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.ALLOC, IRNode.ALLOC_OF, \"Object\", IRNode.COUNTED_LOOP},\n+        counts = {IRNode.STORE, \"20\", IRNode.ALLOC, \"1\", IRNode.ALLOC_OF, \"Object\", \"1\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = {2, 3})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.PRINT_IDEAL, failOn = 1, counts = {1, 4})\n+\n+    @IR(failOn = {IRNode.STORE, IRNode.ALLOC, IRNode.ALLOC_OF, \"Object\", IRNode.COUNTED_LOOP})\n+    @ExpectedFailure(ruleId = 2, phase = CompilePhase.PRINT_IDEAL, failOn = 1)\n+    @ExpectedFailure(ruleId = 2, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = {2, 3})\n+\n+    @IR(counts = {IRNode.STORE, \"20\", IRNode.ALLOC, \"1\", IRNode.ALLOC_OF, \"Object\", \"2\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 3, phase = CompilePhase.PRINT_IDEAL, counts = {1, 4})\n+    @ExpectedFailure(ruleId = 3, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, counts = 3)\n+\n+    @IR(failOn = {IRNode.STORE, IRNode.ALLOC, IRNode.ALLOC_OF, \"Object\", IRNode.COUNTED_LOOP},\n+        counts = {IRNode.STORE, \"20\", IRNode.ALLOC, \"2\", IRNode.ALLOC_OF, \"Object\", \"2\", IRNode.COUNTED_LOOP, \"2\"})\n+    @ExpectedFailure(ruleId = 4, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, failOn = {2, 3}, counts = {2, 3})\n+    @ExpectedFailure(ruleId = 4, phase = CompilePhase.PRINT_IDEAL, failOn = 1, counts = {1, 4})\n+\n+    @IR(counts = {IRNode.ALLOC, \"2\", IRNode.ALLOC_OF, \"Object\", \"1\"})\n+    @ExpectedFailure(ruleId = 5, phase = CompilePhase.PRINT_OPTO_ASSEMBLY, counts = 1)\n+    public void defaultOnBoth() {\n+        obj = new Object();\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP,\n+        counts = {IRNode.LOOP, \"0\", IRNode.LOOP, \"1\", IRNode.LOOP, \"2\"},\n+        phase = {CompilePhase.BEFORE_CLOOPS, CompilePhase.AFTER_CLOOPS})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.BEFORE_CLOOPS, failOn = 1, counts = {1, 2})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.AFTER_CLOOPS, counts = {2, 3})\n+    public int removeLoopsWithMultipleCompilations(int k) {\n+        if (k == 4) {\n+            \/\/ On first compilation, we exit here and emit an UCT for the remaining code.\n+            return 3;\n+        }\n+        int x = 0;\n+        for (int i = 0; i < 1000; i++) {}\n+        for (int i = 0; i < 10000; i++) {\n+            x++;\n+        }\n+        return x;\n+    }\n+\n+    @Run(test = \"removeLoopsWithMultipleCompilations\")\n+    @Warmup(1)\n+    public void run() {\n+        for (int i = 0; i < 10000; i++) {\n+            removeLoopsWithMultipleCompilations(4);\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            removeLoopsWithMultipleCompilations(3);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.COUNTED_LOOP}, counts = {IRNode.LOOP, \"0\", IRNode.LOOP, \"1\", IRNode.COUNTED_LOOP, \"0\", IRNode.COUNTED_LOOP, \"1\"}, phase = {CompilePhase.AFTER_CLOOPS, CompilePhase.BEFORE_MATCHING, CompilePhase.FINAL_CODE})\n+    @ExpectedFailure(ruleId = 1, phase = CompilePhase.AFTER_CLOOPS, failOn = {1, 2}, counts = {1, 3})\n+    \/\/ LOOP + COUNTED_LOOP\n+    @ExpectedFailure(ruleId = 1, phase = {CompilePhase.BEFORE_MATCHING, CompilePhase.FINAL_CODE}, failOn = 1, counts = {1, 4})\n+    \/\/ Only LOOP\n+    public int removeLoops2() {\n+        int x = 0;\n+        while (x < limit()) {\n+            x++;\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            x++;\n+        }\n+        return x;\n+    }\n+\n+    @DontInline\n+    public int limit() {\n+        return 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC, IRNode.ALLOC_ARRAY},\n+        counts = {IRNode.ALLOC, \"0\", IRNode.ALLOC_ARRAY, \"0\"},\n+        phase = {CompilePhase.BEFORE_REMOVEUSELESS, CompilePhase.CCP1, CompilePhase.PRINT_OPTO_ASSEMBLY, CompilePhase.DEFAULT})\n+    @ExpectedFailure(ruleId = 1, failOn = {1, 2}, counts = {1, 2},\n+                     phase = {CompilePhase.BEFORE_REMOVEUSELESS, CompilePhase.CCP1, CompilePhase.PRINT_OPTO_ASSEMBLY})\n+    public void alloc() {\n+        obj = new Object();\n+        obj2 = new Object[1];\n+    }\n+}\n+\n+class NoCompilationOutput {\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE, phase = CompilePhase.AFTER_CLOOPS)\n+    @ExpectedFailure(ruleId = 1, hasCompilation = false, phase = CompilePhase.AFTER_CLOOPS)\n+    public void badPhase1() {}\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE,\n+        phase = {\n+            CompilePhase.BEFORE_STRINGOPTS,\n+            CompilePhase.AFTER_STRINGOPTS,\n+            CompilePhase.INCREMENTAL_INLINE_STEP,\n+            CompilePhase.INCREMENTAL_INLINE_CLEANUP,\n+            CompilePhase.EXPAND_VUNBOX,\n+            CompilePhase.SCALARIZE_VBOX,\n+            CompilePhase.INLINE_VECTOR_REBOX,\n+            CompilePhase.EXPAND_VBOX,\n+            CompilePhase.ELIMINATE_VBOX_ALLOC,\n+            CompilePhase.ITER_GVN_BEFORE_EA,\n+            CompilePhase.ITER_GVN_AFTER_VECTOR,\n+            CompilePhase.BEFORE_BEAUTIFY_LOOPS,\n+            CompilePhase.AFTER_BEAUTIFY_LOOPS,\n+            CompilePhase.BEFORE_CLOOPS,\n+            CompilePhase.AFTER_CLOOPS,\n+            CompilePhase.PHASEIDEAL_BEFORE_EA,\n+            CompilePhase.AFTER_EA,\n+            CompilePhase.ITER_GVN_AFTER_EA,\n+            CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+            CompilePhase.PHASEIDEALLOOP1,\n+            CompilePhase.PHASEIDEALLOOP2,\n+            CompilePhase.PHASEIDEALLOOP3,\n+            CompilePhase.PHASEIDEALLOOP_ITERATIONS}\n+        )\n+    @ExpectedFailure(ruleId = 1, hasCompilation = false,\n+                     phase = {\n+                CompilePhase.BEFORE_STRINGOPTS,\n+                CompilePhase.AFTER_STRINGOPTS,\n+                CompilePhase.INCREMENTAL_INLINE_STEP,\n+                CompilePhase.INCREMENTAL_INLINE_CLEANUP,\n+                CompilePhase.EXPAND_VUNBOX,\n+                CompilePhase.SCALARIZE_VBOX,\n+                CompilePhase.INLINE_VECTOR_REBOX,\n+                CompilePhase.EXPAND_VBOX,\n+                CompilePhase.ELIMINATE_VBOX_ALLOC,\n+                CompilePhase.ITER_GVN_BEFORE_EA,\n+                CompilePhase.ITER_GVN_AFTER_VECTOR,\n+                CompilePhase.BEFORE_BEAUTIFY_LOOPS,\n+                CompilePhase.AFTER_BEAUTIFY_LOOPS,\n+                CompilePhase.BEFORE_CLOOPS,\n+                CompilePhase.AFTER_CLOOPS,\n+                CompilePhase.PHASEIDEAL_BEFORE_EA,\n+                CompilePhase.AFTER_EA,\n+                CompilePhase.ITER_GVN_AFTER_EA,\n+                CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+                CompilePhase.PHASEIDEALLOOP1,\n+                CompilePhase.PHASEIDEALLOOP2,\n+                CompilePhase.PHASEIDEALLOOP3,\n+                CompilePhase.PHASEIDEALLOOP_ITERATIONS}\n+    )\n+    public void badPhase2() {}\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE, phase = CompilePhase.DEFAULT)\n+    @ExpectedFailure(ruleId = -1) \/\/ No compilation found at all\n+    public void badMethod() {\n+    }\n+\n+    @Run(test = \"badMethod\", mode = RunMode.STANDALONE)\n+    public void run() {\n+    }\n+\n+}\n+\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface ExpectedFailures {\n+    ExpectedFailure[] value();\n+}\n+\n+\/**\n+ * Define an expected failure for the @IR rule with id ruleId().\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Repeatable(ExpectedFailures.class)\n+@interface ExpectedFailure {\n+    \/**\n+     * Which @IR rule are we referring to?\n+     *\/\n+    int ruleId();\n+\n+    \/**\n+     * We expect the same failures for all the specified compile phases.\n+     *\/\n+    CompilePhase[] phase() default { CompilePhase.PRINT_IDEAL };\n+\n+    \/**\n+     * List of failOn constraint IDs that failed when applying the @IR rule.\n+     *\/\n+    int[] failOn() default {};\n+\n+    \/**\n+     * List of counts constraint IDs that failed when applying the @IR rule.\n+     *\/\n+    int[] counts() default {};\n+\n+    \/**\n+     * Is a compilation expected for the specified compilation phases?\n+     *\/\n+    boolean hasCompilation() default true;\n+}\n+\n+\n+class FailureBuilder implements MatchResultVisitor {\n+    private String methodName;\n+    private int ruleId;\n+    private CompilePhase compilePhase;\n+    private final Set<Failure> failures = new HashSet<>();\n+\n+    public List<Failure> build(MatchResult testClassResult) {\n+        testClassResult.accept(this);\n+        return Failure.sort(failures);\n+    }\n+\n+    @Override\n+    public void visitTestClass(AcceptChildren acceptChildren) {\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitIRMethod(AcceptChildren acceptChildren, Method method, int failedIRRules) {\n+        methodName = method.getName();\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitMethodNotCompiled(Method method, int failedIRRules) {\n+        methodName = method.getName();\n+        failures.add(new Failure(methodName, -1, CompilePhase.DEFAULT, CheckAttributeType.FAIL_ON, -1));\n+    }\n+\n+    @Override\n+    public void visitIRRule(AcceptChildren acceptChildren, int irRuleId, IR irAnno) {\n+        ruleId = irRuleId;\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitCompilePhaseIRRule(AcceptChildren acceptChildren, CompilePhase compilePhase, String compilationOutput) {\n+        this.compilePhase = compilePhase;\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitNoCompilePhaseCompilation(CompilePhase compilePhase) {\n+        failures.add(new Failure(methodName, ruleId, compilePhase, CheckAttributeType.FAIL_ON, -1));\n+    }\n+\n+    @Override\n+    public void visitCheckAttribute(AcceptChildren acceptChildren, CheckAttributeType checkAttributeType) {\n+        acceptChildren.accept(this);\n+    }\n+\n+    @Override\n+    public void visitFailOnConstraint(FailOnConstraintFailure matchResult) {\n+        failures.add(new Failure(methodName, ruleId, compilePhase, CheckAttributeType.FAIL_ON,\n+                                 matchResult.constraintId()));\n+    }\n+\n+    @Override\n+    public void visitCountsConstraint(CountsConstraintFailure matchResult) {\n+        failures.add(new Failure(methodName, ruleId, compilePhase, CheckAttributeType.COUNTS,\n+                                 matchResult.constraintId()));\n+    }\n+}\n+\n+class ExpectedFailsBuilder {\n+    private final Set<Failure> expectedFails = new HashSet<>();\n+\n+    public List<Failure> build(Class<?> testClass) {\n+        List<Method> irAnnotatedMethods = getIRAnnotatedMethods(testClass);\n+        for (Method method : irAnnotatedMethods) {\n+            processMethod(method);\n+        }\n+        return Failure.sort(expectedFails);\n+    }\n+\n+    private static List<Method> getIRAnnotatedMethods(Class<?> testClass) {\n+        return Arrays.stream(testClass.getDeclaredMethods()).filter(m -> m.getAnnotationsByType(IR.class).length > 0).toList();\n+    }\n+\n+    private void processMethod(Method method) {\n+        ExpectedFailure[] expectedFailures = method.getAnnotationsByType(ExpectedFailure.class);\n+        for (ExpectedFailure expectedFailure : expectedFailures) {\n+            if (expectedFailure.ruleId() == -1) {\n+                expectedFails.add(new Failure(method.getName(), -1, CompilePhase.DEFAULT, CheckAttributeType.FAIL_ON, -1));\n+            } else {\n+                processFail(method, expectedFailure);\n+            }\n+        }\n+    }\n+\n+    private void processFail(Method method, ExpectedFailure expectedFailure) {\n+        for (CompilePhase phase : expectedFailure.phase()) {\n+            if (expectedFailure.hasCompilation()) {\n+                addFailureWithCompilation(method, expectedFailure, phase);\n+            } else {\n+                addFailureWithoutCompilation(method, expectedFailure, phase);\n+            }\n+        }\n+    }\n+\n+    private void addFailureWithCompilation(Method method, ExpectedFailure expectedFailure, CompilePhase phase) {\n+        if (expectedFailure.failOn().length > 0) {\n+            addFailure(method.getName(), expectedFailure.ruleId(), phase, CheckAttributeType.FAIL_ON,\n+                       expectedFailure.failOn());\n+        }\n+        if (expectedFailure.counts().length > 0) {\n+            addFailure(method.getName(), expectedFailure.ruleId(), phase, CheckAttributeType.COUNTS,\n+                       expectedFailure.counts());\n+        }\n+    }\n+\n+    private void addFailureWithoutCompilation(Method method, ExpectedFailure expectedFailure, CompilePhase phase) {\n+        expectedFails.add(new Failure(method.getName(), expectedFailure.ruleId(), phase, CheckAttributeType.FAIL_ON, -1));\n+    }\n+\n+    private void addFailure(String methodName, int ruleId, CompilePhase phase, CheckAttributeType checkAttributeType,\n+                            int[] constraintIds) {\n+        for (int constraintId : constraintIds) {\n+            expectedFails.add(new Failure(methodName, ruleId, phase, checkAttributeType,\n+                                          constraintId));\n+        }\n+    }\n+}\n+\n+record Failure(String methodName, int irRuleId, CompilePhase compilePhase, CheckAttributeType checkAttributeType,\n+               int constraintId) {\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        Failure that = (Failure)o;\n+        return methodName.equals(that.methodName)\n+               && irRuleId == that.irRuleId\n+               && compilePhase == that.compilePhase\n+               && checkAttributeType == that.checkAttributeType\n+               && constraintId == that.constraintId;\n+    }\n+\n+    public static List<Failure> sort(Set<Failure> failures) {\n+        return failures.stream().sorted(Comparator.comparing(Failure::methodName)\n+                                                  .thenComparing(Failure::irRuleId)\n+                                                  .thenComparing(Failure::compilePhase)\n+                                                  .thenComparing(Failure::checkAttributeType)\n+                                                  .thenComparing(Failure::constraintId)).collect(Collectors.toList());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -86,2 +86,0 @@\n-        } catch (Exception e) {\n-            Asserts.fail(\"Should not catch other exceptions\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenarios.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import compiler.lib.ir_framework.Scenario;\n@@ -30,2 +29,0 @@\n-import java.util.Arrays;\n-\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/Utils.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import org.junit.Assert;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+import static compiler.lib.ir_framework.CompilePhase.*;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test compile command file writer.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI compiler.lib.ir_framework.flag.TestCompilePhaseCollector\n+ *\/\n+public class TestCompileCommandFileWriter {\n+\n+    @org.junit.Test\n+    public void testIdeal() throws IOException {\n+        check(IdealOnly1.class, true, false);\n+        check(IdealOnly2.class, true, false);\n+    }\n+\n+    @org.junit.Test\n+    public void testOpto() throws IOException {\n+        check(OptoOnly1.class, false, true);\n+        check(OptoOnly2.class, false, true);\n+    }\n+\n+    @org.junit.Test\n+    public void testBoth() throws IOException {\n+        check(Both1.class, true, true);\n+        check(Both2.class, true, true);\n+    }\n+\n+    @org.junit.Test\n+    public void testOtherOnly() throws IOException {\n+        check(OtherOnly1.class, false,false, AFTER_PARSING);\n+        check(OtherOnly2.class, false,false, AFTER_PARSING, FINAL_CODE);\n+    }\n+\n+    @org.junit.Test\n+    public void testMix() throws IOException {\n+        check(Mix1.class, true,false, AFTER_PARSING);\n+        check(Mix2.class, false,true, AFTER_PARSING);\n+        check(Mix3.class, true,true, AFTER_PARSING);\n+        check(Mix4.class, true,true, AFTER_PARSING);\n+    }\n+\n+    private void check(Class<?> testClass, boolean findIdeal, boolean findOpto, CompilePhase... compilePhases) throws IOException {\n+        try (Scanner scanner = new Scanner(Paths.get(FlagVM.TEST_VM_COMPILE_COMMANDS_FILE))) {\n+            boolean foundIdeal = false;\n+            boolean foundOpto = false;\n+            boolean foundPhase = false;\n+            while (scanner.hasNextLine()) {\n+                String line = scanner.nextLine();\n+                if (isPrintIdeal(line)) {\n+                    foundIdeal = true;\n+                } else if (isPrintOptoAssembly(line)) {\n+                    foundOpto = true;\n+                } else if (isPrintIdealPhase(line, compilePhases)) {\n+                    foundPhase = true;\n+                }\n+            }\n+            Assert.assertEquals(\"PrintIdeal mismatch\", findIdeal, foundIdeal);\n+            Assert.assertEquals(\"PrintOptoAssembly mismatch\", findOpto, foundOpto);\n+            Assert.assertEquals(\"PrintIdealPhase mismatch\", compilePhases.length > 0, foundPhase);\n+        }\n+    }\n+\n+    private boolean isPrintIdeal(String line) {\n+        return line.contains(\"PrintIdeal : true\");\n+    }\n+\n+    private boolean isPrintOptoAssembly(String line) {\n+        return line.contains(\"PrintOptoAssembly : true\");\n+    }\n+\n+    private boolean isPrintIdealPhase(String line, CompilePhase... compilePhases) {\n+        if (!line.contains(\"PrintIdealPhase : \\\"\")) {\n+            return false;\n+        }\n+        return Arrays.stream(compilePhases).allMatch(compilePhase -> line.contains(compilePhase.name()));\n+    }\n+\n+    static class IdealOnly1 {\n+        @Test\n+        @IR(failOn = IRNode.STORE)\n+        public void test() {\n+        }\n+    }\n+\n+    static class IdealOnly2 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = PRINT_IDEAL)\n+        public void test() {\n+        }\n+    }\n+\n+    static class OptoOnly1 {\n+        @Test\n+        @IR(failOn = IRNode.ALLOC)\n+        public void test() {\n+        }\n+    }\n+\n+    static class OptoOnly2 {\n+        @Test\n+        @IR(failOn = IRNode.ALLOC, phase = PRINT_OPTO_ASSEMBLY)\n+        public void test() {\n+        }\n+    }\n+\n+    static class Both1 {\n+        @Test\n+        @IR(failOn = IRNode.STORE)\n+        @IR(failOn = IRNode.ALLOC)\n+        public void test() {\n+        }\n+    }\n+\n+    static class Both2 {\n+        @Test\n+        @IR(failOn = {IRNode.STORE, IRNode. ALLOC})\n+        public void test() {\n+        }\n+    }\n+\n+    static class OtherOnly1 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        public void test() {\n+        }\n+    }\n+\n+    static class OtherOnly2 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {AFTER_PARSING, FINAL_CODE})\n+        public void test() {\n+        }\n+    }\n+\n+    static class Mix1 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(failOn = IRNode.STORE, phase = PRINT_IDEAL)\n+        public void test() {\n+        }\n+    }\n+\n+    static class Mix2 {\n+        @Test\n+        @IR(failOn = IRNode.ALLOC, phase = AFTER_PARSING)\n+        @IR(failOn = IRNode.STORE, phase = PRINT_OPTO_ASSEMBLY)\n+        public void test() {\n+        }\n+    }\n+\n+    static class Mix3 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(failOn = IRNode.STORE, phase = PRINT_IDEAL)\n+        @IR(failOn = IRNode.ALLOC, phase = PRINT_OPTO_ASSEMBLY)\n+        public void test() {\n+        }\n+    }\n+\n+    static class Mix4 {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {AFTER_PARSING, PRINT_IDEAL})\n+        @IR(failOn = IRNode.ALLOC, phase = PRINT_OPTO_ASSEMBLY)\n+        public void test() {\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/flag\/TestCompileCommandFileWriter.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import org.junit.Assert;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static compiler.lib.ir_framework.CompilePhase.*;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test compile phase collector required for writing the compile commands file.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI compiler.lib.ir_framework.flag.TestCompilePhaseCollector\n+ *\/\n+public class TestCompilePhaseCollector {\n+\n+    @org.junit.Test\n+    public void testIdeal() {\n+        testDefault(Ideal.class, PRINT_IDEAL);\n+    }\n+\n+    @org.junit.Test\n+    public void testOpto() {\n+        testDefault(Opto.class, PRINT_OPTO_ASSEMBLY);\n+    }\n+\n+    @org.junit.Test\n+    public void testIdealAndOpto() {\n+        testDefault(IdealAndOpto.class, PRINT_IDEAL, PRINT_OPTO_ASSEMBLY);\n+    }\n+\n+    @org.junit.Test\n+    public void testOnlyOtherPhases() {\n+        Class<?> testClass = OnlyOtherPhases.class;\n+        Map<String, Set<CompilePhase>> methodToCompilePhases = CompilePhaseCollector.collect(testClass);\n+        assertSize(methodToCompilePhases, 8);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test1\", AFTER_PARSING);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test2\", AFTER_PARSING, BEFORE_MATCHING);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test3\", PHASEIDEALLOOP1, PHASEIDEALLOOP2);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test4\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, ITER_GVN1, ITER_GVN2);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test5\", AFTER_PARSING);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test6\", AFTER_PARSING, BEFORE_MATCHING);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test7\", PHASEIDEALLOOP1, PHASEIDEALLOOP2);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test8\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, ITER_GVN1, ITER_GVN2);\n+    }\n+\n+\n+    @org.junit.Test\n+    public void testMixedPhases() {\n+        Class<?> testClass = MixedPhases.class;\n+        Map<String, Set<CompilePhase>> methodToCompilePhases = CompilePhaseCollector.collect(testClass);\n+        assertSize(methodToCompilePhases, 33);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test1\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test2\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test3\", AFTER_PARSING, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test4\", PHASEIDEALLOOP1, PHASEIDEALLOOP2);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test5\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test6\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test7\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test8\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test1A\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test2A\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test3A\", AFTER_PARSING, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test4A\", PHASEIDEALLOOP1, PHASEIDEALLOOP2);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test5A\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test6A\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test7A\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"test8A\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix1\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix2\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix3\", AFTER_PARSING, PRINT_IDEAL, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix4\", AFTER_PARSING, PRINT_IDEAL, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix5\", AFTER_PARSING, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix6\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix7\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix8\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_IDEAL, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix9\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix10\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_OPTO_ASSEMBLY);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix11\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_OPTO_ASSEMBLY,\n+                           FINAL_CODE, OPTIMIZE_FINISHED);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix12\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_OPTO_ASSEMBLY,\n+                           FINAL_CODE, OPTIMIZE_FINISHED, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix13\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL,\n+                           FINAL_CODE, OPTIMIZE_FINISHED);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix14\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, PRINT_IDEAL,\n+                           FINAL_CODE, OPTIMIZE_FINISHED);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix15\", PHASEIDEALLOOP1, PHASEIDEALLOOP2,\n+                           FINAL_CODE, OPTIMIZE_FINISHED);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix16\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_IDEAL);\n+        assertContainsOnly(methodToCompilePhases, testClass, \"mix17\", PHASEIDEALLOOP1, PHASEIDEALLOOP2, FINAL_CODE,\n+                           OPTIMIZE_FINISHED, PRINT_OPTO_ASSEMBLY);\n+    }\n+\n+    private void testDefault(Class<?> testClass, CompilePhase... compilePhases) {\n+        Map<String, Set<CompilePhase>> methodToCompilePhases = CompilePhaseCollector.collect(testClass);\n+        assertSize(methodToCompilePhases, 6);\n+        assertFindOnly(methodToCompilePhases, testClass, compilePhases);\n+    }\n+\n+    private void assertFindOnly(Map<String, Set<CompilePhase>> methodToCompilePhases, Class<?> testClass, CompilePhase... compilePhases) {\n+        Arrays.stream(testClass.getDeclaredMethods())\n+              .forEach(m -> assertContainsOnly(methodToCompilePhases, testClass, m.getName(), compilePhases));\n+    }\n+\n+    private void assertContainsOnly(Map<String, Set<CompilePhase>> methodToCompilePhases, Class<?> testClass,\n+                                    String simpleMethodName, CompilePhase... compilePhases) {\n+        String methodName = getFullMethodName(testClass, simpleMethodName);\n+        Set<CompilePhase> compilePhaseSet = methodToCompilePhases.get(methodName);\n+        Assert.assertEquals(\"must be equal\", compilePhases.length, compilePhaseSet.size());\n+        for (CompilePhase compilePhase : compilePhases) {\n+            Assert.assertTrue(\"did not find \" + compilePhase + \" for \" + methodName,\n+                              methodToCompilePhases.get(methodName).contains(compilePhase));\n+        }\n+    }\n+\n+    private void assertSize(Map<String, Set<CompilePhase>> compilePhases, int size) {\n+        Assert.assertEquals(\"wrong number of results\", size, compilePhases.size());\n+    }\n+\n+    public String getFullMethodName(Class<?> testClass, String methodName) {\n+        return testClass.getCanonicalName() + \"::\" + methodName;\n+    }\n+\n+    static class Ideal {\n+        @Test\n+        @IR(failOn = IRNode.LOAD)\n+        public void test1() {}\n+\n+\n+        @Test\n+        @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"})\n+        public void test2() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"2\"})\n+        public void test3() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"!= 4\"})\n+        public void test4() {}\n+\n+\n+        @Test\n+        @IR(failOn = IRNode.LOAD)\n+        @IR(counts = {IRNode.STORE, \"2\"})\n+        public void test5() {}\n+\n+        @Test\n+        @IR(failOn = {IRNode.LOOP, IRNode.CALL_OF_METHOD, \"foo\"})\n+        @IR(counts = {IRNode.CLASS_CHECK_TRAP, \"2\", IRNode.LOAD_B_OF_CLASS, \"Foo\", \"> 1\"})\n+        public void test6() {}\n+    }\n+\n+    static class Opto {\n+        @Test\n+        @IR(failOn = IRNode.ALLOC)\n+        public void test1() {}\n+\n+\n+        @Test\n+        @IR(failOn = {IRNode.ALLOC_OF, \"Foo\"})\n+        public void test2() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.SCOPE_OBJECT, \"2\"})\n+        public void test3() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.ALLOC_ARRAY_OF, \"Foo\", \"!= 4\"})\n+        public void test4() {}\n+\n+\n+        @Test\n+        @IR(failOn = IRNode.FIELD_ACCESS)\n+        @IR(counts = {IRNode.CHECKCAST_ARRAY, \"2\"})\n+        public void test5() {}\n+\n+        @Test\n+        @IR(failOn = {IRNode.CHECKCAST_ARRAYCOPY, IRNode.CHECKCAST_ARRAY_OF, \"Foo\"})\n+        @IR(counts = {IRNode.ALLOC, \"2\", IRNode.ALLOC_ARRAY_OF, \"Foo\", \"> 1\"})\n+        public void test6() {}\n+    }\n+\n+    static class IdealAndOpto {\n+        @Test\n+        @IR(failOn = IRNode.ALLOC)\n+        @IR(failOn = IRNode.STORE)\n+        public void test1() {}\n+\n+\n+        @Test\n+        @IR(failOn = {IRNode.ALLOC_OF, \"Foo\"})\n+        @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"})\n+        public void test2() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.LOAD, \"2\"})\n+        @IR(counts = {IRNode.SCOPE_OBJECT, \"2\"})\n+        public void test3() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.LOAD_OF_FIELD, \"iFld\", \"!= 4\"})\n+        @IR(counts = {IRNode.ALLOC_ARRAY_OF, \"Foo\", \"!= 4\"})\n+        public void test4() {}\n+\n+\n+        @Test\n+        @IR(failOn = IRNode.FIELD_ACCESS)\n+        @IR(failOn = IRNode.LOOP)\n+        @IR(counts = {IRNode.CHECKCAST_ARRAY, \"2\"})\n+        @IR(counts = {IRNode.STORE, \"2\"})\n+        public void test5() {}\n+\n+        @Test\n+        @IR(failOn = {IRNode.STORE, IRNode.CHECKCAST_ARRAY_OF, \"Foo\"})\n+        @IR(counts = {IRNode.ALLOC, \"2\", IRNode.STORE_OF_FIELD, \"iFld\", \"> 1\"})\n+        public void test6() {}\n+    }\n+\n+    static class OnlyOtherPhases {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        public void test1() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(failOn = {IRNode.STORE_OF_FIELD, \"fld\"}, phase = BEFORE_MATCHING)\n+        public void test2() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        public void test3() {}\n+\n+        @Test\n+        @IR(failOn = {IRNode.CHECKCAST_ARRAY_OF, \"Foo\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = {IRNode.STORE_F}, phase = {ITER_GVN1, ITER_GVN2})\n+        public void test4() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = AFTER_PARSING)\n+        public void test5() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.STORE_OF_FIELD, \"fld\", \">4\"}, phase = BEFORE_MATCHING)\n+        public void test6() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"!=3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        public void test7() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.CHECKCAST_ARRAY_OF, \"Foo\", \">= 23\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.STORE_F, \"2\"}, phase = {ITER_GVN1, ITER_GVN2})\n+        public void test8() {}\n+    }\n+\n+    static class MixedPhases {\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {AFTER_PARSING, DEFAULT})\n+        public void test1() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(failOn = {IRNode.STORE_OF_FIELD, \"fld\"}, phase = DEFAULT)\n+        public void test2() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.ALLOC, phase = AFTER_PARSING)\n+        @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"Foo\"}, phase = DEFAULT)\n+        public void test3() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        public void test4() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, DEFAULT, PHASEIDEALLOOP2})\n+        public void test5() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = {IRNode.STORE_OF_FIELD, \"fld\"}, phase = DEFAULT)\n+        public void test6() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = IRNode.ALLOC, phase = DEFAULT)\n+        @IR(failOn = IRNode.STORE, phase = {FINAL_CODE, OPTIMIZE_FINISHED})\n+        public void test7() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = IRNode.STORE, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void test8() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {AFTER_PARSING, DEFAULT})\n+        public void test1A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.STORE_OF_FIELD, \"fld\", \"3\"}, phase = DEFAULT)\n+        public void test2A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.ALLOC, \"< 3\"}, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.ALLOC_ARRAY_OF, \"Foo\", \">=3\"}, phase = DEFAULT)\n+        public void test3A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        public void test4A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {PHASEIDEALLOOP1, DEFAULT, PHASEIDEALLOOP2})\n+        public void test5A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.STORE_OF_FIELD, \"fld\", \"4\"}, phase = DEFAULT)\n+        public void test6A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = DEFAULT)\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED})\n+        public void test7A() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void test8A() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = DEFAULT)\n+        public void mix1() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = DEFAULT)\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = AFTER_PARSING)\n+        public void mix2() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = DEFAULT)\n+        @IR(failOn = {IRNode.ALLOC_OF, \"Foo\"}, phase = DEFAULT)\n+        public void mix3() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = AFTER_PARSING)\n+        @IR(counts = {IRNode.STORE_OF_CLASS, \"Foo\", \"3\"}, phase = DEFAULT)\n+        @IR(failOn = IRNode.ALLOC, phase = DEFAULT)\n+        public void mix4() {}\n+\n+        @Test\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {AFTER_PARSING, DEFAULT})\n+        @IR(failOn = {IRNode.STORE_OF_CLASS, \"Foo\"}, phase = DEFAULT)\n+        public void mix5() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = DEFAULT)\n+        @IR(failOn = IRNode.STORE, phase = {FINAL_CODE, OPTIMIZE_FINISHED})\n+        public void mix6() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.STORE, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix7() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, DEFAULT, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix8() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PRINT_IDEAL, PHASEIDEALLOOP2})\n+        public void mix9() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PRINT_OPTO_ASSEMBLY, PHASEIDEALLOOP2})\n+        public void mix10() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.ALLOC, phase = {PHASEIDEALLOOP1, PRINT_OPTO_ASSEMBLY, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix11() {}\n+\n+        @Test\n+        @IR(failOn = IRNode.STORE, phase = {PHASEIDEALLOOP1, PRINT_IDEAL, PHASEIDEALLOOP2})\n+        @IR(counts = {IRNode.ALLOC, \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix12() {}\n+\n+        @Test\n+        @IR(failOn = \"foo\", phase = {PHASEIDEALLOOP1, PRINT_IDEAL, PHASEIDEALLOOP2})\n+        @IR(counts = {\"foo\", \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED})\n+        public void mix13() {}\n+\n+        @Test\n+        @IR(failOn = \"foo\", phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(counts = {\"foo\", \"3\"}, phase = {FINAL_CODE, OPTIMIZE_FINISHED, PRINT_IDEAL})\n+        public void mix14() {}\n+\n+        @Test\n+        @IR(counts = {\"foo\", \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = \"foo\", phase = {FINAL_CODE, OPTIMIZE_FINISHED})\n+        public void mix15() {}\n+\n+        @Test\n+        @IR(counts = {\"foo\", \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = IRNode.STORE, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix16() {}\n+\n+        @Test\n+        @IR(counts = {\"foo\", \"3\"}, phase = {PHASEIDEALLOOP1, PHASEIDEALLOOP2})\n+        @IR(failOn = IRNode.ALLOC, phase = {FINAL_CODE, OPTIMIZE_FINISHED, DEFAULT})\n+        public void mix17() {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/flag\/TestCompilePhaseCollector.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"}]}