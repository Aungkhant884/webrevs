{"files":[{"patch":"@@ -368,1 +368,1 @@\n-  C->print_method(CompilerPhaseType::PHASE_MACHANALYSIS, 4);\n+  C->print_method(CompilerPhaseType::PHASE_MACH_ANALYSIS, 4);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  flags(MACHANALYSIS,                 \"After mach analysis\") \\\n+  flags(MACH_ANALYSIS,                \"After mach analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    MACH_ANALYSIS(\"After mach analysis\", RegexType.MACH),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-     * Checks that there is no compile phase overlap of\n+     * Checks that there is no compile phase overlap of any {@link PhaseInterval} objects in {@code phaseRanges}.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/MultiPhaseRangeEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,63 +37,4 @@\n- * Multiple {@link IR @IR} rules can be specified at {@link Test @Test} methods. The IR framework performs a regex-based\n- * IR matching on the ideal graph compile phase (printed by compile command PrintIdealPhase) or PrintOptoAssembly (also\n- * treated as a compile phase and specified in {@link CompilePhase}) output of a method.\n- *\n- * <p>\n- * To perform a matching on a C2 IR node, the user can directly use the public static final strings defined in\n- * {@link IRNode} which mostly represent either a real IR node or group of IR nodes as found in the C2 compiler as node\n- * classes (there are rare exceptions). These strings represent special placeholder strings (referred to as\n- * \"IR placeholder string\" or just \"IR node\") which are replaced by the framework by regexes depending on which compile\n- * phases (defined with {@link IR#phase()) the IR rule should be applied on. If an IR node placeholder string cannot be\n- * used for a specific compile phase (e.g. the IR node does not exist in this phase), a format violation will be reported.\n- *\n- * <p>\n- * The exact mapping from an IR node placeholder string to regexes for different compile phases together with a default\n- * phase (see next section) is defined in a static block directly below the corresponding IR node placeholder string in\n- * {@link IRNode}.\n- *\n- * <p>\n- * The user can also directly specify user-defined regexes in combination with a required compile phase (there is no\n- * default compile phase known by the framework for custom regexes). If such a user-defined regex represents a not yet\n- * supported C2 IR node, it is highly encouraged to directly add a new IR node placeholder string definition to\n- * {@link IRNode} for it instead together with a static regex mapping block.\n- *\n- * <p>\n- * When not specifying any compile phase with {@link IR#phase()} (or explicitly setting {@link CompilePhase#DEFAULT}),\n- * the framework will perform IR matching on a default compile phase which for most IR nodes is\n- * {@link CompilePhase#PRINT_IDEAL} (output of flag -XX:+PrintIdeal, the state of the machine independent ideal graph\n- * after applying optimizations). The default phase for each IR node is defined in the static regex mapping block below\n- * each IR node placeholder string in {@link IRNode}.\n- *\n- * <p>\n- * The {@link IR @IR} annotations provides two kinds of checks:\n- * <ul>\n- *     <li><p>{@link IR#failOn}: A list of one or more IR nodes\/user-defined regexes which are not allowed to occur in\n- *                               any compilation output of any compile phase.<\/li>\n- *     <li><p>{@link IR#counts}: A list of one or more \"IR node\/user-defined regex - counter\" pairs which specify how\n- *                               often each IR node\/user-defined regex should be matched on the compilation output of\n- *                               each compile phase.<\/li>\n- * <\/ul>\n- * <p>\n- *\n- * One might also want to restrict the application of certain @IR rules depending on the used flags in the test VM.\n- * These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted in\n- * {@link TestFramework#JTREG_WHITELIST_FLAGS} (i.e. have no unexpected impact on the IR except if the flag simulates a\n- * specific machine setup like UseAVX={1,2,3} etc.) to enable an IR verification by the framework.\n- * The @IR rules thus have an option to restrict their application:\n- * <ul>\n- *     <li><p>{@link IR#applyIf}:    Only apply a rule if a flag has the specified value\/range of values.<\/li>\n- *     <li><p>{@link IR#applyIfNot}: Only apply a rule if a flag has NOT a specified value\/range of values\n- *                                   (inverse of applyIf).<\/li>\n- *     <li><p>{@link IR#applyIfAnd}: Only apply a rule if ALL flags have the specified value\/range of values.<\/li>\n- *     <li><p>{@link IR#applyIfOr}:  Only apply a rule if AT LEAST ONE flag has the specified value\/range of values.<\/li>\n- * <\/ul>\n- * <p>\n- *\n- * An IR verification cannot always be performed. Certain VM flags explicitly disable IR verification, change the IR\n- * shape in unexpected ways letting IR rules fail or even make IR verification impossible:\n- * <ul>\n- *     <li><p>-DVerifyIR=false is used<\/li>\n- *     <li><p>The test is run with a non-debug build<\/li>\n- *     <li><p>-Xcomp, -Xint, -XX:-UseCompile, -XX:CompileThreshold, -DFlipC1C2=true, or -DExcludeRandom=true are used.<\/li>\n- *     <li><p>JTreg specifies non-whitelisted flags as VM and\/or Javaoptions (could change the IR in unexpected ways).<\/li>\n- * <\/ul>\n+ * The file shows some examples how IR verification can be done by using the {@link IR @IR} annotation. Additional\n+ * comments are provided at the IR rules to explain their purpose. A more detailed and complete description about\n+ * IR verification and the possibilities to write IR tests with {@link IR @IR} annotations can be found in the\n+ * IR framework README.md file.\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":4,"deletions":63,"binary":false,"changes":67,"status":"modified"}]}