{"files":[{"patch":"@@ -63,0 +63,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        byte apply(byte a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        byte apply(byte a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2557,1 +2603,1 @@\n-        return (byte)(ROR_scalar(a,b));\n+        return (byte)(ROR_scalar(a, b));\n@@ -2599,1 +2645,1 @@\n-        return (byte)(ROL_scalar(a,b));\n+        return (byte)(ROL_scalar(a, b));\n@@ -2639,0 +2685,209 @@\n+\n+\n+\n+    static byte LSHR_binary_const(byte a) {\n+        return (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHRByte128VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHRByte128VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+    static byte LSHL_binary_const(byte a) {\n+        return (byte)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHLByte128VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHLByte128VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static byte ASHR_binary_const(byte a) {\n+        return (byte)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ASHRByte128VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ASHRByte128VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROR_binary_const(byte a) {\n+        return (byte)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void RORByte128VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void RORByte128VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROL_binary_const(byte a) {\n+        return (byte)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ROLByte128VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte128VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ROLByte128VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte128VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        byte apply(byte a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        byte apply(byte a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2557,1 +2603,1 @@\n-        return (byte)(ROR_scalar(a,b));\n+        return (byte)(ROR_scalar(a, b));\n@@ -2599,1 +2645,1 @@\n-        return (byte)(ROL_scalar(a,b));\n+        return (byte)(ROL_scalar(a, b));\n@@ -2639,0 +2685,209 @@\n+\n+\n+\n+    static byte LSHR_binary_const(byte a) {\n+        return (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHRByte256VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHRByte256VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+    static byte LSHL_binary_const(byte a) {\n+        return (byte)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHLByte256VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHLByte256VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static byte ASHR_binary_const(byte a) {\n+        return (byte)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ASHRByte256VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ASHRByte256VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROR_binary_const(byte a) {\n+        return (byte)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void RORByte256VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void RORByte256VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROL_binary_const(byte a) {\n+        return (byte)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ROLByte256VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte256VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ROLByte256VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte256VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        byte apply(byte a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        byte apply(byte a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2557,1 +2603,1 @@\n-        return (byte)(ROR_scalar(a,b));\n+        return (byte)(ROR_scalar(a, b));\n@@ -2599,1 +2645,1 @@\n-        return (byte)(ROL_scalar(a,b));\n+        return (byte)(ROL_scalar(a, b));\n@@ -2639,0 +2685,209 @@\n+\n+\n+\n+    static byte LSHR_binary_const(byte a) {\n+        return (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHRByte512VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHRByte512VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+    static byte LSHL_binary_const(byte a) {\n+        return (byte)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHLByte512VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHLByte512VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static byte ASHR_binary_const(byte a) {\n+        return (byte)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ASHRByte512VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ASHRByte512VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROR_binary_const(byte a) {\n+        return (byte)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void RORByte512VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void RORByte512VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROL_binary_const(byte a) {\n+        return (byte)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ROLByte512VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte512VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ROLByte512VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte512VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        byte apply(byte a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        byte apply(byte a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2557,1 +2603,1 @@\n-        return (byte)(ROR_scalar(a,b));\n+        return (byte)(ROR_scalar(a, b));\n@@ -2599,1 +2645,1 @@\n-        return (byte)(ROL_scalar(a,b));\n+        return (byte)(ROL_scalar(a, b));\n@@ -2639,0 +2685,209 @@\n+\n+\n+\n+    static byte LSHR_binary_const(byte a) {\n+        return (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHRByte64VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHRByte64VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+    static byte LSHL_binary_const(byte a) {\n+        return (byte)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHLByte64VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHLByte64VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static byte ASHR_binary_const(byte a) {\n+        return (byte)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ASHRByte64VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ASHRByte64VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROR_binary_const(byte a) {\n+        return (byte)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void RORByte64VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void RORByte64VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROL_binary_const(byte a) {\n+        return (byte)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ROLByte64VectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Byte64VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ROLByte64VectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Byte64VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -468,0 +470,44 @@\n+    interface FBinConstOp {\n+        byte apply(byte a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        byte apply(byte a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(byte[] r, byte[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2562,1 +2608,1 @@\n-        return (byte)(ROR_scalar(a,b));\n+        return (byte)(ROR_scalar(a, b));\n@@ -2604,1 +2650,1 @@\n-        return (byte)(ROL_scalar(a,b));\n+        return (byte)(ROL_scalar(a, b));\n@@ -2644,0 +2690,209 @@\n+\n+\n+\n+    static byte LSHR_binary_const(byte a) {\n+        return (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHRByteMaxVectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ByteMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHRByteMaxVectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ByteMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+    static byte LSHL_binary_const(byte a) {\n+        return (byte)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LSHLByteMaxVectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ByteMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LSHLByteMaxVectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ByteMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static byte ASHR_binary_const(byte a) {\n+        return (byte)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ASHRByteMaxVectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ByteMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ASHRByteMaxVectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ByteMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROR_binary_const(byte a) {\n+        return (byte)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void RORByteMaxVectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ByteMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void RORByteMaxVectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ByteMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static byte ROL_binary_const(byte a) {\n+        return (byte)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ROLByteMaxVectorTestsScalarShiftConst(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ByteMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void ROLByteMaxVectorTestsScalarShiftMaskedConst(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ByteMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        double apply(double a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        double apply(double a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1952,0 +1998,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        double apply(double a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        double apply(double a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1952,0 +1998,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        double apply(double a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        double apply(double a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1952,0 +1998,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        double apply(double a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        double apply(double a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1952,0 +1998,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n+\n@@ -468,0 +470,44 @@\n+    interface FBinConstOp {\n+        double apply(double a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        double apply(double a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(double[] r, double[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1957,0 +2003,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        float apply(float a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        float apply(float a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1962,0 +2008,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        float apply(float a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        float apply(float a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1962,0 +2008,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        float apply(float a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        float apply(float a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1962,0 +2008,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        float apply(float a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        float apply(float a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1962,0 +2008,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n+\n@@ -468,0 +470,44 @@\n+    interface FBinConstOp {\n+        float apply(float a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        float apply(float a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(float[] r, float[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -1967,0 +2013,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        int apply(int a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        int apply(int a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2522,1 +2568,1 @@\n-        return (int)(ROR_scalar(a,b));\n+        return (int)(ROR_scalar(a, b));\n@@ -2564,1 +2610,1 @@\n-        return (int)(ROL_scalar(a,b));\n+        return (int)(ROL_scalar(a, b));\n@@ -2604,0 +2650,209 @@\n+\n+    static int LSHR_binary_const(int a) {\n+        return (int)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHRInt128VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHRInt128VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static int LSHL_binary_const(int a) {\n+        return (int)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHLInt128VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHLInt128VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static int ASHR_binary_const(int a) {\n+        return (int)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ASHRInt128VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ASHRInt128VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static int ROR_binary_const(int a) {\n+        return (int)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void RORInt128VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void RORInt128VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static int ROL_binary_const(int a) {\n+        return (int)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ROLInt128VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int128VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ROLInt128VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int128VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        int apply(int a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        int apply(int a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2522,1 +2568,1 @@\n-        return (int)(ROR_scalar(a,b));\n+        return (int)(ROR_scalar(a, b));\n@@ -2564,1 +2610,1 @@\n-        return (int)(ROL_scalar(a,b));\n+        return (int)(ROL_scalar(a, b));\n@@ -2604,0 +2650,209 @@\n+\n+    static int LSHR_binary_const(int a) {\n+        return (int)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHRInt256VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHRInt256VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static int LSHL_binary_const(int a) {\n+        return (int)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHLInt256VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHLInt256VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static int ASHR_binary_const(int a) {\n+        return (int)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ASHRInt256VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ASHRInt256VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static int ROR_binary_const(int a) {\n+        return (int)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void RORInt256VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void RORInt256VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static int ROL_binary_const(int a) {\n+        return (int)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ROLInt256VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int256VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ROLInt256VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int256VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        int apply(int a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        int apply(int a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2522,1 +2568,1 @@\n-        return (int)(ROR_scalar(a,b));\n+        return (int)(ROR_scalar(a, b));\n@@ -2564,1 +2610,1 @@\n-        return (int)(ROL_scalar(a,b));\n+        return (int)(ROL_scalar(a, b));\n@@ -2604,0 +2650,209 @@\n+\n+    static int LSHR_binary_const(int a) {\n+        return (int)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHRInt512VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHRInt512VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static int LSHL_binary_const(int a) {\n+        return (int)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHLInt512VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHLInt512VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static int ASHR_binary_const(int a) {\n+        return (int)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ASHRInt512VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ASHRInt512VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static int ROR_binary_const(int a) {\n+        return (int)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void RORInt512VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void RORInt512VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static int ROL_binary_const(int a) {\n+        return (int)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ROLInt512VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int512VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ROLInt512VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int512VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        int apply(int a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        int apply(int a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2522,1 +2568,1 @@\n-        return (int)(ROR_scalar(a,b));\n+        return (int)(ROR_scalar(a, b));\n@@ -2564,1 +2610,1 @@\n-        return (int)(ROL_scalar(a,b));\n+        return (int)(ROL_scalar(a, b));\n@@ -2604,0 +2650,209 @@\n+\n+    static int LSHR_binary_const(int a) {\n+        return (int)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHRInt64VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHRInt64VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static int LSHL_binary_const(int a) {\n+        return (int)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHLInt64VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHLInt64VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static int ASHR_binary_const(int a) {\n+        return (int)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ASHRInt64VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ASHRInt64VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static int ROR_binary_const(int a) {\n+        return (int)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void RORInt64VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void RORInt64VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static int ROL_binary_const(int a) {\n+        return (int)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ROLInt64VectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Int64VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ROLInt64VectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Int64VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -468,0 +470,44 @@\n+    interface FBinConstOp {\n+        int apply(int a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        int apply(int a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(int[] r, int[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2527,1 +2573,1 @@\n-        return (int)(ROR_scalar(a,b));\n+        return (int)(ROR_scalar(a, b));\n@@ -2569,1 +2615,1 @@\n-        return (int)(ROL_scalar(a,b));\n+        return (int)(ROL_scalar(a, b));\n@@ -2609,0 +2655,209 @@\n+\n+    static int LSHR_binary_const(int a) {\n+        return (int)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHRIntMaxVectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, IntMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHRIntMaxVectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, IntMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static int LSHL_binary_const(int a) {\n+        return (int)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LSHLIntMaxVectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, IntMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LSHLIntMaxVectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, IntMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static int ASHR_binary_const(int a) {\n+        return (int)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ASHRIntMaxVectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, IntMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ASHRIntMaxVectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, IntMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static int ROR_binary_const(int a) {\n+        return (int)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void RORIntMaxVectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, IntMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void RORIntMaxVectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, IntMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static int ROL_binary_const(int a) {\n+        return (int)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ROLIntMaxVectorTestsScalarShiftConst(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, IntMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void ROLIntMaxVectorTestsScalarShiftMaskedConst(IntFunction<int[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, IntMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -420,0 +422,44 @@\n+    interface FBinConstOp {\n+        long apply(long a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        long apply(long a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2544,1 +2590,1 @@\n-        return (long)(ROR_scalar(a,b));\n+        return (long)(ROR_scalar(a, b));\n@@ -2586,1 +2632,1 @@\n-        return (long)(ROL_scalar(a,b));\n+        return (long)(ROL_scalar(a, b));\n@@ -2626,0 +2672,209 @@\n+\n+    static long LSHR_binary_const(long a) {\n+        return (long)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHRLong128VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHRLong128VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static long LSHL_binary_const(long a) {\n+        return (long)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHLLong128VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHLLong128VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static long ASHR_binary_const(long a) {\n+        return (long)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ASHRLong128VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ASHRLong128VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static long ROR_binary_const(long a) {\n+        return (long)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void RORLong128VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void RORLong128VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static long ROL_binary_const(long a) {\n+        return (long)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ROLLong128VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long128VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ROLLong128VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long128VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -420,0 +422,44 @@\n+    interface FBinConstOp {\n+        long apply(long a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        long apply(long a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2544,1 +2590,1 @@\n-        return (long)(ROR_scalar(a,b));\n+        return (long)(ROR_scalar(a, b));\n@@ -2586,1 +2632,1 @@\n-        return (long)(ROL_scalar(a,b));\n+        return (long)(ROL_scalar(a, b));\n@@ -2626,0 +2672,209 @@\n+\n+    static long LSHR_binary_const(long a) {\n+        return (long)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHRLong256VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHRLong256VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static long LSHL_binary_const(long a) {\n+        return (long)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHLLong256VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHLLong256VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static long ASHR_binary_const(long a) {\n+        return (long)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ASHRLong256VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ASHRLong256VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static long ROR_binary_const(long a) {\n+        return (long)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void RORLong256VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void RORLong256VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static long ROL_binary_const(long a) {\n+        return (long)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ROLLong256VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long256VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ROLLong256VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long256VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -420,0 +422,44 @@\n+    interface FBinConstOp {\n+        long apply(long a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        long apply(long a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2544,1 +2590,1 @@\n-        return (long)(ROR_scalar(a,b));\n+        return (long)(ROR_scalar(a, b));\n@@ -2586,1 +2632,1 @@\n-        return (long)(ROL_scalar(a,b));\n+        return (long)(ROL_scalar(a, b));\n@@ -2626,0 +2672,209 @@\n+\n+    static long LSHR_binary_const(long a) {\n+        return (long)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHRLong512VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHRLong512VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static long LSHL_binary_const(long a) {\n+        return (long)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHLLong512VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHLLong512VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static long ASHR_binary_const(long a) {\n+        return (long)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ASHRLong512VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ASHRLong512VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static long ROR_binary_const(long a) {\n+        return (long)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void RORLong512VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void RORLong512VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static long ROL_binary_const(long a) {\n+        return (long)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ROLLong512VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long512VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ROLLong512VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long512VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -420,0 +422,44 @@\n+    interface FBinConstOp {\n+        long apply(long a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        long apply(long a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2544,1 +2590,1 @@\n-        return (long)(ROR_scalar(a,b));\n+        return (long)(ROR_scalar(a, b));\n@@ -2586,1 +2632,1 @@\n-        return (long)(ROL_scalar(a,b));\n+        return (long)(ROL_scalar(a, b));\n@@ -2626,0 +2672,209 @@\n+\n+    static long LSHR_binary_const(long a) {\n+        return (long)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHRLong64VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHRLong64VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static long LSHL_binary_const(long a) {\n+        return (long)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHLLong64VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHLLong64VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static long ASHR_binary_const(long a) {\n+        return (long)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ASHRLong64VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ASHRLong64VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static long ROR_binary_const(long a) {\n+        return (long)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void RORLong64VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void RORLong64VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static long ROL_binary_const(long a) {\n+        return (long)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ROLLong64VectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Long64VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ROLLong64VectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Long64VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -425,0 +427,44 @@\n+    interface FBinConstOp {\n+        long apply(long a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        long apply(long a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(long[] r, long[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2549,1 +2595,1 @@\n-        return (long)(ROR_scalar(a,b));\n+        return (long)(ROR_scalar(a, b));\n@@ -2591,1 +2637,1 @@\n-        return (long)(ROL_scalar(a,b));\n+        return (long)(ROL_scalar(a, b));\n@@ -2631,0 +2677,209 @@\n+\n+    static long LSHR_binary_const(long a) {\n+        return (long)((a >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHRLongMaxVectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, LongMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHRLongMaxVectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, LongMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    static long LSHL_binary_const(long a) {\n+        return (long)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LSHLLongMaxVectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, LongMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LSHLLongMaxVectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, LongMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static long ASHR_binary_const(long a) {\n+        return (long)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ASHRLongMaxVectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, LongMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ASHRLongMaxVectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, LongMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static long ROR_binary_const(long a) {\n+        return (long)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void RORLongMaxVectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, LongMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void RORLongMaxVectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, LongMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static long ROL_binary_const(long a) {\n+        return (long)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ROLLongMaxVectorTestsScalarShiftConst(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, LongMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void ROLLongMaxVectorTestsScalarShiftMaskedConst(IntFunction<long[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, LongMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2547,1 +2593,1 @@\n-        return (short)(ROR_scalar(a,b));\n+        return (short)(ROR_scalar(a, b));\n@@ -2589,1 +2635,1 @@\n-        return (short)(ROL_scalar(a,b));\n+        return (short)(ROL_scalar(a, b));\n@@ -2629,0 +2675,209 @@\n+\n+\n+\n+\n+\n+    static short LSHR_binary_const(short a) {\n+        return (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHRShort128VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHRShort128VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short128VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    static short LSHL_binary_const(short a) {\n+        return (short)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHLShort128VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHLShort128VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short128VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static short ASHR_binary_const(short a) {\n+        return (short)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASHRShort128VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ASHRShort128VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short128VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static short ROR_binary_const(short a) {\n+        return (short)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void RORShort128VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void RORShort128VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short128VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static short ROL_binary_const(short a) {\n+        return (short)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ROLShort128VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short128VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ROLShort128VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short128VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2547,1 +2593,1 @@\n-        return (short)(ROR_scalar(a,b));\n+        return (short)(ROR_scalar(a, b));\n@@ -2589,1 +2635,1 @@\n-        return (short)(ROL_scalar(a,b));\n+        return (short)(ROL_scalar(a, b));\n@@ -2629,0 +2675,209 @@\n+\n+\n+\n+\n+\n+    static short LSHR_binary_const(short a) {\n+        return (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHRShort256VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHRShort256VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short256VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    static short LSHL_binary_const(short a) {\n+        return (short)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHLShort256VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHLShort256VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short256VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static short ASHR_binary_const(short a) {\n+        return (short)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASHRShort256VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ASHRShort256VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short256VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static short ROR_binary_const(short a) {\n+        return (short)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void RORShort256VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void RORShort256VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short256VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static short ROL_binary_const(short a) {\n+        return (short)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ROLShort256VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short256VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ROLShort256VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short256VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2547,1 +2593,1 @@\n-        return (short)(ROR_scalar(a,b));\n+        return (short)(ROR_scalar(a, b));\n@@ -2589,1 +2635,1 @@\n-        return (short)(ROL_scalar(a,b));\n+        return (short)(ROL_scalar(a, b));\n@@ -2629,0 +2675,209 @@\n+\n+\n+\n+\n+\n+    static short LSHR_binary_const(short a) {\n+        return (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHRShort512VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHRShort512VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short512VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    static short LSHL_binary_const(short a) {\n+        return (short)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHLShort512VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHLShort512VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short512VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static short ASHR_binary_const(short a) {\n+        return (short)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASHRShort512VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ASHRShort512VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short512VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static short ROR_binary_const(short a) {\n+        return (short)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void RORShort512VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void RORShort512VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short512VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static short ROL_binary_const(short a) {\n+        return (short)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ROLShort512VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short512VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ROLShort512VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short512VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -463,0 +465,44 @@\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2547,1 +2593,1 @@\n-        return (short)(ROR_scalar(a,b));\n+        return (short)(ROR_scalar(a, b));\n@@ -2589,1 +2635,1 @@\n-        return (short)(ROL_scalar(a,b));\n+        return (short)(ROL_scalar(a, b));\n@@ -2629,0 +2675,209 @@\n+\n+\n+\n+\n+\n+    static short LSHR_binary_const(short a) {\n+        return (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHRShort64VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHRShort64VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short64VectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    static short LSHL_binary_const(short a) {\n+        return (short)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHLShort64VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHLShort64VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short64VectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static short ASHR_binary_const(short a) {\n+        return (short)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASHRShort64VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ASHRShort64VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short64VectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static short ROR_binary_const(short a) {\n+        return (short)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void RORShort64VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void RORShort64VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short64VectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static short ROL_binary_const(short a) {\n+        return (short)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ROLShort64VectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, Short64VectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ROLShort64VectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, Short64VectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -468,0 +470,44 @@\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n@@ -2552,1 +2598,1 @@\n-        return (short)(ROR_scalar(a,b));\n+        return (short)(ROR_scalar(a, b));\n@@ -2594,1 +2640,1 @@\n-        return (short)(ROL_scalar(a,b));\n+        return (short)(ROL_scalar(a, b));\n@@ -2634,0 +2680,209 @@\n+\n+\n+\n+\n+\n+    static short LSHR_binary_const(short a) {\n+        return (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHRShortMaxVectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ShortMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHRShortMaxVectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ShortMaxVectorTests::LSHR_binary_const);\n+    }\n+\n+\n+\n+    static short LSHL_binary_const(short a) {\n+        return (short)((a << CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LSHLShortMaxVectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ShortMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LSHLShortMaxVectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ShortMaxVectorTests::LSHL_binary_const);\n+    }\n+\n+\n+\n+    static short ASHR_binary_const(short a) {\n+        return (short)((a >> CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASHRShortMaxVectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ShortMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ASHRShortMaxVectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ShortMaxVectorTests::ASHR_binary_const);\n+    }\n+\n+\n+\n+    static short ROR_binary_const(short a) {\n+        return (short)(ROR_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void RORShortMaxVectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ShortMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void RORShortMaxVectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ShortMaxVectorTests::ROR_binary_const);\n+    }\n+\n+\n+\n+    static short ROL_binary_const(short a) {\n+        return (short)(ROL_scalar(a, CONST_SHIFT));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ROLShortMaxVectorTestsScalarShiftConst(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, ShortMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ROLShortMaxVectorTestsScalarShiftMaskedConst(IntFunction<short[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftConstEquals(r, a, mask, ShortMaxVectorTests::ROL_binary_const);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":257,"deletions":2,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+shift_const_template=\"Shift-Const-op\"\n+shift_masked_const_template=\"Shift-Masked-Const-op\"\n@@ -267,1 +269,1 @@\n-function gen_shift_cst_op {\n+function gen_shift_op {\n@@ -273,0 +275,6 @@\n+function gen_shift_cst_op {\n+  echo \"Generating Shift constant op $1 ($2)...\"\n+  gen_op_tmpl $shift_const_template \"$@\"\n+  gen_op_tmpl $shift_masked_const_template \"$@\"\n+}\n+\n@@ -427,9 +435,9 @@\n-gen_shift_cst_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_shift_cst_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n-gen_shift_cst_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n-gen_shift_cst_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n+gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n+gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n+gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n+gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n+gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n+gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n+gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n@@ -438,2 +446,11 @@\n-gen_shift_cst_op  \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n+gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n+\n+# Constant Shifts\n+gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n+gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n+gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n+gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n+gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Shift-Const-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Shift-Masked-Const-op.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+    static $type$ [[TEST]]_binary_const($type$ a) {\n+        return ($type$)([[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$ScalarShiftConst(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertShiftConstEquals(r, a, $vectorteststype$::[[TEST]]_binary_const);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-Const-op.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$ScalarShiftMaskedConst(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertShiftConstEquals(r, a, mask, $vectorteststype$::[[TEST]]_binary_const);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-Masked-Const-op.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -92,0 +92,2 @@\n+    private static final $type$ CONST_SHIFT = $Boxtype$.SIZE \/ 2;\n+\n@@ -494,0 +496,44 @@\n+    interface FBinConstOp {\n+        $type$ apply($type$ a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        $type$ apply($type$ a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals($type$[] r, $type$[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals($type$[] r, $type$[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals($type$[] r, $type$[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}