{"files":[{"patch":"@@ -2546,1 +2546,1 @@\n-RegSet MacroAssembler::call_clobbered_registers() {\n+RegSet MacroAssembler::call_clobbered_gp_registers() {\n@@ -2556,1 +2556,1 @@\n-  push(call_clobbered_registers() - exclude, sp);\n+  push(call_clobbered_gp_registers() - exclude, sp);\n@@ -2578,1 +2578,1 @@\n-  pop(call_clobbered_registers() - exclude, sp);\n+  pop(call_clobbered_gp_registers() - exclude, sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-  static RegSet call_clobbered_registers();\n+  static RegSet call_clobbered_gp_registers();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,73 +317,0 @@\n-template <class RegImpl = Register> class RegSetIterator;\n-\n-\/\/ A set of registers\n-template <class RegImpl>\n-class AbstractRegSet {\n-  uint32_t _bitset;\n-\n-  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n-\n-public:\n-\n-  AbstractRegSet() : _bitset(0) { }\n-\n-  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n-\n-  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n-    AbstractRegSet result(_bitset | aSet._bitset);\n-    return result;\n-  }\n-\n-  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n-    AbstractRegSet result(_bitset & ~aSet._bitset);\n-    return result;\n-  }\n-\n-  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n-    *this = *this + aSet;\n-    return *this;\n-  }\n-\n-  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n-    *this = *this - aSet;\n-    return *this;\n-  }\n-\n-  static AbstractRegSet of(RegImpl r1) {\n-    return AbstractRegSet(r1);\n-  }\n-\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n-    return of(r1) + r2;\n-  }\n-\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n-    return of(r1, r2) + r3;\n-  }\n-\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n-    return of(r1, r2, r3) + r4;\n-  }\n-\n-  static AbstractRegSet range(RegImpl start, RegImpl end) {\n-    uint32_t bits = ~0;\n-    bits <<= start->encoding();\n-    bits <<= 31 - end->encoding();\n-    bits >>= 31 - end->encoding();\n-\n-    return AbstractRegSet(bits);\n-  }\n-\n-  uint32_t bits() const { return _bitset; }\n-\n-private:\n-\n-  RegImpl first();\n-\n-public:\n-\n-  friend class RegSetIterator<RegImpl>;\n-\n-  RegSetIterator<RegImpl> begin();\n-};\n-\n@@ -394,32 +321,0 @@\n-template <class RegImpl>\n-class RegSetIterator {\n-  AbstractRegSet<RegImpl> _regs;\n-\n-public:\n-  RegSetIterator(AbstractRegSet<RegImpl> x): _regs(x) {}\n-  RegSetIterator(const RegSetIterator& mit) : _regs(mit._regs) {}\n-\n-  RegSetIterator& operator++() {\n-    RegImpl r = _regs.first();\n-    if (r->is_valid())\n-      _regs -= r;\n-    return *this;\n-  }\n-\n-  bool operator==(const RegSetIterator& rhs) const {\n-    return _regs.bits() == rhs._regs.bits();\n-  }\n-  bool operator!=(const RegSetIterator& rhs) const {\n-    return ! (rhs == *this);\n-  }\n-\n-  RegImpl operator*() {\n-    return _regs.first();\n-  }\n-};\n-\n-template <class RegImpl>\n-inline RegSetIterator<RegImpl> AbstractRegSet<RegImpl>::begin() {\n-  return RegSetIterator<RegImpl>(*this);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"asm\/register.hpp\"\n@@ -1323,1 +1324,1 @@\n-      = MacroAssembler::call_clobbered_registers() - rscratch1;\n+      = MacroAssembler::call_clobbered_gp_registers() - rscratch1;\n@@ -1326,1 +1327,1 @@\n-    for (RegSetIterator<> it = clobbered.begin(); *it != noreg; ++it) {\n+    for (RegSetIterator<Register> it = clobbered.begin(); *it != noreg; ++it) {\n@@ -6632,1 +6633,1 @@\n-      RegSetIterator<> regs = (RegSet::range(r0, r26) - r18_tls).begin();\n+      RegSetIterator<Register> regs = (RegSet::range(r0, r26) - r18_tls).begin();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    __ pusha();                      \/\/ push registers\n+    __ push_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -93,1 +93,1 @@\n-    __ popa();\n+    __ pop_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -101,1 +101,1 @@\n-  __ pusha();             \/\/ push registers (overkill)\n+  __ push_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -117,1 +117,1 @@\n-  __ popa();\n+  __ pop_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -207,2 +207,0 @@\n-  \/\/ save the live input values\n-  if(tosca_live) __ push(rax);\n@@ -210,2 +208,6 @@\n-  if (obj != noreg && obj != rax)\n-    __ push(obj);\n+  \/\/ Determine and save the live input values\n+  RegSet saved;\n+  if (tosca_live) saved += RegSet::of(rax);\n+  if (obj != noreg && obj != rax) saved += RegSet::of(obj);\n+  if (pre_val != rax) saved += RegSet::of(pre_val);\n+  NOT_LP64( saved += RegSet::of(thread); )\n@@ -213,2 +215,1 @@\n-  if (pre_val != rax)\n-    __ push(pre_val);\n+  __ push_set(saved);\n@@ -228,2 +229,0 @@\n-  NOT_LP64( __ push(thread); )\n-\n@@ -247,11 +246,1 @@\n-\n-  NOT_LP64( __ pop(thread); )\n-\n-  \/\/ save the live input values\n-  if (pre_val != rax)\n-    __ pop(pre_val);\n-\n-  if (obj != noreg && obj != rax)\n-    __ pop(obj);\n-\n-  if(tosca_live) __ pop(rax);\n+  __ pop_set(saved);\n@@ -331,5 +320,2 @@\n-  __ push(store_addr);\n-#ifdef _LP64\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);\n-#else\n-  __ push(thread);\n+  RegSet saved = RegSet::of(store_addr NOT_LP64(COMMA thread));\n+  __ push_set(saved);\n@@ -337,3 +323,1 @@\n-  __ pop(thread);\n-#endif\n-  __ pop(store_addr);\n+  __ pop_set(saved);\n@@ -499,1 +483,1 @@\n-  __ save_live_registers_no_oop_map(true);\n+  __ push_call_clobbered_registers();\n@@ -505,1 +489,1 @@\n-  __ restore_live_registers(true);\n+  __ pop_call_clobbered_registers();\n@@ -518,3 +502,0 @@\n-  \/\/ arg0: store_address\n-  Address store_addr(rbp, 2*BytesPerWord);\n-\n@@ -576,2 +557,1 @@\n-\n-  __ save_live_registers_no_oop_map(true);\n+  __ push_call_clobbered_registers();\n@@ -581,1 +561,1 @@\n-  __ restore_live_registers(true);\n+  __ pop_call_clobbered_registers();\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"c1\/c1_FrameMap.hpp\"\n@@ -3581,0 +3582,184 @@\n+RegSet MacroAssembler::call_clobbered_gp_registers() {\n+  RegSet regs;\n+#ifdef _LP64\n+  regs += RegSet::of(rax, rcx, rdx);\n+#ifndef WINDOWS\n+  regs += RegSet::of(rsi, rdi);\n+#endif\n+  regs += RegSet::range(r8, r11);\n+#else\n+  regs += RegSet::of(rax, rcx, rdx);\n+#endif\n+  return regs;\n+}\n+\n+XMMRegSet MacroAssembler::call_clobbered_xmm_registers() {\n+#if defined(WINDOWS) && defined(_LP64)\n+  XMMRegSet result = XMMRegSet::range(xmm0, xmm5);\n+  if (FrameMap::get_num_caller_save_xmms() > 16) {\n+     result += XMMRegSet::range(xmm16, as_XMMRegister(FrameMap::get_num_caller_save_xmms() - 1));\n+  }\n+  return result;\n+#else\n+  return XMMRegSet::range(xmm0, as_XMMRegister(FrameMap::get_num_caller_save_xmms() - 1));\n+#endif\n+}\n+\n+static int FPUSaveAreaSize = align_up(108, StackAlignmentInBytes); \/\/ 108 bytes needed for FPU state by fsave\/frstor\n+\n+#ifndef _LP64\n+static bool use_x87_registers() { return UseSSE < 2; }\n+#endif\n+static bool use_xmm_registers() { return UseSSE >= 1; }\n+\n+\/\/ C1 only ever uses the first double\/float of the XMM register.\n+static int xmm_save_size() { return UseSSE >= 2 ? sizeof(double) : sizeof(float); }\n+\n+static void save_xmm_register(MacroAssembler* masm, int offset, XMMRegister reg) {\n+  if (UseSSE == 1) {\n+    masm->movflt(Address(rsp, offset), reg);\n+  } else {\n+    masm->movdbl(Address(rsp, offset), reg);\n+  }\n+}\n+\n+static void restore_xmm_register(MacroAssembler* masm, int offset, XMMRegister reg) {\n+  if (UseSSE == 1) {\n+    masm->movflt(reg, Address(rsp, offset));\n+  } else {\n+    masm->movdbl(reg, Address(rsp, offset));\n+  }\n+}\n+\n+int register_section_sizes(RegSet gp_registers, XMMRegSet xmm_registers, bool save_fpu,\n+                           int& gp_area_size, int& fp_area_size, int& xmm_area_size) {\n+\n+  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+                         StackAlignmentInBytes);\n+#ifdef _LP64\n+  fp_area_size = 0;\n+#else\n+  fp_area_size = (save_fpu && use_x87_registers()) ? FPUSaveAreaSize : 0;\n+#endif\n+  xmm_area_size = (save_fpu && use_xmm_registers()) ? xmm_registers.size() * xmm_save_size() : 0;\n+\n+  return gp_area_size + fp_area_size + xmm_area_size;\n+}\n+\n+void MacroAssembler::push_call_clobbered_registers_except(RegSet exclude, bool save_fpu) {\n+  block_comment(\"push_call_clobbered_registers start\");\n+  \/\/ Regular registers\n+  RegSet gp_registers_to_push = call_clobbered_gp_registers() - exclude;\n+\n+  int gp_area_size;\n+  int fp_area_size;\n+  int xmm_area_size;\n+  int total_save_size = register_section_sizes(gp_registers_to_push, call_clobbered_xmm_registers(), save_fpu,\n+                                               gp_area_size, fp_area_size, xmm_area_size);\n+  subptr(rsp, total_save_size);\n+\n+  push_set(gp_registers_to_push, 0);\n+\n+#ifndef _LP64\n+  if (save_fpu && use_x87_registers()) {\n+    fnsave(Address(rsp, gp_area_size));\n+    fwait();\n+  }\n+#endif\n+  if (save_fpu && use_xmm_registers()) {\n+    push_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  }\n+\n+  block_comment(\"push_call_clobbered_registers end\");\n+}\n+\n+void MacroAssembler::pop_call_clobbered_registers_except(RegSet exclude, bool restore_fpu) {\n+  block_comment(\"pop_call_clobbered_registers start\");\n+\n+  RegSet gp_registers_to_pop = call_clobbered_gp_registers() - exclude;\n+\n+  int gp_area_size;\n+  int fp_area_size;\n+  int xmm_area_size;\n+  int total_save_size = register_section_sizes(gp_registers_to_pop, call_clobbered_xmm_registers(), restore_fpu,\n+                                               gp_area_size, fp_area_size, xmm_area_size);\n+\n+  if (restore_fpu && use_xmm_registers()) {\n+    pop_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  }\n+#ifndef _LP64\n+  if (restore_fpu && use_x87_registers()) {\n+    frstor(Address(rsp, gp_area_size));\n+  }\n+#endif\n+\n+  pop_set(gp_registers_to_pop, 0);\n+\n+  addptr(rsp, total_save_size);\n+\n+  vzeroupper();\n+\n+  block_comment(\"pop_call_clobbered_registers end\");\n+}\n+\n+void MacroAssembler::push_set(XMMRegSet set, int offset) {\n+  assert(is_aligned(set.size() * xmm_save_size(), StackAlignmentInBytes), \"must be\");\n+  int spill_offset = offset;\n+\n+  for (RegSetIterator<XMMRegister> it = set.begin(); *it != xnoreg; ++it) {\n+    save_xmm_register(this, spill_offset, *it);\n+    spill_offset += xmm_save_size();\n+  }\n+}\n+\n+void MacroAssembler::pop_set(XMMRegSet set, int offset) {\n+  int restore_size = set.size() * xmm_save_size();\n+  assert(is_aligned(restore_size, StackAlignmentInBytes), \"must be\");\n+\n+  int restore_offset = offset + restore_size - xmm_save_size();\n+\n+  for (ReverseRegSetIterator<XMMRegister> it = set.rbegin(); *it != xnoreg; ++it) {\n+    restore_xmm_register(this, restore_offset, *it);\n+    restore_offset -= xmm_save_size();\n+  }\n+}\n+\n+void MacroAssembler::push_set(RegSet set, int offset) {\n+  int spill_offset;\n+  if (offset == -1) {\n+    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int aligned_size = align_up(register_push_size, StackAlignmentInBytes);\n+    subptr(rsp, aligned_size);\n+    spill_offset = 0;\n+  } else {\n+    spill_offset = offset;\n+  }\n+\n+  for (RegSetIterator<Register> it = set.begin(); *it != noreg; ++it) {\n+    movptr(Address(rsp, spill_offset), *it);\n+    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  }\n+}\n+\n+void MacroAssembler::pop_set(RegSet set, int offset) {\n+\n+  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int restore_size = set.size() * gp_reg_size;\n+  int aligned_size = align_up(restore_size, StackAlignmentInBytes);\n+\n+  int restore_offset;\n+  if (offset == -1) {\n+    restore_offset = restore_size - gp_reg_size;\n+  } else {\n+    restore_offset = offset + restore_size - gp_reg_size;\n+  }\n+  for (ReverseRegSetIterator<Register> it = set.rbegin(); *it != noreg; ++it) {\n+    movptr(*it, Address(rsp, restore_offset));\n+    restore_offset -= gp_reg_size;\n+  }\n+\n+  if (offset == -1) {\n+    addptr(rsp, aligned_size);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"asm\/register.hpp\"\n@@ -524,0 +525,29 @@\n+private:\n+  \/\/ General purpose and XMM registers potentially clobbered by native code; there\n+  \/\/ is no need for FPU or AVX opmask related methods because C1\/interpreter\n+  \/\/ - we save\/restore FPU state as a whole always\n+  \/\/ - do not care about AVX-512 opmask\n+  static RegSet call_clobbered_gp_registers();\n+  static XMMRegSet call_clobbered_xmm_registers();\n+\n+  void push_set(XMMRegSet set, int offset);\n+  void pop_set(XMMRegSet set, int offset);\n+\n+public:\n+  void push_set(RegSet set, int offset = -1);\n+  void pop_set(RegSet set, int offset = -1);\n+\n+  \/\/ Push and pop everything that might be clobbered by a native\n+  \/\/ runtime call.\n+  \/\/ Only save the lower 64 bits of each vector register.\n+  \/\/ Additonal registers can be excluded in a passed RegSet.\n+  void push_call_clobbered_registers_except(RegSet exclude, bool save_fpu = true);\n+  void pop_call_clobbered_registers_except(RegSet exclude, bool restore_fpu = true);\n+\n+  void push_call_clobbered_registers(bool save_fpu = true) {\n+    push_call_clobbered_registers_except(RegSet(), save_fpu);\n+  }\n+  void pop_call_clobbered_registers(bool restore_fpu = true) {\n+    pop_call_clobbered_registers_except(RegSet(), restore_fpu);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"utilities\/count_leading_zeros.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -275,0 +277,29 @@\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_Register(exact_log2(first)) : noreg;\n+}\n+\n+template <>\n+inline Register AbstractRegSet<Register>::last() {\n+  if (_bitset == 0) { return noreg; }\n+  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  return as_Register(last);\n+}\n+\n+template <>\n+inline XMMRegister AbstractRegSet<XMMRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_XMMRegister(exact_log2(first)) : xnoreg;\n+}\n+\n+template <>\n+inline XMMRegister AbstractRegSet<XMMRegister>::last() {\n+  if (_bitset == 0) { return xnoreg; }\n+  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  return as_XMMRegister(last);\n+}\n+\n+typedef AbstractRegSet<Register> RegSet;\n+typedef AbstractRegSet<XMMRegister> XMMRegSet;\n+\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -89,0 +90,143 @@\n+template <class RegImpl> class RegSetIterator;\n+template <class RegImpl> class ReverseRegSetIterator;\n+\n+\/\/ A set of registers\n+template <class RegImpl>\n+class AbstractRegSet {\n+  uint32_t _bitset;\n+\n+  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n+\n+public:\n+\n+  AbstractRegSet() : _bitset(0) { }\n+\n+  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n+\n+  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset | aSet._bitset);\n+    return result;\n+  }\n+\n+  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset & ~aSet._bitset);\n+    return result;\n+  }\n+\n+  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n+    *this = *this + aSet;\n+    return *this;\n+  }\n+\n+  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n+    *this = *this - aSet;\n+    return *this;\n+  }\n+\n+  static AbstractRegSet of(RegImpl r1) {\n+    return AbstractRegSet(r1);\n+  }\n+\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n+    return of(r1) + r2;\n+  }\n+\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n+    return of(r1, r2) + r3;\n+  }\n+\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n+    return of(r1, r2, r3) + r4;\n+  }\n+\n+  static AbstractRegSet range(RegImpl start, RegImpl end) {\n+    assert(start <= end, \"must be\");\n+    uint32_t bits = ~0;\n+    bits <<= start->encoding();\n+    bits <<= 31 - end->encoding();\n+    bits >>= 31 - end->encoding();\n+\n+    return AbstractRegSet(bits);\n+  }\n+\n+  uint size() const { return population_count(_bitset); }\n+\n+  uint32_t bits() const { return _bitset; }\n+\n+private:\n+\n+  RegImpl first();\n+  RegImpl last();\n+\n+public:\n+\n+  friend class RegSetIterator<RegImpl>;\n+  friend class ReverseRegSetIterator<RegImpl>;\n+\n+  RegSetIterator<RegImpl> begin();\n+  ReverseRegSetIterator<RegImpl> rbegin();\n+};\n+\n+template <class RegImpl>\n+class RegSetIterator {\n+  AbstractRegSet<RegImpl> _regs;\n+\n+public:\n+  RegSetIterator(AbstractRegSet<RegImpl> x): _regs(x) {}\n+  RegSetIterator(const RegSetIterator& mit) : _regs(mit._regs) {}\n+\n+  RegSetIterator& operator++() {\n+    RegImpl r = _regs.first();\n+    if (r->is_valid())\n+      _regs -= r;\n+    return *this;\n+  }\n+\n+  bool operator==(const RegSetIterator& rhs) const {\n+    return _regs.bits() == rhs._regs.bits();\n+  }\n+  bool operator!=(const RegSetIterator& rhs) const {\n+    return ! (rhs == *this);\n+  }\n+\n+  RegImpl operator*() {\n+    return _regs.first();\n+  }\n+};\n+\n+template <class RegImpl>\n+inline RegSetIterator<RegImpl> AbstractRegSet<RegImpl>::begin() {\n+  return RegSetIterator<RegImpl>(*this);\n+}\n+\n+template <class RegImpl>\n+class ReverseRegSetIterator {\n+  AbstractRegSet<RegImpl> _regs;\n+\n+public:\n+  ReverseRegSetIterator(AbstractRegSet<RegImpl> x): _regs(x) {}\n+  ReverseRegSetIterator(const ReverseRegSetIterator& mit) : _regs(mit._regs) {}\n+\n+  ReverseRegSetIterator& operator++() {\n+    RegImpl r = _regs.last();\n+    if (r->is_valid())\n+      _regs -= r;\n+    return *this;\n+  }\n+\n+  bool operator==(const ReverseRegSetIterator& rhs) const {\n+    return _regs.bits() == rhs._regs.bits();\n+  }\n+  bool operator!=(const ReverseRegSetIterator& rhs) const {\n+    return ! (rhs == *this);\n+  }\n+\n+  RegImpl operator*() {\n+    return _regs.last();\n+  }\n+};\n+\n+template <class RegImpl>\n+inline ReverseRegSetIterator<RegImpl> AbstractRegSet<RegImpl>::rbegin() {\n+  return ReverseRegSetIterator<RegImpl>(*this);\n+}\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"modified"}]}