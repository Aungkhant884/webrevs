{"files":[{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"vmreg_aarch64.inline.hpp\"\n+\n+address RegisterMap::pd_location(VMReg reg, int slot) const {\n+  if (reg->is_concrete() && slot == 0) {\n+    return NULL; \/\/ Should have been handled by base location()\n+  } else if (reg->is_FloatRegister()) {\n+    \/\/ Not all physical slots of an SVE register have corresponding\n+    \/\/ VMRegs. However they are always saved to the stack in a\n+    \/\/ contiguous region of memory so we can calculate the address of\n+    \/\/ the upper slots by offsetting from the base address.\n+    int base_reg_enc = (reg->value() - ConcreteRegisterImpl::max_gpr) \/\n+                       FloatRegisterImpl::max_slots_per_register;\n+    VMReg base_reg = as_FloatRegister(base_reg_enc)->as_VMReg();\n+    assert(base_reg->is_concrete(), \"should be concrete\");\n+    address base_addr = location(base_reg);\n+    slot += reg->value() - base_reg->value();\n+    if (base_addr != NULL) {\n+      return base_addr + (slot * VMRegImpl::stack_slot_size);\n+    }\n+  }\n+  return NULL;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,1 @@\n-  \/\/ Since there is none, we just return NULL.\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg, int slot) const;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  const bool _save_vectors;\n@@ -86,2 +87,4 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);\n-  static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);\n+  RegisterSaver(bool save_vectors) : _save_vectors(save_vectors) {}\n+\n+  OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words);\n+  void restore_live_registers(MacroAssembler* masm);\n@@ -93,10 +96,4 @@\n-  static int r0_offset_in_bytes(void)    { return (32 + r0->encoding()) * wordSize; }\n-  static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r->encoding() * wordSize; }\n-  static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }\n-  static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1->encoding()) * wordSize; }\n-  static int v0_offset_in_bytes(void)   { return 0; }\n-  static int return_offset_in_bytes(void) { return (32 \/* floats*\/ + 31 \/* gregs*\/) * wordSize; }\n-\n-  \/\/ During deoptimization only the result registers need to be restored,\n-  \/\/ all the other values have already been extracted.\n-  static void restore_result_registers(MacroAssembler* masm);\n+  int reg_offset_in_bytes(Register r);\n+  int r0_offset_in_bytes()    { return reg_offset_in_bytes(r0); }\n+  int rscratch1_offset_in_bytes()    { return reg_offset_in_bytes(rscratch1); }\n+  int v0_offset_in_bytes(void)   { return 0; }\n@@ -104,1 +101,2 @@\n-    \/\/ Capture info about frame layout\n+  \/\/ Capture info about frame layout\n+  \/\/ Note this is only correct when not saving full vectors.\n@@ -119,1 +117,25 @@\n-OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {\n+int RegisterSaver::reg_offset_in_bytes(Register r) {\n+  \/\/ The integer registers are located above the floating point\n+  \/\/ registers in the stack frame pushed by save_live_registers() so the\n+  \/\/ offset depends on whether we are saving full vectors, and whether\n+  \/\/ those vectors are NEON or SVE.\n+\n+  int slots_per_vect = FloatRegisterImpl::save_slots_per_register;\n+\n+#if COMPILER2_OR_JVMCI\n+  if (_save_vectors) {\n+    slots_per_vect = FloatRegisterImpl::slots_per_neon_register;\n+\n+#ifdef COMPILER2\n+    if (Matcher::supports_scalable_vector()) {\n+      slots_per_vect = Matcher::scalable_vector_reg_size(T_FLOAT);\n+    }\n+#endif\n+  }\n+#endif\n+\n+  int r0_offset = (slots_per_vect * FloatRegisterImpl::number_of_registers) * BytesPerInt;\n+  return r0_offset + r->encoding() * wordSize;\n+}\n+\n+OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words) {\n@@ -131,1 +153,1 @@\n-  if (save_vectors) {\n+  if (_save_vectors) {\n@@ -145,1 +167,1 @@\n-  assert(!save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n@@ -160,1 +182,1 @@\n-  __ push_CPU_state(save_vectors, use_sve, sve_vector_size_in_bytes);\n+  __ push_CPU_state(_save_vectors, use_sve, sve_vector_size_in_bytes);\n@@ -185,1 +207,1 @@\n-    if (save_vectors) {\n+    if (_save_vectors) {\n@@ -198,1 +220,1 @@\n-void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {\n+void RegisterSaver::restore_live_registers(MacroAssembler* masm) {\n@@ -200,1 +222,1 @@\n-  __ pop_CPU_state(restore_vectors, Matcher::supports_scalable_vector(),\n+  __ pop_CPU_state(_save_vectors, Matcher::supports_scalable_vector(),\n@@ -212,17 +234,0 @@\n-void RegisterSaver::restore_result_registers(MacroAssembler* masm) {\n-\n-  \/\/ Just restore result register. Only used by deoptimization. By\n-  \/\/ now any callee save register that needs to be restored to a c2\n-  \/\/ caller of the deoptee has been extracted into the vframeArray\n-  \/\/ and will be stuffed into the c2i adapter we create for later\n-  \/\/ restoration so only result registers need to be restored here.\n-\n-  \/\/ Restore fp result register\n-  __ ldrd(v0, Address(sp, v0_offset_in_bytes()));\n-  \/\/ Restore integer result register\n-  __ ldr(r0, Address(sp, r0_offset_in_bytes()));\n-\n-  \/\/ Pop all of the register save are off the stack\n-  __ add(sp, sp, align_up(return_offset_in_bytes(), 16));\n-}\n-\n@@ -2164,0 +2169,1 @@\n+  RegisterSaver reg_save(COMPILER2_OR_JVMCI != 0);\n@@ -2201,1 +2207,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2219,1 +2225,1 @@\n-  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  (void) reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2238,1 +2244,1 @@\n-    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+    reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2295,1 +2301,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2376,1 +2382,1 @@\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ str(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2385,1 +2391,8 @@\n-  RegisterSaver::restore_result_registers(masm);\n+\n+  \/\/ Restore fp result register\n+  __ ldrd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  \/\/ Restore integer result register\n+  __ ldr(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n+\n+  \/\/ Pop all of the register save area off the stack\n+  __ add(sp, sp, frame_size_in_words * wordSize);\n@@ -2466,2 +2479,2 @@\n-  __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ strd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  __ str(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2494,2 +2507,2 @@\n-  __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));\n-  __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ ldrd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  __ ldr(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2741,1 +2754,1 @@\n-  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  RegisterSaver reg_save(poll_type == POLL_AT_VECTOR_LOOP \/* save_vectors *\/);\n@@ -2744,1 +2757,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2789,1 +2802,1 @@\n-  RegisterSaver::restore_live_registers(masm, save_vectors);\n+  reg_save.restore_live_registers(masm);\n@@ -2821,1 +2834,1 @@\n-  RegisterSaver::restore_live_registers(masm, save_vectors);\n+  reg_save.restore_live_registers(masm);\n@@ -2855,0 +2868,1 @@\n+  RegisterSaver reg_save(false \/* save_vectors *\/);\n@@ -2861,1 +2875,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2893,1 +2907,1 @@\n-  __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));\n+  __ str(rmethod, Address(sp, reg_save.reg_offset_in_bytes(rmethod)));\n@@ -2896,2 +2910,2 @@\n-  __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));\n-  RegisterSaver::restore_live_registers(masm);\n+  __ str(r0, Address(sp, reg_save.rscratch1_offset_in_bytes()));\n+  reg_save.restore_live_registers(masm);\n@@ -2907,1 +2921,1 @@\n-  RegisterSaver::restore_live_registers(masm);\n+  reg_save.restore_live_registers(masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":70,"deletions":56,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    case STACK_TYPE: return VMRegImpl::stack2reg(index LP64_ONLY(* 2));\n+    case STACK_TYPE: return VMRegImpl::stack2reg(index * 2);\n@@ -67,0 +67,17 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  if (is_FloatRegister()) {\n+    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_gpr)\n+               \/ FloatRegisterImpl::max_slots_per_register);\n+    return as_FloatRegister()->encoding() == enc;\n+  } else if (is_PRegister()) {\n+    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_fpr)\n+               \/ PRegisterImpl::max_slots_per_register);\n+    return as_PRegister()->encoding() == enc;\n+  } else if (is_Register()) {\n+    int enc = (value() + slot_delta) \/ RegisterImpl::max_slots_per_register;\n+    return as_Register()->encoding() == enc;\n+  } else {\n+    return is_stack();\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,3 @@\n-inline Register as_Register() {\n+inline bool is_PRegister() {\n+  return value() >= ConcreteRegisterImpl::max_fpr && value() < ConcreteRegisterImpl::max_pr;\n+}\n@@ -39,0 +41,1 @@\n+inline Register as_Register() {\n@@ -51,1 +54,7 @@\n-inline   bool is_concrete() {\n+inline PRegister as_PRegister() {\n+  assert( is_PRegister(), \"must be\" );\n+  return ::as_PRegister((value() - ConcreteRegisterImpl::max_fpr) \/\n+                        PRegisterImpl::max_slots_per_register);\n+}\n+\n+inline bool is_concrete() {\n@@ -53,1 +62,8 @@\n-  return is_even(value());\n+  if (is_FloatRegister()) {\n+    int base = value() - ConcreteRegisterImpl::max_gpr;\n+    return base % FloatRegisterImpl::max_slots_per_register == 0;\n+  } else if (is_PRegister()) {\n+    return true;   \/\/ Single slot\n+  } else {\n+    return is_even(value());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg, int slot) const {return NULL;}\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,4 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/vmreg_arm.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg reg, int slot) const { return NULL; }\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,4 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/vmreg_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg, int slot) const {return NULL;}\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,4 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-address RegisterMap::pd_location(VMReg reg) const {\n+address RegisterMap::pd_location(VMReg reg, int slot) const {\n+  assert(slot == 0, \"unexpected\");\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  address pd_location(VMReg reg) const;\n+  address pd_location(VMReg reg, int slot) const;\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,2 @@\n-    number_of_registers = 8\n+    number_of_registers = 8,\n+    max_slots_per_register = 2\n@@ -260,1 +261,1 @@\n-      2 * FloatRegisterImpl::number_of_registers +\n+      FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers +\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,21 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  if (is_Register()) {\n+    int enc = (value() + slot_delta) \/ RegisterImpl::max_slots_per_register;\n+    return as_Register()->encoding() == enc;\n+  } else if (is_FloatRegister()) {\n+    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_gpr) \/\n+               FloatRegisterImpl::max_slots_per_register);\n+    return as_FloatRegister()->encoding() == enc;\n+  } else if (is_XMMRegister()) {\n+    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_fpr) \/\n+               XMMRegisterImpl::max_slots_per_register);\n+    return as_XMMRegister()->encoding() == enc;\n+  } else if (is_KRegister()) {\n+    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_xmm) \/\n+               KRegisterImpl::max_slots_per_register);\n+    return as_KRegister()->encoding() == enc;\n+  } else {\n+    return is_stack();\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg reg, int slot) const { return NULL; }\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,4 @@\n+\n+bool VMRegImpl::is_expressible(int slot_delta) {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/vmreg_zero.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,4 @@\n+  \/\/ Platform dependent function that returns true if offsetting this\n+  \/\/ VMReg by slot_delta slots gives another valid VMReg which is part\n+  \/\/ of the same physical register.\n+  bool is_expressible(int slot_delta);\n@@ -96,3 +100,0 @@\n-  \/\/ This really ought to check that the register is \"real\" in the sense that\n-  \/\/ we don't try and get the VMReg number of a physical register that doesn't\n-  \/\/ have an expressible part. That would be pd specific code\n@@ -100,2 +101,1 @@\n-    assert((is_reg() && value() < stack0->value() - 1) || is_stack(), \"must be\");\n-    return (VMReg)(intptr_t)(value() + 1);\n+    return next(1);\n@@ -105,0 +105,1 @@\n+    assert(is_expressible(i), \"not expressible\");\n@@ -108,2 +109,1 @@\n-    assert((is_stack() && value() > stack0->value()) || (is_reg() && value() != 0), \"must be\");\n-    return (VMReg)(intptr_t)(value() - 1);\n+    return next(-1);\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,2 @@\n-      address elem_addr = reg_map->location(vreg->next(vslot)) + off;\n+      address elem_addr = reg_map->location(vreg, vslot) + off;\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,9 @@\n-      return pd_location(reg);\n+      return pd_location(reg, 0);\n+    }\n+  }\n+\n+  address location(VMReg reg, int slot) {\n+    if (reg->is_expressible(slot)) {\n+      return location(reg->next(slot));\n+    } else {\n+      return pd_location(reg, slot);\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}