{"files":[{"patch":"@@ -86,2 +86,2 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);\n-  static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);\n+  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors);\n+  static void restore_live_registers(MacroAssembler* masm, bool restore_vectors);\n@@ -93,4 +93,3 @@\n-  static int r0_offset_in_bytes(void)    { return (32 + r0->encoding()) * wordSize; }\n-  static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r->encoding() * wordSize; }\n-  static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }\n-  static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1->encoding()) * wordSize; }\n+  static int reg_offset_in_bytes(Register r, bool save_vectors);\n+  static int r0_offset_in_bytes(bool save_vectors)    { return reg_offset_in_bytes(r0, save_vectors); }\n+  static int rscratch1_offset_in_bytes(bool save_vectors)    { return reg_offset_in_bytes(rscratch1, save_vectors); }\n@@ -98,1 +97,0 @@\n-  static int return_offset_in_bytes(void) { return (32 \/* floats*\/ + 31 \/* gregs*\/) * wordSize; }\n@@ -100,5 +98,2 @@\n-  \/\/ During deoptimization only the result registers need to be restored,\n-  \/\/ all the other values have already been extracted.\n-  static void restore_result_registers(MacroAssembler* masm);\n-\n-    \/\/ Capture info about frame layout\n+  \/\/ Capture info about frame layout\n+  \/\/ Note this is only correct when not saving full vectors.\n@@ -119,0 +114,24 @@\n+int RegisterSaver::reg_offset_in_bytes(Register r, bool save_vectors) {\n+  \/\/ The integer registers are located above the floating point\n+  \/\/ registers in the stack frame pushed by save_live_registers() so the\n+  \/\/ offset depends on whether we are saving full vectors, and whether\n+  \/\/ those vectors are NEON or SVE.\n+\n+  int slots_per_vect = FloatRegisterImpl::save_slots_per_register;\n+\n+#if COMPILER2_OR_JVMCI\n+  if (save_vectors) {\n+    slots_per_vect = FloatRegisterImpl::slots_per_neon_register;\n+\n+#ifdef COMPILER2\n+    if (Matcher::supports_scalable_vector()) {\n+      slots_per_vect = Matcher::scalable_vector_reg_size(T_FLOAT);\n+    }\n+#endif\n+  }\n+#endif\n+\n+  int r0_offset = (slots_per_vect * FloatRegisterImpl::number_of_registers) * BytesPerInt;\n+  return r0_offset + r->encoding() * wordSize;\n+}\n+\n@@ -212,17 +231,0 @@\n-void RegisterSaver::restore_result_registers(MacroAssembler* masm) {\n-\n-  \/\/ Just restore result register. Only used by deoptimization. By\n-  \/\/ now any callee save register that needs to be restored to a c2\n-  \/\/ caller of the deoptee has been extracted into the vframeArray\n-  \/\/ and will be stuffed into the c2i adapter we create for later\n-  \/\/ restoration so only result registers need to be restored here.\n-\n-  \/\/ Restore fp result register\n-  __ ldrd(v0, Address(sp, v0_offset_in_bytes()));\n-  \/\/ Restore integer result register\n-  __ ldr(r0, Address(sp, r0_offset_in_bytes()));\n-\n-  \/\/ Pop all of the register save are off the stack\n-  __ add(sp, sp, align_up(return_offset_in_bytes(), 16));\n-}\n-\n@@ -2164,0 +2166,1 @@\n+  bool save_vectors = COMPILER2_OR_JVMCI != 0;\n@@ -2201,1 +2204,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n@@ -2219,1 +2222,1 @@\n-  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n@@ -2238,1 +2241,1 @@\n-    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n@@ -2295,1 +2298,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n@@ -2376,1 +2379,1 @@\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes(save_vectors)));\n@@ -2385,1 +2388,8 @@\n-  RegisterSaver::restore_result_registers(masm);\n+\n+  \/\/ Restore fp result register\n+  __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));\n+  \/\/ Restore integer result register\n+  __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes(save_vectors)));\n+\n+  \/\/ Pop all of the register save area off the stack\n+  __ add(sp, sp, frame_size_in_words * wordSize);\n@@ -2467,1 +2477,1 @@\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes(save_vectors)));\n@@ -2495,1 +2505,1 @@\n-  __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes(save_vectors)));\n@@ -2855,0 +2865,1 @@\n+  bool save_vectors = false;\n@@ -2861,1 +2872,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n@@ -2893,1 +2904,1 @@\n-  __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));\n+  __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod, save_vectors)));\n@@ -2896,2 +2907,2 @@\n-  __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));\n-  RegisterSaver::restore_live_registers(masm);\n+  __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes(save_vectors)));\n+  RegisterSaver::restore_live_registers(masm, save_vectors);\n@@ -2907,1 +2918,1 @@\n-  RegisterSaver::restore_live_registers(masm);\n+  RegisterSaver::restore_live_registers(masm, save_vectors);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":53,"deletions":42,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,2 +138,11 @@\n-      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+      bool contiguous = X86_ONLY(false) NOT_X86(true);\n+      address elem_addr;\n+\n+      if (contiguous) {\n+        elem_addr = reg_map->location(vreg) + (i * elem_size);\n+      } else {\n+        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+\n+        elem_addr = reg_map->location(vreg->next(vslot)) + off;\n+      }\n@@ -141,1 +150,0 @@\n-      address elem_addr = reg_map->location(vreg->next(vslot)) + off;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}