[{"commit":{"message":"8260355: AArch64: deoptimization stub should save vector registers\n\nThis is an AArch64 port of the fix for JDK-8256056 \"Deoptimization stub\ndoesn't save vector registers on x86\". The problem is that a vector\nproduced by the Vector API may be stored in a register when the deopt\nblob is called. Because the deopt blob only stores the lower half of\nvector registers, the full vector object cannot be rematerialized during\ndeoptimization. So the following will crash on AArch64 with current JDK:\n\n  make test TEST=\"jdk\/incubator\/vector\" \\\n    JTREG=\"VM_OPTIONS=-XX:+DeoptimizeALot -XX:DeoptimizeALotInterval=0\"\n\nThe fix is to store the full vector registers by passing\nsave_vectors=true to save_live_registers() in the deopt blob. Because\nsave_live_registers() places the integer registers above the floating\nregisters in the stack frame, RegisterSaver::r0_offset_in_bytes() needs\nto calculate the SP offset based on whether full vectors were saved, and\nwhether those vectors were NEON or SVE, rather than using a static\noffset as it does currently.\n\nThe change to VectorSupport::allocate_vector_payload_helper() is\nrequired because we only store the lowest VMReg slot in the oop map.\nHowever unlike x86 the vector registers are always saved in a contiguous\nregion of memory, so we can calculate the address of each vector element\nas an offset from the address of the first slot. X86 handles this in\nRegisterMap::pd_location() but that won't work on AArch64 because with\nSVE there isn't a unique VMReg corresponding to each four-byte physical\nslot in the vector (there are always exactly eight logical VMRegs\nregardless of the actual vector length).\n\nTested hotspot_all_no_apps and jdk_core."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp"},{"filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp"}],"sha":"83d07c58b6961a3c69b48f56b69392378f2c8559"}]