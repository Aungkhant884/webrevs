{"files":[{"patch":"@@ -29,4 +29,2 @@\n-address RegisterMap::pd_location(VMReg reg, int slot) const {\n-  if (reg->is_concrete() && slot == 0) {\n-    return NULL; \/\/ Should have been handled by base location()\n-  } else if (reg->is_FloatRegister()) {\n+address RegisterMap::pd_location(VMReg base_reg, int slot_idx) const {\n+  if (base_reg->is_FloatRegister()) {\n@@ -37,1 +35,2 @@\n-    int base_reg_enc = (reg->value() - ConcreteRegisterImpl::max_gpr) \/\n+    assert(base_reg->is_concrete(), \"must pass base reg\");\n+    int base_reg_enc = (base_reg->value() - ConcreteRegisterImpl::max_gpr) \/\n@@ -39,6 +38,6 @@\n-    VMReg base_reg = as_FloatRegister(base_reg_enc)->as_VMReg();\n-    assert(base_reg->is_concrete(), \"should be concrete\");\n-    address base_addr = location(base_reg);\n-    slot += reg->value() - base_reg->value();\n-    if (base_addr != NULL) {\n-      return base_addr + (slot * VMRegImpl::stack_slot_size);\n+    intptr_t offset_in_bytes = slot_idx * VMRegImpl::stack_slot_size;\n+    address base_location = location(base_reg);\n+    if (base_location != NULL) {\n+      return base_location + offset_in_bytes;\n+    } else {\n+      return NULL;\n@@ -46,0 +45,2 @@\n+  } else {\n+    return location(base_reg->next(slot_idx));\n@@ -47,1 +48,0 @@\n-  return NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-  address pd_location(VMReg reg, int slot) const;\n+  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg base_reg, int slot_idx) const;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  assert(!restore_vectors, \"vectors are generated only by C2 and JVMCI\");\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n@@ -228,1 +228,1 @@\n-  __ pop_CPU_state(restore_vectors);\n+  __ pop_CPU_state(_save_vectors);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    case STACK_TYPE: return VMRegImpl::stack2reg(index * 2);\n+    case STACK_TYPE: return VMRegImpl::stack2reg(index LP64_ONLY(* 2));\n@@ -67,17 +67,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  if (is_FloatRegister()) {\n-    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_gpr)\n-               \/ FloatRegisterImpl::max_slots_per_register);\n-    return as_FloatRegister()->encoding() == enc;\n-  } else if (is_PRegister()) {\n-    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_fpr)\n-               \/ PRegisterImpl::max_slots_per_register);\n-    return as_PRegister()->encoding() == enc;\n-  } else if (is_Register()) {\n-    int enc = (value() + slot_delta) \/ RegisterImpl::max_slots_per_register;\n-    return as_Register()->encoding() == enc;\n-  } else {\n-    return is_stack();\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -37,1 +37,5 @@\n-  address pd_location(VMReg reg, int slot) const {return NULL;}\n+  address pd_location(VMReg reg) const {return NULL;}\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,4 +57,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vmreg_arm.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,5 @@\n-  address pd_location(VMReg reg, int slot) const { return NULL; }\n+  address pd_location(VMReg reg) const { return NULL; }\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,4 +56,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/vmreg_ppc.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,5 @@\n-  address pd_location(VMReg reg, int slot) const {return NULL;}\n+  address pd_location(VMReg reg) const {return NULL;}\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,4 +55,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-address RegisterMap::pd_location(VMReg reg, int slot) const {\n-  assert(slot == 0, \"unexpected\");\n+address RegisterMap::pd_location(VMReg reg) const {\n@@ -65,0 +64,4 @@\n+\n+address RegisterMap::pd_location(VMReg base_reg, int slot_idx) const {\n+  return location(base_reg->next(slot_idx));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-  address pd_location(VMReg reg, int slot) const;\n+  address pd_location(VMReg reg) const;\n+  address pd_location(VMReg base_reg, int slot_idx) const;\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,2 +108,1 @@\n-    number_of_registers = 8,\n-    max_slots_per_register = 2\n+    number_of_registers = 8\n@@ -261,1 +260,1 @@\n-      FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers +\n+      2 * FloatRegisterImpl::number_of_registers +\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,21 +83,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  if (is_Register()) {\n-    int enc = (value() + slot_delta) \/ RegisterImpl::max_slots_per_register;\n-    return as_Register()->encoding() == enc;\n-  } else if (is_FloatRegister()) {\n-    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_gpr) \/\n-               FloatRegisterImpl::max_slots_per_register);\n-    return as_FloatRegister()->encoding() == enc;\n-  } else if (is_XMMRegister()) {\n-    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_fpr) \/\n-               XMMRegisterImpl::max_slots_per_register);\n-    return as_XMMRegister()->encoding() == enc;\n-  } else if (is_KRegister()) {\n-    int enc = ((value() + slot_delta - ConcreteRegisterImpl::max_xmm) \/\n-               KRegisterImpl::max_slots_per_register);\n-    return as_KRegister()->encoding() == enc;\n-  } else {\n-    return is_stack();\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -35,1 +35,5 @@\n-  address pd_location(VMReg reg, int slot) const { return NULL; }\n+  address pd_location(VMReg reg) const { return NULL; }\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2010, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,4 +69,0 @@\n-\n-bool VMRegImpl::is_expressible(int slot_delta) {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/vmreg_zero.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,4 +95,0 @@\n-  \/\/ Platform dependent function that returns true if offsetting this\n-  \/\/ VMReg by slot_delta slots gives another valid VMReg which is part\n-  \/\/ of the same physical register.\n-  bool is_expressible(int slot_delta);\n@@ -100,0 +96,3 @@\n+  \/\/ This really ought to check that the register is \"real\" in the sense that\n+  \/\/ we don't try and get the VMReg number of a physical register that doesn't\n+  \/\/ have an expressible part. That would be pd specific code\n@@ -101,1 +100,2 @@\n-    return next(1);\n+    assert((is_reg() && value() < stack0->value() - 1) || is_stack(), \"must be\");\n+    return (VMReg)(intptr_t)(value() + 1);\n@@ -105,1 +105,0 @@\n-    assert(is_expressible(i), \"not expressible\");\n@@ -109,1 +108,2 @@\n-    return next(-1);\n+    assert((is_stack() && value() > stack0->value()) || (is_reg() && value() != 0), \"must be\");\n+    return (VMReg)(intptr_t)(value() - 1);\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -141,2 +141,1 @@\n-      address elem_addr = reg_map->location(vreg, vslot) + off;\n-\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-      return pd_location(reg, 0);\n+      return pd_location(reg);\n@@ -102,3 +102,3 @@\n-  address location(VMReg reg, int slot) {\n-    if (reg->is_expressible(slot)) {\n-      return location(reg->next(slot));\n+  address location(VMReg base_reg, int slot_idx) const {\n+    if (slot_idx > 0) {\n+      return pd_location(base_reg, slot_idx);\n@@ -106,1 +106,1 @@\n-      return pd_location(reg, slot);\n+      return location(base_reg);\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}