{"files":[{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"vmreg_aarch64.inline.hpp\"\n+\n+address RegisterMap::pd_location(VMReg base_reg, int slot_idx) const {\n+  if (base_reg->is_FloatRegister()) {\n+    \/\/ Not all physical slots of an SVE register have corresponding\n+    \/\/ VMRegs. However they are always saved to the stack in a\n+    \/\/ contiguous region of memory so we can calculate the address of\n+    \/\/ the upper slots by offsetting from the base address.\n+    assert(base_reg->is_concrete(), \"must pass base reg\");\n+    int base_reg_enc = (base_reg->value() - ConcreteRegisterImpl::max_gpr) \/\n+                       FloatRegisterImpl::max_slots_per_register;\n+    intptr_t offset_in_bytes = slot_idx * VMRegImpl::stack_slot_size;\n+    address base_location = location(base_reg);\n+    if (base_location != NULL) {\n+      return base_location + offset_in_bytes;\n+    } else {\n+      return NULL;\n+    }\n+  } else {\n+    return location(base_reg->next(slot_idx));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  \/\/ Since there is none, we just return NULL.\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg base_reg, int slot_idx) const;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  const bool _save_vectors;\n@@ -86,2 +87,4 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);\n-  static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);\n+  RegisterSaver(bool save_vectors) : _save_vectors(save_vectors) {}\n+\n+  OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words);\n+  void restore_live_registers(MacroAssembler* masm);\n@@ -93,10 +96,4 @@\n-  static int r0_offset_in_bytes(void)    { return (32 + r0->encoding()) * wordSize; }\n-  static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r->encoding() * wordSize; }\n-  static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }\n-  static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1->encoding()) * wordSize; }\n-  static int v0_offset_in_bytes(void)   { return 0; }\n-  static int return_offset_in_bytes(void) { return (32 \/* floats*\/ + 31 \/* gregs*\/) * wordSize; }\n-\n-  \/\/ During deoptimization only the result registers need to be restored,\n-  \/\/ all the other values have already been extracted.\n-  static void restore_result_registers(MacroAssembler* masm);\n+  int reg_offset_in_bytes(Register r);\n+  int r0_offset_in_bytes()    { return reg_offset_in_bytes(r0); }\n+  int rscratch1_offset_in_bytes()    { return reg_offset_in_bytes(rscratch1); }\n+  int v0_offset_in_bytes(void)   { return 0; }\n@@ -104,1 +101,2 @@\n-    \/\/ Capture info about frame layout\n+  \/\/ Capture info about frame layout\n+  \/\/ Note this is only correct when not saving full vectors.\n@@ -119,1 +117,25 @@\n-OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {\n+int RegisterSaver::reg_offset_in_bytes(Register r) {\n+  \/\/ The integer registers are located above the floating point\n+  \/\/ registers in the stack frame pushed by save_live_registers() so the\n+  \/\/ offset depends on whether we are saving full vectors, and whether\n+  \/\/ those vectors are NEON or SVE.\n+\n+  int slots_per_vect = FloatRegisterImpl::save_slots_per_register;\n+\n+#if COMPILER2_OR_JVMCI\n+  if (_save_vectors) {\n+    slots_per_vect = FloatRegisterImpl::slots_per_neon_register;\n+\n+#ifdef COMPILER2\n+    if (Matcher::supports_scalable_vector()) {\n+      slots_per_vect = Matcher::scalable_vector_reg_size(T_FLOAT);\n+    }\n+#endif\n+  }\n+#endif\n+\n+  int r0_offset = (slots_per_vect * FloatRegisterImpl::number_of_registers) * BytesPerInt;\n+  return r0_offset + r->encoding() * wordSize;\n+}\n+\n+OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words) {\n@@ -131,1 +153,1 @@\n-  if (save_vectors) {\n+  if (_save_vectors) {\n@@ -145,1 +167,1 @@\n-  assert(!save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n@@ -160,1 +182,1 @@\n-  __ push_CPU_state(save_vectors, use_sve, sve_vector_size_in_bytes);\n+  __ push_CPU_state(_save_vectors, use_sve, sve_vector_size_in_bytes);\n@@ -185,1 +207,1 @@\n-    if (save_vectors) {\n+    if (_save_vectors) {\n@@ -198,1 +220,1 @@\n-void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {\n+void RegisterSaver::restore_live_registers(MacroAssembler* masm) {\n@@ -200,1 +222,1 @@\n-  __ pop_CPU_state(restore_vectors, Matcher::supports_scalable_vector(),\n+  __ pop_CPU_state(_save_vectors, Matcher::supports_scalable_vector(),\n@@ -204,1 +226,1 @@\n-  assert(!restore_vectors, \"vectors are generated only by C2 and JVMCI\");\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n@@ -206,1 +228,1 @@\n-  __ pop_CPU_state(restore_vectors);\n+  __ pop_CPU_state(_save_vectors);\n@@ -212,17 +234,0 @@\n-void RegisterSaver::restore_result_registers(MacroAssembler* masm) {\n-\n-  \/\/ Just restore result register. Only used by deoptimization. By\n-  \/\/ now any callee save register that needs to be restored to a c2\n-  \/\/ caller of the deoptee has been extracted into the vframeArray\n-  \/\/ and will be stuffed into the c2i adapter we create for later\n-  \/\/ restoration so only result registers need to be restored here.\n-\n-  \/\/ Restore fp result register\n-  __ ldrd(v0, Address(sp, v0_offset_in_bytes()));\n-  \/\/ Restore integer result register\n-  __ ldr(r0, Address(sp, r0_offset_in_bytes()));\n-\n-  \/\/ Pop all of the register save are off the stack\n-  __ add(sp, sp, align_up(return_offset_in_bytes(), 16));\n-}\n-\n@@ -2164,0 +2169,1 @@\n+  RegisterSaver reg_save(COMPILER2_OR_JVMCI != 0);\n@@ -2201,1 +2207,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2219,1 +2225,1 @@\n-  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  (void) reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2238,1 +2244,1 @@\n-    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+    reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2295,1 +2301,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2376,1 +2382,1 @@\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ str(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2385,1 +2391,8 @@\n-  RegisterSaver::restore_result_registers(masm);\n+\n+  \/\/ Restore fp result register\n+  __ ldrd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  \/\/ Restore integer result register\n+  __ ldr(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n+\n+  \/\/ Pop all of the register save area off the stack\n+  __ add(sp, sp, frame_size_in_words * wordSize);\n@@ -2466,2 +2479,2 @@\n-  __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));\n-  __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ strd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  __ str(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2494,2 +2507,2 @@\n-  __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));\n-  __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));\n+  __ ldrd(v0, Address(sp, reg_save.v0_offset_in_bytes()));\n+  __ ldr(r0, Address(sp, reg_save.r0_offset_in_bytes()));\n@@ -2741,1 +2754,1 @@\n-  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  RegisterSaver reg_save(poll_type == POLL_AT_VECTOR_LOOP \/* save_vectors *\/);\n@@ -2744,1 +2757,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, save_vectors);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2789,1 +2802,1 @@\n-  RegisterSaver::restore_live_registers(masm, save_vectors);\n+  reg_save.restore_live_registers(masm);\n@@ -2821,1 +2834,1 @@\n-  RegisterSaver::restore_live_registers(masm, save_vectors);\n+  reg_save.restore_live_registers(masm);\n@@ -2855,0 +2868,1 @@\n+  RegisterSaver reg_save(false \/* save_vectors *\/);\n@@ -2861,1 +2875,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = reg_save.save_live_registers(masm, 0, &frame_size_in_words);\n@@ -2893,1 +2907,1 @@\n-  __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));\n+  __ str(rmethod, Address(sp, reg_save.reg_offset_in_bytes(rmethod)));\n@@ -2896,2 +2910,2 @@\n-  __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));\n-  RegisterSaver::restore_live_registers(masm);\n+  __ str(r0, Address(sp, reg_save.rscratch1_offset_in_bytes()));\n+  reg_save.restore_live_registers(masm);\n@@ -2907,1 +2921,1 @@\n-  RegisterSaver::restore_live_registers(masm);\n+  reg_save.restore_live_registers(masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":72,"deletions":58,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,3 @@\n-inline Register as_Register() {\n+inline bool is_PRegister() {\n+  return value() >= ConcreteRegisterImpl::max_fpr && value() < ConcreteRegisterImpl::max_pr;\n+}\n@@ -39,0 +41,1 @@\n+inline Register as_Register() {\n@@ -51,1 +54,7 @@\n-inline   bool is_concrete() {\n+inline PRegister as_PRegister() {\n+  assert( is_PRegister(), \"must be\" );\n+  return ::as_PRegister((value() - ConcreteRegisterImpl::max_fpr) \/\n+                        PRegisterImpl::max_slots_per_register);\n+}\n+\n+inline bool is_concrete() {\n@@ -53,1 +62,8 @@\n-  return is_even(value());\n+  if (is_FloatRegister()) {\n+    int base = value() - ConcreteRegisterImpl::max_gpr;\n+    return base % FloatRegisterImpl::max_slots_per_register == 0;\n+  } else if (is_PRegister()) {\n+    return true;   \/\/ Single slot\n+  } else {\n+    return is_even(value());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,5 @@\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg) const {return NULL;}\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,5 @@\n-   address pd_location(VMReg reg) const {return NULL;}\n+  address pd_location(VMReg reg) const {return NULL;}\n+\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,4 @@\n+\n+address RegisterMap::pd_location(VMReg base_reg, int slot_idx) const {\n+  return location(base_reg->next(slot_idx));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+  address pd_location(VMReg base_reg, int slot_idx) const;\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,4 @@\n+  address pd_location(VMReg base_reg, int slot_idx) const {\n+    return location(base_reg->next(slot_idx));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-      address elem_addr = reg_map->location(vreg->next(vslot)) + off;\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,8 @@\n+  address location(VMReg base_reg, int slot_idx) const {\n+    if (slot_idx > 0) {\n+      return pd_location(base_reg, slot_idx);\n+    } else {\n+      return location(base_reg);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}