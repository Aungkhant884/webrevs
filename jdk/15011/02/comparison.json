{"files":[{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:+OptimizeFill\n+ *                   compiler.vectorization.runner.ArrayInvariantFillTest\n@@ -40,1 +45,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n@@ -69,0 +74,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -70,0 +76,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_B, \"0\"})\n@@ -80,0 +89,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -81,0 +91,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \"0\"})\n@@ -91,0 +104,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -92,0 +106,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \"0\"})\n@@ -102,0 +119,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -103,0 +121,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \"0\"})\n@@ -124,0 +145,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -125,0 +147,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_F, \"0\"})\n@@ -180,0 +205,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -181,0 +207,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \"0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n@@ -324,1 +324,1 @@\n-            res[i] *= bytes[i + 3];\n+            res[i] += bytes[i + 3];\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n- * @requires (os.arch==\"amd64\" | os.arch==\"x86_64\" | os.simpleArch == \"aarch64\")\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-    private static final long COMP_THRES_SECONDS = 30;\n-\n@@ -57,0 +55,2 @@\n+        Class klass = getClass();\n+\n@@ -58,1 +58,1 @@\n-        \/\/ For each method annotated with @Test in the test method, this test runner\n+        \/\/ For each method annotated with \"@Test\" in test classes, this test runner\n@@ -62,7 +62,14 @@\n-        \/\/ And each test method should not throw any exceptions.\n-        Class klass = getClass();\n-        for (Method method : klass.getDeclaredMethods()) {\n-            try {\n-                if (method.isAnnotationPresent(Test.class)) {\n-                    verifyTestMethod(method);\n-                    runTestOnMethod(method);\n+        \/\/ Some VM options like \"-Xint\" may mess with the compiler control for the\n+        \/\/ correctness check. We disable the check in these cases.\n+        boolean use_intp = WB.getBooleanVMFlag(\"UseInterpreter\");\n+        boolean use_comp = WB.getBooleanVMFlag(\"UseCompiler\");\n+        if (use_intp && use_comp) {\n+            for (Method method : klass.getDeclaredMethods()) {\n+                try {\n+                    if (method.isAnnotationPresent(Test.class)) {\n+                        verifyTestMethod(method);\n+                        runTestOnMethod(method);\n+                    }\n+                } catch (Exception e) {\n+                    throw new RuntimeException(\"Test failed in \" + klass.getName() +\n+                            \".\" + method.getName() + \": \" + e.getMessage());\n@@ -70,3 +77,0 @@\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Test failed in \" + klass.getName() +\n-                        \".\" + method.getName() + \": \" + e.getMessage());\n@@ -74,0 +78,2 @@\n+        } else {\n+            System.out.println(\"WARNING: Correctness check is skipped due to extra compiler control flags\");\n@@ -80,2 +86,0 @@\n-        \/\/ Add extra VM options to enable more auto-vectorization chances\n-        irTest.addFlags(\"-XX:-OptimizeFill\");\n@@ -117,3 +121,4 @@\n-        \/\/ Lock compilation and inovke the method to get reference result from\n-        \/\/ the interpreter\n-        WB.lockCompilation();\n+        \/\/ Temporarily disable the compiler and invoke the method to get reference\n+        \/\/ result from the interpreter\n+        assert(WB.getBooleanVMFlag(\"UseCompiler\"));\n+        WB.setBooleanVMFlag(\"UseCompiler\", false);\n@@ -127,1 +132,1 @@\n-        WB.unlockCompilation();\n+        WB.setBooleanVMFlag(\"UseCompiler\", true);\n@@ -133,4 +138,1 @@\n-            if (System.currentTimeMillis() - enqueueTime > COMP_THRES_SECONDS * 1000) {\n-                fail(\"Method is not compiled after \" + COMP_THRES_SECONDS + \"s.\");\n-            }\n-            Thread.sleep(50 \/*ms*\/);\n+            Thread.sleep(100 \/*ms*\/);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"}]}