{"files":[{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    private static final int COMP_LEVEL_C1 = 1;\n+    private static final int COMP_LEVEL_INTP = 0;\n@@ -54,2 +54,0 @@\n-    private static final long COMP_THRES_SECONDS = 30;\n-\n@@ -61,5 +59,6 @@\n-        \/\/ invokes it twice - first time compiled by C1 and second time by C2. Then\n-        \/\/ two return results are compared. We require each test method returning a\n-        \/\/ primitive value or an array of primitives. Extra VM options like \"-Xint\"\n-        \/\/ may mess with the compiler control so we skip the correctness check with\n-        \/\/ these options.\n+        \/\/ invokes it twice - first time in the interpreter and second time compiled\n+        \/\/ by C2. Then this runner compares the two return values. Hence we require\n+        \/\/ each test method returning a primitive value or an array of primitive type.\n+        \/\/ Some VM options like \"-Xint\" may mess with the compiler control for the\n+        \/\/ correctness check. We disable the check in these cases.\n+        boolean use_intp = WB.getBooleanVMFlag(\"UseInterpreter\");\n@@ -67,2 +66,1 @@\n-        boolean is_tiered = WB.getBooleanVMFlag(\"TieredCompilation\");\n-        if (use_comp && is_tiered) {\n+        if (use_intp && use_comp) {\n@@ -119,5 +117,21 @@\n-    private Object invokeMethodAtCompilationLevel(Method method, int level)\n-            throws InterruptedException {\n-        Object res = null;\n-        WB.enqueueMethodForCompilation(method, level);\n-        while (WB.getMethodCompilationLevel(method) != level) {\n+    private void runTestOnMethod(Method method) throws InterruptedException {\n+        Object expected = null;\n+        Object actual = null;\n+\n+        \/\/ Temporarily disable the compiler and invoke the method to get reference\n+        \/\/ result from the interpreter\n+        assert(WB.getBooleanVMFlag(\"UseCompiler\"));\n+        WB.setBooleanVMFlag(\"UseCompiler\", false);\n+        try {\n+            expected = method.invoke(this);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            fail(\"Exception is thrown in test method invocation (interpreter).\");\n+        }\n+        assert(WB.getMethodCompilationLevel(method) == COMP_LEVEL_INTP);\n+        WB.setBooleanVMFlag(\"UseCompiler\", true);\n+\n+        \/\/ Compile the method and invoke it again\n+        long enqueueTime = System.currentTimeMillis();\n+        WB.enqueueMethodForCompilation(method, COMP_LEVEL_C2);\n+        while (WB.getMethodCompilationLevel(method) != COMP_LEVEL_C2) {\n@@ -127,1 +141,1 @@\n-            res = method.invoke(this);\n+            actual = method.invoke(this);\n@@ -130,1 +144,1 @@\n-            fail(\"Exception is thrown at compilation level \" + level);\n+            fail(\"Exception is thrown in test method invocation (C2).\");\n@@ -132,7 +146,1 @@\n-        assert(WB.getMethodCompilationLevel(method) == level);\n-        return res;\n-    }\n-\n-    private void runTestOnMethod(Method method) throws InterruptedException {\n-        Object expected = invokeMethodAtCompilationLevel(method, COMP_LEVEL_C1);\n-        Object actual = invokeMethodAtCompilationLevel(method, COMP_LEVEL_C2);\n+        assert(WB.getMethodCompilationLevel(method) == COMP_LEVEL_C2);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"}]}