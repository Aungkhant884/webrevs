{"files":[{"patch":"@@ -161,1 +161,1 @@\n-  \/\/ can be used after this point.\n+  \/\/ can be used after this point. These are no-op when CDS is enabled.\n@@ -169,25 +169,30 @@\n-  \/\/ do a bunch more:\n-  resolve_through(VM_CLASS_ID(Reference_klass), scan, CHECK);\n-\n-  \/\/ The offsets for jlr.Reference must be computed before\n-  \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n-  \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n-  \/\/ as they are treated in a special way by the GC. Removing these oops from the\n-  \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n-  java_lang_ref_Reference::compute_offsets();\n-\n-  \/\/ Preload ref klasses and set reference types\n-  vmClasses::Reference_klass()->set_reference_type(REF_OTHER);\n-  InstanceRefKlass::update_nonstatic_oop_maps(vmClasses::Reference_klass());\n-\n-  resolve_through(VM_CLASS_ID(PhantomReference_klass), scan, CHECK);\n-  vmClasses::SoftReference_klass()->set_reference_type(REF_SOFT);\n-  vmClasses::WeakReference_klass()->set_reference_type(REF_WEAK);\n-  vmClasses::FinalReference_klass()->set_reference_type(REF_FINAL);\n-  vmClasses::PhantomReference_klass()->set_reference_type(REF_PHANTOM);\n-\n-  \/\/ JSR 292 classes\n-  vmClassID jsr292_group_start = VM_CLASS_ID(MethodHandle_klass);\n-  vmClassID jsr292_group_end   = VM_CLASS_ID(VolatileCallSite_klass);\n-  resolve_until(jsr292_group_start, scan, CHECK);\n-  resolve_through(jsr292_group_end, scan, CHECK);\n+  if (UseSharedSpaces) {\n+    \/\/ These should already have been initialized during CDS dump.\n+    assert(vmClasses::Reference_klass()->reference_type() == REF_OTHER, \"sanity\");\n+    assert(vmClasses::SoftReference_klass()->reference_type() == REF_SOFT, \"sanity\");\n+    assert(vmClasses::WeakReference_klass()->reference_type() == REF_WEAK, \"sanity\");\n+    assert(vmClasses::FinalReference_klass()->reference_type() == REF_FINAL, \"sanity\");\n+    assert(vmClasses::PhantomReference_klass()->reference_type() == REF_PHANTOM, \"sanity\");\n+  } else {\n+    \/\/ If CDS is not enabled, the references classes must be initialized in\n+    \/\/ this order before the rest of the vmClasses can be resolved.\n+    resolve_through(VM_CLASS_ID(Reference_klass), scan, CHECK);\n+\n+    \/\/ The offsets for jlr.Reference must be computed before\n+    \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n+    \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n+    \/\/ as they are treated in a special way by the GC. Removing these oops from the\n+    \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n+    java_lang_ref_Reference::compute_offsets();\n+\n+    \/\/ Preload ref klasses and set reference types\n+    vmClasses::Reference_klass()->set_reference_type(REF_OTHER);\n+    InstanceRefKlass::update_nonstatic_oop_maps(vmClasses::Reference_klass());\n+\n+    resolve_through(VM_CLASS_ID(PhantomReference_klass), scan, CHECK);\n+    vmClasses::SoftReference_klass()->set_reference_type(REF_SOFT);\n+    vmClasses::WeakReference_klass()->set_reference_type(REF_WEAK);\n+    vmClasses::FinalReference_klass()->set_reference_type(REF_FINAL);\n+    vmClasses::PhantomReference_klass()->set_reference_type(REF_PHANTOM);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"}]}