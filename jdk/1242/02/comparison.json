{"files":[{"patch":"@@ -103,2 +103,0 @@\n-  check_safepoint_state(self);\n-\n@@ -107,0 +105,3 @@\n+  check_safepoint_state(self);\n+  check_rank(self);\n+\n@@ -127,1 +128,0 @@\n-  check_no_safepoint_state(self);\n@@ -129,0 +129,4 @@\n+\n+  check_no_safepoint_state(self);\n+  check_rank(self);\n+\n@@ -140,1 +144,1 @@\n-bool Mutex::try_lock() {\n+bool Mutex::try_lock_inner(bool do_rank_checks) {\n@@ -142,0 +146,9 @@\n+  \/\/ Checking the owner hides the potential difference in recursive locking behaviour\n+  \/\/ on some platforms.\n+  if(owned_by_self(self)) {\n+    return false;\n+  }\n+\n+  if(do_rank_checks) {\n+    check_rank(self);\n+  }\n@@ -145,3 +158,2 @@\n-  \/\/ Checking the owner hides the potential difference in recursive locking behaviour\n-  \/\/ on some platforms.\n-  if (_owner != self && _lock.try_lock()) {\n+\n+  if (_lock.try_lock()) {\n@@ -155,0 +167,10 @@\n+bool Mutex::try_lock() {\n+  return try_lock_inner(true \/* do_rank_checks *\/);\n+}\n+\n+bool Mutex::try_lock_without_rank_check() {\n+  bool res = try_lock_inner(false \/* do_rank_checks *\/);\n+  DEBUG_ONLY(if (res) _skip_rank_check = true;)\n+  return res;\n+}\n+\n@@ -176,13 +198,0 @@\n-#ifdef ASSERT\n-void Monitor::assert_wait_lock_state(Thread* self) {\n-  Mutex* least = get_least_ranked_lock_besides_this(self->owned_locks());\n-  assert(least != this, \"Specification of get_least_... call above\");\n-  if (least != NULL && least->rank() <= special) {\n-    ::tty->print(\"Attempting to wait on monitor %s\/%d while holding\"\n-               \" lock %s\/%d -- possible deadlock\",\n-               name(), rank(), least->name(), least->rank());\n-    assert(false, \"Shouldn't block(wait) while holding a lock of rank special\");\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n@@ -194,1 +203,0 @@\n-\n@@ -196,1 +204,1 @@\n-  assert_wait_lock_state(self);\n+  check_rank(self);\n@@ -201,0 +209,1 @@\n+\n@@ -211,0 +220,2 @@\n+  \/\/ Safepoint checking logically implies an active JavaThread.\n+  assert(self->is_active_Java_thread(), \"invariant\");\n@@ -214,1 +225,0 @@\n-\n@@ -216,0 +226,1 @@\n+  check_rank(self);\n@@ -217,5 +228,0 @@\n-  \/\/ Safepoint checking logically implies an active JavaThread.\n-  guarantee(self->is_active_Java_thread(), \"invariant\");\n-  assert_wait_lock_state(self);\n-\n-  int wait_status;\n@@ -225,0 +231,1 @@\n+\n@@ -228,0 +235,1 @@\n+  int wait_status;\n@@ -288,0 +296,1 @@\n+  _skip_rank_check = false;\n@@ -301,2 +310,6 @@\n-bool Mutex::owned_by_self() const {\n-  return _owner == Thread::current();\n+bool Mutex::owned_by_self(Thread* thread) const {\n+  return _owner == thread;\n+}\n+\n+bool Mutex::owned_by_self() const { \n+  return owned_by_self(Thread::current()); \n@@ -333,1 +346,1 @@\n-#endif\n+#endif \/\/ PRODUCT\n@@ -356,10 +369,0 @@\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ In this case, we expect the held locks to be\n-    \/\/ in increasing rank order (modulo any native ranks)\n-    for (tmp = locks; tmp != NULL; tmp = tmp->next()) {\n-      if (tmp->next() != NULL) {\n-        assert(tmp->rank() == Mutex::native ||\n-               tmp->rank() <= tmp->next()->rank(), \"mutex rank anomaly?\");\n-      }\n-    }\n-  }\n@@ -376,0 +379,9 @@\n+  assert(res != this, \"invariant\");\n+  return res;\n+}\n+\n+\/\/ Tests for rank violations that might indicate exposure to deadlock.\n+void Mutex::check_rank(Thread* thread) {\n+  assert(this->rank() >= 0, \"bad lock rank\");\n+  Mutex* locks_owned = thread->owned_locks();\n+\n@@ -377,3 +389,3 @@\n-    \/\/ In this case, we expect the held locks to be\n-    \/\/ in increasing rank order (modulo any native ranks)\n-    for (tmp = locks; tmp != NULL; tmp = tmp->next()) {\n+    \/\/ We expect the locks already acquired to be in increasing rank order,\n+    \/\/ modulo locks of native rank or acquired in try_lock_without_rank_check()\n+    for (Mutex* tmp = locks_owned; tmp != NULL; tmp = tmp->next()) {\n@@ -381,2 +393,2 @@\n-        assert(tmp->rank() == Mutex::native ||\n-               tmp->rank() <= tmp->next()->rank(), \"mutex rank anomaly?\");\n+        assert(tmp->rank() == Mutex::native || tmp->rank() < tmp->next()->rank()\n+               || tmp->skip_rank_check(), \"mutex rank anomaly?\");\n@@ -386,1 +398,31 @@\n-  return res;\n+\n+  \/\/ Locks with rank native or suspend_resume are an exception and are not\n+  \/\/ subject to the verification rules.\n+  bool check_can_be_skipped = this->rank() == Mutex::native || this->rank() == Mutex::suspend_resume\n+                              || SafepointSynchronize::is_at_safepoint();\n+  if (owned_by_self()) {\n+    \/\/ wait() case\n+    Mutex* least = get_least_ranked_lock_besides_this(locks_owned);\n+    \/\/ We enforce not holding locks of rank special or lower while waiting.\n+    \/\/ Also \"this\" should be the monitor with lowest rank owned by this thread.\n+    if (least != NULL && (least->rank() <= special ||\n+        (least->rank() <= this->rank() && !check_can_be_skipped))) {\n+      assert(false, \"Attempting to wait on monitor %s\/%d while holding lock %s\/%d -- \"\n+             \"possible deadlock. %s\", name(), rank(), least->name(), least->rank(),\n+             least->rank() <= this->rank() ? \"Should wait on the least ranked monitor from \"\n+             \"all owned locks.\" : \"Should not block(wait) while holding a lock of rank special.\");\n+    }\n+  } else {\n+    \/\/ lock()\/lock_without_safepoint_check()\/try_lock() case\n+    Mutex* least = get_least_ranked_lock(locks_owned);\n+    \/\/ Deadlock prevention rules require us to acquire Mutexes only in\n+    \/\/ a global total order. For example, if m1 is the lowest ranked mutex\n+    \/\/ that the thread holds and m2 is the mutex the thread is trying\n+    \/\/ to acquire, then deadlock prevention rules require that the rank\n+    \/\/ of m2 be less than the rank of m1. This prevents circular waits.\n+    if (least != NULL && least->rank() <= this->rank() && !check_can_be_skipped) {\n+      thread->print_owned_locks();\n+      assert(false, \"Attempting to acquire lock %s\/%d out of order with lock %s\/%d -- \"\n+             \"possible deadlock\", this->name(), this->rank(), least->name(), least->rank());\n+    }\n+  }\n@@ -416,2 +458,1 @@\n-\/\/ to track the lock-set of the thread and test for rank violations that\n-\/\/ might indicate exposure to deadlock.\n+\/\/ to track the lock-set of the thread.\n@@ -439,23 +480,0 @@\n-\n-    Mutex* locks = get_least_ranked_lock(new_owner->owned_locks());\n-    \/\/ Mutex::set_owner_implementation is a friend of Thread\n-\n-    assert(this->rank() >= 0, \"bad lock rank\");\n-\n-    \/\/ Deadlock avoidance rules require us to acquire Mutexes only in\n-    \/\/ a global total order. For example m1 is the lowest ranked mutex\n-    \/\/ that the thread holds and m2 is the mutex the thread is trying\n-    \/\/ to acquire, then deadlock avoidance rules require that the rank\n-    \/\/ of m2 be less than the rank of m1.\n-    \/\/ The rank Mutex::native  is an exception in that it is not subject\n-    \/\/ to the verification rules.\n-    if (this->rank() != Mutex::native &&\n-        this->rank() != Mutex::suspend_resume &&\n-        locks != NULL && locks->rank() <= this->rank() &&\n-        !SafepointSynchronize::is_at_safepoint()) {\n-      new_owner->print_owned_locks();\n-      fatal(\"acquiring lock %s\/%d out of order with lock %s\/%d -- \"\n-            \"possible deadlock\", this->name(), this->rank(),\n-            locks->name(), locks->rank());\n-    }\n-\n@@ -473,0 +491,1 @@\n+    _skip_rank_check = false;\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":91,"deletions":72,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+#endif\n+#ifdef ASSERT\n@@ -95,0 +97,2 @@\n+  bool _skip_rank_check;         \/\/ read only by owner when doing rank checks\n+\n@@ -98,1 +102,10 @@\n-#endif  \/\/ ASSERT\n+  bool skip_rank_check() {\n+    assert(owned_by_self(), \"only the owner should call this\");\n+    return _skip_rank_check;\n+  }\n+\n+ public:\n+  int    rank() const          { return _rank; }\n+  Mutex* next()  const         { return _next; }\n+  void   set_next(Mutex *next) { _next = next; }\n+#endif \/\/ ASSERT\n@@ -100,0 +113,1 @@\n+ protected:\n@@ -104,0 +118,1 @@\n+  void check_rank              (Thread* thread)                       NOT_DEBUG_RETURN;\n@@ -173,0 +188,1 @@\n+  bool try_lock_inner(bool do_rank_checks);\n@@ -181,0 +197,2 @@\n+  \/\/ A thread should not call this if failure to acquire ownership will blocks its progress\n+  bool try_lock_without_rank_check();\n@@ -185,0 +203,2 @@\n+  void set_owner(Thread* owner) { set_owner_implementation(owner); }\n+  bool owned_by_self(Thread* thread) const;\n@@ -190,1 +210,0 @@\n-\n@@ -195,9 +214,0 @@\n-  #ifdef ASSERT\n-    int    rank() const          { return _rank; }\n-    bool   allow_vm_block()      { return _allow_vm_block; }\n-\n-    Mutex *next()  const         { return _next; }\n-    void   set_next(Mutex *next) { _next = next; }\n-  #endif \/\/ ASSERT\n-\n-  void set_owner(Thread* owner)             { set_owner_implementation(owner); }\n@@ -207,1 +217,0 @@\n-  void assert_wait_lock_state  (Thread* self)                         NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"unittest.hpp\"\n+\n+#ifdef ASSERT\n+\n+const int rankA = 50;\n+\n+TEST_OTHER_VM(MutexRank, mutex_lock_rank_in_order) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", false, Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankA + 1, \"mutex_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+\n+  mutex_rankA_plus_one->lock();\n+  mutex_rankA->lock();\n+  mutex_rankA->unlock();\n+  mutex_rankA_plus_one->unlock();\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, mutex_lock_rank_out_of_orderA,\n+                   \"Attempting to acquire lock mutex_rankA_plus_one\/51 out of order with lock mutex_rankA\/50 -- possible deadlock\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", false, Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankA + 1, \"mutex_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+\n+  mutex_rankA->lock();\n+  mutex_rankA_plus_one->lock();\n+  mutex_rankA_plus_one->unlock();\n+  mutex_rankA->unlock();\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, mutex_lock_rank_out_of_orderB,\n+                   \"Attempting to acquire lock mutex_rankB\/50 out of order with lock mutex_rankA\/50 -- possible deadlock\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", false, Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankB = new Mutex(rankA, \"mutex_rankB\", false, Mutex::_safepoint_check_always);\n+\n+  mutex_rankA->lock();\n+  mutex_rankB->lock();\n+  mutex_rankB->unlock();\n+  mutex_rankA->unlock();\n+}\n+\n+TEST_OTHER_VM(MutexRank, mutex_trylock_rank_out_of_order) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", false, Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankA + 1, \"mutex_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_two = new Mutex(rankA + 2, \"mutex_rankA_plus_two\", false, Mutex::_safepoint_check_always);\n+\n+  mutex_rankA_plus_two->lock();\n+  mutex_rankA->lock();\n+  mutex_rankA_plus_one->try_lock_without_rank_check();\n+  mutex_rankA_plus_one->unlock();\n+  mutex_rankA->unlock();\n+  mutex_rankA_plus_two->unlock();\n+}\n+\n+TEST_OTHER_VM(MutexRank, monitor_wait_rank_in_order) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", false, Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankA + 1, \"monitor_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+\n+  monitor_rankA_plus_one->lock();\n+  monitor_rankA->lock();\n+  monitor_rankA->wait(1);\n+  monitor_rankA->unlock();\n+  monitor_rankA_plus_one->unlock();\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_wait_rank_out_of_order,\n+                   \"Attempting to wait on monitor monitor_rankA_plus_one\/51 while holding lock monitor_rankA\/50 \"\n+                   \"-- possible deadlock. Should wait on the least ranked monitor from all owned locks.\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", false, Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankA + 1, \"monitor_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+\n+  monitor_rankA_plus_one->lock();\n+  monitor_rankA->lock();\n+  monitor_rankA_plus_one->wait(1);\n+  monitor_rankA_plus_one->unlock();\n+  monitor_rankA->unlock();\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_wait_rank_out_of_order_trylock,\n+                   \"Attempting to wait on monitor monitor_rankA_plus_one\/51 while holding lock monitor_rankA\/50 \"\n+                   \"-- possible deadlock. Should wait on the least ranked monitor from all owned locks.\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", false, Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankA + 1, \"monitor_rankA_plus_one\", false, Mutex::_safepoint_check_always);\n+\n+  monitor_rankA->lock();\n+  monitor_rankA_plus_one->try_lock_without_rank_check();\n+  monitor_rankA_plus_one->wait();\n+  monitor_rankA_plus_one->unlock();\n+  monitor_rankA->unlock();\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_wait_rank_special,\n+                   \"Attempting to wait on monitor monitor_rank_special_minus_one\/5 while holding lock monitor_rank_special\/6 \"\n+                   \"-- possible deadlock. Should not block\\\\(wait\\\\) while holding a lock of rank special.\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rank_special = new Monitor(Mutex::special, \"monitor_rank_special\", false, Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_special_minus_one = new Monitor(Mutex::special - 1, \"monitor_rank_special_minus_one\", false, Mutex::_safepoint_check_never);\n+\n+  monitor_rank_special->lock_without_safepoint_check();\n+  monitor_rank_special_minus_one->lock_without_safepoint_check();\n+  monitor_rank_special_minus_one->wait_without_safepoint_check(1);\n+  monitor_rank_special_minus_one->unlock();\n+  monitor_rank_special->unlock();\n+}\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_mutex_rank.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"}]}