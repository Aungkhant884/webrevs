{"files":[{"patch":"@@ -1394,0 +1394,1 @@\n+        private volatile boolean finalPushResponseCodeReceived;\n@@ -1490,3 +1491,0 @@\n-            responseCode = (int)responseHeaders\n-                .firstValueAsLong(\":status\")\n-                .orElse(-1);\n@@ -1494,3 +1492,4 @@\n-            if (responseCode == -1) {\n-                completeResponseExceptionally(new IOException(\"No status code\"));\n-            }\n+            if (!finalPushResponseCodeReceived) {\n+                responseCode = (int)responseHeaders\n+                    .firstValueAsLong(\":status\")\n+                    .orElse(-1);\n@@ -1498,3 +1497,3 @@\n-            this.response = new Response(\n-                pushReq, exchange, responseHeaders, connection(),\n-                responseCode, HttpClient.Version.HTTP_2);\n+                if (responseCode == -1) {\n+                    completeResponseExceptionally(new IOException(\"No status code\"));\n+                }\n@@ -1502,5 +1501,1 @@\n-            \/* TODO: review if needs to be removed\n-               the value is not used, but in case `content-length` doesn't parse\n-               as long, there will be NumberFormatException. If left as is, make\n-               sure code up the stack handles NFE correctly. *\/\n-            responseHeaders.firstValueAsLong(\"content-length\");\n+                this.finalPushResponseCodeReceived = true;\n@@ -1508,6 +1503,3 @@\n-            if (Log.headers()) {\n-                StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS\");\n-                sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n-                Log.dumpHeaders(sb, \"    \", responseHeaders);\n-                Log.logHeaders(sb.toString());\n-            }\n+                this.response = new Response(\n+                        pushReq, exchange, responseHeaders, connection(),\n+                        responseCode, HttpClient.Version.HTTP_2);\n@@ -1515,1 +1507,5 @@\n-            rspHeadersConsumer.reset();\n+                \/* TODO: review if needs to be removed\n+                   the value is not used, but in case `content-length` doesn't parse\n+                   as long, there will be NumberFormatException. If left as is, make\n+                   sure code up the stack handles NFE correctly. *\/\n+                responseHeaders.firstValueAsLong(\"content-length\");\n@@ -1517,2 +1513,20 @@\n-            \/\/ different implementations for normal streams and pushed streams\n-            completeResponse(response);\n+                if (Log.headers()) {\n+                    StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS\");\n+                    sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n+                    Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                    Log.logHeaders(sb.toString());\n+                }\n+\n+                rspHeadersConsumer.reset();\n+\n+                \/\/ different implementations for normal streams and pushed streams\n+                completeResponse(response);\n+            } else {\n+                if (Log.headers()) {\n+                    StringBuilder sb = new StringBuilder(\"TRAILING HEADERS\");\n+                    sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n+                    Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                    Log.logHeaders(sb.toString());\n+                }\n+                rspHeadersConsumer.reset();\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @library \/test\/lib server\n@@ -30,0 +29,2 @@\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer\n@@ -34,1 +35,1 @@\n- * @run testng\/othervm -Djdk.httpclient.HttpClient.log=errors,requests,headers TrailingHeadersTest\n+ * @run testng\/othervm -Djdk.httpclient.HttpClient.log=all TrailingHeadersTest\n@@ -37,0 +38,1 @@\n+import jdk.httpclient.test.lib.http2.OutgoingPushPromise;\n@@ -41,0 +43,1 @@\n+import org.testng.TestException;\n@@ -42,0 +45,1 @@\n+import org.testng.annotations.BeforeMethod;\n@@ -43,0 +47,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -46,0 +51,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -48,0 +54,1 @@\n+import java.io.OutputStream;\n@@ -57,0 +64,1 @@\n+import java.util.HashMap;\n@@ -58,0 +66,2 @@\n+import java.util.Map;\n+import java.util.Properties;\n@@ -59,1 +69,14 @@\n-\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executors;\n+import java.util.function.BiPredicate;\n+\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -65,1 +88,1 @@\n-    URI trailingURI, trailng1xxURI, warmupURI;\n+    URI trailingURI, trailng1xxURI, trailingPushPromiseURI, warmupURI;\n@@ -68,0 +91,8 @@\n+    \/\/ Set up simple client-side push promise handler\n+    ConcurrentMap<HttpRequest, CompletableFuture<HttpResponse<String>>> pushPromiseMap = new ConcurrentHashMap<>();\n+\n+    @BeforeMethod\n+    public void beforeMethod() {\n+        pushPromiseMap = new ConcurrentHashMap<>();\n+    }\n+\n@@ -70,1 +101,11 @@\n-        http2TestServer = new Http2TestServer(false, 0);\n+        Properties props = new Properties();\n+        \/\/ For triggering trailing headers to send after Push Promise Response headers are sent\n+        props.setProperty(\"sendTrailingHeadersAfterPushPromise\", \"1\");\n+\n+        http2TestServer = new Http2TestServer(\"Test_Server\",\n+                                              false,\n+                                              0,\n+                                              null,\n+                                              0,\n+                                              props,\n+                                       null);\n@@ -74,0 +115,1 @@\n+        http2TestServer.addHandler(new PushPromiseTrailersHandler(), \"\/PushPromiseTrailingHeaders\");\n@@ -80,1 +122,1 @@\n-        warmupURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/WarmupHandler\");\n+        trailingPushPromiseURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/PushPromiseTrailingHeaders\");\n@@ -82,2 +124,2 @@\n-        testLog.println(this.getClass().getCanonicalName() + \": setup(): trailing = \" + trailingURI);\n-        testLog.println(this.getClass().getCanonicalName() + \": setup(): trailing1xxURI = \" + trailng1xxURI);\n+        \/\/ Used to ensure HTTP\/2 upgrade takes place\n+        warmupURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/WarmupHandler\");\n@@ -91,2 +133,3 @@\n-    @Test\n-    public void testTrailingHeaders() {\n+    @Test(dataProvider = \"httpRequests\")\n+    public void testTrailingHeaders(String description, HttpRequest hRequest, HttpResponse.PushPromiseHandler<String> pph) {\n+        testLog.println(\"testTrailingHeaders(): \" + description);\n@@ -94,1 +137,0 @@\n-        testLog.println(this.getClass().getCanonicalName() + \": testTrailingHeaders(): Performing warmup request, upgrade to HTTP\/2\");\n@@ -96,0 +138,4 @@\n+        CompletableFuture<HttpResponse<String>> cf = httpClient.sendAsync(hRequest, BodyHandlers.ofString(UTF_8), pph);\n+\n+        testLog.println(\"testTrailingHeaders(): Performing request: \" + hRequest);\n+        HttpResponse<String> resp = cf.join();\n@@ -97,2 +143,26 @@\n-        HttpRequest hRequest = HttpRequest.newBuilder()\n-                .version(HttpClient.Version.HTTP_2)\n+        assertEquals(resp.statusCode(), 200, \"Status code of response should be 200\");\n+\n+        \/\/ Verify Push Promise was successful if necessary\n+        if (pph != null)\n+            verifyPushPromise();\n+\n+        testLog.println(\"testTrailingHeaders(): Request successfully completed\");\n+    }\n+\n+    private void verifyPushPromise()  {\n+        if (pushPromiseMap.size() > 1) {\n+            throw new TestException(\"Push Promise map size is greater than 1\");\n+        } else {\n+            \/\/ This will only iterate once\n+            for (HttpRequest r : pushPromiseMap.keySet()) {\n+                CompletableFuture<HttpResponse<String>> serverPushResp = pushPromiseMap.get(r);\n+                \/\/ Get the push promise HttpResponse result if present\n+                HttpResponse<String> resp = serverPushResp.join();\n+                assertEquals(resp.body(), \"Sample_Push_Data\", \"Unexpected Push Promise response body\");\n+                assertEquals(resp.statusCode(), 200, \"Status code of Push Promise response should be 200\");\n+            }\n+        }\n+    }\n+\n+    private void performWarmupRequest(HttpClient httpClient) {\n+        HttpRequest warmupReq = HttpRequest.newBuilder(warmupURI).version(HTTP_2)\n@@ -100,1 +170,0 @@\n-                .uri(trailingURI)\n@@ -102,4 +171,1 @@\n-        testLog.println(this.getClass().getCanonicalName() + \": testTrailingHeaders(): Client sending GET\");\n-        CompletableFuture<HttpResponse<String>> hSend = httpClient.sendAsync(hRequest, BodyHandlers.ofString(StandardCharsets.UTF_8));\n-        HttpResponse<String> hResponse = hSend.join();\n-        assertEquals(hResponse.statusCode(), 200, (\"Expected 200 but got \" + hResponse.statusCode()));\n+        httpClient.sendAsync(warmupReq, BodyHandlers.discarding()).join();\n@@ -108,10 +174,10 @@\n-    \/**\n-     * Changes concerned with this test alters behavior of how partial http responses are handled (1XX Codes).\n-     * Therefore, an additional test case checking that partial responses, when expected by the client, behave\n-     * as expected.\n-     *\/\n-    @Test\n-    public void testTrailingHeaders1XX() {\n-        HttpClient httpClient = HttpClient.newBuilder().build();\n-        testLog.println(this.getClass().getCanonicalName() + \": testTrailingHeaders1XX(): Performing warmup request, upgrade to HTTP\/2\");\n-        performWarmupRequest(httpClient);\n+    @DataProvider(name = \"httpRequests\")\n+    public Object[][] uris() {\n+        HttpResponse.PushPromiseHandler<String> pph = (initial, pushRequest, acceptor) -> {\n+            HttpResponse.BodyHandler<String> s = HttpResponse.BodyHandlers.ofString(UTF_8);\n+            pushPromiseMap.put(pushRequest, acceptor.apply(s));\n+        };\n+\n+        HttpRequest httpGetTrailing = HttpRequest.newBuilder(trailingURI).version(HTTP_2)\n+                .GET()\n+                .build();\n@@ -119,2 +185,1 @@\n-        HttpRequest hRequest = HttpRequest.newBuilder()\n-                .version(HttpClient.Version.HTTP_2)\n+        HttpRequest httpPost1xxTrailing = HttpRequest.newBuilder(trailng1xxURI).version(HTTP_2)\n@@ -123,1 +188,0 @@\n-                .uri(trailng1xxURI)\n@@ -125,5 +189,0 @@\n-        testLog.println(this.getClass().getCanonicalName() + \": testTrailingHeaders1XX(): Client sending POST with 100-continue header\");\n-        CompletableFuture<HttpResponse<String>> hSend = httpClient.sendAsync(hRequest, BodyHandlers.ofString(StandardCharsets.UTF_8));\n-        HttpResponse<String> hResponse = hSend.join();\n-        assertEquals(hResponse.statusCode(), 200, (\"Expected 200 but got \" + hResponse.statusCode()));\n-    }\n@@ -131,3 +190,1 @@\n-    private void performWarmupRequest(HttpClient httpClient) {\n-        HttpRequest warmupReq = HttpRequest.newBuilder()\n-                .version(HttpClient.Version.HTTP_2)\n+        HttpRequest httpGetPushPromiseTrailing = HttpRequest.newBuilder(trailingPushPromiseURI).version(HTTP_2)\n@@ -135,1 +192,0 @@\n-                .uri(warmupURI)\n@@ -137,2 +193,6 @@\n-        CompletableFuture<HttpResponse<String>> warmup = httpClient.sendAsync(warmupReq, BodyHandlers.ofString(StandardCharsets.UTF_8));\n-        warmup.join();\n+\n+        return new Object[][] {\n+                { \"Test GET with Trailing Headers\", httpGetTrailing, null },\n+                { \"Test POST with 1xx response & Trailing Headers\", httpPost1xxTrailing, null },\n+                { \"Test Push Promise with Trailing Headers\", httpGetPushPromiseTrailing, pph }\n+        };\n@@ -143,1 +203,1 @@\n-        byte[] resp = \"Test Response\".getBytes(StandardCharsets.UTF_8);\n+        byte[] resp = \"Sample_Data\".getBytes(StandardCharsets.UTF_8);\n@@ -153,6 +213,0 @@\n-            this.sendResponseHeaders(200, resp.length);\n-            DataFrame dataFrame = new DataFrame(this.streamid, 0, ByteBuffer.wrap(resp));\n-            this.conn.outputQ.put(dataFrame);\n-\n-            \/\/ Encoding sample headers here can intermittently cause an IllegalStateException as the encoder may be busy.\n-            \/\/ Leaving the code commented out here as it can be useful to observe how Trailing Headers appear in the log.\n@@ -164,1 +218,1 @@\n-\n+            \/\/ TODO: see if there is a safe way to encode headers without interrupting connection thread\n@@ -168,1 +222,27 @@\n-            this.conn.outputQ.put(headerFrame);\n+\n+            this.sendResponseHeaders(200, resp.length);\n+            DataFrame dataFrame = new DataFrame(this.streamid, 0, ByteBuffer.wrap(resp));\n+            this.conn.addToOutputQ(dataFrame);\n+            this.conn.addToOutputQ(headerFrame);\n+        }\n+\n+        @Override\n+        public void serverPush(URI uri, HttpHeaders headers, InputStream content) {\n+            HttpHeadersBuilder headersBuilder = new HttpHeadersBuilder();\n+            headersBuilder.setHeader(\":method\", \"GET\");\n+            headersBuilder.setHeader(\":scheme\", uri.getScheme());\n+            headersBuilder.setHeader(\":authority\", uri.getAuthority());\n+            headersBuilder.setHeader(\":path\", uri.getPath());\n+            for (Map.Entry<String,List<String>> entry : headers.map().entrySet()) {\n+                for (String value : entry.getValue())\n+                    headersBuilder.addHeader(entry.getKey(), value);\n+            }\n+            HttpHeaders combinedHeaders = headersBuilder.build();\n+            OutgoingPushPromise pp = new OutgoingPushPromise(streamid, uri, combinedHeaders, content);\n+            pp.setFlag(HeaderFrame.END_HEADERS);\n+\n+            try {\n+                this.conn.addToOutputQ(pp);\n+            } catch (IOException ex) {\n+                testLog.println(\"serverPush(): pushPromise exception: \" + ex);\n+            }\n@@ -189,1 +269,1 @@\n-                testLog.println(this.getClass().getCanonicalName() + \": Incorrect protocol version\");\n+                testLog.println(\"ResponseTrailersHandler: Incorrect protocol version\");\n@@ -210,1 +290,1 @@\n-                testLog.println(this.getClass().getCanonicalName() + \": Incorrect protocol version\");\n+                testLog.println(\"InformationalTrailersHandler: Incorrect protocol version\");\n@@ -214,0 +294,11 @@\n+    }\n+\n+    static class PushPromiseTrailersHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (exchange.getProtocol().equals(\"HTTP\/2\")) {\n+                if (exchange instanceof TrailingHeadersExchange trailingHeadersExchange) {\n+                    try (InputStream is = exchange.getRequestBody()) {\n+                        is.readAllBytes();\n+                    }\n@@ -215,0 +306,3 @@\n+                    if (exchange.serverPushAllowed()) {\n+                        pushPromise(trailingHeadersExchange);\n+                    }\n@@ -216,0 +310,21 @@\n+                    try (OutputStream os = trailingHeadersExchange.getResponseBody()) {\n+                        byte[] bytes = \"Sample_Data\".getBytes(UTF_8);\n+                        trailingHeadersExchange.sendResponseHeaders(200, bytes.length);\n+                        os.write(bytes);\n+                    }\n+                }\n+            }\n+        }\n+\n+        static final BiPredicate<String,String> ACCEPT_ALL = (x, y) -> true;\n+\n+        private void pushPromise(Http2TestExchange exchange) {\n+            URI requestURI = exchange.getRequestURI();\n+            URI uri = requestURI.resolve(\"\/promise\");\n+            InputStream is = new ByteArrayInputStream(\"Sample_Push_Data\".getBytes(UTF_8));\n+            Map<String, List<String>> map = new HashMap<>();\n+            map.put(\"x-promise\", List.of(\"promise-header\"));\n+            HttpHeaders headers = HttpHeaders.of(map, ACCEPT_ALL);\n+            exchange.serverPush(uri, headers, is);\n+            testLog.println(\"PushPromiseTrailersHandler: Push Promise complete\");\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/TrailingHeadersTest.java","additions":169,"deletions":54,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-            send(EMPTY_BARRAY, 0, 0, DataFrame.END_STREAM);\n+            sendEndStream();\n@@ -139,0 +139,4 @@\n+\n+    protected void sendEndStream() throws IOException {\n+        send(EMPTY_BARRAY, 0, 0, DataFrame.END_STREAM);\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyOutputStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        this.properties = properties;\n+        this.properties = properties == null ? new Properties() : properties;\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -963,1 +963,16 @@\n-                        SettingsFrame.INITIAL_WINDOW_SIZE), this);\n+                        SettingsFrame.INITIAL_WINDOW_SIZE), this) {\n+\n+            @Override\n+            protected void sendEndStream() {\n+                try {\n+                    if (properties.getProperty(\"sendTrailingHeadersAfterPushPromise\", \"0\").equals(\"1\")) {\n+                        conn.outputQ.put(getTrailingHeadersFrame(promisedStreamid, List.of()));\n+                    } else {\n+                        super.sendEndStream();\n+                    }\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        };\n+\n@@ -970,0 +985,1 @@\n+\n@@ -982,0 +998,5 @@\n+    private HeadersFrame getTrailingHeadersFrame(int promisedStreamid, List<ByteBuffer> headerBlocks) {\n+        \/\/ TODO: see if there is a safe way to encode headers without interrupting connection thread\n+        return new HeadersFrame(promisedStreamid, (HeaderFrame.END_HEADERS | HeaderFrame.END_STREAM), headerBlocks);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}