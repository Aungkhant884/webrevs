{"files":[{"patch":"@@ -45,1 +45,1 @@\n-    _verify_closure(VerifyOption::G1UseFullMarking),\n+    _verify_closure(G1CollectedHeap::heap(), VerifyOption::G1UseFullMarking),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1OopClosures.hpp\"\n@@ -65,1 +66,1 @@\n-  G1VerifyOopClosure    _verify_closure;\n+  G1VerifyLiveClosure   _verify_closure;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/g1\/g1OopClosures.inline.hpp\"\n@@ -129,1 +130,1 @@\n-    if (_verify_closure.failures()) {\n+    if (_verify_closure.has_failures()) {\n@@ -149,2 +150,1 @@\n-      if (_verify_closure.failures()) {\n-        log_warning(gc, verify)(\"Failed after %d\", _verify_closure._cc);\n+      if (_verify_closure.has_failures()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,59 +43,0 @@\n-\n-G1VerifyOopClosure::G1VerifyOopClosure(VerifyOption option) :\n-   _g1h(G1CollectedHeap::heap()),\n-   _failures(false),\n-   _containing_obj(NULL),\n-   _verify_option(option),\n-   _cc(0) {\n-}\n-\n-void G1VerifyOopClosure::print_object(outputStream* out, oop obj) {\n-#ifdef PRODUCT\n-  Klass* k = obj->klass();\n-  const char* class_name = InstanceKlass::cast(k)->external_name();\n-  out->print_cr(\"class name %s\", class_name);\n-#else \/\/ PRODUCT\n-  obj->print_on(out);\n-#endif \/\/ PRODUCT\n-}\n-\n-template <class T> void G1VerifyOopClosure::do_oop_work(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    _cc++;\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    bool failed = false;\n-    if (!_g1h->is_in(obj) || _g1h->is_obj_dead_cond(obj, _verify_option)) {\n-      MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n-      LogStreamHandle(Error, gc, verify) yy;\n-      if (!_failures) {\n-        yy.cr();\n-        yy.print_cr(\"----------\");\n-      }\n-      if (!_g1h->is_in(obj)) {\n-        HeapRegion* from = _g1h->heap_region_containing(p);\n-        yy.print_cr(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-        print_object(&yy, _containing_obj);\n-        yy.print_cr(\"points to obj \" PTR_FORMAT \" not in the heap\",\n-                    p2i(obj));\n-      } else {\n-        HeapRegion* from = _g1h->heap_region_containing(p);\n-        HeapRegion* to   = _g1h->heap_region_containing(obj);\n-        yy.print_cr(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-        print_object(&yy, _containing_obj);\n-        yy.print_cr(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(obj), HR_FORMAT_PARAMS(to));\n-        print_object(&yy, obj);\n-      }\n-      yy.print_cr(\"----------\");\n-      yy.flush();\n-      _failures = true;\n-      failed = true;\n-    }\n-  }\n-}\n-\n-template void G1VerifyOopClosure::do_oop_work(oop*);\n-template void G1VerifyOopClosure::do_oop_work(narrowOop*);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -89,24 +89,0 @@\n-class G1VerifyOopClosure: public BasicOopIterateClosure {\n-private:\n-  G1CollectedHeap* _g1h;\n-  bool             _failures;\n-  oop              _containing_obj;\n-  VerifyOption     _verify_option;\n-\n-public:\n-  int _cc;\n-  G1VerifyOopClosure(VerifyOption option);\n-\n-  void set_containing_obj(oop obj) {\n-    _containing_obj = obj;\n-  }\n-\n-  bool failures() { return _failures; }\n-  void print_object(outputStream* out, oop obj);\n-\n-  template <class T> void do_oop_work(T* p);\n-\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -61,0 +61,13 @@\n+\n+G1VerificationClosure::G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo) :\n+  _g1h(g1h), _containing_obj(nullptr), _num_failures(0), _vo(vo) { }\n+\n+void G1VerificationClosure::print_object(outputStream* out, oop obj) {\n+#ifdef PRODUCT\n+  Klass* k = obj->klass();\n+  const char* class_name = k->external_name();\n+  out->print_cr(\"class name %s\", class_name);\n+#else \/\/ PRODUCT\n+  obj->print_on(out);\n+#endif \/\/ PRODUCT\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -237,0 +237,32 @@\n+class G1VerificationClosure : public BasicOopIterateClosure {\n+protected:\n+  G1CollectedHeap* _g1h;\n+  oop _containing_obj;\n+  uint _num_failures;\n+  VerifyOption _vo;\n+\n+public:\n+  G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo);\n+\n+  void set_containing_obj(oop obj) {\n+    _containing_obj = obj;\n+  }\n+\n+  bool has_failures() { return _num_failures != 0; }\n+  uint num_failures() { return _num_failures; }\n+\n+  void print_object(outputStream* out, oop obj);\n+};\n+\n+class G1VerifyLiveClosure : public G1VerificationClosure {\n+\n+  template <class T>\n+  inline void do_oop_work(T* p);\n+\n+public:\n+  G1VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n+\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p) { do_oop_work(p); }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -36,0 +36,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -273,0 +275,43 @@\n+template <class T>\n+inline void G1VerifyLiveClosure::do_oop_work(T* p) {\n+  assert(_containing_obj != nullptr, \"Precondition\");\n+  assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n+\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (CompressedOops::is_null(heap_oop)) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+\n+  Log(gc, verify) log;\n+  LogStream ls(log.error());\n+\n+  oop obj = CompressedOops::decode_raw_not_null(heap_oop);\n+  bool is_in_heap = _g1h->is_in(obj);\n+\n+  if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n+    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+\n+    if (!has_failures()) {\n+      log.error(\"----------\");\n+    }\n+\n+    HeapRegion* from = _g1h->heap_region_containing(p);\n+    log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n+              p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n+    print_object(&ls, _containing_obj);\n+\n+    if (!is_in_heap) {\n+      log.error(\"points to address \" PTR_FORMAT \" outside of heap\", p2i(obj));\n+    } else {\n+      HeapRegion* to = _g1h->heap_region_containing(obj);\n+      log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n+                p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n+      print_object(&ls, obj);\n+    }\n+    log.error(\"----------\");\n+    _num_failures++;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  develop(intx, G1MaxVerifyFailures, -1,                                    \\\n+  develop(uint, G1MaxVerifyFailures, 0,                                     \\\n@@ -226,2 +226,2 @@\n-          \"-1 means print all.\")                                            \\\n-          range(-1, max_jint)                                               \\\n+          \"0 means print all.\")                                             \\\n+          range(0, max_jint)                                                \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -462,3 +462,1 @@\n-class G1VerificationClosure : public BasicOopIterateClosure {\n-protected:\n-  G1CollectedHeap* _g1h;\n+class VerifyRemSetClosure : public G1VerificationClosure {\n@@ -466,31 +464,0 @@\n-  oop _containing_obj;\n-  bool _failures;\n-  int _n_failures;\n-  VerifyOption _vo;\n-\n-public:\n-\n-  G1VerificationClosure(G1CollectedHeap* g1h, VerifyOption vo) :\n-    _g1h(g1h), _ct(g1h->card_table()),\n-    _containing_obj(NULL), _failures(false), _n_failures(0), _vo(vo) {\n-  }\n-\n-  void set_containing_obj(oop obj) {\n-    _containing_obj = obj;\n-  }\n-\n-  bool failures() { return _failures; }\n-  int n_failures() { return _n_failures; }\n-\n-  void print_object(outputStream* out, oop obj) {\n-#ifdef PRODUCT\n-    Klass* k = obj->klass();\n-    const char* class_name = k->external_name();\n-    out->print_cr(\"class name %s\", class_name);\n-#else \/\/ PRODUCT\n-    obj->print_on(out);\n-#endif \/\/ PRODUCT\n-  }\n-};\n-\n-class VerifyLiveClosure : public G1VerificationClosure {\n@@ -500,3 +467,2 @@\n-    assert(_containing_obj != NULL, \"Precondition\");\n-    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo),\n-      \"Precondition\");\n+    assert(_containing_obj != nullptr, \"Precondition\");\n+    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo), \"Precondition\");\n@@ -510,3 +476,0 @@\n-    bool is_in_heap = _g1h->is_in(obj);\n-    if (!is_in_heap || _g1h->is_obj_dead_cond(obj, _vo)) {\n-      MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n@@ -514,5 +477,6 @@\n-      Log(gc, verify) log;\n-      if (!_failures) {\n-        log.error(\"----------\");\n-      }\n-      ResourceMark rm;\n+    HeapRegion* from = _g1h->heap_region_containing_or_null(p);\n+    HeapRegion* to = _g1h->heap_region_containing_or_null(obj);\n+    if (from != nullptr && to != nullptr &&\n+        from != to &&\n+        !to->is_pinned() &&\n+        to->rem_set()->is_complete()) {\n@@ -520,5 +484,3 @@\n-      HeapRegion* from = _g1h->heap_region_containing(p);\n-      log.error(\"Field \" PTR_FORMAT \" of live obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-      LogStream ls(log.error());\n-      print_object(&ls, _containing_obj);\n+      jbyte cv_obj = *_ct->byte_for_const(_containing_obj);\n+      jbyte cv_field = *_ct->byte_for_const(p);\n+      const jbyte dirty = G1CardTable::dirty_card_val();\n@@ -526,5 +488,21 @@\n-      if (!is_in_heap) {\n-        log.error(\"points to address \" PTR_FORMAT \" outside of heap\", p2i(obj));\n-      } else {\n-        HeapRegion* to = _g1h->heap_region_containing(obj);\n-        log.error(\"points to dead obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n+      bool is_bad = !(from->is_young() ||\n+                      to->rem_set()->contains_reference(p) ||\n+                      (_containing_obj->is_objArray() ?\n+                       cv_field == dirty :\n+                       cv_obj == dirty || cv_field == dirty));\n+\n+      if (is_bad) {\n+        ResourceMark rm;\n+        Log(gc, verify) log;\n+        LogStream ls(log.error());\n+\n+        MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+\n+        if (!has_failures()) {\n+          log.error(\"----------\");\n+        }\n+        log.error(\"Missing rem set entry:\");\n+        log.error(\"Field \" PTR_FORMAT \" of obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n+                  p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n+        _containing_obj->print_on(&ls);\n+        log.error(\"points to obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n@@ -532,1 +510,6 @@\n-        print_object(&ls, obj);\n+        if (oopDesc::is_oop(obj)) {\n+          obj->print_on(&ls);\n+        }\n+        log.error(\"Obj head CTE = %d, field CTE = %d.\", cv_obj, cv_field);\n+        log.error(\"----------\");\n+        _num_failures++;\n@@ -534,3 +517,0 @@\n-      log.error(\"----------\");\n-      _failures = true;\n-      _n_failures++;\n@@ -541,1 +521,1 @@\n-  VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n+  VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo), _ct(g1h->card_table()) {}\n@@ -547,62 +527,0 @@\n-class VerifyRemSetClosure : public G1VerificationClosure {\n-public:\n-  VerifyRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) : G1VerificationClosure(g1h, vo) {}\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-\n-  template <class T>\n-  void do_oop_work(T* p) {\n-    assert(_containing_obj != NULL, \"Precondition\");\n-    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo),\n-      \"Precondition\");\n-    verify_remembered_set(p);\n-  }\n-\n-  template <class T>\n-  void verify_remembered_set(T* p) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    Log(gc, verify) log;\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop obj = CompressedOops::decode_not_null(heap_oop);\n-      HeapRegion* from = _g1h->heap_region_containing(p);\n-      HeapRegion* to = _g1h->heap_region_containing(obj);\n-      if (from != NULL && to != NULL &&\n-        from != to &&\n-        !to->is_pinned() &&\n-        to->rem_set()->is_complete()) {\n-        jbyte cv_obj = *_ct->byte_for_const(_containing_obj);\n-        jbyte cv_field = *_ct->byte_for_const(p);\n-        const jbyte dirty = G1CardTable::dirty_card_val();\n-\n-        bool is_bad = !(from->is_young()\n-          || to->rem_set()->contains_reference(p)\n-          || (_containing_obj->is_objArray() ?\n-                cv_field == dirty :\n-                cv_obj == dirty || cv_field == dirty));\n-        if (is_bad) {\n-          MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n-\n-          if (!_failures) {\n-            log.error(\"----------\");\n-          }\n-          log.error(\"Missing rem set entry:\");\n-          log.error(\"Field \" PTR_FORMAT \" of obj \" PTR_FORMAT \" in region \" HR_FORMAT,\n-                    p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));\n-          ResourceMark rm;\n-          LogStream ls(log.error());\n-          _containing_obj->print_on(&ls);\n-          log.error(\"points to obj \" PTR_FORMAT \" in region \" HR_FORMAT \" remset %s\",\n-                    p2i(obj), HR_FORMAT_PARAMS(to), to->rem_set()->get_state_str());\n-          if (oopDesc::is_oop(obj)) {\n-            obj->print_on(&ls);\n-          }\n-          log.error(\"Obj head CTE = %d, field CTE = %d.\", cv_obj, cv_field);\n-          log.error(\"----------\");\n-          _failures = true;\n-          _n_failures++;\n-        }\n-      }\n-    }\n-  }\n-};\n-\n@@ -630,1 +548,1 @@\n-  VerifyLiveClosure vl_cl(g1h, vo);\n+  G1VerifyLiveClosure vl_cl(g1h, vo);\n@@ -663,1 +581,1 @@\n-            if (vr_cl.failures()) {\n+            if (vr_cl.has_failures()) {\n@@ -666,2 +584,2 @@\n-            if (G1MaxVerifyFailures >= 0 &&\n-              vr_cl.n_failures() >= G1MaxVerifyFailures) {\n+            if (G1MaxVerifyFailures > 0 &&\n+              vr_cl.num_failures() >= G1MaxVerifyFailures) {\n@@ -674,1 +592,1 @@\n-          if (vl_cl.failures()) {\n+          if (vl_cl.has_failures()) {\n@@ -677,2 +595,2 @@\n-          if (G1MaxVerifyFailures >= 0 &&\n-              vl_cl.n_failures() >= G1MaxVerifyFailures) {\n+          if (G1MaxVerifyFailures > 0 &&\n+            vl_cl.num_failures() >= G1MaxVerifyFailures) {\n@@ -731,1 +649,1 @@\n-        if (vr_cl.failures()) {\n+        if (vr_cl.has_failures()) {\n@@ -734,2 +652,2 @@\n-        if (G1MaxVerifyFailures >= 0 &&\n-          vr_cl.n_failures() >= G1MaxVerifyFailures) {\n+        if (G1MaxVerifyFailures > 0 &&\n+          vr_cl.num_failures() >= G1MaxVerifyFailures) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":50,"deletions":132,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-  void verify(VerifyOption vo, bool *failures) const;\n+  void verify(VerifyOption vo, bool* failures) const;\n@@ -589,1 +589,1 @@\n-  void verify_rem_set(VerifyOption vo, bool *failures) const;\n+  void verify_rem_set(VerifyOption vo, bool* failures) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}