{"files":[{"patch":"@@ -110,14 +110,1 @@\n-    \/\/ The rationale for selecting the roots to scan is as follows:\n-    \/\/   a. With unload_classes = true, we only want to scan the actual strong roots from the\n-    \/\/      code cache. This will allow us to identify the dead classes, unload them, *and*\n-    \/\/      invalidate the relevant code cache blobs. This could be only done together with\n-    \/\/      class unloading.\n-    \/\/   b. With unload_classes = false, we have to nominally retain all the references from code\n-    \/\/      cache, because there could be the case of embedded class\/oop in the generated code,\n-    \/\/      which we will never visit during mark. Without code cache invalidation, as in (a),\n-    \/\/      we risk executing that code cache blob, and crashing.\n-    if (heap->unload_classes()) {\n-      _rp->strong_roots_do(worker_id, oops);\n-    } else {\n-      _rp->roots_do(worker_id, oops);\n-    }\n+    _rp->roots_do(worker_id, oops);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n@@ -173,1 +172,1 @@\n-  roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n+  roots_do(worker_id, oops, &blobs_cl);\n@@ -176,16 +175,2 @@\n-void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops) {\n-  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n-  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);\n-  strong_roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n-}\n-\n-void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure *tc) {\n-  assert(!ShenandoahSafepoint::is_at_shenandoah_safepoint() ||\n-         !ShenandoahHeap::heap()->unload_classes(),\n-          \"Expect class unloading when Shenandoah cycle is running\");\n-  assert(clds != NULL, \"Only possible with CLD closure\");\n-\n-  ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);\n-  ResourceMark rm;\n-  _thread_roots.threads_do(&tc_cl, worker_id);\n-}\n+void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops, CodeBlobClosure* code, ThreadClosure *tc) {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at a safepoint\");\n@@ -193,2 +178,0 @@\n-void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc) {\n-  assert(ShenandoahHeap::heap()->unload_classes(), \"Should be used during class unloading\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -200,7 +200,0 @@\n-  \/\/ Apply oops, clds and blobs to all strongly reachable roots in the system,\n-  \/\/ during class unloading cycle\n-  void strong_roots_do(uint worker_id, OopClosure* cl);\n-  void strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);\n-\n-  \/\/ Apply oops, clds and blobs to all strongly reachable roots and weakly reachable\n-  \/\/ roots when class unloading is disabled during this cycle\n@@ -208,1 +201,3 @@\n-  void roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);\n+\n+private:\n+  void roots_do(uint worker_id, OopClosure* oops, CodeBlobClosure* code, ThreadClosure* tc = NULL);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"}]}