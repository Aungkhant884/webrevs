{"files":[{"patch":"@@ -110,14 +110,1 @@\n-    \/\/ The rationale for selecting the roots to scan is as follows:\n-    \/\/   a. With unload_classes = true, we only want to scan the actual strong roots from the\n-    \/\/      code cache. This will allow us to identify the dead classes, unload them, *and*\n-    \/\/      invalidate the relevant code cache blobs. This could be only done together with\n-    \/\/      class unloading.\n-    \/\/   b. With unload_classes = false, we have to nominally retain all the references from code\n-    \/\/      cache, because there could be the case of embedded class\/oop in the generated code,\n-    \/\/      which we will never visit during mark. Without code cache invalidation, as in (a),\n-    \/\/      we risk executing that code cache blob, and crashing.\n-    if (heap->unload_classes()) {\n-      _rp->strong_roots_do(worker_id, oops);\n-    } else {\n-      _rp->roots_do(worker_id, oops);\n-    }\n+    _rp->roots_do(worker_id, oops);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -192,1 +192,0 @@\n-  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n@@ -194,7 +193,1 @@\n-  roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n-}\n-\n-void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops) {\n-  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n-  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);\n-  strong_roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n+  roots_do(worker_id, oops, NULL, &blobs_cl);\n@@ -204,18 +197,1 @@\n-  assert(!ShenandoahSafepoint::is_at_shenandoah_safepoint() ||\n-         !ShenandoahHeap::heap()->unload_classes(),\n-          \"Expect class unloading when Shenandoah cycle is running\");\n-  assert(clds != NULL, \"Only possible with CLD closure\");\n-\n-  ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);\n-\n-  ResourceMark rm;\n-\n-  \/\/ Process serial-claiming roots first\n-  _serial_roots.oops_do(oops, worker_id);\n-\n-  \/\/ Process heavy-weight\/fully parallel roots the last\n-  _thread_roots.threads_do(&tc_cl, worker_id);\n-}\n-\n-void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc) {\n-  assert(ShenandoahHeap::heap()->unload_classes(), \"Should be used during class unloading\");\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at a safepoint\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -209,7 +209,0 @@\n-  \/\/ Apply oops, clds and blobs to all strongly reachable roots in the system,\n-  \/\/ during class unloading cycle\n-  void strong_roots_do(uint worker_id, OopClosure* cl);\n-  void strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc = NULL);\n-\n-  \/\/ Apply oops, clds and blobs to all strongly reachable roots and weakly reachable\n-  \/\/ roots when class unloading is disabled during this cycle\n@@ -217,0 +210,2 @@\n+\n+private:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}