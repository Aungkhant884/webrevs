{"files":[{"patch":"@@ -81,1 +81,1 @@\n-     * CGLLayer.\n+     * layer (CGLLayer\/MTLLayer).\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static sun.java2d.pipe.BufferedOpCodes.INVALIDATE_CONTEXT;\n@@ -82,26 +81,0 @@\n-    \/**\n-     * Invalidates the currentContext field to ensure that we properly\n-     * revalidate the MTLContext (make it current, etc.) next time through\n-     * the validate() method.  This is typically invoked from methods\n-     * that affect the current context state (e.g. disposing a context or\n-     * surface).\n-     *\/\n-    public static void invalidateCurrentContext() {\n-        \/\/ assert MTLRenderQueue.getInstance().lock.isHeldByCurrentThread();\n-\n-        \/\/ invalidate the current Java-level context so that we\n-        \/\/ revalidate everything the next time around\n-        if (currentContext != null) {\n-            currentContext.invalidateContext();\n-            currentContext = null;\n-        }\n-\n-        \/\/ invalidate the context reference at the native level, and\n-        \/\/ then flush the queue so that we have no pending operations\n-        \/\/ dependent on the current context\n-        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n-        rq.ensureCapacity(4);\n-        rq.getBuffer().putInt(INVALIDATE_CONTEXT);\n-        rq.flushNow();\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLContext.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -148,4 +148,0 @@\n-            \/\/ getMTLConfigInfo() creates and destroys temporary\n-            \/\/ surfaces\/contexts, so we should first invalidate the current\n-            \/\/ Java-level context and flush the queue...\n-            MTLContext.invalidateCurrentContext();\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import \"MTLSurfaceData.h\"\n@@ -33,3 +32,0 @@\n-#pragma mark -\n-#pragma mark \"--- Mac OS X specific methods for Metal pipeline ---\"\n-\n@@ -61,4 +57,0 @@\n-#pragma mark -\n-#pragma mark \"--- MTLGraphicsConfig methods ---\"\n-\n-\n@@ -85,6 +77,5 @@\n-    jboolean ret = JNI_FALSE;\n-    JNI_COCOA_ENTER(env);\n-    NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];\n-    [retArray addObject: [NSNumber numberWithInt: (int)displayID]];\n-    char *str = JNU_GetStringPlatformChars(env, shadersLibName, 0);\n-    [retArray addObject: [NSString stringWithUTF8String: str]];\n+    __block jboolean ret = JNI_FALSE;\n+\n+JNI_COCOA_ENTER(env);\n+\n+    __block NSString* path = NormalizedPathNSStringFromJavaString(env, shadersLibName);\n@@ -93,1 +84,13 @@\n-        [MTLGraphicsConfigUtil _tryLoadMetalLibrary: retArray];\n+\n+        id<MTLDevice> device = CGDirectDisplayCopyCurrentMetalDevice(displayID);\n+        if (device != nil) {\n+            NSError* error = nil;\n+            id<MTLLibrary> lib = [device newLibraryWithFile:path error:&error];\n+            if (lib != nil) {\n+                ret = JNI_TRUE;\n+            } else {\n+                J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to load Metal shader library.\");\n+            }\n+        } else {\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to create MTLDevice.\");\n+        }\n@@ -96,4 +99,1 @@\n-    NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];\n-    ret = (jboolean)[num boolValue];\n-    JNU_ReleaseStringPlatformChars(env, shadersLibName, str);\n-    JNI_COCOA_EXIT(env);\n+JNI_COCOA_EXIT(env);\n@@ -103,1 +103,0 @@\n-\n@@ -105,8 +104,6 @@\n- * Determines whether the MTL pipeline can be used for a given GraphicsConfig\n- * provided its screen number and visual ID.  If the minimum requirements are\n- * met, the native MTLGraphicsConfigInfo structure is initialized for this\n- * GraphicsConfig with the necessary information (pixel format, etc.)\n- * and a pointer to this structure is returned as a jlong.  If\n- * initialization fails at any point, zero is returned, indicating that MTL\n- * cannot be used for this GraphicsConfig (we should fallback on an existing\n- * 2D pipeline).\n+ * Determines whether the Metal pipeline can be used for a given screen number and\n+ * shader library path. A MTLContext is created and the native MTLGraphicsConfigInfo\n+ * structure is initialized for this context. A pointer to this structure is\n+ * returned as a jlong.\n+ * If initialization fails at any point, zero is returned, indicating that Metal pipeline\n+ * cannot be used for this GraphicsConfig (we should fallback on an existing 2D pipeline).\n@@ -118,31 +115,2 @@\n-    jlong ret = 0L;\n-    JNI_COCOA_ENTER(env);\n-    NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];\n-    [retArray addObject: [NSNumber numberWithInt: (int)displayID]];\n-    char *str = JNU_GetStringPlatformChars(env, mtlShadersLib, 0);\n-    [retArray addObject: [NSString stringWithUTF8String: str]];\n-\n-    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n-        [MTLGraphicsConfigUtil _getMTLConfigInfo: retArray];\n-    }];\n-\n-    NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];\n-    ret = (jlong)[num longValue];\n-    JNU_ReleaseStringPlatformChars(env, mtlShadersLib, str);\n-    JNI_COCOA_EXIT(env);\n-    return ret;\n-}\n-\n-\n-\n-\n-@implementation MTLGraphicsConfigUtil\n-+ (void) _getMTLConfigInfo: (NSMutableArray *)argValue {\n-    AWT_ASSERT_APPKIT_THREAD;\n-\n-    jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];\n-    NSString *mtlShadersLib = (NSString *)[argValue objectAtIndex: 1];\n-    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n-    [argValue removeAllObjects];\n-\n-    J2dRlsTraceLn(J2D_TRACE_INFO, \"MTLGraphicsConfig_getMTLConfigInfo\");\n+    __block MTLContext* mtlc = nil;\n+    __block MTLGraphicsConfigInfo* mtlinfo = nil;\n@@ -150,1 +118,1 @@\n-    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];\n+JNI_COCOA_ENTER(env);\n@@ -152,0 +120,1 @@\n+    __block NSString* path = NormalizedPathNSStringFromJavaString(env, mtlShadersLib);\n@@ -153,47 +122,1 @@\n-    NSRect contentRect = NSMakeRect(0, 0, 64, 64);\n-    NSWindow *window =\n-        [[NSWindow alloc]\n-            initWithContentRect: contentRect\n-            styleMask: NSBorderlessWindowMask\n-            backing: NSBackingStoreBuffered\n-            defer: false];\n-    if (window == nil) {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: NSWindow is NULL\");\n-        [argValue addObject: [NSNumber numberWithLong: 0L]];\n-        return;\n-    }\n-\n-    MTLContext *mtlc = [[MTLContext alloc] initWithDevice:CGDirectDisplayCopyCurrentMetalDevice(displayID)\n-                        shadersLib:mtlShadersLib];\n-    if (mtlc == 0L) {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGC_InitMTLContext: could not initialze MTLContext.\");\n-        [argValue addObject: [NSNumber numberWithLong: 0L]];\n-        return;\n-    }\n-\n-\n-    \/\/ create the MTLGraphicsConfigInfo record for this config\n-    MTLGraphicsConfigInfo *mtlinfo = (MTLGraphicsConfigInfo *)malloc(sizeof(MTLGraphicsConfigInfo));\n-    if (mtlinfo == NULL) {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not allocate memory for mtlinfo\");\n-        free(mtlc);\n-        [argValue addObject: [NSNumber numberWithLong: 0L]];\n-        return;\n-    }\n-    memset(mtlinfo, 0, sizeof(MTLGraphicsConfigInfo));\n-    mtlinfo->context = mtlc;\n-\n-    [argValue addObject: [NSNumber numberWithLong:ptr_to_jlong(mtlinfo)]];\n-    [pool drain];\n-}\n-\n-+ (void) _tryLoadMetalLibrary: (NSMutableArray *)argValue {\n-    AWT_ASSERT_APPKIT_THREAD;\n-\n-    jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];\n-    NSString *mtlShadersLib = (NSString *)[argValue objectAtIndex: 1];\n-    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n-    [argValue removeAllObjects];\n-\n-    J2dRlsTraceLn(J2D_TRACE_INFO, \"MTLGraphicsConfigUtil_tryLoadMTLLibrary\");\n-\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n@@ -201,7 +124,13 @@\n-    BOOL ret = FALSE;;\n-    id<MTLDevice> device = CGDirectDisplayCopyCurrentMetalDevice(displayID);\n-    if (device != nil) {\n-        NSError *error = nil;\n-        id<MTLLibrary> lib = [device newLibraryWithFile:mtlShadersLib error:&error];\n-        if (lib != nil) {\n-            ret = TRUE;\n+        mtlc = [[MTLContext alloc] initWithDevice:CGDirectDisplayCopyCurrentMetalDevice(displayID)\n+                                       shadersLib:path];\n+        if (mtlc != 0L) {\n+            \/\/ create the MTLGraphicsConfigInfo record for this context\n+            mtlinfo = (MTLGraphicsConfigInfo *)malloc(sizeof(MTLGraphicsConfigInfo));\n+            if (mtlinfo != NULL) {\n+                memset(mtlinfo, 0, sizeof(MTLGraphicsConfigInfo));\n+                mtlinfo->context = mtlc;\n+            } else {\n+                J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not allocate memory for mtlinfo\");\n+                [mtlc release];\n+                mtlc = nil;\n+            }\n@@ -209,1 +138,1 @@\n-            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to load Metal shader library.\");\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not initialze MTLContext.\");\n@@ -211,3 +140,1 @@\n-    } else {\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_tryLoadMetalLibrary - Failed to create MTLDevice.\");\n-    }\n+    }];\n@@ -215,1 +142,1 @@\n-    [argValue addObject: [NSNumber numberWithBool: ret]];\n+JNI_COCOA_EXIT(env);\n@@ -217,0 +144,1 @@\n+    return ptr_to_jlong(mtlinfo);\n@@ -219,3 +147,0 @@\n-@end \/\/GraphicsConfigUtil\n-\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":47,"deletions":122,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -670,10 +670,0 @@\n-                case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:\n-                {\n-                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n-                    \/\/ invalidate the references to the current context and\n-                    \/\/ destination surface that are maintained at the native level\n-                    if (mtlc != NULL) {\n-                        commitEncodedCommands();\n-                        RESET_PREVIOUS_OP();\n-                        [mtlc reset];\n-                    }\n@@ -681,9 +671,0 @@\n-                    MTLTR_FreeGlyphCaches();\n-                    if (dstOps != NULL) {\n-                        MTLSD_Delete(env, dstOps);\n-                    }\n-\n-                    mtlc = NULL;\n-                    dstOps = NULL;\n-                    break;\n-                }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"}]}