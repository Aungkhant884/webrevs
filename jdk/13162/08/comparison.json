{"files":[{"patch":"@@ -1205,0 +1205,5 @@\n+  \/\/ Still nothing? If NMT is enabled, we can ask what it thinks...\n+  if (MemTracker::print_containing_region(addr, st)) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  static const uint16_t _header_canary_life_mark = 0xE99E;\n+  static const uint16_t _header_canary_live_mark = 0xE99E;\n@@ -101,1 +101,1 @@\n-  static const uint16_t _footer_canary_life_mark = 0xE88E;\n+  static const uint16_t _footer_canary_live_mark = 0xE88E;\n@@ -103,1 +103,1 @@\n-  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_live_mark = 0xE99EE99E;)\n@@ -142,0 +142,7 @@\n+\n+  bool is_dead() const { return _canary == _header_canary_dead_mark; }\n+  bool is_live() const { return _canary == _header_canary_live_mark; }\n+\n+  \/\/ Used for debugging purposes only. Check header if it could constitute a valid (live or dead) header.\n+  inline bool looks_valid() const;\n+\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    _unused(0), _canary(_header_canary_life_mark)\n+    _unused(0), _canary(_header_canary_live_mark)\n@@ -44,2 +44,2 @@\n-  NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n-  set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n+  NOT_LP64(_alt_canary = _header_alt_canary_live_mark;)\n+  set_footer(_footer_canary_live_mark); \/\/ set after initializing _size\n@@ -52,3 +52,3 @@\n-  _canary = _header_canary_life_mark;\n-  NOT_LP64(_alt_canary = _header_alt_canary_life_mark);\n-  set_footer(_footer_canary_life_mark);\n+  _canary = _header_canary_live_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_live_mark);\n+  set_footer(_footer_canary_live_mark);\n@@ -119,0 +119,10 @@\n+\n+\/\/ Used for debugging purposes only. Check header if it could constitute a valid (live or dead) header.\n+inline bool MallocHeader::looks_valid() const {\n+  \/\/ Note: we define these restrictions loose enough to also catch moderately corrupted blocks.\n+  \/\/ E.g. we don't check footer canary.\n+  return ( (_canary == _header_canary_live_mark NOT_LP64(&& _alt_canary == _header_alt_canary_live_mark)) ||\n+           (_canary == _header_canary_dead_mark NOT_LP64(&& _alt_canary == _header_alt_canary_dead_mark)) ) &&\n+           _size > 0 && _size < max_reasonable_malloc_size;\n+}\n+\n@@ -124,1 +134,1 @@\n-  if (_canary != _header_canary_life_mark) {\n+  if (_canary != _header_canary_live_mark) {\n@@ -132,1 +142,1 @@\n-  if (_alt_canary != _header_alt_canary_life_mark) {\n+  if (_alt_canary != _header_alt_canary_live_mark) {\n@@ -147,1 +157,1 @@\n-  if (get_footer() != _footer_canary_life_mark) {\n+  if (get_footer() != _footer_canary_live_mark) {\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4,0 +4,2 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ *\n@@ -193,2 +195,2 @@\n-\/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n-\/\/ print the block. Note that since there is very low risk of memory looking\n+\/\/ Given a pointer, look for the containing malloc block.\n+\/\/ Print the block. Note that since there is very low risk of memory looking\n@@ -199,15 +201,45 @@\n-  assert(MemTracker::enabled(), \"NMT must be enabled\");\n-  if (os::is_readable_pointer(p)) {\n-    const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n-    const MallocHeader* mhdr = malloc_header(p);\n-    char msg[256];\n-    address p_corrupted;\n-    if (os::is_readable_pointer(mhdr) &&\n-        mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n-      st->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n-          p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n-      if (tracking_level == NMT_detail) {\n-        NativeCallStack ncs;\n-        if (mhdr->get_stack(ncs)) {\n-          ncs.print_on(st);\n-          st->cr();\n+  assert(MemTracker::enabled(), \"NMT not enabled\");\n+\n+  address addr = (address)p;\n+\n+  \/\/ Carefully feel your way upwards and try to find a malloc header. Then check if\n+  \/\/ we are within the block.\n+  \/\/ We give preference to found live blocks; but if no live block had been found,\n+  \/\/ but the pointer points into remnants of a dead block, print that instead.\n+  const MallocHeader* likely_dead_block = nullptr;\n+  const MallocHeader* likely_live_block = nullptr;\n+  {\n+    const size_t smallest_possible_alignment = sizeof(void*);\n+    const uint8_t* here = align_down(addr, smallest_possible_alignment);\n+    const uint8_t* const end = here - (0x1000 + sizeof(MallocHeader)); \/\/ stop searching after 4k\n+    for (; here >= end; here -= smallest_possible_alignment) {\n+      if (!os::is_readable_pointer(here)) {\n+        \/\/ Probably OOB, give up\n+        return false;\n+      }\n+      const MallocHeader* const candidate = (const MallocHeader*)here;\n+      if (!candidate->looks_valid()) {\n+        \/\/ This is definitely not a header, go on to the next candidate.\n+        continue;\n+      }\n+\n+      \/\/ fudge factor:\n+      \/\/ We don't report blocks for which p is clearly outside of. That would cause us to return true and possibly prevent\n+      \/\/ subsequent tests of p, see os::print_location(). But if p is just outside of the found block, this may be a\n+      \/\/ narrow oob error and we'd like to know that.\n+      const int fudge = 8;\n+      const address start_block = (address)candidate;\n+      const address start_payload = (address)(candidate + 1);\n+      const address end_payload = start_payload + candidate->size();\n+      const address end_payload_plus_fudge = end_payload + fudge;\n+      if (addr >= start_block && addr < end_payload_plus_fudge) {\n+        \/\/ We found a block the pointer is pointing into, or almost into.\n+        \/\/ If its a live block, we have our info. If its a dead block, we still\n+        \/\/ may be within the borders of a larger live block we have not found yet -\n+        \/\/ continue search.\n+        if (candidate->is_live()) {\n+          likely_live_block = candidate;\n+          break;\n+        } else {\n+          likely_dead_block = candidate;\n+          continue;\n@@ -216,1 +248,0 @@\n-      return true;\n@@ -219,0 +250,29 @@\n+\n+  \/\/ If we've found a reasonable candidate. Print the info.\n+  const MallocHeader* block = likely_live_block != nullptr ? likely_live_block : likely_dead_block;\n+  if (block != nullptr) {\n+    const char* where = nullptr;\n+    const address start_block = (address)block;\n+    const address start_payload = (address)(block + 1);\n+    const address end_payload = start_payload + block->size();\n+    if (addr < start_payload) {\n+      where = \"into header of\";\n+    } else if (addr < end_payload) {\n+      where = \"into\";\n+    } else {\n+      where = \"just outside of\";\n+    }\n+    st->print_cr(PTR_FORMAT \" %s %s malloced block starting at \" PTR_FORMAT \", size \" SIZE_FORMAT \", tag %s\",\n+                 p2i(p), where,\n+                 (block->is_dead() ? \"dead\" : \"live\"),\n+                 p2i(block + 1), \/\/ lets print the payload start, not the header\n+                 block->size(), NMTUtil::flag_to_enum_name(block->flags()));\n+    if (MemTracker::tracking_level() == NMT_detail) {\n+      NativeCallStack ncs;\n+      if (block->get_stack(ncs)) {\n+        ncs.print_on(st);\n+        st->cr();\n+      }\n+    }\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":78,"deletions":18,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -311,2 +311,2 @@\n-  \/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n-  \/\/ print the block. Note that since there is very low risk of memory looking\n+  \/\/ Given a pointer, look for the containing malloc block.\n+  \/\/ Print the block. Note that since there is very low risk of memory looking\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,8 @@\n+\/\/ Given an unknown pointer, check if it points into a known region; print region if found\n+\/\/ and return true; false if not found.\n+bool MemTracker::print_containing_region(const void* p, outputStream* out) {\n+  return enabled() &&\n+      (MallocTracker::print_pointer_information(p, out) ||\n+       VirtualMemoryTracker::print_containing_region(p, out));\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -237,0 +237,4 @@\n+  \/\/ Given an unknown pointer, check if it points into a known region; print region if found\n+  \/\/ and return true; false if not found.\n+  static bool print_containing_region(const void* p, outputStream* out);\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,2 +682,2 @@\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n-        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::flag_to_enum_name(rgn->flag()));\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,9 +396,2 @@\n-    if (MemTracker::enabled()) {\n-      \/\/ Does it point into a known mmapped region?\n-      if (VirtualMemoryTracker::print_containing_region(p, tty)) {\n-        return;\n-      }\n-      \/\/ Does it look like the start of a malloced block?\n-      if (MallocTracker::print_pointer_information(p, tty)) {\n-        return;\n-      }\n+    if (MemTracker::print_containing_region(p, tty)) {\n+      return;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocHeader.inline.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Uncomment to get test output\n+\/\/#define LOG_PLEASE\n+#include \"testutils.hpp\"\n+\n+using ::testing::HasSubstr;\n+\n+static void test_pointer(const void* p, bool expected_return_code, const char* expected_message) {\n+  stringStream ss;\n+  const bool b = MemTracker::print_containing_region(p, &ss);\n+  LOG_HERE(\"MemTracker::print_containing_region(\" PTR_FORMAT \") yielded: %d \\\"%s\\\"\", p2i(p), b, ss.base());\n+  EXPECT_EQ(b, expected_return_code);\n+  if (b) {\n+    EXPECT_THAT(ss.base(), HasSubstr(expected_message));\n+  }\n+}\n+\n+static void test_for_live_c_heap_block(size_t sz, ssize_t offset) {\n+  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n+  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), offset);\n+  memset(c, 0, sz);\n+  if (MemTracker::enabled()) {\n+    const char* expected_string = \"into live malloced block\";\n+    if (offset < 0) {\n+      expected_string = \"into header of live malloced block\";\n+    } else if ((size_t)offset >= sz) {\n+      expected_string = \"just outside of live malloced block\";\n+    }\n+    test_pointer(c + offset, true, expected_string);\n+  } else {\n+    \/\/ NMT disabled: we should see nothing.\n+    test_pointer(c + offset, false, \"\");\n+  }\n+  FREE_C_HEAP_ARRAY(char, c);\n+}\n+\n+static void test_for_dead_c_heap_block(size_t sz, ssize_t offset) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n+  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), offset);\n+  memset(c, 0, sz);\n+  \/\/ We cannot just free the allocation to try dead block printing, since the memory\n+  \/\/ may be immediately reused by concurrent code. Instead, we mark the block as dead\n+  \/\/ manually, and revert that before freeing it.\n+  MallocHeader* const hdr = MallocHeader::resolve_checked(c);\n+  hdr->mark_block_as_dead();\n+\n+  const char* expected_string = \"into dead malloced block\";\n+  if (offset < 0) {\n+    expected_string = \"into header of dead malloced block\";\n+  } else if ((size_t)offset >= sz) {\n+    expected_string = \"just outside of dead malloced block\";\n+  }\n+\n+  test_pointer(c + offset, true, expected_string);\n+\n+  hdr->revive();\n+  FREE_C_HEAP_ARRAY(char, c);\n+}\n+\n+TEST_VM(NMT, location_printing_cheap_live_1) { test_for_live_c_heap_block(2 * K, 0); }              \/\/ start of payload\n+TEST_VM(NMT, location_printing_cheap_live_2) { test_for_live_c_heap_block(2 * K, -7); }             \/\/ into header\n+TEST_VM(NMT, location_printing_cheap_live_3) { test_for_live_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n+TEST_VM(NMT, location_printing_cheap_live_4) { test_for_live_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n+TEST_VM(NMT, location_printing_cheap_live_5) { test_for_live_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n+TEST_VM(NMT, location_printing_cheap_live_6) { test_for_live_c_heap_block(4, 0); }                  \/\/ into a very small block\n+TEST_VM(NMT, location_printing_cheap_live_7) { test_for_live_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n+\n+#ifdef LINUX\n+TEST_VM(NMT, location_printing_cheap_dead_1) { test_for_dead_c_heap_block(2 * K, 0); }              \/\/ start of payload\n+TEST_VM(NMT, location_printing_cheap_dead_2) { test_for_dead_c_heap_block(2 * K, -7); }             \/\/ into header\n+TEST_VM(NMT, location_printing_cheap_dead_3) { test_for_dead_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n+TEST_VM(NMT, location_printing_cheap_dead_4) { test_for_dead_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n+TEST_VM(NMT, location_printing_cheap_dead_5) { test_for_dead_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n+TEST_VM(NMT, location_printing_cheap_dead_6) { test_for_dead_c_heap_block(4, 0); }                  \/\/ into a very small block\n+TEST_VM(NMT, location_printing_cheap_dead_7) { test_for_dead_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n+#endif\n+\n+static void test_for_mmap(size_t sz, ssize_t offset) {\n+  char* addr = os::reserve_memory(sz, false, mtTest);\n+  if (MemTracker::enabled()) {\n+    test_pointer(addr + offset, true, \"in mmap'd memory region\");\n+  } else {\n+    \/\/ NMT disabled: we should see nothing.\n+    test_pointer(addr + offset, false, \"\");\n+  }\n+  os::release_memory(addr, os::vm_page_size());\n+}\n+\n+TEST_VM(NMT, location_printing_mmap_1) { test_for_mmap(os::vm_page_size(), 0);  }\n+TEST_VM(NMT, location_printing_mmap_2) { test_for_mmap(os::vm_page_size(), os::vm_page_size() - 1);  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_locationprinting.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -33,2 +33,2 @@\n-#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n-\/\/#define LOG(...)\n+\/\/#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+#define LOG(...)\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#ifdef LOG_PLEASE\n@@ -66,0 +67,3 @@\n+#else\n+#define LOG_HERE(s, ...)\n+#endif\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}