{"files":[{"patch":"@@ -122,1 +122,1 @@\n-  \/\/ Note: we define these restrictions lose enough to also catch moderately corrupted blocks.\n+  \/\/ Note: we define these restrictions loose enough to also catch moderately corrupted blocks.\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,3 +199,2 @@\n-  if (!MemTracker::enabled()) {\n-    return false;\n-  }\n+  assert(MemTracker::enabled(), \"NMT not enabled\");\n+\n@@ -206,7 +205,17 @@\n-  const MallocHeader* candidate = (const MallocHeader*)(align_down(addr, 16));\n-  const MallocHeader* const last_candidate = candidate - 0x1001; \/\/ 4k (incl. header)\n-  while(candidate >= last_candidate) {\n-    if (!os::is_readable_pointer(candidate)) {\n-      break;\n-    }\n-    if (candidate->looks_valid()) {\n+  \/\/ We give preference to found life blocks; but if no life block had been found,\n+  \/\/ but the pointer points into remnants of a dead block, print that instead.\n+  const MallocHeader* likely_dead_block = nullptr;\n+  const MallocHeader* likely_life_block = nullptr;\n+  {\n+    const MallocHeader* candidate = (const MallocHeader*)(align_down(addr, 16));\n+    const MallocHeader* const end = candidate - 0x1001; \/\/ stop searching after 4k\n+    for (; candidate >= end; candidate--) {\n+      if (!os::is_readable_pointer(candidate)) {\n+        \/\/ Probably OOB, give up\n+        return false;\n+      }\n+      if (!candidate->looks_valid()) {\n+        \/\/ This is definitely not a header, go on to the next candidate.\n+        continue;\n+      }\n+\n@@ -214,1 +223,1 @@\n-      \/\/ We don't report blocks for which p is clearly out. That would cause us to return true and possibly prevent\n+      \/\/ We don't report blocks for which p is clearly outside of. That would cause us to return true and possibly prevent\n@@ -223,25 +232,4 @@\n-        const char* where = nullptr;\n-        if (addr < start_payload) {\n-          where = \"into header of\";\n-        } else if (addr < end_payload) {\n-          where = \"into\";\n-        } else {\n-          where = \"just outside of\";\n-        }\n-        st->print_cr(PTR_FORMAT \" %s %s malloced block starting at \" PTR_FORMAT \", size \" SIZE_FORMAT \", tag %s\",\n-                  p2i(p), where,\n-                  (candidate->is_dead() ? \"dead\" : \"live\"),\n-                  p2i(candidate + 1), \/\/ lets print the payload start, not the header\n-                  candidate->size(), NMTUtil::flag_to_enum_name(candidate->flags()));\n-        if (MemTracker::tracking_level() == NMT_detail) {\n-          NativeCallStack ncs;\n-          if (candidate->get_stack(ncs)) {\n-            ncs.print_on(st);\n-            st->cr();\n-          }\n-        }\n-        return true;\n-        break;\n-      } else {\n-        \/\/ Break if we found a live header but the pointer had not been nearby. If this was a dead header, it may be\n-        \/\/ a remnant from an older freed block, so continue searching.\n+        \/\/ We found a life block the pointer is pointing into or very nearby.\n+        \/\/ If its a life block, we have our info. If its a dead block, we still\n+        \/\/ may be within the borders of a larger life block we have not found yet -\n+        \/\/ continue search.\n@@ -249,1 +237,5 @@\n-          return false;\n+          likely_life_block = candidate;\n+          break;\n+        } else {\n+          likely_dead_block = candidate;\n+          continue;\n@@ -253,1 +245,29 @@\n-    candidate --;\n+  }\n+\n+  \/\/ If we've found a reasonable candidate. Print the info.\n+  const MallocHeader* block = likely_life_block != nullptr ? likely_life_block : likely_dead_block;\n+  if (block != nullptr) {\n+    const char* where = nullptr;\n+    const address start_block = (address)block;\n+    const address start_payload = (address)(block + 1);\n+    const address end_payload = start_payload + block->size();\n+    if (addr < start_payload) {\n+      where = \"into header of\";\n+    } else if (addr < end_payload) {\n+      where = \"into\";\n+    } else {\n+      where = \"just outside of\";\n+    }\n+    st->print_cr(PTR_FORMAT \" %s %s malloced block starting at \" PTR_FORMAT \", size \" SIZE_FORMAT \", tag %s\",\n+                 p2i(p), where,\n+                 (block->is_dead() ? \"dead\" : \"live\"),\n+                 p2i(block + 1), \/\/ lets print the payload start, not the header\n+                 block->size(), NMTUtil::flag_to_enum_name(block->flags()));\n+    if (MemTracker::tracking_level() == NMT_detail) {\n+      NativeCallStack ncs;\n+      if (block->get_stack(ncs)) {\n+        ncs.print_on(st);\n+        st->cr();\n+      }\n+    }\n+    return true;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":58,"deletions":38,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -31,0 +32,1 @@\n+\/\/ Uncomment to get test output\n@@ -46,1 +48,1 @@\n-static void test_for_c_heap(size_t sz, ssize_t offset) {\n+static void test_for_live_c_heap_block(size_t sz, ssize_t offset) {\n@@ -65,5 +67,41 @@\n-TEST_VM(NMT, location_printing_cheap_1) { test_for_c_heap(2 * K, 0); }              \/\/ start of payload\n-TEST_VM(NMT, location_printing_cheap_2) { test_for_c_heap(2 * K, -7); }             \/\/ into header\n-TEST_VM(NMT, location_printing_cheap_3) { test_for_c_heap(2 * K, K + 1); }          \/\/ into payload\n-TEST_VM(NMT, location_printing_cheap_4) { test_for_c_heap(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n-TEST_VM(NMT, location_printing_cheap_5) { test_for_c_heap(4, 4); }                  \/\/ just outside a very small block\n+static void test_for_dead_c_heap_block(size_t sz, ssize_t offset) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+  char* c = NEW_C_HEAP_ARRAY(char, sz, mtTest);\n+  LOG_HERE(\"C-block starts \" PTR_FORMAT \", size \" SIZE_FORMAT \".\", p2i(c), offset);\n+  memset(c, 0, sz);\n+  \/\/ We cannot just free the allocation to try dead block printing, since the memory\n+  \/\/ may be immediately reused by concurrent code. Instead, we mark the block as dead\n+  \/\/ manually, and revert that before freeing it.\n+  MallocHeader* const hdr = MallocHeader::resolve_checked(c);\n+  hdr->mark_block_as_dead();\n+\n+  const char* expected_string = \"into dead malloced block\";\n+  if (offset < 0) {\n+    expected_string = \"into header of dead malloced block\";\n+  } else if ((size_t)offset >= sz) {\n+    expected_string = \"just outside of dead malloced block\";\n+  }\n+\n+  test_pointer(c + offset, true, expected_string);\n+\n+  hdr->revive();\n+  FREE_C_HEAP_ARRAY(char, c);\n+}\n+\n+TEST_VM(NMT, location_printing_cheap_live_1) { test_for_live_c_heap_block(2 * K, 0); }              \/\/ start of payload\n+TEST_VM(NMT, location_printing_cheap_live_2) { test_for_live_c_heap_block(2 * K, -7); }             \/\/ into header\n+TEST_VM(NMT, location_printing_cheap_live_3) { test_for_live_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n+TEST_VM(NMT, location_printing_cheap_live_4) { test_for_live_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n+TEST_VM(NMT, location_printing_cheap_live_5) { test_for_live_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n+TEST_VM(NMT, location_printing_cheap_live_6) { test_for_live_c_heap_block(4, 0); }                  \/\/ into a very small block\n+TEST_VM(NMT, location_printing_cheap_live_7) { test_for_live_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n+\n+TEST_VM(NMT, location_printing_cheap_dead_1) { test_for_dead_c_heap_block(2 * K, 0); }              \/\/ start of payload\n+TEST_VM(NMT, location_printing_cheap_dead_2) { test_for_dead_c_heap_block(2 * K, -7); }             \/\/ into header\n+TEST_VM(NMT, location_printing_cheap_dead_3) { test_for_dead_c_heap_block(2 * K, K + 1); }          \/\/ into payload\n+TEST_VM(NMT, location_printing_cheap_dead_4) { test_for_dead_c_heap_block(2 * K, K + 2); }          \/\/ into payload (check for even\/odd errors)\n+TEST_VM(NMT, location_printing_cheap_dead_5) { test_for_dead_c_heap_block(2 * K + 1, 2 * K + 2); }  \/\/ just outside payload\n+TEST_VM(NMT, location_printing_cheap_dead_6) { test_for_dead_c_heap_block(4, 0); }                  \/\/ into a very small block\n+TEST_VM(NMT, location_printing_cheap_dead_7) { test_for_dead_c_heap_block(4, 4); }                  \/\/ just outside a very small block\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_locationprinting.cpp","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n-\/\/#define LOG(...)\n+\/\/#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+#define LOG(...)\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}