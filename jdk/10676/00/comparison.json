{"files":[{"patch":"@@ -240,1 +240,5 @@\n-    public boolean isEveryChunk() {\n+    \/**\n+     * Returns true if \"beginChunk\", \"endChunk\" or \"everyChunk\" have\n+     * been set.\n+     *\/\n+    public boolean isChunkTime() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -43,0 +44,1 @@\n+    private static final ReentrantLock lock = new ReentrantLock();\n@@ -69,1 +71,1 @@\n-                        jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+                        emitJVMEvent(type);\n@@ -83,0 +85,12 @@\n+        private void emitJVMEvent(PlatformEventType type) {\n+            try {\n+                \/\/ There should only be one thread in native at a time.\n+                \/\/ ReentrantLock is used to avoid JavaMonitorBlocked event\n+                \/\/ from synchronized block.\n+                lock.lock();\n+                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n@@ -224,1 +238,1 @@\n-            if (!es.isEnabled() || es.isEveryChunk()) {\n+            if (!es.isEnabled() || es.isChunkTime()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}