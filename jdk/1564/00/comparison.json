{"files":[{"patch":"@@ -226,1 +226,0 @@\n- * @implSpec\n@@ -228,31 +227,7 @@\n- * Records are serialized differently than ordinary serializable or externalizable\n- * objects. The serialized form of a record object is a sequence of values derived\n- * from the record components. The stream format of a record object is the same as\n- * that of an ordinary object in the stream. During deserialization, if the local\n- * class equivalent of the specified stream class descriptor is a record class,\n- * then first the stream fields are read and reconstructed to serve as the record's\n- * component values; and second, a record object is created by invoking the\n- * record's <i>canonical<\/i> constructor with the component values as arguments (or the\n- * default value for component's type if a component value is absent from the\n- * stream).\n- * Like other serializable or externalizable objects, record objects can function\n- * as the target of back references appearing subsequently in the serialization\n- * stream. However, a cycle in the graph where the record object is referred to,\n- * either directly or transitively, by one of its components, is not preserved.\n- * The record components are deserialized prior to the invocation of the record\n- * constructor, hence this limitation (see\n- * <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#cyclic-references\">\n- * <cite>Java Object Serialization Specification,<\/cite>\n- * Section 1.14, \"Circular References\"<\/a> for additional information).\n- * The process by which record objects are serialized or externalized cannot be\n- * customized; any class-specific writeObject, readObject, readObjectNoData,\n- * writeExternal, and readExternal methods defined by record classes are\n- * ignored during serialization and deserialization. However, a substitute object\n- * to be serialized or a designate replacement may be specified, by the\n- * writeReplace and readResolve methods, respectively.  Any\n- * serialPersistentFields field declaration is ignored. Documenting serializable\n- * fields and data for record classes is unnecessary, since there is no variation\n- * in the serial form, other than whether a substitute or replacement object is\n- * used. The serialVersionUID of a record class is 0L unless explicitly\n- * declared. The requirement for matching serialVersionUID values is waived for\n- * record classes.\n+ * <p>Records are serialized differently than ordinary serializable or externalizable\n+ * objects. During deserialization the record's canonical constructor is invoked\n+ * to construct the record object. Certain serialization-related methods, such\n+ * as readObject and writeObject, are ignored for serializable records. See\n+ * <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-records\">\n+ * <cite>Java Object Serialization Specification,<\/cite> Section 1.13,\n+ * \"Serialization of Records\"<\/a> for additional information.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,2 +153,1 @@\n- * @implSpec\n- * Records are serialized differently than ordinary serializable or externalizable\n+ * <p>Records are serialized differently than ordinary serializable or externalizable\n@@ -1486,1 +1485,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -493,5 +493,0 @@\n-    @SuppressWarnings(\"preview\")\n-    private static boolean isRecord(Class<?> cls) {\n-        return cls.isRecord();\n-    }\n-\n@@ -506,1 +501,1 @@\n-        isRecord = isRecord(cl);\n+        isRecord = cl.isRecord();\n@@ -721,1 +716,1 @@\n-                    !cl.isArray() && !isRecord(cl) &&\n+                    !cl.isArray() && !cl.isRecord() &&\n@@ -783,1 +778,1 @@\n-            assert isRecord(cl) ? localDesc.cons == null : true;\n+            assert cl.isRecord() ? localDesc.cons == null : true;\n@@ -1593,1 +1588,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1595,1 +1589,1 @@\n-        assert isRecord(cls) : \"Expected record, got: \" + cls;\n+        assert cls.isRecord() : \"Expected record, got: \" + cls;\n@@ -1746,1 +1740,1 @@\n-        if (isRecord(cl)) {\n+        if (cl.isRecord()) {\n@@ -2666,1 +2660,0 @@\n-        @SuppressWarnings(\"preview\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -142,0 +142,6 @@\n+ * Record classes can implement {@code Serializable} and receive treatment defined\n+ * by the <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-records\">\n+ * <cite>Java Object Serialization Specification,<\/cite> Section 1.13,\n+ * \"Serialization of Records\"<\/a>. Any declarations of the special\n+ * handling methods discussed above are ignored for record types.<p>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/io\/Serializable.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,2 +77,4 @@\n- * serializable records can be found in\n- * <a href=\"{@docRoot}\/java.base\/java\/io\/ObjectInputStream.html#record-serialization\">record serialization<\/a>.\n+ * serializable records can be found in the\n+ * <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-records\">\n+ * <cite>Java Object Serialization Specification,<\/cite> Section 1.13,\n+ * \"Serialization of Records\"<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Record.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}