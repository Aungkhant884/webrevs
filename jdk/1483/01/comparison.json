{"files":[{"patch":"@@ -2130,1 +2130,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),\n+    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n@@ -2133,0 +2133,1 @@\n+    int count = 0;\n@@ -2135,5 +2136,20 @@\n-      \/\/ This returns <package-name>\/<class-name>.\n-      Symbol* klass_name = ik->constants()->klass_name_at(cp_index);\n-      assert(klass_name != NULL, \"Unexpected null klass_name\");\n-      Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);\n-      result->obj_at_put(i, perm_subtype_h());\n+      Klass* k = ik->constants()->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+          return NULL; \/\/ propagate VMEs\n+        }\n+        CLEAR_PENDING_EXCEPTION;\n+        continue;\n+      }\n+      if (k->is_instance_klass()) {\n+        result->obj_at_put(count++, k->java_mirror());\n+      }\n+    }\n+    if (count < length) {\n+      objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+                                                count, CHECK_NULL);\n+      objArrayHandle result2(THREAD, r2);\n+      for (int i = 0; i < count; i++) {\n+        result2->obj_at_put(i, result->obj_at(i));\n+      }\n+      return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.HashSet;\n@@ -67,0 +68,1 @@\n+import java.util.Set;\n@@ -203,2 +205,0 @@\n-    private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];\n-\n@@ -3024,0 +3024,39 @@\n+    \/*\n+     * Checks if a client loaded in ClassLoader ccl is allowed to access the provided\n+     * classes under the current package access policy. If access is denied,\n+     * throw a SecurityException.\n+     *\n+     * NOTE: this method should only be called if a SecurityManager is active\n+     *       classes must be non-empty\n+     *       all classes provided must be loaded by the same ClassLoader\n+     *\/\n+    private static void checkPackageAccessForClasses(SecurityManager sm, final ClassLoader ccl,\n+                                    boolean checkProxyInterfaces, Class<?>[] classes) {\n+        final ClassLoader cl = classes[0].getClassLoader0();\n+\n+        if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {\n+            Set<String> packages = new HashSet<>();\n+\n+            for (Class<?> c : classes) {\n+                \/\/ skip the package access check on a proxy class in default proxy package\n+                if (!Proxy.isProxyClass(c) || ReflectUtil.isNonPublicProxyClass(c)) {\n+                    String pkg = c.getPackageName();\n+                    if (pkg != null && !pkg.isEmpty()) {\n+                        packages.add(pkg);\n+                    }\n+                }\n+            }\n+            for (String pkg : packages) {\n+                sm.checkPackageAccess(pkg);\n+            }\n+        }\n+        \/\/ check package access on the proxy interfaces\n+        if (checkProxyInterfaces) {\n+            for (Class<?> c : classes) {\n+                if (Proxy.isProxyClass(c)) {\n+                    ReflectUtil.checkProxyPackageAccess(ccl, c.getInterfaces());\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4359,2 +4398,2 @@\n-     * Returns an array containing {@code ClassDesc} objects representing all the\n-     * direct subclasses or direct implementation classes permitted to extend or\n+     * Returns an array containing {@code Class} objects representing the\n+     * direct subinterfaces or subclasses permitted to extend or\n@@ -4366,1 +4405,18 @@\n-     * @return an array of class descriptors of all the permitted subclasses of this class or interface\n+     * For each class or interface {@code C} which is recorded as a permitted\n+     * direct subinterface or subclass of this class or interface,\n+     * this method attempts to obtain the {@code Class}\n+     * object for {@code C} (using {@linkplain #getClassLoader() the defining class\n+     * loader} of the current {@code Class} object).\n+     * The {@code Class} objects which can be obtained using this procedure\n+     * are indicated by elements of the returned array. If a {@code Class} object\n+     * cannot be obtained, it is silently ignored, and not included in the result\n+     * array.\n+     *\n+     * @return an array of class objects of the permitted subclasses of this class or interface\n+     *\n+     * @throws SecurityException\n+     *         If a security manager, <i>s<\/i>, is present and the caller's\n+     *         class loader is not the same as or an ancestor of the class\n+     *         loader for that returned class and invocation of {@link\n+     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}\n+     *         denies access to the package of any class in the returned array.\n@@ -4373,12 +4429,14 @@\n-    public ClassDesc[] permittedSubclasses() {\n-        String[] subclassNames;\n-        if (isArray() || isPrimitive() || (subclassNames = getPermittedSubclasses0()).length == 0) {\n-            return EMPTY_CLASS_DESC_ARRAY;\n-        }\n-        ClassDesc[] constants = new ClassDesc[subclassNames.length];\n-        int i = 0;\n-        for (String subclassName : subclassNames) {\n-            try {\n-                constants[i++] = ClassDesc.of(subclassName.replace('\/', '.'));\n-            } catch (IllegalArgumentException iae) {\n-                throw new InternalError(\"Invalid type in permitted subclasses information: \" + subclassName, iae);\n+    @CallerSensitive\n+    public Class<?>[] getPermittedSubclasses() {\n+        Class<?>[] subClasses;\n+        if (isArray() || isPrimitive() || (subClasses = getPermittedSubclasses0()).length == 0) {\n+            return EMPTY_CLASS_ARRAY;\n+        }\n+        if (subClasses.length > 0) {\n+            \/\/ If we return some classes we need a security check:\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                checkPackageAccessForClasses(sm,\n+                                             ClassLoader.getClassLoader(Reflection.getCallerClass()),\n+                                             true,\n+                                             subClasses);\n@@ -4387,1 +4445,1 @@\n-        return constants;\n+        return subClasses;\n@@ -4391,1 +4449,1 @@\n-     * * {@preview Associated with sealed classes, a preview feature of the Java language.\n+     * {@preview Associated with sealed classes, a preview feature of the Java language.\n@@ -4398,2 +4456,3 @@\n-     * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.\n-     * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns\n+     * Returns {@code true} if and only if this {@code Class} object represents\n+     * a sealed class or interface. If this {@code Class} object represents a\n+     * primitive type, {@code void}, or an array type, this method returns\n@@ -4402,0 +4461,4 @@\n+     * @apiNote\n+     * Sealed class or interface has no relationship with\n+     * {@linkplain Package#isSealed package sealing}.\n+     *\n@@ -4414,1 +4477,1 @@\n-        return permittedSubclasses().length != 0;\n+        return getPermittedSubclasses().length != 0;\n@@ -4417,1 +4480,1 @@\n-    private native String[] getPermittedSubclasses0();\n+    private native Class<?>[] getPermittedSubclasses0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":86,"deletions":23,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    {\"getPermittedSubclasses0\", \"()[\" STR,  (void *)&JVM_GetPermittedSubclasses},\n+    {\"getPermittedSubclasses0\", \"()[\" CLS,  (void *)&JVM_GetPermittedSubclasses},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1632,1 +1632,1 @@\n-     * Is t is castable to s?<br>\n+     * Is t castable to s?<br>\n@@ -1637,0 +1637,1 @@\n+        \/\/ if same type\n@@ -1639,0 +1640,1 @@\n+        \/\/ if one of the types is primitive\n@@ -1645,0 +1647,1 @@\n+        boolean result;\n@@ -1649,1 +1652,1 @@\n-                return isCastable.visit(t,s);\n+                result = isCastable.visit(t,s);\n@@ -1654,1 +1657,1 @@\n-            return isCastable.visit(t,s);\n+            result = isCastable.visit(t,s);\n@@ -1656,0 +1659,6 @@\n+        if (result && (t.tsym.isSealed() || s.tsym.isSealed())) {\n+            return (t.isCompound() || s.isCompound()) ?\n+                    false :\n+                    !areDisjoint((ClassSymbol)t.tsym, (ClassSymbol)s.tsym);\n+        }\n+        return result;\n@@ -1658,0 +1667,28 @@\n+        private boolean areDisjoint(ClassSymbol ts, ClassSymbol ss) {\n+            if (isSubtype(ts.type, ss.type)) {\n+                return false;\n+            }\n+            \/\/ if both are classes or both are interfaces, shortcut\n+            if (ts.isInterface() == ss.isInterface() && isSubtype(ss.type, ts.type)) {\n+                return false;\n+            }\n+            if (ts.isInterface() && !ss.isInterface()) {\n+                \/* so ts is interface but ss is a class\n+                 * an interface is disjoint from a class if the class is disjoint form the interface\n+                 *\/\n+                return areDisjoint(ss, ts);\n+            }\n+            \/\/ a final class that is not subtype of ss is disjoint\n+            if (!ts.isInterface() && ts.isFinal()) {\n+                return true;\n+            }\n+            \/\/ if at least one is sealed\n+            if (ts.isSealed() || ss.isSealed()) {\n+                \/\/ permitted subtypes have to be disjoint with the other symbol\n+                ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n+                ClassSymbol other = sealedOne == ts ? ss : ts;\n+                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1306,1 +1306,4 @@\n-                           FINAL | NON_SEALED)) {\n+                           FINAL | NON_SEALED)\n+                 && checkDisjoint(pos, flags,\n+                                SEALED,\n+                                ANNOTATION)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4267,1 +4267,5 @@\n-                case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4271,1 +4275,5 @@\n-                case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,3 +24,2 @@\n-\/\/ This class has entries in its PermittedSubclasses attribute that do not exist.\n-\/\/ Test that this does not prevent JVM_GetPermittedSubclasses() from returning\n-\/\/ their names.\n+\/\/ This class has an entry in its PermittedSubclasses attribute that does not exist.\n+\/\/ Test that JVM_GetPermittedSubclasses() only returns the existing class.\n@@ -28,1 +27,1 @@\n-\/\/ sealed class NoLoadSubclasses permits iDontExist, I\/Dont\/Exist\/Either { }\n+\/\/ sealed class NoLoadSubclasses permits OldClassFile, I\/Dont\/Exist\/Either { }\n@@ -50,1 +49,1 @@\n-    Utf8 \"iDontExist\"; \/\/ #15     at 0xA0\n+    Utf8 \"OldClassFile\"; \/\/ #15     at 0xA0\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/GetPermittedSubclasses.jcod","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        Object[] permitted = c.permittedSubclasses();\n+        Object[] permitted = c.getPermittedSubclasses();\n@@ -68,1 +68,1 @@\n-                permittedNames.add(((ClassDesc)permitted[i]).descriptorString());\n+                permittedNames.add(((Class)permitted[i]).getName());\n@@ -105,4 +105,5 @@\n-        testSealedInfo(SealedI1.class, new String[] {\"LGetPermittedSubclassesTest$NotSealed;\",\n-                                                     \"LGetPermittedSubclassesTest$Sub1;\",\n-                                                     \"LGetPermittedSubclassesTest$Extender;\"});\n-        testSealedInfo(Sealed1.class, new String[] {\"LGetPermittedSubclassesTest$Sub1;\"});\n+        testSealedInfo(SealedI1.class, new String[] {\"GetPermittedSubclassesTest$NotSealed\",\n+                                                     \"GetPermittedSubclassesTest$Sub1\",\n+                                                     \"GetPermittedSubclassesTest$Extender\"});\n+\n+        testSealedInfo(Sealed1.class, new String[] {\"GetPermittedSubclassesTest$Sub1\"});\n@@ -118,2 +119,2 @@\n-        \/\/ Test returning names of non-existing classes.\n-        testSealedInfo(NoLoadSubclasses.class, new String[]{\"LiDontExist;\", \"LI\/Dont\/Exist\/Either;\"});\n+        \/\/ Test returning only names of existing classes.\n+        testSealedInfo(NoLoadSubclasses.class, new String[]{\"OldClassFile\" });\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/GetPermittedSubclassesTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length > 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length > 0);\n@@ -113,2 +113,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length == 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length == 0);\n@@ -131,2 +131,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length == 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length == 0);\n@@ -218,1 +218,1 @@\n-        assertTrue(sealedClass.permittedSubclasses().length == numberOfSubclasses);\n+        assertTrue(sealedClass.getPermittedSubclasses().length == numberOfSubclasses);\n@@ -220,2 +220,2 @@\n-        for (ClassDesc cd : sealedClass.permittedSubclasses()) {\n-            assertTrue(cd.displayName().equals(subclassDescriptors[i]), \"expected: \" + subclassDescriptors[i] + \" found: \" + cd.displayName());\n+        for (Class<?> cd : sealedClass.getPermittedSubclasses()) {\n+            assertTrue(cd.getName().equals(subclassDescriptors[i]), \"expected: \" + subclassDescriptors[i] + \" found: \" + cd.getName());\n","filename":"test\/jdk\/java\/lang\/reflect\/sealed_classes\/SealedClassesReflectionTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8246778\n+ * @summary Test that security checks occur for getPermittedSubclasses\n+ * @library \/test\/lib\n+ * @modules java.compiler\n+ * @build jdk.test.lib.compiler.CompilerUtils jdk.test.lib.compiler.ModuleInfoMaker TestSecurityManagerChecks\n+ * @run main\/othervm --enable-preview TestSecurityManagerChecks named\n+ * @run main\/othervm --enable-preview TestSecurityManagerChecks unnamed\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.test.lib.compiler.*;\n+\n+public class TestSecurityManagerChecks {\n+\n+    private static final ClassLoader OBJECT_CL = Object.class.getClassLoader();\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (\"named\".equals(args[0])) {\n+            runNamedModuleTest();\n+        } else {\n+            runUnnamedModuleTest();\n+        }\n+    }\n+\n+    private static void runNamedModuleTest() throws Throwable {\n+        Path classes = compileNamedModuleTest();\n+        URL testLocation = TestSecurityManagerChecks.class\n+                                                    .getProtectionDomain()\n+                                                    .getCodeSource()\n+                                                    .getLocation();\n+\n+        \/\/need to use a different ClassLoader to run the test, so that the checks are performed:\n+        ClassLoader testCL = new URLClassLoader(new URL[] {testLocation}, OBJECT_CL);\n+        testCL.loadClass(\"TestSecurityManagerChecks\")\n+              .getDeclaredMethod(\"doRunNamedModuleTest\", Path.class)\n+              .invoke(null, classes);\n+    }\n+\n+    public static void doRunNamedModuleTest(Path classes) throws Throwable {\n+        Configuration testConfig = ModuleLayer.boot()\n+                                              .configuration()\n+                                              .resolve(ModuleFinder.of(),\n+                                                       ModuleFinder.of(classes),\n+                                                       List.of(\"test\"));\n+        ModuleLayer testLayer = ModuleLayer.boot()\n+                                           .defineModulesWithOneLoader(testConfig,\n+                                                                         OBJECT_CL);\n+\n+        \/\/ First get hold of the target classes before we enable security\n+        Class<?> sealed = testLayer.findLoader(\"test\").loadClass(\"test.Base\");\n+\n+        \/\/try without a SecurityManager:\n+        Class<?>[] subclasses = sealed.getPermittedSubclasses();\n+\n+        if (subclasses.length != 3) {\n+            throw new AssertionError(\"Incorrect permitted subclasses: \" +\n+                                       Arrays.asList(subclasses));\n+        }\n+\n+        System.out.println(\"OK - getPermittedSubclasses for \" + sealed.getName() +\n+                           \" got result: \" + Arrays.asList(subclasses));\n+\n+        String[] denyPackageAccess = new String[1];\n+        int[] checkPackageAccessCallCount = new int[1];\n+\n+        \/\/try with a SecurityManager:\n+        SecurityManager sm = new SecurityManager() {\n+            @Override\n+            public void checkPackageAccess(String pkg) {\n+                if (pkg.startsWith(\"test.\")) {\n+                    checkPackageAccessCallCount[0]++;\n+                }\n+                if (Objects.equals(denyPackageAccess[0], pkg)) {\n+                    throw new SecurityException();\n+                }\n+            }\n+        };\n+\n+        System.setSecurityManager(sm);\n+\n+        denyPackageAccess[0] = \"test\";\n+\n+        \/\/should pass - does not return a class from package \"test\":\n+        sealed.getPermittedSubclasses();\n+\n+        if (checkPackageAccessCallCount[0] != 2) {\n+            throw new AssertionError(\"Unexpected call count: \" +\n+                                      checkPackageAccessCallCount[0]);\n+        }\n+\n+        denyPackageAccess[0] = \"test.a\";\n+\n+        try {\n+            sealed.getPermittedSubclasses();\n+            throw new Error(\"getPermittedSubclasses incorrectly succeeded for \" +\n+                             sealed.getName());\n+        } catch (SecurityException e) {\n+            System.out.println(\"OK - getPermittedSubclasses for \" + sealed.getName() +\n+                               \" got expected exception: \" + e);\n+        }\n+    }\n+\n+    private static Path compileNamedModuleTest() throws IOException {\n+        Path base = Paths.get(\".\", \"named\");\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        ModuleInfoMaker maker = new ModuleInfoMaker(src);\n+        maker.writeJavaFiles(\"test\",\n+                              \"module test {}\",\n+                              \"package test; public sealed interface Base permits test.a.ImplA1, test.a.ImplA2, test.b.ImplB, test.c.ImplC {}\",\n+                              \"package test.a; public final class ImplA1 implements test.Base {}\",\n+                              \"package test.a; public final class ImplA2 implements test.Base {}\",\n+                              \"package test.b; public final class ImplB implements test.Base {}\",\n+                              \"package test.c; public final class ImplC implements test.Base {}\"\n+                              );\n+\n+        if (!CompilerUtils.compile(src, classes.resolve(\"test\"), \"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\"))) {\n+            throw new AssertionError(\"Compilation didn't succeed!\");\n+        }\n+\n+        Files.delete(classes.resolve(\"test\").resolve(\"test\").resolve(\"c\").resolve(\"ImplC.class\"));\n+\n+        return classes;\n+    }\n+\n+    private static void runUnnamedModuleTest() throws Throwable {\n+        Path classes = compileUnnamedModuleTest();\n+        URL testLocation = TestSecurityManagerChecks.class\n+                                                    .getProtectionDomain()\n+                                                    .getCodeSource()\n+                                                    .getLocation();\n+\n+        \/\/need to use a different ClassLoader to run the test, so that the checks are performed:\n+        ClassLoader testCL = new URLClassLoader(new URL[] {testLocation}, OBJECT_CL);\n+        testCL.loadClass(\"TestSecurityManagerChecks\")\n+              .getDeclaredMethod(\"doRunUnnamedModuleTest\", Path.class)\n+              .invoke(null, classes);\n+    }\n+\n+    public static void doRunUnnamedModuleTest(Path classes) throws Throwable {\n+        ClassLoader unnamedModuleCL =\n+                new URLClassLoader(new URL[] {classes.toUri().toURL()}, OBJECT_CL);\n+\n+        \/\/ First get hold of the target classes before we enable security\n+        Class<?> sealed = unnamedModuleCL.loadClass(\"test.Base\");\n+\n+        \/\/try without a SecurityManager:\n+        Class<?>[] subclasses = sealed.getPermittedSubclasses();\n+\n+        if (subclasses.length != 3) {\n+            throw new AssertionError(\"Incorrect permitted subclasses: \" +\n+                                       Arrays.asList(subclasses));\n+        }\n+\n+        System.out.println(\"OK - getPermittedSubclasses for \" + sealed.getName() +\n+                           \" got result: \" + Arrays.asList(subclasses));\n+\n+        String[] denyPackageAccess = new String[1];\n+        int[] checkPackageAccessCallCount = new int[1];\n+\n+        \/\/try with a SecurityManager:\n+        SecurityManager sm = new SecurityManager() {\n+            @Override\n+            public void checkPackageAccess(String pkg) {\n+                if (pkg.equals(\"test\")) {\n+                    checkPackageAccessCallCount[0]++;\n+                }\n+                if (Objects.equals(denyPackageAccess[0], pkg)) {\n+                    throw new SecurityException();\n+                }\n+            }\n+        };\n+\n+        System.setSecurityManager(sm);\n+\n+        denyPackageAccess[0] = \"test.unknown\";\n+\n+        \/\/should pass - does not return a class from package \"test.unknown\":\n+        sealed.getPermittedSubclasses();\n+\n+        if (checkPackageAccessCallCount[0] != 1) {\n+            throw new AssertionError(\"Unexpected call count: \" +\n+                                      checkPackageAccessCallCount[0]);\n+        }\n+\n+        denyPackageAccess[0] = \"test\";\n+\n+        try {\n+            sealed.getPermittedSubclasses();\n+            throw new Error(\"getPermittedSubclasses incorrectly succeeded for \" +\n+                             sealed.getName());\n+        } catch (SecurityException e) {\n+            System.out.println(\"OK - getPermittedSubclasses for \" + sealed.getName() +\n+                               \" got expected exception: \" + e);\n+        }\n+    }\n+\n+    private static Path compileUnnamedModuleTest() throws IOException {\n+        Path base = Paths.get(\".\", \"unnamed\");\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        ModuleInfoMaker maker = new ModuleInfoMaker(src);\n+        maker.writeJavaFiles(\"test\",\n+                              \"module test {}\",\n+                              \"package test; public sealed interface Base permits ImplA1, ImplA2, ImplB, ImplC {}\",\n+                              \"package test; public final class ImplA1 implements test.Base {}\",\n+                              \"package test; public final class ImplA2 implements test.Base {}\",\n+                              \"package test; public final class ImplB implements test.Base {}\",\n+                              \"package test; public final class ImplC implements test.Base {}\"\n+                              );\n+\n+        Files.delete(src.resolve(\"test\").resolve(\"module-info.java\"));\n+\n+        if (!CompilerUtils.compile(src.resolve(\"test\"), classes, \"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\"))) {\n+            throw new AssertionError(\"Compilation didn't succeed!\");\n+        }\n+\n+        Files.delete(classes.resolve(\"test\").resolve(\"ImplC.class\"));\n+\n+        return classes;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/sealed_classes\/TestSecurityManagerChecks.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -80,1 +80,4 @@\n-        \/\/ sealing a super class which was not sealed, should fail with IncompatibleClassChangeError\n+        \/* If a class that was not declared sealed is changed to be declared sealed, then an\n+         * IncompatibleClassChangeError is thrown if a binary of a pre-existing subclass of\n+         * this class is loaded that is not contained in its permits clause\n+         *\/\n@@ -83,0 +86,1 @@\n+                true,\n@@ -106,2 +110,1 @@\n-                \"\"\",\n-                true\n+                \"\"\"\n@@ -113,1 +116,1 @@\n-        \/\/ sealing a super interface which was not sealed, should fail with IncompatibleClassChangeError\n+        \/\/ test similar to testCompatibilityAfterMakingSuperclassSealed but with interfaces\n@@ -116,0 +119,1 @@\n+                true,\n@@ -139,2 +143,1 @@\n-                \"\"\",\n-                true\n+                \"\"\"\n@@ -152,0 +155,1 @@\n+            boolean shouldFail,\n@@ -154,2 +158,1 @@\n-            String subClassCode,\n-            boolean shouldFail) throws Exception {\n+            String... subClassesCode) throws Exception {\n@@ -161,1 +164,0 @@\n-        \/\/ super class initially not sealed\n@@ -163,1 +165,1 @@\n-        tb.writeJavaFiles(sub, subClassCode);\n+        tb.writeJavaFiles(sub, subClassesCode);\n@@ -223,1 +225,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is declared sealed to no longer be declared\n+         * sealed does not break compatibility with pre-existing binaries.\n+         *\/\n@@ -226,0 +230,1 @@\n+                false,\n@@ -247,2 +252,1 @@\n-                \"\"\",\n-                false\n+                \"\"\"\n@@ -254,1 +258,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as testRemoveSealedModifierToClass but with an interface\n@@ -257,0 +261,1 @@\n+                false,\n@@ -278,2 +283,1 @@\n-                \"\"\",\n-                false\n+                \"\"\"\n@@ -285,1 +289,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is not declared non-sealed to be declared\n+         * non-sealed does not break compatibility with pre-existing binaries\n+         *\/\n@@ -310,1 +316,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as `testAddNonSealedModifierToClass` but with interfaces\n@@ -335,1 +341,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is declared non-sealed to no longer be declared\n+         * non-sealed does not break compatibility with pre-existing binaries\n+         *\/\n@@ -360,1 +368,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as `testRemoveNonSealedModifier` but with interfaces\n@@ -455,1 +463,4 @@\n-        \/\/ the VM will throw IncompatibleClassChangeError\n+        \/* If a class is removed from the set of permitted direct subclasses of\n+         * a sealed class then an IncompatibleClassChangeError is thrown if the\n+         * pre-existing binary of the removed class is loaded\n+         *\/\n@@ -458,0 +469,1 @@\n+                true,\n@@ -483,0 +495,22 @@\n+                \"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testAfterChangingPermitsClause2(Path base) throws Exception {\n+        \/* If a class is removed from the set of permitted direct subclasses of\n+         * a sealed class then an IncompatibleClassChangeError is thrown if the\n+         * pre-existing binary of the removed class is loaded\n+         *\/\n+        testCompatibilityAfterModifyingSupertype(\n+                base,\n+                true,\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1, pkg.Sub2 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n@@ -484,1 +518,18 @@\n-                true\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                final class Sub1 extends Super {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                final class Sub2 extends Super {}\n+                \"\"\"\n@@ -487,0 +538,92 @@\n+\n+    @Test\n+    public void testAfterChangingPermitsClause3(Path base) throws Exception {\n+        \/* Changing the set of permitted direct subclasses of a sealed class will\n+         * not break compatibility with pre-existing binaries, provided that the\n+         * total set of permitted direct subclasses of the sealed class loses no\n+         * members\n+         *\/\n+        String superClassCode1 =\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\";\n+        String subClass1Code =\n+                \"\"\"\n+                package pkg;\n+                final class Sub1 extends Super {}\n+                \"\"\";\n+\n+        String superClassCode2 =\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1, pkg.Sub2 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\";\n+        String subClass2Code =\n+                \"\"\"\n+                package pkg;\n+                final class Sub2 extends Super {}\n+                \"\"\";\n+\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path superClass = pkg.resolve(\"Super\");\n+        Path sub1 = pkg.resolve(\"Sub1\");\n+\n+        tb.writeJavaFiles(superClass, superClassCode1);\n+        tb.writeJavaFiles(sub1, subClass1Code);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                        \"-source\", Integer.toString(Runtime.version().feature()))\n+                .outdir(out)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's working\n+        String output = new JavaTask(tb)\n+                .vmOptions(\"--enable-preview\")\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Super\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+\n+        \/\/ let's first check that it runs wo issues\n+        if (!output.contains(\"done\")) {\n+            throw new AssertionError(\"execution of Super didn't finish\");\n+        }\n+\n+        \/\/ now lets change the super class\n+        tb.writeJavaFiles(superClass, superClassCode2);\n+        Path sub2 = pkg.resolve(\"Sub2\");\n+        tb.writeJavaFiles(sub2, subClass2Code);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                        \"-source\", Integer.toString(Runtime.version().feature()))\n+                .classpath(out)\n+                .outdir(out)\n+                .files(findJavaFiles(superClass)[0], findJavaFiles(sub2)[0])\n+                .run();\n+\n+        new JavaTask(tb)\n+                .vmOptions(\"--enable-preview\")\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Super\")\n+                .run(Task.Expect.SUCCESS);\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/BinaryCompatibilityTests.java","additions":165,"deletions":22,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -471,0 +471,20 @@\n+                \"\"\",\n+                \"\"\"\n+                sealed class C {\n+                    void m() {\n+                        class L {\n+                            final class D extends C { }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C {\n+                    void m() {\n+                        class L {\n+                            void foo() {\n+                                final class D extends C { }\n+                            }\n+                        }\n+                    }\n+                }\n@@ -616,1 +636,1 @@\n-            Assert.check(c.permittedSubclasses().length == 0);\n+            Assert.check(c.getPermittedSubclasses().length == 0);\n@@ -959,0 +979,278 @@\n+\n+    public void testDoNotAllowSealedAnnotation() {\n+        for (String s : List.of(\n+            \"\"\"\n+            sealed @interface A {}\n+            non-sealed interface I extends A {}\n+            \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.expected4\", s);\n+        }\n+    }\n+\n+    public void testNarrowConversion() {\n+        for (String s : List.of(\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D {}\n+                final class D extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits C {}\n+                final class C implements I {}\n+                interface J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                sealed interface J permits C {}\n+                final class C implements J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits A {}\n+                sealed interface J permits B {}\n+                final class A implements I {}\n+                final class B implements J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class C {}\n+                sealed interface I permits A {}\n+                final class A implements I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                final class C {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                final class C {}\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                final class D extends C {}\n+                non-sealed interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                final class D {}\n+                sealed interface I permits E {}\n+                final class E {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                sealed class D permits NS {}\n+                non-sealed class NS extends D {}\n+                sealed interface I permits E {}\n+                final class E {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                final class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D {}\n+                final class D {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D {}\n+                class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+                final class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+                sealed class C permits E {}\n+                final class E extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.prob.found.req\", s);\n+        }\n+\n+        for (String s : List.of(\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D, E {}\n+                non-sealed class D extends C {}\n+                final class E extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                interface J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class C {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                sealed class D extends C permits NS {}\n+                non-sealed class NS extends D {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface A permits B { }\n+                non-sealed interface B extends A { }\n+                interface C { }\n+\n+                class D implements C, B { }\n+\n+                class Test {\n+                  void m(A a, C c) {\n+                     a = (A)c;\n+                  }\n+                }\n+                \"\"\"\n+        )) {\n+            assertOK(s);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":299,"deletions":1,"binary":false,"changes":300,"status":"modified"}]}