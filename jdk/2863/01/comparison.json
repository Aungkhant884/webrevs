{"files":[{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jtreg.SkippedException;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * @test\n+ * @bug 8261095\n+ * @summary Test the clhsdb 'symbol' command on live process\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run main\/othervm ClhsdbSymbol\n+ *\/\n+\n+public class ClhsdbSymbol {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Starting the ClhsdbSymbol test\");\n+        LingeredApp theApp = null;\n+\n+        try {\n+            List<String> cmds = null;\n+            String cmdStr = null;\n+            Map<String, List<String>> expStrMap = null;\n+            ClhsdbLauncher test = new ClhsdbLauncher();\n+            theApp = LingeredApp.startApp();\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+\n+            \/\/ Use command \"class java.lang.Thread\" to get the address of the InstanceKlass for java.lang.Thread\n+            cmdStr = \"class java.lang.Thread\";\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"java\/lang\/Thread\"));\n+            String classOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+\n+            \/\/ Extract the thread InstanceKlass address from the output, which looks similar to the following:\n+            \/\/   java\/lang\/Thread @0x000000080001d940\n+            String threadAddress = classOutput.lines().filter(part -> part.startsWith(\"java\/lang\/Thread\"))\n+                                                      .map(part -> part.split(\" @\"))\n+                                                      .findFirst()\n+                                                      .map(addresses -> addresses[1])\n+                                                      .orElse(null);\n+\n+            if (threadAddress == null) {\n+                throw new RuntimeException(\"Cannot find address of the InstanceKlass for java.lang.Thread in output\");\n+            }\n+\n+            \/\/ Use \"inspect\" on the thread address we extracted in previous step\n+            cmdStr = \"inspect \" + threadAddress;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"Symbol\"));\n+            String inspectOutput = test.run(theApp.getPid(), cmds, expStrMap, null);\n+\n+            \/\/ The inspect command output will have one line of output that looks like the following.\n+            \/\/ Symbol* Klass::_name: Symbol @ 0x0000000800471120\n+            \/\/ Extract the Symbol address from it.\n+            String symbolAddress = inspectOutput.lines().filter(part -> part.startsWith(\"Symbol\"))\n+                                                        .map(part -> part.split(\"@ \"))\n+                                                        .findFirst().map(symbolParts -> symbolParts[1])\n+                                                        .orElse(null);\n+            if (symbolAddress == null) {\n+                throw new RuntimeException(\"Cannot find address with Symbol instance\");\n+            }\n+\n+            \/\/ Run \"symbol\" command on the Symbol instance address extracted in previous step.\n+            \/\/ It should produce the symbol for java\/lang\/Thread.\n+            cmdStr = \"symbol \" + symbolAddress;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"#java\/lang\/Thread\"));\n+            test.run(theApp.getPid(), cmds, expStrMap, null);\n+        } catch (SkippedException se) {\n+            throw se;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbSymbol.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}