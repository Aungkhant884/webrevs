{"files":[{"patch":"@@ -642,3 +642,1 @@\n-            \/\/ Pass no_name so method name doesn't affect check for legal signature.\n-            const Symbol* const no_name = vmSymbols::type_name(); \/\/ place holder\n-            verify_legal_method_signature(no_name, sig, CHECK);\n+            verify_legal_method_signature(name, sig, false, CHECK);\n@@ -757,1 +755,1 @@\n-        verify_legal_method_signature(no_name, signature, CHECK);\n+        verify_legal_method_signature(no_name, signature, false, CHECK);\n@@ -2303,1 +2301,1 @@\n-                 verify_legal_method_signature(name, signature, CHECK_NULL);\n+                 verify_legal_method_signature(name, signature, true, CHECK_NULL);\n@@ -5052,0 +5050,2 @@\n+\/\/ If check_compatibility is true, then check that the signature is compatible\n+\/\/ with the method name.  For example, check that <init> has a void signature.\n@@ -5055,0 +5055,1 @@\n+                                                   bool check_compatibility,\n@@ -5063,1 +5064,1 @@\n-  if (name == vmSymbols::class_initializer_name() &&\n+  if (check_compatibility && name == vmSymbols::class_initializer_name() &&\n@@ -5092,1 +5093,2 @@\n-      if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n+      if (check_compatibility && name->utf8_length() > 0 &&\n+          name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+                                     bool check_compatibility,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,12 @@\n+\n+        \/\/ Test that a NameAndType with a valid name and invalid signature throws a\n+        \/\/ ClassFormatError exception with a message containing the name <init> and\n+        \/\/ the bad signature.\n+        try {\n+            Class newClass2 = Class.forName(\"voidInitBadSig\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class voidInitBadSig has illegal signature \\\"()))V\\\"\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/NameAndTypeSig.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#3) that\n@@ -135,2 +135,2 @@\n-\/\/ But, a cp Methodref that points to NameAndType with a method named <init>,\n-\/\/ and a non-void return type, is invalid.\n+\/\/ But, a cp Methodref (#1) that points to NameAndType with a method named\n+\/\/ <init> and a non-void return type, is invalid.\n@@ -240,0 +240,107 @@\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ points to method <init> and signature ()))V.  This is an invalid NameAndType\n+\/\/ entry and should throw a ClassFormatError exception, with a message containing\n+\/\/ the name <init> and the bad signature, even thought the NameAndType is not\n+\/\/ referenced by a cp Methodref.\n+class voidInitBadSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"voidInitBadSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"voidInitBadSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()))V\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()))V.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class voidInitBadSig\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/nonVoidInitSig.jcod","additions":110,"deletions":3,"binary":false,"changes":113,"status":"modified"}]}