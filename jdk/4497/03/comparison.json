{"files":[{"patch":"@@ -695,2 +695,3 @@\n-            \/\/ Method name and signature are verified above, when iterating NameAndType_info.\n-            \/\/ Need only to be sure signature is non-zero length and the right type.\n+            \/\/ Method name and signature are individually verified above, when iterating\n+            \/\/ NameAndType_info.  Need to check here that signature is non-zero length and\n+            \/\/ the right type.\n@@ -701,1 +702,1 @@\n-          \/\/ 4509014: If a class method name begins with '<', it must be \"<init>\"\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -703,8 +704,10 @@\n-          if (tag == JVM_CONSTANT_Methodref &&\n-              name_len != 0 &&\n-              name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-              name != vmSymbols::object_initializer_name()) {\n-            classfile_parse_error(\n-              \"Bad method name at constant pool index %u in class file %s\",\n-              name_ref_index, THREAD);\n-            return;\n+          if (tag == JVM_CONSTANT_Methodref && name_len != 0 &&\n+              name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n+            if (name != vmSymbols::object_initializer_name()) {\n+              classfile_parse_error(\n+                \"Bad method name at constant pool index %u in class file %s\",\n+                name_ref_index, THREAD);\n+              return;\n+            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            }\n@@ -2297,0 +2300,1 @@\n+    verify_legal_name_with_signature(name, signature, CHECK_NULL);\n@@ -5046,5 +5050,5 @@\n-\/\/ Checks if signature is a legal method signature.\n-\/\/ Returns number of parameters\n-int ClassFileParser::verify_legal_method_signature(const Symbol* name,\n-                                                   const Symbol* signature,\n-                                                   TRAPS) const {\n+\/\/ Check that the signature is compatible with the method name.  For example,\n+\/\/ check that <init> has a void signature.\n+void ClassFileParser::verify_legal_name_with_signature(const Symbol* name,\n+                                                       const Symbol* signature,\n+                                                       TRAPS) const {\n@@ -5054,1 +5058,1 @@\n-    return -2;\n+    return;\n@@ -5061,2 +5065,22 @@\n-    throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    return 0;\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    return;\n+  }\n+\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+      sig_length > 0 &&\n+      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+  }\n+}\n+\n+\/\/ Checks if signature is a legal method signature.\n+\/\/ Returns number of parameters\n+int ClassFileParser::verify_legal_method_signature(const Symbol* name,\n+                                                   const Symbol* signature,\n+                                                   TRAPS) const {\n+  if (!_need_verify) {\n+    \/\/ make sure caller's args_size will be less than 0 even for non-static\n+    \/\/ method so it will be recomputed in compute_size_of_parameters().\n+    return -2;\n@@ -5087,11 +5111,4 @@\n-      if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n-        \/\/ All internal methods must return void\n-        if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {\n-          return args_size;\n-        }\n-      } else {\n-        \/\/ Now we better just have a return value\n-        nextp = skip_over_field_signature(p, true, length, CHECK_0);\n-        if (nextp && ((int)length == (nextp - p))) {\n-          return args_size;\n-        }\n+      \/\/ Now we better just have a return value\n+      nextp = skip_over_field_signature(p, true, length, CHECK_0);\n+      if (nextp && ((int)length == (nextp - p))) {\n+        return args_size;\n@@ -5102,1 +5119,1 @@\n-  throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+  throwIllegalSignature(\"Method\", name, signature, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":48,"deletions":31,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -465,0 +465,3 @@\n+  void verify_legal_name_with_signature(const Symbol* name,\n+                                        const Symbol* signature,\n+                                        TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268720\n+ * @summary Constant pool NameAndType entries with valid but incompatible method\n+ *          name and signature shouldn't cause an exception until referenced by\n+ *          a method_ref.\n+ * @compile nonVoidInitSig.jcod\n+ * @run main\/othervm -Xverify:remote NameAndTypeSig\n+ *\/\n+\n+\/\/ Test constant pool NameAndType descriptors with valid but incompatible method\n+\/\/ names and signatures.\n+public class NameAndTypeSig {\n+    public static void main(String args[]) throws Throwable {\n+\n+        \/\/ Test that an unreferenced NameAndType with a valid name and signature\n+        \/\/ is allowed even for name and signature pairs such as <init>()D.\n+        Class newClass = Class.forName(\"nonVoidInitSig\");\n+\n+        \/\/ Test that a NameAndType with a valid name and signature is allowed for\n+        \/\/ name and signature pairs such as <init>()D, but not allowed by a cp\n+        \/\/ Method_ref.\n+        try {\n+            Class newClass2 = Class.forName(\"nonVoidInitSigCFE\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class nonVoidInitSigCFE has illegal signature\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+\n+        \/\/ Test that a NameAndType with a valid name and invalid signature throws a\n+        \/\/ ClassFormatError exception with a message containing the name <init> and\n+        \/\/ the bad signature.\n+        try {\n+            Class newClass2 = Class.forName(\"voidInitBadSig\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class voidInitBadSig has illegal signature \\\"()))V\\\"\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+        System.out.println(\"Test NameAndTypeSig passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/NameAndTypeSig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The constant pool in this class contains an unused NameAndType entry (#20)\n+\/\/ that points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+class nonVoidInitSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()D.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSig\n+\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#3) that\n+\/\/ points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+\/\/ But, a cp Methodref (#1) that points to NameAndType with a method named\n+\/\/ <init> and a non-void return type, is invalid.\n+class nonVoidInitSigCFE {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #19; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSigCFE\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSigCFE.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSigCFE\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ points to method <init> and signature ()))V.  This is an invalid NameAndType\n+\/\/ entry and should throw a ClassFormatError exception, with a message containing\n+\/\/ the name <init> and the bad signature, even thought the NameAndType is not\n+\/\/ referenced by a cp Methodref.\n+class voidInitBadSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"voidInitBadSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"voidInitBadSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()))V\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()))V.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class voidInitBadSig\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/nonVoidInitSig.jcod","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"}]}