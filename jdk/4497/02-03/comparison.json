{"files":[{"patch":"@@ -642,1 +642,1 @@\n-            verify_legal_method_signature(name, sig, false, CHECK);\n+            verify_legal_method_signature(name, sig, CHECK);\n@@ -755,1 +755,1 @@\n-        verify_legal_method_signature(no_name, signature, false, CHECK);\n+        verify_legal_method_signature(no_name, signature, CHECK);\n@@ -2300,0 +2300,1 @@\n+    verify_legal_name_with_signature(name, signature, CHECK_NULL);\n@@ -2301,1 +2302,1 @@\n-                 verify_legal_method_signature(name, signature, true, CHECK_NULL);\n+                 verify_legal_method_signature(name, signature, CHECK_NULL);\n@@ -5049,0 +5050,28 @@\n+\/\/ Check that the signature is compatible with the method name.  For example,\n+\/\/ check that <init> has a void signature.\n+void ClassFileParser::verify_legal_name_with_signature(const Symbol* name,\n+                                                       const Symbol* signature,\n+                                                       TRAPS) const {\n+  if (!_need_verify) {\n+    \/\/ make sure caller's args_size will be less than 0 even for non-static\n+    \/\/ method so it will be recomputed in compute_size_of_parameters().\n+    return;\n+  }\n+\n+  \/\/ Class initializers cannot have args for class format version >= 51.\n+  if (name == vmSymbols::class_initializer_name() &&\n+      signature != vmSymbols::void_method_signature() &&\n+      _major_version >= JAVA_7_VERSION) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    return;\n+  }\n+\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+      sig_length > 0 &&\n+      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+  }\n+}\n+\n@@ -5050,2 +5079,0 @@\n-\/\/ If check_compatibility is true, then check that the signature is compatible\n-\/\/ with the method name.  For example, check that <init> has a void signature.\n@@ -5055,1 +5082,0 @@\n-                                                   bool check_compatibility,\n@@ -5063,8 +5089,0 @@\n-  \/\/ Class initializers cannot have args for class format version >= 51.\n-  if (check_compatibility && name == vmSymbols::class_initializer_name() &&\n-      signature != vmSymbols::void_method_signature() &&\n-      _major_version >= JAVA_7_VERSION) {\n-    throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    return 0;\n-  }\n-\n@@ -5093,12 +5111,4 @@\n-      if (check_compatibility && name->utf8_length() > 0 &&\n-          name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n-        \/\/ All internal methods must return void\n-        if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {\n-          return args_size;\n-        }\n-      } else {\n-        \/\/ Now we better just have a return value\n-        nextp = skip_over_field_signature(p, true, length, CHECK_0);\n-        if (nextp && ((int)length == (nextp - p))) {\n-          return args_size;\n-        }\n+      \/\/ Now we better just have a return value\n+      nextp = skip_over_field_signature(p, true, length, CHECK_0);\n+      if (nextp && ((int)length == (nextp - p))) {\n+        return args_size;\n@@ -5109,1 +5119,1 @@\n-  throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+  throwIllegalSignature(\"Method\", name, signature, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -464,1 +464,0 @@\n-                                     bool check_compatibility,\n@@ -466,0 +465,3 @@\n+  void verify_legal_name_with_signature(const Symbol* name,\n+                                        const Symbol* signature,\n+                                        TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}