{"files":[{"patch":"@@ -454,0 +454,1 @@\n+#ifdef ASSERT\n@@ -470,0 +471,19 @@\n+static void assert_no_oops_or_metadata(nmethod* nm) {\n+  if (nm == nullptr) return;\n+  assert(nm->oop_maps() == nullptr, \"expectation\");\n+\n+  CheckForOopsClosure cfo;\n+  nm->oops_do(&cfo);\n+  assert(!cfo.found_oop(), \"no oops allowed\");\n+\n+  \/\/ We allow an exception for the own Method, but require it's class to be permanent.\n+  Method* own_method = nm->method();\n+  CheckForMetadataClosure cfm(\/* ignore reference to own Method *\/ own_method);\n+  nm->metadata_do(&cfm);\n+  assert(!cfm.found_metadata(), \"no metadata allowed\");\n+\n+  assert(own_method->method_holder()->class_loader_data()->is_permanent_class_loader_data(),\n+         \"Method's class needs to be permanent\");\n+}\n+#endif\n+\n@@ -503,15 +523,2 @@\n-#ifdef ASSERT\n-    \/\/ Allocating in NonNMethod space is only for special nmethods which don't\n-    \/\/ need to be findable by nmethod iterators.\n-    \/\/ GC may not look for Oops, there.\n-    if (allow_NonNMethod_space) {\n-      assert(oop_maps == nullptr, \"expectation\");\n-      CheckForOopsClosure cfo;\n-      nm->oops_do(&cfo);\n-      assert(!cfo.found_oop(), \"no oops allowed\");\n-      CheckForMetadataClosure cfm(\/* ignore reference to own Method *\/ nm->method());\n-      nm->metadata_do(&cfm);\n-      assert(!cfm.found_metadata(), \"no metadata allowed\");\n-    }\n-#endif\n-    NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));\n+    DEBUG_ONLY( if (allow_NonNMethod_space) assert_no_oops_or_metadata(nm); )\n+    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"}]}