{"files":[{"patch":"@@ -454,0 +454,36 @@\n+#ifdef ASSERT\n+class CheckForOopsClosure : public OopClosure {\n+  bool _found_oop = false;\n+ public:\n+  virtual void do_oop(oop* o) { _found_oop = true; }\n+  virtual void do_oop(narrowOop* o) { _found_oop = true; }\n+  bool found_oop() { return _found_oop; }\n+};\n+class CheckForMetadataClosure : public MetadataClosure {\n+  bool _found_metadata = false;\n+  Metadata* _ignore = nullptr;\n+ public:\n+  CheckForMetadataClosure(Metadata* ignore) : _ignore(ignore) {}\n+  virtual void do_metadata(Metadata* md) { if (md != _ignore) _found_metadata = true; }\n+  bool found_metadata() { return _found_metadata; }\n+};\n+\n+static void assert_no_oops_or_metadata(nmethod* nm) {\n+  if (nm == nullptr) return;\n+  assert(nm->oop_maps() == nullptr, \"expectation\");\n+\n+  CheckForOopsClosure cfo;\n+  nm->oops_do(&cfo);\n+  assert(!cfo.found_oop(), \"no oops allowed\");\n+\n+  \/\/ We allow an exception for the own Method, but require its class to be permanent.\n+  Method* own_method = nm->method();\n+  CheckForMetadataClosure cfm(\/* ignore reference to own Method *\/ own_method);\n+  nm->metadata_do(&cfm);\n+  assert(!cfm.found_metadata(), \"no metadata allowed\");\n+\n+  assert(own_method->method_holder()->class_loader_data()->is_permanent_class_loader_data(),\n+         \"Method's class needs to be permanent\");\n+}\n+#endif\n+\n@@ -477,1 +513,4 @@\n-    nm = new (native_nmethod_size, CompLevel_none)\n+\n+    \/\/ MH intrinsics are dispatch stubs which are compatible with NonNMethod space.\n+    bool allow_NonNMethod_space = method->is_method_handle_intrinsic();\n+    nm = new (native_nmethod_size, allow_NonNMethod_space)\n@@ -484,1 +523,2 @@\n-    NOT_PRODUCT(if (nm != NULL)  native_nmethod_stats.note_native_nmethod(nm));\n+    DEBUG_ONLY( if (allow_NonNMethod_space) assert_no_oops_or_metadata(nm); )\n+    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n@@ -719,0 +759,8 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw () {\n+  \/\/ Try MethodNonProfiled and MethodProfiled.\n+  void* return_value = CodeCache::allocate(nmethod_size, CodeBlobType::MethodNonProfiled);\n+  if (return_value != nullptr || !allow_NonNMethod_space) return return_value;\n+  \/\/ Try NonNMethod or give up.\n+  return CodeCache::allocate(nmethod_size, CodeBlobType::NonNMethod);\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -301,0 +301,4 @@\n+  \/\/ For method handle intrinsics: Try MethodNonProfiled, MethodProfiled and NonNMethod.\n+  \/\/ Attention: Only allow NonNMethod space for special nmethods which don't need to be\n+  \/\/ findable by nmethod iterators! In particular, they must not contain oops!\n+  void* operator new(size_t size, int nmethod_size, bool allow_NonNMethod_space) throw();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -33,0 +34,5 @@\n+  if (cm->method()->method_holder()->class_loader_data()->is_permanent_class_loader_data()) {\n+    \/\/ When the nmethod is in NonNMethod space, we may reach here without IsUnloadingBehaviour.\n+    \/\/ We only allow this for permenent methods which never get unloaded.\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcBehaviours.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}