{"files":[{"patch":"@@ -718,1 +718,1 @@\n-    private static void signAppBundle(\n+    static void signAppBundle(\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,6 @@\n+                \/\/ We need to re-sign app image after adding \".package\" to it.\n+                \/\/ We only do this if app image was not signed which means it is\n+                \/\/ signed with ad-hoc signature. App bundles with ad-hoc\n+                \/\/ signature are sealed, but without a signing identity, so we\n+                \/\/ need to re-sign it after modification.\n+                MacAppImageBuilder.signAppBundle(params, appDir, \"-\", null, null);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-        SigningBase.verifyCodesign(outputBundle, false);\n+        SigningBase.verifyDMG(outputBundle);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-        SigningBase.verifyCodesign(outputBundle, false);\n+        SigningBase.verifyDMG(outputBundle);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -83,1 +83,1 @@\n-        SigningBase.verifyCodesign(outputBundle, false);\n+        SigningBase.verifyDMG(outputBundle);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,10 @@\n+    \/\/ Note: It is not clear if we can combine \"--verify\" and \"--display\", so\n+    \/\/ we testing them separately. Since JDK-8298488 unsigned app images are\n+    \/\/ actually signed with adhoc signature and it will pass \"--verify\", so in\n+    \/\/ addition we will check certificate name which was used to sign.\n+    private static enum CodesignCheckType {\n+        VERIFY, \/\/ Runs codesign with \"--verify\" to check signature and 0 exit code\n+        VERIFY_UNSIGNED, \/\/ Runs codesign with \"--verify\" to check signature and 1 exit code\n+        DISPLAY \/\/ Runs codesign with \"--display --verbose=4\" to get info about signature\n+    };\n+\n@@ -52,10 +62,18 @@\n-    private static List<String> codesignResult(Path target, boolean signed) {\n-        int exitCode = signed ? 0 : 1;\n-        List<String> result = new Executor()\n-                .setExecutable(\"\/usr\/bin\/codesign\")\n-                .addArguments(\"--verify\", \"--deep\", \"--strict\", \"--verbose=2\",\n-                        target.toString())\n-                .saveOutput()\n-                .execute(exitCode).getOutput();\n-\n-        return result;\n+    private static List<String> codesignResult(Path target, CodesignCheckType type) {\n+        int exitCode = 0;\n+        Executor executor = new Executor().setExecutable(\"\/usr\/bin\/codesign\");\n+        switch (type) {\n+            case CodesignCheckType.VERIFY_UNSIGNED:\n+                exitCode = 1;\n+            case CodesignCheckType.VERIFY:\n+                executor.addArguments(\"--verify\", \"--deep\", \"--strict\",\n+                                      \"--verbose=2\", target.toString());\n+                break;\n+            case CodesignCheckType.DISPLAY:\n+                executor.addArguments(\"--display\", \"--verbose=4\", target.toString());\n+                break;\n+            default:\n+                TKit.error(\"Unknown CodesignCheckType: \" + type);\n+                break;\n+        }\n+        return executor.saveOutput().execute(exitCode).getOutput();\n@@ -65,1 +83,1 @@\n-            boolean signed) {\n+            boolean signed, CodesignCheckType type) {\n@@ -67,9 +85,23 @@\n-        if (signed) {\n-            String lookupString = target.toString() + \": valid on disk\";\n-            checkString(result, lookupString);\n-            lookupString = target.toString() + \": satisfies its Designated Requirement\";\n-            checkString(result, lookupString);\n-        } else {\n-            String lookupString = target.toString()\n-                    + \": code object is not signed at all\";\n-            checkString(result, lookupString);\n+        String lookupString;\n+        switch (type) {\n+            case CodesignCheckType.VERIFY:\n+                lookupString = target.toString() + \": valid on disk\";\n+                checkString(result, lookupString);\n+                lookupString = target.toString() + \": satisfies its Designated Requirement\";\n+                checkString(result, lookupString);\n+                break;\n+            case CodesignCheckType.VERIFY_UNSIGNED:\n+                lookupString = target.toString() + \": code object is not signed at all\";\n+                checkString(result, lookupString);\n+                break;\n+            case CodesignCheckType.DISPLAY:\n+                if (signed) {\n+                    lookupString = \"Authority=\" + APP_CERT;\n+                } else {\n+                    lookupString = \"Signature=adhoc\";\n+                }\n+                checkString(result, lookupString);\n+                break;\n+            default:\n+                TKit.error(\"Unknown CodesignCheckType: \" + type);\n+                break;\n@@ -135,2 +167,18 @@\n-        List<String> result = codesignResult(target, signed);\n-        verifyCodesignResult(result, target, signed);\n+        List<String> result = codesignResult(target, CodesignCheckType.VERIFY);\n+        verifyCodesignResult(result, target, signed, CodesignCheckType.VERIFY);\n+\n+        result = codesignResult(target, CodesignCheckType.DISPLAY);\n+        verifyCodesignResult(result, target, signed, CodesignCheckType.DISPLAY);\n+    }\n+\n+    \/\/ Since we no longer have unsigned app image, but we need to check\n+    \/\/ DMG which is not adhoc or certificate signed and we cannot use verifyCodesign\n+    \/\/ for this. verifyDMG() is introduced to check that DMG is unsigned.\n+    \/\/ Should not be used to validated anything else.\n+    public static void verifyDMG(Path target) {\n+        if (!target.toString().toLowerCase().endsWith(\".dmg\")) {\n+            TKit.error(\"Unexpected target: \" + target);\n+        }\n+\n+        List<String> result = codesignResult(target, CodesignCheckType.VERIFY_UNSIGNED);\n+        verifyCodesignResult(result, target, false, CodesignCheckType.VERIFY_UNSIGNED);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":71,"deletions":23,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-            \/\/ On macOS aarch64 we always signing app image and signing will fail, since\n+            \/\/ On macOS we always signing app image and signing will fail, since\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,5 @@\n-        }).run(Action.CREATE, Action.UNPACK);\n+        })\n+        \/\/ On macOS we always signing app image and signing will fail, since\n+        \/\/ test produces invalid app bundle.\n+        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)\n+        .run(Action.CREATE, Action.UNPACK);\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}