{"files":[{"patch":"@@ -28,0 +28,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -36,0 +38,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -47,0 +51,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -57,0 +63,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -67,0 +75,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -77,0 +87,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -85,2 +97,1 @@\n-import java.util.Set;\n-import java.util.HashSet;\n+import java.util.LinkedList;\n@@ -91,0 +102,3 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n+\n@@ -96,1 +110,1 @@\n-    private static Set<Range> ranges = new HashSet<>();\n+    private static LinkedList<RangeWithPageSize> ranges = new LinkedList<>();\n@@ -103,4 +117,1 @@\n-    \/\/ will generate a match. The order of KernelPageSize and\n-    \/\/ AnonHugePages can be different, so we need to match the block\n-    \/\/ body first, assuming VmFlags are the last, and then parse out\n-    \/\/ the individual fields out of it.\n+    \/\/ will generate a match.\n@@ -108,6 +119,4 @@\n-        Pattern blockPatt = Pattern.compile(\"(\\\\w+)-(\\\\w+)(.*?)\" +\n-                                            \"VmFlags: ([\\\\w ]*)\", Pattern.DOTALL);\n-        Pattern psPatt  = Pattern.compile(\".*KernelPageSize:\\\\s*(\\\\d*) kB.*?\", Pattern.DOTALL);\n-        Pattern ahpPatt = Pattern.compile(\".*AnonHugePages:\\\\s*(\\\\d*).*?\", Pattern.DOTALL);\n-\n-        \/\/ Find all memory segments in the smaps-file with pattern 1\n+        String smapsPatternString = \"(\\\\w+)-(\\\\w+).*?\" +\n+                                    \"KernelPageSize:\\\\s*(\\\\d*) kB.*?\" +\n+                                    \"VmFlags: ([\\\\w ]*)\";\n+        Pattern smapsPattern = Pattern.compile(smapsPatternString, Pattern.DOTALL);\n@@ -115,1 +124,2 @@\n-        smapsScanner.findAll(blockPatt).forEach(mr -> {\n+        \/\/ Find all memory segments in the smaps-file.\n+        smapsScanner.findAll(smapsPattern).forEach(mr -> {\n@@ -118,1 +128,1 @@\n-            String body = mr.group(3);\n+            String ps = mr.group(3);\n@@ -121,16 +131,0 @@\n-            String ps = null;\n-            Matcher psMatcher = psPatt.matcher(body);\n-            if (psMatcher.matches()) {\n-                ps = psMatcher.group(1);\n-            } else {\n-                throw new IllegalStateException(\"Cannot parse page size out of \" + body);\n-            }\n-\n-            String ahp = null;\n-            Matcher ahpMatcher = ahpPatt.matcher(body);\n-            if (ahpMatcher.matches()) {\n-                ahp = ahpMatcher.group(1);\n-            } else {\n-                throw new IllegalStateException(\"Cannot parse anon huge pages out of \" + body);\n-            }\n-\n@@ -138,1 +132,1 @@\n-            Range range = new Range(start, end, ahp, ps, vmFlags);\n+            RangeWithPageSize range = new RangeWithPageSize(start, end, ps, vmFlags);\n@@ -146,1 +140,1 @@\n-    private static Range getRange(String addr) {\n+    private static RangeWithPageSize getRange(String addr) {\n@@ -148,1 +142,1 @@\n-        for (Range range : ranges) {\n+        for (RangeWithPageSize range : ranges) {\n@@ -185,0 +179,5 @@\n+        \/\/ Older kernels do not have reliable madvise tag for this test to work\n+        if (Platform.isLinux() && Platform.getOsVersionMajor() <= 4) {\n+            throw new SkippedException(\"Skipped for kernel: \" + Platform.getOsVersion());\n+        }\n+\n@@ -203,1 +202,1 @@\n-                Range range = getRange(address);\n+                RangeWithPageSize range = getRange(address);\n@@ -246,1 +245,0 @@\n-\/\/ AnonHugePages:         4096\n@@ -252,3 +250,0 @@\n-\/\/ Unfortunately, old kernels do not print the madvise flag.\n-\/\/ To handle that case, we need to check for non-zero AnonHugePages.\n-\/\/\n@@ -257,5 +252,4 @@\n-class Range {\n-    private final long start;\n-    private final long end;\n-    private final long anonHugePages;\n-    private final long pageSize;\n+class RangeWithPageSize {\n+    private long start;\n+    private long end;\n+    private long pageSize;\n@@ -265,1 +259,1 @@\n-    public Range(String start, String end, String anonHugePages, String pageSize, String vmFlags) {\n+    public RangeWithPageSize(String start, String end, String pageSize, String vmFlags) {\n@@ -268,1 +262,0 @@\n-        this.anonHugePages = Long.parseLong(anonHugePages);\n@@ -290,1 +283,1 @@\n-        return vmFlagHG || (!vmFlagHT && anonHugePages > 0);\n+        return vmFlagHG;\n@@ -303,13 +296,1 @@\n-               \"anonHugePages = \" + anonHugePages + \" pageSize=\" + pageSize +\n-               \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n-    }\n-\n-    public int hashCode() {\n-        return (int)(start ^ end);\n-    }\n-\n-    public boolean equals(Object o) {\n-        Range r = ((Range) o);\n-        if (start != r.start) return false;\n-        if (end != r.end) return false;\n-        return true;\n+               \"pageSize=\" + pageSize + \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":41,"deletions":60,"binary":false,"changes":101,"status":"modified"}]}