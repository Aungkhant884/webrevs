{"files":[{"patch":"@@ -85,1 +85,2 @@\n-import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.HashSet;\n@@ -95,1 +96,1 @@\n-    private static LinkedList<RangeWithPageSize> ranges = new LinkedList<>();\n+    private static Set<Range> ranges = new HashSet<>();\n@@ -102,1 +103,4 @@\n-    \/\/ will generate a match.\n+    \/\/ will generate a match. The order of KernelPageSize and\n+    \/\/ AnonHugePages can be different, so we need to match the block\n+    \/\/ body first, assuming VmFlags are the last, and then parse out\n+    \/\/ the individual fields out of it.\n@@ -104,4 +108,6 @@\n-        String smapsPatternString = \"(\\\\w+)-(\\\\w+).*?\" +\n-                                    \"KernelPageSize:\\\\s*(\\\\d*) kB.*?\" +\n-                                    \"VmFlags: ([\\\\w ]*)\";\n-        Pattern smapsPattern = Pattern.compile(smapsPatternString, Pattern.DOTALL);\n+        Pattern blockPatt = Pattern.compile(\"(\\\\w+)-(\\\\w+)(.*?)\" +\n+                                            \"VmFlags: ([\\\\w ]*)\", Pattern.DOTALL);\n+        Pattern psPatt  = Pattern.compile(\".*KernelPageSize:\\\\s*(\\\\d*) kB.*?\", Pattern.DOTALL);\n+        Pattern ahpPatt = Pattern.compile(\".*AnonHugePages:\\\\s*(\\\\d*).*?\", Pattern.DOTALL);\n+\n+        \/\/ Find all memory segments in the smaps-file with pattern 1\n@@ -109,2 +115,1 @@\n-        \/\/ Find all memory segments in the smaps-file.\n-        smapsScanner.findAll(smapsPattern).forEach(mr -> {\n+        smapsScanner.findAll(blockPatt).forEach(mr -> {\n@@ -113,1 +118,1 @@\n-            String ps = mr.group(3);\n+            String body = mr.group(3);\n@@ -116,0 +121,16 @@\n+            String ps = null;\n+            Matcher psMatcher = psPatt.matcher(body);\n+            if (psMatcher.matches()) {\n+                ps = psMatcher.group(1);\n+            } else {\n+                throw new IllegalStateException(\"Cannot parse page size out of \" + body);\n+            }\n+\n+            String ahp = null;\n+            Matcher ahpMatcher = ahpPatt.matcher(body);\n+            if (ahpMatcher.matches()) {\n+                ahp = ahpMatcher.group(1);\n+            } else {\n+                throw new IllegalStateException(\"Cannot parse anon huge pages out of \" + body);\n+            }\n+\n@@ -117,1 +138,1 @@\n-            RangeWithPageSize range = new RangeWithPageSize(start, end, ps, vmFlags);\n+            Range range = new Range(start, end, ahp, ps, vmFlags);\n@@ -125,1 +146,1 @@\n-    private static RangeWithPageSize getRange(String addr) {\n+    private static Range getRange(String addr) {\n@@ -127,1 +148,1 @@\n-        for (RangeWithPageSize range : ranges) {\n+        for (Range range : ranges) {\n@@ -182,1 +203,1 @@\n-                RangeWithPageSize range = getRange(address);\n+                Range range = getRange(address);\n@@ -225,0 +246,1 @@\n+\/\/ AnonHugePages:         4096\n@@ -230,0 +252,3 @@\n+\/\/ Unfortunately, old kernels do not print the madvise flag.\n+\/\/ To handle that case, we need to check for non-zero AnonHugePages.\n+\/\/\n@@ -232,4 +257,5 @@\n-class RangeWithPageSize {\n-    private long start;\n-    private long end;\n-    private long pageSize;\n+class Range {\n+    private final long start;\n+    private final long end;\n+    private final long anonHugePages;\n+    private final long pageSize;\n@@ -239,1 +265,1 @@\n-    public RangeWithPageSize(String start, String end, String pageSize, String vmFlags) {\n+    public Range(String start, String end, String anonHugePages, String pageSize, String vmFlags) {\n@@ -242,0 +268,1 @@\n+        this.anonHugePages = Long.parseLong(anonHugePages);\n@@ -263,1 +290,1 @@\n-        return vmFlagHG;\n+        return vmFlagHG || (!vmFlagHT && anonHugePages > 0);\n@@ -276,1 +303,2 @@\n-               \"pageSize=\" + pageSize + \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n+               \"anonHugePages = \" + anonHugePages + \" pageSize=\" + pageSize +\n+               \"KB isTHP=\" + vmFlagHG + \" isHUGETLB=\" + vmFlagHT;\n@@ -278,1 +306,12 @@\n-}\n\\ No newline at end of file\n+\n+    public int hashCode() {\n+        return (int)(start ^ end);\n+    }\n+\n+    public boolean equals(Object o) {\n+        Range r = ((Range) o);\n+        if (start != r.start) return false;\n+        if (end != r.end) return false;\n+        return true;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":61,"deletions":22,"binary":false,"changes":83,"status":"modified"}]}