{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.AbstractMap;\n@@ -31,0 +32,1 @@\n+import java.util.Map;\n@@ -42,2 +44,21 @@\n-    private static final ThreadLocal<BufferReference[]> CACHE =\n-        new ThreadLocal<BufferReference[]>() {\n+\n+    \/*\n+     * We used to have a class BufferReference extending from WeakReference<ByteBuffer>.\n+     * BufferReference class had an  instance field called \"capacity\". This field was\n+     * used to make DECREASING_CAPACITY_NULLS_LAST comparator stable in the presence\n+     * of GC clearing the WeakReference concurrently.\n+     *\n+     * But this scheme results in metaspace leak. The thread local is alive till the\n+     * the thread is alive. And so ImageBufferCache$BufferReference class was kept alive.\n+     * Because this class and ImageBufferCache$BufferReference are all loaded by a URL\n+     * class loader from jrt-fs.jar, the class loader and so all the classes loaded by it\n+     * were alive!\n+     *\n+     * Solution is to avoid using a URL loader loaded class type with thread local. All we\n+     * need is a pair of WeakReference<ByteBuffer>, Integer (saved capacity for stability\n+     * of comparator). We use Map.Entry as pair implementation. With this, all types used\n+     * with thread local are bootstrap types and so no metaspace leak.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ThreadLocal<Map.Entry<WeakReference<ByteBuffer>, Integer>[]> CACHE =\n+        new ThreadLocal<Map.Entry<WeakReference<ByteBuffer>, Integer>[]>() {\n@@ -45,1 +66,1 @@\n-            protected BufferReference[] initialValue() {\n+            protected Map.Entry<WeakReference<ByteBuffer>, Integer>[] initialValue() {\n@@ -47,1 +68,1 @@\n-                return new BufferReference[MAX_CACHED_BUFFERS + 1];\n+                return (Map.Entry<WeakReference<ByteBuffer>, Integer>[])new Map.Entry<?,?>[MAX_CACHED_BUFFERS + 1];\n@@ -65,1 +86,1 @@\n-            BufferReference[] cache = CACHE.get();\n+            Map.Entry<WeakReference<ByteBuffer>, Integer>[] cache = CACHE.get();\n@@ -70,1 +91,1 @@\n-                BufferReference reference = cache[i];\n+                Map.Entry<WeakReference<ByteBuffer>, Integer> reference = cache[i];\n@@ -73,1 +94,1 @@\n-                    ByteBuffer buffer = reference.get();\n+                    ByteBuffer buffer = getByteBuffer(reference);\n@@ -99,1 +120,1 @@\n-        BufferReference[] cache = CACHE.get();\n+        Map.Entry<WeakReference<ByteBuffer>, Integer>[] cache = CACHE.get();\n@@ -103,2 +124,2 @@\n-            BufferReference reference = cache[i];\n-            if (reference != null && reference.get() == null) {\n+            Map.Entry<WeakReference<ByteBuffer>, Integer> reference = cache[i];\n+            if (reference != null && getByteBuffer(reference) == null) {\n@@ -110,1 +131,1 @@\n-        cache[MAX_CACHED_BUFFERS] = new BufferReference(buffer);\n+        cache[MAX_CACHED_BUFFERS] = newCacheEntry(buffer);\n@@ -116,8 +137,4 @@\n-    private static Comparator<BufferReference> DECREASING_CAPACITY_NULLS_LAST =\n-        new Comparator<BufferReference>() {\n-            @Override\n-            public int compare(BufferReference br1, BufferReference br2) {\n-                return Integer.compare(br2 == null ? 0 : br2.capacity,\n-                                       br1 == null ? 0 : br1.capacity);\n-            }\n-        };\n+    private static Map.Entry<WeakReference<ByteBuffer>, Integer> newCacheEntry(ByteBuffer bb) {\n+        return new AbstractMap.SimpleEntry<WeakReference<ByteBuffer>, Integer>(\n+                    new WeakReference<ByteBuffer>(bb), bb.capacity());\n+    }\n@@ -125,4 +142,3 @@\n-    private static class BufferReference extends WeakReference<ByteBuffer> {\n-        \/\/ saved capacity so that DECREASING_CAPACITY_NULLS_LAST comparator\n-        \/\/ is stable in the presence of GC clearing the WeakReference concurrently\n-        final int capacity;\n+    private static int getCapacity(Map.Entry<WeakReference<ByteBuffer>, Integer> e) {\n+        return e == null? 0 : e.getValue();\n+    }\n@@ -130,4 +146,2 @@\n-        BufferReference(ByteBuffer buffer) {\n-            super(buffer);\n-            capacity = buffer.capacity();\n-        }\n+    private static ByteBuffer getByteBuffer(Map.Entry<WeakReference<ByteBuffer>, Integer> e) {\n+        return e == null? null : e.getKey().get();\n@@ -135,0 +149,9 @@\n+\n+    private static Comparator<Map.Entry<WeakReference<ByteBuffer>, Integer>> DECREASING_CAPACITY_NULLS_LAST =\n+        new Comparator<Map.Entry<WeakReference<ByteBuffer>, Integer>>() {\n+            @Override\n+            public int compare(Map.Entry<WeakReference<ByteBuffer>, Integer> br1,\n+                        Map.Entry<WeakReference<ByteBuffer>, Integer> br2) {\n+                return Integer.compare(getCapacity(br1), getCapacity(br2));\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageBufferCache.java","additions":50,"deletions":27,"binary":false,"changes":77,"status":"modified"}]}