{"files":[{"patch":"@@ -102,0 +102,22 @@\n+ * <h2><a id=Ieee754RecommendedOps>IEEE 754 Recommended\n+ * Operations<\/a><\/h2>\n+ *\n+ * The 2019 revision of the IEEE 754 floating-point standard includes\n+ * a section of recommended operations and the semantics of those\n+ * operations if they are included in a programming environment. The\n+ * recommended operations present in this class include {@link sin\n+ * sin}, {@link cos cos}, {@link tan tan}, {@link asin asin}, {@link\n+ * acos acos}, {@link atan atan}, {@link exp exp}, {@link expm1\n+ * expm1}, {@link log log}, {@link log10 log10}, {@link log1p log1p},\n+ * {@link sinh sinh}, {@link cosh cosh}, {@link tanh tanh}, {@link\n+ * hypot hypot}, and {@link pow pow}.  (The {@link sqrt sqrt}\n+ * operation is a required part of IEEE 754 from a different section\n+ * of the standard.) The special case behavior of the recommended\n+ * operations generally follows the guidance of the IEEE 754\n+ * standard. However, the {@code pow} method defines different\n+ * behavior for some arguments, as noted in its {@linkplain pow\n+ * specification}. The IEEE 754 standard defines its operations to be\n+ * correctly rounded, which is a more stringent quality of\n+ * implementation condition than required for most of the methods in\n+ * question that are also included in this class.\n+ *\n@@ -159,1 +181,3 @@\n-     * result is NaN.<\/ul>\n+     * result is NaN.\n+     * <li>If the argument is zero, then the result is {@code 1.0}.\n+     *<\/ul>\n@@ -212,1 +236,5 @@\n-     * than 1, then the result is NaN.<\/ul>\n+     * than 1, then the result is NaN.\n+     * <li>If the argument is {@code 1.0}, the result is {@code +0.0}.\n+     * <li>If the argument is {@linkplain Double#isInfinite infinite},\n+     * the result is the value closest to <i>pi<\/i>\/2.\n+     * <\/ul>\n@@ -229,1 +257,5 @@\n-     * same sign as the argument.<\/ul>\n+     * same sign as the argument.\n+     * <li>If the argument is {@linkplain Double#isInfinite infinite},\n+     * then the result is <i>pi<\/i>\/2, rounded, with the same sign as\n+     * the input.\n+     * <\/ul>\n@@ -278,1 +310,3 @@\n-     * positive zero.<\/ul>\n+     * positive zero.\n+     * <li>If the argument is zero, then the result is {@code 1.0}.\n+     * <\/ul>\n@@ -300,1 +334,3 @@\n-     * result is negative infinity.<\/ul>\n+     * result is negative infinity.\n+     * <li>If the argument is {@code 1.0}, then the result is positive\n+     * zero.<\/ul>\n@@ -324,2 +360,4 @@\n-     * <li> If the argument is equal to 10<sup><i>n<\/i><\/sup> for\n-     * integer <i>n<\/i>, then the result is <i>n<\/i>.\n+     * <li>If the argument is equal to 10<sup><i>n<\/i><\/sup> for\n+     * integer <i>n<\/i>, then the result is <i>n<\/i>. In particular,\n+     * if the argument is {@code 1.0} (10<sup>0<\/sup>), then the\n+     * result is positive zero.\n@@ -532,0 +570,9 @@\n+     * @apiNote\n+     * For <i>y<\/i> with a positive sign and finite nonzero\n+     * <i>x<\/i>, the exact mathematical value of {@code atan2} is\n+     * equal to:\n+     * <ul>\n+     * <li>If <i>x<\/i> {@literal >} 0, atan(abs(<i>y<\/i>\/<i>x<\/i>))\n+     * <li>If <i>x<\/i> {@literal <} 0, &pi; - atan(abs(<i>y<\/i>\/<i>x<\/i>))\n+     * <\/ul>\n+     *\n@@ -663,0 +710,10 @@\n+     * @apiNote\n+     * The special cases definitions of this method differ from the\n+     * special case definitions of the IEEE 754 recommended {@code\n+     * pow} operation for &plusmn;{@code 1.0} raised to an infinite\n+     * power. This method treats such cases as indeterminate and\n+     * specifies a NaN is returned. The IEEE 754 specification treats\n+     * the infinite power as a large integer (large-magnitude\n+     * floating-point numbers are numerically integers, specifically\n+     * even integer) and therefore specifies {@code 1.0} be returned.\n+     *\n@@ -2116,0 +2173,1 @@\n+     * <li> If both arguments are zero, the result is positive zero.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -77,0 +77,9 @@\n+ * <h2><a id=Ieee754RecommendedOps>IEEE 754 Recommended\n+ * Operations<\/a><\/h2>\n+ *\n+ * The {@code Math} class discusses how the shared quality of\n+ * implementation criteria for selected {@code Math} and {@code\n+ * StrictMath} methods <a\n+ * href=\"Math.html#Ieee754RecommendedOps\">relate to the IEEE 754\n+ * recommended operations<\/a>.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011,2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8255368\n+ * @bug 8255368 8240632\n@@ -49,0 +49,4 @@\n+\n+           \/\/ Identified special cases in IEEE 754 exp operation\n+           {+0.0,                      1.0},\n+           {-0.0,                      1.0},\n","filename":"test\/jdk\/java\/lang\/Math\/ExpCornerCaseTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 4851638 4939441 8078672\n+ * @bug 4851638 4939441 8078672 8240632\n@@ -201,0 +201,7 @@\n+    \/**\n+     * Verify +0.0 is returned if both arguments are zero.\n+     *\/\n+    private static int testHypotZeros() {\n+        return testHypotCase(0.0, 0.0, +0.0, 0.0);\n+    }\n+\n@@ -240,0 +247,1 @@\n+        failures += testHypotZeros();\n","filename":"test\/jdk\/java\/lang\/Math\/HypotTests.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240632\n+ * @summary Test special cases of IEEE 754 recommended ops not otherwise tested\n+ * @build Tests\n+ * @build WorstCaseTests\n+ * @run main WorstCaseTests\n+ *\/\n+\n+public class Ieee754SpecialCaseTests {\n+    private Ieee754SpecialCaseTests() {throw new AssertionError(\"No instances for you.\");}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testSpecialCos();\n+        failures += testSpecialAcos();\n+        failures += testSpecialAtan();\n+        failures += testSpecialLog();\n+\n+        if (failures > 0) {\n+            System.err.printf(\"Testing special cases incurred %d failures.%n\", failures);\n+            throw new RuntimeException();\n+        }\n+    }\n+    private static int testSpecialCos() {\n+        int failures = 0;\n+        double [][] testCases = {\n+            {+0.0,    1.0},\n+            {-0.0,    1.0},\n+        };\n+\n+        for(double[] testCase: testCases) {\n+            failures += testCosCase(testCase[0], testCase[1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testCosCase(double input, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"Math.cos\",       input, Math.cos(input),       expected);\n+        failures += Tests.test(\"StrictMath.cos\", input, StrictMath.cos(input), expected);\n+        return failures;\n+    }\n+\n+    private static int testSpecialAcos() {\n+        int failures = 0;\n+        double [][] testCases = {\n+            {+0.0,                        1.0},\n+            {-0.0,                        1.0},\n+            {Double.POSITIVE_INFINITY,    Math.PI\/2.0},\n+            {Double.NEGATIVE_INFINITY,    Math.PI\/2.0},\n+        };\n+\n+        for(double[] testCase: testCases) {\n+            failures += testAcosCase(testCase[0], testCase[1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAcosCase(double input, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"Math.acos\",       input, Math.acos(input),       expected);\n+        failures += Tests.test(\"StrictMath.acos\", input, StrictMath.acos(input), expected);\n+        return failures;\n+    }\n+\n+    private static int testSpecialAtan() {\n+        int failures = 0;\n+        double [][] testCases = {\n+            {Double.POSITIVE_INFINITY,    +Math.PI\/2.0},\n+            {Double.NEGATIVE_INFINITY,    -Math.PI\/2.0},\n+        };\n+\n+        for(double[] testCase: testCases) {\n+            failures += testAtanCase(testCase[0], testCase[1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAtanCase(double input, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"Math.atan\",       input, Math.atan(input),       expected);\n+        failures += Tests.test(\"StrictMath.atan\", input, StrictMath.atan(input), expected);\n+        return failures;\n+    }\n+\n+    private static int testSpecialLog() {\n+        int failures = 0;\n+        double [][] testCases = {\n+            {1.0,    +0.0},\n+        };\n+\n+        for(double[] testCase: testCases) {\n+            failures += testLogCase(testCase[0], testCase[1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testLog(double input, double expected) {\n+        int failures = 0;\n+        failures += Tests.test(\"Math.log\",       input, Math.log(input),       expected);\n+        failures += Tests.test(\"StrictMath.log\", input, StrictMath.log(input), expected);\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/Ieee754SpecialCaseTests.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}