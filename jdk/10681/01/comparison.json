{"files":[{"patch":"@@ -37,0 +37,3 @@\n+import java.awt.geom.AffineTransform;\n+\n+import static sun.java2d.pipe.Region.clipRound;\n@@ -147,0 +150,37 @@\n+            AffineTransform at = g2d.getTransform();\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n+            \/\/ or if no Scaling enabled,\n+            \/\/ skip resetting the transform\n+            boolean resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0)) &&\n+                    ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n+\n+            int xtranslation;\n+            int ytranslation;\n+            int w;\n+            int h;\n+            int offs;\n+\n+            if (resetTransform) {\n+                \/* Deactivate the HiDPI scaling transform,\n+                 * so we can do paint operations in the device\n+                 * pixel coordinate system instead of the logical coordinate system.\n+                 *\/\n+                g2d.setTransform(new AffineTransform());\n+                double xx = at.getScaleX() * x + at.getTranslateX();\n+                double yy = at.getScaleY() * y + at.getTranslateY();\n+                xtranslation = clipRound(xx);\n+                ytranslation = clipRound(yy);\n+                w = clipRound(at.getScaleX() * width + xx) - xtranslation;\n+                h = clipRound(at.getScaleY() * height + yy) - ytranslation;\n+                offs = this.thickness * (int) at.getScaleX();\n+            } else {\n+                w = width;\n+                h = height;\n+                xtranslation = x;\n+                ytranslation = y;\n+                offs = this.thickness;\n+            }\n+\n+            g2d.translate(xtranslation, ytranslation);\n+\n@@ -153,1 +193,0 @@\n-            int offs = this.thickness;\n@@ -157,2 +196,2 @@\n-                outer = new RoundRectangle2D.Float(x, y, width, height, offs, offs);\n-                inner = new RoundRectangle2D.Float(x + offs, y + offs, width - size, height - size, arc, arc);\n+                outer = new RoundRectangle2D.Float(0, 0, w, h, offs, offs);\n+                inner = new RoundRectangle2D.Float(offs, offs, w - size, h - size, arc, arc);\n@@ -161,2 +200,2 @@\n-                outer = new Rectangle2D.Float(x, y, width, height);\n-                inner = new Rectangle2D.Float(x + offs, y + offs, width - size, height - size);\n+                outer = new Rectangle2D.Float(0, 0, w, h);\n+                inner = new Rectangle2D.Float(offs, offs, w - size, h - size);\n@@ -169,0 +208,6 @@\n+\n+            g2d.translate(-xtranslation, -ytranslation);\n+\n+            if (resetTransform) {\n+                g2d.setTransform(at);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/LineBorder.java","additions":50,"deletions":5,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8282958\n+ * @summary Verify LineBorder edges have the same width\n+ * @requires (os.family == \"windows\")\n+ * @run main ScaledLineBorderTest\n+ *\/\n+public class ScaledLineBorderTest {\n+    private static final Dimension SIZE = new Dimension(120, 25);\n+\n+    private static final Color OUTER_COLOR = Color.BLACK;\n+    private static final Color BORDER_COLOR = Color.RED;\n+    private static final Color INSIDE_COLOR = Color.WHITE;\n+    private static final Color TRANSPARENT_COLOR = new Color(0x00000000, true);\n+\n+    private static final double[] scales =\n+            {1.00, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00};\n+\n+    private static final List<BufferedImage> images =\n+            new ArrayList<>(scales.length);\n+\n+    private static final List<Point> panelLocations =\n+            new ArrayList<>(4);\n+\n+    public static void main(String[] args) throws Exception {\n+        Collection<String> params = Arrays.asList(args);\n+        final boolean showFrame = params.contains(\"-show\");\n+        final boolean saveImages = params.contains(\"-save\");\n+        SwingUtilities.invokeAndWait(() -> testScaling(showFrame, saveImages));\n+    }\n+\n+    private static void testScaling(boolean showFrame, boolean saveImages) {\n+        JComponent content = createUI();\n+        if (showFrame) {\n+            showFrame(content);\n+        }\n+\n+        paintToImages(content, saveImages);\n+        verifyBorderRendering(saveImages);\n+    }\n+\n+    private static void verifyBorderRendering(final boolean saveImages) {\n+        String errorMessage = null;\n+        int errorCount = 0;\n+        for (int i = 0; i < images.size(); i++) {\n+            BufferedImage img = images.get(i);\n+            double scaling = scales[i];\n+            try {\n+                int thickness = (int) Math.floor(scaling);\n+\n+                checkVerticalBorders(SIZE.width \/ 2, thickness, img);\n+\n+                for (Point p : panelLocations) {\n+                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n+                    checkHorizontalBorder(y, thickness, img);\n+                }\n+            } catch (Error e) {\n+                if (errorMessage == null) {\n+                    errorMessage = e.getMessage();\n+                }\n+                errorCount++;\n+\n+                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                e.printStackTrace();\n+\n+                \/\/ Save the image if it wasn't already saved\n+                if (!saveImages) {\n+                    saveImage(img, getImageFileName(scaling));\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                    + errorCount + \" error(s) detected - \"\n+                    + errorMessage);\n+        }\n+    }\n+\n+    private static void checkVerticalBorders(final int x,\n+                                             final int thickness,\n+                                             final BufferedImage img) {\n+        checkBorder(x, 0,\n+                0, 1,\n+                thickness, img);\n+    }\n+\n+    private static void checkHorizontalBorder(final int y,\n+                                              final int thickness,\n+                                              final BufferedImage img) {\n+        checkBorder(0, y,\n+                1, 0,\n+                thickness, img);\n+    }\n+\n+    private static void checkBorder(final int xStart, final int yStart,\n+                                    final int xStep,  final int yStep,\n+                                    final int thickness,\n+                                    final BufferedImage img) {\n+        final int width = img.getWidth();\n+        final int height = img.getHeight();\n+\n+        State state = State.BACKGROUND;\n+        int borderThickness = 0;\n+\n+        int x = xStart;\n+        int y = yStart;\n+        do {\n+            do {\n+                final int color = img.getRGB(x, y);\n+                switch (state) {\n+                    case BACKGROUND:\n+                        if (color == BORDER_COLOR.getRGB()) {\n+                            state = State.LEFT;\n+                            borderThickness = 1;\n+                        } else if (color != OUTER_COLOR.getRGB()\n+                                && color != TRANSPARENT_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT:\n+                        if (color == BORDER_COLOR.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == INSIDE_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            state = State.INSIDE;\n+                            borderThickness = 0;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case INSIDE:\n+                        if (color == BORDER_COLOR.getRGB()) {\n+                            state = State.RIGHT;\n+                            borderThickness = 1;\n+                        } else if (color != INSIDE_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT:\n+                        if (color == BORDER_COLOR.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == OUTER_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            state = State.BACKGROUND;\n+                            borderThickness = 0;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                }\n+            } while (yStep > 0 && ((y += yStep) < height));\n+        } while (xStep > 0 && ((x += xStep) < width));\n+    }\n+\n+    private enum State {\n+        BACKGROUND, LEFT, INSIDE, RIGHT\n+    }\n+\n+    private static void throwWrongThickness(int thickness, int borderThickness,\n+                                            int x, int y) {\n+        throw new Error(\n+                String.format(\"Wrong border thickness at %d, %d: %d vs %d\",\n+                        x, y, borderThickness, thickness));\n+    }\n+\n+    private static void throwUnexpectedColor(int x, int y, int color) {\n+        throw new Error(\n+                String.format(\"Unexpected color at %d, %d: %08x\",\n+                        x, y, color));\n+    }\n+\n+    private static JComponent createUI() {\n+        Box contentPanel = Box.createVerticalBox();\n+        contentPanel.setBackground(OUTER_COLOR);\n+\n+        Dimension childSize = null;\n+        for (int i = 0; i < 4; i++) {\n+            JComponent filler = new JPanel(null);\n+            filler.setBackground(INSIDE_COLOR);\n+            filler.setPreferredSize(SIZE);\n+            filler.setBounds(i, 0, SIZE.width, SIZE.height);\n+            filler.setBorder(BorderFactory.createLineBorder(BORDER_COLOR));\n+\n+            JPanel childPanel = new JPanel(new BorderLayout());\n+            childPanel.setBorder(BorderFactory.createEmptyBorder(0, i, 4, 4));\n+            childPanel.add(filler, BorderLayout.CENTER);\n+            childPanel.setBackground(OUTER_COLOR);\n+\n+            contentPanel.add(childPanel);\n+            if (childSize == null) {\n+                childSize = childPanel.getPreferredSize();\n+            }\n+            childPanel.setBounds(0, childSize.height * i, childSize.width, childSize.height);\n+        }\n+\n+        contentPanel.setSize(childSize.width, childSize.height * 4);\n+\n+        \/\/ Save coordinates of the panels\n+        for (Component comp : contentPanel.getComponents()) {\n+            panelLocations.add(comp.getLocation());\n+        }\n+\n+        return contentPanel;\n+    }\n+\n+    private static void showFrame(JComponent content) {\n+        JFrame frame = new JFrame(\"Scaled Line Border Test\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.getContentPane().add(content, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void paintToImages(final JComponent content,\n+                                      final boolean saveImages) {\n+        for (double scaling : scales) {\n+            BufferedImage image =\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n+                            (int) Math.ceil(content.getHeight() * scaling),\n+                            BufferedImage.TYPE_INT_ARGB);\n+\n+            Graphics2D g2d = image.createGraphics();\n+            g2d.scale(scaling, scaling);\n+            content.paint(g2d);\n+            g2d.dispose();\n+\n+            if (saveImages) {\n+                saveImage(image, getImageFileName(scaling));\n+            }\n+            images.add(image);\n+        }\n+    }\n+\n+    private static String getImageFileName(final double scaling) {\n+        return String.format(\"test%.2f.png\", scaling);\n+    }\n+\n+    private static void saveImage(BufferedImage image, String filename) {\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (IOException e) {\n+            \/\/ Don't propagate the exception\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledLineBorderTest.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.border.LineBorder;\n+\n+\/*\n+ * @test\n+ * @bug 8282958\n+ * @summary Verify all the borders are rendered consistently for a JTextField\n+ *          in Windows LaF which uses LineBorder\n+ * @requires (os.family == \"windows\")\n+ * @run main ScaledTextFieldBorderTest\n+ *\/\n+public class ScaledTextFieldBorderTest {\n+\n+    private static final double[] scales = {\n+            1.00, 1.25, 1.50, 1.75,\n+            2.00, 2.25, 2.50, 2.75,\n+            3.00\n+    };\n+\n+    private static final List<BufferedImage> images =\n+            new ArrayList<>(scales.length);\n+\n+    private static final List<Point> panelLocations =\n+            new ArrayList<>(4);\n+\n+    private static Dimension textFieldSize;\n+\n+    public static void main(String[] args) throws Exception {\n+        Collection<String> params = Arrays.asList(args);\n+        final boolean showFrame = params.contains(\"-show\");\n+        final boolean saveImages = params.contains(\"-save\");\n+        SwingUtilities.invokeAndWait(() -> testScaling(showFrame, saveImages));\n+    }\n+\n+    private static void testScaling(boolean showFrame, boolean saveImages) {\n+        JComponent content = createUI();\n+        if (showFrame) {\n+            showFrame(content);\n+        }\n+\n+        paintToImages(content, saveImages);\n+        verifyBorderRendering(saveImages);\n+    }\n+\n+    private static void verifyBorderRendering(final boolean saveImages) {\n+        String errorMessage = null;\n+        int errorCount = 0;\n+        for (int i = 0; i < images.size(); i++) {\n+            BufferedImage img = images.get(i);\n+            double scaling = scales[i];\n+            try {\n+                int thickness = (int) Math.floor(scaling);\n+\n+                checkVerticalBorders(textFieldSize.width \/ 2, thickness, img);\n+\n+                for (Point p : panelLocations) {\n+                    int y = (int) (p.y * scaling) + textFieldSize.height \/ 2;\n+                    checkHorizontalBorder(y, thickness, img);\n+                }\n+            } catch (Error | Exception e) {\n+                if (errorMessage == null) {\n+                    errorMessage = e.getMessage();\n+                }\n+                errorCount++;\n+\n+                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                e.printStackTrace();\n+\n+                \/\/ Save the image if it wasn't already saved\n+                if (!saveImages) {\n+                    saveImage(img, getImageFileName(scaling));\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                    + errorCount + \" error(s) detected - \"\n+                    + errorMessage);\n+        }\n+    }\n+\n+    private static void checkVerticalBorders(final int x,\n+                                             final int thickness,\n+                                             final BufferedImage img) {\n+        checkBorder(x, 0,\n+                0, 1,\n+                thickness, img);\n+    }\n+\n+    private static void checkHorizontalBorder(final int y,\n+                                              final int thickness,\n+                                              final BufferedImage img) {\n+        checkBorder(0, y,\n+                1, 0,\n+                thickness, img);\n+    }\n+\n+    private enum State {\n+        BACKGROUND, LEFT, INSIDE, RIGHT\n+    }\n+\n+    private static final int transparentColor = 0x00000000;\n+    private static int panelColor;\n+    private static int borderColor;\n+    private static int insideColor;\n+\n+    private static void checkBorder(final int xStart, final int yStart,\n+                                    final int xStep,  final int yStep,\n+                                    final int thickness,\n+                                    final BufferedImage img) {\n+        final int width = img.getWidth();\n+        final int height = img.getHeight();\n+\n+        State state = State.BACKGROUND;\n+        int borderThickness = -1;\n+\n+        int x = xStart;\n+        int y = yStart;\n+        do {\n+            do {\n+                final int color = img.getRGB(x, y);\n+                switch (state) {\n+                    case BACKGROUND:\n+                        if (color == borderColor) {\n+                            state = State.LEFT;\n+                            borderThickness = 1;\n+                        } else if (color != panelColor\n+                                && color != transparentColor) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT:\n+                        if (color == borderColor) {\n+                            borderThickness++;\n+                        } else if (color == insideColor) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            state = State.INSIDE;\n+                            borderThickness = 0;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case INSIDE:\n+                        if (color == borderColor) {\n+                            state = State.RIGHT;\n+                            borderThickness = 1;\n+                        } else if (color != insideColor) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT:\n+                        if (color == borderColor) {\n+                            borderThickness++;\n+                        } else if (color == panelColor) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            state = State.BACKGROUND;\n+                            borderThickness = 0;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                }\n+            } while (yStep > 0 && ((y += yStep) < height));\n+        } while (xStep > 0 && ((x += xStep) < width));\n+\n+        if (state != State.BACKGROUND) {\n+            throw new Error(String.format(\"Border is not rendered correctly at %d, %d\", x, y));\n+        }\n+    }\n+\n+    private static void throwWrongThickness(int thickness, int borderThickness, int x, int y) {\n+        throw new Error(\n+                String.format(\"Wrong border thickness at %d, %d: %d vs %d\",\n+                        x, y, borderThickness, thickness));\n+    }\n+\n+    private static void throwUnexpectedColor(int x, int y, int color) {\n+        throw new Error(\n+                String.format(\"Unexpected color at %d, %d: %08x\",\n+                        x, y, color));\n+    }\n+\n+    private static JComponent createUI() {\n+        JPanel contentPanel = new JPanel();\n+        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n+\n+        final LineBorder tfBorder = new LineBorder(Color.RED);\n+\n+        for (int i = 0; i < 4; i++) {\n+            JTextField textField = new JTextField(10);\n+            textField.setBorder(tfBorder);\n+            Box childPanel = Box.createHorizontalBox();\n+            childPanel.add(Box.createHorizontalStrut(i));\n+            childPanel.add(textField);\n+            childPanel.add(Box.createHorizontalStrut(4));\n+\n+            contentPanel.add(childPanel);\n+            if (textFieldSize == null) {\n+                textFieldSize = textField.getPreferredSize();\n+                borderColor = tfBorder.getLineColor().getRGB();\n+                insideColor = textField.getBackground().getRGB();\n+            }\n+            textField.setBounds(i, 0, textFieldSize.width, textFieldSize.height);\n+            childPanel.setBounds(0, (textFieldSize.height + 4) * i,\n+                    textFieldSize.width + i + 4, textFieldSize.height);\n+        }\n+\n+        contentPanel.setSize(textFieldSize.width + 4,\n+                (textFieldSize.height + 4) * 4);\n+\n+        panelColor = contentPanel.getBackground().getRGB();\n+\n+        \/\/ Save coordinates of the panels\n+        for (Component comp : contentPanel.getComponents()) {\n+            panelLocations.add(comp.getLocation());\n+        }\n+\n+        return contentPanel;\n+    }\n+\n+    private static void showFrame(JComponent content) {\n+        JFrame frame = new JFrame(\"Text Field Border Test\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.getContentPane().add(content, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void paintToImages(final JComponent content,\n+                                      final boolean saveImages) {\n+        for (double scaling : scales) {\n+            BufferedImage image =\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n+                            (int) Math.ceil(content.getHeight() * scaling),\n+                            BufferedImage.TYPE_INT_ARGB);\n+\n+            Graphics2D g2d = image.createGraphics();\n+            g2d.scale(scaling, scaling);\n+            content.paint(g2d);\n+            g2d.dispose();\n+\n+            if (saveImages) {\n+                saveImage(image, getImageFileName(scaling));\n+            }\n+            images.add(image);\n+        }\n+    }\n+\n+    private static String getImageFileName(final double scaling) {\n+        return String.format(\"test%.2f.png\", scaling);\n+    }\n+\n+    private static void saveImage(BufferedImage image, String filename) {\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (IOException e) {\n+            \/\/ Don't propagate the exception\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"}]}