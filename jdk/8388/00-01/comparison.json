{"files":[{"patch":"@@ -82,1 +82,0 @@\n-  bool is_async_installer()        { return _handshake_cl->is_async_installer(); }\n@@ -322,4 +321,0 @@\n-  } else {\n-    if (_handshake_cl->is_async_installer()) {\n-      _handshake_cl->do_cleanup();\n-    }\n@@ -432,0 +427,20 @@\n+\/\/ Filters\n+static bool non_self_executable_filter(HandshakeOperation* op) {\n+  return !op->is_async();\n+}\n+static bool no_async_exception_filter(HandshakeOperation* op) {\n+  return !op->is_async_exception();\n+}\n+static bool async_exception_filter(HandshakeOperation* op) {\n+  return op->is_async_exception();\n+}\n+static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n+  return op->is_ThreadDeath();\n+}\n+static bool no_suspend_no_async_exception_filter(HandshakeOperation* op) {\n+  return !op->is_suspend() && !op->is_async_exception();\n+}\n+static bool all_ops_filter(HandshakeOperation* op) {\n+  return true;\n+}\n+\n@@ -439,2 +454,9 @@\n-  _async_suspend_handshake(false)\n-{\n+  _async_suspend_handshake(false) {\n+}\n+\n+HandshakeState::~HandshakeState() {\n+  while (has_operation()) {\n+    HandshakeOperation* op = _queue.pop(all_ops_filter);\n+    guarantee(op->is_async(), \"Only async operations may still be present on queue\");\n+    delete op;\n+  }\n@@ -455,17 +477,0 @@\n-\/\/ Filters\n-static bool non_self_executable_filter(HandshakeOperation* op) {\n-  return !op->is_async();\n-}\n-static bool no_async_exception_filter(HandshakeOperation* op) {\n-  return !op->is_async_exception();\n-}\n-static bool async_exception_filter(HandshakeOperation* op) {\n-  return op->is_async_exception();\n-}\n-static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n-  return op->is_ThreadDeath();\n-}\n-static bool no_suspend_no_async_exception_filter(HandshakeOperation* op) {\n-  return !op->is_suspend() && !op->is_async_exception();\n-}\n-\n@@ -500,11 +505,0 @@\n-void HandshakeState::clean_async_exception_operation() {\n-  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-\n-    HandshakeOperation* op;\n-    op = _queue.peek(async_exception_filter);\n-    remove_op(op);\n-    delete op;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":29,"deletions":35,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  virtual bool is_async_installer()                { return false; }\n@@ -59,1 +58,0 @@\n-  virtual void do_cleanup()                        {}\n@@ -131,0 +129,1 @@\n+  ~HandshakeState();\n@@ -137,1 +136,0 @@\n-  void clean_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1378,13 +1378,1 @@\n-      {\n-        NoAsyncExceptionDeliveryMark _no_async(this);\n-\n-        EXCEPTION_MARK;\n-        JavaValue result(T_VOID);\n-        Klass* thread_klass = vmClasses::Thread_klass();\n-        JavaCalls::call_virtual(&result,\n-                                threadObj, thread_klass,\n-                                vmSymbols::exit_method_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n+      NoAsyncExceptionDeliveryMark _no_async(this);\n@@ -1392,6 +1380,9 @@\n-      \/\/ If we have an async exception pending at this point, then it was\n-      \/\/ queued up while NoAsyncExceptionDeliveryMark was active above so\n-      \/\/ it could not be processed by this target thread.\n-      if (has_async_exception_condition(\/* ThreadDeath_only *\/ false)) {\n-        handshake_state()->clean_async_exception_operation();\n-      }\n+      EXCEPTION_MARK;\n+      JavaValue result(T_VOID);\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::exit_method_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      CLEAR_PENDING_EXCEPTION;\n@@ -1682,2 +1673,1 @@\n-  virtual bool is_async_installer()                { return true; }\n-  void do_cleanup() {\n+  ~InstallAsyncExceptionHandshake() {\n@@ -1689,0 +1679,1 @@\n+    _aeh = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8167108 8266130 8282704 8283467\n+ * @bug 8167108 8266130 8282704 8283467 8284632\n@@ -96,9 +96,0 @@\n-            Throwable myException;\n-            if ((count % 1) == 1) {\n-              \/\/ Throw RuntimeException before ThreadDeath since a\n-              \/\/ ThreadDeath can also be queued up when there's already\n-              \/\/ a non-ThreadDeath async execution queued up.\n-              myException = new RuntimeException();\n-            } else {\n-              myException = new ThreadDeath();\n-            }\n@@ -114,0 +105,1 @@\n+                long inner_count = 0;\n@@ -115,0 +107,12 @@\n+                    inner_count++;\n+\n+                    \/\/ Throw RuntimeException before ThreadDeath since a\n+                    \/\/ ThreadDeath can also be queued up when there's already\n+                    \/\/ a non-ThreadDeath async execution queued up.\n+                    Throwable myException;\n+                    if ((inner_count % 1) == 1) {\n+                        myException = new RuntimeException();\n+                    } else {\n+                        myException = new ThreadDeath();\n+                    }\n+\n@@ -150,1 +154,1 @@\n-            retCode = stopThread(thread, myException);\n+            retCode = stopThread(thread, new ThreadDeath());\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}