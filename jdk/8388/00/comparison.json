{"files":[{"patch":"@@ -82,0 +82,1 @@\n+  bool is_async_installer()        { return _handshake_cl->is_async_installer(); }\n@@ -321,0 +322,4 @@\n+  } else {\n+    if (_handshake_cl->is_async_installer()) {\n+      _handshake_cl->do_cleanup();\n+    }\n@@ -495,0 +500,11 @@\n+void HandshakeState::clean_async_exception_operation() {\n+  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+\n+    HandshakeOperation* op;\n+    op = _queue.peek(async_exception_filter);\n+    remove_op(op);\n+    delete op;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  virtual bool is_async_installer()                { return false; }\n@@ -58,0 +59,1 @@\n+  virtual void do_cleanup()                        {}\n@@ -135,0 +137,1 @@\n+  void clean_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1378,1 +1378,13 @@\n-      NoAsyncExceptionDeliveryMark _no_async(this);\n+      {\n+        NoAsyncExceptionDeliveryMark _no_async(this);\n+\n+        EXCEPTION_MARK;\n+        JavaValue result(T_VOID);\n+        Klass* thread_klass = vmClasses::Thread_klass();\n+        JavaCalls::call_virtual(&result,\n+                                threadObj, thread_klass,\n+                                vmSymbols::exit_method_name(),\n+                                vmSymbols::void_method_signature(),\n+                                THREAD);\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n@@ -1380,9 +1392,6 @@\n-      EXCEPTION_MARK;\n-      JavaValue result(T_VOID);\n-      Klass* thread_klass = vmClasses::Thread_klass();\n-      JavaCalls::call_virtual(&result,\n-                              threadObj, thread_klass,\n-                              vmSymbols::exit_method_name(),\n-                              vmSymbols::void_method_signature(),\n-                              THREAD);\n-      CLEAR_PENDING_EXCEPTION;\n+      \/\/ If we have an async exception pending at this point, then it was\n+      \/\/ queued up while NoAsyncExceptionDeliveryMark was active above so\n+      \/\/ it could not be processed by this target thread.\n+      if (has_async_exception_condition(\/* ThreadDeath_only *\/ false)) {\n+        handshake_state()->clean_async_exception_operation();\n+      }\n@@ -1673,0 +1682,4 @@\n+  virtual bool is_async_installer()                { return true; }\n+  void do_cleanup() {\n+    delete _aeh;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -96,1 +96,9 @@\n-            Throwable myException = new ThreadDeath();\n+            Throwable myException;\n+            if ((count % 1) == 1) {\n+              \/\/ Throw RuntimeException before ThreadDeath since a\n+              \/\/ ThreadDeath can also be queued up when there's already\n+              \/\/ a non-ThreadDeath async execution queued up.\n+              myException = new RuntimeException();\n+            } else {\n+              myException = new ThreadDeath();\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}