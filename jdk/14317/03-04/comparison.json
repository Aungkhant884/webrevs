{"files":[{"patch":"@@ -115,1 +115,1 @@\n-     * bwlow.\n+     * below.\n@@ -269,0 +269,18 @@\n+     *\n+     * *** Revision notes ***\n+     *\n+     * This version differs from previous releases as follows:\n+     *\n+     * * Class TransferNode replaces Qnode, with fields and methods\n+     *   that apply to any match-based dual data structure, and now\n+     *   used in other j.u.c classes. in particular, SynchronousQueue.\n+     * * Blocking control (in class TransferQueue) accommodates\n+     *   VirtualThreads and (perhaps virtualized) uniprocessors.\n+     * * All fields of this class (LinkedTransferQueue) are\n+     *   default-initializable (to null), allowing further\n+     *   extension (in particular, SynchronousQueue.Transferer)\n+     * * Head and tail fields are lazily initialized rather than\n+     *   set to a dummy node, requiring accommodation in many\n+     *   places (as well as adjustments in WhiteBox tests).\n+     * * Reduced retries under heavy contention using MAX_SLACK and\n+     *   method unslacken.\n@@ -273,2 +291,1 @@\n-     * cancellation and forgetting after use. Note that this class is\n-     * statically imported by class SynchronousQueue.\n+     * cancellation and forgetting after use.\n@@ -387,1 +404,1 @@\n-            boolean canSpin = (!w.isVirtual() && spin);\n+            boolean canSpin = (!w.isVirtual() && spin), u;\n@@ -393,5 +410,3 @@\n-                boolean u;\n-                if (canSpin &&     \/\/ recheck for next time\n-                    (u = (Runtime.getRuntime().\n-                          availableProcessors() <= 1)) != isUniprocessor)\n-                    isUniprocessor = u;\n+                if (canSpin && isUniprocessor !=\n+                    (u = (Runtime.getRuntime().availableProcessors() <= 1)))\n+                    isUniprocessor = u;         \/\/ reset for next time\n@@ -425,2 +440,0 @@\n-            if (e == null)\n-                forgetItem();\n@@ -460,0 +473,3 @@\n+            \/\/ Reduce the risk of rare disastrous classloading in first call to\n+            \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n+            Class<?> ensureLoaded = LockSupport.class;\n@@ -468,1 +484,1 @@\n-    private static final int MAX_SLACK = 1 << 6;\n+    private static final int MAX_SLACK = 1 << 7;\n@@ -489,2 +505,3 @@\n-     * Unless empty, a node from which the last node on list (that is, the unique\n-     * node with node.next == null), if one exists, can be reached\n+     * Unless empty, a node from which the last node on list (that is,\n+     * the unique node with node.next == null), if one exists, can be\n+     * reached.\n@@ -496,0 +513,4 @@\n+     *\n+     * This field is used by subclass SynchronousQueue.Transferer to\n+     * record the top of a Lifo stack, with head always null, but\n+     * otherwise maintaining the same properties.\n@@ -550,1 +571,1 @@\n-        TransferNode prevTail = null;       \/\/ to avoid unbounded retries\n+        TransferNode prevTail = null;       \/\/ to avoid unbounded tail retries\n@@ -554,8 +575,9 @@\n-                if (nanos == 0L)            \/\/ no possible match\n-                    break restart;\n-                if ((h = cmpExHead(null,    \/\/ try to install as head\n-                                   s = new TransferNode(e, haveData))) == null) {\n-                    cmpExTail(null, s);\n-                    break restart;\n-                }\n-                p = h;                      \/\/ lost initialization race\n+                if (nanos == 0L)            \/\/ unless immediate\n+                    return e;\n+                if (s == null)\n+                    s = new TransferNode(e, haveData);\n+                if (cmpExHead(null, s) != null)\n+                    continue;               \/\/ lost initialization race\n+                if (nanos < 0L)\n+                    return e;               \/\/ async mode\n+                break restart;              \/\/ wait below\n@@ -577,1 +599,1 @@\n-                        break restart;\n+                        return e;\n@@ -583,1 +605,1 @@\n-                        if (nanos > 0L || p != t)\n+                        if (p != t)\n@@ -585,0 +607,2 @@\n+                        if (nanos < 0L)\n+                            return e;\n@@ -593,6 +617,6 @@\n-        Object match;\n-        if (s == null || nanos <= 0L)\n-            match = e;\n-        else if ((match = s.await(e, nanos, this, \/\/ spin if near head\n-                                  (p == null || p.waiter == null))) == e)\n-            unsplice(p, s);                 \/\/ cancelled\n+        Object match;                        \/\/ await match\n+        boolean maySpin = (p == null || p.waiter == null); \/\/ at or near head\n+        if ((match = s.await(e, nanos, this, maySpin)) == e)\n+            unsplice(p, s);                  \/\/ cancelled\n+        else if (match != null)\n+            s.forgetItem();\n@@ -603,1 +627,1 @@\n-     * Collapses dead nodes from head and tail. Called before\n+     * Incrementally advances head and tail if possible. Called before\n@@ -608,1 +632,1 @@\n-        TransferNode h, t, p;\n+        TransferNode h, t, s, n, u;\n@@ -610,11 +634,5 @@\n-            (p = h.next) != null && p != h) {  \/\/ collapse head\n-            for (TransferNode n; (n = p.next) != p; p = n) {\n-                if (n == null || p.isLive()) {\n-                    if (cmpExHead(h, p) == h) {\n-                        if (n == null)         \/\/ absorb tail\n-                            cmpExTail(tail, p);\n-                        h.forgetNext();\n-                    }\n-                    break;\n-                }\n-            }\n+            (s = h.next) != null && s != h) { \/\/ try to advance by 2\n+            if (!s.isLive() && (n = s.next) != null && n != s &&\n+                !(s = n).isLive() && (n = s.next) != null && n != s)\n+                s = n;\n+            tryAdvanceHead(h, s);\n@@ -622,8 +640,4 @@\n-        if ((t = tail) != null) {              \/\/ help collapse tail\n-            for (TransferNode q = t, n; (n = q.next) != q; q = n) {\n-                if (n == null) {\n-                    if (q != t)\n-                        cmpExTail(t, q);\n-                    break;\n-                }\n-            }\n+        if ((t = tail) != null && (s = t.next) != null && s != t) {\n+            if (!s.isLive() && (n = s.next) != null)\n+                s = (s == (u = t.cmpExNext(s, n))) ? n : u;\n+            cmpExTail(t, s); \/\/ advance by 2 if can unlink dead node\n@@ -659,3 +673,1 @@\n-            else if ((n = s.next) == null) {\n-                if ((h = head) != null && s == h.next)\n-                    cmpExTail(s, h);       \/\/ absorb tail as head\n+            else if ((n = s.next) == null)\n@@ -663,1 +675,0 @@\n-            }\n@@ -704,2 +715,2 @@\n-     * Tries to match the given object only if nonnull and p\n-     * is a data node. Signals waiter on success.\n+     * Tries to match the given object only if p is a data\n+     * node. Signals waiter on success.\n@@ -1620,4 +1631,0 @@\n-\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":69,"deletions":62,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -150,1 +150,3 @@\n-     * are not prone to unbounded garbage chains.\n+     * are not prone to unbounded garbage chains. Also note that\n+     * \"async\" mode is never used and not supported for synchronous\n+     * transfers.\n@@ -157,1 +159,2 @@\n-         * * If top is already matched, pop and continue\n+         *\n+         * * If top exists and is already matched, pop and continue\n@@ -160,2 +163,2 @@\n-         * * Else push a node and wait (unless immediate mode), unsplicing\n-         *   the node if cancelled.\n+         * * If no possible match, unless immediate mode, push a\n+         *    node and wait, later unsplicing if cancelled.\n@@ -168,2 +171,1 @@\n-            boolean haveData = (e != null), isData = false;\n-            Object match, item = null;\n+            boolean haveData = (e != null);\n@@ -171,7 +173,10 @@\n-                if (top != null &&                \/\/ collapse dead nodes\n-                    (isData = top.isData) != ((item = top.item) != null)) {\n-                    TransferNode f = top.next, u = cmpExTail(top, f);\n-                    top = (top == u) ? f : u;\n-                } else if (top != null && isData != haveData) {\n-                    if (top.cmpExItem(item, e) == item) {\n-                        match = item;            \/\/ fulfill waiting node\n+                boolean isData; Object match;\n+                if (top != null) {\n+                    if ((isData = top.isData) != ((match = top.item) != null)) {\n+                        TransferNode n = top.next, u = cmpExTail(top, n);\n+                        top = (top == u) ? n : u;     \/\/ collapse dead node\n+                        continue;                     \/\/ retry with next top\n+                    }\n+                    if (isData != haveData) {         \/\/ try to fulfill\n+                        if (top.cmpExItem(match, e) != match)\n+                            continue;                 \/\/ lost race\n@@ -180,14 +185,1 @@\n-                        break;\n-                    }\n-                } else if (nanos == 0L) {       \/\/ no fulfillers, no wait\n-                    match = e;\n-                    break;\n-                } else {                        \/\/ push new node and wait\n-                    if (s == null)\n-                        s = new TransferNode(e, haveData);\n-                    s.setNext(top);\n-                    if (top == (top = cmpExTail(top, s))) {\n-                        boolean spin = (top == null || top.waiter == null);\n-                        if ((match = s.await(e, nanos, this, spin)) == e)\n-                            unspliceLifo(s);    \/\/ cancelled\n-                        break;\n+                        return match;\n@@ -196,0 +188,11 @@\n+                if (nanos == 0L)                     \/\/ no fulfillers, no wait\n+                    return e;\n+                if (s == null)                       \/\/ push new node and wait\n+                    s = new TransferNode(e, haveData);\n+                s.setNext(top);\n+                if (top == (top = cmpExTail(top, s))) {\n+                    boolean maySpin = (top == null || top.waiter == null);\n+                    if ((match = s.await(e, nanos, this, maySpin)) == e)\n+                        unspliceLifo(s);             \/\/ cancelled\n+                    return match;\n+                }\n@@ -197,1 +200,0 @@\n-            return match;\n@@ -597,6 +599,0 @@\n-\n-    static {\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -252,2 +252,1 @@\n-        if (n > 0)\n-            assertEquals(q.size(), c - (q.contains(n - 1) ? 0 : 1));\n+        checkNodeCount(c - (q.contains(n - 1) ? 0 : 1), q.size());\n","filename":"test\/jdk\/java\/util\/concurrent\/LinkedTransferQueue\/WhiteBox.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}