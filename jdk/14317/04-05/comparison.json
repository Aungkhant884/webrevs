{"files":[{"patch":"@@ -153,6 +153,6 @@\n-     * Once a node is matched, its match status can never again\n-     * change.  We may thus arrange that the linked list of them\n-     * contain a prefix of zero or more matched nodes, followed by a\n-     * suffix of zero or more unmatched nodes. Note that we allow both\n-     * the prefix and suffix to be zero length, which in turn means\n-     * that we do not require a dummy header.\n+     * Once a node is matched, it is no longer live -- its match\n+     * status can never again change.  We may thus arrange that the\n+     * linked list of them contain a prefix of zero or more dead\n+     * nodes, followed by a suffix of zero or more live nodes. Note\n+     * that we allow both the prefix and suffix to be zero length,\n+     * which in turn means that we do not require a dummy header.\n@@ -177,10 +177,11 @@\n-     * traversal chains, while smaller values increase CAS contention\n-     * and overhead. Using the smallest non-zero value of one is both\n-     * simple and empirically a good choice in most applicatkions.\n-     * The slack value is hard-wired: a path greater than one is\n-     * usually implemented by checking equality of traversal pointers.\n-     * Because CASes updating fields may fail and threads attempting\n-     * to do so may stall, the actual slack may exceed targeted\n-     * slack. To reduce the consequent staleness impact, threads may\n-     * help update (method unslacken) when traversal lengths exceed an\n-     * imposed limit of MAX_SLACK.\n+     * traversal chains and out-of-order updates, while smaller values\n+     * increase CAS contention and overhead. Using the smallest\n+     * non-zero value of one is both simple and empirically a good\n+     * choice in most applicatkions.  The slack value is hard-wired: a\n+     * path greater than one is usually implemented by checking\n+     * equality of traversal pointers.  Because CASes updating fields\n+     * attempting to do so may stall, the writes may appear out of\n+     * order (an older CAS from the same head or tail may execute\n+     * after a newer one), the actual slack may exceed targeted\n+     * slack. To reduce impact, other threads may help update by\n+     * unsplicing dead nodes while traversing.\n@@ -200,7 +201,6 @@\n-     * values held in other node fields.)  However, doing so adds some\n-     * further complexity to traversal: If any \"next\" pointer links to\n-     * itself, it indicates that the current thread has lagged behind\n-     * a head-update, and so the traversal must continue from the\n-     * \"head\".  Traversals trying to find the current tail starting\n-     * from \"tail\" may also encounter self-links, in which case they\n-     * also continue at \"head\".\n+     * values held in other node fields.) This is easy to accommodate\n+     * in the primary xfer method, but adds a lot of complexity to\n+     * Collection operations including traversal; mainly because if\n+     * any \"next\" pointer links to itself, the current thread has\n+     * lagged behind a head-update, and so must restart from the\n+     * \"head\".\n@@ -210,4 +210,3 @@\n-     * The TransferNode class is shared with class SynchronousQueue\n-     * (which adds Lifo-based matching methods). It houses method\n-     * await, which is used for all blocking control, as described\n-     * below in TransferNode internal documentation.\n+     * The DualNode class is shared with class SynchronousQueue It\n+     * houses method await, which is used for all blocking control, as\n+     * described below in DualNode internal documentation.\n@@ -274,1 +273,1 @@\n-     * * Class TransferNode replaces Qnode, with fields and methods\n+     * * Class DualNode replaces Qnode, with fields and methods\n@@ -282,5 +281,4 @@\n-     * * Head and tail fields are lazily initialized rather than\n-     *   set to a dummy node, requiring accommodation in many\n-     *   places (as well as adjustments in WhiteBox tests).\n-     * * Reduced retries under heavy contention using MAX_SLACK and\n-     *   method unslacken.\n+     * * Head and tail fields are lazily initialized rather than set\n+     *   to a dummy node, also reducing retries under heavy contention\n+     *   and misordering, requiring accommodation in many places (as\n+     *   well as adjustments in WhiteBox tests),\n@@ -290,2 +288,2 @@\n-     * Queue nodes. Uses type Object, not E, for items to allow\n-     * cancellation and forgetting after use.\n+     * Node for linked dual data structures. Uses type Object, not E,\n+     * for items to allow cancellation and forgetting after use.\n@@ -293,1 +291,1 @@\n-    static final class TransferNode implements ForkJoinPool.ManagedBlocker {\n+    static final class DualNode implements ForkJoinPool.ManagedBlocker {\n@@ -295,2 +293,2 @@\n-        volatile TransferNode next;\n-        volatile Thread waiter; \/\/ null when not parked waiting for a match\n+        volatile DualNode next;\n+        Thread waiter;          \/\/ plain mode; order constrained by context\n@@ -299,1 +297,1 @@\n-        TransferNode(Object item, boolean isData) {\n+        DualNode(Object item, boolean isData) {\n@@ -308,2 +306,2 @@\n-        final TransferNode cmpExNext(TransferNode cmp, TransferNode val) {\n-            return (TransferNode)NEXT.compareAndExchange(this, cmp, val);\n+        final DualNode cmpExNext(DualNode cmp, DualNode val) {\n+            return (DualNode)NEXT.compareAndExchange(this, cmp, val);\n@@ -313,1 +311,1 @@\n-         * Returns true if this node has not been matched\n+         * Returns true if this node has not been matched (or cancelled)\n@@ -319,9 +317,0 @@\n-        \/**\n-         * Tries to cancel by matching with self if initially null else null\n-         * @param e the initial item value\n-         * @return e if successful, else current item\n-         *\/\n-        final Object tryCancel(Object e) {\n-            return cmpExItem(e, (e == null) ? this : null);\n-        }\n-\n@@ -329,4 +318,3 @@\n-        final void clearWaiter()   { WAITER.setOpaque(this, null); }\n-        final void forgetItem()    { ITEM.set(this, this); }\n-        final void forgetNext()    { NEXT.set(this, this); }\n-        final void setNext(TransferNode n) { NEXT.set(this, n);  }\n+        final void forgetItem()        { ITEM.set(this, this); }\n+        final void selfLink()          { NEXT.set(this, this); }\n+        final void setNext(DualNode n) { NEXT.set(this, n);  }\n@@ -386,1 +374,9 @@\n-         * 5. To make the above work, callers must precheck that\n+         * 5. Park\/unpark signalling otherwise relies on a Dekker-like\n+         * scheme in which the caller advertises the need to unpark by\n+         * setting its waiter field, followed by a full fence and\n+         * recheck before actually parking. (An explicit fence in used\n+         * in this one case rather than requiring volatile mode,\n+         * rather than overconstraining waiter accesses that are\n+         * otherwise already constrained by surrounding atomics.)\n+         *\n+         * 6. To make the above work, callers must precheck that\n@@ -397,1 +393,1 @@\n-         * @param spin true if eligible for spinning if enabled\n+         * @param spin true if eligible for spinning when enabled\n@@ -404,1 +400,1 @@\n-            boolean canSpin = (!w.isVirtual() && spin), u;\n+            boolean canSpin = (!w.isVirtual() && spin);\n@@ -410,0 +406,1 @@\n+                boolean uni;\n@@ -411,2 +408,2 @@\n-                    (u = (Runtime.getRuntime().availableProcessors() <= 1)))\n-                    isUniprocessor = u;         \/\/ reset for next time\n+                    (uni = (Runtime.getRuntime().availableProcessors() <= 1)))\n+                    isUniprocessor = uni; \/\/ reset for next time\n@@ -415,0 +412,1 @@\n+                VarHandle.fullFence(); \/\/ ensure ordering\n@@ -416,4 +414,5 @@\n-                    long ns;\n-                    if (w.isInterrupted()) {\n-                        match = tryCancel(e);\n-                        break;\n+                    long ns = 0L;\n+                    if (w.isInterrupted() ||\n+                        (timed && ((ns = deadline - System.nanoTime()) <= 0L))) {\n+                        match = cmpExItem(e, (e == null) ? this : null);\n+                        break;         \/\/ try to cancel with impossible match\n@@ -422,4 +421,0 @@\n-                        if ((ns = deadline - System.nanoTime()) <= 0L) {\n-                            match = tryCancel(e);\n-                            break;\n-                        }\n@@ -435,1 +430,1 @@\n-                        LockSupport.park(this);\n+                        LockSupport.park();\n@@ -437,1 +432,0 @@\n-                clearWaiter();\n@@ -439,0 +433,1 @@\n+                waiter = null;\n@@ -440,0 +435,2 @@\n+            if (match != e && match != null)\n+                forgetItem();\n@@ -462,1 +459,0 @@\n-        static final VarHandle WAITER;\n@@ -465,1 +461,1 @@\n-                Class<?> tn = TransferNode.class;\n+                Class<?> tn = DualNode.class;\n@@ -469,1 +465,0 @@\n-                WAITER = l.findVarHandle(tn, \"waiter\", Thread.class);\n@@ -479,7 +474,0 @@\n-    \/**\n-     * The maximum number of dead nodes traversed before unslackening\n-     * to reduce retries due to stalls in updating head and tail.  Must\n-     * be at least 4.\n-     *\/\n-    private static final int MAX_SLACK = 1 << 7;\n-\n@@ -490,1 +478,1 @@\n-     * two, at least 2 and at most MAX_SLACK.\n+     * two, at least 4.\n@@ -501,0 +489,4 @@\n+     *\n+     * This field is used by subclass SynchronousQueue.Transferer to\n+     * record the top of a Lifo stack, with tail always null, but\n+     * otherwise maintaining the same properties.\n@@ -502,1 +494,1 @@\n-    transient volatile TransferNode head;\n+    transient volatile DualNode head;\n@@ -511,0 +503,1 @@\n+     * - tail may or may not be self-linked.\n@@ -512,5 +505,0 @@\n-     * - tail.next may or may not be self-linked.\n-     *\n-     * This field is used by subclass SynchronousQueue.Transferer to\n-     * record the top of a Lifo stack, with head always null, but\n-     * otherwise maintaining the same properties.\n@@ -518,1 +506,1 @@\n-    transient volatile TransferNode tail;\n+    transient volatile DualNode tail;\n@@ -523,6 +511,0 @@\n-    \/** increment sweepVotes and return true on trigger *\/\n-    private boolean sweepNow() {\n-        return (((int) SWEEPVOTES.getAndAdd(this, 1) + 1) &\n-                (SWEEP_THRESHOLD - 1)) == 0;\n-    }\n-\n@@ -531,2 +513,2 @@\n-    final TransferNode cmpExTail(TransferNode cmp, TransferNode val) {\n-        return (TransferNode)TAIL.compareAndExchange(this, cmp, val);\n+    final DualNode cmpExTail(DualNode cmp, DualNode val) {\n+        return (DualNode)TAIL.compareAndExchange(this, cmp, val);\n@@ -534,2 +516,2 @@\n-    final TransferNode cmpExHead(TransferNode cmp, TransferNode val) {\n-        return (TransferNode)HEAD.compareAndExchange(this, cmp, val);\n+    final DualNode cmpExHead(DualNode cmp, DualNode val) {\n+        return (DualNode)HEAD.compareAndExchange(this, cmp, val);\n@@ -537,10 +519,2 @@\n-\n-    \/**\n-     * Tries to update to new head, forgetting links from previous\n-     * head (if it exists) on success.\n-     *\/\n-    final TransferNode tryAdvanceHead(TransferNode h, TransferNode p) {\n-        TransferNode u;\n-        if ((u = cmpExHead(h, p)) == h && h != null)\n-            h.forgetNext();\n-        return u;\n+    final int addSweepVote() {\n+        return (int)SWEEPVOTES.getAndAdd(this, 1);\n@@ -552,4 +526,3 @@\n-     * * If head not initialized, try to add new node and exit (unless immediate)\n-     * * If tail initialized and has same mode, and this is not a retry,\n-     *   start traversing at tail (for an append), else start at head\n-     *   (for a likely match, but if no live nodes, an append)\n+     * * If not initialized, try to add new node (unless immediate) and exit\n+     * * If tail has same mode, start traversing at tail for a likely\n+     *   append, else at head for a likely match\n@@ -557,2 +530,1 @@\n-     *   to match\/append, or falling off the list because of self-links,\n-     *   taking or too many steps, in which case help unslacken and restart.\n+     *   to match\/append, or falling off the list because of self-links.\n@@ -569,7 +541,7 @@\n-        TransferNode p;                     \/\/ current traversal node\n-        TransferNode s = null;              \/\/ the enqueued npde, if needed\n-        TransferNode prevTail = null;       \/\/ to avoid unbounded tail retries\n-        restart: for (;;) {\n-            TransferNode h, t;\n-            if ((p = h = head) == null) {   \/\/ lazily initialize\n-                if (nanos == 0L)            \/\/ unless immediate\n+        DualNode s = null;                   \/\/ the enqueued node, if needed\n+        DualNode pred;                       \/\/ s's predecessor if waiting\n+        DualNode prevTail = null;            \/\/ to avoid self-linked paths\n+        restart: for (;;) {                  \/\/ restart if fall off list\n+            DualNode h, t, p;\n+            if ((h = head) == null) {        \/\/ initialize\n+                if (nanos == 0L)             \/\/ unless immediate\n@@ -577,7 +549,7 @@\n-                if (s == null)\n-                    s = new TransferNode(e, haveData);\n-                if (cmpExHead(null, s) != null)\n-                    continue;               \/\/ lost initialization race\n-                if (nanos < 0L)\n-                    return e;               \/\/ async mode\n-                break restart;              \/\/ wait below\n+                s = new DualNode(e, haveData);\n+                if ((h = cmpExHead(null, s)) == null) {\n+                    if (nanos < 0L)\n+                        return e;            \/\/ async mode\n+                    pred = null;\n+                    break;                   \/\/ wait below\n+                }\n@@ -585,5 +557,5 @@\n-            if ((t = tail) != null && haveData == t.isData && t != prevTail)\n-                p = prevTail = t;           \/\/ start at tail\n-            for (int slack = 0; slack < MAX_SLACK; ++slack) { \/\/ bound steps\n-                TransferNode q, n; Object item;\n-                if (haveData != p.isData && \/\/ try to match waiting node\n+            p = ((t = tail) != null && t != prevTail && t.isData == haveData ?\n+                 (prevTail = t) : h);        \/\/ start at tail if may be eligible\n+            for (boolean slack = false; ; slack = true) {\n+                DualNode q; Object item;\n+                if (haveData != p.isData &&  \/\/ try to match existing node\n@@ -592,3 +564,7 @@\n-                    if (p != h)\n-                        tryAdvanceHead(h, (n = p.next) == null ? p : n);\n-                    LockSupport.unpark(p.waiter);\n+                    Thread w = p.waiter;\n+                    if (slack) {\n+                        DualNode n = ((q = p.next) == null) ? p : q;\n+                        if (h != n && h == cmpExHead(h, n))\n+                            h.selfLink();    \/\/ advance by 2 if possible\n+                    }\n+                    LockSupport.unpark(w);\n@@ -597,2 +573,2 @@\n-                if ((q = p.next) == null) { \/\/ no matches\n-                    if (nanos == 0L)\n+                if ((q = p.next) == null) {  \/\/ try to append\n+                    if (nanos == 0L)         \/\/ unless immediate\n@@ -600,3 +576,3 @@\n-                    if (s == null) {        \/\/ try to append node\n-                        s = new TransferNode(e, haveData);\n-                        q = p.next;         \/\/ recheck after allocation\n+                    if (s == null) {\n+                        s = new DualNode(e, haveData);\n+                        q = p.next;          \/\/ recheck after allocation\n@@ -605,2 +581,2 @@\n-                        if (p != t)\n-                            cmpExTail(tail, s);\n+                        if (slack)\n+                            cmpExTail(t, s);\n@@ -609,0 +585,1 @@\n+                        pred = p;\n@@ -612,1 +589,1 @@\n-                if (p == (p = q))            \/\/ stale; restart\n+                if (p == (p = q))            \/\/ self-linked; restart\n@@ -615,1 +592,0 @@\n-            unslacken();                     \/\/ collapse before retrying\n@@ -617,6 +593,4 @@\n-        Object match;                        \/\/ await match\n-        boolean maySpin = (p == null || p.waiter == null); \/\/ at or near head\n-        if ((match = s.await(e, nanos, this, maySpin)) == e)\n-            unsplice(p, s);                  \/\/ cancelled\n-        else if (match != null)\n-            s.forgetItem();\n+        Object match = s.await(e, nanos, this, \/\/ spin if at or near head\n+                               pred == null || pred.waiter == null);\n+        if (match == e)\n+            unsplice(pred, s);               \/\/ cancelled\n@@ -626,20 +600,1 @@\n-    \/**\n-     * Incrementally advances head and tail if possible. Called before\n-     * retraversals and during unsplices to reduce retries due to\n-     * stalled head and tail updates.\n-     *\/\n-    private void unslacken() {\n-        TransferNode h, t, s, n, u;\n-        if ((h = head) != null && !h.isLive() &&\n-            (s = h.next) != null && s != h) { \/\/ try to advance by 2\n-            if (!s.isLive() && (n = s.next) != null && n != s &&\n-                !(s = n).isLive() && (n = s.next) != null && n != s)\n-                s = n;\n-            tryAdvanceHead(h, s);\n-        }\n-        if ((t = tail) != null && (s = t.next) != null && s != t) {\n-            if (!s.isLive() && (n = s.next) != null)\n-                s = (s == (u = t.cmpExNext(s, n))) ? n : u;\n-            cmpExTail(t, s); \/\/ advance by 2 if can unlink dead node\n-        }\n-    }\n+    \/* --------------  Removals -------------- *\/\n@@ -647,1 +602,0 @@\n-    \/* --------------  Interior removals -------------- *\/\n@@ -649,2 +603,2 @@\n-     * Unsplices (now or later) the given deleted\/cancelled node with\n-     * the given predecessor.\n+     * Unlinks (now or later) the given (non-live) node with given\n+     * predecessor. See above for rationale.\n@@ -656,7 +610,14 @@\n-    final void unsplice(TransferNode pred, TransferNode s) {\n-        TransferNode n;\n-        if (pred != null && s != null && pred.next == s && (n = s.next) != s &&\n-            (n == null || pred.cmpExNext(s, n) != s) &&\n-            sweepNow())    \/\/ occasionally sweep initially pinned nodes\n-            sweep();\n-        unslacken();       \/\/ help clean endpoints\n+    private void unsplice(DualNode pred, DualNode s) {\n+        DualNode sn;\n+        if (pred != null && pred.next == s && s != null && (sn = s.next) != s) {\n+            if (sn != null)\n+                pred.cmpExNext(s, sn);\n+            if ((sn == null || !pred.isLive()) &&\n+                ((addSweepVote() + 1) & (SWEEP_THRESHOLD - 1)) == 0) {\n+                for (DualNode p = head, f, n, u;  \/\/ occasionally sweep\n+                     p != null && (f = p.next) != null && (n = f.next) != null;)\n+                    p = (f.isLive()                   ? f :     \/\/ skip\n+                         f == p                       ? head :  \/\/ stale\n+                         f == (u = p.cmpExNext(f, n)) ? n : u); \/\/ unspliced\n+            }\n+        }\n@@ -666,1 +627,2 @@\n-     * Unlinks dead nodes encountered in a traversal from head.\n+     * Tries to update to new head, forgetting links from previous\n+     * head (if it exists) on success.\n@@ -668,12 +630,5 @@\n-    private void sweep() {\n-        for (TransferNode p = head, s; p != null && (s = p.next) != null; ) {\n-            TransferNode n, u, h;\n-            if (s.isLive())\n-                p = s;\n-            else if ((n = s.next) == null)\n-                break;\n-            else if (s == n)               \/\/ stale\n-                p = head;\n-            else                           \/\/ unlink\n-                p = ((u = p.cmpExNext(s, n)) == s) ? n : u;\n-        }\n+    final DualNode tryAdvanceHead(DualNode h, DualNode p) {\n+        DualNode u;\n+        if ((u = cmpExHead(h, p)) == h && h != null)\n+            h.selfLink();\n+        return u;\n@@ -686,2 +641,1 @@\n-    final boolean tryCasSuccessor(TransferNode pred, TransferNode c,\n-                                  TransferNode p) {\n+    final boolean tryCasSuccessor(DualNode pred, DualNode c, DualNode p) {\n@@ -702,2 +656,2 @@\n-    final TransferNode skipDeadNodes(TransferNode pred, TransferNode c,\n-                                     TransferNode p, TransferNode q) {\n+    final DualNode skipDeadNodes(DualNode pred, DualNode c,\n+                                 DualNode p, DualNode q) {\n@@ -718,1 +672,1 @@\n-    final boolean tryMatchData(TransferNode p, Object x) {\n+    final boolean tryMatchData(DualNode p, Object x) {\n@@ -734,2 +688,2 @@\n-    final TransferNode firstDataNode() {\n-        for (TransferNode h = head, p = h, q, u; p != null;) {\n+    final DualNode firstDataNode() {\n+        for (DualNode h = head, p = h, q, u; p != null;) {\n@@ -761,1 +715,1 @@\n-            for (TransferNode p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -780,1 +734,1 @@\n-            for (TransferNode p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -809,1 +763,1 @@\n-            for (TransferNode p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -902,4 +856,4 @@\n-        private TransferNode nextNode;   \/\/ next node to return item for\n-        private E nextItem;      \/\/ the corresponding item\n-        private TransferNode lastRet;    \/\/ last returned node, to support remove\n-        private TransferNode ancestor;   \/\/ Helps unlink lastRet on remove()\n+        private DualNode nextNode;   \/\/ next node to return item for\n+        private E nextItem;          \/\/ the corresponding item\n+        private DualNode lastRet;    \/\/ last returned node, to support remove\n+        private DualNode ancestor;   \/\/ Helps unlink lastRet on remove()\n@@ -911,2 +865,2 @@\n-        private void advance(TransferNode pred) {\n-            for (TransferNode p = (pred == null) ? head : pred.next, c = p;\n+        private void advance(DualNode pred) {\n+            for (DualNode p = (pred == null) ? head : pred.next, c = p;\n@@ -946,1 +900,1 @@\n-            final TransferNode p;\n+            final DualNode p;\n@@ -955,2 +909,2 @@\n-            TransferNode q = null;\n-            for (TransferNode p; (p = nextNode) != null; advance(q = p))\n+            DualNode q = null;\n+            for (DualNode p; (p = nextNode) != null; advance(q = p))\n@@ -963,1 +917,1 @@\n-            final TransferNode lastRet = this.lastRet;\n+            final DualNode lastRet = this.lastRet;\n@@ -970,2 +924,2 @@\n-            TransferNode pred = ancestor;\n-            for (TransferNode p = (pred == null) ? head : pred.next, c = p, q;\n+            DualNode pred = ancestor;\n+            for (DualNode p = (pred == null) ? head : pred.next, c = p, q;\n@@ -1006,1 +960,1 @@\n-        TransferNode current;       \/\/ current node; null until initialized\n+        DualNode current;   \/\/ current node; null until initialized\n@@ -1012,1 +966,1 @@\n-            TransferNode p, q;\n+            DualNode p, q;\n@@ -1041,1 +995,1 @@\n-            final TransferNode p;\n+            final DualNode p;\n@@ -1052,1 +1006,1 @@\n-            TransferNode p;\n+            DualNode p;\n@@ -1078,1 +1032,1 @@\n-        private void setCurrent(TransferNode p) {\n+        private void setCurrent(DualNode p) {\n@@ -1083,2 +1037,2 @@\n-        private TransferNode current() {\n-            TransferNode p;\n+        private DualNode current() {\n+            DualNode p;\n@@ -1135,1 +1089,1 @@\n-        TransferNode h = null, t = null;\n+        DualNode h = null, t = null;\n@@ -1137,1 +1091,1 @@\n-            TransferNode newNode = new TransferNode(Objects.requireNonNull(e), true);\n+            DualNode newNode = new DualNode(Objects.requireNonNull(e), true);\n@@ -1324,1 +1278,1 @@\n-            for (TransferNode p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -1352,1 +1306,1 @@\n-            for (TransferNode p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -1401,2 +1355,2 @@\n-            for (TransferNode p = head, pred = null; p != null; ) {\n-                TransferNode q = p.next;\n+            for (DualNode p = head, pred = null; p != null; ) {\n+                DualNode q = p.next;\n@@ -1415,1 +1369,1 @@\n-                for (TransferNode c = p;; q = p.next) {\n+                for (DualNode c = p;; q = p.next) {\n@@ -1437,2 +1391,2 @@\n-            for (TransferNode p = head, pred = null; p != null; ) {\n-                TransferNode q = p.next;\n+            for (DualNode p = head, pred = null; p != null; ) {\n+                DualNode q = p.next;\n@@ -1449,1 +1403,1 @@\n-                for (TransferNode c = p;; q = p.next) {\n+                for (DualNode c = p;; q = p.next) {\n@@ -1499,1 +1453,1 @@\n-        TransferNode h = null, t = null;\n+        DualNode h = null, t = null;\n@@ -1501,1 +1455,1 @@\n-            TransferNode newNode = new TransferNode(item, true);\n+            DualNode newNode = new DualNode(item, true);\n@@ -1545,0 +1499,1 @@\n+\n@@ -1553,1 +1508,1 @@\n-            for (TransferNode p = head, c = p, pred = null, q; p != null; p = q) {\n+            for (DualNode p = head, c = p, pred = null, q; p != null; p = q) {\n@@ -1588,3 +1543,3 @@\n-    void forEachFrom(Consumer<? super E> action, TransferNode p) {\n-        for (TransferNode pred = null; p != null; ) {\n-            TransferNode q = p.next;\n+    void forEachFrom(Consumer<? super E> action, DualNode p) {\n+        for (DualNode pred = null; p != null; ) {\n+            DualNode q = p.next;\n@@ -1600,1 +1555,1 @@\n-            for (TransferNode c = p;; q = p.next) {\n+            for (DualNode c = p;; q = p.next) {\n@@ -1623,1 +1578,1 @@\n-            Class<?> ltq = LinkedTransferQueue.class, tn = TransferNode.class;\n+            Class<?> ltq = LinkedTransferQueue.class, tn = DualNode.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":196,"deletions":241,"binary":false,"changes":437,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import static java.util.concurrent.LinkedTransferQueue.TransferNode;\n@@ -108,6 +107,6 @@\n-     * low contention, but can be much slower under high contention.\n-     * Performance of applications using them also varies. Lifo is\n-     * generally preferable in resource management settings (for\n-     * example cached thread pools) because of better temporal\n-     * locality, but inappropriate for message-passing applications.\n-\n+     * low contention, but slower under high contention.  Performance\n+     * of applications using them also varies. Lifo is generally\n+     * preferable in resource management settings (for example cached\n+     * thread pools) because of better temporal locality, but\n+     * inappropriate for message-passing applications.\n+     *\n@@ -128,1 +127,4 @@\n-     *  1. The original algorithms used bit-marked pointers, but\n+     *  *  For historical compatibility, Fifo mode directly uses\n+     *     LinkedTransferQueue operations, but Lifo mode support is\n+     *     added in subclass Transferer.\n+     *  *  The original algorithms used bit-marked pointers, but\n@@ -135,4 +137,3 @@\n-     *  2. SynchronousQueues must block threads waiting to become\n-     *     fulfilled, preceded by brief spins at\/mear front positions\n-     *     if not VirtualThreads.\n-     *  3. Support for cancellation via timeout and interrupts,\n+     *  *  SynchronousQueues must block threads waiting to become\n+     *     fulfilled, sometimes preceded by brief spins.\n+     *  *  Support for cancellation via timeout and interrupts,\n@@ -141,3 +142,0 @@\n-     *  4. For compatibility and logistics reasons, Fifo mode directly\n-     *     uses LinkedTransferQueue operations, but Lifo mode support is\n-     *     added in subclass Transferer.\n@@ -148,1 +146,1 @@\n-     * Methods use tha \"tail\" field as top of stack (versus tail of\n+     * Methods use the \"head\" field as head (top) of stack (versus\n@@ -159,2 +157,1 @@\n-         *\n-         * * If top exists and is already matched, pop and continue\n+         * * If top (p) exists and is already matched, pop and continue\n@@ -162,1 +159,2 @@\n-         *    and pop (which will succeed unless already helped).\n+         *    On success pop (which will succeed unless already helped),\n+         *    otherwise restart.\n@@ -167,1 +165,1 @@\n-         * @param nanos timeout: 0 for immediate, Long.MAX_VALUE for untimed\n+         * @param nanos timeout or 0 for immediate, Long.MAX_VALUE for untimed\n@@ -172,7 +170,16 @@\n-            for (TransferNode top = tail, s = null;;) {\n-                boolean isData; Object match;\n-                if (top != null) {\n-                    if ((isData = top.isData) != ((match = top.item) != null)) {\n-                        TransferNode n = top.next, u = cmpExTail(top, n);\n-                        top = (top == u) ? n : u;     \/\/ collapse dead node\n-                        continue;                     \/\/ retry with next top\n+            for (DualNode s = null;;) {\n+                for (DualNode p = head;;) {\n+                    if (p != null) {\n+                        Object item; DualNode n, u;\n+                        boolean isData = p.isData;\n+                        if (isData != ((item = p.item) != null)) {\n+                            p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n+                            continue;                    \/\/ retry with next top\n+                        } else if (isData != haveData) { \/\/ try to fulfill\n+                            if (p.cmpExItem(item, e) != item)\n+                                break;                   \/\/ lost race; restart\n+                            Thread w = p.waiter;\n+                            cmpExHead(p, p.next);\n+                            LockSupport.unpark(w);\n+                            return item;\n+                        }\n@@ -180,5 +187,10 @@\n-                    if (isData != haveData) {         \/\/ try to fulfill\n-                        if (top.cmpExItem(match, e) != match)\n-                            continue;                 \/\/ lost race\n-                        cmpExTail(top, top.next);\n-                        LockSupport.unpark(top.waiter);\n+                    if (nanos == 0L)                     \/\/ no match, no wait\n+                        return e;\n+                    if (s == null)                       \/\/ push new node; wait\n+                        s = new DualNode(e, haveData);\n+                    s.setNext(p);\n+                    if (p == (p = cmpExHead(p, s))) {\n+                        Object match = s.await(e, nanos, this, \/\/ spin near empty\n+                                               p == null || p.waiter == null);\n+                        if (match == e)\n+                            unspliceLifo(s);             \/\/ cancelled\n@@ -188,11 +200,0 @@\n-                if (nanos == 0L)                     \/\/ no fulfillers, no wait\n-                    return e;\n-                if (s == null)                       \/\/ push new node and wait\n-                    s = new TransferNode(e, haveData);\n-                s.setNext(top);\n-                if (top == (top = cmpExTail(top, s))) {\n-                    boolean maySpin = (top == null || top.waiter == null);\n-                    if ((match = s.await(e, nanos, this, maySpin)) == e)\n-                        unspliceLifo(s);             \/\/ cancelled\n-                    return match;\n-                }\n@@ -203,1 +204,9 @@\n-         * Unlinks s, assuming lifo mode.\n+         * Unlinks (non-live) node s from stack.  Unlike fifo lists,\n+         * we don't have a known predecessor that usually suffices to\n+         * unlink.  At worst we may need to traverse entire list, and\n+         * we might not see s if already off-list or another unsplicer\n+         * has removed it. But we can stop when we see any node known\n+         * to follow s. We use s.next unless it is not live, in which\n+         * case we try the node one past. We don't check any further\n+         * because we don't want to doubly traverse just to find\n+         * sentinel.\n@@ -205,11 +214,2 @@\n-        private void unspliceLifo(TransferNode s) {\n-            TransferNode past = null;\n-            \/*\n-             * At worst we may need to traverse entire stack to unlink\n-             * s, and we might not see s if already popped or another\n-             * unsplicer has removed it. But we can stop when we see\n-             * any node known to follow s. We use s.next unless it is\n-             * not live, in which case we try the node one past. We\n-             * don't check any further because we don't want to doubly\n-             * traverse just to find sentinel.\n-             *\/\n+        private void unspliceLifo(DualNode s) {\n+            DualNode past = null;\n@@ -218,12 +218,7 @@\n-\n-            TransferNode p = tail;           \/\/ collapse top\n-            while (p != null && p != past && !p.isLive()) {\n-                TransferNode n = p.next, h = cmpExTail(p, n);\n-                p = (h == p) ? n : h;\n-            }\n-\n-            for (TransferNode n, f, u;;) {   \/\/ unsplice embedded nodes\n-                if (p == null || p == past || (n = p.next) == null)\n-                    break;\n-                p = (n.isLive() ? n :\n-                     n == (u = p.cmpExNext(n, f = n.next)) ? f : u);\n+            DualNode p = head;      \/\/ collapse dead nodes at top\n+            for (DualNode n, u; p != null && p != past && !p.isLive(); )\n+                p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n+            for (DualNode f, n, u;  \/\/ unsplice embedded nodes\n+                 p != null && p != past && (f = p.next) != null; ) {\n+                p = (f.isLive() ? f :\n+                     f == (u = p.cmpExNext(f, n = f.next)) ? n : u);\n@@ -242,1 +237,1 @@\n-    private Object xfer(boolean fair, Object e, long nanos) {\n+    private Object xfer(Object e, long nanos) {\n@@ -275,1 +270,1 @@\n-            if (xfer(fair, e, Long.MAX_VALUE) == null)\n+            if (xfer(e, Long.MAX_VALUE) == null)\n@@ -295,1 +290,1 @@\n-        if (xfer(fair, e, nanos) == null)\n+        if (xfer(e, nanos) == null)\n@@ -313,1 +308,1 @@\n-        return xfer(fair, e, 0L) == null;\n+        return xfer(e, 0L) == null;\n@@ -327,1 +322,1 @@\n-            if ((e = xfer(fair, null, Long.MAX_VALUE)) != null)\n+            if ((e = xfer(null, Long.MAX_VALUE)) != null)\n@@ -347,1 +342,1 @@\n-        if ((e = xfer(fair, null, nanos)) != null || !Thread.interrupted())\n+        if ((e = xfer(null, nanos)) != null || !Thread.interrupted())\n@@ -361,1 +356,1 @@\n-        return (E) xfer(fair, null, 0L);\n+        return (E) xfer(null, 0L);\n@@ -594,1 +589,1 @@\n-     * the associated type of Transferer.\n+     * the associated fairness\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":70,"deletions":75,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+\n@@ -65,9 +66,14 @@\n-    public WhiteBox() throws ReflectiveOperationException {\n-        Class<?> qClass = LinkedTransferQueue.class;\n-        Class<?> nodeClass = Class.forName(qClass.getName() + \"$TransferNode\");\n-        MethodHandles.Lookup lookup\n-            = MethodHandles.privateLookupIn(qClass, MethodHandles.lookup());\n-        HEAD = lookup.findVarHandle(qClass, \"head\", nodeClass);\n-        TAIL = lookup.findVarHandle(qClass, \"tail\", nodeClass);\n-        NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n-        ITEM = lookup.findVarHandle(nodeClass, \"item\", Object.class);\n+    public WhiteBox() throws Throwable { \/\/ throws ReflectiveOperationException {\n+        try {\n+            Class<?> qClass = LinkedTransferQueue.class;\n+            Class<?> nodeClass = Class.forName(qClass.getName() + \"$DualNode\");\n+            MethodHandles.Lookup lookup\n+                = MethodHandles.privateLookupIn(qClass, MethodHandles.lookup());\n+            HEAD = lookup.findVarHandle(qClass, \"head\", nodeClass);\n+            TAIL = lookup.findVarHandle(qClass, \"tail\", nodeClass);\n+            NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n+            ITEM = lookup.findVarHandle(nodeClass, \"item\", Object.class);\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            throw ex;\n+        }\n@@ -81,0 +87,10 @@\n+    \/*\n+     * Modified for jdk22: Accommodate lazy initialization, so counts\n+     * may vary by 1, and some nodes become headers vs unlinked,\n+     * compared to previous versions.\n+     *\/\n+\n+    static void checkCount(int val, int expect) {\n+        assertTrue(val == expect || val == expect - 1);\n+    }\n+\n@@ -99,10 +115,0 @@\n-    \/*\n-     * Modified for jdk22: Accommodate lazy initialization, so counts\n-     * may vary by 1, and some nodes become headers vs unlinked,\n-     * compared to previous versions.\n-     *\/\n-\n-    static void checkNodeCount(int c, int n) {\n-        assertTrue(c == n || c == n - 1); \/\/ May or may not include header node\n-    }\n-\n@@ -142,1 +148,1 @@\n-        checkNodeCount(nodeCount(q), 2);\n+        checkCount(nodeCount(q), 2);\n@@ -145,1 +151,1 @@\n-        checkNodeCount(nodeCount(q), 1);\n+        checkCount(nodeCount(q), 1);\n@@ -173,1 +179,1 @@\n-        checkNodeCount(nodeCount(q), n + 1);\n+        checkCount(nodeCount(q), n + 1);\n@@ -177,1 +183,2 @@\n-        checkNodeCount(nodeCount(q), n);\n+        checkCount(nodeCount(q), n);\n+        \/\/        assertIsSelfLinked(oldHead);\n@@ -218,1 +225,1 @@\n-        assertEquals(nodeCount(q), c - 1);\n+        checkCount(nodeCount(q), c - 1);\n@@ -231,1 +238,1 @@\n-        assertEquals(nodeCount(q), c - 1);\n+        checkCount(nodeCount(q), c - 1);\n@@ -242,1 +249,1 @@\n-        int n = rnd.nextInt(6);\n+        int n = 1 + rnd.nextInt(6);\n@@ -252,1 +259,1 @@\n-        checkNodeCount(c - (q.contains(n - 1) ? 0 : 1), q.size());\n+        checkCount(c - (q.contains(n - 1) ? 0 : 1), q.size() + 1);\n@@ -277,1 +284,1 @@\n-        checkNodeCount(nodeCount(q), 1);\n+        checkCount(nodeCount(q), 1);\n@@ -303,1 +310,1 @@\n-        checkNodeCount(nodeCount(q), n + 1);\n+        checkCount(nodeCount(q), n + 1);\n@@ -309,1 +316,1 @@\n-            assertEquals(nodeCount(q), q.isEmpty() ? 1 : c - (slack ? 2 : 0));\n+            checkCount(nodeCount(q), q.isEmpty() ? 1 : c - (slack ? 2 : 0));\n@@ -381,2 +388,3 @@\n-        for (Object h; (h = head(q)) != null && next(h) == h; )\n-            assertNotSame(h, head(q)); \/\/ must be update race\n+        Object h;\n+        if ((h = head(q)) != null)\n+            assertNotSame(h, next(h));\n","filename":"test\/jdk\/java\/util\/concurrent\/LinkedTransferQueue\/WhiteBox.java","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"}]}