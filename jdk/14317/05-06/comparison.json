{"files":[{"patch":"@@ -144,1 +144,1 @@\n-     * pointer updates, that provide the current value to comtinue\n+     * pointer updates, that provide the current value to continue\n@@ -205,2 +205,1 @@\n-     * lagged behind a head-update, and so must restart from the\n-     * \"head\".\n+     * lagged behind a head-update, and so must restart.\n@@ -228,6 +227,7 @@\n-     * appended. (2) We cannot necessarily unlink s given a\n-     * predecessor node that is matched (including the case of being\n-     * cancelled): the predecessor may already be unspliced, in which\n-     * case some previous reachable node may still point to s.\n-     * (For further explanation see Herlihy & Shavit \"The Art of\n-     * Multiprocessor Programming\" chapter 9).\n+     * appended. (2) Unless we know it is already off-list, we cannot\n+     * necessarily unlink s given a predecessor node that is matched\n+     * (including the case of being cancelled): the predecessor may\n+     * already be unspliced, in which case some previous reachable\n+     * node may still point to s.  (For further explanation see\n+     * Herlihy & Shavit \"The Art of Multiprocessor Programming\"\n+     * chapter 9).\n@@ -275,2 +275,2 @@\n-     *   used in other j.u.c classes. in particular, SynchronousQueue.\n-     * * Blocking control (in class TransferQueue) accommodates\n+     *   usable in other j.u.c classes. in particular, SynchronousQueue.\n+     * * Blocking control (in class DualNode) accommodates\n@@ -279,2 +279,2 @@\n-     *   default-initializable (to null), allowing further\n-     *   extension (in particular, SynchronousQueue.Transferer)\n+     *   default-initializable (to null), allowing further extension\n+     *   (in particular, SynchronousQueue.Transferer)\n@@ -282,3 +282,4 @@\n-     *   to a dummy node, also reducing retries under heavy contention\n-     *   and misordering, requiring accommodation in many places (as\n-     *   well as adjustments in WhiteBox tests),\n+     *   to a dummy node, while also reducing retries under heavy\n+     *   contention and misorderings, and relaxing some accesses,\n+     *   requiring accommodation in many places (as well as\n+     *   adjustments in WhiteBox tests).\n@@ -289,1 +290,61 @@\n-     * for items to allow cancellation and forgetting after use.\n+     * for items to allow cancellation and forgetting after use. Only\n+     * field \"item\" is declared volatile (with bypasses for\n+     * pre-publication and post-match writes), although field \"next\"\n+     * is also CAS-able. Other accesses are constrained by context\n+     * (including dependent chains of next's headed by a volatile\n+     * read).\n+     *\n+     * This class also arranges blocking while awaiting matches.\n+     * Control of blocking (and thread scheduling in general) for\n+     * possibly-synchronous queues (and channels etc constructed\n+     * from them) must straddle two extremes: If there are too few\n+     * underlying cores for a fulfilling party to continue, then\n+     * the caller must park to cause a context switch. On the\n+     * other hand, if the queue is busy with approximately the\n+     * same number of independent producers and consumers, then\n+     * that context switch may cause an order-of-magnitude\n+     * slowdown. Many cases are somewhere in-between, in which\n+     * case threads should try spinning and then give up and\n+     * block. We deal with this as follows:\n+     *\n+     * 1. Callers to method await indicate eligibility for\n+     * spinning when the node is either the only waiting node, or\n+     * the next matchable node is still spinning.  Otherwise, the\n+     * caller may block (almost) immediately.\n+     *\n+     * 2. Even if eligible to spin, a caller blocks anyway in two\n+     * cases where it is normally best: If the thread isVirtual,\n+     * or the system is a uniprocessor. Uniprocessor status can\n+     * vary over time (due to virtualization at other system\n+     * levels), but checking Runtime availableProcessors can be\n+     * slow and may itself acquire blocking locks, so we only\n+     * occasionally (using ThreadLocalRandom) update when an\n+     * otherwise-eligible spin elapses.\n+     *\n+     * 3. When enabled, spins should be long enough to cover\n+     * bookeeping overhead of almost-immediate fulfillments, but\n+     * much less than the expected time of a (non-virtual)\n+     * park\/unpark context switch.  The optimal value is\n+     * unknowable, in part because the relative costs of\n+     * Thread.onSpinWait versus park\/unpark vary across platforms.\n+     * The current value is an empirical compromise across tested\n+     * platforms.\n+     *\n+     * 4. When using timed waits, callers spin instead of invoking\n+     * timed park if the remaining time is less than the likely\n+     * cost of park\/unpark. This also avoids re-parks when timed\n+     * park returns just barely too soon.\n+     *\n+     * 5. Park\/unpark signalling otherwise relies on a Dekker-like\n+     * scheme in which the caller advertises the need to unpark by\n+     * setting its waiter field, followed by a full fence and recheck\n+     * before actually parking. An explicit fence in used here rather\n+     * than unnecessarily requiring volatile accesses elsewhere.\n+     *\n+     * 6. To make the above work, callers must precheck that\n+     * timeouts are not already elapsed, and that interruptible\n+     * operations were not already interrupted on call to the\n+     * corresponding queue operation.  Cancellation on timeout or\n+     * interrupt otherwise proceeds by trying to fulfill with an\n+     * impossible value (which is one reason that we use Object\n+     * types here rather than typed fields).\n@@ -293,2 +354,2 @@\n-        volatile DualNode next;\n-        Thread waiter;          \/\/ plain mode; order constrained by context\n+        DualNode next;          \/\/ accessed only in chains of volatile ops\n+        Thread waiter;          \/\/ access order constrained by context\n@@ -310,0 +371,5 @@\n+        \/** Returns true if this node has been matched or cancelled  *\/\n+        final boolean matched() {\n+            return isData != (item != null);\n+        }\n+\n@@ -311,1 +377,3 @@\n-         * Returns true if this node has not been matched (or cancelled)\n+         * Relaxed write to replace reference to user data with\n+         * self-link. Can be used only if not already null after\n+         * match.\n@@ -313,2 +381,2 @@\n-        final boolean isLive() {\n-            return isData == (item != null);\n+        final void selfLinkItem() {\n+            ITEM.set(this, this);\n@@ -317,4 +385,2 @@\n-        \/\/ Relaxed writes when volatile is unnecessarily strong\n-        final void forgetItem()        { ITEM.set(this, this); }\n-        final void selfLink()          { NEXT.set(this, this); }\n-        final void setNext(DualNode n) { NEXT.set(this, n);  }\n+        \/** The number of times to spin when eligible *\/\n+        private static final int SPINS = 1 << 7;\n@@ -322,8 +388,19 @@\n-        \/\/ ManagedBlocker support\n-        public final boolean isReleasable() {\n-            return (!isLive() || Thread.currentThread().isInterrupted());\n-        }\n-        public final boolean block() {\n-            while (!isReleasable()) LockSupport.park();\n-            return true;\n-        }\n+        \/**\n+         * The number of nanoseconds for which it is faster to spin\n+         * rather than to use timed park. A rough estimate suffices.\n+         *\/\n+        private static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1L << 10;\n+\n+        \/**\n+         * True if system is a uniprocessor, occasionally rechecked.\n+         *\/\n+        private static boolean isUniprocessor =\n+            (Runtime.getRuntime().availableProcessors() == 1);\n+\n+        \/**\n+         * Refresh rate (probablility) for updating isUniprocessor\n+         * field, to reduce the likeihood that multiple calls to await\n+         * will contend invoking Runtime.availableProcessors.  Must be\n+         * a power of two minus one.\n+         *\/\n+        private static final int UNIPROCESSOR_REFRESH_RATE = (1 << 5) - 1;\n@@ -334,56 +411,0 @@\n-         * Control of blocking (and thread scheduling in general) for\n-         * possibly-synchronous queues (and channels etc constructed\n-         * from them) must straddle two extremes: If there are too few\n-         * underlying cores for a fulfilling party to continue, then\n-         * the caller must park to cause a context switch. On the\n-         * other hand, if the queue is busy with approximately the\n-         * same number of independent producers and consumers, then\n-         * that context switch causes a huge slowdown (often more than\n-         * 20X). Many cases are somewhere in-between, in which case\n-         * threads should try spinning and then give up and block. We\n-         * deal with this as follows:\n-         *\n-         * 1. Callers to method await indicate eligibility for\n-         * spinning when the node is either the only waiting node, or\n-         * the next eligible node is still spinning.  Otherwise, the\n-         * caller normally blocks (almost) immediately.\n-         *\n-         * 2. Even if eligible to spin, a caller blocks anyway in two\n-         * cases where it is normally best: If the thread is Virtual,\n-         * or the system is a uniprocessor. Because uniprocessor\n-         * status can vary over time (due to virtualization at other\n-         * system levels), we update it whenever an otherwise-eligible\n-         * spin elapses. (Updates to static field isUniprocessor are\n-         * allowed to be racy -- if status is dynamically varying,\n-         * tracking is at best approximate.)\n-         *\n-         * 3. When enabled, spins should be long enough to cover\n-         * bookeeping overhead of almost-immediate fulfillments, but\n-         * much less than the expected time of a (non-virtual)\n-         * park\/unpark context switch.  The optimal value is\n-         * unknowable, in part because the relative costs of\n-         * Thread.onSpinWait versus park\/unpark vary across platforms.\n-         * The current value is an empirical compromise across tested\n-         * platforms.\n-         *\n-         * 4. When using timed waits, callers spin instead of invoking\n-         * timed park if the remaining time is less than the likely\n-         * cost of park\/unpark. This also avoids re-parks when timed\n-         * park returns just barely too soon.\n-         *\n-         * 5. Park\/unpark signalling otherwise relies on a Dekker-like\n-         * scheme in which the caller advertises the need to unpark by\n-         * setting its waiter field, followed by a full fence and\n-         * recheck before actually parking. (An explicit fence in used\n-         * in this one case rather than requiring volatile mode,\n-         * rather than overconstraining waiter accesses that are\n-         * otherwise already constrained by surrounding atomics.)\n-         *\n-         * 6. To make the above work, callers must precheck that\n-         * timeouts are not already elapsed, and that interruptible\n-         * operations were not already interrupted on call to the\n-         * corresponding queue operation.  Cancellation on timeout or\n-         * interrupt otherwise proceeds by trying to fulfill with an\n-         * impossible value (which is one reason that we use Object\n-         * types here rather than tyoed results).\n-         *\n@@ -391,1 +412,1 @@\n-         * @param nanos timeout, or Long.MAX_VALUE if untimed\n+         * @param ns timeout, or Long.MAX_VALUE if untimed\n@@ -393,1 +414,1 @@\n-         * @param spin true if eligible for spinning when enabled\n+         * @param spin true if should spin when enabled\n@@ -396,3 +417,5 @@\n-        final Object await(Object e, long nanos, Object blocker, boolean spin) {\n-            boolean timed = (nanos != Long.MAX_VALUE);\n-            long deadline = (timed) ? System.nanoTime() + nanos : 0L;\n+        final Object await(Object e, long ns, Object blocker, boolean spin) {\n+            Object m;                      \/\/ the match or e if none\n+            boolean timed = (ns != Long.MAX_VALUE);\n+            long deadline = (timed) ? System.nanoTime() + ns : 0L;\n+            boolean upc = isUniprocessor;  \/\/ don't spin but later recheck\n@@ -400,19 +423,13 @@\n-            boolean canSpin = (!w.isVirtual() && spin);\n-            int spins = (canSpin && !isUniprocessor) ? SPINS : 0;\n-            Object match;\n-            while ((match = item) == e && --spins >= 0)\n-                Thread.onSpinWait();\n-            if (match == e) {\n-                boolean uni;\n-                if (canSpin && isUniprocessor !=\n-                    (uni = (Runtime.getRuntime().availableProcessors() <= 1)))\n-                    isUniprocessor = uni; \/\/ reset for next time\n-                LockSupport.setCurrentBlocker(blocker);\n-                waiter = w;\n-                VarHandle.fullFence(); \/\/ ensure ordering\n-                while ((match = item) == e) {\n-                    long ns = 0L;\n-                    if (w.isInterrupted() ||\n-                        (timed && ((ns = deadline - System.nanoTime()) <= 0L))) {\n-                        match = cmpExItem(e, (e == null) ? this : null);\n-                        break;         \/\/ try to cancel with impossible match\n+            if (w.isVirtual())             \/\/ don't spin\n+                spin = false;\n+            int spins = (spin & !upc) ? SPINS : 0; \/\/ negative when may park\n+            while ((m = item) == e) {\n+                if (spins >= 0) {\n+                    if (--spins >= 0)\n+                        Thread.onSpinWait();\n+                    else {                 \/\/ prepare to park\n+                        if (spin)          \/\/ occasionally recheck\n+                            checkForUniprocessor(upc);\n+                        LockSupport.setCurrentBlocker(blocker);\n+                        waiter = w;        \/\/ ensure ordering\n+                        VarHandle.fullFence();\n@@ -420,12 +437,18 @@\n-                    if (timed) {\n-                        if (ns < SPIN_FOR_TIMEOUT_THRESHOLD)\n-                            Thread.onSpinWait();\n-                        else\n-                            LockSupport.parkNanos(ns);\n-                    } else if (w instanceof ForkJoinWorkerThread) {\n-                        try {\n-                            ForkJoinPool.managedBlock(this);\n-                        } catch (InterruptedException cannotHappen) { }\n-                    } else\n-                        LockSupport.park();\n-                }\n+                } else if (w.isInterrupted() ||\n+                           (timed &&       \/\/ try to cancel with impossible match\n+                            ((ns = deadline - System.nanoTime()) <= 0L))) {\n+                    m = cmpExItem(e, (e == null) ? this : null);\n+                    break;\n+                } else if (timed) {\n+                    if (ns < SPIN_FOR_TIMEOUT_THRESHOLD)\n+                        Thread.onSpinWait();\n+                    else\n+                        LockSupport.parkNanos(ns);\n+                } else if (w instanceof ForkJoinWorkerThread) {\n+                    try {\n+                        ForkJoinPool.managedBlock(this);\n+                    } catch (InterruptedException cannotHappen) { }\n+                } else\n+                    LockSupport.park();\n+            }\n+            if (spins < 0) {\n@@ -435,3 +458,1 @@\n-            if (match != e && match != null)\n-                forgetItem();\n-            return match;\n+            return m;\n@@ -440,10 +461,9 @@\n-        \/**\n-         * The number of times to spin when eligible.\n-         *\/\n-        private static final int SPINS = 1 << 7;\n-\n-        \/**\n-         * The number of nanoseconds for which it is faster to spin\n-         * rather than to use timed park. A rough estimate suffices.\n-         *\/\n-        private static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1L << 10;\n+        \/** Occasionally updates isUniprocessor field *\/\n+        private void checkForUniprocessor(boolean prev) {\n+            int r = ThreadLocalRandom.nextSecondarySeed();\n+            if ((r & UNIPROCESSOR_REFRESH_RATE) == 0) {\n+                boolean u = (Runtime.getRuntime().availableProcessors() == 1);\n+                if (u != prev)\n+                    isUniprocessor = u;\n+            }\n+        }\n@@ -451,4 +471,8 @@\n-        \/**\n-         * True if system is a uniprocessor. Initially assumed false.\n-         *\/\n-        private static boolean isUniprocessor;\n+        \/\/ ManagedBlocker support\n+        public final boolean isReleasable() {\n+            return (matched() || Thread.currentThread().isInterrupted());\n+        }\n+        public final boolean block() {\n+            while (!isReleasable()) LockSupport.park();\n+            return true;\n+        }\n@@ -474,8 +498,0 @@\n-    \/**\n-     * The maximum number of estimated removal failures (sweepVotes)\n-     * to tolerate before sweeping through the queue unlinking\n-     * cancelled nodes that were initially pinned.  Must be a power of\n-     * two, at least 4.\n-     *\/\n-    private static final int SWEEP_THRESHOLD = 1 << 5;\n-\n@@ -497,1 +513,1 @@\n-     * Unless empty, a node from which the last node on list (that is,\n+     * Unless null, a node from which the last node on list (that is,\n@@ -509,1 +525,1 @@\n-    private transient volatile int sweepVotes;\n+    transient volatile int sweepVotes;\n@@ -519,2 +535,15 @@\n-    final int addSweepVote() {\n-        return (int)SWEEPVOTES.getAndAdd(this, 1);\n+\n+    \/**\n+     * The maximum number of estimated removal failures (sweepVotes)\n+     * to tolerate before sweeping through the queue unlinking\n+     * dead nodes that were initially pinned.  Must be a power of\n+     * two minus one, at least 3.\n+     *\/\n+    static final int SWEEP_THRESHOLD = (1 << 4) - 1;\n+\n+    \/**\n+     * Adds a sweepVote and returns true if triggered threshold.\n+     *\/\n+    final boolean sweepNow() {\n+        return (SWEEP_THRESHOLD ==\n+                ((int)SWEEPVOTES.getAndAdd(this, 1) & (SWEEP_THRESHOLD)));\n@@ -531,2 +560,2 @@\n-     * * On success, update head or tail if slacked, and return or wait,\n-     *   depending on nanos argument\n+     * * On success, update head or tail if slacked, and possibly wait,\n+     *   depending on ns argument\n@@ -535,2 +564,2 @@\n-     * @param nanos timeout, or negative for async, 0 for immediate,\n-     *        Long.MAX_VALUE for untimed\n+     * @param ns timeout or negative if async, 0 if immediate,\n+     *        Long.MAX_VALUE if untimed\n@@ -539,1 +568,1 @@\n-    final Object xfer(Object e, long nanos) {\n+    final Object xfer(Object e, long ns) {\n@@ -541,15 +570,9 @@\n-        DualNode s = null;                   \/\/ the enqueued node, if needed\n-        DualNode pred;                       \/\/ s's predecessor if waiting\n-        DualNode prevTail = null;            \/\/ to avoid self-linked paths\n-        restart: for (;;) {                  \/\/ restart if fall off list\n-            DualNode h, t, p;\n-            if ((h = head) == null) {        \/\/ initialize\n-                if (nanos == 0L)             \/\/ unless immediate\n-                    return e;\n-                s = new DualNode(e, haveData);\n-                if ((h = cmpExHead(null, s)) == null) {\n-                    if (nanos < 0L)\n-                        return e;            \/\/ async mode\n-                    pred = null;\n-                    break;                   \/\/ wait below\n-                }\n+        Object m;                           \/\/ the match or e if none\n+        DualNode s = null, p;               \/\/ enqueued node and its predecessor\n+        restart: for (DualNode prevp = null;;) {\n+            DualNode h, t, q;\n+            if ((h = head) == null &&       \/\/ initialize unless immediate\n+                (ns == 0L ||\n+                 (h = cmpExHead(null, s = new DualNode(e, haveData))) == null)) {\n+                p = null;                   \/\/ no predecessor\n+                break;                      \/\/ else lost init race\n@@ -557,13 +580,10 @@\n-            p = ((t = tail) != null && t != prevTail && t.isData == haveData ?\n-                 (prevTail = t) : h);        \/\/ start at tail if may be eligible\n-            for (boolean slack = false; ; slack = true) {\n-                DualNode q; Object item;\n-                if (haveData != p.isData &&  \/\/ try to match existing node\n-                    haveData != ((item = p.item) != null) &&\n-                    p.cmpExItem(item, e) == item) {\n-                    Thread w = p.waiter;\n-                    if (slack) {\n-                        DualNode n = ((q = p.next) == null) ? p : q;\n-                        if (h != n && h == cmpExHead(h, n))\n-                            h.selfLink();    \/\/ advance by 2 if possible\n-                    }\n+            p = (t = tail) != null && t.isData == haveData && t != prevp ? t : h;\n+            prevp = p;                      \/\/ avoid known self-linked tail path\n+            do {\n+                m = p.item;\n+                q = p.next;\n+                if (p.isData != haveData && haveData != (m != null) &&\n+                    p.cmpExItem(m, e) == m) {\n+                    Thread w = p.waiter;    \/\/ matched complementary node\n+                    if (p != h && h == cmpExHead(h, (q == null) ? p : q))\n+                        h.next = h;         \/\/ advance head; self-link old\n@@ -571,6 +591,5 @@\n-                    return item;\n-                }\n-                if ((q = p.next) == null) {  \/\/ try to append\n-                    if (nanos == 0L)         \/\/ unless immediate\n-                        return e;\n-                    if (s == null) {\n+                    return m;\n+                } else if (q == null) {\n+                    if (ns == 0L)           \/\/ try to append unless immediate\n+                        break restart;\n+                    if (s == null)\n@@ -578,4 +597,2 @@\n-                        q = p.next;          \/\/ recheck after allocation\n-                    }\n-                    if (q == null && (q = p.cmpExNext(null, s)) == null) {\n-                        if (slack)\n+                    if ((q = p.cmpExNext(null, s)) == null) {\n+                        if (p != t)\n@@ -583,3 +600,0 @@\n-                        if (nanos < 0L)\n-                            return e;\n-                        pred = p;\n@@ -589,3 +603,1 @@\n-                if (p == (p = q))            \/\/ self-linked; restart\n-                    break;\n-            }\n+            } while (p != (p = q));         \/\/ restart if self-linked\n@@ -593,5 +605,8 @@\n-        Object match = s.await(e, nanos, this, \/\/ spin if at or near head\n-                               pred == null || pred.waiter == null);\n-        if (match == e)\n-            unsplice(pred, s);               \/\/ cancelled\n-        return match;\n+        if (s == null || ns <= 0L)\n+            m = e;                          \/\/ don't wait\n+        else if ((m = s.await(e, ns, this,  \/\/ spin if at or near head\n+                              p == null || p.waiter == null)) == e)\n+            unsplice(p, s);                 \/\/ cancelled\n+        else if (m != null)\n+            s.selfLinkItem();\n+        return m;\n@@ -607,1 +622,1 @@\n-     * predecessor of s\n+     * predecessor of s (else s may have been head)\n@@ -611,11 +626,27 @@\n-        DualNode sn;\n-        if (pred != null && pred.next == s && s != null && (sn = s.next) != s) {\n-            if (sn != null)\n-                pred.cmpExNext(s, sn);\n-            if ((sn == null || !pred.isLive()) &&\n-                ((addSweepVote() + 1) & (SWEEP_THRESHOLD - 1)) == 0) {\n-                for (DualNode p = head, f, n, u;  \/\/ occasionally sweep\n-                     p != null && (f = p.next) != null && (n = f.next) != null;)\n-                    p = (f.isLive()                   ? f :     \/\/ skip\n-                         f == p                       ? head :  \/\/ stale\n-                         f == (u = p.cmpExNext(f, n)) ? n : u); \/\/ unspliced\n+        boolean seen = false; \/\/ try removing by collapsing head\n+        for (DualNode h = head, p = h, f; p != null;) {\n+            boolean matched;\n+            if (p == s)\n+                matched = seen = true;\n+            else\n+                matched = p.matched();\n+            if ((f = p.next) == p)\n+                p = h = head;\n+            else if (f != null && matched)\n+                p = f;\n+            else {\n+                if (p != h && cmpExHead(h, p) == h)\n+                    h.next = h; \/\/ h.selfLink();\n+                break;\n+            }\n+        }\n+        DualNode sn;      \/\/ try to unsplice if not pinned\n+        if (!seen &&\n+            pred != null && pred.next == s && s != null && (sn = s.next) != s &&\n+            (sn == null || pred.cmpExNext(s, sn) != s || pred.matched()) &&\n+            sweepNow()) { \/\/ occasionally sweep if might not have been removed\n+            for (DualNode p = head, f, n, u;\n+                 p != null && (f = p.next) != null && (n = f.next) != null;) {\n+                p = (f == p                       ? head :  \/\/ stale\n+                     !f.matched()                 ? f :     \/\/ skip\n+                     f == (u = p.cmpExNext(f, n)) ? n : u); \/\/ unspliced\n@@ -624,11 +655,0 @@\n-    }\n-\n-    \/**\n-     * Tries to update to new head, forgetting links from previous\n-     * head (if it exists) on success.\n-     *\/\n-    final DualNode tryAdvanceHead(DualNode h, DualNode p) {\n-        DualNode u;\n-        if ((u = cmpExHead(h, p)) == h && h != null)\n-            h.selfLink();\n-        return u;\n@@ -642,4 +662,8 @@\n-        \/\/ assert p != null && !c.isLive() && c != p;\n-        return ((pred != null ?\n-                 pred.cmpExNext(c, p) :\n-                 tryAdvanceHead(c, p))) == c;\n+        \/\/ assert p != null && c.matched() && c != p;\n+        if (pred != null)\n+            return pred.cmpExNext(c, p) == c;\n+        else if (cmpExHead(c, p) != c)\n+            return false;\n+        if (c != null)\n+            c.next = c;\n+        return true;\n@@ -658,1 +682,1 @@\n-        \/\/ assert pred != c && p != q; && !c.isLive() && !p.isLive();\n+        \/\/ assert pred != c && p != q; && c.matched() && p.matched();\n@@ -664,1 +688,1 @@\n-        return (tryCasSuccessor(pred, c, q) && (pred == null || pred.isLive()))\n+        return (tryCasSuccessor(pred, c, q) && (pred == null || !pred.matched()))\n@@ -700,3 +724,1 @@\n-            else if (p != h)                  \/\/ collapse\n-                p = h = ((u = tryAdvanceHead(h, q)) == h) ? q : u;\n-            else                              \/\/ traverse past header\n+            else if (p == h)                  \/\/ traverse past header\n@@ -704,0 +726,6 @@\n+            else if ((u = cmpExHead(h, q)) != h)\n+                p = h = u;                    \/\/ lost update race\n+            else {\n+                h.next = h;                   \/\/ collapse; self-link\n+                p = h = q;\n+            }\n@@ -716,1 +744,1 @@\n-                if (p.isLive()) {\n+                if (!p.matched()) {\n@@ -868,2 +896,3 @@\n-                final Object item;\n-                if ((item = p.item) != null && p.isData) {\n+                boolean isData = p.isData;\n+                Object item = p.item;\n+                if (isData && item != null) {\n@@ -876,1 +905,1 @@\n-                else if (!p.isData && item == null)\n+                else if (!isData && item == null)\n@@ -900,1 +929,1 @@\n-            final DualNode p;\n+            DualNode p;\n@@ -953,1 +982,1 @@\n-            \/\/ assert !lastRet.isLive();\n+            \/\/ assert lastRet.matched();\n@@ -1010,2 +1039,2 @@\n-                    final boolean isData = p.isData;\n-                    final Object item = p.item;\n+                    boolean isData = p.isData;\n+                    Object item = p.item;\n@@ -1093,1 +1122,1 @@\n-                t = h = newNode;\n+                h = newNode;\n@@ -1095,1 +1124,2 @@\n-                t.setNext(t = newNode);\n+                t.next = newNode;\n+            t = newNode;\n@@ -1356,0 +1386,2 @@\n+                boolean isData = p.isData;\n+                Object item = p.item;\n@@ -1357,3 +1389,2 @@\n-                final Object item;\n-                if ((item = p.item) != null) {\n-                    if (p.isData) {\n+                if (item != null) {\n+                    if (isData) {\n@@ -1367,1 +1398,1 @@\n-                else if (!p.isData)\n+                else if (!isData)\n@@ -1370,1 +1401,1 @@\n-                    if (q == null || q.isLive()) {\n+                    if (q == null || !q.matched()) {\n@@ -1392,0 +1423,2 @@\n+                boolean isData = p.isData;\n+                Object item = p.item;\n@@ -1393,3 +1426,2 @@\n-                final Object item;\n-                if ((item = p.item) != null) {\n-                    if (p.isData) {\n+                if (item != null) {\n+                    if (isData) {\n@@ -1401,1 +1433,1 @@\n-                else if (!p.isData)\n+                else if (!isData)\n@@ -1404,1 +1436,1 @@\n-                    if (q == null || q.isLive()) {\n+                    if (q == null || !q.matched()) {\n@@ -1457,1 +1489,1 @@\n-                t = h = newNode;\n+                h = newNode;\n@@ -1459,1 +1491,2 @@\n-                t.setNext(t = newNode);\n+                t.next = newNode;\n+            t = newNode;\n@@ -1509,0 +1542,2 @@\n+                boolean isData = p.isData, pAlive;\n+                Object item = p.item;\n@@ -1510,2 +1545,1 @@\n-                final Object item; boolean pAlive;\n-                if (pAlive = ((item = p.item) != null && p.isData)) {\n+                if (pAlive = (item != null && isData)) {\n@@ -1518,1 +1552,1 @@\n-                else if (!p.isData && item == null)\n+                else if (!isData && item == null)\n@@ -1524,2 +1558,1 @@\n-                    if ((c != p && !tryCasSuccessor(pred, c, c = p))\n-                        || pAlive) {\n+                    if ((c != p && !tryCasSuccessor(pred, c, c = p)) || pAlive) {\n@@ -1545,0 +1578,2 @@\n+            boolean isData = p.isData;\n+            Object item = p.item;\n@@ -1546,3 +1581,2 @@\n-            final Object item;\n-            if ((item = p.item) != null) {\n-                if (p.isData) {\n+            if (item != null) {\n+                if (isData) {\n@@ -1553,1 +1587,1 @@\n-            else if (!p.isData)\n+            else if (!isData)\n@@ -1556,1 +1590,1 @@\n-                if (q == null || q.isLive()) {\n+                if (q == null || !q.matched()) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":307,"deletions":273,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-     * representing take operations, or is empty. A \"fulfill\"\n+     * representing take operations, or is empty. A fulfilling\n@@ -117,6 +117,6 @@\n-     * data or vice versa) dequeues a complementary node.  Any\n-     * operation can figure out which mode the queue is in, and act\n-     * accordingly without needing locks.  So put and take operations\n-     * are symmetrical, and all transfer methods invoke a single\n-     * method \"xfer\" that does a put or a take in either fifo or lifo\n-     * mode.\n+     * data or vice versa) \"matches\" the item of and then dequeues a\n+     * complementary node.  Any operation can figure out which mode\n+     * the queue is in, and act accordingly without needing locks.  So\n+     * put and take operations are symmetrical, and all transfer\n+     * methods invoke a single \"xfer\" method that does a put or a take\n+     * in either fifo or lifo mode.\n@@ -127,5 +127,2 @@\n-     *  *  For historical compatibility, Fifo mode directly uses\n-     *     LinkedTransferQueue operations, but Lifo mode support is\n-     *     added in subclass Transferer.\n-     *  *  The original algorithms used bit-marked pointers, but\n-     *     the ones here use mode bits in nodes, and usually avoid\n+     *  * The original algorithms used bit-marked pointers, but the\n+     *     ones here use a bit (isData) in nodes, and usually avoid\n@@ -133,9 +130,11 @@\n-     *     compareAndExchange form of CAS for pointer updates to reduce\n-     *     memory traffic. The Fifo version accommodates lazy\n-     *     updates and slack as desxcribed in the LinkedTransferQueue\n-     *     internal documentation.\n-     *  *  SynchronousQueues must block threads waiting to become\n-     *     fulfilled, sometimes preceded by brief spins.\n-     *  *  Support for cancellation via timeout and interrupts,\n-     *     including cleaning out cancelled nodes\/threads\n-     *     from lists to avoid garbage retention and memory depletion.\n+     *     compareAndExchange form of CAS for pointer updates to\n+     *     reduce memory traffic.\n+     *  * Fifo mode is based on LinkedTransferQueue operations, but\n+     *     Lifo mode support is added in subclass Transferer.\n+     *  * The Fifo version accommodates lazy updates and slack as\n+     *     described in LinkedTransferQueue internal documentation.\n+     *  * Threads may block when waiting to become fulfilled,\n+     *     sometimes preceded by brief spins.\n+     *  * Support for cancellation via timeout and interrupts,\n+     *     including cleaning out cancelled nodes\/threads from lists\n+     *     to avoid garbage retention and memory depletion.\n@@ -147,1 +146,1 @@\n-     * queue). Note that popped nodes are not self-linked because thay\n+     * queue). Note that popped nodes are not self-linked because they\n@@ -157,1 +156,1 @@\n-         * * If top (p) exists and is already matched, pop and continue\n+         * * If top (var p) exists and is already matched, pop and continue\n@@ -165,1 +164,1 @@\n-         * @param nanos timeout or 0 for immediate, Long.MAX_VALUE for untimed\n+         * @param ns timeout or 0 if immediate, Long.MAX_VALUE if untimed\n@@ -168,1 +167,1 @@\n-        final Object xferLifo(Object e, long nanos) {\n+        final Object xferLifo(Object e, long ns) {\n@@ -170,28 +169,15 @@\n-            for (DualNode s = null;;) {\n-                for (DualNode p = head;;) {\n-                    if (p != null) {\n-                        Object item; DualNode n, u;\n-                        boolean isData = p.isData;\n-                        if (isData != ((item = p.item) != null)) {\n-                            p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n-                            continue;                    \/\/ retry with next top\n-                        } else if (isData != haveData) { \/\/ try to fulfill\n-                            if (p.cmpExItem(item, e) != item)\n-                                break;                   \/\/ lost race; restart\n-                            Thread w = p.waiter;\n-                            cmpExHead(p, p.next);\n-                            LockSupport.unpark(w);\n-                            return item;\n-                        }\n-                    }\n-                    if (nanos == 0L)                     \/\/ no match, no wait\n-                        return e;\n-                    if (s == null)                       \/\/ push new node; wait\n-                        s = new DualNode(e, haveData);\n-                    s.setNext(p);\n-                    if (p == (p = cmpExHead(p, s))) {\n-                        Object match = s.await(e, nanos, this, \/\/ spin near empty\n-                                               p == null || p.waiter == null);\n-                        if (match == e)\n-                            unspliceLifo(s);             \/\/ cancelled\n-                        return match;\n+            Object m;                              \/\/ the match or e if none\n+            outer: for (DualNode s = null, p = head;;) {\n+                while (p != null) {\n+                    boolean isData; DualNode n, u; \/\/ help collapse\n+                    if ((isData = p.isData) != ((m = p.item) != null))\n+                        p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n+                    else if (isData == haveData)   \/\/ same mode; push below\n+                        break;\n+                    else if (p.cmpExItem(m, e) != m)\n+                        p = head;                  \/\/ missed; restart\n+                    else {                         \/\/ matched complementary node\n+                        Thread w = p.waiter;\n+                        cmpExHead(p, p.next);\n+                        LockSupport.unpark(w);\n+                        break outer;\n@@ -200,0 +186,13 @@\n+                if (ns == 0L) {                    \/\/ no match, no wait\n+                    m = e;\n+                    break;\n+                }\n+                if (s == null)                     \/\/ try to push node and wait\n+                    s = new DualNode(e, haveData);\n+                s.next = p;\n+                if (p == (p = cmpExHead(p, s))) {\n+                    if ((m = s.await(e, ns, this,  \/\/ spin if (nearly) empty\n+                                     p == null || p.waiter == null)) == e)\n+                        unspliceLifo(s);           \/\/ cancelled\n+                    break;\n+                }\n@@ -201,0 +200,1 @@\n+            return m;\n@@ -204,9 +204,1 @@\n-         * Unlinks (non-live) node s from stack.  Unlike fifo lists,\n-         * we don't have a known predecessor that usually suffices to\n-         * unlink.  At worst we may need to traverse entire list, and\n-         * we might not see s if already off-list or another unsplicer\n-         * has removed it. But we can stop when we see any node known\n-         * to follow s. We use s.next unless it is not live, in which\n-         * case we try the node one past. We don't check any further\n-         * because we don't want to doubly traverse just to find\n-         * sentinel.\n+         * Unlinks node s. Same idea as Fifo version.\n@@ -215,10 +207,12 @@\n-            DualNode past = null;\n-            if (s != null && (past = s.next) != null && !past.isLive())\n-                past = past.next;\n-            DualNode p = head;      \/\/ collapse dead nodes at top\n-            for (DualNode n, u; p != null && p != past && !p.isLive(); )\n-                p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n-            for (DualNode f, n, u;  \/\/ unsplice embedded nodes\n-                 p != null && p != past && (f = p.next) != null; ) {\n-                p = (f.isLive() ? f :\n-                     f == (u = p.cmpExNext(f, n = f.next)) ? n : u);\n+            boolean seen = false; \/\/ try removing by collapsing head\n+            DualNode p = head;\n+            for (DualNode f, u; p != null && p.matched();) {\n+                if (p == s)\n+                    seen = true;\n+                p = (p == (u = cmpExHead(p, (f = p.next)))) ? f : u;\n+            }\n+            if (p != null && !seen && sweepNow()) { \/\/ occasionally sweep\n+                for (DualNode f, n, u; p != null && (f = p.next) != null; ) {\n+                    p = (!f.matched() ? f :\n+                         f == (u = p.cmpExNext(f, n = f.next)) ? n : u);\n+                }\n@@ -227,1 +221,1 @@\n-   }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":67,"deletions":73,"binary":false,"changes":140,"status":"modified"}]}