{"files":[{"patch":"@@ -312,6 +312,18 @@\n-     *    the current thread was interrupted or the wait timed out. To\n-     *    improve performance in common single-source \/ single-sink\n-     *    usages when there are more tasks that cores, an initial\n-     *    Thread.yield is tried when there is apparently only one\n-     *    waiter.  In other cases, waiters may help with some\n-     *    bookkeeping, then park\/unpark.\n+     *    the current thread was interrupted or the wait timed out.\n+     *    If the caller is a VirtualThread, the most likely next step\n+     *    is for another to take the item, so an immediate (virtual)\n+     *    park\/unpark is used.  Otherwise (for non-Virtual threads),\n+     *    we use front-of-queue spinning: If a node appears to be the\n+     *    first unmatched node in the queue, it spins a bit before\n+     *    blocking. In either case, before blocking it tries to\n+     *    unsplice any nodes between the current \"head\" and the first\n+     *    unmatched node.\n+     *\n+     *    Front-of-queue spinning vastly improves performance of\n+     *    heavily contended queues. And so long as it is relatively\n+     *    brief and \"quiet\", spinning does not much impact performance\n+     *    of less-contended queues. We also use smaller (1\/2) spins\n+     *    for nodes that are not known to be front but whose\n+     *    predecessors have not blocked -- these \"chained\" spins avoid\n+     *    artifacts of front-of-queue rules which otherwise lead to\n+     *    alternating nodes spinning vs blocking.\n@@ -353,8 +365,22 @@\n-     * won't help for case (1) anyway), we record the need to sweep the\n-     * next time any thread would otherwise block in awaitMatch. Also,\n-     * because traversal operations on the linked list of nodes are a\n-     * natural opportunity to sweep dead nodes, we generally do so,\n-     * including all the operations that might remove elements as they\n-     * traverse, such as removeIf and Iterator.remove.  This largely\n-     * eliminates long chains of dead interior nodes, except from\n-     * cancelled or timed out blocking operations.\n+     * won't help for case (1) anyway), we record a conservative\n+     * estimate of possible unsplice failures (in \"sweepVotes\").\n+     * We trigger a full sweep when the estimate exceeds a threshold\n+     * (\"SWEEP_THRESHOLD\") indicating the maximum number of estimated\n+     * removal failures to tolerate before sweeping through, unlinking\n+     * cancelled nodes that were not unlinked upon initial removal.\n+     * We perform sweeps by the thread hitting threshold (rather than\n+     * background threads or by spreading work to other threads)\n+     * because in the main contexts in which removal occurs, the\n+     * caller is timed-out or cancelled, which are not time-critical\n+     * enough to warrant the overhead that alternatives would impose\n+     * on other threads.\n+     *\n+     * Because the sweepVotes estimate is conservative, and because\n+     * nodes become unlinked \"naturally\" as they fall off the head of\n+     * the queue, and because we allow votes to accumulate even while\n+     * sweeps are in progress, there are typically significantly fewer\n+     * such nodes than estimated.  Choice of a threshold value\n+     * balances the likelihood of wasted effort and contention, versus\n+     * providing a worst-case bound on retention of interior nodes in\n+     * quiescent queues. The value defined below was chosen\n+     * empirically to balance these under various timeout scenarios.\n@@ -375,0 +401,9 @@\n+    \/**\n+     * The number of times to spin for a non-virtual thread before\n+     * blocking when a node is apparently the first waiter in the\n+     * queue.  See above for explanation. Must be a power of two. The\n+     * value is empirically derived -- it works pretty well across a\n+     * variety of processors, numbers of CPUs, and OSes.\n+     *\/\n+    private static final int FRONT_SPINS   = 1 << 7;\n+\n@@ -506,1 +541,1 @@\n-    private transient volatile boolean needSweep;\n+    private transient volatile int sweepVotes;\n@@ -518,0 +553,5 @@\n+    \/** Atomic version of ++sweepVotes. *\/\n+    private int incSweepVotes() {\n+        return (int) SWEEPVOTES.getAndAdd(this, 1) + 1;\n+    }\n+\n@@ -635,1 +675,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -637,11 +676,19 @@\n-        final boolean isData = s.isData;\n-        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n-        final Thread w = Thread.currentThread();\n-        int stat = -1;                   \/\/ -1: may yield, +1: park, else 0\n-        Object item;\n-        while ((item = s.item) == e) {\n-            if (needSweep)               \/\/ help clean\n-                sweep();\n-            else if ((timed && nanos <= 0L) || w.isInterrupted()) {\n-                if (s.casItem(e, (e == null) ? s : null)) {\n-                    unsplice(pred, s);   \/\/ cancelled\n+        boolean isData = s.isData, parking = false;\n+        int spins = -1;                         \/\/ establish after initial checks\n+        long deadline = timed ? System.nanoTime() + nanos : 0L;\n+        Thread w = Thread.currentThread();\n+        for (;;) {\n+            Object item;\n+            if ((item = s.item) != e) {         \/\/ matched\n+                if (!isData)\n+                    ITEM.set(s, s);             \/\/ self-link to avoid garbage\n+                if (parking)\n+                    WAITER.set(s, null);\n+                @SuppressWarnings(\"unchecked\") E itemE = (E) item;\n+                return itemE;\n+            } else if (spins > 0) {\n+                --spins;\n+                Thread.onSpinWait();\n+            } else if (w.isInterrupted() || (timed && nanos <= 0L)) {\n+                if (s.casItem(e, s.isData ? null : s)) {\n+                    unsplice(pred, s);          \/\/ cancel and unlink\n@@ -649,0 +696,19 @@\n+                }                               \/\/ else retry\n+            } else if (spins < 0) {             \/\/ initialize spins\n+                if (w.isVirtual() || pred == null)\n+                    spins = 0;                  \/\/ don't spin\n+                else if (pred.isData != isData || pred.isMatched())\n+                    spins =  FRONT_SPINS;\n+                else if (pred.waiter == null)   \/\/ pred spinning\n+                    spins = FRONT_SPINS >>> 1;\n+                else                            \/\/ pred already parked\n+                    spins = 0;\n+            } else if (!parking) {              \/\/ request unpark then recheck\n+                parking = true;\n+                s.waiter = w;\n+            } else if (timed) {\n+                if ((nanos = deadline - System.nanoTime()) > 0L) {\n+                    if (nanos <= SPIN_FOR_TIMEOUT_THRESHOLD)\n+                        spins = FRONT_SPINS;\n+                    else\n+                        LockSupport.parkNanos(this, nanos);\n@@ -650,17 +716,1 @@\n-            }\n-            else if (stat <= 0) {\n-                if (pred != null && pred.next == s) {\n-                    if (stat < 0 &&\n-                        (pred.isData != isData || pred.isMatched())) {\n-                        stat = 0;        \/\/ yield once if first\n-                        Thread.yield();\n-                    }\n-                    else {\n-                        stat = 1;\n-                        s.waiter = w;    \/\/ enable unpark\n-                    }\n-                }                        \/\/ else signal in progress\n-            }\n-            else if ((item = s.item) != e)\n-                break;                   \/\/ recheck\n-            else if (!timed) {\n+            } else {\n@@ -673,5 +723,0 @@\n-            else {\n-                nanos = deadline - System.nanoTime();\n-                if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                    LockSupport.parkNanos(this, nanos);\n-            }\n@@ -679,5 +724,0 @@\n-        if (stat == 1)\n-            WAITER.set(s, null);\n-        if (!isData)\n-            ITEM.set(s, s);              \/\/ self-link to avoid garbage\n-        return (E) item;\n@@ -1106,1 +1146,2 @@\n-         * nor s are head or offlist, set needSweep;\n+         * nor s are head or offlist, add to sweepVotes, and if enough\n+         * votes have accumulated, sweep.\n@@ -1124,2 +1165,4 @@\n-                if (pred.next != pred && s.next != s)\n-                    needSweep = true;\n+                \/\/ sweep every SWEEP_THRESHOLD votes\n+                if (pred.next != pred && s.next != s \/\/ recheck if offlist\n+                    && (incSweepVotes() & (SWEEP_THRESHOLD - 1)) == 0)\n+                    sweep();\n@@ -1135,1 +1178,0 @@\n-        needSweep = false;\n@@ -1645,0 +1687,1 @@\n+    private static final VarHandle SWEEPVOTES;\n@@ -1655,0 +1698,2 @@\n+            SWEEPVOTES = l.findVarHandle(LinkedTransferQueue.class, \"sweepVotes\",\n+                                         int.class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":103,"deletions":58,"binary":false,"changes":161,"status":"modified"}]}