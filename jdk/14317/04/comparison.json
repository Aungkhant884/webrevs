{"files":[{"patch":"@@ -50,0 +50,1 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n@@ -110,1 +111,5 @@\n-     * dictated by callers.\n+     * dictated by callers. All enqueue\/dequeue operations can be\n+     * handled by a single method (here, \"xfer\") with parameters\n+     * indicating whether to act as some form of offer, put, poll,\n+     * take, or transfer (each possibly with timeout), as described\n+     * below.\n@@ -129,7 +134,4 @@\n-     * tail pointers. This has led to the development of\n-     * contention-reducing variants such as elimination arrays (see\n-     * Moir et al http:\/\/portal.acm.org\/citation.cfm?id=1074013) and\n-     * optimistic back pointers (see Ladan-Mozes & Shavit\n-     * http:\/\/people.csail.mit.edu\/edya\/publications\/OptimisticFIFOQueue-journal.pdf).\n-     * However, the nature of dual queues enables a simpler tactic for\n-     * improving M&S-style implementations when dual-ness is needed.\n+     * tail pointers. To address these, dual queues with slack differ\n+     * from plain M&S dual queues by virtue of only sometimes updating\n+     * head or tail pointers when matching, appending, or even\n+     * traversing nodes.\n@@ -138,13 +140,12 @@\n-     * status. While there are other possible variants, we implement\n-     * this here as: for a data-mode node, matching entails CASing an\n-     * \"item\" field from a non-null data value to null upon match, and\n-     * vice-versa for request nodes, CASing from null to a data\n-     * value. (Note that the linearization properties of this style of\n-     * queue are easy to verify -- elements are made available by\n-     * linking, and unavailable by matching.) Compared to plain M&S\n-     * queues, this property of dual queues requires one additional\n-     * successful atomic operation per enq\/deq pair. But it also\n-     * enables lower cost variants of queue maintenance mechanics. (A\n-     * variation of this idea applies even for non-dual queues that\n-     * support deletion of interior elements, such as\n-     * j.u.c.ConcurrentLinkedQueue.)\n+     * status. Matching entails CASing an \"item\" field from a non-null\n+     * data value to null upon match, and vice-versa for request\n+     * nodes, CASing from null to a data value.  (To reduce the need\n+     * for re-reads, we use the compareAndExchange forms of CAS for\n+     * pointer updates, that provide the current value to comtinue\n+     * with on failure.)  Note that the linearization properties of\n+     * this style of queue are easy to verify -- elements are made\n+     * available by linking, and unavailable by matching. Compared to\n+     * plain M&S queues, this property of dual queues requires one\n+     * additional successful atomic operation per enq\/deq pair. But it\n+     * also enables lower cost variants of queue maintenance\n+     * mechanics.\n@@ -155,10 +156,3 @@\n-     * suffix of zero or more unmatched nodes. (Note that we allow\n-     * both the prefix and suffix to be zero length, which in turn\n-     * means that we do not use a dummy header.)  If we were not\n-     * concerned with either time or space efficiency, we could\n-     * correctly perform enqueue and dequeue operations by traversing\n-     * from a pointer to the initial node; CASing the item of the\n-     * first unmatched node on match and CASing the next field of the\n-     * trailing node on appends.  While this would be a terrible idea\n-     * in itself, it does have the benefit of not requiring ANY atomic\n-     * updates on head\/tail fields.\n+     * suffix of zero or more unmatched nodes. Note that we allow both\n+     * the prefix and suffix to be zero length, which in turn means\n+     * that we do not require a dummy header.\n@@ -166,1 +160,1 @@\n-     * We introduce here an approach that lies between the extremes of\n+     * We use here an approach that lies between the extremes of\n@@ -181,34 +175,12 @@\n-     * similarly for \"tail\") is an empirical matter. We have found\n-     * that using very small constants in the range of 1-3 work best\n-     * over a range of platforms. Larger values introduce increasing\n-     * costs of cache misses and risks of long traversal chains, while\n-     * smaller values increase CAS contention and overhead.\n-     *\n-     * Dual queues with slack differ from plain M&S dual queues by\n-     * virtue of only sometimes updating head or tail pointers when\n-     * matching, appending, or even traversing nodes; in order to\n-     * maintain a targeted slack.  The idea of \"sometimes\" may be\n-     * operationalized in several ways. The simplest is to use a\n-     * per-operation counter incremented on each traversal step, and\n-     * to try (via CAS) to update the associated queue pointer\n-     * whenever the count exceeds a threshold. Another, that requires\n-     * more overhead, is to use random number generators to update\n-     * with a given probability per traversal step.\n-     *\n-     * In any strategy along these lines, because CASes updating\n-     * fields may fail, the actual slack may exceed targeted slack.\n-     * However, they may be retried at any time to maintain targets.\n-     * Even when using very small slack values, this approach works\n-     * well for dual queues because it allows all operations up to the\n-     * point of matching or appending an item (hence potentially\n-     * allowing progress by another thread) to be read-only, thus not\n-     * introducing any further contention.  As described below, we\n-     * implement this by performing slack maintenance retries only\n-     * after these points.\n-     *\n-     * As an accompaniment to such techniques, traversal overhead can\n-     * be further reduced without increasing contention of head\n-     * pointer updates: Threads may sometimes shortcut the \"next\" link\n-     * path from the current \"head\" node to be closer to the currently\n-     * known first unmatched node, and similarly for tail. Again, this\n-     * may be triggered with using thresholds or randomization.\n+     * similarly for \"tail\") is an empirical matter. Larger values\n+     * introduce increasing costs of cache misses and risks of long\n+     * traversal chains, while smaller values increase CAS contention\n+     * and overhead. Using the smallest non-zero value of one is both\n+     * simple and empirically a good choice in most applicatkions.\n+     * The slack value is hard-wired: a path greater than one is\n+     * usually implemented by checking equality of traversal pointers.\n+     * Because CASes updating fields may fail and threads attempting\n+     * to do so may stall, the actual slack may exceed targeted\n+     * slack. To reduce the consequent staleness impact, threads may\n+     * help update (method unslacken) when traversal lengths exceed an\n+     * imposed limit of MAX_SLACK.\n@@ -220,2 +192,2 @@\n-     * (http:\/\/portal.acm.org\/citation.cfm?doid=503272.503282), if a GC\n-     * delays noticing that any arbitrarily old node has become\n+     * (http:\/\/portal.acm.org\/citation.cfm?doid=503272.503282), if a\n+     * GC delays noticing that any arbitrarily old node has become\n@@ -224,94 +196,18 @@\n-     * this in our implementation, upon CASing to advance the head\n-     * pointer, we set the \"next\" link of the previous head to point\n-     * only to itself; thus limiting the length of chains of dead nodes.\n-     * (We also take similar care to wipe out possibly garbage\n-     * retaining values held in other Node fields.)  However, doing so\n-     * adds some further complexity to traversal: If any \"next\"\n-     * pointer links to itself, it indicates that the current thread\n-     * has lagged behind a head-update, and so the traversal must\n-     * continue from the \"head\".  Traversals trying to find the\n-     * current tail starting from \"tail\" may also encounter\n-     * self-links, in which case they also continue at \"head\".\n-     *\n-     * It is tempting in slack-based scheme to not even use CAS for\n-     * updates (similarly to Ladan-Mozes & Shavit). However, this\n-     * cannot be done for head updates under the above link-forgetting\n-     * mechanics because an update may leave head at a detached node.\n-     * And while direct writes are possible for tail updates, they\n-     * increase the risk of long retraversals, and hence long garbage\n-     * chains, which can be much more costly than is worthwhile\n-     * considering that the cost difference of performing a CAS vs\n-     * write is smaller when they are not triggered on each operation\n-     * (especially considering that writes and CASes equally require\n-     * additional GC bookkeeping (\"write barriers\") that are sometimes\n-     * more costly than the writes themselves because of contention).\n-     *\n-     * *** Overview of implementation ***\n-     *\n-     * We use a threshold-based approach to updates, with a slack\n-     * threshold of two -- that is, we update head\/tail when the\n-     * current pointer appears to be two or more steps away from the\n-     * first\/last node. The slack value is hard-wired: a path greater\n-     * than one is naturally implemented by checking equality of\n-     * traversal pointers except when the list has only one element,\n-     * in which case we keep slack threshold at one. Avoiding tracking\n-     * explicit counts across method calls slightly simplifies an\n-     * already-messy implementation. Using randomization would\n-     * probably work better if there were a low-quality dirt-cheap\n-     * per-thread one available, but even ThreadLocalRandom is too\n-     * heavy for these purposes.\n-     *\n-     * With such a small slack threshold value, it is not worthwhile\n-     * to augment this with path short-circuiting (i.e., unsplicing\n-     * interior nodes) except in the case of cancellation\/removal (see\n-     * below).\n-     *\n-     * All enqueue\/dequeue operations are handled by the single method\n-     * \"xfer\" with parameters indicating whether to act as some form\n-     * of offer, put, poll, take, or transfer (each possibly with\n-     * timeout). The relative complexity of using one monolithic\n-     * method outweighs the code bulk and maintenance problems of\n-     * using separate methods for each case.\n-     *\n-     * Operation consists of up to two phases. The first is implemented\n-     * in method xfer, the second in method awaitMatch.\n-     *\n-     * 1. Traverse until matching or appending (method xfer)\n-     *\n-     *    Conceptually, we simply traverse all nodes starting from head.\n-     *    If we encounter an unmatched node of opposite mode, we match\n-     *    it and return, also updating head (by at least 2 hops) to\n-     *    one past the matched node (or the node itself if it's the\n-     *    pinned trailing node).  Traversals also check for the\n-     *    possibility of falling off-list, in which case they restart.\n-     *\n-     *    If the trailing node of the list is reached, a match is not\n-     *    possible.  If this call was untimed poll or tryTransfer\n-     *    (argument \"how\" is NOW), return empty-handed immediately.\n-     *    Else a new node is CAS-appended.  On successful append, if\n-     *    this call was ASYNC (e.g. offer), an element was\n-     *    successfully added to the end of the queue and we return.\n-     *\n-     *    Of course, this naive traversal is O(n) when no match is\n-     *    possible.  We optimize the traversal by maintaining a tail\n-     *    pointer, which is expected to be \"near\" the end of the list.\n-     *    It is only safe to fast-forward to tail (in the presence of\n-     *    arbitrary concurrent changes) if it is pointing to a node of\n-     *    the same mode, even if it is dead (in this case no preceding\n-     *    node could still be matchable by this traversal).  If we\n-     *    need to restart due to falling off-list, we can again\n-     *    fast-forward to tail, but only if it has changed since the\n-     *    last traversal (else we might loop forever).  If tail cannot\n-     *    be used, traversal starts at head (but in this case we\n-     *    expect to be able to match near head).  As with head, we\n-     *    CAS-advance the tail pointer by at least two hops.\n-     *\n-     * 2. Await match or cancellation (method awaitMatch)\n-     *\n-     *    Wait for another thread to match node; instead cancelling if\n-     *    the current thread was interrupted or the wait timed out. To\n-     *    improve performance in common single-source \/ single-sink\n-     *    usages when there are more tasks that cores, an initial\n-     *    Thread.yield is tried when there is apparently only one\n-     *    waiter.  In other cases, waiters may help with some\n-     *    bookkeeping, then park\/unpark.\n+     * this in our implementation, upon advancing the head pointer, we\n+     * set the \"next\" link of the previous head to point only to\n+     * itself; thus limiting the length of chains of dead nodes.  (We\n+     * also take similar care to wipe out possibly garbage retaining\n+     * values held in other node fields.)  However, doing so adds some\n+     * further complexity to traversal: If any \"next\" pointer links to\n+     * itself, it indicates that the current thread has lagged behind\n+     * a head-update, and so the traversal must continue from the\n+     * \"head\".  Traversals trying to find the current tail starting\n+     * from \"tail\" may also encounter self-links, in which case they\n+     * also continue at \"head\".\n+     *\n+     * *** Blocking ***\n+     *\n+     * The TransferNode class is shared with class SynchronousQueue\n+     * (which adds Lifo-based matching methods). It houses method\n+     * await, which is used for all blocking control, as described\n+     * below in TransferNode internal documentation.\n@@ -338,4 +234,1 @@\n-     * Multiprocessor Programming\" chapter 9).  Although, in both\n-     * cases, we can rule out the need for further action if either s\n-     * or its predecessor are (or can be made to be) at, or fall off\n-     * from, the head of list.\n+     * Multiprocessor Programming\" chapter 9).\n@@ -353,8 +246,18 @@\n-     * won't help for case (1) anyway), we record the need to sweep the\n-     * next time any thread would otherwise block in awaitMatch. Also,\n-     * because traversal operations on the linked list of nodes are a\n-     * natural opportunity to sweep dead nodes, we generally do so,\n-     * including all the operations that might remove elements as they\n-     * traverse, such as removeIf and Iterator.remove.  This largely\n-     * eliminates long chains of dead interior nodes, except from\n-     * cancelled or timed out blocking operations.\n+     * won't help for case (1) anyway), we record a conservative\n+     * estimate of possible unsplice failures (in \"sweepVotes\").\n+     * We trigger a full sweep when the estimate exceeds a threshold\n+     * (\"SWEEP_THRESHOLD\") indicating the maximum number of estimated\n+     * removal failures to tolerate before sweeping through, unlinking\n+     * cancelled nodes that were not unlinked upon initial removal.\n+     * We perform sweeps by the thread hitting threshold (rather than\n+     * background threads or by spreading work to other threads)\n+     * because in the main contexts in which removal occurs, the\n+     * caller is timed-out or cancelled, which are not time-critical\n+     * enough to warrant the overhead that alternatives would impose\n+     * on other threads.\n+     *\n+     * Because the sweepVotes estimate is conservative, and because\n+     * nodes become unlinked \"naturally\" as they fall off the head of\n+     * the queue, and because we allow votes to accumulate even while\n+     * sweeps are in progress, there are typically significantly fewer\n+     * such nodes than estimated.\n@@ -366,0 +269,18 @@\n+     *\n+     * *** Revision notes ***\n+     *\n+     * This version differs from previous releases as follows:\n+     *\n+     * * Class TransferNode replaces Qnode, with fields and methods\n+     *   that apply to any match-based dual data structure, and now\n+     *   used in other j.u.c classes. in particular, SynchronousQueue.\n+     * * Blocking control (in class TransferQueue) accommodates\n+     *   VirtualThreads and (perhaps virtualized) uniprocessors.\n+     * * All fields of this class (LinkedTransferQueue) are\n+     *   default-initializable (to null), allowing further\n+     *   extension (in particular, SynchronousQueue.Transferer)\n+     * * Head and tail fields are lazily initialized rather than\n+     *   set to a dummy node, requiring accommodation in many\n+     *   places (as well as adjustments in WhiteBox tests).\n+     * * Reduced retries under heavy contention using MAX_SLACK and\n+     *   method unslacken.\n@@ -369,19 +290,2 @@\n-     * The number of nanoseconds for which it is faster to spin\n-     * rather than to use timed park. A rough estimate suffices.\n-     * Using a power of two minus one simplifies some comparisons.\n-     *\/\n-    static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1023L;\n-\n-    \/**\n-     * The maximum number of estimated removal failures (sweepVotes)\n-     * to tolerate before sweeping through the queue unlinking\n-     * cancelled nodes that were not unlinked upon initial\n-     * removal. See above for explanation. The value must be at least\n-     * two to avoid useless sweeps when removing trailing nodes.\n-     *\/\n-    static final int SWEEP_THRESHOLD = 32;\n-\n-    \/**\n-     * Queue nodes. Uses Object, not E, for items to allow forgetting\n-     * them after use.  Writes that are intrinsically ordered wrt\n-     * other accesses or CASes use simple relaxed forms.\n+     * Queue nodes. Uses type Object, not E, for items to allow\n+     * cancellation and forgetting after use.\n@@ -389,2 +293,1 @@\n-    static final class Node implements ForkJoinPool.ManagedBlocker {\n-        final boolean isData;   \/\/ false if this is a request node\n+    static final class TransferNode implements ForkJoinPool.ManagedBlocker {\n@@ -392,2 +295,3 @@\n-        volatile Node next;\n-        volatile Thread waiter; \/\/ null when not waiting for a match\n+        volatile TransferNode next;\n+        volatile Thread waiter; \/\/ null when not parked waiting for a match\n+        final boolean isData;   \/\/ false if this is a request node\n@@ -395,8 +299,3 @@\n-        \/**\n-         * Constructs a data node holding item if item is non-null,\n-         * else a request node.  Uses relaxed write because item can\n-         * only be seen after piggy-backing publication via CAS.\n-         *\/\n-        Node(Object item) {\n-            ITEM.set(this, item);\n-            isData = (item != null);\n+        TransferNode(Object item, boolean isData) {\n+            ITEM.set(this, item); \/\/ relaxed write before publication\n+            this.isData = isData;\n@@ -405,3 +304,3 @@\n-        \/** Constructs a (matched data) dummy node. *\/\n-        Node() {\n-            isData = true;\n+        \/\/ Atomic updates\n+        final Object cmpExItem(Object cmp, Object val) { \/\/ try to match\n+            return ITEM.compareAndExchange(this, cmp, val);\n@@ -409,4 +308,2 @@\n-\n-        final boolean casNext(Node cmp, Node val) {\n-            \/\/ assert val != null;\n-            return NEXT.compareAndSet(this, cmp, val);\n+        final TransferNode cmpExNext(TransferNode cmp, TransferNode val) {\n+            return (TransferNode)NEXT.compareAndExchange(this, cmp, val);\n@@ -415,5 +312,5 @@\n-        final boolean casItem(Object cmp, Object val) {\n-            \/\/ assert isData == (cmp != null);\n-            \/\/ assert isData == (val == null);\n-            \/\/ assert !(cmp instanceof Node);\n-            return ITEM.compareAndSet(this, cmp, val);\n+        \/**\n+         * Returns true if this node has not been matched\n+         *\/\n+        final boolean isLive() {\n+            return isData == (item != null);\n@@ -423,2 +320,3 @@\n-         * Links node to itself to avoid garbage retention.  Called\n-         * only after CASing head field, so uses relaxed write.\n+         * Tries to cancel by matching with self if initially null else null\n+         * @param e the initial item value\n+         * @return e if successful, else current item\n@@ -426,3 +324,2 @@\n-        final void selfLink() {\n-            \/\/ assert isMatched();\n-            NEXT.setRelease(this, this);\n+        final Object tryCancel(Object e) {\n+            return cmpExItem(e, (e == null) ? this : null);\n@@ -431,4 +328,13 @@\n-        final void appendRelaxed(Node next) {\n-            \/\/ assert next != null;\n-            \/\/ assert this.next == null;\n-            NEXT.setOpaque(this, next);\n+        \/\/ Relaxed writes when volatile is unnecessarily strong\n+        final void clearWaiter()   { WAITER.setOpaque(this, null); }\n+        final void forgetItem()    { ITEM.set(this, this); }\n+        final void forgetNext()    { NEXT.set(this, this); }\n+        final void setNext(TransferNode n) { NEXT.set(this, n);  }\n+\n+        \/\/ ManagedBlocker support\n+        public final boolean isReleasable() {\n+            return (!isLive() || Thread.currentThread().isInterrupted());\n+        }\n+        public final boolean block() {\n+            while (!isReleasable()) LockSupport.park();\n+            return true;\n@@ -438,2 +344,55 @@\n-         * Returns true if this node has been matched, including the\n-         * case of artificial matches due to cancellation.\n+         * Possibly blocks until matched or caller gives up.\n+         *\n+         * Control of blocking (and thread scheduling in general) for\n+         * possibly-synchronous queues (and channels etc constructed\n+         * from them) must straddle two extremes: If there are too few\n+         * underlying cores for a fulfilling party to continue, then\n+         * the caller must park to cause a context switch. On the\n+         * other hand, if the queue is busy with approximately the\n+         * same number of independent producers and consumers, then\n+         * that context switch causes a huge slowdown (often more than\n+         * 20X). Many cases are somewhere in-between, in which case\n+         * threads should try spinning and then give up and block. We\n+         * deal with this as follows:\n+         *\n+         * 1. Callers to method await indicate eligibility for\n+         * spinning when the node is either the only waiting node, or\n+         * the next eligible node is still spinning.  Otherwise, the\n+         * caller normally blocks (almost) immediately.\n+         *\n+         * 2. Even if eligible to spin, a caller blocks anyway in two\n+         * cases where it is normally best: If the thread is Virtual,\n+         * or the system is a uniprocessor. Because uniprocessor\n+         * status can vary over time (due to virtualization at other\n+         * system levels), we update it whenever an otherwise-eligible\n+         * spin elapses. (Updates to static field isUniprocessor are\n+         * allowed to be racy -- if status is dynamically varying,\n+         * tracking is at best approximate.)\n+         *\n+         * 3. When enabled, spins should be long enough to cover\n+         * bookeeping overhead of almost-immediate fulfillments, but\n+         * much less than the expected time of a (non-virtual)\n+         * park\/unpark context switch.  The optimal value is\n+         * unknowable, in part because the relative costs of\n+         * Thread.onSpinWait versus park\/unpark vary across platforms.\n+         * The current value is an empirical compromise across tested\n+         * platforms.\n+         *\n+         * 4. When using timed waits, callers spin instead of invoking\n+         * timed park if the remaining time is less than the likely\n+         * cost of park\/unpark. This also avoids re-parks when timed\n+         * park returns just barely too soon.\n+         *\n+         * 5. To make the above work, callers must precheck that\n+         * timeouts are not already elapsed, and that interruptible\n+         * operations were not already interrupted on call to the\n+         * corresponding queue operation.  Cancellation on timeout or\n+         * interrupt otherwise proceeds by trying to fulfill with an\n+         * impossible value (which is one reason that we use Object\n+         * types here rather than tyoed results).\n+         *\n+         * @param e the comparison value for checking match\n+         * @param nanos timeout, or Long.MAX_VALUE if untimed\n+         * @param blocker the LockSupport.setCurrentBlocker argument\n+         * @param spin true if eligible for spinning if enabled\n+         * @return matched item, or e if unmatched on interrupt or timeout\n@@ -441,9 +400,39 @@\n-        final boolean isMatched() {\n-            return isData == (item == null);\n-        }\n-\n-        \/** Tries to CAS-match this node; if successful, wakes waiter. *\/\n-        final boolean tryMatch(Object cmp, Object val) {\n-            if (casItem(cmp, val)) {\n-                LockSupport.unpark(waiter);\n-                return true;\n+        final Object await(Object e, long nanos, Object blocker, boolean spin) {\n+            boolean timed = (nanos != Long.MAX_VALUE);\n+            long deadline = (timed) ? System.nanoTime() + nanos : 0L;\n+            Thread w = Thread.currentThread();\n+            boolean canSpin = (!w.isVirtual() && spin), u;\n+            int spins = (canSpin && !isUniprocessor) ? SPINS : 0;\n+            Object match;\n+            while ((match = item) == e && --spins >= 0)\n+                Thread.onSpinWait();\n+            if (match == e) {\n+                if (canSpin && isUniprocessor !=\n+                    (u = (Runtime.getRuntime().availableProcessors() <= 1)))\n+                    isUniprocessor = u;         \/\/ reset for next time\n+                LockSupport.setCurrentBlocker(blocker);\n+                waiter = w;\n+                while ((match = item) == e) {\n+                    long ns;\n+                    if (w.isInterrupted()) {\n+                        match = tryCancel(e);\n+                        break;\n+                    }\n+                    if (timed) {\n+                        if ((ns = deadline - System.nanoTime()) <= 0L) {\n+                            match = tryCancel(e);\n+                            break;\n+                        }\n+                        if (ns < SPIN_FOR_TIMEOUT_THRESHOLD)\n+                            Thread.onSpinWait();\n+                        else\n+                            LockSupport.parkNanos(ns);\n+                    } else if (w instanceof ForkJoinWorkerThread) {\n+                        try {\n+                            ForkJoinPool.managedBlock(this);\n+                        } catch (InterruptedException cannotHappen) { }\n+                    } else\n+                        LockSupport.park(this);\n+                }\n+                clearWaiter();\n+                LockSupport.setCurrentBlocker(null);\n@@ -451,1 +440,1 @@\n-            return false;\n+            return match;\n@@ -455,3 +444,1 @@\n-         * Returns true if a node with the given mode cannot be\n-         * appended to this node because this node is unmatched and\n-         * has opposite data mode.\n+         * The number of times to spin when eligible.\n@@ -459,4 +446,1 @@\n-        final boolean cannotPrecede(boolean haveData) {\n-            boolean d = isData;\n-            return d != haveData && d != (item == null);\n-        }\n+        private static final int SPINS = 1 << 7;\n@@ -464,4 +448,5 @@\n-        public final boolean isReleasable() {\n-            return (isData == (item == null)) ||\n-                Thread.currentThread().isInterrupted();\n-        }\n+        \/**\n+         * The number of nanoseconds for which it is faster to spin\n+         * rather than to use timed park. A rough estimate suffices.\n+         *\/\n+        private static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1L << 10;\n@@ -469,3 +454,22 @@\n-        public final boolean block() {\n-            while (!isReleasable()) LockSupport.park();\n-            return true;\n+        \/**\n+         * True if system is a uniprocessor. Initially assumed false.\n+         *\/\n+        private static boolean isUniprocessor;\n+\n+        \/\/ VarHandle mechanics\n+        static final VarHandle ITEM;\n+        static final VarHandle NEXT;\n+        static final VarHandle WAITER;\n+        static {\n+            try {\n+                Class<?> tn = TransferNode.class;\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                ITEM = l.findVarHandle(tn, \"item\", Object.class);\n+                NEXT = l.findVarHandle(tn, \"next\", tn);\n+                WAITER = l.findVarHandle(tn, \"waiter\", Thread.class);\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+            \/\/ Reduce the risk of rare disastrous classloading in first call to\n+            \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n+            Class<?> ensureLoaded = LockSupport.class;\n@@ -473,2 +477,0 @@\n-\n-        private static final long serialVersionUID = -3375979862319811754L;\n@@ -478,2 +480,17 @@\n-     * A node from which the first live (non-matched) node (if any)\n-     * can be reached in O(1) time.\n+     * The maximum number of dead nodes traversed before unslackening\n+     * to reduce retries due to stalls in updating head and tail.  Must\n+     * be at least 4.\n+     *\/\n+    private static final int MAX_SLACK = 1 << 7;\n+\n+    \/**\n+     * The maximum number of estimated removal failures (sweepVotes)\n+     * to tolerate before sweeping through the queue unlinking\n+     * cancelled nodes that were initially pinned.  Must be a power of\n+     * two, at least 2 and at most MAX_SLACK.\n+     *\/\n+    private static final int SWEEP_THRESHOLD = 1 << 5;\n+\n+    \/**\n+     * Unless empty (in which case possibly null), a node from which\n+     * all live nodes are reachable.\n@@ -481,3 +498,1 @@\n-     * - all live nodes are reachable from head via .next\n-     * - head != null\n-     * - (tmp = head).next != tmp || tmp != head\n+     * - head is never self-linked\n@@ -486,2 +501,0 @@\n-     * - it is permitted for tail to lag behind head, that is, for tail\n-     *   to not be reachable from head!\n@@ -489,1 +502,1 @@\n-    transient volatile Node head;\n+    transient volatile TransferNode head;\n@@ -492,5 +505,3 @@\n-     * A node from which the last node on list (that is, the unique\n-     * node with node.next == null) can be reached in O(1) time.\n-     * Invariants:\n-     * - the last node is always reachable from tail via .next\n-     * - tail != null\n+     * Unless empty, a node from which the last node on list (that is,\n+     * the unique node with node.next == null), if one exists, can be\n+     * reached.\n@@ -499,2 +510,2 @@\n-     * - it is permitted for tail to lag behind head, that is, for tail\n-     *   to not be reachable from head!\n+     * - tail may be the same as head\n+     * - tail may lag behind head, so need not be reachable from head\n@@ -502,0 +513,4 @@\n+     *\n+     * This field is used by subclass SynchronousQueue.Transferer to\n+     * record the top of a Lifo stack, with head always null, but\n+     * otherwise maintaining the same properties.\n@@ -503,1 +518,1 @@\n-    private transient volatile Node tail;\n+    transient volatile TransferNode tail;\n@@ -506,1 +521,1 @@\n-    private transient volatile boolean needSweep;\n+    private transient volatile int sweepVotes;\n@@ -508,4 +523,4 @@\n-    private boolean casTail(Node cmp, Node val) {\n-        \/\/ assert cmp != null;\n-        \/\/ assert val != null;\n-        return TAIL.compareAndSet(this, cmp, val);\n+    \/** increment sweepVotes and return true on trigger *\/\n+    private boolean sweepNow() {\n+        return (((int) SWEEPVOTES.getAndAdd(this, 1) + 1) &\n+                (SWEEP_THRESHOLD - 1)) == 0;\n@@ -514,2 +529,7 @@\n-    private boolean casHead(Node cmp, Node val) {\n-        return HEAD.compareAndSet(this, cmp, val);\n+    \/\/ Atomic updates\n+\n+    final TransferNode cmpExTail(TransferNode cmp, TransferNode val) {\n+        return (TransferNode)TAIL.compareAndExchange(this, cmp, val);\n+    }\n+    final TransferNode cmpExHead(TransferNode cmp, TransferNode val) {\n+        return (TransferNode)HEAD.compareAndExchange(this, cmp, val);\n@@ -519,2 +539,2 @@\n-     * Tries to CAS pred.next (or head, if pred is null) from c to p.\n-     * Caller must ensure that we're not unlinking the trailing node.\n+     * Tries to update to new head, forgetting links from previous\n+     * head (if it exists) on success.\n@@ -522,11 +542,5 @@\n-    private boolean tryCasSuccessor(Node pred, Node c, Node p) {\n-        \/\/ assert p != null;\n-        \/\/ assert c.isData != (c.item != null);\n-        \/\/ assert c != p;\n-        if (pred != null)\n-            return pred.casNext(c, p);\n-        if (casHead(c, p)) {\n-            c.selfLink();\n-            return true;\n-        }\n-        return false;\n+    final TransferNode tryAdvanceHead(TransferNode h, TransferNode p) {\n+        TransferNode u;\n+        if ((u = cmpExHead(h, p)) == h && h != null)\n+            h.forgetNext();\n+        return u;\n@@ -536,6 +550,16 @@\n-     * Collapses dead (matched) nodes between pred and q.\n-     * @param pred the last known live node, or null if none\n-     * @param c the first dead node\n-     * @param p the last dead node\n-     * @param q p.next: the next live node, or null if at end\n-     * @return pred if pred still alive and CAS succeeded; else p\n+     * Implements all queuing methods. Loops, trying:\n+     *\n+     * * If head not initialized, try to add new node and exit (unless immediate)\n+     * * If tail initialized and has same mode, and this is not a retry,\n+     *   start traversing at tail (for an append), else start at head\n+     *   (for a likely match, but if no live nodes, an append)\n+     * * Traverse over dead or wrong-mode nodes until finding a spot\n+     *   to match\/append, or falling off the list because of self-links,\n+     *   taking or too many steps, in which case help unslacken and restart.\n+     * * On success, update head or tail if slacked, and return or wait,\n+     *   depending on nanos argument\n+     *\n+     * @param e the item or null for take\n+     * @param nanos timeout, or negative for async, 0 for immediate,\n+     *        Long.MAX_VALUE for untimed\n+     * @return an item if matched, else e\n@@ -543,9 +567,49 @@\n-    private Node skipDeadNodes(Node pred, Node c, Node p, Node q) {\n-        \/\/ assert pred != c;\n-        \/\/ assert p != q;\n-        \/\/ assert c.isMatched();\n-        \/\/ assert p.isMatched();\n-        if (q == null) {\n-            \/\/ Never unlink trailing node.\n-            if (c == p) return pred;\n-            q = p;\n+    final Object xfer(Object e, long nanos) {\n+        boolean haveData = (e != null);\n+        TransferNode p;                     \/\/ current traversal node\n+        TransferNode s = null;              \/\/ the enqueued npde, if needed\n+        TransferNode prevTail = null;       \/\/ to avoid unbounded tail retries\n+        restart: for (;;) {\n+            TransferNode h, t;\n+            if ((p = h = head) == null) {   \/\/ lazily initialize\n+                if (nanos == 0L)            \/\/ unless immediate\n+                    return e;\n+                if (s == null)\n+                    s = new TransferNode(e, haveData);\n+                if (cmpExHead(null, s) != null)\n+                    continue;               \/\/ lost initialization race\n+                if (nanos < 0L)\n+                    return e;               \/\/ async mode\n+                break restart;              \/\/ wait below\n+            }\n+            if ((t = tail) != null && haveData == t.isData && t != prevTail)\n+                p = prevTail = t;           \/\/ start at tail\n+            for (int slack = 0; slack < MAX_SLACK; ++slack) { \/\/ bound steps\n+                TransferNode q, n; Object item;\n+                if (haveData != p.isData && \/\/ try to match waiting node\n+                    haveData != ((item = p.item) != null) &&\n+                    p.cmpExItem(item, e) == item) {\n+                    if (p != h)\n+                        tryAdvanceHead(h, (n = p.next) == null ? p : n);\n+                    LockSupport.unpark(p.waiter);\n+                    return item;\n+                }\n+                if ((q = p.next) == null) { \/\/ no matches\n+                    if (nanos == 0L)\n+                        return e;\n+                    if (s == null) {        \/\/ try to append node\n+                        s = new TransferNode(e, haveData);\n+                        q = p.next;         \/\/ recheck after allocation\n+                    }\n+                    if (q == null && (q = p.cmpExNext(null, s)) == null) {\n+                        if (p != t)\n+                            cmpExTail(tail, s);\n+                        if (nanos < 0L)\n+                            return e;\n+                        break restart;\n+                    }\n+                }\n+                if (p == (p = q))            \/\/ stale; restart\n+                    break;\n+            }\n+            unslacken();                     \/\/ collapse before retrying\n@@ -553,3 +617,7 @@\n-        return (tryCasSuccessor(pred, c, q)\n-                && (pred == null || !pred.isMatched()))\n-            ? pred : p;\n+        Object match;                        \/\/ await match\n+        boolean maySpin = (p == null || p.waiter == null); \/\/ at or near head\n+        if ((match = s.await(e, nanos, this, maySpin)) == e)\n+            unsplice(p, s);                  \/\/ cancelled\n+        else if (match != null)\n+            s.forgetItem();\n+        return match;\n@@ -559,2 +627,3 @@\n-     * Collapses dead (matched) nodes from h (which was once head) to p.\n-     * Caller ensures all nodes from h up to and including p are dead.\n+     * Incrementally advances head and tail if possible. Called before\n+     * retraversals and during unsplices to reduce retries due to\n+     * stalled head and tail updates.\n@@ -562,9 +631,13 @@\n-    private void skipDeadNodesNearHead(Node h, Node p) {\n-        \/\/ assert h != null;\n-        \/\/ assert h != p;\n-        \/\/ assert p.isMatched();\n-        for (;;) {\n-            final Node q;\n-            if ((q = p.next) == null) break;\n-            else if (!q.isMatched()) { p = q; break; }\n-            else if (p == (p = q)) return;\n+    private void unslacken() {\n+        TransferNode h, t, s, n, u;\n+        if ((h = head) != null && !h.isLive() &&\n+            (s = h.next) != null && s != h) { \/\/ try to advance by 2\n+            if (!s.isLive() && (n = s.next) != null && n != s &&\n+                !(s = n).isLive() && (n = s.next) != null && n != s)\n+                s = n;\n+            tryAdvanceHead(h, s);\n+        }\n+        if ((t = tail) != null && (s = t.next) != null && s != t) {\n+            if (!s.isLive() && (n = s.next) != null)\n+                s = (s == (u = t.cmpExNext(s, n))) ? n : u;\n+            cmpExTail(t, s); \/\/ advance by 2 if can unlink dead node\n@@ -572,2 +645,0 @@\n-        if (casHead(h, p))\n-            h.selfLink();\n@@ -576,1 +647,34 @@\n-    \/* Possible values for \"how\" argument in xfer method. *\/\n+    \/* --------------  Interior removals -------------- *\/\n+    \/**\n+     * Unsplices (now or later) the given deleted\/cancelled node with\n+     * the given predecessor.\n+     *\n+     * @param pred if nonnull, a node that was at one time known to be the\n+     * predecessor of s\n+     * @param s the node to be unspliced\n+     *\/\n+    final void unsplice(TransferNode pred, TransferNode s) {\n+        TransferNode n;\n+        if (pred != null && s != null && pred.next == s && (n = s.next) != s &&\n+            (n == null || pred.cmpExNext(s, n) != s) &&\n+            sweepNow())    \/\/ occasionally sweep initially pinned nodes\n+            sweep();\n+        unslacken();       \/\/ help clean endpoints\n+    }\n+\n+    \/**\n+     * Unlinks dead nodes encountered in a traversal from head.\n+     *\/\n+    private void sweep() {\n+        for (TransferNode p = head, s; p != null && (s = p.next) != null; ) {\n+            TransferNode n, u, h;\n+            if (s.isLive())\n+                p = s;\n+            else if ((n = s.next) == null)\n+                break;\n+            else if (s == n)               \/\/ stale\n+                p = head;\n+            else                           \/\/ unlink\n+                p = ((u = p.cmpExNext(s, n)) == s) ? n : u;\n+        }\n+    }\n@@ -578,4 +682,11 @@\n-    private static final int NOW   = 0; \/\/ for untimed poll, tryTransfer\n-    private static final int ASYNC = 1; \/\/ for offer, put, add\n-    private static final int SYNC  = 2; \/\/ for transfer, take\n-    private static final int TIMED = 3; \/\/ for timed poll, tryTransfer\n+    \/**\n+     * Tries to CAS pred.next (or head, if pred is null) from c to p.\n+     * Caller must ensure that we're not unlinking the trailing node.\n+     *\/\n+    final boolean tryCasSuccessor(TransferNode pred, TransferNode c,\n+                                  TransferNode p) {\n+        \/\/ assert p != null && !c.isLive() && c != p;\n+        return ((pred != null ?\n+                 pred.cmpExNext(c, p) :\n+                 tryAdvanceHead(c, p))) == c;\n+    }\n@@ -584,8 +695,6 @@\n-     * Implements all queuing methods. See above for explanation.\n-     *\n-     * @param e the item or null for take\n-     * @param haveData true if this is a put, else a take\n-     * @param how NOW, ASYNC, SYNC, or TIMED\n-     * @param nanos timeout in nanosecs, used only if mode is TIMED\n-     * @return an item if matched, else e\n-     * @throws NullPointerException if haveData mode but e is null\n+     * Collapses dead (matched) nodes between pred and q.\n+     * @param pred the last known live node, or null if none\n+     * @param c the first dead node\n+     * @param p the last dead node\n+     * @param q p.next: the next live node, or null if at end\n+     * @return pred if pred still alive and CAS succeeded; else p\n@@ -593,27 +702,7 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private E xfer(E e, boolean haveData, int how, long nanos) {\n-        if (haveData && (e == null))\n-            throw new NullPointerException();\n-\n-        restart: for (Node s = null, t = null, h = null;;) {\n-            for (Node p = (t != (t = tail) && t.isData == haveData) ? t\n-                     : (h = head);; ) {\n-                final Node q; final Object item;\n-                if (p.isData != haveData\n-                    && haveData == ((item = p.item) == null)) {\n-                    if (h == null) h = head;\n-                    if (p.tryMatch(item, e)) {\n-                        if (h != p) skipDeadNodesNearHead(h, p);\n-                        return (E) item;\n-                    }\n-                }\n-                if ((q = p.next) == null) {\n-                    if (how == NOW) return e;\n-                    if (s == null) s = new Node(e);\n-                    if (!p.casNext(null, s)) continue;\n-                    if (p != t) casTail(t, s);\n-                    if (how == ASYNC) return e;\n-                    return awaitMatch(s, p, e, (how == TIMED), nanos);\n-                }\n-                if (p == (p = q)) continue restart;\n-            }\n+    final TransferNode skipDeadNodes(TransferNode pred, TransferNode c,\n+                                     TransferNode p, TransferNode q) {\n+        \/\/ assert pred != c && p != q; && !c.isLive() && !p.isLive();\n+        if (q == null) { \/\/ Never unlink trailing node.\n+            if (c == p)\n+                return pred;\n+            q = p;\n@@ -621,0 +710,2 @@\n+        return (tryCasSuccessor(pred, c, q) && (pred == null || pred.isLive()))\n+            ? pred : p;\n@@ -624,10 +715,2 @@\n-     * Possibly blocks until node s is matched or caller gives up.\n-     *\n-     * @param s the waiting node\n-     * @param pred the predecessor of s, or null if unknown (the null\n-     * case does not occur in any current calls but may in possible\n-     * future extensions)\n-     * @param e the comparison value for checking match\n-     * @param timed if true, wait only until timeout elapses\n-     * @param nanos timeout in nanosecs, used only if timed is true\n-     * @return matched item, or e if unmatched on interrupt or timeout\n+     * Tries to match the given object only if p is a data\n+     * node. Signals waiter on success.\n@@ -635,43 +718,5 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {\n-        final boolean isData = s.isData;\n-        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n-        final Thread w = Thread.currentThread();\n-        int stat = -1;                   \/\/ -1: may yield, +1: park, else 0\n-        Object item;\n-        while ((item = s.item) == e) {\n-            if (needSweep)               \/\/ help clean\n-                sweep();\n-            else if ((timed && nanos <= 0L) || w.isInterrupted()) {\n-                if (s.casItem(e, (e == null) ? s : null)) {\n-                    unsplice(pred, s);   \/\/ cancelled\n-                    return e;\n-                }\n-            }\n-            else if (stat <= 0) {\n-                if (pred != null && pred.next == s) {\n-                    if (stat < 0 &&\n-                        (pred.isData != isData || pred.isMatched())) {\n-                        stat = 0;        \/\/ yield once if first\n-                        Thread.yield();\n-                    }\n-                    else {\n-                        stat = 1;\n-                        s.waiter = w;    \/\/ enable unpark\n-                    }\n-                }                        \/\/ else signal in progress\n-            }\n-            else if ((item = s.item) != e)\n-                break;                   \/\/ recheck\n-            else if (!timed) {\n-                LockSupport.setCurrentBlocker(this);\n-                try {\n-                    ForkJoinPool.managedBlock(s);\n-                } catch (InterruptedException cannotHappen) { }\n-                LockSupport.setCurrentBlocker(null);\n-            }\n-            else {\n-                nanos = deadline - System.nanoTime();\n-                if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                    LockSupport.parkNanos(this, nanos);\n-            }\n+    final boolean tryMatchData(TransferNode p, Object x) {\n+        if (p != null && p.isData &&\n+            x != null && p.cmpExItem(x, null) == x) {\n+            LockSupport.unpark(p.waiter);\n+            return true;\n@@ -679,5 +724,1 @@\n-        if (stat == 1)\n-            WAITER.set(s, null);\n-        if (!isData)\n-            ITEM.set(s, s);              \/\/ self-link to avoid garbage\n-        return (E) item;\n+        return false;\n@@ -693,22 +734,16 @@\n-    final Node firstDataNode() {\n-        Node first = null;\n-        restartFromHead: for (;;) {\n-            Node h = head, p = h;\n-            while (p != null) {\n-                if (p.item != null) {\n-                    if (p.isData) {\n-                        first = p;\n-                        break;\n-                    }\n-                }\n-                else if (!p.isData)\n-                    break;\n-                final Node q;\n-                if ((q = p.next) == null)\n-                    break;\n-                if (p == (p = q))\n-                    continue restartFromHead;\n-            }\n-            if (p != h && casHead(h, p))\n-                h.selfLink();\n-            return first;\n+    final TransferNode firstDataNode() {\n+        for (TransferNode h = head, p = h, q, u; p != null;) {\n+            boolean isData = p.isData;\n+            Object item = p.item;\n+            if (isData && item != null)       \/\/ is live data\n+                return p;\n+            else if (!isData && item == null) \/\/ is live request\n+                break;\n+            else if ((q = p.next) == null)    \/\/ end of list\n+                break;\n+            else if (p == q)                  \/\/ self-link; restart\n+                p = h = head;\n+            else if (p != h)                  \/\/ collapse\n+                p = h = ((u = tryAdvanceHead(h, q)) == h) ? q : u;\n+            else                              \/\/ traverse past header\n+                p = q;\n@@ -716,0 +751,1 @@\n+        return null;\n@@ -722,1 +758,1 @@\n-    private int countOfMode(boolean data) {\n+    final int countOfMode(boolean data) {\n@@ -725,2 +761,2 @@\n-            for (Node p = head; p != null;) {\n-                if (!p.isMatched()) {\n+            for (TransferNode p = head; p != null;) {\n+                if (p.isLive()) {\n@@ -744,1 +780,1 @@\n-            for (Node p = head; p != null;) {\n+            for (TransferNode p = head; p != null;) {\n@@ -773,1 +809,1 @@\n-            for (Node p = head; p != null;) {\n+            for (TransferNode p = head; p != null;) {\n@@ -866,1 +902,1 @@\n-        private Node nextNode;   \/\/ next node to return item for\n+        private TransferNode nextNode;   \/\/ next node to return item for\n@@ -868,2 +904,2 @@\n-        private Node lastRet;    \/\/ last returned node, to support remove\n-        private Node ancestor;   \/\/ Helps unlink lastRet on remove()\n+        private TransferNode lastRet;    \/\/ last returned node, to support remove\n+        private TransferNode ancestor;   \/\/ Helps unlink lastRet on remove()\n@@ -875,2 +911,2 @@\n-        private void advance(Node pred) {\n-            for (Node p = (pred == null) ? head : pred.next, c = p;\n+        private void advance(TransferNode pred) {\n+            for (TransferNode p = (pred == null) ? head : pred.next, c = p;\n@@ -910,1 +946,1 @@\n-            final Node p;\n+            final TransferNode p;\n@@ -919,2 +955,2 @@\n-            Node q = null;\n-            for (Node p; (p = nextNode) != null; advance(q = p))\n+            TransferNode q = null;\n+            for (TransferNode p; (p = nextNode) != null; advance(q = p))\n@@ -927,1 +963,1 @@\n-            final Node lastRet = this.lastRet;\n+            final TransferNode lastRet = this.lastRet;\n@@ -934,2 +970,2 @@\n-            Node pred = ancestor;\n-            for (Node p = (pred == null) ? head : pred.next, c = p, q;\n+            TransferNode pred = ancestor;\n+            for (TransferNode p = (pred == null) ? head : pred.next, c = p, q;\n@@ -938,3 +974,1 @@\n-                    final Object item;\n-                    if ((item = p.item) != null)\n-                        p.tryMatch(item, null);\n+                    tryMatchData(p, p.item);\n@@ -965,1 +999,1 @@\n-            \/\/ assert lastRet.isMatched();\n+            \/\/ assert !lastRet.isLive();\n@@ -972,1 +1006,1 @@\n-        Node current;       \/\/ current node; null until initialized\n+        TransferNode current;       \/\/ current node; null until initialized\n@@ -978,1 +1012,1 @@\n-            Node p, q;\n+            TransferNode p, q;\n@@ -1007,1 +1041,1 @@\n-            final Node p;\n+            final TransferNode p;\n@@ -1018,1 +1052,1 @@\n-            Node p;\n+            TransferNode p;\n@@ -1022,1 +1056,0 @@\n-                    final Object item = p.item;\n@@ -1024,0 +1057,1 @@\n+                    final Object item = p.item;\n@@ -1044,1 +1078,1 @@\n-        private void setCurrent(Node p) {\n+        private void setCurrent(TransferNode p) {\n@@ -1049,2 +1083,2 @@\n-        private Node current() {\n-            Node p;\n+        private TransferNode current() {\n+            TransferNode p;\n@@ -1085,65 +1119,0 @@\n-    \/* -------------- Removal methods -------------- *\/\n-\n-    \/**\n-     * Unsplices (now or later) the given deleted\/cancelled node with\n-     * the given predecessor.\n-     *\n-     * @param pred a node that was at one time known to be the\n-     * predecessor of s\n-     * @param s the node to be unspliced\n-     *\/\n-    final void unsplice(Node pred, Node s) {\n-        \/\/ assert pred != null;\n-        \/\/ assert pred != s;\n-        \/\/ assert s != null;\n-        \/\/ assert s.isMatched();\n-        \/\/ assert (SWEEP_THRESHOLD & (SWEEP_THRESHOLD - 1)) == 0;\n-        s.waiter = null; \/\/ disable signals\n-        \/*\n-         * See above for rationale. Briefly: if pred still points to\n-         * s, try to unlink s.  If s cannot be unlinked, because it is\n-         * trailing node or pred might be unlinked, and neither pred\n-         * nor s are head or offlist, set needSweep;\n-         *\/\n-        if (pred != null && pred.next == s) {\n-            Node n = s.next;\n-            if (n == null ||\n-                (n != s && pred.casNext(s, n) && pred.isMatched())) {\n-                for (;;) {               \/\/ check if at, or could be, head\n-                    Node h = head;\n-                    if (h == pred || h == s)\n-                        return;          \/\/ at head or list empty\n-                    if (!h.isMatched())\n-                        break;\n-                    Node hn = h.next;\n-                    if (hn == null)\n-                        return;          \/\/ now empty\n-                    if (hn != h && casHead(h, hn))\n-                        h.selfLink();  \/\/ advance head\n-                }\n-                if (pred.next != pred && s.next != s)\n-                    needSweep = true;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Unlinks matched (typically cancelled) nodes encountered in a\n-     * traversal from head.\n-     *\/\n-    private void sweep() {\n-        needSweep = false;\n-        for (Node p = head, s, n; p != null && (s = p.next) != null; ) {\n-            if (!s.isMatched())\n-                \/\/ Unmatched nodes are never self-linked\n-                p = s;\n-            else if ((n = s.next) == null) \/\/ trailing node is pinned\n-                break;\n-            else if (s == n)    \/\/ stale\n-                \/\/ No need to also check for p == s, since that implies s == n\n-                p = head;\n-            else\n-                p.casNext(s, n);\n-        }\n-    }\n-\n@@ -1154,1 +1123,0 @@\n-        head = tail = new Node();\n@@ -1167,1 +1135,1 @@\n-        Node h = null, t = null;\n+        TransferNode h = null, t = null;\n@@ -1169,3 +1137,3 @@\n-            Node newNode = new Node(Objects.requireNonNull(e));\n-            if (h == null)\n-                h = t = newNode;\n+            TransferNode newNode = new TransferNode(Objects.requireNonNull(e), true);\n+            if (t == null)\n+                t = h = newNode;\n@@ -1173,1 +1141,1 @@\n-                t.appendRelaxed(t = newNode);\n+                t.setNext(t = newNode);\n@@ -1175,2 +1143,0 @@\n-        if (h == null)\n-            h = t = new Node();\n@@ -1188,1 +1154,1 @@\n-        xfer(e, true, ASYNC, 0L);\n+        offer(e);\n@@ -1201,2 +1167,1 @@\n-        xfer(e, true, ASYNC, 0L);\n-        return true;\n+        return offer(e);\n@@ -1213,1 +1178,2 @@\n-        xfer(e, true, ASYNC, 0L);\n+        Objects.requireNonNull(e);\n+        xfer(e, -1L);\n@@ -1226,2 +1192,1 @@\n-        xfer(e, true, ASYNC, 0L);\n-        return true;\n+        return offer(e);\n@@ -1241,1 +1206,2 @@\n-        return xfer(e, true, NOW, 0L) == null;\n+        Objects.requireNonNull(e);\n+        return xfer(e, 0L) == null;\n@@ -1256,1 +1222,4 @@\n-        if (xfer(e, true, SYNC, 0L) != null) {\n+        Objects.requireNonNull(e);\n+        if (!Thread.interrupted()) {\n+            if (xfer(e, Long.MAX_VALUE) == null)\n+                return;\n@@ -1258,1 +1227,0 @@\n-            throw new InterruptedException();\n@@ -1260,0 +1228,1 @@\n+        throw new InterruptedException();\n@@ -1278,1 +1247,3 @@\n-        if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)\n+        Objects.requireNonNull(e);\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if (xfer(e, nanos) == null)\n@@ -1285,0 +1256,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1286,4 +1258,6 @@\n-        E e = xfer(null, false, SYNC, 0L);\n-        if (e != null)\n-            return e;\n-        Thread.interrupted();\n+        Object e;\n+        if (!Thread.interrupted()) {\n+            if ((e = xfer(null, Long.MAX_VALUE)) != null)\n+                return (E) e;\n+            Thread.interrupted();\n+        }\n@@ -1293,0 +1267,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1294,3 +1269,4 @@\n-        E e = xfer(null, false, TIMED, unit.toNanos(timeout));\n-        if (e != null || !Thread.interrupted())\n-            return e;\n+        Object e;\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if ((e = xfer(null, nanos)) != null || !Thread.interrupted())\n+            return (E) e;\n@@ -1300,0 +1276,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1301,1 +1278,1 @@\n-        return xfer(null, false, NOW, 0L);\n+        return (E) xfer(null, 0L);\n@@ -1347,1 +1324,1 @@\n-            for (Node p = head; p != null;) {\n+            for (TransferNode p = head; p != null;) {\n@@ -1375,1 +1352,1 @@\n-            for (Node p = head; p != null;) {\n+            for (TransferNode p = head; p != null;) {\n@@ -1424,2 +1401,2 @@\n-            for (Node p = head, pred = null; p != null; ) {\n-                Node q = p.next;\n+            for (TransferNode p = head, pred = null; p != null; ) {\n+                TransferNode q = p.next;\n@@ -1429,1 +1406,1 @@\n-                        if (o.equals(item) && p.tryMatch(item, null)) {\n+                        if (o.equals(item) && tryMatchData(p, item)) {\n@@ -1438,2 +1415,2 @@\n-                for (Node c = p;; q = p.next) {\n-                    if (q == null || !q.isMatched()) {\n+                for (TransferNode c = p;; q = p.next) {\n+                    if (q == null || q.isLive()) {\n@@ -1460,2 +1437,2 @@\n-            for (Node p = head, pred = null; p != null; ) {\n-                Node q = p.next;\n+            for (TransferNode p = head, pred = null; p != null; ) {\n+                TransferNode q = p.next;\n@@ -1472,2 +1449,2 @@\n-                for (Node c = p;; q = p.next) {\n-                    if (q == null || !q.isMatched()) {\n+                for (TransferNode c = p;; q = p.next) {\n+                    if (q == null || q.isLive()) {\n@@ -1522,1 +1499,1 @@\n-        Node h = null, t = null;\n+        TransferNode h = null, t = null;\n@@ -1524,3 +1501,3 @@\n-            Node newNode = new Node(item);\n-            if (h == null)\n-                h = t = newNode;\n+            TransferNode newNode = new TransferNode(item, true);\n+            if (t == null)\n+                t = h = newNode;\n@@ -1528,1 +1505,1 @@\n-                t.appendRelaxed(t = newNode);\n+                t.setNext(t = newNode);\n@@ -1530,2 +1507,0 @@\n-        if (h == null)\n-            h = t = new Node();\n@@ -1578,1 +1553,1 @@\n-            for (Node p = head, c = p, pred = null, q; p != null; p = q) {\n+            for (TransferNode p = head, c = p, pred = null, q; p != null; p = q) {\n@@ -1583,1 +1558,1 @@\n-                        if (p.tryMatch(item, null))\n+                        if (tryMatchData(p, item))\n@@ -1613,3 +1588,3 @@\n-    void forEachFrom(Consumer<? super E> action, Node p) {\n-        for (Node pred = null; p != null; ) {\n-            Node q = p.next;\n+    void forEachFrom(Consumer<? super E> action, TransferNode p) {\n+        for (TransferNode pred = null; p != null; ) {\n+            TransferNode q = p.next;\n@@ -1625,2 +1600,2 @@\n-            for (Node c = p;; q = p.next) {\n-                if (q == null || !q.isMatched()) {\n+            for (TransferNode c = p;; q = p.next) {\n+                if (q == null || q.isLive()) {\n@@ -1643,5 +1618,3 @@\n-    private static final VarHandle HEAD;\n-    private static final VarHandle TAIL;\n-    static final VarHandle ITEM;\n-    static final VarHandle NEXT;\n-    static final VarHandle WAITER;\n+    static final VarHandle HEAD;\n+    static final VarHandle TAIL;\n+    static final VarHandle SWEEPVOTES;\n@@ -1650,0 +1623,1 @@\n+            Class<?> ltq = LinkedTransferQueue.class, tn = TransferNode.class;\n@@ -1651,7 +1625,3 @@\n-            HEAD = l.findVarHandle(LinkedTransferQueue.class, \"head\",\n-                                   Node.class);\n-            TAIL = l.findVarHandle(LinkedTransferQueue.class, \"tail\",\n-                                   Node.class);\n-            ITEM = l.findVarHandle(Node.class, \"item\", Object.class);\n-            NEXT = l.findVarHandle(Node.class, \"next\", Node.class);\n-            WAITER = l.findVarHandle(Node.class, \"waiter\", Thread.class);\n+            HEAD = l.findVarHandle(ltq, \"head\", tn);\n+            TAIL = l.findVarHandle(ltq, \"tail\", tn);\n+            SWEEPVOTES = l.findVarHandle(ltq, \"sweepVotes\", int.class);\n@@ -1661,4 +1631,0 @@\n-\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":567,"deletions":601,"binary":false,"changes":1168,"status":"modified"},{"patch":"@@ -50,0 +50,4 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.LinkedTransferQueue;\n+import java.util.concurrent.TransferQueue;\n+import static java.util.concurrent.LinkedTransferQueue.TransferNode;\n@@ -101,27 +105,19 @@\n-     * The (Lifo) stack is used for non-fair mode, and the (Fifo)\n-     * queue for fair mode. The performance of the two is generally\n-     * similar. Fifo usually supports higher throughput under\n-     * contention but Lifo maintains higher thread locality in common\n-     * applications.\n-     *\n-     * A dual queue (and similarly stack) is one that at any given\n-     * time either holds \"data\" -- items provided by put operations,\n-     * or \"requests\" -- slots representing take operations, or is\n-     * empty. A call to \"fulfill\" (i.e., a call requesting an item\n-     * from a queue holding data or vice versa) dequeues a\n-     * complementary node.  The most interesting feature of these\n-     * queues is that any operation can figure out which mode the\n-     * queue is in, and act accordingly without needing locks.\n-     *\n-     * Both the queue and stack extend abstract class Transferer\n-     * defining the single method transfer that does a put or a\n-     * take. These are unified into a single method because in dual\n-     * data structures, the put and take operations are symmetrical,\n-     * so nearly all code can be combined. The resulting transfer\n-     * methods are on the long side, but are easier to follow than\n-     * they would be if broken up into nearly-duplicated parts.\n-     *\n-     * The queue and stack data structures share many conceptual\n-     * similarities but very few concrete details. For simplicity,\n-     * they are kept distinct so that they can later evolve\n-     * separately.\n+     * The queue is treated as a Lifo stack in non-fair mode, and a\n+     * Fifo queue in fair mode. In most contexts, transfer performance\n+     * is roughly comparable across them. Lifo is usually faster under\n+     * low contention, but can be much slower under high contention.\n+     * Performance of applications using them also varies. Lifo is\n+     * generally preferable in resource management settings (for\n+     * example cached thread pools) because of better temporal\n+     * locality, but inappropriate for message-passing applications.\n+\n+     * A dual queue is one that at any given time either holds \"data\"\n+     * -- items provided by put operations, or \"requests\" -- slots\n+     * representing take operations, or is empty. A \"fulfill\"\n+     * operation (i.e., a call requesting an item from a queue holding\n+     * data or vice versa) dequeues a complementary node.  Any\n+     * operation can figure out which mode the queue is in, and act\n+     * accordingly without needing locks.  So put and take operations\n+     * are symmetrical, and all transfer methods invoke a single\n+     * method \"xfer\" that does a put or a take in either fifo or lifo\n+     * mode.\n@@ -130,2 +126,1 @@\n-     * in extending them for use in synchronous queues, as well as\n-     * dealing with cancellation. The main differences include:\n+     * in ways including:\n@@ -134,2 +129,6 @@\n-     *     the ones here use mode bits in nodes, leading to a number\n-     *     of further adaptations.\n+     *     the ones here use mode bits in nodes, and usually avoid\n+     *     creating nodes when fulfilling. They also use the\n+     *     compareAndExchange form of CAS for pointer updates to reduce\n+     *     memory traffic. The Fifo version accommodates lazy\n+     *     updates and slack as desxcribed in the LinkedTransferQueue\n+     *     internal documentation.\n@@ -137,1 +136,2 @@\n-     *     fulfilled.\n+     *     fulfilled, preceded by brief spins at\/mear front positions\n+     *     if not VirtualThreads.\n@@ -141,44 +141,3 @@\n-     *\n-     * Blocking is mainly accomplished using LockSupport park\/unpark,\n-     * except that nodes that appear to be the next ones to become\n-     * fulfilled first spin a bit (on multiprocessors only). On very\n-     * busy synchronous queues, spinning can dramatically improve\n-     * throughput. And on less busy ones, the amount of spinning is\n-     * small enough not to be noticeable.\n-     *\n-     * Cleaning is done in different ways in queues vs stacks.  For\n-     * queues, we can almost always remove a node immediately in O(1)\n-     * time (modulo retries for consistency checks) when it is\n-     * cancelled. But if it may be pinned as the current tail, it must\n-     * wait until some subsequent cancellation. For stacks, we need a\n-     * potentially O(n) traversal to be sure that we can remove the\n-     * node, but this can run concurrently with other threads\n-     * accessing the stack.\n-     *\n-     * While garbage collection takes care of most node reclamation\n-     * issues that otherwise complicate nonblocking algorithms, care\n-     * is taken to \"forget\" references to data, other nodes, and\n-     * threads that might be held on to long-term by blocked\n-     * threads. In cases where setting to null would otherwise\n-     * conflict with main algorithms, this is done by changing a\n-     * node's link to now point to the node itself. This doesn't arise\n-     * much for Stack nodes (because blocked threads do not hang on to\n-     * old head pointers), but references in Queue nodes must be\n-     * aggressively forgotten to avoid reachability of everything any\n-     * node has ever referred to since arrival.\n-     *\n-     * The above steps improve throughput when many threads produce\n-     * and\/or consume data. But they don't help much with\n-     * single-source \/ single-sink usages in which one side or the\n-     * other is always transiently blocked, and so throughput is\n-     * mainly a function of thread scheduling. This is not usually\n-     * noticeably improved with bounded short spin-waits. Instead both\n-     * forms of transfer try Thread.yield if apparently the sole\n-     * waiter. This works well when there are more tasks that cores,\n-     * which is expected to be the main usage context of this mode. In\n-     * other cases, waiters may help with some bookkeeping, then\n-     * park\/unpark.\n-     *\/\n-\n-    \/**\n-     * Shared internal API for dual stacks and queues.\n+     *  4. For compatibility and logistics reasons, Fifo mode directly\n+     *     uses LinkedTransferQueue operations, but Lifo mode support is\n+     *     added in subclass Transferer.\n@@ -186,16 +145,0 @@\n-    abstract static class Transferer<E> {\n-        \/**\n-         * Performs a put or take.\n-         *\n-         * @param e if non-null, the item to be handed to a consumer;\n-         *          if null, requests that transfer return an item\n-         *          offered by producer.\n-         * @param timed if this operation should timeout\n-         * @param nanos the timeout, in nanoseconds\n-         * @return if non-null, the item provided or received; if null,\n-         *         the operation failed due to timeout or interrupt --\n-         *         the caller can distinguish which of these occurred\n-         *         by checking Thread.interrupted.\n-         *\/\n-        abstract E transfer(E e, boolean timed, long nanos);\n-    }\n@@ -204,2 +147,6 @@\n-     * The number of nanoseconds for which it is faster to spin\n-     * rather than to use timed park. A rough estimate suffices.\n+     * Extension of LinkedTransferQueue to support Lifo (stack) mode.\n+     * Methods use tha \"tail\" field as top of stack (versus tail of\n+     * queue). Note that popped nodes are not self-linked because thay\n+     * are not prone to unbounded garbage chains. Also note that\n+     * \"async\" mode is never used and not supported for synchronous\n+     * transfers.\n@@ -207,126 +154,2 @@\n-    static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1023L;\n-\n-    \/** Dual stack *\/\n-    static final class TransferStack<E> extends Transferer<E> {\n-        \/*\n-         * This extends Scherer-Scott dual stack algorithm, differing,\n-         * among other ways, by using \"covering\" nodes rather than\n-         * bit-marked pointers: Fulfilling operations push on marker\n-         * nodes (with FULFILLING bit set in mode) to reserve a spot\n-         * to match a waiting node.\n-         *\/\n-\n-        \/* Modes for SNodes, ORed together in node fields *\/\n-        \/** Node represents an unfulfilled consumer *\/\n-        static final int REQUEST    = 0;\n-        \/** Node represents an unfulfilled producer *\/\n-        static final int DATA       = 1;\n-        \/** Node is fulfilling another unfulfilled DATA or REQUEST *\/\n-        static final int FULFILLING = 2;\n-\n-        \/** Returns true if m has fulfilling bit set. *\/\n-        static boolean isFulfilling(int m) { return (m & FULFILLING) != 0; }\n-\n-        \/** Node class for TransferStacks. *\/\n-        static final class SNode implements ForkJoinPool.ManagedBlocker {\n-            volatile SNode next;        \/\/ next node in stack\n-            volatile SNode match;       \/\/ the node matched to this\n-            volatile Thread waiter;     \/\/ to control park\/unpark\n-            Object item;                \/\/ data; or null for REQUESTs\n-            int mode;\n-            \/\/ Note: item and mode fields don't need to be volatile\n-            \/\/ since they are always written before, and read after,\n-            \/\/ other volatile\/atomic operations.\n-\n-            SNode(Object item) {\n-                this.item = item;\n-            }\n-\n-            boolean casNext(SNode cmp, SNode val) {\n-                return cmp == next &&\n-                    SNEXT.compareAndSet(this, cmp, val);\n-            }\n-\n-            \/**\n-             * Tries to match node s to this node, if so, waking up thread.\n-             * Fulfillers call tryMatch to identify their waiters.\n-             * Waiters block until they have been matched.\n-             *\n-             * @param s the node to match\n-             * @return true if successfully matched to s\n-             *\/\n-            boolean tryMatch(SNode s) {\n-                SNode m; Thread w;\n-                if ((m = match) == null) {\n-                    if (SMATCH.compareAndSet(this, null, s)) {\n-                        if ((w = waiter) != null)\n-                            LockSupport.unpark(w);\n-                        return true;\n-                    }\n-                    else\n-                        m = match;\n-                }\n-                return m == s;\n-            }\n-\n-            \/**\n-             * Tries to cancel a wait by matching node to itself.\n-             *\/\n-            boolean tryCancel() {\n-                return SMATCH.compareAndSet(this, null, this);\n-            }\n-\n-            boolean isCancelled() {\n-                return match == this;\n-            }\n-\n-            public final boolean isReleasable() {\n-                return match != null || Thread.currentThread().isInterrupted();\n-            }\n-\n-            public final boolean block() {\n-                while (!isReleasable()) LockSupport.park();\n-                return true;\n-            }\n-\n-            void forgetWaiter() {\n-                SWAITER.setOpaque(this, null);\n-            }\n-\n-            \/\/ VarHandle mechanics\n-            private static final VarHandle SMATCH;\n-            private static final VarHandle SNEXT;\n-            private static final VarHandle SWAITER;\n-            static {\n-                try {\n-                    MethodHandles.Lookup l = MethodHandles.lookup();\n-                    SMATCH = l.findVarHandle(SNode.class, \"match\", SNode.class);\n-                    SNEXT = l.findVarHandle(SNode.class, \"next\", SNode.class);\n-                    SWAITER = l.findVarHandle(SNode.class, \"waiter\", Thread.class);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new ExceptionInInitializerError(e);\n-                }\n-            }\n-        }\n-\n-        \/** The head (top) of the stack *\/\n-        volatile SNode head;\n-\n-        boolean casHead(SNode h, SNode nh) {\n-            return h == head &&\n-                SHEAD.compareAndSet(this, h, nh);\n-        }\n-\n-        \/**\n-         * Creates or resets fields of a node. Called only from transfer\n-         * where the node to push on stack is lazily created and\n-         * reused when possible to help reduce intervals between reads\n-         * and CASes of head and to avoid surges of garbage when CASes\n-         * to push nodes fail due to contention.\n-         *\/\n-        static SNode snode(SNode s, Object e, SNode next, int mode) {\n-            if (s == null) s = new SNode(e);\n-            s.mode = mode;\n-            s.next = next;\n-            return s;\n-        }\n+    @SuppressWarnings(\"serial\") \/\/ never serialized\n+    static final class Transferer<E> extends LinkedTransferQueue<E> {\n@@ -335,1 +158,11 @@\n-         * Puts or takes an item.\n+         * Puts or takes an item with lifo ordering. Loops trying:\n+         *\n+         * * If top exists and is already matched, pop and continue\n+         * * If top has complementary type, try to fulfill by CASing item,\n+         *    and pop (which will succeed unless already helped).\n+         * * If no possible match, unless immediate mode, push a\n+         *    node and wait, later unsplicing if cancelled.\n+         *\n+         * @param e the item or null for take\n+         * @param nanos timeout: 0 for immediate, Long.MAX_VALUE for untimed\n+         * @return an item if matched, else e\n@@ -337,91 +170,9 @@\n-        @SuppressWarnings(\"unchecked\")\n-        E transfer(E e, boolean timed, long nanos) {\n-            \/*\n-             * Basic algorithm is to loop trying one of three actions:\n-             *\n-             * 1. If apparently empty or already containing nodes of same\n-             *    mode, try to push node on stack and wait for a match,\n-             *    returning it, or null if cancelled.\n-             *\n-             * 2. If apparently containing node of complementary mode,\n-             *    try to push a fulfilling node on to stack, match\n-             *    with corresponding waiting node, pop both from\n-             *    stack, and return matched item. The matching or\n-             *    unlinking might not actually be necessary because of\n-             *    other threads performing action 3:\n-             *\n-             * 3. If top of stack already holds another fulfilling node,\n-             *    help it out by doing its match and\/or pop\n-             *    operations, and then continue. The code for helping\n-             *    is essentially the same as for fulfilling, except\n-             *    that it doesn't return the item.\n-             *\/\n-\n-            SNode s = null; \/\/ constructed\/reused as needed\n-            int mode = (e == null) ? REQUEST : DATA;\n-\n-            for (;;) {\n-                SNode h = head;\n-                if (h == null || h.mode == mode) {  \/\/ empty or same-mode\n-                    if (timed && nanos <= 0L) {     \/\/ can't wait\n-                        if (h != null && h.isCancelled())\n-                            casHead(h, h.next);     \/\/ pop cancelled node\n-                        else\n-                            return null;\n-                    } else if (casHead(h, s = snode(s, e, h, mode))) {\n-                        long deadline = timed ? System.nanoTime() + nanos : 0L;\n-                        Thread w = Thread.currentThread();\n-                        int stat = -1; \/\/ -1: may yield, +1: park, else 0\n-                        SNode m;                    \/\/ await fulfill or cancel\n-                        while ((m = s.match) == null) {\n-                            if ((timed &&\n-                                 (nanos = deadline - System.nanoTime()) <= 0) ||\n-                                w.isInterrupted()) {\n-                                if (s.tryCancel()) {\n-                                    clean(s);       \/\/ wait cancelled\n-                                    return null;\n-                                }\n-                            } else if ((m = s.match) != null) {\n-                                break;              \/\/ recheck\n-                            } else if (stat <= 0) {\n-                                if (stat < 0 && h == null && head == s) {\n-                                    stat = 0;       \/\/ yield once if was empty\n-                                    Thread.yield();\n-                                } else {\n-                                    stat = 1;\n-                                    s.waiter = w;   \/\/ enable signal\n-                                }\n-                            } else if (!timed) {\n-                                LockSupport.setCurrentBlocker(this);\n-                                try {\n-                                    ForkJoinPool.managedBlock(s);\n-                                } catch (InterruptedException cannotHappen) { }\n-                                LockSupport.setCurrentBlocker(null);\n-                            } else if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                                LockSupport.parkNanos(this, nanos);\n-                        }\n-                        if (stat == 1)\n-                            s.forgetWaiter();\n-                        Object result = (mode == REQUEST) ? m.item : s.item;\n-                        if (h != null && h.next == s)\n-                            casHead(h, s.next);     \/\/ help fulfiller\n-                        return (E) result;\n-                    }\n-                } else if (!isFulfilling(h.mode)) { \/\/ try to fulfill\n-                    if (h.isCancelled())            \/\/ already cancelled\n-                        casHead(h, h.next);         \/\/ pop and retry\n-                    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n-                        for (;;) { \/\/ loop until matched or waiters disappear\n-                            SNode m = s.next;       \/\/ m is s's match\n-                            if (m == null) {        \/\/ all waiters are gone\n-                                casHead(s, null);   \/\/ pop fulfill node\n-                                s = null;           \/\/ use new node next time\n-                                break;              \/\/ restart main loop\n-                            }\n-                            SNode mn = m.next;\n-                            if (m.tryMatch(s)) {\n-                                casHead(s, mn);     \/\/ pop both s and m\n-                                return (E) ((mode == REQUEST) ? m.item : s.item);\n-                            } else                  \/\/ lost match\n-                                s.casNext(m, mn);   \/\/ help unlink\n-                        }\n+        final Object xferLifo(Object e, long nanos) {\n+            boolean haveData = (e != null);\n+            for (TransferNode top = tail, s = null;;) {\n+                boolean isData; Object match;\n+                if (top != null) {\n+                    if ((isData = top.isData) != ((match = top.item) != null)) {\n+                        TransferNode n = top.next, u = cmpExTail(top, n);\n+                        top = (top == u) ? n : u;     \/\/ collapse dead node\n+                        continue;                     \/\/ retry with next top\n@@ -429,10 +180,6 @@\n-                } else {                            \/\/ help a fulfiller\n-                    SNode m = h.next;               \/\/ m is h's match\n-                    if (m == null)                  \/\/ waiter is gone\n-                        casHead(h, null);           \/\/ pop fulfilling node\n-                    else {\n-                        SNode mn = m.next;\n-                        if (m.tryMatch(h))          \/\/ help match\n-                            casHead(h, mn);         \/\/ pop both h and m\n-                        else                        \/\/ lost match\n-                            h.casNext(m, mn);       \/\/ help unlink\n+                    if (isData != haveData) {         \/\/ try to fulfill\n+                        if (top.cmpExItem(match, e) != match)\n+                            continue;                 \/\/ lost race\n+                        cmpExTail(top, top.next);\n+                        LockSupport.unpark(top.waiter);\n+                        return match;\n@@ -441,0 +188,11 @@\n+                if (nanos == 0L)                     \/\/ no fulfillers, no wait\n+                    return e;\n+                if (s == null)                       \/\/ push new node and wait\n+                    s = new TransferNode(e, haveData);\n+                s.setNext(top);\n+                if (top == (top = cmpExTail(top, s))) {\n+                    boolean maySpin = (top == null || top.waiter == null);\n+                    if ((match = s.await(e, nanos, this, maySpin)) == e)\n+                        unspliceLifo(s);             \/\/ cancelled\n+                    return match;\n+                }\n@@ -445,1 +203,1 @@\n-         * Unlinks s from the stack.\n+         * Unlinks s, assuming lifo mode.\n@@ -447,4 +205,2 @@\n-        void clean(SNode s) {\n-            s.item = null;   \/\/ forget item\n-            s.forgetWaiter();\n-\n+        private void unspliceLifo(TransferNode s) {\n+            TransferNode past = null;\n@@ -453,7 +209,6 @@\n-             * s. If there are multiple concurrent calls to clean, we\n-             * might not see s if another thread has already removed\n-             * it. But we can stop when we see any node known to\n-             * follow s. We use s.next unless it too is cancelled, in\n-             * which case we try the node one past. We don't check any\n-             * further because we don't want to doubly traverse just to\n-             * find sentinel.\n+             * s, and we might not see s if already popped or another\n+             * unsplicer has removed it. But we can stop when we see\n+             * any node known to follow s. We use s.next unless it is\n+             * not live, in which case we try the node one past. We\n+             * don't check any further because we don't want to doubly\n+             * traverse just to find sentinel.\n@@ -461,3 +216,1 @@\n-\n-            SNode past = s.next;\n-            if (past != null && past.isCancelled())\n+            if (s != null && (past = s.next) != null && !past.isLive())\n@@ -466,12 +219,4 @@\n-            \/\/ Absorb cancelled nodes at head\n-            SNode p;\n-            while ((p = head) != null && p != past && p.isCancelled())\n-                casHead(p, p.next);\n-\n-            \/\/ Unsplice embedded nodes\n-            while (p != null && p != past) {\n-                SNode n = p.next;\n-                if (n != null && n.isCancelled())\n-                    p.casNext(n, n.next);\n-                else\n-                    p = n;\n+            TransferNode p = tail;           \/\/ collapse top\n+            while (p != null && p != past && !p.isLive()) {\n+                TransferNode n = p.next, h = cmpExTail(p, n);\n+                p = (h == p) ? n : h;\n@@ -479,1 +224,0 @@\n-        }\n@@ -481,8 +225,5 @@\n-        \/\/ VarHandle mechanics\n-        private static final VarHandle SHEAD;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                SHEAD = l.findVarHandle(TransferStack.class, \"head\", SNode.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n+            for (TransferNode n, f, u;;) {   \/\/ unsplice embedded nodes\n+                if (p == null || p == past || (n = p.next) == null)\n+                    break;\n+                p = (n.isLive() ? n :\n+                     n == (u = p.cmpExNext(n, f = n.next)) ? f : u);\n@@ -491,34 +232,1 @@\n-    }\n-\n-    \/** Dual Queue *\/\n-    static final class TransferQueue<E> extends Transferer<E> {\n-        \/*\n-         * This extends Scherer-Scott dual queue algorithm, differing,\n-         * among other ways, by using modes within nodes rather than\n-         * marked pointers. The algorithm is a little simpler than\n-         * that for stacks because fulfillers do not need explicit\n-         * nodes, and matching is done by CAS'ing QNode.item field\n-         * from non-null to null (for put) or vice versa (for take).\n-         *\/\n-\n-        \/** Node class for TransferQueue. *\/\n-        static final class QNode implements ForkJoinPool.ManagedBlocker {\n-            volatile QNode next;          \/\/ next node in queue\n-            volatile Object item;         \/\/ CAS'ed to or from null\n-            volatile Thread waiter;       \/\/ to control park\/unpark\n-            final boolean isData;\n-\n-            QNode(Object item, boolean isData) {\n-                this.item = item;\n-                this.isData = isData;\n-            }\n-\n-            boolean casNext(QNode cmp, QNode val) {\n-                return next == cmp &&\n-                    QNEXT.compareAndSet(this, cmp, val);\n-            }\n-\n-            boolean casItem(Object cmp, Object val) {\n-                return item == cmp &&\n-                    QITEM.compareAndSet(this, cmp, val);\n-            }\n+   }\n@@ -526,189 +234,4 @@\n-            \/**\n-             * Tries to cancel by CAS'ing ref to this as item.\n-             *\/\n-            boolean tryCancel(Object cmp) {\n-                return QITEM.compareAndSet(this, cmp, this);\n-            }\n-\n-            boolean isCancelled() {\n-                return item == this;\n-            }\n-\n-            \/**\n-             * Returns true if this node is known to be off the queue\n-             * because its next pointer has been forgotten due to\n-             * an advanceHead operation.\n-             *\/\n-            boolean isOffList() {\n-                return next == this;\n-            }\n-\n-            void forgetWaiter() {\n-                QWAITER.setOpaque(this, null);\n-            }\n-\n-            boolean isFulfilled() {\n-                Object x;\n-                return isData == ((x = item) == null) || x == this;\n-            }\n-\n-            public final boolean isReleasable() {\n-                Object x;\n-                return isData == ((x = item) == null) || x == this ||\n-                    Thread.currentThread().isInterrupted();\n-            }\n-\n-            public final boolean block() {\n-                while (!isReleasable()) LockSupport.park();\n-                return true;\n-            }\n-\n-            \/\/ VarHandle mechanics\n-            private static final VarHandle QITEM;\n-            private static final VarHandle QNEXT;\n-            private static final VarHandle QWAITER;\n-            static {\n-                try {\n-                    MethodHandles.Lookup l = MethodHandles.lookup();\n-                    QITEM = l.findVarHandle(QNode.class, \"item\", Object.class);\n-                    QNEXT = l.findVarHandle(QNode.class, \"next\", QNode.class);\n-                    QWAITER = l.findVarHandle(QNode.class, \"waiter\", Thread.class);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new ExceptionInInitializerError(e);\n-                }\n-            }\n-        }\n-\n-        \/** Head of queue *\/\n-        transient volatile QNode head;\n-        \/** Tail of queue *\/\n-        transient volatile QNode tail;\n-        \/**\n-         * Reference to a cancelled node that might not yet have been\n-         * unlinked from queue because it was the last inserted node\n-         * when it was cancelled.\n-         *\/\n-        transient volatile QNode cleanMe;\n-\n-        TransferQueue() {\n-            QNode h = new QNode(null, false); \/\/ initialize to dummy node.\n-            head = h;\n-            tail = h;\n-        }\n-\n-        \/**\n-         * Tries to cas nh as new head; if successful, unlink\n-         * old head's next node to avoid garbage retention.\n-         *\/\n-        void advanceHead(QNode h, QNode nh) {\n-            if (h == head &&\n-                QHEAD.compareAndSet(this, h, nh))\n-                h.next = h; \/\/ forget old next\n-        }\n-\n-        \/**\n-         * Tries to cas nt as new tail.\n-         *\/\n-        void advanceTail(QNode t, QNode nt) {\n-            if (tail == t)\n-                QTAIL.compareAndSet(this, t, nt);\n-        }\n-\n-        \/**\n-         * Tries to CAS cleanMe slot.\n-         *\/\n-        boolean casCleanMe(QNode cmp, QNode val) {\n-            return cleanMe == cmp &&\n-                QCLEANME.compareAndSet(this, cmp, val);\n-        }\n-\n-        \/**\n-         * Puts or takes an item.\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        E transfer(E e, boolean timed, long nanos) {\n-            \/* Basic algorithm is to loop trying to take either of\n-             * two actions:\n-             *\n-             * 1. If queue apparently empty or holding same-mode nodes,\n-             *    try to add node to queue of waiters, wait to be\n-             *    fulfilled (or cancelled) and return matching item.\n-             *\n-             * 2. If queue apparently contains waiting items, and this\n-             *    call is of complementary mode, try to fulfill by CAS'ing\n-             *    item field of waiting node and dequeuing it, and then\n-             *    returning matching item.\n-             *\n-             * In each case, along the way, check for and try to help\n-             * advance head and tail on behalf of other stalled\/slow\n-             * threads.\n-             *\n-             * The loop starts off with a null check guarding against\n-             * seeing uninitialized head or tail values. This never\n-             * happens in current SynchronousQueue, but could if\n-             * callers held non-volatile\/final ref to the\n-             * transferer. The check is here anyway because it places\n-             * null checks at top of loop, which is usually faster\n-             * than having them implicitly interspersed.\n-             *\/\n-\n-            QNode s = null;                  \/\/ constructed\/reused as needed\n-            boolean isData = (e != null);\n-            for (;;) {\n-                QNode t = tail, h = head, m, tn;         \/\/ m is node to fulfill\n-                if (t == null || h == null)\n-                    ;                                    \/\/ inconsistent\n-                else if (h == t || t.isData == isData) { \/\/ empty or same-mode\n-                    if (t != tail)                       \/\/ inconsistent\n-                        ;\n-                    else if ((tn = t.next) != null)      \/\/ lagging tail\n-                        advanceTail(t, tn);\n-                    else if (timed && nanos <= 0L)       \/\/ can't wait\n-                        return null;\n-                    else if (t.casNext(null, (s != null) ? s :\n-                                       (s = new QNode(e, isData)))) {\n-                        advanceTail(t, s);\n-                        long deadline = timed ? System.nanoTime() + nanos : 0L;\n-                        Thread w = Thread.currentThread();\n-                        int stat = -1; \/\/ same idea as TransferStack\n-                        Object item;\n-                        while ((item = s.item) == e) {\n-                            if ((timed &&\n-                                 (nanos = deadline - System.nanoTime()) <= 0) ||\n-                                w.isInterrupted()) {\n-                                if (s.tryCancel(e)) {\n-                                    clean(t, s);\n-                                    return null;\n-                                }\n-                            } else if ((item = s.item) != e) {\n-                                break;                   \/\/ recheck\n-                            } else if (stat <= 0) {\n-                                if (t.next == s) {\n-                                    if (stat < 0 && t.isFulfilled()) {\n-                                        stat = 0;        \/\/ yield once if first\n-                                        Thread.yield();\n-                                    }\n-                                    else {\n-                                        stat = 1;\n-                                        s.waiter = w;\n-                                    }\n-                                }\n-                            } else if (!timed) {\n-                                LockSupport.setCurrentBlocker(this);\n-                                try {\n-                                    ForkJoinPool.managedBlock(s);\n-                                } catch (InterruptedException cannotHappen) { }\n-                                LockSupport.setCurrentBlocker(null);\n-                            }\n-                            else if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                                LockSupport.parkNanos(this, nanos);\n-                        }\n-                        if (stat == 1)\n-                            s.forgetWaiter();\n-                        if (!s.isOffList()) {            \/\/ not already unlinked\n-                            advanceHead(t, s);           \/\/ unlink if head\n-                            if (item != null)            \/\/ and forget fields\n-                                s.item = s;\n-                        }\n-                        return (item != null) ? (E)item : e;\n-                    }\n+    \/**\n+     * The transferer. (See below about serialization.)\n+     *\/\n+    private transient final Transferer<E> transferer;\n@@ -716,14 +239,1 @@\n-                } else if ((m = h.next) != null && t == tail && h == head) {\n-                    Thread waiter;\n-                    Object x = m.item;\n-                    boolean fulfilled = ((isData == (x == null)) &&\n-                                         x != m && m.casItem(x, e));\n-                    advanceHead(h, m);                    \/\/ (help) dequeue\n-                    if (fulfilled) {\n-                        if ((waiter = m.waiter) != null)\n-                            LockSupport.unpark(waiter);\n-                        return (x != null) ? (E)x : e;\n-                    }\n-                }\n-            }\n-        }\n+    private transient final boolean fair;\n@@ -731,71 +241,4 @@\n-        \/**\n-         * Gets rid of cancelled node s with original predecessor pred.\n-         *\/\n-        void clean(QNode pred, QNode s) {\n-            s.forgetWaiter();\n-            \/*\n-             * At any given time, exactly one node on list cannot be\n-             * deleted -- the last inserted node. To accommodate this,\n-             * if we cannot delete s, we save its predecessor as\n-             * \"cleanMe\", deleting the previously saved version\n-             * first. At least one of node s or the node previously\n-             * saved can always be deleted, so this always terminates.\n-             *\/\n-            while (pred.next == s) { \/\/ Return early if already unlinked\n-                QNode h = head;\n-                QNode hn = h.next;   \/\/ Absorb cancelled first node as head\n-                if (hn != null && hn.isCancelled()) {\n-                    advanceHead(h, hn);\n-                    continue;\n-                }\n-                QNode t = tail;      \/\/ Ensure consistent read for tail\n-                if (t == h)\n-                    return;\n-                QNode tn = t.next;\n-                if (t != tail)\n-                    continue;\n-                if (tn != null) {\n-                    advanceTail(t, tn);\n-                    continue;\n-                }\n-                if (s != t) {        \/\/ If not tail, try to unsplice\n-                    QNode sn = s.next;\n-                    if (sn == s || pred.casNext(s, sn))\n-                        return;\n-                }\n-                QNode dp = cleanMe;\n-                if (dp != null) {    \/\/ Try unlinking previous cancelled node\n-                    QNode d = dp.next;\n-                    QNode dn;\n-                    if (d == null ||               \/\/ d is gone or\n-                        d == dp ||                 \/\/ d is off list or\n-                        !d.isCancelled() ||        \/\/ d not cancelled or\n-                        (d != t &&                 \/\/ d not tail and\n-                         (dn = d.next) != null &&  \/\/   has successor\n-                         dn != d &&                \/\/   that is on list\n-                         dp.casNext(d, dn)))       \/\/ d unspliced\n-                        casCleanMe(dp, null);\n-                    if (dp == pred)\n-                        return;      \/\/ s is already saved node\n-                } else if (casCleanMe(null, pred))\n-                    return;          \/\/ Postpone cleaning s\n-            }\n-        }\n-\n-        \/\/ VarHandle mechanics\n-        private static final VarHandle QHEAD;\n-        private static final VarHandle QTAIL;\n-        private static final VarHandle QCLEANME;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                QHEAD = l.findVarHandle(TransferQueue.class, \"head\",\n-                                        QNode.class);\n-                QTAIL = l.findVarHandle(TransferQueue.class, \"tail\",\n-                                        QNode.class);\n-                QCLEANME = l.findVarHandle(TransferQueue.class, \"cleanMe\",\n-                                           QNode.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n+    \/** Invokes fair or lifo transfer *\/\n+    private Object xfer(boolean fair, Object e, long nanos) {\n+        Transferer<E> x = transferer;\n+        return (fair) ? x.xfer(e, nanos) : x.xferLifo(e, nanos);\n@@ -804,9 +247,0 @@\n-    \/**\n-     * The transferer. Set only in constructor, but cannot be declared\n-     * as final without further complicating serialization.  Since\n-     * this is accessed only at most once per public method, there\n-     * isn't a noticeable performance penalty for using volatile\n-     * instead of final here.\n-     *\/\n-    private transient volatile Transferer<E> transferer;\n-\n@@ -827,1 +261,2 @@\n-        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();\n+        this.fair = fair;\n+        transferer = new Transferer<E>();\n@@ -838,4 +273,5 @@\n-        if (e == null) throw new NullPointerException();\n-        if (transferer.transfer(e, false, 0) == null) {\n-            Thread.interrupted();\n-            throw new InterruptedException();\n+        Objects.requireNonNull(e);\n+        if (!Thread.interrupted()) {\n+            if (xfer(fair, e, Long.MAX_VALUE) == null)\n+                return;\n+            Thread.interrupted(); \/\/ failure possible only due to interrupt\n@@ -843,0 +279,1 @@\n+        throw new InterruptedException();\n@@ -856,2 +293,3 @@\n-        if (e == null) throw new NullPointerException();\n-        if (transferer.transfer(e, true, unit.toNanos(timeout)) != null)\n+        Objects.requireNonNull(e);\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if (xfer(fair, e, nanos) == null)\n@@ -874,2 +312,2 @@\n-        if (e == null) throw new NullPointerException();\n-        return transferer.transfer(e, true, 0) != null;\n+        Objects.requireNonNull(e);\n+        return xfer(fair, e, 0L) == null;\n@@ -885,0 +323,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -886,4 +325,6 @@\n-        E e = transferer.transfer(null, false, 0);\n-        if (e != null)\n-            return e;\n-        Thread.interrupted();\n+        Object e;\n+        if (!Thread.interrupted()) {\n+            if ((e = xfer(fair, null, Long.MAX_VALUE)) != null)\n+                return (E) e;\n+            Thread.interrupted();\n+        }\n@@ -902,0 +343,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -903,3 +345,4 @@\n-        E e = transferer.transfer(null, true, unit.toNanos(timeout));\n-        if (e != null || !Thread.interrupted())\n-            return e;\n+        Object e;\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if ((e = xfer(fair, null, nanos)) != null || !Thread.interrupted())\n+            return (E) e;\n@@ -916,0 +359,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -917,1 +361,1 @@\n-        return transferer.transfer(null, true, 0);\n+        return (E) xfer(fair, null, 0L);\n@@ -1107,5 +551,7 @@\n-     * To cope with serialization strategy in the 1.5 version of\n-     * SynchronousQueue, we declare some unused classes and fields\n-     * that exist solely to enable serializability across versions.\n-     * These fields are never used, so are initialized only if this\n-     * object is ever serialized or deserialized.\n+     * To cope with serialization across multiple implementation\n+     * overhauls, we declare some unused classes and fields that exist\n+     * solely to enable serializability across versions.  These fields\n+     * are never used, so are initialized only if this object is ever\n+     * serialized. We use readResolve to replace a deserialized queue\n+     * with a fresh one. Note that no queue elements are serialized,\n+     * since any existing ones are only transient.\n@@ -1133,1 +579,0 @@\n-        boolean fair = transferer instanceof TransferQueue;\n@@ -1148,5 +593,2 @@\n-     * Reconstitutes this queue from a stream (that is, deserializes it).\n-     * @param s the stream\n-     * @throws ClassNotFoundException if the class of a serialized object\n-     *         could not be found\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * Replaces a deserialized SynchronousQueue with a fresh one with\n+     * the associated type of Transferer.\n@@ -1154,13 +596,2 @@\n-    private void readObject(java.io.ObjectInputStream s)\n-        throws java.io.IOException, ClassNotFoundException {\n-        s.defaultReadObject();\n-        if (waitingProducers instanceof FifoWaitQueue)\n-            transferer = new TransferQueue<E>();\n-        else\n-            transferer = new TransferStack<E>();\n-    }\n-\n-    static {\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n+    private Object readResolve() {\n+        return new SynchronousQueue<E>(waitingProducers instanceof FifoWaitQueue);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":147,"deletions":716,"binary":false,"changes":863,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        Class<?> nodeClass = Class.forName(qClass.getName() + \"$Node\");\n+        Class<?> nodeClass = Class.forName(qClass.getName() + \"$TransferNode\");\n@@ -99,0 +99,10 @@\n+    \/*\n+     * Modified for jdk22: Accommodate lazy initialization, so counts\n+     * may vary by 1, and some nodes become headers vs unlinked,\n+     * compared to previous versions.\n+     *\/\n+\n+    static void checkNodeCount(int c, int n) {\n+        assertTrue(c == n || c == n - 1); \/\/ May or may not include header node\n+    }\n+\n@@ -127,2 +137,4 @@\n-        assertNull(next(head(q)));\n-        assertNull(item(head(q)));\n+        if (head(q) != null) {\n+            assertNull(next(head(q)));\n+            assertNull(item(head(q)));\n+        }\n@@ -130,1 +142,1 @@\n-        assertEquals(nodeCount(q), 2);\n+        checkNodeCount(nodeCount(q), 2);\n@@ -133,1 +145,1 @@\n-        assertEquals(nodeCount(q), 1);\n+        checkNodeCount(nodeCount(q), 1);\n@@ -161,1 +173,1 @@\n-        assertEquals(nodeCount(q), n + 1);\n+        checkNodeCount(nodeCount(q), n + 1);\n@@ -165,2 +177,1 @@\n-        assertEquals(nodeCount(q), n);\n-        assertIsSelfLinked(oldHead);\n+        checkNodeCount(nodeCount(q), n);\n@@ -241,1 +252,1 @@\n-        assertEquals(q.size(), c - (q.contains(n - 1) ? 0 : 1));\n+        checkNodeCount(c - (q.contains(n - 1) ? 0 : 1), q.size());\n@@ -266,1 +277,1 @@\n-        assertEquals(nodeCount(q), 1);\n+        checkNodeCount(nodeCount(q), 1);\n@@ -292,1 +303,1 @@\n-        assertEquals(nodeCount(q), n + 1);\n+        checkNodeCount(nodeCount(q), n + 1);\n@@ -321,1 +332,2 @@\n-            boolean slack = next(tail(q)) != null;\n+            boolean empty = (tail(q) == null);\n+            boolean slack = !empty && (next(tail(q)) != null);\n@@ -325,1 +337,1 @@\n-            else {\n+            else if (!empty) {\n@@ -368,2 +380,0 @@\n-        assertNotNull(head(q));\n-        assertNotNull(tail(q));\n@@ -371,1 +381,1 @@\n-        for (Object h; next(h = head(q)) == h; )\n+        for (Object h; (h = head(q)) != null && next(h) == h; )\n","filename":"test\/jdk\/java\/util\/concurrent\/LinkedTransferQueue\/WhiteBox.java","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"}]}