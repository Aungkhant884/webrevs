{"files":[{"patch":"@@ -575,1 +575,6 @@\n-Block* PhaseCFG::convert_NeverBranch_to_Goto(Block* b) {\n+\/\/ Check for NeverBranch at block end.  This needs to become a GOTO to the\n+\/\/ true target.  NeverBranch are treated as a conditional branch that always\n+\/\/ goes the same direction for most of the optimizer and are used to give a\n+\/\/ fake exit path to infinite loops.  At this late stage they need to turn\n+\/\/ into Goto's so that when you enter the infinite loop you indeed hang.\n+void PhaseCFG::convert_NeverBranch_to_Goto(Block *b) {\n@@ -610,1 +615,0 @@\n-  return dead;\n@@ -685,1 +689,0 @@\n-  Block_List unreachable; \/\/ Worklist of unreachable blocks to be removed.\n@@ -699,5 +702,1 @@\n-      Block* dead = convert_NeverBranch_to_Goto(block);\n-      \/\/ If the fake exit block becomes unreachable, save it for later removal.\n-      if (dead->is_trivially_unreachable()) {\n-        unreachable.push(dead);\n-      }\n+      convert_NeverBranch_to_Goto(block);\n@@ -733,35 +732,0 @@\n-\n-  \/\/ Remove all blocks that are transitively unreachable after the\n-  \/\/ NeverBranch-to-Goto conversion.\n-  while (unreachable.size() > 0) {\n-    Block* dead = unreachable.pop();\n-    for (uint i = 0; i < number_of_blocks(); i++) {\n-      Block* block = get_block(i);\n-      if (block == dead) {\n-        _blocks.remove(i);\n-        _number_of_blocks--;\n-        i--; \/\/ Ensure that we visit the block following the removed one.\n-      }\n-      if (block->_pre_order > dead->_pre_order) {\n-        \/\/ Enforce contiguous pre-order indices (assumed by PhaseBlockLayout).\n-        block->_pre_order--;\n-      }\n-      if (block->_rpo > dead->_rpo) {\n-        \/\/ Enforce contiguous reverse post-order indices as well, for sanity.\n-        block->_rpo--;\n-      }\n-    }\n-    \/\/ Update the successors' predecessor list and push new unreachable blocks.\n-    for (uint i = 0; i < dead->_num_succs; i++) {\n-      Block* succ = dead->_succs[i];\n-      Node* head = succ->head();\n-      for (int j = head->req() - 1; j >= 1; j--) {\n-        if (get_block_for_node(head->in(j)) == dead) {\n-          head->del_req(j);\n-        }\n-      }\n-      if (succ->is_trivially_unreachable()) {\n-        unreachable.push(succ);\n-      }\n-    }\n-  }\n@@ -984,0 +948,46 @@\n+void PhaseCFG::remove_unreachable_blocks() {\n+  ResourceMark rm;\n+  Block_List unreachable;\n+  \/\/ Initialize worklist of unreachable blocks to be removed.\n+  for (uint i = 0; i < number_of_blocks(); i++) {\n+    Block* block = get_block(i);\n+    if (block->is_trivially_unreachable()) {\n+      unreachable.push(block);\n+    }\n+  }\n+  \/\/ Now remove all blocks that are transitively unreachable.\n+  while (unreachable.size() > 0) {\n+    Block* dead = unreachable.pop();\n+    for (uint i = 0; i < _number_of_blocks; i++) {\n+      Block* block = get_block(i);\n+      if (block == dead) {\n+        _blocks.remove(i);\n+        _number_of_blocks--;\n+        i--; \/\/ Ensure that we visit the block following the removed one.\n+        continue;\n+      }\n+      if (block->_pre_order > dead->_pre_order) {\n+        \/\/ When this code runs (after PhaseCFG::fixup_flow()), Block::_pre_order\n+        \/\/ does not contain pre-order indices but simple block list indices.\n+        \/\/ Ensure they stay contiguous.\n+        \/\/ Block::_rpo does not contain valid reverse post-order indices anymore\n+        \/\/ (they are invalidated by block insertions in PhaseCFG::fixup_flow()),\n+        \/\/ so there is no need to update them.\n+        block->_pre_order--;\n+      }\n+    }\n+    \/\/ Update the successors' predecessor list and push new unreachable blocks.\n+    for (uint i = 0; i < dead->_num_succs; i++) {\n+      Block* succ = dead->_succs[i];\n+      Node* head = succ->head();\n+      for (int j = head->req() - 1; j >= 1; j--) {\n+        if (get_block_for_node(head->in(j)) == dead) {\n+          head->del_req(j);\n+        }\n+      }\n+      if (succ->is_trivially_unreachable()) {\n+        unreachable.push(succ);\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -508,2 +508,1 @@\n-  \/\/ Return the target block of the fake exit path.\n-  Block* convert_NeverBranch_to_Goto(Block* b);\n+  void convert_NeverBranch_to_Goto(Block *b);\n@@ -617,0 +616,4 @@\n+  \/\/ Remove all blocks that are transitively unreachable. Such blocks can be\n+  \/\/ found e.g. after PhaseCFG::convert_NeverBranch_to_Goto(). This function\n+  \/\/ assumes post-fixup_flow() block indices (Block::_pre_order, Block::_rpo).\n+  void remove_unreachable_blocks();\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2973,0 +2973,1 @@\n+    cfg.remove_unreachable_blocks();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}