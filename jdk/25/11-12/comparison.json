{"files":[{"patch":"@@ -543,1 +543,1 @@\n-\/\/ allowing workers to claim heap blocks, gaining exclusive rights to these blocks.\n+\/\/ allowing workers to claim heap areas (\"blocks\"), gaining exclusive rights to these.\n@@ -546,1 +546,1 @@\n-\/\/ The old spaces are divided into serveral fixed-size blocks.\n+\/\/ The old space is divided into fixed-size blocks.\n@@ -548,6 +548,8 @@\n-  \/\/ Index of iterable block, negative values for indexes of young generation spaces,\n-  \/\/ zero and positive values for indexes of blocks in old generation space.\n-  ssize_t _claimed_index;\n- public:\n-  static const ssize_t EdenIndex = -2;\n-  static const ssize_t SurvivorIndex = -1;\n+  size_t _claimed_index;\n+\n+public:\n+  static const size_t EdenIndex = 0;\n+  static const size_t SurvivorIndex = 1;\n+  \/\/ Use max_size_t as the invalid claim index\n+  static const size_t InvalidIndex = (size_t)-1;\n+  static const size_t NumNonOldGenClaims = 2;\n@@ -557,8 +559,8 @@\n-  bool claim_and_get_block(ssize_t* block_index) {\n-    assert(block_index != NULL, \"Invalid index pointer\");\n-    *block_index = Atomic::fetch_and_add(&_claimed_index, 1);\n-    ssize_t iterable_blocks = (ssize_t)ParallelScavengeHeap::heap()->old_gen()->iterable_blocks();\n-    if (*block_index >= iterable_blocks) {\n-      return false;\n-    }\n-    return true;\n+  size_t claim_and_get_block() {\n+    size_t block_index;\n+    block_index = Atomic::fetch_and_add(&_claimed_index, (size_t)1);\n+\n+    PSOldGen* old_gen = ParallelScavengeHeap::heap()->old_gen();\n+    size_t num_claims = old_gen->num_iterable_blocks() + NumNonOldGenClaims;\n+\n+    return block_index < num_claims ? block_index : InvalidIndex;\n@@ -570,1 +572,1 @@\n-  ssize_t block_index;\n+  size_t block_index = claimer->claim_and_get_block();\n@@ -572,1 +574,1 @@\n-  while (claimer->claim_and_get_block(&block_index)) {\n+  while (block_index != HeapBlockClaimer::InvalidIndex) {\n@@ -579,1 +581,1 @@\n-      old_gen()->block_iterate(cl, (size_t)block_index);\n+      old_gen()->object_iterate_block(cl, block_index - HeapBlockClaimer::NumNonOldGenClaims);\n@@ -581,0 +583,1 @@\n+    block_index = claimer->claim_and_get_block();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -176,20 +176,3 @@\n-\/*\n- * Divide space into blocks, processes block begins at\n- * bottom + block_index  * (IterateBlockSize \/ HeapWordSize).\n- * NOTE:\n- * - The initial block start address may not be a valid\n- * object address, _start_array is used to correct it.\n- *\n- * - The end address is not necessary to be object address.\n- *\n- * - If there is an object that crosses blocks, it is\n- * processed by the worker that owns the block within\n- * which the object starts.\n- *\n- *\/\n-void PSOldGen::block_iterate(ObjectClosure* cl, size_t block_index) {\n-  MutableSpace *space = object_space();\n-  HeapWord* bottom = space->bottom();\n-  HeapWord* top = space->top();\n-  size_t block_word_size = IterateBlockSize \/ HeapWordSize;\n-  HeapWord* begin = bottom + block_index * block_word_size;\n+size_t PSOldGen::num_iterable_blocks() const {\n+  return (object_space()->used_in_bytes() + IterateBlockSize - 1) \/ IterateBlockSize;\n+}\n@@ -197,0 +180,2 @@\n+void PSOldGen::object_iterate_block(ObjectClosure* cl, size_t block_index) {\n+  size_t block_word_size = IterateBlockSize \/ HeapWordSize;\n@@ -198,20 +183,22 @@\n-         \"BLOCK SIZE not a multiple of start_array block\");\n-\n-  \/\/ iterate objects in block.\n-  HeapWord* end = MIN2(top, begin + block_word_size);\n-  \/\/ Only iterate if there are objects between begin and end.\n-  if (start_array()->object_starts_in_range(begin, end)) {\n-    \/\/ Process objects in the range, start from finding object at the begining\n-    \/\/ address. Note that object_start() can return the last object in previous\n-    \/\/ block, and that object is processed by other worker scanning that block.\n-    \/\/ So here only focus on objects that fall into the current block.\n-    HeapWord* start = start_array()->object_start(begin);\n-    if (start < begin) {\n-      start += oop(start)->size();\n-    }\n-    assert(begin <= start,\n-           \"object address \" PTR_FORMAT \" must be larger or equal to block address at \" PTR_FORMAT,\n-           p2i(start), p2i(begin));\n-    for (HeapWord* p = start; p < end; p += oop(p)->size()) {\n-      cl->do_object(oop(p));\n-    }\n+         \"Block size not a multiple of start_array block\");\n+\n+  MutableSpace *space = object_space();\n+\n+  HeapWord* begin = space->bottom() + block_index * block_word_size;\n+  HeapWord* end = MIN2(space->top(), begin + block_word_size);\n+\n+  if (!start_array()->object_starts_in_range(begin, end)) {\n+    return;\n+  }\n+\n+  \/\/ Get object starting at or reaching into this block.\n+  HeapWord* start = start_array()->object_start(begin);\n+  if (start < begin) {\n+    start += oop(start)->size();\n+  }\n+  assert(start >= begin,\n+         \"Object address\" PTR_FORMAT \" must be larger or equal to block address at \" PTR_FORMAT,\n+         p2i(start), p2i(begin));\n+  \/\/ Iterate all objects until the end.\n+  for (HeapWord* p = start; p < end; p += oop(p)->size()) {\n+    cl->do_object(oop(p));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -168,5 +168,8 @@\n-  size_t iterable_blocks() {\n-    return (object_space()->used_in_bytes() + IterateBlockSize - 1) \/ IterateBlockSize;\n-  }\n-  \/\/ Iterate block with given block_index\n-  void block_iterate(ObjectClosure* cl, size_t block_index);\n+\n+  \/\/ Number of blocks to be iterated over in the used part of old gen.\n+  size_t num_iterable_blocks() const;\n+  \/\/ Iterate the objects starting in block block_index within [bottom, top) of the\n+  \/\/ old gen. The object just reaching into this block is not iterated over.\n+  \/\/ A block is an evenly sized non-overlapping part of the old gen of\n+  \/\/ IterateBlockSize bytes.\n+  void object_iterate_block(ObjectClosure* cl, size_t block_index);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"}]}