{"files":[{"patch":"@@ -543,1 +543,0 @@\n-                                                   uint worker_id,\n@@ -545,1 +544,1 @@\n-  uint block_index;\n+  int block_index;\n@@ -548,1 +547,1 @@\n-    if (block_index == HeapBlockClaimer::eden_index) {\n+    if (block_index == HeapBlockClaimer::EdenIndex) {\n@@ -550,1 +549,1 @@\n-    } else if (block_index == HeapBlockClaimer::survivor_index) {\n+    } else if (block_index == HeapBlockClaimer::SurvivorIndex) {\n@@ -554,2 +553,1 @@\n-      uint index = block_index - HeapBlockClaimer::num_inseparable_spaces;\n-      old_gen()->block_iterate(cl, index);\n+      old_gen()->block_iterate(cl, block_index);\n@@ -560,18 +558,1 @@\n-HeapBlockClaimer::HeapBlockClaimer(uint n_workers) :\n-    _n_workers(n_workers), _n_blocks(0), _claims(NULL) {\n-  assert(n_workers > 0, \"Need at least one worker.\");\n-  size_t old_gen_used = ParallelScavengeHeap::heap()->old_gen()->used_in_bytes();\n-  size_t block_size = ParallelScavengeHeap::heap()->old_gen()->iterate_block_size();\n-  uint n_blocks_in_old = old_gen_used \/ block_size + 1;\n-  _n_blocks = n_blocks_in_old + num_inseparable_spaces;\n-  _unclaimed_index = 0;\n-  uint* new_claims = NEW_C_HEAP_ARRAY(uint, _n_blocks, mtGC);\n-  memset(new_claims, Unclaimed, sizeof(*_claims) * _n_blocks);\n-  _claims = new_claims;\n-}\n-\n-HeapBlockClaimer::~HeapBlockClaimer() {\n-   FREE_C_HEAP_ARRAY(uint, _claims);\n-}\n-\n-bool HeapBlockClaimer::claim_and_get_block(uint* block_index) {\n+bool HeapBlockClaimer::claim_and_get_block(int* block_index) {\n@@ -579,12 +560,4 @@\n-  uint next_index = Atomic::load(&_unclaimed_index);\n-  while (true) {\n-    if (next_index >= _n_blocks) {\n-      return false;\n-    }\n-    uint old_val = Atomic::cmpxchg(&_claims[next_index], Unclaimed, Claimed);\n-    if (old_val == Unclaimed) {\n-      *block_index = next_index;\n-      Atomic::inc(&_unclaimed_index);\n-      return true;\n-    }\n-    next_index = Atomic::load(&_unclaimed_index);\n+  *block_index = Atomic::fetch_and_add(&_claimed_index, 1);\n+  int itrable_blocks = ParallelScavengeHeap::heap()->old_gen()->iterable_blocks();\n+  if (*block_index >= itrable_blocks) {\n+    return false;\n@@ -592,0 +565,1 @@\n+  return true;\n@@ -604,1 +578,1 @@\n-      _claimer(thread_num == 0 ? ParallelScavengeHeap::heap()->workers().active_workers() : thread_num) {}\n+      _claimer() {}\n@@ -607,1 +581,1 @@\n-    _heap->object_iterate_parallel(cl, worker_id, &_claimer);\n+    _heap->object_iterate_parallel(cl, &_claimer);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":12,"deletions":38,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapBlockClaimer* claimer);\n+  void object_iterate_parallel(ObjectClosure* cl, HeapBlockClaimer* claimer);\n@@ -297,1 +297,1 @@\n-\/\/ The eden, survivor spaces are treated as single blocks as it is hard to divide\n+\/\/ The eden and survivor spaces are treated as single blocks as it is hard to divide\n@@ -301,12 +301,3 @@\n-  uint           _n_workers;\n-  uint           _n_blocks;\n-  uint           _unclaimed_index;\n-  volatile uint* _claims;\n-\n-  static const uint Unclaimed = 0;\n-  static const uint Claimed   = 1;\n-\n-  public:\n-  HeapBlockClaimer(uint n_workers);\n-  ~HeapBlockClaimer();\n-\n+  int _claimed_index;\n+ public:\n+  HeapBlockClaimer() : _claimed_index(EdenIndex) { }\n@@ -314,5 +305,3 @@\n-  bool claim_and_get_block(uint* block_index);\n-\n-  static const uint eden_index = 0;\n-  static const uint survivor_index = 1;\n-  static const uint num_inseparable_spaces = 2;\n+  bool claim_and_get_block(int* block_index);\n+  static const int EdenIndex = -2;\n+  static const int SurvivorIndex = -1;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-  _max_gen_size(max_size),\n-  _iterate_block_size(1024 * 1024) \/\/ 1M (HeapWord)\n+  _max_gen_size(max_size)\n@@ -177,1 +176,1 @@\n- * bottom + block_index  * _iterate_block_size.\n+ * bottom + block_index  * (_iterate_block_size \/ HeapWordSize).\n@@ -193,1 +192,2 @@\n-  HeapWord* begin = bottom + block_index * _iterate_block_size;\n+  size_t block_word_size = _iterate_block_size \/ HeapWordSize;\n+  HeapWord* begin = bottom + block_index * block_word_size;\n@@ -195,1 +195,1 @@\n-  assert((_iterate_block_size % (ObjectStartArray::block_size)) == 0,\n+  assert((block_word_size % (ObjectStartArray::block_size)) == 0,\n@@ -199,2 +199,2 @@\n-  HeapWord* end = MIN2(top, begin + _iterate_block_size);\n-  \/\/ There can be no object between begin and end.\n+  HeapWord* end = MIN2(top, begin + block_word_size);\n+  \/\/ Only iterate if there are objects between begin and end.\n@@ -202,4 +202,4 @@\n-    \/\/ There are objects in the range. Find the object of begin address.\n-    \/\/ Note that object_start() can return the last object in previous block,\n-    \/\/ and the object is processed by other worker. Here only focus objects that\n-    \/\/ fall into the current block.\n+    \/\/ Process objects in the range, start from finding object at the begining\n+    \/\/ address. Note that object_start() can return the last object in previous\n+    \/\/ block, and that object is processed by other worker scanning that block.\n+    \/\/ So here only focus on objects that fall into the current block.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  const size_t _iterate_block_size;\n+  static const size_t _iterate_block_size = 1024 * 1024;\n@@ -129,1 +129,0 @@\n-  size_t iterate_block_size() const { return _iterate_block_size; }\n@@ -169,0 +168,3 @@\n+  uint iterable_blocks() {\n+    return (object_space()->used_in_bytes() + _iterate_block_size -1) \/ _iterate_block_size;\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}