{"files":[{"patch":"@@ -544,19 +544,10 @@\n-                                                   uint thread_num) {\n-  \/\/ It is hard to divide space in youngGen for parallel processing because it is\n-  \/\/ hard to get valid object for any given address.\n-  \/\/ So use 1 thread to process 1 space in Young Generation (eden, from\/to).\n-  assert(worker_id < thread_num,\n-         \"worker (%d) must not exceed total thread number (%d)\", worker_id, thread_num);\n-  if (thread_num <= 1) {\n-    \/\/ Work serially as less than 1 workers\n-    this->object_iterate(cl);\n-  } else if (thread_num == 2) {\n-    \/\/ 2 workers, all workers for all generations\n-    \/\/ YoungGen internally handle the logic of assigning worker to seperate space\n-    young_gen()->object_iterate_parallel(cl, worker_id, thread_num);\n-    old_gen()->object_iterate_parallel(cl, worker_id, thread_num);\n-  } else {\n-    \/\/ More than 2 workers.\n-    \/\/ The first 2 threads (worker 0 and worker 1) for youngGen and others for oldGen\n-    if (worker_id <= 1) {\n-      young_gen()->object_iterate_parallel(cl, worker_id, thread_num);\n+                                                   HeapBlockClaimer* claimer) {\n+\n+  uint block_index;\n+  \/\/ iterate until all blocks are claimed\n+  while (claimer->claim_and_get_block(&block_index)) {\n+    if (block_index == HeapBlockClaimer::eden_index) {\n+      young_gen()->eden_space()->object_iterate(cl);\n+    } else if (block_index == HeapBlockClaimer::survivor_index) {\n+      young_gen()->from_space()->object_iterate(cl);\n+      young_gen()->to_space()->object_iterate(cl);\n@@ -564,1 +555,40 @@\n-      old_gen()->object_iterate_parallel(cl, worker_id, thread_num);\n+      uint index = block_index - HeapBlockClaimer::num_inseparable_spaces;\n+      old_gen()->block_iterate(cl, index);\n+    }\n+  }\n+}\n+\n+HeapBlockClaimer::HeapBlockClaimer(uint n_workers) :\n+    _n_workers(n_workers), _n_blocks(0), _claims(NULL) {\n+  assert(n_workers > 0, \"Need at least one worker.\");\n+  size_t old_gen_used = ParallelScavengeHeap::heap()->old_gen()->used_in_bytes();\n+  size_t block_size = ParallelScavengeHeap::heap()->old_gen()->iterate_block_size();\n+  uint n_blocks_in_old = old_gen_used \/ block_size + 1;\n+  _n_blocks = n_blocks_in_old + num_inseparable_spaces;\n+  _unclaimed_index = 0;\n+  uint* new_claims = NEW_C_HEAP_ARRAY(uint, _n_blocks, mtGC);\n+  memset(new_claims, Unclaimed, sizeof(*_claims) * _n_blocks);\n+  _claims = new_claims;\n+}\n+\n+HeapBlockClaimer::~HeapBlockClaimer() {\n+   FREE_C_HEAP_ARRAY(uint, _claims);\n+}\n+\n+bool HeapBlockClaimer::is_block_claimed(uint block_index) const {\n+  assert(block_index < _n_blocks, \"Invalid index.\");\n+  return _claims[block_index] == Claimed;\n+}\n+\/\/ is_region_claimed\n+bool HeapBlockClaimer::claim_and_get_block(uint* block_index) {\n+  assert(block_index != NULL, \"Invalid index pointer\");\n+  uint next_index = Atomic::load(&_unclaimed_index);\n+  while (true) {\n+    if (next_index >= _n_blocks) {\n+      return false;\n+    }\n+    uint old_val = Atomic::cmpxchg(&_claims[next_index], Unclaimed, Claimed);\n+    if (old_val == Unclaimed) {\n+      *block_index = next_index;\n+      Atomic::inc(&_unclaimed_index);\n+      return true;\n@@ -566,0 +596,1 @@\n+    next_index = Atomic::load(&_unclaimed_index);\n@@ -573,0 +604,1 @@\n+  HeapBlockClaimer      _claimer;\n@@ -577,1 +609,2 @@\n-      _heap(ParallelScavengeHeap::heap()) {}\n+      _heap(ParallelScavengeHeap::heap()),\n+      _claimer(thread_num == 0 ? ParallelScavengeHeap::heap()->workers().active_workers() : thread_num) {}\n@@ -580,1 +613,1 @@\n-    _heap->object_iterate_parallel(cl, worker_id, _thread_num);\n+    _heap->object_iterate_parallel(cl, worker_id, &_claimer);\n@@ -587,1 +620,1 @@\n-\n+\/\/ heapwordsize\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":56,"deletions":23,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class HeapBlockClaimer;\n@@ -56,0 +57,1 @@\n+  friend class HeapBlockClaimer;\n@@ -212,1 +214,1 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, uint thread_num);\n+  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapBlockClaimer* claimer);\n@@ -293,0 +295,35 @@\n+\/\/ The HeapBlockClaimer is used during parallel iteration over heap,\n+\/\/ allowing workers to claim heap blocks, gaining exclusive rights to these blocks.\n+\/\/ The eden, survivor spaces are treated as single blocks as it is hard to divide\n+\/\/ these spaces.\n+\/\/ The old spaces are divided into several blocks based on iteration threads number.\n+class HeapBlockClaimer : public StackObj {\n+  uint           _n_workers;\n+  uint           _n_blocks;\n+  uint           _unclaimed_index;\n+  volatile uint* _claims;\n+\n+  static const uint Unclaimed = 0;\n+  static const uint Claimed   = 1;\n+\n+  public:\n+  HeapBlockClaimer(uint n_workers);\n+  ~HeapBlockClaimer();\n+\n+  inline uint n_blocks() const {\n+    return _n_blocks;\n+  }\n+\n+  \/\/ Return a start offset given a worker id.\n+  uint offset_for_worker(uint worker_id) const;\n+\n+  \/\/ Check if block has been claimed with this Claimer.\n+  bool is_block_claimed(uint block_index) const;\n+\n+  bool claim_and_get_block(uint* block_index);\n+\n+  static const uint eden_index = 0;\n+  static const uint survivor_index = 1;\n+  static const uint num_inseparable_spaces = 2;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-  _max_gen_size(max_size)\n+  _max_gen_size(max_size),\n+  _iterate_block_size(1024 * 1024)\n@@ -174,43 +175,3 @@\n-void PSOldGen::object_iterate_parallel(ObjectClosure* cl,\n-                                       uint worker_id,\n-                                       uint thread_num) {\n-  if (thread_num <= 1) {\n-    \/\/ Only 1 thread, work serially for whole space\n-    object_space()->object_iterate(cl);\n-  } else if (thread_num == 2) {\n-    \/\/ if there are 2 workers, all workers process youngGen and oldGen.\n-    blocks_iterate_parallel(cl, worker_id, thread_num);\n-  } else if (worker_id >=2) {\n-    \/\/ If there are more than 2 workers, let worker 0 and worker 1 process youngGen,\n-    \/\/ and others process oldGen, so all workers can process in parallel.\n-    \/\/ Actually there are thread_num-2 worker for oldGen and worker_id should start\n-    \/\/ from 0 to calculate blocks.\n-    \/\/ See blocks_iterate_parallel for details.\n-    uint worker = worker_id - 2;\n-    uint total_workers = thread_num -2;\n-    blocks_iterate_parallel(cl, worker, total_workers);\n-  }\n-}\n-\n-\/* Divide space into blocks, every worker processes blocks that\n- * begin at worker_id * BLOCK_SIZE + stride, where stride is\n- * constant value calculated as number_thread * BLOCK_SIZE.\n- * example for 4 workers:\n- *      +========================+\n- *      |    BLOCK 0 <worker0>   |  -----------------------\n- *      +------------------------+           ^\n- *      |    BLOCK 1 <worker1>   |           |\n- *      +------------------------+           |\n- *      |    BLOCK 2 <worker2>   |  BLOCKSIZE * number_thread\n- *      +------------------------+           |\n- *      |    BLOCK 3 <worker4>   |           |\n- *      +========================+           v\n- *      |    BLOCK 5 <worker0>   |  -----------------------\n- *      +------------------------+\n- *      |    BLOCK 6 <worker1>   |\n- *      +------------------------+\n- *      |    BLOCK 7 <worker2>   |\n- *      +------------------------+\n- *      |    BLOCK 8 <worker4>   |\n- *      +========================+\n- * The worker0 first processes BLOCK 0 and then BLOCK 5.\n+\/*\n+ * Divide space into blocks, processes block begins at\n+ * bottom + block_index  * _iterate_block_size.\n@@ -223,3 +184,3 @@\n- * - If there is an object that cross blocks, it is\n- * processed by the worker that the object start address\n- * locates in the related block.\n+ * - If there is an object that crosses blocks, it is\n+ * processed by the worker that owns the block within\n+ * which the object starts.\n@@ -228,4 +189,1 @@\n-void PSOldGen::blocks_iterate_parallel(ObjectClosure* cl,\n-                                       uint worker_id,\n-                                       uint thread_num) {\n-  const int BLOCK_SIZE = 64 * 1024; \/\/ 64 KB\n+void PSOldGen::block_iterate(ObjectClosure* cl, uint block_index) {\n@@ -235,24 +193,22 @@\n-  HeapWord* begin = bottom + worker_id * BLOCK_SIZE;\n-  uint stride = thread_num * BLOCK_SIZE;\n-\n-  while (begin < top) {\n-    \/\/ iterate objects in block.\n-    HeapWord* end = MIN2(top, begin + BLOCK_SIZE);\n-    \/\/ There can be no object between begin and end.\n-    if (start_array()->object_starts_in_range(begin, end)) {\n-      \/\/ There is objects in the range. Find the object of begin address.\n-      \/\/ Note that object_start() can reture the last object in previous block,\n-      \/\/ and the object is processed by other worker, here only focus objects that\n-      \/\/ fall into the current block.\n-      HeapWord* start = start_array()->object_start(begin);\n-      if (start < begin) {\n-        start += oop(start)->size();\n-      }\n-      assert(begin <= start && start < end,\n-             \"object %p must in the range of [%p, %p)\\n\", start, begin, end);\n-      \/\/ iterate objects\n-      HeapWord* p = start;\n-      while (p < end) {\n-        cl->do_object(oop(p));\n-        p += oop(p)->size();\n-      }\n+  HeapWord* begin = bottom + block_index * _iterate_block_size;\n+\n+  assert((_iterate_block_size % (ObjectStartArray::block_size)) == 0,\n+         \"BLOCK SIZE not a multiple of start_array block\");\n+\n+  \/\/ iterate objects in block.\n+  HeapWord* end = MIN2(top, begin + _iterate_block_size);\n+  \/\/ There can be no object between begin and end.\n+  if (start_array()->object_starts_in_range(begin, end)) {\n+    \/\/ There are objects in the range. Find the object of begin address.\n+    \/\/ Note that object_start() can return the last object in previous block,\n+    \/\/ and the object is processed by other worker. Here only focus objects that\n+    \/\/ fall into the current block.\n+    HeapWord* start = start_array()->object_start(begin);\n+    if (start < begin) {\n+      start += oop(start)->size();\n+    }\n+    assert(begin <= start && start < end,\n+           \"object %p must in the range of [%p, %p)\\n\", start, begin, end);\n+    \/\/ iterate objects\n+    for (HeapWord* p = start; p < end; p += oop(p)->size()) {\n+      cl->do_object(oop(p));\n@@ -260,1 +216,0 @@\n-    begin += stride;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":31,"deletions":76,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  \/\/ Block size for parallel iteration\n+  const size_t _iterate_block_size;\n+\n@@ -126,0 +129,1 @@\n+  size_t iterate_block_size() const { return _iterate_block_size; }\n@@ -165,2 +169,3 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, uint thread_num);\n-  void blocks_iterate_parallel(ObjectClosure* cl, uint worker_id, uint worker_num);\n+  \/\/ Iterate block with given block_index\n+  void block_iterate(ObjectClosure* cl, uint block_index);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -706,22 +706,0 @@\n-\/\/ It is hard to identify an object with given address in youngGen, so process every space\n-\/\/ seperately with different worker, and one worker for one space\n-void PSYoungGen::object_iterate_parallel(ObjectClosure* blk,\n-                                         uint worker_id,\n-                                         uint thread_num) {\n-  if (thread_num <=1) {\n-    \/\/ only one worker, iterate serially\n-    object_iterate(blk);\n-  } else {\n-    if (worker_id == 0) {\n-      \/\/ worker 0 process eden serially\n-      eden_space()->object_iterate(blk);\n-    } else if (worker_id == 1) {\n-      \/\/ worker 1 process from space and to space serially\n-      from_space()->object_iterate(blk);\n-      to_space()->object_iterate(blk);\n-    } else {\n-      \/\/ nothing to do. leave all other workers for oldGen.\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -143,3 +143,0 @@\n-  void object_iterate_parallel(ObjectClosure* blk,\n-                               uint worker_id,\n-                               uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}