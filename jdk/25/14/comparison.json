{"files":[{"patch":"@@ -542,0 +542,65 @@\n+\/\/ The HeapBlockClaimer is used during parallel iteration over the heap,\n+\/\/ allowing workers to claim heap areas (\"blocks\"), gaining exclusive rights to these.\n+\/\/ The eden and survivor spaces are treated as single blocks as it is hard to divide\n+\/\/ these spaces.\n+\/\/ The old space is divided into fixed-size blocks.\n+class HeapBlockClaimer : public StackObj {\n+  size_t _claimed_index;\n+\n+public:\n+  static const size_t InvalidIndex = (size_t)SIZE_MAX;\n+  static const size_t EdenIndex = 0;\n+  static const size_t SurvivorIndex = 1;\n+  static const size_t NumNonOldGenClaims = 2;\n+\n+  HeapBlockClaimer() : _claimed_index(EdenIndex) { }\n+  \/\/ Claim the block and get the block index.\n+  size_t claim_and_get_block() {\n+    size_t block_index;\n+    block_index = Atomic::fetch_and_add(&_claimed_index, 1u);\n+\n+    PSOldGen* old_gen = ParallelScavengeHeap::heap()->old_gen();\n+    size_t num_claims = old_gen->num_iterable_blocks() + NumNonOldGenClaims;\n+\n+    return block_index < num_claims ? block_index : InvalidIndex;\n+  }\n+};\n+\n+void ParallelScavengeHeap::object_iterate_parallel(ObjectClosure* cl,\n+                                                   HeapBlockClaimer* claimer) {\n+  size_t block_index = claimer->claim_and_get_block();\n+  \/\/ Iterate until all blocks are claimed\n+  if (block_index == HeapBlockClaimer::EdenIndex) {\n+    young_gen()->eden_space()->object_iterate(cl);\n+    block_index = claimer->claim_and_get_block();\n+  }\n+  if (block_index == HeapBlockClaimer::SurvivorIndex) {\n+    young_gen()->from_space()->object_iterate(cl);\n+    young_gen()->to_space()->object_iterate(cl);\n+    block_index = claimer->claim_and_get_block();\n+  }\n+  while (block_index != HeapBlockClaimer::InvalidIndex) {\n+    old_gen()->object_iterate_block(cl, block_index - HeapBlockClaimer::NumNonOldGenClaims);\n+    block_index = claimer->claim_and_get_block();\n+  }\n+}\n+\n+class PSScavengeParallelObjectIterator : public ParallelObjectIterator {\n+private:\n+  ParallelScavengeHeap*  _heap;\n+  HeapBlockClaimer      _claimer;\n+\n+public:\n+  PSScavengeParallelObjectIterator() :\n+      _heap(ParallelScavengeHeap::heap()),\n+      _claimer() {}\n+\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) {\n+    _heap->object_iterate_parallel(cl, &_claimer);\n+  }\n+};\n+\n+ParallelObjectIterator* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n+  return new PSScavengeParallelObjectIterator();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class HeapBlockClaimer;\n@@ -210,0 +211,2 @@\n+  void object_iterate_parallel(ObjectClosure* cl, HeapBlockClaimer* claimer);\n+  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,0 +176,32 @@\n+size_t PSOldGen::num_iterable_blocks() const {\n+  return (object_space()->used_in_bytes() + IterateBlockSize - 1) \/ IterateBlockSize;\n+}\n+\n+void PSOldGen::object_iterate_block(ObjectClosure* cl, size_t block_index) {\n+  size_t block_word_size = IterateBlockSize \/ HeapWordSize;\n+  assert((block_word_size % (ObjectStartArray::block_size)) == 0,\n+         \"Block size not a multiple of start_array block\");\n+\n+  MutableSpace *space = object_space();\n+\n+  HeapWord* begin = space->bottom() + block_index * block_word_size;\n+  HeapWord* end = MIN2(space->top(), begin + block_word_size);\n+\n+  if (!start_array()->object_starts_in_range(begin, end)) {\n+    return;\n+  }\n+\n+  \/\/ Get object starting at or reaching into this block.\n+  HeapWord* start = start_array()->object_start(begin);\n+  if (start < begin) {\n+    start += oop(start)->size();\n+  }\n+  assert(start >= begin,\n+         \"Object address\" PTR_FORMAT \" must be larger or equal to block address at \" PTR_FORMAT,\n+         p2i(start), p2i(begin));\n+  \/\/ Iterate all objects until the end.\n+  for (HeapWord* p = start; p < end; p += oop(p)->size()) {\n+    cl->do_object(oop(p));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  \/\/ Block size for parallel iteration\n+  static const size_t IterateBlockSize = 1024 * 1024;\n+\n@@ -166,0 +169,8 @@\n+  \/\/ Number of blocks to be iterated over in the used part of old gen.\n+  size_t num_iterable_blocks() const;\n+  \/\/ Iterate the objects starting in block block_index within [bottom, top) of the\n+  \/\/ old gen. The object just reaching into this block is not iterated over.\n+  \/\/ A block is an evenly sized non-overlapping part of the old gen of\n+  \/\/ IterateBlockSize bytes.\n+  void object_iterate_block(ObjectClosure* cl, size_t block_index);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}