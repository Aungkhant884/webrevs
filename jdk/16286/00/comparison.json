{"files":[{"patch":"@@ -52,1 +52,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -563,17 +562,17 @@\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n+            return switch (base) {\n+                case byte[] __ ->\n+                        new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case short[] __ ->\n+                        new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case char[] __ ->\n+                        new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case int[] __ ->\n+                        new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case float[] __ ->\n+                        new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case long[] __ ->\n+                        new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case double[] __ ->\n+                        new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                default -> throw new AssertionError(\"Cannot get here\");\n+            };\n@@ -599,20 +598,0 @@\n-    private static int getScaleFactor(Buffer buffer) {\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n-        } else {\n-            throw new AssertionError(\"Cannot get here\");\n-        }\n-    }\n-\n@@ -656,1 +635,1 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        var dstInfo = Utils.BaseAndScale.of(dstArray);\n@@ -660,2 +639,0 @@\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -667,1 +644,1 @@\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        srcImpl.checkAccess(srcOffset, elementCount * dstInfo.scale(), true);\n@@ -669,1 +646,1 @@\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+        if (dstInfo.scale() == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n@@ -672,1 +649,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale());\n@@ -676,1 +653,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale(), dstInfo.scale());\n@@ -685,1 +662,1 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        var srcInfo = Utils.BaseAndScale.of(srcArray);\n@@ -689,2 +666,0 @@\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -697,2 +672,2 @@\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+        destImpl.checkAccess(dstOffset, elementCount * srcInfo.scale(), false);\n+        if (srcInfo.scale() == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n@@ -700,2 +675,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale());\n@@ -704,2 +679,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale(), srcInfo.scale());\n@@ -747,18 +722,10 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+    private static int getScaleFactor(Buffer buffer) {\n+        return switch (buffer) {\n+            case ByteBuffer   __ -> 0;\n+            case CharBuffer   __ -> 1;\n+            case ShortBuffer  __ -> 1;\n+            case IntBuffer    __ -> 2;\n+            case FloatBuffer  __ -> 2;\n+            case LongBuffer   __ -> 3;\n+            case DoubleBuffer __ -> 3;\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":39,"deletions":72,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -43,1 +42,1 @@\n- * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}, so that each subclass can override the\n+ * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}), so that each subclass can override the\n@@ -52,2 +51,4 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);\n+    \/\/ Constants defining the maximum alignment supported by various kinds of heap arrays.\n+    \/\/ While for most arrays, the maximum alignment is constant (the size, in bytes, of the array elements),\n+    \/\/ note that the alignment of a long[]\/double[] depends on the platform: it's 4-byte on x86, but 8 bytes on x64\n+    \/\/ (as specified by the JAVA_LONG layout constant).\n@@ -55,4 +56,4 @@\n-    private static final long MAX_ALIGN_1 = ValueLayout.JAVA_BYTE.byteAlignment();\n-    private static final long MAX_ALIGN_2 = ValueLayout.JAVA_SHORT.byteAlignment();\n-    private static final long MAX_ALIGN_4 = ValueLayout.JAVA_INT.byteAlignment();\n-    private static final long MAX_ALIGN_8 = ValueLayout.JAVA_LONG.byteAlignment();\n+    private static final long MAX_ALIGN_BYTE_ARRAY = ValueLayout.JAVA_BYTE.byteAlignment();\n+    private static final long MAX_ALIGN_SHORT_ARRAY = ValueLayout.JAVA_SHORT.byteAlignment();\n+    private static final long MAX_ALIGN_INT_ARRAY = ValueLayout.JAVA_INT.byteAlignment();\n+    private static final long MAX_ALIGN_LONG_ARRAY = ValueLayout.JAVA_LONG.byteAlignment();\n@@ -91,1 +92,1 @@\n-        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - Utils.BaseAndScale.BYTE.base(), (int) byteSize(), null);\n@@ -114,1 +115,1 @@\n-            return MAX_ALIGN_1;\n+            return MAX_ALIGN_BYTE_ARRAY;\n@@ -119,1 +120,1 @@\n-            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.BYTE.base();\n@@ -141,1 +142,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -146,1 +147,1 @@\n-            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.CHAR.base();\n@@ -168,1 +169,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -173,1 +174,1 @@\n-            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.SHORT.base();\n@@ -195,1 +196,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -200,1 +201,1 @@\n-            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.INT.base();\n@@ -222,1 +223,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -227,1 +228,1 @@\n-            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.LONG.base();\n@@ -249,1 +250,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -254,1 +255,1 @@\n-            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.FLOAT.base();\n@@ -276,1 +277,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -281,1 +282,1 @@\n-            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.DOUBLE.base();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -44,1 +42,0 @@\n-import java.util.Locale;\n@@ -53,1 +50,1 @@\n- * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)},\n+ * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)}),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    public static final MemorySessionImpl toMemorySession(Arena arena) {\n+    public static MemorySessionImpl toMemorySession(Arena arena) {\n@@ -102,1 +102,1 @@\n-     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * Add a cleanup action. If a failure occurred (because of an add vs. close race), call the cleanup action.\n@@ -105,1 +105,1 @@\n-     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * clean up memory. From the perspective of the client, such a failure would manifest as a factory\n@@ -204,1 +204,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n@@ -214,1 +214,1 @@\n-    public static final void checkValidState(MemorySegment segment) {\n+    public static void checkValidState(MemorySegment segment) {\n@@ -230,1 +230,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-        return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.BYTE.scale();\n+        return new OfByte(Utils.BaseAndScale.BYTE.base(), arr, byteSize, false,\n@@ -94,2 +94,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-        return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.SHORT.scale();\n+        return new OfShort(Utils.BaseAndScale.SHORT.base(), arr, byteSize, false,\n@@ -102,2 +102,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-        return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.INT.scale();\n+        return new OfInt(Utils.BaseAndScale.INT.base(), arr, byteSize, false,\n@@ -110,2 +110,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-        return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.CHAR.scale();\n+        return new OfChar(Utils.BaseAndScale.CHAR.base(), arr, byteSize, false,\n@@ -118,2 +118,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-        return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.FLOAT.scale();\n+        return new OfFloat(Utils.BaseAndScale.FLOAT.base(), arr, byteSize, false,\n@@ -126,2 +126,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-        return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.DOUBLE.scale();\n+        return new OfDouble(Utils.BaseAndScale.DOUBLE.base(), arr, byteSize, false,\n@@ -134,2 +134,2 @@\n-        long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-        return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+        long byteSize = (long)arr.length * Utils.BaseAndScale.LONG.scale();\n+        return new OfLong(Utils.BaseAndScale.LONG.base(), arr, byteSize, false,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-public class StringSupport {\n+public final class StringSupport {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -89,1 +89,1 @@\n-        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -279,0 +280,32 @@\n+    public record BaseAndScale(int base, long scale) {\n+\n+        public static final BaseAndScale BYTE =\n+                new BaseAndScale(Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+        public static final BaseAndScale CHAR =\n+                new BaseAndScale(Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+        public static final BaseAndScale SHORT =\n+                new BaseAndScale(Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+        public static final BaseAndScale INT =\n+                new BaseAndScale(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+        public static final BaseAndScale FLOAT =\n+                new BaseAndScale(Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+        public static final BaseAndScale LONG =\n+                new BaseAndScale(Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);\n+        public static final BaseAndScale DOUBLE =\n+                new BaseAndScale(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+\n+        public static BaseAndScale of(Object array) {\n+            return switch (array) {\n+                case byte[]   __ -> BaseAndScale.BYTE;\n+                case char[]   __ -> BaseAndScale.CHAR;\n+                case short[]  __ -> BaseAndScale.SHORT;\n+                case int[]    __ -> BaseAndScale.INT;\n+                case float[]  __ -> BaseAndScale.FLOAT;\n+                case long[]   __ -> BaseAndScale.LONG;\n+                case double[] __ -> BaseAndScale.DOUBLE;\n+                default -> throw new IllegalArgumentException(\"Not a supported array class: \" + array.getClass().getSimpleName());\n+            };\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    private final MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n+    private MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.ByteOrder;\n@@ -60,1 +59,1 @@\n- * ABI-specific). Note that each argument has it's own recipe, which is indicated by '[number]:' (though, the only\n+ * ABI-specific). Note that each argument has its own recipe, which is indicated by '[number]:' (though, the only\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-            \/\/ adjust return type so it matches the inferred type of the effective\n+            \/\/ adjust return type so that it matches the inferred type of the effective\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SoftReferenceCache<K, V> {\n+final class SoftReferenceCache<K, V> {\n@@ -44,4 +44,1 @@\n-        public Node() {\n-        }\n-\n-        public V get(K key, Function<K, V> valueFactory) {\n+        V get(K key, Function<K, V> valueFactory) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -249,2 +248,2 @@\n-        MacOs, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n-        MacOs, VA       | FW in regs       | CW on the stack                 | CW on the stack\n+        macOS, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n+        macOS, VA       | FW in regs       | CW on the stack                 | CW on the stack\n@@ -260,1 +259,1 @@\n-        MacOs           | CW in regs       | CW on the stack                 | CW on the stack\n+        macOS           | CW in regs       | CW on the stack                 | CW on the stack\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * ABI implementation for macOS on Apple Silicon. Based on AAPCS with\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    private static WindowsAArch64Linker instance;\n@@ -53,2 +52,2 @@\n-        if (instance == null) {\n-            instance = new WindowsAArch64Linker();\n+        class Holder {\n+            private static final WindowsAArch64Linker INSTANCE =  new WindowsAArch64Linker();\n@@ -56,1 +55,1 @@\n-        return instance;\n+        return Holder.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -243,24 +243,19 @@\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> {\n+                MemorySegment addrArg = (MemorySegment) arg;\n+                acquireCallback.accept(addrArg);\n+                argSeg.set(al, 0, addrArg);\n+            }\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT: return FLOAT_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.FLOAT   -> FLOAT_REG_SIZE;\n@@ -59,3 +59,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/PPC64Architecture.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.abi.riscv64.linux.TypeClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -48,1 +47,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -153,1 +151,1 @@\n-        \/\/ Aggregates or scalars passed on the stack are aligned to the greater of\n+        \/\/ Aggregates or scalars passed on the stack are aligned to the greatest of\n@@ -256,2 +254,2 @@\n-    static class UnboxBindingCalculator extends BindingCalculator {\n-        boolean forArguments;\n+    static final class UnboxBindingCalculator extends BindingCalculator {\n+        final boolean forArguments;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private static record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n+    private record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n@@ -131,3 +131,1 @@\n-    public static record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) {\n-\n-    }\n+    public record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) { }\n@@ -136,10 +134,16 @@\n-        if (layout instanceof ValueLayout valueLayout) {\n-            TypeClass typeClass = classifyValueType(valueLayout);\n-            return List.of(switch (typeClass) {\n-                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n-                default -> throw new IllegalStateException(\"Should not reach here.\");\n-            });\n-        } else if (layout instanceof GroupLayout groupLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                if (memberLayout instanceof PaddingLayout) {\n+        return switch (layout) {\n+            case ValueLayout valueLayout -> {\n+                TypeClass typeClass = classifyValueType(valueLayout);\n+                yield List.of(switch (typeClass) {\n+                    case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                });\n+            }\n+            case GroupLayout groupLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        offset += memberLayout.byteSize();\n+                        continue;\n+                    }\n+                    fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n@@ -147,1 +151,0 @@\n-                    continue;\n@@ -149,2 +152,1 @@\n-                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n-                offset += memberLayout.byteSize();\n+                yield fields;\n@@ -152,7 +154,8 @@\n-            return fields;\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n-            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n-                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n-                offset += elementLayout.byteSize();\n+            case SequenceLayout sequenceLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+                for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                    fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                    offset += elementLayout.byteSize();\n+                }\n+                yield fields;\n@@ -160,4 +163,2 @@\n-            return fields;\n-        } else {\n-            throw new IllegalStateException(\"Cannot get here: \" + layout);\n-        }\n+            case null, default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -55,5 +55,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER:\n-                return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT:\n-                return FLOAT_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.FLOAT   -> FLOAT_REG_SIZE;\n@@ -61,3 +59,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/S390Architecture.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -49,1 +47,0 @@\n-import java.util.Map;\n@@ -52,1 +49,0 @@\n-import static jdk.internal.foreign.abi.s390.linux.TypeClass.*;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390CallArranger.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,4 +99,1 @@\n-        if (baseArgClass != FLOAT)\n-            return false;\n-\n-        return true;\n+        return baseArgClass == FLOAT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -211,1 +210,1 @@\n-            \/\/ok, let's pass pass on registers\n+            \/\/ok, let's pass on registers\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -211,6 +211,10 @@\n-    private static void groupByEightBytes(MemoryLayout l, long offset, List<ArgumentClassImpl>[] groups) {\n-        if (l instanceof GroupLayout group) {\n-            for (MemoryLayout m : group.memberLayouts()) {\n-                groupByEightBytes(m, offset, groups);\n-                if (group instanceof StructLayout) {\n-                    offset += m.byteSize();\n+    private static void groupByEightBytes(MemoryLayout layout,\n+                                          long offset,\n+                                          List<ArgumentClassImpl>[] groups) {\n+        switch (layout) {\n+            case GroupLayout group -> {\n+                for (MemoryLayout m : group.memberLayouts()) {\n+                    groupByEightBytes(m, offset, groups);\n+                    if (group instanceof StructLayout) {\n+                        offset += m.byteSize();\n+                    }\n@@ -219,7 +223,1 @@\n-        } else if (l instanceof PaddingLayout) {\n-            return;\n-        } else if (l instanceof SequenceLayout seq) {\n-            MemoryLayout elem = seq.elementLayout();\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n-                groupByEightBytes(elem, offset, groups);\n-                offset += elem.byteSize();\n+            case PaddingLayout __ -> {\n@@ -227,5 +225,6 @@\n-        } else if (l instanceof ValueLayout vl) {\n-            List<ArgumentClassImpl> layouts = groups[(int)offset \/ 8];\n-            if (layouts == null) {\n-                layouts = new ArrayList<>();\n-                groups[(int)offset \/ 8] = layouts;\n+            case SequenceLayout seq -> {\n+                MemoryLayout elem = seq.elementLayout();\n+                for (long i = 0; i < seq.elementCount(); i++) {\n+                    groupByEightBytes(elem, offset, groups);\n+                    offset += elem.byteSize();\n+                }\n@@ -233,7 +232,13 @@\n-            \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n-            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n-                    argumentClassFor(vl) :\n-                    ArgumentClassImpl.MEMORY;\n-            layouts.add(argumentClass);\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + l);\n+            case ValueLayout vl -> {\n+                List<ArgumentClassImpl> layouts = groups[(int) offset \/ 8];\n+                if (layouts == null) {\n+                    layouts = new ArrayList<>();\n+                    groups[(int) offset \/ 8] = layouts;\n+                }\n+                \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n+                ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                        argumentClassFor(vl) :\n+                        ArgumentClassImpl.MEMORY;\n+                layouts.add(argumentClass);\n+            }\n+            case null, default -> throw new IllegalStateException(\"Unexpected layout: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":30,"deletions":25,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n+        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but, they act just\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-public sealed abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n+abstract sealed class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    abstract sealed static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+    abstract static sealed class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}