{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2067,1 +2067,1 @@\n-template<class T>\n+template<bool CONCURRENT>\n@@ -2070,1 +2070,0 @@\n-  T cl;\n@@ -2073,1 +2072,0 @@\n-  bool _concurrent;\n@@ -2075,1 +2073,1 @@\n-  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :\n+  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions) :\n@@ -2077,1 +2075,0 @@\n-    cl(T()),\n@@ -2079,2 +2076,1 @@\n-    _regions(regions),\n-    _concurrent(concurrent) {\n+    _regions(regions) {\n@@ -2084,1 +2080,1 @@\n-    if (_concurrent) {\n+    if (CONCURRENT) {\n@@ -2087,1 +2083,1 @@\n-      do_work();\n+      do_work<ShenandoahUpdateRefsConcClosure>();\n@@ -2090,1 +2086,1 @@\n-      do_work();\n+      do_work<ShenandoahUpdateRefsSTWClosure>();\n@@ -2095,0 +2091,1 @@\n+  template<class T>\n@@ -2096,0 +2093,1 @@\n+    T cl;\n@@ -2107,1 +2105,1 @@\n-      if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      if (_heap->check_cancelled_gc_and_yield(CONCURRENT)) {\n@@ -2118,2 +2116,7 @@\n-  ShenandoahUpdateHeapRefsTask<ShenandoahUpdateHeapRefsClosure> task(&_update_refs_iterator, concurrent);\n-  workers()->run_task(&task);\n+  if (concurrent) {\n+    ShenandoahUpdateHeapRefsTask<true> task(&_update_refs_iterator);\n+    workers()->run_task(&task);\n+  } else {\n+    ShenandoahUpdateHeapRefsTask<false> task(&_update_refs_iterator);\n+    workers()->run_task(&task);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-  inline oop evac_update_with_forwarded(T* p);\n+  inline void conc_update_with_forwarded(T* p);\n@@ -625,4 +625,1 @@\n-  inline oop maybe_update_with_forwarded(T* p);\n-\n-  template <class T>\n-  inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);\n+  inline void update_with_forwarded(T* p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,0 +96,9 @@\n+template <class T>\n+inline void ShenandoahHeap::update_with_forwarded(T* p) {\n+  T o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n+    update_with_forwarded_not_null(p, obj);\n+  }\n+}\n+\n@@ -103,5 +112,1 @@\n-#ifdef ASSERT\n-  else {\n-    shenandoah_assert_not_forwarded(p, obj);\n-  }\n-#endif\n+  shenandoah_assert_not_forwarded(p, obj);\n@@ -112,1 +117,1 @@\n-inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {\n+inline void ShenandoahHeap::conc_update_with_forwarded(T* p) {\n@@ -116,22 +121,17 @@\n-    return maybe_update_with_forwarded_not_null(p, obj);\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-template <class T>\n-inline oop ShenandoahHeap::evac_update_with_forwarded(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop heap_oop = CompressedOops::decode_not_null(o);\n-    if (in_collection_set(heap_oop)) {\n-      oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-      if (forwarded_oop == heap_oop) {\n-        forwarded_oop = evacuate_object(heap_oop, Thread::current());\n-      }\n-      oop prev = cas_oop(forwarded_oop, p, heap_oop);\n-      if (prev == heap_oop) {\n-        return forwarded_oop;\n-      } else {\n-        return NULL;\n-      }\n+    if (in_collection_set(obj)) {\n+      \/\/ Corner case: when evacuation fails, there are objects in collection\n+      \/\/ set that are not really forwarded. We can still go and try CAS-update them\n+      \/\/ (uselessly) to simplify the common path.\n+      shenandoah_assert_forwarded_except(p, obj, cancelled_gc());\n+      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      shenandoah_assert_not_in_cset_except(p, fwd, cancelled_gc());\n+\n+      \/\/ Sanity check: we should not be updating the cset regions themselves,\n+      \/\/ unless we are recovering from the evacuation failure.\n+      shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || cancelled_gc());\n+\n+      \/\/ Either we succeed in updating the reference, or something else gets in our way.\n+      \/\/ We don't care if that is another concurrent GC update, or another mutator update.\n+      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n+      oop witness = cas_oop(fwd, p, obj);\n+      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n@@ -139,3 +139,0 @@\n-    return heap_oop;\n-  } else {\n-    return NULL;\n@@ -163,43 +160,0 @@\n-template <class T>\n-inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {\n-  shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-  shenandoah_assert_correct(p, heap_oop);\n-\n-  if (in_collection_set(heap_oop)) {\n-    oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-    if (forwarded_oop == heap_oop) {\n-      \/\/ E.g. during evacuation.\n-      return forwarded_oop;\n-    }\n-\n-    shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-    shenandoah_assert_not_forwarded(p, forwarded_oop);\n-    shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());\n-\n-    \/\/ If this fails, another thread wrote to p before us, it will be logged in SATB and the\n-    \/\/ reference be updated later.\n-    oop witness = cas_oop(forwarded_oop, p, heap_oop);\n-\n-    if (witness != heap_oop) {\n-      \/\/ CAS failed, someone had beat us to it. Normally, we would return the failure witness,\n-      \/\/ because that would be the proper write of to-space object, enforced by strong barriers.\n-      \/\/ However, there is a corner case with arraycopy. It can happen that a Java thread\n-      \/\/ beats us with an arraycopy, which first copies the array, which potentially contains\n-      \/\/ from-space refs, and only afterwards updates all from-space refs to to-space refs,\n-      \/\/ which leaves a short window where the new array elements can be from-space.\n-      \/\/ In this case, we can just resolve the result again. As we resolve, we need to consider\n-      \/\/ the contended write might have been NULL.\n-      oop result = ShenandoahBarrierSet::resolve_forwarded(witness);\n-      shenandoah_assert_not_forwarded_except(p, result, (result == NULL));\n-      shenandoah_assert_not_in_cset_except(p, result, (result == NULL) || cancelled_gc());\n-      return result;\n-    } else {\n-      \/\/ Success! We have updated with known to-space copy. We have already asserted it is sane.\n-      return forwarded_oop;\n-    }\n-  } else {\n-    shenandoah_assert_not_forwarded(p, heap_oop);\n-    return heap_oop;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":28,"deletions":74,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -43,1 +44,1 @@\n-  ShenandoahMark::mark_through_ref<T, NONE, NO_DEDUP>(p, _heap, _queue, _mark_context, false);\n+  ShenandoahMark::mark_through_ref<T, NO_UPDATE, NO_DEDUP>(p, _heap, _queue, _mark_context, false);\n@@ -238,1 +239,1 @@\n-      ShenandoahMark::mark_through_ref<oop, NONE, STRING_DEDUP>(p, _heap, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, NO_UPDATE, STRING_DEDUP>(p, _heap, _queue, _mark_context, false);\n@@ -249,11 +250,10 @@\n-    case NONE:\n-      break;\n-    case SIMPLE:\n-      \/\/ We piggy-back reference updating to the marking tasks.\n-      obj = heap->update_with_forwarded_not_null(p, obj);\n-      break;\n-    case CONCURRENT:\n-      obj = heap->maybe_update_with_forwarded_not_null(p, obj);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n+      case NO_UPDATE:\n+        shenandoah_assert_not_forwarded(p, obj);\n+        break;\n+      case STW_UPDATE:\n+        obj = heap->update_with_forwarded_not_null(p, obj);\n+        break;\n+      case CONC_UPDATE:\n+        fatal(\"Concurrent update is not supported for marking\");\n+      default:\n+        ShouldNotReachHere();\n@@ -262,20 +262,1 @@\n-    \/\/ Note: Only when concurrently updating references can obj be different\n-    \/\/ (that is, really different, not just different from-\/to-space copies of the same)\n-    \/\/ from the one we originally loaded. Mutator thread can beat us by writing something\n-    \/\/ else into the location. In that case, we would mark through that updated value,\n-    \/\/ on the off-chance it is not handled by other means (e.g. via SATB). However,\n-    \/\/ if that write was NULL, we don't need to do anything else.\n-    if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {\n-      shenandoah_assert_not_forwarded(p, obj);\n-      shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n-\n-      bool skip_live = false;\n-      bool marked;\n-      if (weak) {\n-        marked = mark_context->mark_weak(obj);\n-      } else {\n-        marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n-      }\n-      if (marked) {\n-        bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n-        assert(pushed, \"overflow queue should always succeed pushing\");\n+    shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n@@ -283,5 +264,10 @@\n-        if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n-          assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n-          ShenandoahStringDedup::enqueue_candidate(obj);\n-        }\n-      }\n+    bool skip_live = false;\n+    bool marked;\n+    if (weak) {\n+      marked = mark_context->mark_weak(obj);\n+    } else {\n+      marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n+    }\n+    if (marked) {\n+      bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n+      assert(pushed, \"overflow queue should always succeed pushing\");\n@@ -289,1 +275,4 @@\n-      shenandoah_assert_marked(p, obj);\n+      if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n+        assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n+        ShenandoahStringDedup::enqueue_candidate(obj);\n+      }\n@@ -291,0 +280,2 @@\n+\n+    shenandoah_assert_marked(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":30,"deletions":39,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -36,3 +37,3 @@\n-  NONE,       \/\/ No reference updating\n-  SIMPLE,     \/\/ Reference updating using simple store\n-  CONCURRENT  \/\/ Reference updating using CAS\n+  NO_UPDATE,   \/\/ Skip reference updates\n+  STW_UPDATE,  \/\/ Update references, assuming STW mode (no concurrent mutator updates)\n+  CONC_UPDATE, \/\/ Update references, assuming concurrent mutator updates\n@@ -72,1 +73,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, NO_DEDUP>(p); }\n@@ -75,2 +76,4 @@\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -86,1 +89,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -89,2 +92,4 @@\n-  ShenandoahMarkUpdateRefsDedupClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsDedupClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -100,1 +105,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, NO_DEDUP>(p); }\n@@ -103,2 +108,4 @@\n-  ShenandoahMarkUpdateRefsMetadataClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-    ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsMetadataClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -114,1 +121,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -117,2 +124,4 @@\n-  ShenandoahMarkUpdateRefsMetadataDedupClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsMetadataDedupClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -128,1 +137,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, NO_DEDUP>(p); }\n@@ -142,1 +151,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -156,1 +165,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, NO_DEDUP>(p); }\n@@ -170,1 +179,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -181,1 +190,1 @@\n-class ShenandoahUpdateHeapRefsClosure : public BasicOopIterateClosure {\n+class ShenandoahUpdateRefsSuperClosure : public BasicOopIterateClosure {\n@@ -185,2 +194,26 @@\n-  template <class T>\n-  void do_oop_work(T* p);\n+protected:\n+  template <class T, UpdateRefsMode UPDATE_MODE>\n+  inline void work(T *p);\n+\n+public:\n+  ShenandoahUpdateRefsSuperClosure() :  _heap(ShenandoahHeap::heap()) {}\n+};\n+\n+class ShenandoahUpdateRefsSTWClosure : public ShenandoahUpdateRefsSuperClosure {\n+private:\n+  template<class T>\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE>(p); }\n+\n+public:\n+  ShenandoahUpdateRefsSTWClosure() : ShenandoahUpdateRefsSuperClosure() {\n+    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must only be used at safepoints\");\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+};\n+\n+class ShenandoahUpdateRefsConcClosure : public ShenandoahUpdateRefsSuperClosure {\n+private:\n+  template<class T>\n+  inline void do_oop_work(T* p)     { work<T, CONC_UPDATE>(p); }\n@@ -189,2 +222,1 @@\n-  ShenandoahUpdateHeapRefsClosure() :\n-    _heap(ShenandoahHeap::heap()) {}\n+  ShenandoahUpdateRefsConcClosure() : ShenandoahUpdateRefsSuperClosure() {}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":56,"deletions":24,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -36,3 +36,15 @@\n-template <class T>\n-inline void ShenandoahUpdateHeapRefsClosure::do_oop_work(T* p) {\n-  _heap->maybe_update_with_forwarded(p);\n+template<class T, UpdateRefsMode UPDATE_REFS>\n+inline void ShenandoahUpdateRefsSuperClosure::work(T* p) {\n+  switch (UPDATE_REFS) {\n+    case NO_UPDATE:\n+      fatal(\"Not supported\");\n+      break;\n+    case STW_UPDATE:\n+      _heap->update_with_forwarded(p);\n+      break;\n+    case CONC_UPDATE:\n+      _heap->conc_update_with_forwarded(p);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}