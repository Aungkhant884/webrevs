{"files":[{"patch":"@@ -73,5 +73,1 @@\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    _heap->update_with_forwarded_not_null(p, obj);\n-  }\n+  _heap->update_with_forwarded(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2067,1 +2067,1 @@\n-template<class T>\n+template<bool CONCURRENT>\n@@ -2070,1 +2070,0 @@\n-  T cl;\n@@ -2073,1 +2072,0 @@\n-  bool _concurrent;\n@@ -2075,1 +2073,1 @@\n-  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :\n+  ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions) :\n@@ -2077,1 +2075,0 @@\n-    cl(T()),\n@@ -2079,2 +2076,1 @@\n-    _regions(regions),\n-    _concurrent(concurrent) {\n+    _regions(regions) {\n@@ -2084,1 +2080,1 @@\n-    if (_concurrent) {\n+    if (CONCURRENT) {\n@@ -2087,1 +2083,1 @@\n-      do_work();\n+      do_work<ShenandoahConcUpdateRefsClosure>();\n@@ -2090,1 +2086,1 @@\n-      do_work();\n+      do_work<ShenandoahSTWUpdateRefsClosure>();\n@@ -2095,0 +2091,1 @@\n+  template<class T>\n@@ -2096,0 +2093,1 @@\n+    T cl;\n@@ -2107,1 +2105,1 @@\n-      if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      if (_heap->check_cancelled_gc_and_yield(CONCURRENT)) {\n@@ -2118,2 +2116,7 @@\n-  ShenandoahUpdateHeapRefsTask<ShenandoahUpdateHeapRefsClosure> task(&_update_refs_iterator, concurrent);\n-  workers()->run_task(&task);\n+  if (concurrent) {\n+    ShenandoahUpdateHeapRefsTask<true> task(&_update_refs_iterator);\n+    workers()->run_task(&task);\n+  } else {\n+    ShenandoahUpdateHeapRefsTask<false> task(&_update_refs_iterator);\n+    workers()->run_task(&task);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-  inline oop evac_update_with_forwarded(T* p);\n+  inline void conc_update_with_forwarded(T* p);\n@@ -625,7 +625,1 @@\n-  inline oop maybe_update_with_forwarded(T* p);\n-\n-  template <class T>\n-  inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);\n-\n-  template <class T>\n-  inline oop update_with_forwarded_not_null(T* p, oop obj);\n+  inline void update_with_forwarded(T* p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,16 +97,1 @@\n-inline oop ShenandoahHeap::update_with_forwarded_not_null(T* p, oop obj) {\n-  if (in_collection_set(obj)) {\n-    shenandoah_assert_forwarded_except(p, obj, is_full_gc_in_progress() || cancelled_gc() || is_degenerated_gc_in_progress());\n-    obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n-    RawAccess<IS_NOT_NULL>::oop_store(p, obj);\n-  }\n-#ifdef ASSERT\n-  else {\n-    shenandoah_assert_not_forwarded(p, obj);\n-  }\n-#endif\n-  return obj;\n-}\n-\n-template <class T>\n-inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {\n+inline void ShenandoahHeap::update_with_forwarded(T* p) {\n@@ -116,3 +101,11 @@\n-    return maybe_update_with_forwarded_not_null(p, obj);\n-  } else {\n-    return NULL;\n+    if (in_collection_set(obj)) {\n+      \/\/ Corner case: when evacuation fails, there are objects in collection\n+      \/\/ set that are not really forwarded. We can still go and try and update them\n+      \/\/ (uselessly) to simplify the common path.\n+      shenandoah_assert_forwarded_except(p, obj, cancelled_gc());\n+      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      shenandoah_assert_not_in_cset_except(p, fwd, cancelled_gc());\n+\n+      \/\/ Unconditionally store the update: no concurrent updates expected.\n+      RawAccess<IS_NOT_NULL>::oop_store(p, fwd);\n+    }\n@@ -123,1 +116,1 @@\n-inline oop ShenandoahHeap::evac_update_with_forwarded(T* p) {\n+inline void ShenandoahHeap::conc_update_with_forwarded(T* p) {\n@@ -126,12 +119,18 @@\n-    oop heap_oop = CompressedOops::decode_not_null(o);\n-    if (in_collection_set(heap_oop)) {\n-      oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-      if (forwarded_oop == heap_oop) {\n-        forwarded_oop = evacuate_object(heap_oop, Thread::current());\n-      }\n-      oop prev = cas_oop(forwarded_oop, p, heap_oop);\n-      if (prev == heap_oop) {\n-        return forwarded_oop;\n-      } else {\n-        return NULL;\n-      }\n+    oop obj = CompressedOops::decode_not_null(o);\n+    if (in_collection_set(obj)) {\n+      \/\/ Corner case: when evacuation fails, there are objects in collection\n+      \/\/ set that are not really forwarded. We can still go and try CAS-update them\n+      \/\/ (uselessly) to simplify the common path.\n+      shenandoah_assert_forwarded_except(p, obj, cancelled_gc());\n+      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      shenandoah_assert_not_in_cset_except(p, fwd, cancelled_gc());\n+\n+      \/\/ Sanity check: we should not be updating the cset regions themselves,\n+      \/\/ unless we are recovering from the evacuation failure.\n+      shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || cancelled_gc());\n+\n+      \/\/ Either we succeed in updating the reference, or something else gets in our way.\n+      \/\/ We don't care if that is another concurrent GC update, or another mutator update.\n+      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n+      oop witness = cas_oop(fwd, p, obj);\n+      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n@@ -139,3 +138,0 @@\n-    return heap_oop;\n-  } else {\n-    return NULL;\n@@ -163,43 +159,0 @@\n-template <class T>\n-inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {\n-  shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-  shenandoah_assert_correct(p, heap_oop);\n-\n-  if (in_collection_set(heap_oop)) {\n-    oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-    if (forwarded_oop == heap_oop) {\n-      \/\/ E.g. during evacuation.\n-      return forwarded_oop;\n-    }\n-\n-    shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-    shenandoah_assert_not_forwarded(p, forwarded_oop);\n-    shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());\n-\n-    \/\/ If this fails, another thread wrote to p before us, it will be logged in SATB and the\n-    \/\/ reference be updated later.\n-    oop witness = cas_oop(forwarded_oop, p, heap_oop);\n-\n-    if (witness != heap_oop) {\n-      \/\/ CAS failed, someone had beat us to it. Normally, we would return the failure witness,\n-      \/\/ because that would be the proper write of to-space object, enforced by strong barriers.\n-      \/\/ However, there is a corner case with arraycopy. It can happen that a Java thread\n-      \/\/ beats us with an arraycopy, which first copies the array, which potentially contains\n-      \/\/ from-space refs, and only afterwards updates all from-space refs to to-space refs,\n-      \/\/ which leaves a short window where the new array elements can be from-space.\n-      \/\/ In this case, we can just resolve the result again. As we resolve, we need to consider\n-      \/\/ the contended write might have been NULL.\n-      oop result = ShenandoahBarrierSet::resolve_forwarded(witness);\n-      shenandoah_assert_not_forwarded_except(p, result, (result == NULL));\n-      shenandoah_assert_not_in_cset_except(p, result, (result == NULL) || cancelled_gc());\n-      return result;\n-    } else {\n-      \/\/ Success! We have updated with known to-space copy. We have already asserted it is sane.\n-      return forwarded_oop;\n-    }\n-  } else {\n-    shenandoah_assert_not_forwarded(p, heap_oop);\n-    return heap_oop;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":31,"deletions":78,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-  _heap(ShenandoahHeap::heap()),\n-  _mark_context(_heap->marking_context()),\n+  _mark_context(ShenandoahHeap::heap()->marking_context()),\n@@ -50,2 +49,1 @@\n-  _heap(ShenandoahHeap::heap()),\n-  _mark_context(_heap->marking_context()) {\n+  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-  ShenandoahHeap*           const _heap;\n@@ -64,2 +63,2 @@\n-  template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n-  static inline void mark_through_ref(T* p, ShenandoahHeap* heap, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n+  template<class T, StringDedupMode STRING_DEDUP>\n+  static inline void mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -43,1 +44,1 @@\n-  ShenandoahMark::mark_through_ref<T, NONE, NO_DEDUP>(p, _heap, _queue, _mark_context, false);\n+  ShenandoahMark::mark_through_ref<T, NO_DEDUP>(p, _queue, _mark_context, false);\n@@ -238,1 +239,1 @@\n-      ShenandoahMark::mark_through_ref<oop, NONE, STRING_DEDUP>(p, _heap, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, STRING_DEDUP>(p, _queue, _mark_context, false);\n@@ -243,2 +244,2 @@\n-template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n-inline void ShenandoahMark::mark_through_ref(T *p, ShenandoahHeap* heap, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak) {\n+template<class T, StringDedupMode STRING_DEDUP>\n+inline void ShenandoahMark::mark_through_ref(T* p, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context, bool weak) {\n@@ -248,13 +249,0 @@\n-    switch (UPDATE_REFS) {\n-    case NONE:\n-      break;\n-    case SIMPLE:\n-      \/\/ We piggy-back reference updating to the marking tasks.\n-      obj = heap->update_with_forwarded_not_null(p, obj);\n-      break;\n-    case CONCURRENT:\n-      obj = heap->maybe_update_with_forwarded_not_null(p, obj);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n@@ -262,20 +250,2 @@\n-    \/\/ Note: Only when concurrently updating references can obj be different\n-    \/\/ (that is, really different, not just different from-\/to-space copies of the same)\n-    \/\/ from the one we originally loaded. Mutator thread can beat us by writing something\n-    \/\/ else into the location. In that case, we would mark through that updated value,\n-    \/\/ on the off-chance it is not handled by other means (e.g. via SATB). However,\n-    \/\/ if that write was NULL, we don't need to do anything else.\n-    if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {\n-      shenandoah_assert_not_forwarded(p, obj);\n-      shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n-\n-      bool skip_live = false;\n-      bool marked;\n-      if (weak) {\n-        marked = mark_context->mark_weak(obj);\n-      } else {\n-        marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n-      }\n-      if (marked) {\n-        bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n-        assert(pushed, \"overflow queue should always succeed pushing\");\n+    shenandoah_assert_not_forwarded(p, obj);\n+    shenandoah_assert_not_in_cset_except(p, obj, ShenandoahHeap::heap()->cancelled_gc());\n@@ -283,5 +253,10 @@\n-        if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n-          assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n-          ShenandoahStringDedup::enqueue_candidate(obj);\n-        }\n-      }\n+    bool skip_live = false;\n+    bool marked;\n+    if (weak) {\n+      marked = mark_context->mark_weak(obj);\n+    } else {\n+      marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n+    }\n+    if (marked) {\n+      bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n+      assert(pushed, \"overflow queue should always succeed pushing\");\n@@ -289,1 +264,4 @@\n-      shenandoah_assert_marked(p, obj);\n+      if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n+        assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n+        ShenandoahStringDedup::enqueue_candidate(obj);\n+      }\n@@ -291,0 +269,2 @@\n+\n+    shenandoah_assert_marked(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":23,"deletions":43,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -35,6 +36,0 @@\n-enum UpdateRefsMode {\n-  NONE,       \/\/ No reference updating\n-  SIMPLE,     \/\/ Reference updating using simple store\n-  CONCURRENT  \/\/ Reference updating using CAS\n-};\n-\n@@ -49,1 +44,0 @@\n-  ShenandoahHeap* _heap;\n@@ -54,1 +48,1 @@\n-  template <class T, UpdateRefsMode UPDATE_MODE, StringDedupMode STRING_DEDUP>\n+  template <class T, StringDedupMode STRING_DEDUP>\n@@ -69,1 +63,16 @@\n-class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkRefsSuperClosure {\n+class ShenandoahMarkUpdateRefsSuperClosure : public ShenandoahMarkRefsSuperClosure {\n+protected:\n+  ShenandoahHeap* const _heap;\n+\n+  template <class T, StringDedupMode STRING_DEDUP>\n+  inline void work(T* p);\n+\n+public:\n+  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n+    ShenandoahMarkRefsSuperClosure(q, rp),\n+    _heap(ShenandoahHeap::heap()) {\n+    assert(_heap->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n+};\n+\n+class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n@@ -72,1 +81,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_DEDUP>(p); }\n@@ -76,1 +85,1 @@\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp) {}\n@@ -83,1 +92,1 @@\n-class ShenandoahMarkUpdateRefsDedupClosure : public ShenandoahMarkRefsSuperClosure {\n+class ShenandoahMarkUpdateRefsDedupClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n@@ -86,1 +95,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, ENQUEUE_DEDUP>(p); }\n@@ -90,1 +99,1 @@\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp) {}\n@@ -97,1 +106,1 @@\n-class ShenandoahMarkUpdateRefsMetadataClosure : public ShenandoahMarkRefsSuperClosure {\n+class ShenandoahMarkUpdateRefsMetadataClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n@@ -100,1 +109,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_DEDUP>(p); }\n@@ -104,1 +113,1 @@\n-    ShenandoahMarkRefsSuperClosure(q, rp) {};\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp) {}\n@@ -111,1 +120,1 @@\n-class ShenandoahMarkUpdateRefsMetadataDedupClosure : public ShenandoahMarkRefsSuperClosure {\n+class ShenandoahMarkUpdateRefsMetadataDedupClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n@@ -114,1 +123,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, ENQUEUE_DEDUP>(p); }\n@@ -118,1 +127,1 @@\n-  ShenandoahMarkRefsSuperClosure(q, rp) {};\n+    ShenandoahMarkUpdateRefsSuperClosure(q, rp) {}\n@@ -128,1 +137,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_DEDUP>(p); }\n@@ -142,1 +151,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, ENQUEUE_DEDUP>(p); }\n@@ -156,1 +165,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_DEDUP>(p); }\n@@ -170,1 +179,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, ENQUEUE_DEDUP>(p); }\n@@ -181,2 +190,2 @@\n-class ShenandoahUpdateHeapRefsClosure : public BasicOopIterateClosure {\n-private:\n+class ShenandoahUpdateRefsSuperClosure : public BasicOopIterateClosure {\n+protected:\n@@ -185,2 +194,8 @@\n-  template <class T>\n-  void do_oop_work(T* p);\n+public:\n+  ShenandoahUpdateRefsSuperClosure() :  _heap(ShenandoahHeap::heap()) {}\n+};\n+\n+class ShenandoahSTWUpdateRefsClosure : public ShenandoahUpdateRefsSuperClosure {\n+private:\n+  template<class T>\n+  inline void work(T* p);\n@@ -189,2 +204,3 @@\n-  ShenandoahUpdateHeapRefsClosure() :\n-    _heap(ShenandoahHeap::heap()) {}\n+  ShenandoahSTWUpdateRefsClosure() : ShenandoahUpdateRefsSuperClosure() {\n+    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must only be used at safepoints\");\n+  }\n@@ -192,2 +208,14 @@\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n+class ShenandoahConcUpdateRefsClosure : public ShenandoahUpdateRefsSuperClosure {\n+private:\n+  template<class T>\n+  inline void work(T* p);\n+\n+public:\n+  ShenandoahConcUpdateRefsClosure() : ShenandoahUpdateRefsSuperClosure() {}\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":60,"deletions":32,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-template<class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP>\n-inline void ShenandoahMarkRefsSuperClosure::work(T *p) {\n-  ShenandoahMark::mark_through_ref<T, UPDATE_REFS, STRING_DEDUP>(p, _heap, _queue, _mark_context, _weak);\n+template<class T, StringDedupMode STRING_DEDUP>\n+inline void ShenandoahMarkRefsSuperClosure::work(T* p) {\n+  ShenandoahMark::mark_through_ref<T, STRING_DEDUP>(p, _queue, _mark_context, _weak);\n@@ -36,3 +36,17 @@\n-template <class T>\n-inline void ShenandoahUpdateHeapRefsClosure::do_oop_work(T* p) {\n-  _heap->maybe_update_with_forwarded(p);\n+template<class T, StringDedupMode STRING_DEDUP>\n+inline void ShenandoahMarkUpdateRefsSuperClosure::work(T* p) {\n+  \/\/ Update the location\n+  _heap->update_with_forwarded(p);\n+\n+  \/\/ ...then do the usual thing\n+  ShenandoahMarkRefsSuperClosure::work<T, STRING_DEDUP>(p);\n+}\n+\n+template<class T>\n+inline void ShenandoahSTWUpdateRefsClosure::work(T* p) {\n+  _heap->update_with_forwarded(p);\n+}\n+\n+template<class T>\n+inline void ShenandoahConcUpdateRefsClosure::work(T* p) {\n+  _heap->conc_update_with_forwarded(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}