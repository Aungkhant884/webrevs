{"files":[{"patch":"@@ -622,7 +622,1 @@\n-  inline oop evac_update_with_forwarded(T* p);\n-\n-  template <class T>\n-  inline oop maybe_update_with_forwarded(T* p);\n-\n-  template <class T>\n-  inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);\n+  inline void atomic_update_with_forwarded(T* p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,5 +103,1 @@\n-#ifdef ASSERT\n-  else {\n-    shenandoah_assert_not_forwarded(p, obj);\n-  }\n-#endif\n+  shenandoah_assert_not_forwarded(p, obj);\n@@ -112,1 +108,1 @@\n-inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {\n+inline void ShenandoahHeap::atomic_update_with_forwarded(T* p) {\n@@ -116,22 +112,17 @@\n-    return maybe_update_with_forwarded_not_null(p, obj);\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-template <class T>\n-inline oop ShenandoahHeap::evac_update_with_forwarded(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop heap_oop = CompressedOops::decode_not_null(o);\n-    if (in_collection_set(heap_oop)) {\n-      oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-      if (forwarded_oop == heap_oop) {\n-        forwarded_oop = evacuate_object(heap_oop, Thread::current());\n-      }\n-      oop prev = cas_oop(forwarded_oop, p, heap_oop);\n-      if (prev == heap_oop) {\n-        return forwarded_oop;\n-      } else {\n-        return NULL;\n-      }\n+    if (in_collection_set(obj)) {\n+      \/\/ Corner case: when evacuation fails, there are objects in collection\n+      \/\/ set that are not really forwarded. We can still go and try CAS-update them\n+      \/\/ (uselessly) to simplify the common path.\n+      shenandoah_assert_forwarded_except(p, obj, cancelled_gc());\n+      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      shenandoah_assert_not_in_cset_except(p, fwd, cancelled_gc());\n+\n+      \/\/ Sanity check: we should not be updating the cset regions themselves,\n+      \/\/ unless we are recovering from the evacuation failure.\n+      shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || cancelled_gc());\n+\n+      \/\/ Either we succeed in updating the reference, or something else gets in our way.\n+      \/\/ We don't care if that is another concurrent GC update, or another mutator update.\n+      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n+      oop witness = cas_oop(fwd, p, obj);\n+      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n@@ -139,3 +130,0 @@\n-    return heap_oop;\n-  } else {\n-    return NULL;\n@@ -163,43 +151,0 @@\n-template <class T>\n-inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {\n-  shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-  shenandoah_assert_correct(p, heap_oop);\n-\n-  if (in_collection_set(heap_oop)) {\n-    oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);\n-    if (forwarded_oop == heap_oop) {\n-      \/\/ E.g. during evacuation.\n-      return forwarded_oop;\n-    }\n-\n-    shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());\n-    shenandoah_assert_not_forwarded(p, forwarded_oop);\n-    shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());\n-\n-    \/\/ If this fails, another thread wrote to p before us, it will be logged in SATB and the\n-    \/\/ reference be updated later.\n-    oop witness = cas_oop(forwarded_oop, p, heap_oop);\n-\n-    if (witness != heap_oop) {\n-      \/\/ CAS failed, someone had beat us to it. Normally, we would return the failure witness,\n-      \/\/ because that would be the proper write of to-space object, enforced by strong barriers.\n-      \/\/ However, there is a corner case with arraycopy. It can happen that a Java thread\n-      \/\/ beats us with an arraycopy, which first copies the array, which potentially contains\n-      \/\/ from-space refs, and only afterwards updates all from-space refs to to-space refs,\n-      \/\/ which leaves a short window where the new array elements can be from-space.\n-      \/\/ In this case, we can just resolve the result again. As we resolve, we need to consider\n-      \/\/ the contended write might have been NULL.\n-      oop result = ShenandoahBarrierSet::resolve_forwarded(witness);\n-      shenandoah_assert_not_forwarded_except(p, result, (result == NULL));\n-      shenandoah_assert_not_in_cset_except(p, result, (result == NULL) || cancelled_gc());\n-      return result;\n-    } else {\n-      \/\/ Success! We have updated with known to-space copy. We have already asserted it is sane.\n-      return forwarded_oop;\n-    }\n-  } else {\n-    shenandoah_assert_not_forwarded(p, heap_oop);\n-    return heap_oop;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":19,"deletions":74,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -43,1 +44,1 @@\n-  ShenandoahMark::mark_through_ref<T, NONE, NO_DEDUP>(p, _heap, _queue, _mark_context, false);\n+  ShenandoahMark::mark_through_ref<T, NO_UPDATE, NO_DEDUP>(p, _heap, _queue, _mark_context, false);\n@@ -238,1 +239,1 @@\n-      ShenandoahMark::mark_through_ref<oop, NONE, STRING_DEDUP>(p, _heap, _queue, _mark_context, false);\n+      ShenandoahMark::mark_through_ref<oop, NO_UPDATE, STRING_DEDUP>(p, _heap, _queue, _mark_context, false);\n@@ -249,11 +250,8 @@\n-    case NONE:\n-      break;\n-    case SIMPLE:\n-      \/\/ We piggy-back reference updating to the marking tasks.\n-      obj = heap->update_with_forwarded_not_null(p, obj);\n-      break;\n-    case CONCURRENT:\n-      obj = heap->maybe_update_with_forwarded_not_null(p, obj);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n+      case NO_UPDATE:\n+        shenandoah_assert_not_forwarded(p, obj);\n+        break;\n+      case STW_UPDATE:\n+        obj = heap->update_with_forwarded_not_null(p, obj);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n@@ -262,20 +260,1 @@\n-    \/\/ Note: Only when concurrently updating references can obj be different\n-    \/\/ (that is, really different, not just different from-\/to-space copies of the same)\n-    \/\/ from the one we originally loaded. Mutator thread can beat us by writing something\n-    \/\/ else into the location. In that case, we would mark through that updated value,\n-    \/\/ on the off-chance it is not handled by other means (e.g. via SATB). However,\n-    \/\/ if that write was NULL, we don't need to do anything else.\n-    if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {\n-      shenandoah_assert_not_forwarded(p, obj);\n-      shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n-\n-      bool skip_live = false;\n-      bool marked;\n-      if (weak) {\n-        marked = mark_context->mark_weak(obj);\n-      } else {\n-        marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n-      }\n-      if (marked) {\n-        bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n-        assert(pushed, \"overflow queue should always succeed pushing\");\n+    shenandoah_assert_not_in_cset_except(p, obj, heap->cancelled_gc());\n@@ -283,5 +262,10 @@\n-        if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n-          assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n-          ShenandoahStringDedup::enqueue_candidate(obj);\n-        }\n-      }\n+    bool skip_live = false;\n+    bool marked;\n+    if (weak) {\n+      marked = mark_context->mark_weak(obj);\n+    } else {\n+      marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n+    }\n+    if (marked) {\n+      bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, weak));\n+      assert(pushed, \"overflow queue should always succeed pushing\");\n@@ -289,1 +273,4 @@\n-      shenandoah_assert_marked(p, obj);\n+      if ((STRING_DEDUP == ENQUEUE_DEDUP) && ShenandoahStringDedup::is_candidate(obj)) {\n+        assert(ShenandoahStringDedup::is_enabled(), \"Must be enabled\");\n+        ShenandoahStringDedup::enqueue_candidate(obj);\n+      }\n@@ -291,0 +278,2 @@\n+\n+    shenandoah_assert_marked(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -36,3 +36,2 @@\n-  NONE,       \/\/ No reference updating\n-  SIMPLE,     \/\/ Reference updating using simple store\n-  CONCURRENT  \/\/ Reference updating using CAS\n+  NO_UPDATE, \/\/ Skip reference updates\n+  STW_UPDATE \/\/ Update references, assuming STW mode (no concurrent mutator updates)\n@@ -72,1 +71,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, NO_DEDUP>(p); }\n@@ -75,2 +74,4 @@\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -86,1 +87,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -89,2 +90,4 @@\n-  ShenandoahMarkUpdateRefsDedupClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-          ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsDedupClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -100,1 +103,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, NO_DEDUP>(p); }\n@@ -103,2 +106,4 @@\n-  ShenandoahMarkUpdateRefsMetadataClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-    ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsMetadataClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -114,1 +119,1 @@\n-  inline void do_oop_work(T* p)     { work<T, CONCURRENT, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, STW_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -117,2 +122,4 @@\n-  ShenandoahMarkUpdateRefsMetadataDedupClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp) :\n-  ShenandoahMarkRefsSuperClosure(q, rp) {};\n+  ShenandoahMarkUpdateRefsMetadataDedupClosure(ShenandoahObjToScanQueue *q, ShenandoahReferenceProcessor *rp) :\n+          ShenandoahMarkRefsSuperClosure(q, rp) {\n+    assert(ShenandoahHeap::heap()->is_stw_gc_in_progress(), \"Can only be used for STW GC\");\n+  };\n@@ -128,1 +135,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, NO_DEDUP>(p); }\n@@ -142,1 +149,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, ENQUEUE_DEDUP>(p); }\n@@ -156,1 +163,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, NO_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, NO_DEDUP>(p); }\n@@ -170,1 +177,1 @@\n-  inline void do_oop_work(T* p)     { work<T, NONE, ENQUEUE_DEDUP>(p); }\n+  inline void do_oop_work(T* p)     { work<T, NO_UPDATE, ENQUEUE_DEDUP>(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  _heap->maybe_update_with_forwarded(p);\n+  _heap->atomic_update_with_forwarded(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}