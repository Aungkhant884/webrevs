{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -272,3 +271,6 @@\n-                int count = countLeadingBackslash(verificationType, s, s.length());\n-                while (count-- > 0) {\n-                    cmdbuf.append(BACKSLASH);   \/\/ double the number of backslashes\n+                if (verificationType == VERIFICATION_WIN32_SAFE ||\n+                    verificationType == VERIFICATION_LEGACY) {\n+                    int count = countLeadingBackslash(verificationType, s, s.length());\n+                    while (count-- > 0) {\n+                        cmdbuf.append(BACKSLASH);   \/\/ double the number of backslashes\n+                    }\n@@ -277,0 +279,8 @@\n+            } else if (verificationType == VERIFICATION_WIN32_SAFE &&\n+                 (s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\") && s.length() > 2)) {\n+                \/\/ Check that quoted argument does not escape the final quote\n+                cmdbuf.append(s);\n+                int count = countLeadingBackslash(verificationType, s, s.length() - 1);\n+                while (count-- > 0) {\n+                    cmdbuf.insert(cmdbuf.length() - 1, BACKSLASH);    \/\/ double the number of backslashes\n+                }\n@@ -285,3 +295,1 @@\n-     * Return the argument without quotes (1st and last) if properly quoted, else the arg.\n-     * A properly quoted string has first and last characters as quote and\n-     * the last quote is not escaped.\n+     * Return the argument without quotes (first and last) if quoted, otherwise the arg.\n@@ -295,3 +303,0 @@\n-        if (str.endsWith(\"\\\\\\\"\")) {\n-            return str;    \/\/ not properly quoted, treat as unquoted\n-        }\n","filename":"src\/java.base\/windows\/classes\/java\/lang\/ProcessImpl.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @run main\/othervm ArgCheck\n+ * @summary Check invocation of exe and non-exe programs using ProcessBuilder\n+ *      and arguments with spaces, backslashes, and simple quoting.\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.concurrent.Callable;\n+\n+\/**\n+ * Class to check invocation of java, .cmd, and vbs scripts with arguments and various quote cases.\n+ * Can be run standalone to compare results with other Java versions.\n+ *\/\n+public class ArgCheck {\n+\n+    private static final Path SRC_DIR = Path.of(System.getProperty(\"test.src\", \".\"));\n+    private static final Path WORK_DIR = Path.of(System.getProperty(\"user.dir\", \".\"));\n+    private static final Path TEST_CLASSES = Path.of(System.getProperty(\"test.classes\", \".\"));\n+\n+    private static final String ECHO_CMD_PATH = WORK_DIR.resolve(\"EchoArguments.cmd\").toString();\n+    private static final String ECHO_VBS_PATH = WORK_DIR.resolve(\"EchoArguments.vbs\").toString();\n+\n+    \/\/ Test argument containing both a space and a trailing backslash\n+    \/\/ Depending on the mode the final backslash may act as an escape that may turn an added quote to a literal quote\n+    private static final String SPACE_AND_BACKSLASH = \"SPACE AND BACKSLASH\\\\\";\n+    private static final char DOUBLE_QUOTE = '\"';\n+\n+    private static final String AMBIGUOUS_PROP_NAME = \"jdk.lang.Process.allowAmbiguousCommands\";\n+    private static final String AMBIGUOUS_PROP_VALUE = System.getProperty(AMBIGUOUS_PROP_NAME);\n+    private static final Boolean AMBIGUOUS_PROP_BOOLEAN = AMBIGUOUS_PROP_VALUE == null ? null :\n+                                                          Boolean.valueOf(!\"false\".equals(AMBIGUOUS_PROP_VALUE));\n+\n+    private static final List<String> ECHO_JAVA_ARGS = List.of(\"java\", \"-classpath\", TEST_CLASSES.toString(), \"ArgCheck\");\n+    private static final List<String> ECHO_CMD_ARGS = List.of(ECHO_CMD_PATH);\n+    private static final List<String> ECHO_VBS_ARGS = List.of(\"CScript\", \"\/b\", ECHO_VBS_PATH);\n+\n+    \/**\n+     * If zero arguments are supplied, run the test cases.\n+     * If there are arguments, echo them to Stdout.\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length > 0) {\n+            \/\/ Echo supplied arguments and exit\n+            for (String arg : args)\n+                System.out.println(arg);\n+            return;\n+        }\n+\n+        System.out.println(\"Java Version: \" + Runtime.getRuntime().version());\n+\n+        int errors = 0;\n+        int success = 0;\n+\n+        ArgCheck ac = new ArgCheck();\n+        ac.setup();\n+        for (CMD cmd : CASES) {\n+            \/\/ If System property jdk.lang.process.allowAmbiguousCommands matches the case, test it\n+            \/\/ If undefined, test them all\n+            if (AMBIGUOUS_PROP_BOOLEAN == null ||\n+                    AMBIGUOUS_PROP_BOOLEAN.booleanValue() == cmd.allowAmbiguous) {\n+                try {\n+                    ac.testQuoteCases(cmd);\n+                    success++;\n+                } catch (Exception ex) {\n+                    ex.printStackTrace();\n+                    errors++;\n+                }\n+            } else {\n+                \/\/ skip unmatched cases\n+            }\n+        }\n+        System.out.println(\"\\nSuccess: \" + success + \", errors: \" + errors);\n+        if (errors > 0) {\n+            throw new RuntimeException(\"Errors: \" + errors);\n+        }\n+    }\n+\n+    \/**\n+     * A CMD holds the parameters and the expected result of invoking a process with the parameters.\n+     *\/\n+    static class CMD {\n+        \/**\n+         * Construct a test case.\n+         *\n+         * @param command list of command parameters to invoke the executable or script\n+         * @param arguments list of arguments (appended to the command)\n+         * @param allowAmbiguous  true\/false to set property jdk.lang.Process.allowAmbiguousCommands\n+         * @param expected    expected lines of output from invoked command\n+         *\/\n+        CMD(List<String> command, List<String> arguments, boolean allowAmbiguous, String expected) {\n+            this.command = command;\n+            this.arguments = arguments;\n+            this.allowAmbiguous = allowAmbiguous;\n+            this.result = expected.indent(0);\n+        }\n+\n+        final List<String> command;\n+        final List<String> arguments;\n+        final boolean allowAmbiguous;\n+        final String result;\n+    }\n+\n+    \/**\n+     * List of cases with the command, arguments, allowAmbiguous setting, and the expected results\n+     *\/\n+    static final List<CMD> CASES = List.of(\n+\n+            \/\/ allowAmbiguousCommands = false, without application supplied double-quotes.\n+            \/\/ The space in the argument requires it to be quoted, the final backslash\n+            \/\/ must not be allowed to turn the quote that is added into a literal\n+            \/\/ instead of closing the quote.\n+            new CMD(ECHO_JAVA_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_1\"),\n+                    false,\n+                    \"SPACE AND BACKSLASH\\\\\\n\" +\n+                            \"ARG_1\"),\n+            new CMD(ECHO_CMD_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_2\"),\n+                    false,\n+                    \"\\\"SPACE AND BACKSLASH\\\\\\\"\\n\" +\n+                            \"ARG_2\"),\n+            new CMD(ECHO_VBS_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_3\"),\n+                    false,\n+                    \"SPACE AND BACKSLASH\\\\\\\\\\n\" +\n+                            \"ARG_3\"),\n+\n+            \/\/ allowAmbiguousCommands = false, WITH application supplied double-quotes around the argument\n+            \/\/ The argument has surrounding quotes so does not need further quoting.\n+            \/\/ However, for exe commands, the final backslash must not be allowed to turn the quote\n+            \/\/ into a literal instead of closing the quote.\n+            new CMD(ECHO_JAVA_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_11\"),\n+                    false,\n+                    \"SPACE AND BACKSLASH\\\\\\n\" +\n+                            \"ARG_11\"),\n+            new CMD(ECHO_CMD_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_12\"),\n+                    false,\n+                    \"\\\"SPACE AND BACKSLASH\\\\\\\"\\n\" +\n+                            \"ARG_12\"),\n+            new CMD(ECHO_VBS_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_13\"),\n+                    false,\n+                    \"SPACE AND BACKSLASH\\\\\\\\\\n\" +\n+                            \"ARG_13\"),\n+\n+            \/\/ Legacy mode tests; allowAmbiguousCommands = true; no application supplied quotes\n+            \/\/ The space in the argument requires it to be quoted, the final backslash\n+            \/\/ must not be allowed to turn the quote that is added into a literal\n+            \/\/ instead of closing the quote.\n+            new CMD(ECHO_JAVA_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_21\"),\n+                    true,\n+                    \"SPACE AND BACKSLASH\\\\\\n\" +\n+                            \"ARG_21\"),\n+            new CMD(ECHO_CMD_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_22\"),\n+                    true,\n+                    \"\\\"SPACE AND BACKSLASH\\\\\\\\\\\"\\n\" +\n+                            \"ARG_22\"),\n+            new CMD(ECHO_VBS_ARGS,\n+                    List.of(SPACE_AND_BACKSLASH, \"ARG_23\"),\n+                    true,\n+                    \"SPACE AND BACKSLASH\\\\\\\\\\n\" +\n+                            \"ARG_23\"),\n+\n+            \/\/ allowAmbiguousCommands = true, WITH application supplied double-quotes around the argument\n+            \/\/ The argument has surrounding quotes so does not need further quoting.\n+            \/\/ The backslash before the final quote is ignored and is interpreted differently for each command.\n+            new CMD(ECHO_JAVA_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_31\"),\n+                    true,\n+                    \"SPACE AND BACKSLASH\\\" ARG_31\"),\n+            new CMD(ECHO_CMD_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_32\"),\n+                    true,\n+                    \"\\\"SPACE AND BACKSLASH\\\\\\\"\\n\" +\n+                            \"ARG_32\"),\n+            new CMD(ECHO_VBS_ARGS,\n+                    List.of(DOUBLE_QUOTE + SPACE_AND_BACKSLASH + DOUBLE_QUOTE, \"ARG_33\"),\n+                    true,\n+                    \"SPACE AND BACKSLASH\\\\\\n\" +\n+                            \"ARG_33\")\n+    );\n+\n+    \/**\n+     * Test various commands and arguments invoking non-exe (.cmd) scripts with lenient argument checking.\n+     *\n+     * @param commands A {@literal List<String>} of command arguents.\n+     * @param expected an expected result, either the class of an expected exception or an Integer exit value\n+     *\/\n+    void testQuoteCases(CMD cmd) throws Exception {\n+        List<String> args = new ArrayList<>(cmd.command);\n+        args.addAll(cmd.arguments);\n+        testCommand(() -> new ProcessBuilder(args).start(), args, cmd.allowAmbiguous, cmd.result);\n+    }\n+\n+    \/**\n+     * Common function to Invoke a process with the commands and check the result.\n+     *\n+     * @param callable a callable to create the Process\n+     * @param arguments a list of command strings\n+     * @param allowAmbiguous true\/false to set the value of system property jdk.lang.Process.allowAmbiguousCommands\n+     * @param expected   expected stdout\n+     *\/\n+    private static void testCommand(Callable<Process> callable, List<String> arguments,\n+                                    boolean allowAmbiguous, String expected) throws Exception {\n+        System.setProperty(AMBIGUOUS_PROP_NAME, Boolean.toString(allowAmbiguous));\n+        String actual = \"\";\n+        try {\n+            \/\/ Launch the process and wait for termination\n+            Process process = callable.call();\n+            try (InputStream is = process.getInputStream()) {\n+                byte[] bytes = is.readAllBytes();\n+                actual = new String(bytes, Charset.defaultCharset()).indent(0);\n+            } catch (IOException ioe) {\n+                throw new RuntimeException(ioe.getMessage(), ioe);\n+            }\n+            int exitCode = process.waitFor();\n+            if (exitCode != 0) {\n+                throw new RuntimeException(\"exitCode: \" + exitCode);\n+            }\n+        } catch (IOException ioe) {\n+            actual = ioe.getMessage();\n+            actual = actual.replace(arguments.get(0), \"CMD\");\n+            ioe.printStackTrace();\n+        } catch (Exception ex) {\n+            actual = ex.getMessage();       \/\/ Use exception message as output\n+        }\n+        if (expected != null) {\n+            if (!Objects.equals(actual, expected)) {\n+                System.out.println(\"Invoking(\" + allowAmbiguous + \"): \" + arguments);\n+                System.out.print(\"Actual:   \" + actual);\n+                System.out.print(\"Expected: \" + expected);\n+                System.out.println();\n+                throw new RuntimeException(\"Unexpected output\");\n+            }\n+        } else {\n+            System.out.println(\"out: \" + actual);\n+        }\n+    }\n+\n+    \/**\n+     * Initialize .cmd and .vbs scripts.\n+     *\n+     * @throws Error if an exception occurs\n+     *\/\n+    private static void setup() {\n+        try {\n+            Files.writeString(Path.of(ECHO_CMD_PATH), EchoArgumentsCmd);\n+            Files.writeString(Path.of(ECHO_VBS_PATH), EchoArgumentsVbs);\n+        } catch (IOException e) {\n+            throw new Error(e.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Self contained .cmd to echo each arg on a separate line.\n+     *\/\n+    static final String EchoArgumentsCmd = \"@echo off\\n\" +\n+            \"set p1=\\n\" +\n+            \"set p2=\\n\" +\n+            \"\\n\" +\n+            \"if not [%1]==[] set p1=%1\\n\" +\n+            \"if not [%2]==[] set p2=%2\\n\" +\n+            \"if not [%3]==[] set p3=%3\\n\" +\n+            \"if defined p1 echo %p1%\\n\" +\n+            \"if defined p2 echo %p2%\\n\" +\n+            \"if defined p3 echo %p3%\\n\" +\n+            \"exit \/b 0\\n\";\n+\n+\n+    \/**\n+     * Self contained .vbs to echo each arg on a separate line.\n+     *\/\n+    static final String EchoArgumentsVbs = \"Option Explicit\\n\" +\n+            \"Dim arg\\n\" +\n+            \"for each arg in WScript.Arguments\\n\" +\n+            \"  WScript.StdOut.WriteLine(arg)\\n\" +\n+            \"Next\\n\";\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ArgCheck.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"}]}