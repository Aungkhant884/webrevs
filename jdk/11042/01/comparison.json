{"files":[{"patch":"@@ -198,0 +198,1 @@\n+  OrderAccess::cross_modify_fence();\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\n@@ -103,0 +104,18 @@\n+    uintptr_t prev_poll_word = thread->poll_data()->get_polling_word();\n+\n+    if (prev_poll_word != poll_word ||\n+        prev_poll_word == _poll_word_armed_value) {\n+      \/\/ While updating the poll value, we allow entering new nmethods\n+      \/\/ through stack unwinding. The nmethods might have been processed in\n+      \/\/ a concurrent thread by the GC. So we need to run a cross modify\n+      \/\/ fence to ensure patching becomes visible. We may also wake up from\n+      \/\/ a safepoint that has patched code. This cross modify fence will\n+      \/\/ ensure such paths can observe patched code.\n+      \/\/ Note that while other threads may arm the thread-local poll of\n+      \/\/ a thread, only the thread itself has permission to disarm its own\n+      \/\/ poll value, in any way making it less restrictive. Therefore, whenever\n+      \/\/ the frontier of what the mutator allows itself to do is increased,\n+      \/\/ we will catch that here, and ensure a cross modifying fence is used.\n+      OrderAccess::cross_modify_fence();\n+    }\n+\n@@ -144,1 +163,0 @@\n-  OrderAccess::cross_modify_fence();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-\n-  \/\/ We are now about to avoid processing and thus no cross modify fence will be executed.\n-  \/\/ In case a safepoint happened, while being blocked, we execute it here.\n-  OrderAccess::cross_modify_fence();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}