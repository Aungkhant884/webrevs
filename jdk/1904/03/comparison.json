{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.charset.Charset;\n@@ -41,0 +42,1 @@\n+import java.util.HashMap;\n@@ -42,0 +44,5 @@\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.EventType;\n@@ -239,1 +246,1 @@\n-    private void ensureAccess(Path path) throws UserDataException {\n+    final protected void ensureAccess(Path path) throws UserDataException {\n@@ -306,1 +313,105 @@\n-}\n+\n+    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n+        if (typo.equals(options.peek())) {\n+            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n+        }\n+    }\n+\n+    final protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n+    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n+        return x -> filter != null && filter.test(x);\n+    }\n+\n+    private static String acronomify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    final protected static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String category : eventType.getCategoryNames()) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String filter : filters) {\n+                String fullEventName = eventType.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":113,"deletions":2,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+            System.out.println(\" jfr metadata --categories GC,Detailed\");\n+            System.out.println();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -30,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -31,0 +33,3 @@\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -34,0 +39,1 @@\n+import java.util.HashSet;\n@@ -35,0 +41,1 @@\n+import java.util.function.Predicate;\n@@ -36,0 +43,3 @@\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Name;\n@@ -37,0 +47,1 @@\n+import jdk.jfr.internal.PrivateAccess;\n@@ -42,3 +53,1 @@\n-    private final static JdkJfrConsumer PRIVATE_ACCESS = JdkJfrConsumer.instance();\n-\n-    private static class TypeComparator implements Comparator<Type> {\n+    private static class TypeComparator implements Comparator<EventType> {\n@@ -47,1 +56,3 @@\n-        public int compare(Type t1, Type t2) {\n+        public int compare(EventType et1, EventType et2) {\n+            Type t1 = PrivateAccess.getInstance().getType(et1);\n+            Type t2 = PrivateAccess.getInstance().getType(et2);\n@@ -94,1 +105,0 @@\n-\n@@ -102,1 +112,5 @@\n-        return Collections.singletonList(\"<file>\");\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--categories <filter>]\");\n+        list.add(\"[--events <filter>]\");\n+        list.add(\"[<file>]\");\n+        return list;\n@@ -106,1 +120,1 @@\n-    public String getDescription() {\n+    protected String getTitle() {\n@@ -110,0 +124,31 @@\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help print' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        stream.println(\"  --categories <filter>   Select events matching a category name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  --events <filter>       Select events matching an event name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  <file>                  Location of the recording file (.jfr), it's optional.\");\n+        stream.println();\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events jdk.ThreadStart recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events CPULoad,GarbageCollection\");\n+        stream.println();\n+        char q = quoteCharacter();\n+        stream.println(\" jfr metadata --categories \" + q + \"GC,JVM,Java*\" + q);\n+        stream.println();\n+        stream.println(\" jfr metadata --events \"+ q + \"Thread*\" + q);\n+        stream.println();\n+    }\n+\n@@ -112,1 +157,1 @@\n-        Path file = getJFRInputFile(options);\n+        Path file = getOptionalJFRInputFile(options);\n@@ -115,0 +160,3 @@\n+        boolean foundEventFilter = false;\n+        boolean foundCategoryFilter = false;\n+        Predicate<EventType> filter = null;\n@@ -117,1 +165,2 @@\n-            if (acceptOption(options, \"--ids\")) {\n+            \/\/ internal option, doest not export to users\n+            if (acceptSingleOption(options, \"--ids\")) {\n@@ -120,0 +169,18 @@\n+            if (acceptFilterOption(options, \"--events\")) {\n+                if (foundEventFilter) {\n+                    throw new UserSyntaxException(\"use --events event1,event2,event3 to include multiple events\");\n+                }\n+                foundEventFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--events\", filterStr);\n+                filter = addEventFilter(filterStr, filter);\n+            }\n+            if (acceptFilterOption(options, \"--categories\")) {\n+                if (foundCategoryFilter) {\n+                    throw new UserSyntaxException(\"use --categories category1,category2 to include multiple categories\");\n+                }\n+                foundCategoryFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--categories\", filterStr);\n+                filter = addCategoryFilter(filterStr, filter);\n+            }\n@@ -122,0 +189,2 @@\n+                checkCommonError(options, \"--event\", \"--events\");\n+                checkCommonError(options, \"--category\", \"--categories\");\n@@ -127,1 +196,1 @@\n-        try (PrintWriter pw = new PrintWriter(System.out)) {\n+        try (PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(\"UTF-8\"))) {\n@@ -130,2 +199,18 @@\n-            try (RecordingFile rf = new RecordingFile(file)) {\n-                List<Type> types = PRIVATE_ACCESS.readTypes(rf);\n+            if (filter != null) {\n+                filter = addCache(filter, eventType -> eventType.getId());\n+            }\n+\n+            \/\/ determine whether reading from recording file or reading from metadata.bin\n+            List<EventType> types = null;\n+            if (file != null) {\n+                try (RecordingFile rf = new RecordingFile(file)) {\n+                    types = rf.readEventTypes();\n+                } catch (IOException ioe) {\n+                     couldNotReadError(file, ioe);\n+                }\n+            } else {\n+                \/\/ FlightRecorder.getEventTypes returns unmodifiable list thus disallowing sorting\n+                \/\/ so copy its elements to new list and allow further sorting\n+                types = new ArrayList<>(FlightRecorder.getFlightRecorder().getEventTypes());\n+            }\n+            if (types != null) {\n@@ -133,2 +218,21 @@\n-                for (Type type : types) {\n-                    prettyWriter.printType(type);\n+            }\n+            for (EventType type : types) {\n+                if (filter != null && !filter.test(type)) {\n+                    continue;\n+                }\n+                prettyWriter.printType(type);\n+            }\n+            prettyWriter.flush(true);\n+            pw.flush();\n+        }\n+    }\n+\n+    private Path getOptionalJFRInputFile(Deque<String> options) throws UserDataException {\n+        if (!options.isEmpty()) {\n+            String file = options.getLast();\n+            if (!file.startsWith(\"--\")) {\n+                Path tmp = Paths.get(file).toAbsolutePath();\n+                if (tmp.toString().endsWith(\".jfr\")) {\n+                    ensureAccess(tmp);\n+                    options.removeLast();\n+                    return tmp;\n@@ -136,3 +240,0 @@\n-                prettyWriter.flush(true);\n-            } catch (IOException ioe) {\n-                couldNotReadError(file, ioe);\n@@ -141,0 +242,9 @@\n+        return null;\n+    }\n+\n+    private static boolean acceptSingleOption(Deque<String> options, String expected) {\n+        if (expected.equals(options.peek())) {\n+            options.remove();\n+            return true;\n+        }\n+        return false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":127,"deletions":17,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.jfr.EventType;\n@@ -79,0 +80,4 @@\n+    public void printType(EventType t) {\n+        printType(PrivateAccess.getInstance().getType(t));\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.HashMap;\n@@ -38,2 +37,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n@@ -174,6 +171,0 @@\n-    private void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n-       if (typo.equals(options.peek())) {\n-           throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n-       }\n-    }\n-\n@@ -190,98 +181,0 @@\n-\n-    private static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -30,0 +31,1 @@\n+import java.util.List;\n@@ -33,0 +35,1 @@\n+import jdk.jfr.FlightRecorder;\n@@ -34,0 +37,1 @@\n+import jdk.test.lib.Asserts;\n@@ -47,0 +51,7 @@\n+        testBasic();\n+        testEventTypeNum();\n+        testDeterministic();\n+        testWildcardAndAcronym();\n+    }\n+\n+    static void testBasic() throws Throwable {\n@@ -51,1 +62,2 @@\n-        output.shouldContain(\"missing file\");\n+        output.shouldContain(\"@Name\");\n+        output.shouldContain(\"jdk.jfr.Event\");\n@@ -78,1 +90,58 @@\n-}\n+\n+    static void testEventTypeNum() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n+        List<String> expectedNames = new ArrayList<>();\n+        for (EventType eventType : eventTypes) {\n+            expectedNames.add(eventType.getName());\n+        }\n+        Asserts.assertEQ(eventNames.size(), expectedNames.size());\n+    }\n+\n+    static void testDeterministic() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"CPULoad,GarbageCollection\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        Asserts.assertEQ(eventNames.size(), 2);\n+    }\n+\n+    static void testWildcardAndAcronym() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"Thread*\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        for (String eventName : eventNames) {\n+            Asserts.assertTrue(eventName.contains(\"Thread\"));\n+        }\n+\n+        output = ExecuteHelper.jfr(\"metadata\", \"--categories\", \"J*\");\n+        lines = output.asLines();\n+        eventNames.clear();\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Category(\\\"\")) {\n+                eventNames.add(line.substring(11, line.indexOf(\"\\\"\", 11)));\n+            }\n+        }\n+        for (String eventName : eventNames) {\n+            Asserts.assertTrue(eventName.startsWith(\"J\"));\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestMetadata.java","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"}]}