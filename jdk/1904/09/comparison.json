{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.nio.charset.Charset;\n@@ -38,0 +39,1 @@\n+import java.util.Arrays;\n@@ -41,0 +43,1 @@\n+import java.util.HashMap;\n@@ -42,0 +45,6 @@\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.internal.Type;\n@@ -239,1 +248,1 @@\n-    private void ensureAccess(Path path) throws UserDataException {\n+    final protected void ensureAccess(Path path) throws UserDataException {\n@@ -306,1 +315,112 @@\n-}\n+\n+    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n+        if (typo.equals(options.peek())) {\n+            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n+        }\n+    }\n+\n+    final protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n+    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n+        return x -> filter != null && filter.test(x);\n+    }\n+\n+    private static String acronomify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    final protected static Predicate<Type> addCategoryFilter(String filterText, Predicate<Type> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<Type> newFilter = recurseIfPossible(type -> {\n+            List<String> categories = null;\n+            Category c = type.getAnnotation(Category.class);\n+            if (c != null) {\n+                categories = Collections.unmodifiableList(Arrays.asList(c.value()));\n+            } else {\n+                categories = new ArrayList<>();\n+            }\n+            for (String category : categories) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static Predicate<Type> addEventFilter(String filterText, final Predicate<Type> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<Type> newFilter = recurseIfPossible(type -> {\n+            for (String filter : filters) {\n+                String fullEventName = type.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":123,"deletions":3,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.jfr.EventType;\n@@ -46,0 +45,2 @@\n+import jdk.jfr.internal.PrivateAccess;\n+import jdk.jfr.internal.Type;\n@@ -58,1 +59,1 @@\n-    private Predicate<EventType> eventFilter = x -> true;\n+    private Predicate<Type> eventFilter = x -> true;\n@@ -96,1 +97,1 @@\n-    public final void setEventFilter(Predicate<EventType> eventFilter) {\n+    public final void setEventFilter(Predicate<Type> eventFilter) {\n@@ -101,1 +102,1 @@\n-        return eventFilter.test(event.getEventType());\n+        return eventFilter.test(PrivateAccess.getInstance().getType(event.getEventType()));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/EventPrintWriter.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+            System.out.println(\" jfr metadata --categories GC,Detailed\");\n+            System.out.println();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -30,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -31,0 +33,2 @@\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n@@ -35,0 +39,1 @@\n+import java.util.function.Predicate;\n@@ -38,0 +43,1 @@\n+import jdk.jfr.internal.TypeLibrary;\n@@ -102,1 +108,5 @@\n-        return Collections.singletonList(\"<file>\");\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--categories <filter>]\");\n+        list.add(\"[--events <filter>]\");\n+        list.add(\"[<file>]\");\n+        return list;\n@@ -106,1 +116,1 @@\n-    public String getDescription() {\n+    protected String getTitle() {\n@@ -110,0 +120,36 @@\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help metadata' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        char q = quoteCharacter();\n+        stream.println(\"  --categories <filter>   Select events matching a category name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  --events <filter>       Select events matching an event name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  <file>                  Location of the recording file (.jfr)\");\n+        stream.println();\n+        stream.println(\"If the <file> parameter is omitted, metadata from the JDK where\");\n+        stream.println(\"the \" + q + \"jfr\" + q + \" tool is located will be used\");\n+        stream.println();\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr metadata\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events jdk.ThreadStart recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events CPULoad,GarbageCollection\");\n+        stream.println();\n+        stream.println(\" jfr metadata --categories \" + q + \"GC,JVM,Java*\" + q);\n+        stream.println();\n+        stream.println(\" jfr metadata --events \" + q + \"Thread*\" + q);\n+        stream.println();\n+    }\n+\n@@ -112,1 +158,1 @@\n-        Path file = getJFRInputFile(options);\n+        Path file = getOptionalJFRInputFile(options);\n@@ -115,0 +161,3 @@\n+        boolean foundEventFilter = false;\n+        boolean foundCategoryFilter = false;\n+        Predicate<Type> filter = null;\n@@ -117,1 +166,2 @@\n-            if (acceptOption(options, \"--ids\")) {\n+            \/\/ internal option, doest not export to users\n+            if (acceptSingleOption(options, \"--ids\")) {\n@@ -120,0 +170,18 @@\n+            if (acceptFilterOption(options, \"--events\")) {\n+                if (foundEventFilter) {\n+                    throw new UserSyntaxException(\"use --events event1,event2,event3 to include multiple events\");\n+                }\n+                foundEventFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--events\", filterStr);\n+                filter = addEventFilter(filterStr, filter);\n+            }\n+            if (acceptFilterOption(options, \"--categories\")) {\n+                if (foundCategoryFilter) {\n+                    throw new UserSyntaxException(\"use --categories category1,category2 to include multiple categories\");\n+                }\n+                foundCategoryFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--categories\", filterStr);\n+                filter = addCategoryFilter(filterStr, filter);\n+            }\n@@ -122,0 +190,2 @@\n+                checkCommonError(options, \"--event\", \"--events\");\n+                checkCommonError(options, \"--category\", \"--categories\");\n@@ -127,1 +197,1 @@\n-        try (PrintWriter pw = new PrintWriter(System.out)) {\n+        try (PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(\"UTF-8\"))) {\n@@ -130,5 +200,9 @@\n-            try (RecordingFile rf = new RecordingFile(file)) {\n-                List<Type> types = PRIVATE_ACCESS.readTypes(rf);\n-                Collections.sort(types, new TypeComparator());\n-                for (Type type : types) {\n-                    prettyWriter.printType(type);\n+            if (filter != null) {\n+                filter = addCache(filter, type -> type.getId());\n+            }\n+\n+            List<Type> types = getAllTypes(file);\n+            Collections.sort(types, new TypeComparator());\n+            for (Type type : types) {\n+                if (filter != null && !filter.test(type)) {\n+                    continue;\n@@ -136,3 +210,2 @@\n-                prettyWriter.flush(true);\n-            } catch (IOException ioe) {\n-                couldNotReadError(file, ioe);\n+\n+                prettyWriter.printType(type);\n@@ -140,0 +213,39 @@\n+            prettyWriter.flush(true);\n+            pw.flush();\n+        }\n+    }\n+\n+    private List<Type> getAllTypes(Path file) throws UserDataException {\n+        \/\/ Determine whether reading from recording file or reading from the JDK where\n+        \/\/ the jfr tool is located will be used\n+        if (file == null) {\n+            return TypeLibrary.getInstance().getTypes();\n+        }\n+        List<Type> types = null;\n+        try (RecordingFile rf = new RecordingFile(file)) {\n+            types = PRIVATE_ACCESS.readTypes(rf);\n+        } catch (IOException ioe) {\n+            couldNotReadError(file, ioe);\n+        }\n+        return types;\n+    }\n+\n+    private Path getOptionalJFRInputFile(Deque<String> options) throws UserDataException {\n+        if (!options.isEmpty()) {\n+            String file = options.getLast();\n+            if (!file.startsWith(\"--\")) {\n+                Path tmp = Paths.get(file).toAbsolutePath();\n+                if (tmp.toString().endsWith(\".jfr\")) {\n+                    ensureAccess(tmp);\n+                    options.removeLast();\n+                    return tmp;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean acceptSingleOption(Deque<String> options, String expected) {\n+        if (expected.equals(options.peek())) {\n+            options.remove();\n+            return true;\n@@ -141,0 +253,1 @@\n+        return false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":127,"deletions":14,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.HashMap;\n@@ -38,2 +37,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n@@ -42,1 +39,1 @@\n-import jdk.jfr.EventType;\n+import jdk.jfr.internal.Type;\n@@ -108,1 +105,1 @@\n-        Predicate<EventType> eventFilter = null;\n+        Predicate<Type> eventFilter = null;\n@@ -163,1 +160,1 @@\n-            eventFilter = addCache(eventFilter, eventType -> eventType.getId());\n+            eventFilter = addCache(eventFilter, type -> type.getId());\n@@ -174,6 +171,0 @@\n-    private void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n-       if (typo.equals(options.peek())) {\n-           throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n-       }\n-    }\n-\n@@ -190,98 +181,0 @@\n-\n-    private static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":4,"deletions":111,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -30,0 +31,1 @@\n+import java.util.List;\n@@ -33,0 +35,1 @@\n+import jdk.jfr.FlightRecorder;\n@@ -34,0 +37,1 @@\n+import jdk.test.lib.Asserts;\n@@ -47,0 +51,7 @@\n+        testBasic();\n+        testEventTypeNum();\n+        testDeterministic();\n+        testWildcardAndAcronym();\n+    }\n+\n+    static void testBasic() throws Throwable {\n@@ -51,1 +62,2 @@\n-        output.shouldContain(\"missing file\");\n+        output.shouldContain(\"@Name\");\n+        output.shouldContain(\"jdk.jfr.Event\");\n@@ -78,1 +90,60 @@\n-}\n+\n+    static void testEventTypeNum() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n+        List<String> expectedNames = new ArrayList<>();\n+        for (EventType eventType : eventTypes) {\n+            expectedNames.add(eventType.getName());\n+        }\n+        \/\/ expectedNames not only includes event types but also contains other types\n+        \/\/ while FlightRecorder.getEventTypes only returns event types\n+        Asserts.assertGTE(eventNames.size(), expectedNames.size());\n+    }\n+\n+    static void testDeterministic() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"CPULoad,GarbageCollection\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        Asserts.assertEQ(eventNames.size(), 2);\n+    }\n+\n+    static void testWildcardAndAcronym() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"Thread*\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        for (String eventName : eventNames) {\n+            Asserts.assertTrue(eventName.contains(\"Thread\"));\n+        }\n+\n+        output = ExecuteHelper.jfr(\"metadata\", \"--categories\", \"J*\");\n+        lines = output.asLines();\n+        eventNames.clear();\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Category(\\\"\")) {\n+                eventNames.add(line.substring(11, line.indexOf(\"\\\"\", 11)));\n+            }\n+        }\n+        for (String eventName : eventNames) {\n+            Asserts.assertTrue(eventName.startsWith(\"J\"));\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestMetadata.java","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"}]}