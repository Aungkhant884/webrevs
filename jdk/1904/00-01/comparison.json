{"files":[{"patch":"@@ -236,2 +236,6 @@\n-    \/\/ package private\n-    Type getType() {\n+    \/**\n+     * Returns the underlying platform event type\n+     *\n+     * @return the underlying platform event type\n+     *\/\n+    public Type getType() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.charset.Charset;\n@@ -41,0 +42,1 @@\n+import java.util.HashMap;\n@@ -42,0 +44,5 @@\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.EventType;\n@@ -311,2 +318,100 @@\n-     }\n-}\n+    }\n+\n+    final protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n+    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n+        return x -> filter != null && filter.test(x);\n+    }\n+\n+    private static String acronomify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    final protected static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String category : eventType.getCategoryNames()) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String filter : filters) {\n+                String fullEventName = eventType.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":107,"deletions":2,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -30,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -39,0 +41,1 @@\n+import java.util.function.Predicate;\n@@ -40,2 +43,2 @@\n-import jdk.jfr.AnnotationElement;\n-import jdk.jfr.Category;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n@@ -43,1 +46,0 @@\n-import jdk.jfr.internal.PlatformEventType;\n@@ -46,1 +48,0 @@\n-import jdk.jfr.internal.TypeLibrary;\n@@ -51,1 +52,1 @@\n-    private static class TypeComparator implements Comparator<Type> {\n+    private static class TypeComparator implements Comparator<EventType> {\n@@ -54,1 +55,3 @@\n-        public int compare(Type t1, Type t2) {\n+        public int compare(EventType et1, EventType et2) {\n+            Type t1 = et1.getType();\n+            Type t2 = et2.getType();\n@@ -101,1 +104,0 @@\n-\n@@ -117,1 +119,1 @@\n-    public String getDescription() {\n+    protected String getTitle() {\n@@ -121,0 +123,31 @@\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help print' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        stream.println(\"  --categories <filter>   Select events matching a category name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  --events <filter>       Select events matching an event name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  <file>                  Location of the recording file (.jfr), it's optional.\");\n+        stream.println();\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events jdk.ThreadStart recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events CPULoad,GarbageCollection\");\n+        stream.println();\n+        char q = quoteCharacter();\n+        stream.println(\" jfr metadata --categories \" + q + \"GC,JVM,Java*\" + q);\n+        stream.println();\n+        stream.println(\" jfr metadata --events \"+ q + \"Thread*\" + q);\n+        stream.println();\n+    }\n+\n@@ -128,2 +161,1 @@\n-        HashSet<String> acceptedEvents = null;\n-        HashSet<String> acceptedCategories = null;\n+        Predicate<EventType> filter = null;\n@@ -132,1 +164,2 @@\n-            if (acceptOption(options, \"--ids\")) {\n+            \/\/ internal option, doest not export to users\n+            if (acceptSingleOption(options, \"--ids\")) {\n@@ -140,3 +173,3 @@\n-                String filter = options.remove();\n-                warnForWildcardExpansion(\"--events\", filter);\n-                acceptedEvents = new HashSet<>(Arrays.asList(filter.split(\",\")));\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--events\", filterStr);\n+                filter = addEventFilter(filterStr, filter);\n@@ -149,3 +182,3 @@\n-                String filter = options.remove();\n-                warnForWildcardExpansion(\"--categories\", filter);\n-                acceptedCategories  = new HashSet<>(Arrays.asList(filter.split(\",\")));\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--categories\", filterStr);\n+                filter = addCategoryFilter(filterStr, filter);\n@@ -162,1 +195,1 @@\n-        try (PrintWriter pw = new PrintWriter(System.out)) {\n+        try (PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(\"UTF-8\"))) {\n@@ -165,0 +198,3 @@\n+            if (filter != null) {\n+                filter = addCache(filter, eventType -> eventType.getId());\n+            }\n@@ -166,1 +202,2 @@\n-            List<Type> types = null;\n+            \/\/ determine whether reading from recording file or reading from metadata.bin\n+            List<EventType> types = null;\n@@ -168,1 +205,0 @@\n-                \/\/ has recording.jfr, read metadata from file\n@@ -170,2 +206,3 @@\n-                    types = JdkJfrConsumer.instance().readTypes(rf);\n-                    Collections.sort(types, new TypeComparator());\n+                    types = rf.readEventTypes();\n+                } catch (IOException ioe) {\n+                     couldNotReadError(file, ioe);\n@@ -174,2 +211,3 @@\n-                \/\/ don't have recoring.jfr, read metadata from metadata.bin\n-                types = TypeLibrary.getInstance().getTypes();\n+                \/\/ FlightRecorder.getEventTypes returns unmodifiable list thus disallowing sorting\n+                \/\/ so copy its elements to new list and allow further sorting\n+                types = new ArrayList<>(FlightRecorder.getFlightRecorder().getEventTypes());\n@@ -177,17 +215,5 @@\n-\n-            for (Type type : types) {\n-                if (!(type instanceof PlatformEventType)) {\n-                    continue;\n-                }\n-                if (foundEventFilter) {\n-                    if (acceptedEvents.contains(type.getName())) {\n-                        prettyWriter.printType(type);\n-                        prettyWriter.flush(true);\n-                    }\n-                    continue;\n-                }\n-                if (foundCategoryFilter) {\n-                    if (acceptCategory(acceptedCategories, type)) {\n-                        prettyWriter.printType(type);\n-                        prettyWriter.flush(true);\n-                    }\n+            if (types != null) {\n+                Collections.sort(types, new TypeComparator());\n+            }\n+            for (EventType type : types) {\n+                if (filter != null && !filter.test(type)) {\n@@ -196,1 +222,0 @@\n-                \/\/ no filter, just printing\n@@ -198,16 +223,0 @@\n-                prettyWriter.flush(true);\n-            }\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static boolean acceptCategory(HashSet<String> categoryNames, Type type) {\n-        Category categoryAnno = type.getAnnotation(Category.class);\n-        int matchCount = 0;\n-        if (categoryAnno != null) {\n-            String[] categories = categoryAnno.value();\n-            for (String category : categories) {\n-                if (categoryNames.contains(category)) {\n-                    matchCount++;\n-                }\n@@ -215,0 +224,2 @@\n+            prettyWriter.flush(true);\n+            pw.flush();\n@@ -216,2 +227,0 @@\n-\n-        return matchCount == categoryNames.size();\n@@ -237,0 +246,8 @@\n+\n+    private static boolean acceptSingleOption(Deque<String> options, String expected) throws UserSyntaxException {\n+        if (expected.equals(options.peek())) {\n+            options.remove();\n+            return true;\n+        }\n+        return false;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":77,"deletions":60,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.jfr.EventType;\n@@ -79,0 +80,4 @@\n+    public void printType(EventType t) {\n+        printType(t.getType());\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.HashMap;\n@@ -38,2 +37,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n@@ -184,98 +181,0 @@\n-\n-    private static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.jfr.FlightRecorder;\n@@ -36,3 +37,0 @@\n-import jdk.jfr.internal.PlatformEventType;\n-import jdk.jfr.internal.Type;\n-import jdk.jfr.internal.TypeLibrary;\n@@ -45,1 +43,0 @@\n- * @modules jdk.jfr\/jdk.jfr.internal\n@@ -54,0 +51,7 @@\n+        testBasic();\n+        testEventTypeNum();\n+        testDeterministic();\n+        testWildcardAndAcronym();\n+    }\n+\n+    static void testBasic() throws Throwable {\n@@ -85,0 +89,1 @@\n+    }\n@@ -86,1 +91,2 @@\n-        output = ExecuteHelper.jfr(\"metadata\");\n+    static void testEventTypeNum() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\");\n@@ -89,0 +95,1 @@\n+\n@@ -94,1 +101,1 @@\n-        List<Type> eventTypes = TypeLibrary.getInstance().getTypes();\n+        List<EventType> eventTypes = FlightRecorder.getFlightRecorder().getEventTypes();\n@@ -96,3 +103,26 @@\n-        for (Type eventType : eventTypes) {\n-            if (eventType instanceof PlatformEventType) {\n-                expectedNames.add(eventType.getName());\n+        for (EventType eventType : eventTypes) {\n+            expectedNames.add(eventType.getName());\n+        }\n+        Asserts.assertEQ(eventNames.size(), expectedNames.size());\n+    }\n+\n+    static void testDeterministic() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"CPULoad,GarbageCollection\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n+            }\n+        }\n+        Asserts.assertEQ(eventNames.size(), 2);\n+    }\n+\n+    static void testWildcardAndAcronym() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"Thread*\");\n+        List<String> eventNames = new ArrayList<>();\n+        List<String> lines = output.asLines();\n+        for (String line : lines) {\n+            if (line.startsWith(\"@Name(\\\"\")) {\n+                eventNames.add(line.substring(7, line.indexOf(\"\\\"\", 7)));\n@@ -101,2 +131,3 @@\n-        \/\/ expectedNames may have instrumented event\n-        Asserts.assertLT(eventNames.size(), expectedNames.size());\n+        for (String eventName : eventNames) {\n+            Asserts.assertTrue(eventName.contains(\"Thread\"));\n+        }\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestMetadata.java","additions":42,"deletions":11,"binary":false,"changes":53,"status":"modified"}]}