{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.nio.charset.Charset;\n@@ -41,0 +42,1 @@\n+import java.util.HashMap;\n@@ -42,0 +44,5 @@\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.EventType;\n@@ -239,1 +246,1 @@\n-    private void ensureAccess(Path path) throws UserDataException {\n+    final protected void ensureAccess(Path path) throws UserDataException {\n@@ -306,1 +313,105 @@\n-}\n+\n+    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n+        if (typo.equals(options.peek())) {\n+            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n+        }\n+    }\n+\n+    final protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n+    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n+        return x -> filter != null && filter.test(x);\n+    }\n+\n+    private static String acronomify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    final protected static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String category : eventType.getCategoryNames()) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n+            for (String filter : filters) {\n+                String fullEventName = eventType.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        });\n+        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n+    }\n+\n+    final protected static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":114,"deletions":3,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+            System.out.println(\" jfr metadata --categories GC,Detailed\");\n+            System.out.println();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -30,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -31,0 +33,2 @@\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n@@ -35,0 +39,1 @@\n+import java.util.function.Predicate;\n@@ -36,0 +41,2 @@\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n@@ -37,0 +44,2 @@\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.PrivateAccess;\n@@ -38,0 +47,1 @@\n+import jdk.jfr.internal.TypeLibrary;\n@@ -94,1 +104,0 @@\n-\n@@ -102,1 +111,5 @@\n-        return Collections.singletonList(\"<file>\");\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--categories <filter>]\");\n+        list.add(\"[--events <filter>]\");\n+        list.add(\"[<file>]\");\n+        return list;\n@@ -106,1 +119,1 @@\n-    public String getDescription() {\n+    protected String getTitle() {\n@@ -110,0 +123,36 @@\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help metadata' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        char q = quoteCharacter();\n+        stream.println(\"  --categories <filter>   Select events matching a category name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  --events <filter>       Select events matching an event name.\");\n+        stream.println(\"                          The filter is a comma-separated list of names,\");\n+        stream.println(\"                          simple and\/or qualified, and\/or quoted glob patterns\");\n+        stream.println();\n+        stream.println(\"  <file>                  Location of the recording file (.jfr)\");\n+        stream.println();\n+        stream.println(\"If the <file> parameter is omitted, metadata from the JDK where\");\n+        stream.println(\"the \" + q + \"jfr\" + q + \" tool is located will be used\");\n+        stream.println();\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr metadata\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events jdk.ThreadStart recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr metadata --events CPULoad,GarbageCollection\");\n+        stream.println();\n+        stream.println(\" jfr metadata --categories \" + q + \"GC,JVM,Java*\" + q);\n+        stream.println();\n+        stream.println(\" jfr metadata --events \" + q + \"Thread*\" + q);\n+        stream.println();\n+    }\n+\n@@ -112,1 +161,1 @@\n-        Path file = getJFRInputFile(options);\n+        Path file = getOptionalJFRInputFile(options);\n@@ -115,0 +164,3 @@\n+        boolean foundEventFilter = false;\n+        boolean foundCategoryFilter = false;\n+        Predicate<EventType> filter = null;\n@@ -117,1 +169,2 @@\n-            if (acceptOption(options, \"--ids\")) {\n+            \/\/ internal option, doest not export to users\n+            if (acceptSingleOption(options, \"--ids\")) {\n@@ -120,0 +173,18 @@\n+            if (acceptFilterOption(options, \"--events\")) {\n+                if (foundEventFilter) {\n+                    throw new UserSyntaxException(\"use --events event1,event2,event3 to include multiple events\");\n+                }\n+                foundEventFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--events\", filterStr);\n+                filter = addEventFilter(filterStr, filter);\n+            }\n+            if (acceptFilterOption(options, \"--categories\")) {\n+                if (foundCategoryFilter) {\n+                    throw new UserSyntaxException(\"use --categories category1,category2 to include multiple categories\");\n+                }\n+                foundCategoryFilter = true;\n+                String filterStr = options.remove();\n+                warnForWildcardExpansion(\"--categories\", filterStr);\n+                filter = addCategoryFilter(filterStr, filter);\n+            }\n@@ -122,0 +193,2 @@\n+                checkCommonError(options, \"--event\", \"--events\");\n+                checkCommonError(options, \"--category\", \"--categories\");\n@@ -127,1 +200,1 @@\n-        try (PrintWriter pw = new PrintWriter(System.out)) {\n+        try (PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(\"UTF-8\"))) {\n@@ -130,4 +203,16 @@\n-            try (RecordingFile rf = new RecordingFile(file)) {\n-                List<Type> types = PRIVATE_ACCESS.readTypes(rf);\n-                Collections.sort(types, new TypeComparator());\n-                for (Type type : types) {\n+            if (filter != null) {\n+                filter = addCache(filter, type -> type.getId());\n+            }\n+\n+            List<Type> types = findTypes(file);\n+            Collections.sort(types, new TypeComparator());\n+            for (Type type : types) {\n+                if (filter != null) {\n+                    \/\/ If --events or --categories, only operate on events\n+                    if (Type.SUPER_TYPE_EVENT.equals(type.getSuperType())) {\n+                        EventType et = PrivateAccess.getInstance().newEventType((PlatformEventType) type);\n+                        if (filter.test(et)) {\n+                            prettyWriter.printType(type);\n+                        }\n+                    }\n+                } else {\n@@ -136,3 +221,0 @@\n-                prettyWriter.flush(true);\n-            } catch (IOException ioe) {\n-                couldNotReadError(file, ioe);\n@@ -140,0 +222,40 @@\n+            prettyWriter.flush(true);\n+            pw.flush();\n+        }\n+    }\n+\n+    private List<Type> findTypes(Path file) throws UserDataException {\n+        \/\/ Determine whether reading from recording file or reading from the JDK where\n+        \/\/ the jfr tool is located will be used\n+        if (file == null) {\n+            \/\/ Force initialization\n+            FlightRecorder.getFlightRecorder().getEventTypes();\n+            return TypeLibrary.getInstance().getTypes();\n+        }\n+        try (RecordingFile rf = new RecordingFile(file)) {\n+            return PRIVATE_ACCESS.readTypes(rf);\n+        } catch (IOException ioe) {\n+            couldNotReadError(file, ioe);\n+        }\n+        return null; \/\/ Can't reach\n+    }\n+\n+    private Path getOptionalJFRInputFile(Deque<String> options) throws UserDataException {\n+        if (!options.isEmpty()) {\n+            String file = options.getLast();\n+            if (!file.startsWith(\"--\")) {\n+                Path tmp = Paths.get(file).toAbsolutePath();\n+                if (tmp.toString().endsWith(\".jfr\")) {\n+                    ensureAccess(tmp);\n+                    options.removeLast();\n+                    return tmp;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean acceptSingleOption(Deque<String> options, String expected) {\n+        if (expected.equals(options.peek())) {\n+            options.remove();\n+            return true;\n@@ -141,0 +263,1 @@\n+        return false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":137,"deletions":14,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.HashMap;\n@@ -38,2 +37,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n@@ -174,6 +171,0 @@\n-    private void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n-       if (typo.equals(options.peek())) {\n-           throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n-       }\n-    }\n-\n@@ -190,98 +181,0 @@\n-\n-    private static <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":1,"deletions":108,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -30,0 +31,1 @@\n+import java.util.List;\n@@ -32,0 +34,2 @@\n+import jdk.jfr.Category;\n+import jdk.jfr.Event;\n@@ -33,0 +37,3 @@\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Name;\n+import jdk.jfr.Registered;\n@@ -34,0 +41,1 @@\n+import jdk.test.lib.Asserts;\n@@ -47,0 +55,13 @@\n+        testUnfiltered();\n+        testIllegalOption();\n+        testNumberOfEventTypes();\n+\n+        FlightRecorder.register(MyEvent1.class);\n+        FlightRecorder.register(MyEvent2.class);\n+        FlightRecorder.register(MyEvent3.class);\n+        String file = ExecuteHelper.createProfilingRecording().toAbsolutePath().toAbsolutePath().toString();\n+        testEventFilter(file);\n+        testWildcardAndAcronym(file);\n+    }\n+\n+    static void testUnfiltered() throws Throwable {\n@@ -49,1 +70,0 @@\n-\n@@ -51,4 +71,1 @@\n-        output.shouldContain(\"missing file\");\n-\n-        output = ExecuteHelper.jfr(\"metadata\", \"--wrongOption\", file);\n-        output.shouldContain(\"unknown option --wrongOption\");\n+        output.shouldContain(\"extends jdk.jfr.Event\");\n@@ -78,1 +95,85 @@\n-}\n+\n+    static void testIllegalOption() throws Throwable {\n+        Path f = ExecuteHelper.createProfilingRecording().toAbsolutePath();\n+        String file = f.toAbsolutePath().toString();\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--wrongOption\", file);\n+        output.shouldContain(\"unknown option --wrongOption\");\n+\n+        output = ExecuteHelper.jfr(\"metadata\", \"--wrongOption2\");\n+        output.shouldContain(\"unknown option --wrongOption2\");\n+    }\n+\n+    static void testNumberOfEventTypes() throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\");\n+        int count  = 0;\n+        for (String line : output.asLines()) {\n+            if (line.contains(\"extends jdk.jfr.Event\")) {\n+                count++;\n+            }\n+        }\n+        Asserts.assertEquals(count, FlightRecorder.getFlightRecorder().getEventTypes().size());\n+    }\n+\n+    static void testEventFilter(String file) throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"MyEvent1,MyEvent2\", file);\n+        int count = 0;\n+        for (String line : output.asLines()) {\n+            if (line.contains(\"extends jdk.jfr.Event\")) {\n+                Asserts.assertTrue(line.contains(\"MyEvent1\") || line.contains(\"MyEvent2\"));\n+                count++;\n+            }\n+        }\n+        Asserts.assertEQ(count, 2);\n+\n+        output = ExecuteHelper.jfr(\"metadata\", \"--categories\", \"Customized\", file);\n+        count = 0;\n+        for (String line : output.asLines()) {\n+            if (line.contains(\"extends jdk.jfr.Event\")) {\n+                Asserts.assertTrue(line.contains(\"MyEvent1\") || line.contains(\"MyEvent2\") || line.contains(\"MyEvent3\"));\n+                count++;\n+            }\n+        }\n+        Asserts.assertEQ(count, 3);\n+    }\n+\n+    static void testWildcardAndAcronym(String file) throws Throwable {\n+        OutputAnalyzer output = ExecuteHelper.jfr(\"metadata\", \"--events\", \"MyEv*\", file);\n+        int count = 0;\n+        for (String line : output.asLines()) {\n+            if (line.contains(\"extends jdk.jfr.Event\")) {\n+                count++;\n+                Asserts.assertTrue(line.contains(\"MyEvent\"));\n+            }\n+        }\n+        Asserts.assertEQ(count, 3);\n+\n+        output = ExecuteHelper.jfr(\"metadata\", \"--categories\", \"Custo*\", file);\n+        count = 0;\n+        for (String line : output.asLines()) {\n+            if (line.startsWith(\"@Category\")) {\n+                Asserts.assertTrue(line.contains(\"Customized\"));\n+            }\n+            if (line.contains(\"extends jdk.jfr.Event\")) {\n+                count++;\n+                Asserts.assertTrue(line.contains(\"MyEvent\"));\n+            }\n+        }\n+        Asserts.assertEQ(count, 3);\n+    }\n+\n+    @Registered(false)\n+    @Category(\"Customized\")\n+    @Name(\"MyEvent1\")\n+    private static class MyEvent1 extends Event {\n+    }\n+    @Registered(false)\n+    @Category(\"Customized\")\n+    @Name(\"MyEvent2\")\n+    private static class MyEvent2 extends Event {\n+    }\n+    @Registered(false)\n+    @Category(\"Customized\")\n+    @Name(\"MyEvent3\")\n+    private static class MyEvent3 extends Event {\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestMetadata.java","additions":108,"deletions":7,"binary":false,"changes":115,"status":"modified"}]}