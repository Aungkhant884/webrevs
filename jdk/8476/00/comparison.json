{"files":[{"patch":"@@ -637,1 +637,1 @@\n-        result.appendLine(\"public \" + params.getClassName() + \"() {\");\n+        result.appendLine(params.getClassName() + \"() {\");\n@@ -825,0 +825,10 @@\n+        \/\/ Use grade-school multiplication with a simple squaring optimization.\n+        \/\/ Multiply into primitives to avoid the temporary array allocation.\n+        \/\/ This is equivalent to the following code:\n+        \/\/  long[] c = new long[2 * NUM_LIMBS - 1];\n+        \/\/  for(int i = 0; i < NUM_LIMBS; i++) {\n+        \/\/      c[2 * i] = a[i] * a[i];\n+        \/\/      for(int j = i + 1; j < NUM_LIMBS; j++) {\n+        \/\/          c[i + j] += 2 * a[i] * a[j]\n+        \/\/      }\n+        \/\/  }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    private static final IntegerFieldModuloP ipl1305 =\n-            new IntegerPolynomial1305();\n+    private static final IntegerFieldModuloP ipl1305\n+            = IntegerPolynomial.Holder.P1305;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,2 +70,19 @@\n-            sun.security.util.math.intpoly.Curve25519OrderField,\n-            sun.security.util.math.intpoly.Curve448OrderField {\n+            Curve25519OrderField,\n+            Curve448OrderField {\n+\n+    public final class Holder {\n+        \/\/ EC\n+        public static final IntegerPolynomial P256 = new IntegerPolynomialP256();\n+        public static final IntegerPolynomial P384 = new IntegerPolynomialP384();\n+        public static final IntegerPolynomial P521 = new IntegerPolynomialP521();\n+        public static final IntegerPolynomial PO256 = new P256OrderField();\n+        public static final IntegerPolynomial PO384 = new P384OrderField();\n+        public static final IntegerPolynomial PO521 = new P521OrderField();\n+        \/\/ XEC or EdDSA\n+        public static final IntegerPolynomial P25519 = new IntegerPolynomial25519();\n+        public static final IntegerPolynomial P448 = new IntegerPolynomial448();\n+        public static final IntegerPolynomial PO25519 = new Curve25519OrderField();\n+        public static final IntegerPolynomial PO448 = new Curve448OrderField();\n+        \/\/ Poly1305\n+        public static final IntegerPolynomial P1305 = new IntegerPolynomial1305();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public IntegerPolynomial1305() {\n+    IntegerPolynomial1305() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.util.math.intpoly;\n-\n-import java.math.BigInteger;\n-\n-\/**\n- * An IntegerFieldModuloP designed for use with the Curve25519.\n- * The representation uses 10 signed long values.\n- *\/\n-\n-public final class IntegerPolynomial25519 extends IntegerPolynomial {\n-\n-    private static final int POWER = 255;\n-    private static final int SUBTRAHEND = 19;\n-    private static final int NUM_LIMBS = 10;\n-    private static final int BITS_PER_LIMB = 26;\n-    public static final BigInteger MODULUS\n-        = TWO.pow(POWER).subtract(BigInteger.valueOf(SUBTRAHEND));\n-\n-    \/\/ BITS_PER_LIMB does not divide POWER, so reduction is a bit complicated\n-    \/\/ The constants below help split up values during reduction\n-    private static final int BIT_OFFSET = NUM_LIMBS * BITS_PER_LIMB - POWER;\n-    private static final int LIMB_MASK = -1 >>> (64 - BITS_PER_LIMB);\n-    private static final int RIGHT_BIT_OFFSET = BITS_PER_LIMB - BIT_OFFSET;\n-\n-    public IntegerPolynomial25519() {\n-        super(BITS_PER_LIMB, NUM_LIMBS, 1, MODULUS);\n-    }\n-\n-    @Override\n-    protected void reduceIn(long[] limbs, long v, int i) {\n-        long t0 = 19 * v;\n-        limbs[i - 10] += (t0 << 5) & LIMB_MASK;\n-        limbs[i - 9] += t0 >> 21;\n-    }\n-\n-    @Override\n-    protected void finalCarryReduceLast(long[] limbs) {\n-\n-        long reducedValue = limbs[numLimbs - 1] >> RIGHT_BIT_OFFSET;\n-        limbs[numLimbs - 1] -= reducedValue << RIGHT_BIT_OFFSET;\n-        limbs[0] += reducedValue * SUBTRAHEND;\n-    }\n-\n-    @Override\n-    protected void reduce(long[] a) {\n-\n-        \/\/ carry(8, 2)\n-        long carry8 = carryValue(a[8]);\n-        a[8] -= (carry8 << BITS_PER_LIMB);\n-        a[9] += carry8;\n-\n-        long carry9 = carryValue(a[9]);\n-        a[9] -= (carry9 << BITS_PER_LIMB);\n-\n-        \/\/ reduce(0, 1)\n-        long reducedValue10 = (carry9 * SUBTRAHEND);\n-        a[0] += ((reducedValue10 << BIT_OFFSET) & LIMB_MASK);\n-        a[1] += reducedValue10 >> RIGHT_BIT_OFFSET;\n-\n-        \/\/ carry(0, 9)\n-        carry(a, 0, 9);\n-    }\n-\n-    @Override\n-    protected void mult(long[] a, long[] b, long[] r) {\n-        long c0 = (a[0] * b[0]);\n-        long c1 = (a[0] * b[1]) + (a[1] * b[0]);\n-        long c2 = (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]);\n-        long c3 = (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]);\n-        long c4 = (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]);\n-        long c5 = (a[0] * b[5]) + (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]) + (a[5] * b[0]);\n-        long c6 = (a[0] * b[6]) + (a[1] * b[5]) + (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]) + (a[5] * b[1]) + (a[6] * b[0]);\n-        long c7 = (a[0] * b[7]) + (a[1] * b[6]) + (a[2] * b[5]) + (a[3] * b[4]) + (a[4] * b[3]) + (a[5] * b[2]) + (a[6] * b[1]) + (a[7] * b[0]);\n-        long c8 = (a[0] * b[8]) + (a[1] * b[7]) + (a[2] * b[6]) + (a[3] * b[5]) + (a[4] * b[4]) + (a[5] * b[3]) + (a[6] * b[2]) + (a[7] * b[1]) + (a[8] * b[0]);\n-        long c9 = (a[0] * b[9]) + (a[1] * b[8]) + (a[2] * b[7]) + (a[3] * b[6]) + (a[4] * b[5]) + (a[5] * b[4]) + (a[6] * b[3]) + (a[7] * b[2]) + (a[8] * b[1]) + (a[9] * b[0]);\n-        long c10 = (a[1] * b[9]) + (a[2] * b[8]) + (a[3] * b[7]) + (a[4] * b[6]) + (a[5] * b[5]) + (a[6] * b[4]) + (a[7] * b[3]) + (a[8] * b[2]) + (a[9] * b[1]);\n-        long c11 = (a[2] * b[9]) + (a[3] * b[8]) + (a[4] * b[7]) + (a[5] * b[6]) + (a[6] * b[5]) + (a[7] * b[4]) + (a[8] * b[3]) + (a[9] * b[2]);\n-        long c12 = (a[3] * b[9]) + (a[4] * b[8]) + (a[5] * b[7]) + (a[6] * b[6]) + (a[7] * b[5]) + (a[8] * b[4]) + (a[9] * b[3]);\n-        long c13 = (a[4] * b[9]) + (a[5] * b[8]) + (a[6] * b[7]) + (a[7] * b[6]) + (a[8] * b[5]) + (a[9] * b[4]);\n-        long c14 = (a[5] * b[9]) + (a[6] * b[8]) + (a[7] * b[7]) + (a[8] * b[6]) + (a[9] * b[5]);\n-        long c15 = (a[6] * b[9]) + (a[7] * b[8]) + (a[8] * b[7]) + (a[9] * b[6]);\n-        long c16 = (a[7] * b[9]) + (a[8] * b[8]) + (a[9] * b[7]);\n-        long c17 = (a[8] * b[9]) + (a[9] * b[8]);\n-        long c18 = a[9] * b[9];\n-\n-        carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8,\n-            c9, c10, c11, c12, c13, c14, c15, c16, c17, c18);\n-\n-    }\n-\n-    private void carryReduce(long[] r, long c0, long c1, long c2,\n-                             long c3, long c4, long c5, long c6,\n-                             long c7, long c8, long c9, long c10,\n-                             long c11, long c12, long c13, long c14,\n-                             long c15, long c16, long c17, long c18) {\n-        \/\/ reduce(7,2)\n-        long reducedValue17 = (c17 * SUBTRAHEND);\n-        c7 += (reducedValue17 << BIT_OFFSET) & LIMB_MASK;\n-        c8 += reducedValue17 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue18 = (c18 * SUBTRAHEND);\n-        c8 += (reducedValue18 << BIT_OFFSET) & LIMB_MASK;\n-        c9 += reducedValue18 >> RIGHT_BIT_OFFSET;\n-\n-        \/\/ carry(8,2)\n-        long carry8 = carryValue(c8);\n-        r[8] = c8 - (carry8 << BITS_PER_LIMB);\n-        c9 += carry8;\n-\n-        long carry9 = carryValue(c9);\n-        r[9] = c9 - (carry9 << BITS_PER_LIMB);\n-        c10 += carry9;\n-\n-        \/\/ reduce(0,7)\n-        long reducedValue10 = (c10 * SUBTRAHEND);\n-        r[0] = c0 + ((reducedValue10 << BIT_OFFSET) & LIMB_MASK);\n-        c1 += reducedValue10 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue11 = (c11 * SUBTRAHEND);\n-        r[1] = c1 + ((reducedValue11 << BIT_OFFSET) & LIMB_MASK);\n-        c2 += reducedValue11 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue12 = (c12 * SUBTRAHEND);\n-        r[2] = c2 + ((reducedValue12 << BIT_OFFSET) & LIMB_MASK);\n-        c3 += reducedValue12 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue13 = (c13 * SUBTRAHEND);\n-        r[3] = c3 + ((reducedValue13 << BIT_OFFSET) & LIMB_MASK);\n-        c4 += reducedValue13 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue14 = (c14 * SUBTRAHEND);\n-        r[4] = c4 + ((reducedValue14 << BIT_OFFSET) & LIMB_MASK);\n-        c5 += reducedValue14 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue15 = (c15 * SUBTRAHEND);\n-        r[5] = c5 + ((reducedValue15 << BIT_OFFSET) & LIMB_MASK);\n-        c6 += reducedValue15 >> RIGHT_BIT_OFFSET;\n-\n-        long reducedValue16 = (c16 * SUBTRAHEND);\n-        r[6] = c6 + ((reducedValue16 << BIT_OFFSET) & LIMB_MASK);\n-        r[7] = c7 + (reducedValue16 >> RIGHT_BIT_OFFSET);\n-\n-        \/\/ carry(0,9)\n-        carry(r, 0, 9);\n-    }\n-    @Override\n-    protected void square(long[] a, long[] r) {\n-\n-        \/\/ Use grade-school multiplication with a simple squaring optimization.\n-        \/\/ Multiply into primitives to avoid the temporary array allocation.\n-        \/\/ This is equivalent to the following code:\n-        \/\/  long[] c = new long[2 * NUM_LIMBS - 1];\n-        \/\/  for(int i = 0; i < NUM_LIMBS; i++) {\n-        \/\/      c[2 * i] = a[i] * a[i];\n-        \/\/      for(int j = i + 1; j < NUM_LIMBS; j++) {\n-        \/\/          c[i + j] += 2 * a[i] * a[j]\n-        \/\/      }\n-        \/\/  }\n-\n-        long c0 = a[0] * a[0];\n-        long c1 = 2 * a[0] * a[1];\n-        long c2 = a[1] * a[1] + 2 * a[0] * a[2];\n-        long c3 = 2 * (a[0] * a[3] + a[1] * a[2]);\n-        long c4 = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3]);\n-        long c5 = 2 * (a[0] * a[5] + a[1] * a[4] + a[2] * a[3]);\n-        long c6 = a[3] * a[3] + 2 * (a[0] * a[6] + a[1] * a[5] + a[2] * a[4]);\n-        long c7 = 2 * (a[0] * a[7] + a[1] * a[6] + a[2] * a[5] + a[3] * a[4]);\n-        long c8 = a[4] * a[4] + 2 * (a[0] * a[8] + a[1] * a[7] + a[2] * a[6] + a[3] * a[5]);\n-        long c9 = 2 * (a[0] * a[9] + a[1] * a[8] + a[2] * a[7] + a[3] * a[6] + a[4] * a[5]);\n-        long c10 = a[5] * a[5] + 2 * (a[1] * a[9] + a[2] * a[8] + a[3] * a[7] + a[4] * a[6]);\n-        long c11 = 2 * (a[2] * a[9] + a[3] * a[8] + a[4] * a[7] + a[5] * a[6]);\n-        long c12 = a[6] * a[6] + 2 * (a[3] * a[9] + a[4] * a[8] + a[5] * a[7]);\n-        long c13 = 2 * (a[4] * a[9] + a[5] * a[8] + a[6] * a[7]);\n-        long c14 = a[7] * a[7] + 2 * (a[5] * a[9] + a[6] * a[8]);\n-        long c15 = 2 * (a[6] * a[9] + a[7] * a[8]);\n-        long c16 = a[8] * a[8] + 2 * a[7] * a[9];\n-        long c17 = 2 * a[8] * a[9];\n-        long c18 = a[9] * a[9];\n-\n-        carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8,\n-            c9, c10, c11, c12, c13, c14, c15, c16, c17, c18);\n-    }\n-\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial25519.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -1,252 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.util.math.intpoly;\n-\n-import java.math.BigInteger;\n-\n-\/**\n- * An IntegerFieldModuloP designed for use with the Curve448.\n- * The representation uses 16 signed long values.\n- *\/\n-\n-public final class IntegerPolynomial448 extends IntegerPolynomial {\n-\n-    private static final int POWER = 448;\n-    private static final int NUM_LIMBS = 16;\n-    private static final int BITS_PER_LIMB = 28;\n-    public static final BigInteger MODULUS\n-        = TWO.pow(POWER).subtract(TWO.pow(POWER \/ 2))\n-            .subtract(BigInteger.valueOf(1));\n-\n-    public IntegerPolynomial448() {\n-        super(BITS_PER_LIMB, NUM_LIMBS, 1, MODULUS);\n-    }\n-\n-    @Override\n-    protected void reduceIn(long[] limbs, long v, int i) {\n-        limbs[i - 8] += v;\n-        limbs[i - 16] += v;\n-    }\n-\n-    @Override\n-    protected void finalCarryReduceLast(long[] limbs) {\n-        long carry = limbs[numLimbs - 1] >> bitsPerLimb;\n-        limbs[numLimbs - 1] -= carry << bitsPerLimb;\n-        reduceIn(limbs, carry, numLimbs);\n-    }\n-\n-    @Override\n-    protected void reduce(long[] a) {\n-\n-        \/\/ carry(14, 2)\n-        long carry14 = carryValue(a[14]);\n-        a[14] -= (carry14 << BITS_PER_LIMB);\n-        a[15] += carry14;\n-\n-        long carry15 = carryValue(a[15]);\n-        a[15] -= (carry15 << BITS_PER_LIMB);\n-\n-        \/\/ reduce(0, 1)\n-        a[0] += carry15;\n-        a[8] += carry15;\n-\n-        \/\/ carry(0, 15)\n-        carry(a, 0, 15);\n-    }\n-\n-    @Override\n-    protected void mult(long[] a, long[] b, long[] r) {\n-\n-        \/\/ Use grade-school multiplication into primitives to avoid the\n-        \/\/ temporary array allocation. This is equivalent to the following\n-        \/\/ code:\n-        \/\/  long[] c = new long[2 * NUM_LIMBS - 1];\n-        \/\/  for(int i = 0; i < NUM_LIMBS; i++) {\n-        \/\/      for(int j - 0; j < NUM_LIMBS; j++) {\n-        \/\/          c[i + j] += a[i] * b[j]\n-        \/\/      }\n-        \/\/  }\n-\n-        long c0 = (a[0] * b[0]);\n-        long c1 = (a[0] * b[1]) + (a[1] * b[0]);\n-        long c2 = (a[0] * b[2]) + (a[1] * b[1]) + (a[2] * b[0]);\n-        long c3 = (a[0] * b[3]) + (a[1] * b[2]) + (a[2] * b[1]) + (a[3] * b[0]);\n-        long c4 = (a[0] * b[4]) + (a[1] * b[3]) + (a[2] * b[2]) + (a[3] * b[1]) + (a[4] * b[0]);\n-        long c5 = (a[0] * b[5]) + (a[1] * b[4]) + (a[2] * b[3]) + (a[3] * b[2]) + (a[4] * b[1]) + (a[5] * b[0]);\n-        long c6 = (a[0] * b[6]) + (a[1] * b[5]) + (a[2] * b[4]) + (a[3] * b[3]) + (a[4] * b[2]) + (a[5] * b[1]) + (a[6] * b[0]);\n-        long c7 = (a[0] * b[7]) + (a[1] * b[6]) + (a[2] * b[5]) + (a[3] * b[4]) + (a[4] * b[3]) + (a[5] * b[2]) + (a[6] * b[1]) + (a[7] * b[0]);\n-        long c8 = (a[0] * b[8]) + (a[1] * b[7]) + (a[2] * b[6]) + (a[3] * b[5]) + (a[4] * b[4]) + (a[5] * b[3]) + (a[6] * b[2]) + (a[7] * b[1]) + (a[8] * b[0]);\n-        long c9 = (a[0] * b[9]) + (a[1] * b[8]) + (a[2] * b[7]) + (a[3] * b[6]) + (a[4] * b[5]) + (a[5] * b[4]) + (a[6] * b[3]) + (a[7] * b[2]) + (a[8] * b[1]) + (a[9] * b[0]);\n-        long c10 = (a[0] * b[10]) + (a[1] * b[9]) + (a[2] * b[8]) + (a[3] * b[7]) + (a[4] * b[6]) + (a[5] * b[5]) + (a[6] * b[4]) + (a[7] * b[3]) + (a[8] * b[2]) + (a[9] * b[1]) + (a[10] * b[0]);\n-        long c11 = (a[0] * b[11]) + (a[1] * b[10]) + (a[2] * b[9]) + (a[3] * b[8]) + (a[4] * b[7]) + (a[5] * b[6]) + (a[6] * b[5]) + (a[7] * b[4]) + (a[8] * b[3]) + (a[9] * b[2]) + (a[10] * b[1]) + (a[11] * b[0]);\n-        long c12 = (a[0] * b[12]) + (a[1] * b[11]) + (a[2] * b[10]) + (a[3] * b[9]) + (a[4] * b[8]) + (a[5] * b[7]) + (a[6] * b[6]) + (a[7] * b[5]) + (a[8] * b[4]) + (a[9] * b[3]) + (a[10] * b[2]) + (a[11] * b[1]) + (a[12] * b[0]);\n-        long c13 = (a[0] * b[13]) + (a[1] * b[12]) + (a[2] * b[11]) + (a[3] * b[10]) + (a[4] * b[9]) + (a[5] * b[8]) + (a[6] * b[7]) + (a[7] * b[6]) + (a[8] * b[5]) + (a[9] * b[4]) + (a[10] * b[3]) + (a[11] * b[2]) + (a[12] * b[1]) + (a[13] * b[0]);\n-        long c14 = (a[0] * b[14]) + (a[1] * b[13]) + (a[2] * b[12]) + (a[3] * b[11]) + (a[4] * b[10]) + (a[5] * b[9]) + (a[6] * b[8]) + (a[7] * b[7]) + (a[8] * b[6]) + (a[9] * b[5]) + (a[10] * b[4]) + (a[11] * b[3]) + (a[12] * b[2]) + (a[13] * b[1]) + (a[14] * b[0]);\n-        long c15 = (a[0] * b[15]) + (a[1] * b[14]) + (a[2] * b[13]) + (a[3] * b[12]) + (a[4] * b[11]) + (a[5] * b[10]) + (a[6] * b[9]) + (a[7] * b[8]) + (a[8] * b[7]) + (a[9] * b[6]) + (a[10] * b[5]) + (a[11] * b[4]) + (a[12] * b[3]) + (a[13] * b[2]) + (a[14] * b[1]) + (a[15] * b[0]);\n-        long c16 = (a[1] * b[15]) + (a[2] * b[14]) + (a[3] * b[13]) + (a[4] * b[12]) + (a[5] * b[11]) + (a[6] * b[10]) + (a[7] * b[9]) + (a[8] * b[8]) + (a[9] * b[7]) + (a[10] * b[6]) + (a[11] * b[5]) + (a[12] * b[4]) + (a[13] * b[3]) + (a[14] * b[2]) + (a[15] * b[1]);\n-        long c17 = (a[2] * b[15]) + (a[3] * b[14]) + (a[4] * b[13]) + (a[5] * b[12]) + (a[6] * b[11]) + (a[7] * b[10]) + (a[8] * b[9]) + (a[9] * b[8]) + (a[10] * b[7]) + (a[11] * b[6]) + (a[12] * b[5]) + (a[13] * b[4]) + (a[14] * b[3]) + (a[15] * b[2]);\n-        long c18 = (a[3] * b[15]) + (a[4] * b[14]) + (a[5] * b[13]) + (a[6] * b[12]) + (a[7] * b[11]) + (a[8] * b[10]) + (a[9] * b[9]) + (a[10] * b[8]) + (a[11] * b[7]) + (a[12] * b[6]) + (a[13] * b[5]) + (a[14] * b[4]) + (a[15] * b[3]);\n-        long c19 = (a[4] * b[15]) + (a[5] * b[14]) + (a[6] * b[13]) + (a[7] * b[12]) + (a[8] * b[11]) + (a[9] * b[10]) + (a[10] * b[9]) + (a[11] * b[8]) + (a[12] * b[7]) + (a[13] * b[6]) + (a[14] * b[5]) + (a[15] * b[4]);\n-        long c20 = (a[5] * b[15]) + (a[6] * b[14]) + (a[7] * b[13]) + (a[8] * b[12]) + (a[9] * b[11]) + (a[10] * b[10]) + (a[11] * b[9]) + (a[12] * b[8]) + (a[13] * b[7]) + (a[14] * b[6]) + (a[15] * b[5]);\n-        long c21 = (a[6] * b[15]) + (a[7] * b[14]) + (a[8] * b[13]) + (a[9] * b[12]) + (a[10] * b[11]) + (a[11] * b[10]) + (a[12] * b[9]) + (a[13] * b[8]) + (a[14] * b[7]) + (a[15] * b[6]);\n-        long c22 = (a[7] * b[15]) + (a[8] * b[14]) + (a[9] * b[13]) + (a[10] * b[12]) + (a[11] * b[11]) + (a[12] * b[10]) + (a[13] * b[9]) + (a[14] * b[8]) + (a[15] * b[7]);\n-        long c23 = (a[8] * b[15]) + (a[9] * b[14]) + (a[10] * b[13]) + (a[11] * b[12]) + (a[12] * b[11]) + (a[13] * b[10]) + (a[14] * b[9]) + (a[15] * b[8]);\n-        long c24 = (a[9] * b[15]) + (a[10] * b[14]) + (a[11] * b[13]) + (a[12] * b[12]) + (a[13] * b[11]) + (a[14] * b[10]) + (a[15] * b[9]);\n-        long c25 = (a[10] * b[15]) + (a[11] * b[14]) + (a[12] * b[13]) + (a[13] * b[12]) + (a[14] * b[11]) + (a[15] * b[10]);\n-        long c26 = (a[11] * b[15]) + (a[12] * b[14]) + (a[13] * b[13]) + (a[14] * b[12]) + (a[15] * b[11]);\n-        long c27 = (a[12] * b[15]) + (a[13] * b[14]) + (a[14] * b[13]) + (a[15] * b[12]);\n-        long c28 = (a[13] * b[15]) + (a[14] * b[14]) + (a[15] * b[13]);\n-        long c29 = (a[14] * b[15]) + (a[15] * b[14]);\n-        long c30 = (a[15] * b[15]);\n-\n-        carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,\n-            c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25,\n-            c26, c27, c28, c29, c30);\n-    }\n-\n-    private void carryReduce(long[] r, long c0, long c1, long c2, long c3,\n-                             long c4, long c5, long c6, long c7, long c8,\n-                             long c9, long c10, long c11, long c12, long c13,\n-                             long c14, long c15, long c16, long c17, long c18,\n-                             long c19, long c20, long c21, long c22, long c23,\n-                             long c24, long c25, long c26, long c27, long c28,\n-                             long c29, long c30) {\n-\n-        \/\/ reduce(8, 7)\n-        c8 += c24;\n-        c16 += c24;\n-\n-        c9 += c25;\n-        c17 += c25;\n-\n-        c10 += c26;\n-        c18 += c26;\n-\n-        c11 += c27;\n-        c19 += c27;\n-\n-        c12 += c28;\n-        c20 += c28;\n-\n-        c13 += c29;\n-        c21 += c29;\n-\n-        c14 += c30;\n-        c22 += c30;\n-\n-        \/\/ reduce(4, 4)\n-        r[4] = c4 + c20;\n-        r[12] = c12 + c20;\n-\n-        r[5] = c5 + c21;\n-        r[13] = c13 + c21;\n-\n-        r[6] = c6 + c22;\n-        c14 += c22;\n-\n-        r[7] = c7 + c23;\n-        c15 += c23;\n-\n-        \/\/carry(14, 2)\n-        long carry14 = carryValue(c14);\n-        r[14] = c14 - (carry14 << BITS_PER_LIMB);\n-        c15 += carry14;\n-\n-        long carry15 = carryValue(c15);\n-        r[15] = c15 - (carry15 << BITS_PER_LIMB);\n-        c16 += carry15;\n-\n-        \/\/ reduce(0, 4)\n-        r[0] = c0 + c16;\n-        r[8] = c8 + c16;\n-\n-        r[1] = c1 + c17;\n-        r[9] = c9 + c17;\n-\n-        r[2] =  c2 + c18;\n-        r[10] = c10 + c18;\n-\n-        r[3] = c3 + c19;\n-        r[11] = c11 + c19;\n-\n-        \/\/ carry(0, 15)\n-        carry(r, 0, 15);\n-    }\n-\n-    @Override\n-    protected void square(long[] a, long[] r) {\n-\n-        \/\/ Use grade-school multiplication with a simple squaring optimization.\n-        \/\/ Multiply into primitives to avoid the temporary array allocation.\n-        \/\/ This is equivalent to the following code:\n-        \/\/  long[] c = new long[2 * NUM_LIMBS - 1];\n-        \/\/  for(int i = 0; i < NUM_LIMBS; i++) {\n-        \/\/      c[2 * i] = a[i] * a[i];\n-        \/\/      for(int j = i + 1; j < NUM_LIMBS; j++) {\n-        \/\/          c[i + j] += 2 * a[i] * a[j]\n-        \/\/      }\n-        \/\/  }\n-\n-        long c0 = a[0] * a[0];\n-        long c1 = 2 * a[0] * a[1];\n-        long c2 = a[1] * a[1] + 2 * a[0] * a[2];\n-        long c3 = 2 * (a[0] * a[3] + a[1] * a[2]);\n-        long c4 = a[2] * a[2] + 2 * (a[0] * a[4] + a[1] * a[3]);\n-        long c5 = 2 * (a[0] * a[5] + a[1] * a[4] + a[2] * a[3]);\n-        long c6 = a[3] * a[3] + 2 * (a[0] * a[6] + a[1] * a[5] + a[2] * a[4]);\n-        long c7 = 2 * (a[0] * a[7] + a[1] * a[6] + a[2] * a[5] + a[3] * a[4]);\n-        long c8 = a[4] * a[4] + 2 * (a[0] * a[8] + a[1] * a[7] + a[2] * a[6] + a[3] * a[5]);\n-        long c9 = 2 * (a[0] * a[9] + a[1] * a[8] + a[2] * a[7] + a[3] * a[6] + a[4] * a[5]);\n-        long c10 = a[5] * a[5] + 2 * (a[0] * a[10] + a[1] * a[9] + a[2] * a[8] + a[3] * a[7] + a[4] * a[6]);\n-        long c11 = 2 * (a[0] * a[11] + a[1] * a[10] + a[2] * a[9] + a[3] * a[8] + a[4] * a[7] + a[5] * a[6]);\n-        long c12 = a[6] * a[6] + 2 * (a[0] * a[12] + a[1] * a[11] + a[2] * a[10] + a[3] * a[9] + a[4] * a[8] + a[5] * a[7]);\n-        long c13 = 2 * (a[0] * a[13] + a[1] * a[12] + a[2] * a[11] + a[3] * a[10] + a[4] * a[9] + a[5] * a[8] + a[6] * a[7]);\n-        long c14 = a[7] * a[7] + 2 * (a[0] * a[14] + a[1] * a[13] + a[2] * a[12] + a[3] * a[11] + a[4] * a[10] + a[5] * a[9] + a[6] * a[8]);\n-        long c15 = 2 * (a[0] * a[15] + a[1] * a[14] + a[2] * a[13] + a[3] * a[12] + a[4] * a[11] + a[5] * a[10] + a[6] * a[9] + a[7] * a[8]);\n-        long c16 = a[8] * a[8] + 2 * (a[1] * a[15] + a[2] * a[14] + a[3] * a[13] + a[4] * a[12] + a[5] * a[11] + a[6] * a[10] + a[7] * a[9]);\n-        long c17 = 2 * (a[2] * a[15] + a[3] * a[14] + a[4] * a[13] + a[5] * a[12] + a[6] * a[11] + a[7] * a[10] + a[8] * a[9]);\n-        long c18 = a[9] * a[9] + 2 * (a[3] * a[15] + a[4] * a[14] + a[5] * a[13] + a[6] * a[12] + a[7] * a[11] + a[8] * a[10]);\n-        long c19 = 2 * (a[4] * a[15] + a[5] * a[14] + a[6] * a[13] + a[7] * a[12] + a[8] * a[11] + a[9] * a[10]);\n-        long c20 = a[10] * a[10] + 2 * (a[5] * a[15] + a[6] * a[14] + a[7] * a[13] + a[8] * a[12] + a[9] * a[11]);\n-        long c21 = 2 * (a[6] * a[15] + a[7] * a[14] + a[8] * a[13] + a[9] * a[12] + a[10] * a[11]);\n-        long c22 = a[11] * a[11] + 2 * (a[7] * a[15] + a[8] * a[14] + a[9] * a[13] + a[10] * a[12]);\n-        long c23 = 2 * (a[8] * a[15] + a[9] * a[14] + a[10] * a[13] + a[11] * a[12]);\n-        long c24 = a[12] * a[12] + 2 * (a[9] * a[15] + a[10] * a[14] + a[11] * a[13]);\n-        long c25 = 2 * (a[10] * a[15] + a[11] * a[14] + a[12] * a[13]);\n-        long c26 = a[13] * a[13] + 2 * (a[11] * a[15] + a[12] * a[14]);\n-        long c27 = 2 * (a[12] * a[15] + a[13] * a[14]);\n-        long c28 = a[14] * a[14] + 2 * a[13] * a[15];\n-        long c29 = 2 * a[14] * a[15];\n-        long c30 = a[15] * a[15];\n-\n-        carryReduce(r, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,\n-            c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25,\n-            c26, c27, c28, c29, c30);\n-\n-    }\n-\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial448.java","additions":0,"deletions":252,"binary":false,"changes":252,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,3 @@\n-        IntegerPolynomialP256.MODULUS, new IntegerPolynomialP256(),\n-        IntegerPolynomialP384.MODULUS, new IntegerPolynomialP384(),\n-        IntegerPolynomialP521.MODULUS, new IntegerPolynomialP521()\n+        IntegerPolynomialP256.MODULUS, IntegerPolynomial.Holder.P256,\n+        IntegerPolynomialP384.MODULUS, IntegerPolynomial.Holder.P384,\n+        IntegerPolynomialP521.MODULUS, IntegerPolynomial.Holder.P521\n@@ -65,3 +65,3 @@\n-        P256OrderField.MODULUS, new P256OrderField(),\n-        P384OrderField.MODULUS, new P384OrderField(),\n-        P521OrderField.MODULUS, new P521OrderField()\n+        P256OrderField.MODULUS, IntegerPolynomial.Holder.PO256,\n+        P384OrderField.MODULUS, IntegerPolynomial.Holder.PO384,\n+        P521OrderField.MODULUS, IntegerPolynomial.Holder.PO521\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import sun.security.util.math.intpoly.IntegerPolynomial;\n@@ -189,1 +190,1 @@\n-            return new IntegerPolynomial25519();\n+            return IntegerPolynomial.Holder.P25519;\n@@ -192,1 +193,1 @@\n-            return new IntegerPolynomial448();\n+            return IntegerPolynomial.Holder.P448;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XECOperations.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,2 +262,2 @@\n-        IntegerFieldModuloP ed25519Field = new IntegerPolynomial25519();\n-        IntegerFieldModuloP ed25519OrderField = new Curve25519OrderField();\n+        IntegerFieldModuloP ed25519Field = IntegerPolynomial.Holder.P25519;\n+        IntegerFieldModuloP ed25519OrderField = IntegerPolynomial.Holder.PO25519;\n@@ -283,2 +283,2 @@\n-        IntegerFieldModuloP ed448Field = new IntegerPolynomial448();\n-        IntegerFieldModuloP ed448OrderField = new Curve448OrderField();\n+        IntegerFieldModuloP ed448Field = IntegerPolynomial.Holder.P448;\n+        IntegerFieldModuloP ed448OrderField = IntegerPolynomial.Holder.PO448;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAParameters.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,11 +30,11 @@\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomial25519 32 0\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomial448 56 1\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomial1305 16 2\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomialP256 32 5\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomialP384 48 6\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.IntegerPolynomialP521 66 7\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.P256OrderField 32 8\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.P384OrderField 48 9\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.P521OrderField 66 10\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.Curve25519OrderField 32 11\n- * @run main TestIntegerModuloP sun.security.util.math.intpoly.Curve448OrderField 56 12\n+ * @run main TestIntegerModuloP P25519 32 0\n+ * @run main TestIntegerModuloP P448 56 1\n+ * @run main TestIntegerModuloP P1305 16 2\n+ * @run main TestIntegerModuloP P256 32 5\n+ * @run main TestIntegerModuloP P384 48 6\n+ * @run main TestIntegerModuloP P521 66 7\n+ * @run main TestIntegerModuloP PO256 32 8\n+ * @run main TestIntegerModuloP PO384 48 9\n+ * @run main TestIntegerModuloP PO521 66 10\n+ * @run main TestIntegerModuloP PO25519 32 11\n+ * @run main TestIntegerModuloP PO448 56 12\n@@ -121,1 +121,1 @@\n-        String className = args[0];\n+        String fieldName = args[0];\n@@ -125,1 +125,0 @@\n-        Class<IntegerFieldModuloP> fieldBaseClass = IntegerFieldModuloP.class;\n@@ -127,4 +126,2 @@\n-            Class<? extends IntegerFieldModuloP> clazz =\n-                Class.forName(className).asSubclass(fieldBaseClass);\n-            IntegerFieldModuloP field =\n-                clazz.getDeclaredConstructor().newInstance();\n+            IntegerFieldModuloP field = (IntegerFieldModuloP)\n+                    IntegerPolynomial.Holder.class.getDeclaredField(fieldName).get(null);\n","filename":"test\/jdk\/sun\/security\/util\/math\/TestIntegerModuloP.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"}]}