{"files":[{"patch":"@@ -49,0 +49,4 @@\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -1914,1 +1918,0 @@\n-\n@@ -1923,0 +1926,1 @@\n+  JFR_ONLY(Jfr::on_resolution(this, holder, target); CHECK_BAILOUT();)\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+  friend class JfrResolution;\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,0 @@\n-  Symbol* get_symbol() const { return _symbol; }\n-\n@@ -109,0 +107,3 @@\n+\n+  Symbol* get_symbol() const { return _symbol; }\n+\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -1095,0 +1099,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n@@ -1300,0 +1305,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n@@ -1420,0 +1426,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n@@ -1531,0 +1538,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n@@ -1702,0 +1710,1 @@\n+    JFR_ONLY(Jfr::on_resolution(result, CHECK_false);)\n@@ -1733,0 +1742,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n@@ -1814,0 +1824,1 @@\n+  JFR_ONLY(Jfr::on_resolution(result, CHECK);)\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -50,0 +50,1 @@\n+#include \"oops\/constMethod.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -60,0 +62,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -71,1 +74,1 @@\n-  \"eventHandler\", \/\/ 3\n+  \"eventConfiguration\", \/\/ 3\n@@ -80,1 +83,1 @@\n-  \"Ljdk\/jfr\/internal\/handlers\/EventHandler;\", \/\/ 12\n+  \"Ljdk\/jfr\/internal\/event\/EventConfiguration;\", \/\/ 12\n@@ -98,1 +101,1 @@\n-  UTF8_REQ_eventHandler,\n+  UTF8_REQ_eventConfiguration,\n@@ -111,1 +114,1 @@\n-  UTF8_OPT_eventHandler_FIELD_DESC = NOF_UTF8_REQ_SYMBOLS,\n+  UTF8_OPT_eventConfiguration_FIELD_DESC = NOF_UTF8_REQ_SYMBOLS,\n@@ -568,1 +571,1 @@\n-static u2 add_field_infos(JfrBigEndianWriter& writer, const u2* utf8_indexes, bool untypedEventHandler) {\n+static u2 add_field_infos(JfrBigEndianWriter& writer, const u2* utf8_indexes, bool untypedEventConfiguration) {\n@@ -571,2 +574,2 @@\n-                 utf8_indexes[UTF8_REQ_eventHandler],\n-                 untypedEventHandler ? utf8_indexes[UTF8_OPT_LjavaLangObject] : utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC],\n+                 utf8_indexes[UTF8_REQ_eventConfiguration],\n+                 untypedEventConfiguration ? utf8_indexes[UTF8_OPT_LjavaLangObject] : utf8_indexes[UTF8_OPT_eventConfiguration_FIELD_DESC],\n@@ -1114,0 +1117,27 @@\n+static Symbol* begin = NULL;\n+static Symbol* end = NULL;\n+static Symbol* commit = NULL;\n+static Symbol* isEnabled = NULL;\n+static Symbol* shouldCommit = NULL;\n+static Symbol* void_method_sig = NULL;\n+static Symbol* boolean_method_sig = NULL;\n+\n+static void initialize_symbols() {\n+  if (begin == NULL) {\n+    begin = SymbolTable::probe(\"begin\", 5);\n+    assert(begin != NULL, \"invariant\");\n+    end = SymbolTable::probe(\"end\", 3);\n+    assert(end != NULL, \"invariant\");\n+    commit = SymbolTable::probe(\"commit\", 6);\n+    assert(commit != NULL, \"invariant\");\n+    isEnabled = SymbolTable::probe(\"isEnabled\", 9);\n+    assert(isEnabled != NULL, \"invariant\");\n+    shouldCommit = SymbolTable::probe(\"shouldCommit\", 12);\n+    assert(shouldCommit != NULL, \"invariant\");\n+    void_method_sig = SymbolTable::probe(\"()V\", 3);\n+    assert(void_method_sig != NULL, \"invariant\");\n+    boolean_method_sig = SymbolTable::probe(\"()Z\", 3);\n+    assert(boolean_method_sig != NULL, \"invariant\");\n+  }\n+}\n+\n@@ -1115,1 +1145,1 @@\n-static ClassFileStream* create_new_bytes_for_event_klass(const InstanceKlass* ik, const ClassFileParser& parser, TRAPS) {\n+static ClassFileStream* schema_extend_event_klass_bytes(const InstanceKlass* ik, const ClassFileParser& parser, TRAPS) {\n@@ -1117,0 +1147,1 @@\n+  initialize_symbols();\n@@ -1119,0 +1150,1 @@\n+  assert(orig_stream != NULL, \"invariant\");\n@@ -1205,1 +1237,1 @@\n-                               bool untypedEventHandler,\n+                               bool untypedEventConfiguration,\n@@ -1215,2 +1247,2 @@\n-  utf8_indexes[UTF8_OPT_eventHandler_FIELD_DESC] = untypedEventHandler ? invalid_cp_index :\n-    find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_eventHandler_FIELD_DESC], orig_cp_len, added_cp_entries, THREAD);\n+  utf8_indexes[UTF8_OPT_eventConfiguration_FIELD_DESC] = untypedEventConfiguration ? invalid_cp_index :\n+    find_or_add_utf8_info(writer, ik, utf8_constants[UTF8_OPT_eventConfiguration_FIELD_DESC], orig_cp_len, added_cp_entries, THREAD);\n@@ -1218,1 +1250,1 @@\n-  utf8_indexes[UTF8_OPT_LjavaLangObject] = untypedEventHandler ?\n+  utf8_indexes[UTF8_OPT_LjavaLangObject] = untypedEventConfiguration ?\n@@ -1264,1 +1296,1 @@\n-static u1* new_bytes_for_lazy_instrumentation(const InstanceKlass* ik,\n+static u1* schema_extend_event_subklass_bytes(const InstanceKlass* ik,\n@@ -1286,1 +1318,1 @@\n-      \" bytes failed in JfrClassAdapter::on_klass_creation\", (size_t)new_buffer_size);\n+      \" bytes failed in JfrEventClassTransformer::on_klass_creation\", static_cast<size_t>(new_buffer_size));\n@@ -1385,0 +1417,4 @@\n+static bool should_force_instrumentation() {\n+  return !JfrOptionSet::allow_event_retransforms() || JfrEventClassTransformer::is_force_instrumentation();\n+}\n+\n@@ -1396,2 +1432,16 @@\n-static bool should_force_instrumentation() {\n-  return !JfrOptionSet::allow_event_retransforms() || JfrEventClassTransformer::is_force_instrumentation();\n+static bool has_pending_exception(TRAPS) {\n+  assert(THREAD != NULL, \"invariant\");\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_pending_exception(PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static bool has_local_method_implementation(const InstanceKlass* ik, const Symbol* name, const Symbol* signature) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(name != NULL, \"invariant\");\n+  assert(signature != NULL, \"invariant\");\n+  return NULL != ik->find_local_method(name, signature, Klass::OverpassLookupMode::skip, Klass::StaticLookupMode::find,\n+                                          Klass::PrivateLookupMode::find);\n@@ -1400,1 +1450,12 @@\n-static ClassFileStream* create_new_bytes_for_subklass(const InstanceKlass* ik, const ClassFileParser& parser, JavaThread* t) {\n+\/\/ If for a subklass, on initial class load, an implementation exist for any of the final methods declared in Event,\n+\/\/ then constraints are considered breached.\n+static bool invalid_preconditions_for_subklass_on_initial_load(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  return has_local_method_implementation(ik, begin, void_method_sig) ||\n+         has_local_method_implementation(ik, end, void_method_sig) ||\n+         has_local_method_implementation(ik, commit, void_method_sig) ||\n+         has_local_method_implementation(ik, isEnabled, boolean_method_sig) ||\n+         has_local_method_implementation(ik, shouldCommit, boolean_method_sig);\n+}\n+\n+static ClassFileStream* schema_extend_event_subklass_bytes(const InstanceKlass* ik, const ClassFileParser& parser, bool& is_instrumented, TRAPS) {\n@@ -1402,1 +1463,8 @@\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(t));\n+  assert(!is_instrumented, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (invalid_preconditions_for_subklass_on_initial_load(ik)) {\n+    \/\/ Remove the tag denoting this as a jdk.jfr.Event subklass. No instrumentation, hence no events can be written.\n+    \/\/ The class is allowed to load as-is, but it is classified as outside of the jfr system.\n+    JdkJfrEvent::remove(ik);\n+    return NULL;\n+  }\n@@ -1404,1 +1472,1 @@\n-  const u1* new_bytes = new_bytes_for_lazy_instrumentation(ik, parser, size_of_new_bytes, t);\n+  const u1* new_bytes = schema_extend_event_subklass_bytes(ik, parser, size_of_new_bytes, THREAD);\n@@ -1410,2 +1478,1 @@\n-\n-  bool force_instrumentation = should_force_instrumentation();\n+  const bool force_instrumentation = should_force_instrumentation();\n@@ -1413,3 +1480,4 @@\n-    jint size_instrumented_data = 0;\n-    unsigned char* instrumented_data = NULL;\n-    const jclass super = (jclass)JNIHandles::make_local(ik->super()->java_mirror());\n+    jint size_of_instrumented_bytes = 0;\n+    unsigned char* instrumented_bytes = NULL;\n+    const jclass super = static_cast<jclass>(JfrJavaSupport::local_jni_handle(ik->super()->java_mirror(), THREAD));\n+    const jboolean boot_class_loader = ik->class_loader_data()->is_boot_class_loader_data();\n@@ -1418,0 +1486,1 @@\n+                                                boot_class_loader,\n@@ -1421,6 +1490,5 @@\n-                                                &size_instrumented_data,\n-                                                &instrumented_data,\n-                                                t);\n-    if (t->has_pending_exception()) {\n-      log_pending_exception(t->pending_exception());\n-      t->clear_pending_exception();\n+                                                &size_of_instrumented_bytes,\n+                                                &instrumented_bytes,\n+                                                THREAD);\n+    JfrJavaSupport::destroy_local_jni_handle(super);\n+    if (has_pending_exception(THREAD)) {\n@@ -1429,3 +1497,5 @@\n-    assert(instrumented_data != NULL, \"invariant\");\n-    assert(size_instrumented_data > 0, \"invariant\");\n-    return new ClassFileStream(instrumented_data, size_instrumented_data, NULL, ClassFileStream::verify);\n+    assert(instrumented_bytes != NULL, \"invariant\");\n+    assert(size_of_instrumented_bytes > 0, \"invariant\");\n+    new_bytes = instrumented_bytes;\n+    size_of_new_bytes = size_of_instrumented_bytes;\n+    is_instrumented = true;\n@@ -1436,2 +1506,42 @@\n-static bool cache_bytes(InstanceKlass* ik, ClassFileStream* new_stream, InstanceKlass* new_ik, TRAPS) {\n-  assert(ik != NULL, \"invariant\");\n+static bool _force_instrumentation = false;\n+\n+void JfrEventClassTransformer::set_force_instrumentation(bool force_instrumentation) {\n+  _force_instrumentation = force_instrumentation;\n+}\n+\n+bool JfrEventClassTransformer::is_force_instrumentation() {\n+  return _force_instrumentation;\n+}\n+\n+static ClassFileStream* retransform_bytes(const Klass* existing_klass, const ClassFileParser& parser, bool& is_instrumented, TRAPS) {\n+  assert(existing_klass != NULL, \"invariant\");\n+  assert(!is_instrumented, \"invariant\");\n+  assert(JdkJfrEvent::is_a(existing_klass) || JdkJfrEvent::is_host(existing_klass), \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  jint size_of_new_bytes = 0;\n+  unsigned char* new_bytes = NULL;\n+  {\n+    ResourceMark rm(THREAD);\n+    const ClassFileStream* const stream = parser.clone_stream();\n+    assert(stream != NULL, \"invariant\");\n+    const jclass clazz = static_cast<jclass>(JfrJavaSupport::local_jni_handle(existing_klass->java_mirror(), THREAD));\n+    JfrUpcalls::on_retransform(JfrTraceId::load_raw(existing_klass),\n+                               clazz,\n+                               stream->length(),\n+                               stream->buffer(),\n+                               &size_of_new_bytes,\n+                               &new_bytes,\n+                               THREAD);\n+    JfrJavaSupport::destroy_local_jni_handle(clazz);\n+    if (has_pending_exception(THREAD)) {\n+      return NULL;\n+    }\n+  }\n+  assert(new_bytes != NULL, \"invariant\");\n+  assert(size_of_new_bytes > 0, \"invariant\");\n+  is_instrumented = true;\n+  return new ClassFileStream(new_bytes, size_of_new_bytes, NULL, ClassFileStream::verify);\n+}\n+\n+\/\/ On initial class load.\n+static void cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread) {\n@@ -1439,1 +1549,0 @@\n-  assert(new_ik->name() != NULL, \"invariant\");\n@@ -1441,4 +1550,4 @@\n-  assert(!HAS_PENDING_EXCEPTION, \"invariant\");\n-  static const bool can_retransform = JfrOptionSet::allow_retransforms();\n-  if (!can_retransform) {\n-    return true;\n+  assert(thread != NULL, \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  if (!JfrOptionSet::allow_retransforms()) {\n+    return;\n@@ -1450,3 +1559,3 @@\n-    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for \" SIZE_FORMAT\n-      \" bytes failed in JfrClassAdapter::on_klass_creation\", (size_t)offset_of(JvmtiCachedClassFileData, data) + stream_len);\n-    return false;\n+    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for \" SIZE_FORMAT \" bytes failed in JfrEventClassTransformer::cache_class_file_data\",\n+      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n+    return;\n@@ -1457,3 +1566,9 @@\n-  JvmtiCachedClassFileData* const cached_class_data = ik->get_cached_class_file();\n-  if (cached_class_data != NULL) {\n-    os::free(cached_class_data);\n+}\n+\n+\/\/ On redefine \/ retransform, in case an agent modified the class, the original bytes are cached onto the scratch klass.\n+static void transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(new_ik != NULL, \"invariant\");\n+  JvmtiCachedClassFileData* const p = ik->get_cached_class_file();\n+  if (p != NULL) {\n+    new_ik->set_cached_class_file(p);\n@@ -1461,0 +1576,53 @@\n+    return;\n+  }\n+  \/\/ No cached classfile indicates that no agent modified the klass.\n+  \/\/ This means that the parser is holding the original bytes. Hence, we cache it onto the scratch klass.\n+  const ClassFileStream* const stream = parser.clone_stream();\n+  cache_class_file_data(new_ik, stream, thread);\n+}\n+\n+static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(new_ik != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  assert(IS_EVENT_OR_HOST_KLASS(new_ik), \"invariant\");\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  \/\/ Assign original InstanceKlass* back onto \"its\" parser object for proper destruction.\n+  parser.set_klass_to_deallocate(ik);\n+  \/\/ Finally rewrite the original pointer to the newly created InstanceKlass.\n+  ik = new_ik;\n+}\n+\n+\/\/ If code size is 1, it is 0xb1, i.e. the return instruction.\n+static inline bool is_commit_method_instrumented(const Method* m) {\n+  assert(m != NULL, \"invariant\");\n+  assert(m->name() == commit, \"invariant\");\n+  assert(m->constMethod()->code_size() > 0, \"invariant\");\n+  return m->constMethod()->code_size() > 1;\n+}\n+\n+static bool bless_static_commit_method(const Array<Method*>* methods) {\n+  assert(methods != NULL, \"invariant\");\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const m = methods->at(i);\n+    \/\/ Method is on the form \"static void UserEvent::commit(...)\" and instrumented\n+    if (m->is_static() && m->name() == commit && is_commit_method_instrumented(m)) {\n+      BLESS_METHOD(m);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+static void bless_instance_commit_method(const Array<Method*>* methods) {\n+  assert(methods != NULL, \"invariant\");\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const m = methods->at(i);\n+    \/\/ Method is on the form \"void UserEvent:commit()\" and instrumented\n+    if (!m->is_static() &&\n+         m->name() == commit &&\n+         m->signature() == void_method_sig &&\n+         is_commit_method_instrumented(m)) {\n+      BLESS_METHOD(m);\n+    }\n@@ -1462,1 +1630,50 @@\n-  return true;\n+}\n+\n+\/\/ A blessed method is a method that is allowed to link to system sensitive code.\n+\/\/ It is primarily the class file schema extended instance 'commit()V' method.\n+\/\/ Jdk events can also define a static commit method with an arbitrary signature.\n+static void bless_commit_method(const InstanceKlass* new_ik) {\n+  assert(new_ik != NULL, \"invariant\");\n+  assert(JdkJfrEvent::is_subklass(new_ik), \"invariant\");\n+  const Array<Method*>* const methods = new_ik->methods();\n+  if (new_ik->class_loader() == NULL) {\n+    \/\/ JDK events are allowed an additional commit method that is static.\n+    \/\/ Search precedence must therefore inspect static methods first.\n+    if (bless_static_commit_method(methods)) {\n+      return;\n+    }\n+  }\n+  bless_instance_commit_method(methods);\n+}\n+\n+static void copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(new_ik != NULL, \"invariant\");\n+  new_ik->set_trace_id(ik->trace_id());\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+}\n+\n+static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(state != NULL, \"invariant\");\n+  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  if (redef_klasses == NULL || redef_klasses->is_empty()) {\n+    return NULL;\n+  }\n+  for (int i = 0; i < redef_klasses->length(); ++i) {\n+    const Klass* const existing_klass = redef_klasses->at(i);\n+    assert(existing_klass != NULL, \"invariant\");\n+    if (ik->name() == existing_klass->name() && ik->class_loader_data() == existing_klass->class_loader_data()) {\n+      \/\/ 'ik' is a scratch klass. Return the klass being redefined.\n+      return existing_klass;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Redefining \/ retransforming?\n+static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JvmtiThreadState* const state = thread->jvmti_thread_state();\n+  return state != NULL ? klass_being_redefined(ik, state) : NULL;\n@@ -1494,1 +1711,1 @@\n-  return cache_bytes(ik, stream, new_ik, THREAD) ? new_ik : NULL;\n+  return new_ik;\n@@ -1497,10 +1714,14 @@\n-static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, TRAPS) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(new_ik != NULL, \"invariant\");\n-  assert(new_ik->name() != NULL, \"invariant\");\n-  assert(JdkJfrEvent::is(new_ik) || JdkJfrEvent::is_subklass(new_ik), \"invariant\");\n-  assert(!HAS_PENDING_EXCEPTION, \"invariant\");\n-  \/\/ assign original InstanceKlass* back onto \"its\" parser object for proper destruction\n-  parser.set_klass_to_deallocate(ik);\n-  \/\/ now rewrite original pointer to newly created InstanceKlass\n-  ik = new_ik;\n+static InstanceKlass* create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread) {\n+  if (stream == NULL) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create ClassFileStream for %s\", ik->external_name());\n+    }\n+    return NULL;\n+  }\n+  InstanceKlass* const new_ik = create_new_instance_klass(ik, stream, thread);\n+  if (new_ik == NULL) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create InstanceKlass for %s\", ik->external_name());\n+    }\n+  }\n+  return new_ik;\n@@ -1509,8 +1730,26 @@\n-static bool is_retransforming(const InstanceKlass* ik, TRAPS) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(JdkJfrEvent::is_a(ik), \"invariant\");\n-  Symbol* const name = ik->name();\n-  assert(name != NULL, \"invariant\");\n-  Handle class_loader(THREAD, ik->class_loader());\n-  Handle protection_domain(THREAD, ik->protection_domain());\n-  return SystemDictionary::find_instance_klass(name, class_loader, protection_domain) != NULL;\n+static void transform(InstanceKlass*& ik, ClassFileParser& parser, JavaThread* thread) {\n+  assert(IS_EVENT_OR_HOST_KLASS(ik), \"invariant\");\n+  bool is_instrumented = false;\n+  ClassFileStream* stream = NULL;\n+  const Klass* const existing_klass = find_existing_klass(ik, thread);\n+  if (existing_klass != NULL) {\n+    \/\/ There is already a klass defined, implying we are redefining \/ retransforming.\n+    stream = retransform_bytes(existing_klass, parser, is_instrumented, thread);\n+  } else {\n+    \/\/ No existing klass, implying this is the initial load.\n+    stream = JdkJfrEvent::is(ik) ? schema_extend_event_klass_bytes(ik, parser, thread) : schema_extend_event_subklass_bytes(ik, parser, is_instrumented, thread);\n+  }\n+  InstanceKlass* const new_ik = create_instance_klass(ik, stream, existing_klass == NULL, thread);\n+  if (new_ik == NULL) {\n+    return;\n+  }\n+  if (existing_klass != NULL) {\n+    transfer_cached_class_file_data(ik, new_ik, parser, thread);\n+  } else {\n+    cache_class_file_data(new_ik, stream, thread);\n+  }\n+  if (is_instrumented && JdkJfrEvent::is_subklass(new_ik)) {\n+    bless_commit_method(new_ik);\n+  }\n+  copy_traceid(ik, new_ik);\n+  rewrite_klass_pointer(ik, new_ik, parser, thread);\n@@ -1519,1 +1758,5 @@\n-\/\/ target for JFR_ON_KLASS_CREATION hook\n+\/\/ Target for the JFR_ON_KLASS_CREATION hook.\n+\/\/ Extends the class file schema on initial class load or reinstruments on redefine \/ retransform.\n+\/\/ The passed in parameter 'ik' acts as an in-out parameter: it is rewritten to point to a replaced\n+\/\/ instance of the passed in InstanceKlass. The original 'ik' will be set onto the passed parser,\n+\/\/ for destruction when the parser goes out of scope.\n@@ -1522,25 +1765,4 @@\n-  if (JdkJfrEvent::is(ik)) {\n-    ResourceMark rm(THREAD);\n-    HandleMark hm(THREAD);\n-    ClassFileStream* new_stream = create_new_bytes_for_event_klass(ik, parser, THREAD);\n-    if (new_stream == NULL) {\n-      log_error(jfr, system)(\"JfrClassAdapter: unable to create ClassFileStream\");\n-      return;\n-    }\n-    assert(new_stream != NULL, \"invariant\");\n-    InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);\n-    if (new_ik == NULL) {\n-      log_error(jfr, system)(\"JfrClassAdapter: unable to create InstanceKlass\");\n-      return;\n-    }\n-    assert(new_ik != NULL, \"invariant\");\n-    \/\/ We now need to explicitly tag the replaced klass as the jdk.jfr.Event klass\n-    assert(!JdkJfrEvent::is(new_ik), \"invariant\");\n-    JdkJfrEvent::tag_as(new_ik);\n-    assert(JdkJfrEvent::is(new_ik), \"invariant\");\n-    rewrite_klass_pointer(ik, new_ik, parser, THREAD);\n-    return;\n-  }\n-  assert(JdkJfrEvent::is_subklass(ik), \"invariant\");\n-  if (ik->is_abstract() || is_retransforming(ik, THREAD)) {\n-    \/\/ abstract and scratch classes are not instrumented\n+  assert(IS_EVENT_OR_HOST_KLASS(ik), \"invariant\");\n+  if (ik->is_abstract() && !JdkJfrEvent::is(ik)) {\n+    assert(JdkJfrEvent::is_subklass(ik), \"invariant\");\n+    \/\/ Abstract subklasses are not instrumented.\n@@ -1551,10 +1773,11 @@\n-  ClassFileStream* const new_stream = create_new_bytes_for_subklass(ik, parser, THREAD);\n-  if (NULL == new_stream) {\n-    log_error(jfr, system)(\"JfrClassAdapter: unable to create ClassFileStream\");\n-    return;\n-  }\n-  assert(new_stream != NULL, \"invariant\");\n-  InstanceKlass* new_ik = create_new_instance_klass(ik, new_stream, THREAD);\n-  if (new_ik == NULL) {\n-    log_error(jfr, system)(\"JfrClassAdapter: unable to create InstanceKlass\");\n-    return;\n+  transform(ik, parser, THREAD);\n+}\n+\n+static bool is_static_commit_method_blessed(const Array<Method*>* methods) {\n+  assert(methods != NULL, \"invariant\");\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const m = methods->at(i);\n+    \/\/ Must be on form: static void UserEvent::commit(...)\n+    if (m->is_static() && m->name() == commit) {\n+      return IS_METHOD_BLESSED(m);\n+    }\n@@ -1562,7 +1785,1 @@\n-  assert(new_ik != NULL, \"invariant\");\n-  \/\/ would have been tagged already as a subklass during the normal process of traceid assignment\n-  assert(JdkJfrEvent::is_subklass(new_ik), \"invariant\");\n-  traceid id = ik->trace_id();\n-  ik->set_trace_id(0);\n-  new_ik->set_trace_id(id);\n-  rewrite_klass_pointer(ik, new_ik, parser, THREAD);\n+  return false;\n@@ -1571,3 +1788,10 @@\n-static bool _force_instrumentation = false;\n-void JfrEventClassTransformer::set_force_instrumentation(bool force_instrumentation) {\n-  _force_instrumentation = force_instrumentation;\n+static bool is_instance_commit_method_blessed(const Array<Method*>* methods) {\n+  assert(methods != NULL, \"invariant\");\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const m = methods->at(i);\n+    \/\/ Must be on form: void UserEvent::commit()\n+    if (!m->is_static() && m->name() == commit && m->signature() == void_method_sig) {\n+      return IS_METHOD_BLESSED(m);\n+    }\n+  }\n+  return false;\n@@ -1576,2 +1800,12 @@\n-bool JfrEventClassTransformer::is_force_instrumentation() {\n-  return _force_instrumentation;\n+bool JfrEventClassTransformer::is_instrumented(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(JdkJfrEvent::is_subklass(ik), \"invariant\");\n+  const Array<Method*>* const methods = ik->methods();\n+  if (ik->class_loader() == NULL) {\n+    \/\/ JDK events are allowed an additional commit method that is static.\n+    \/\/ Search precedence must therefore inspect static methods first.\n+    if (is_static_commit_method_blessed(methods)) {\n+      return true;\n+    }\n+  }\n+  return is_instance_commit_method_blessed(methods);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":349,"deletions":115,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -31,0 +31,1 @@\n+class CallInfo;\n@@ -33,0 +34,2 @@\n+class Method;\n+class Symbol;\n@@ -41,0 +44,1 @@\n+  static bool is_instrumented(const InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,0 @@\n-  callbacks.ClassFileLoadHook = jfr_on_class_file_load_hook;\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"c1\/c1_GraphBuilder.hpp\"\n+#include \"ci\/ciKlass.hpp\"\n+#include \"ci\/ciMethod.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"jfr\/instrumentation\/jfrResolution.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"opto\/parse.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+\n+static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriter.getEventWriter(long)'\";\n+\n+static const Method* ljf_sender_method(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  if (!jt->has_last_Java_frame()) {\n+    return nullptr;\n+  }\n+  const vframeStream ljf(jt, false, false);\n+  return ljf.method();\n+}\n+\n+void JfrResolution::on_runtime_resolution(const CallInfo & info, TRAPS) {\n+  assert(info.selected_method() != nullptr, \"invariant\");\n+  assert(info.resolved_klass() != nullptr, \"invariant\");\n+  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n+  assert(event_writer_method_name != nullptr, \"invariant\");\n+  \/\/ Fast path\n+  if (info.selected_method()->name() != event_writer_method_name) {\n+    return;\n+  }\n+  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n+  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n+  if (info.resolved_klass()->name() != event_writer_factory_klass_name) {\n+    return;\n+  }\n+  \/\/ Attempting to link against jdk.jfr.internal.event.EventWriter.getEventWriter().\n+  \/\/ The sender, i.e. the method attempting to link, is in the ljf (if one exists).\n+  const Method* const sender = ljf_sender_method(THREAD);\n+  if (sender == nullptr) {\n+    \/\/ A compiler thread is doing linktime resolution but there is no information about the sender available.\n+    \/\/ For the compiler threads, the sender is instead found as part of bytecode parsing.\n+    return;\n+  }\n+  \/\/ Is the sender method blessed for linkage?\n+  if (IS_METHOD_BLESSED(sender)) {\n+    return;\n+  }\n+  THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+}\n+\n+static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {\n+  assert(holder != nullptr, \"invariant\");\n+  assert(target != nullptr, \"invariant\");\n+  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n+  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n+  if (holder->name()->get_symbol() != event_writer_factory_klass_name) {\n+    return false;\n+  }\n+  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n+  assert(event_writer_method_name != nullptr, \"invariant\");\n+  return target->name()->get_symbol() == event_writer_method_name;\n+}\n+\n+\/\/ C1\n+void JfrResolution::on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target) {\n+  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(builder->method()->get_Method())) {\n+    builder->bailout(link_error_msg);\n+  }\n+}\n+\n+\/\/ C2\n+void JfrResolution::on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target) {\n+  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(parse->method()->get_Method())) {\n+    parse->C->record_failure(link_error_msg);\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n+#define SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class CallInfo;\n+class ciKlass;\n+class ciMethod;\n+class GraphBuilder;\n+class Parse;\n+\n+class JfrResolution : AllStatic {\n+ public:\n+  static void on_runtime_resolution(const CallInfo & info, TRAPS);\n+  static void on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target);\n+  static void on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target);\n+};\n+\n+#endif \/\/ SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n+\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jfr\/instrumentation\/jfrResolution.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -101,0 +103,12 @@\n+void Jfr::on_resolution(const CallInfo& info, TRAPS) {\n+  JfrResolution::on_runtime_resolution(info, THREAD);\n+}\n+\n+void Jfr::on_resolution(const GraphBuilder* builder, const ciKlass* holder, const ciMethod* target) {\n+  JfrResolution::on_c1_resolution(builder, holder, target);\n+}\n+\n+void Jfr::on_resolution(const Parse* parse, const ciKlass* holder, const ciMethod* target) {\n+  JfrResolution::on_c2_resolution(parse, holder, target);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/exceptions.hpp\"\n@@ -33,0 +34,4 @@\n+class CallInfo;\n+class ciKlass;\n+class ciMethod;\n+class GraphBuilder;\n@@ -34,0 +39,1 @@\n+class Klass;\n@@ -35,0 +41,1 @@\n+class Parse;\n@@ -56,0 +63,3 @@\n+  static void on_resolution(const CallInfo& info, TRAPS);\n+  static void on_resolution(const Parse* parse, const ciKlass* holder, const ciMethod* target);\n+  static void on_resolution(const GraphBuilder* builder, const ciKlass* holder, const ciMethod* target);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n@@ -765,1 +766,1 @@\n-static const Klass* get_handler_field_descriptor(const Handle& h_mirror, fieldDescriptor* descriptor, TRAPS) {\n+static const Klass* get_configuration_field_descriptor(const Handle& h_mirror, fieldDescriptor* descriptor, TRAPS) {\n@@ -775,2 +776,2 @@\n-  const Klass* const typed_field_holder = ik->find_field(vmSymbols::eventHandler_name(),\n-                                                         vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),\n+  const Klass* const typed_field_holder = ik->find_field(vmSymbols::eventConfiguration_name(),\n+                                                         vmSymbols::jdk_jfr_internal_event_EventConfiguration_signature(),\n@@ -779,1 +780,1 @@\n-  return typed_field_holder != NULL ? typed_field_holder : ik->find_field(vmSymbols::eventHandler_name(),\n+  return typed_field_holder != NULL ? typed_field_holder : ik->find_field(vmSymbols::eventConfiguration_name(),\n@@ -785,1 +786,1 @@\n-jobject JfrJavaSupport::get_handler(jobject clazz, TRAPS) {\n+jobject JfrJavaSupport::get_configuration(jobject clazz, TRAPS) {\n@@ -790,2 +791,2 @@\n-  fieldDescriptor handler_field_descriptor;\n-  const Klass* const field_holder = get_handler_field_descriptor(h_mirror, &handler_field_descriptor, THREAD);\n+  fieldDescriptor configuration_field_descriptor;\n+  const Klass* const field_holder = get_configuration_field_descriptor(h_mirror, &configuration_field_descriptor, THREAD);\n@@ -797,2 +798,2 @@\n-  oop handler_oop = h_mirror->obj_field(handler_field_descriptor.offset());\n-  return handler_oop != NULL ? JfrJavaSupport::local_jni_handle(handler_oop, THREAD) : NULL;\n+  oop configuration_oop = h_mirror->obj_field(configuration_field_descriptor.offset());\n+  return configuration_oop != NULL ? JfrJavaSupport::local_jni_handle(configuration_oop, THREAD) : NULL;\n@@ -801,1 +802,1 @@\n-bool JfrJavaSupport::set_handler(jobject clazz, jobject handler, TRAPS) {\n+bool JfrJavaSupport::set_configuration(jobject clazz, jobject configuration, TRAPS) {\n@@ -806,2 +807,2 @@\n-  fieldDescriptor handler_field_descriptor;\n-  const Klass* const field_holder = get_handler_field_descriptor(h_mirror, &handler_field_descriptor, THREAD);\n+  fieldDescriptor configuration_field_descriptor;\n+  const Klass* const field_holder = get_configuration_field_descriptor(h_mirror, &configuration_field_descriptor, THREAD);\n@@ -813,3 +814,3 @@\n-  const oop handler_oop = JNIHandles::resolve(handler);\n-  assert(handler_oop != NULL, \"invariant\");\n-  h_mirror->obj_field_put(handler_field_descriptor.offset(), handler_oop);\n+  const oop configuration_oop = JNIHandles::resolve(configuration);\n+  assert(configuration_oop != NULL, \"invariant\");\n+  h_mirror->obj_field_put(configuration_field_descriptor.offset(), configuration_oop);\n@@ -819,0 +820,7 @@\n+bool JfrJavaSupport::is_instrumented(jobject clazz, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  const Klass* const k = java_lang_Class::as_Klass(resolve_non_null(clazz));\n+  assert(k->is_instance_klass(), \"invariant\");\n+  return JfrEventClassTransformer::is_instrumented(InstanceKlass::cast(k));\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -113,2 +113,4 @@\n-  static jobject get_handler(jobject clazz, TRAPS);\n-  static bool set_handler(jobject clazz, jobject handler, TRAPS);\n+  static jobject get_configuration(jobject clazz, TRAPS);\n+  static bool set_configuration(jobject clazz, jobject configuration, TRAPS);\n+\n+  static bool is_instrumented(jobject clazz, TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -369,2 +369,2 @@\n-JVM_ENTRY_NO_ENV(jobject, jfr_get_handler(JNIEnv * env, jobject jvm, jobject clazz))\n-  return JfrJavaSupport::get_handler(clazz, thread);\n+JVM_ENTRY_NO_ENV(jobject, jfr_get_configuration(JNIEnv * env, jobject jvm, jobject clazz))\n+  return JfrJavaSupport::get_configuration(clazz, thread);\n@@ -373,2 +373,10 @@\n-JVM_ENTRY_NO_ENV(jboolean, jfr_set_handler(JNIEnv * env, jobject jvm, jobject clazz, jobject handler))\n-  return JfrJavaSupport::set_handler(clazz, handler, thread);\n+JVM_ENTRY_NO_ENV(jboolean, jfr_set_configuration(JNIEnv * env, jobject jvm, jobject clazz, jobject configuration))\n+  return JfrJavaSupport::set_configuration(clazz, configuration, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jboolean, jfr_is_class_excluded(JNIEnv * env, jobject jvm, jclass clazz))\n+  return JdkJfrEvent::is_excluded(clazz);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jboolean, jfr_is_class_instrumented(JNIEnv* env, jobject jvm, jclass clazz))\n+  return JfrJavaSupport::is_instrumented(clazz, thread);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-jobject JNICALL jfr_get_handler(JNIEnv* env, jobject jvm, jobject clazz);\n+jobject JNICALL jfr_get_configuration(JNIEnv* env, jobject jvm, jobject clazz);\n@@ -153,1 +153,1 @@\n-jboolean JNICALL jfr_set_handler(JNIEnv* env, jobject jvm, jobject clazz, jobject handler);\n+jboolean JNICALL jfr_set_configuration(JNIEnv* env, jobject jvm, jobject clazz, jobject configuration);\n@@ -157,0 +157,4 @@\n+jboolean JNICALL jfr_is_class_excluded(JNIEnv* env, jobject jvm, jclass clazz);\n+\n+jboolean JNICALL jfr_is_class_instrumented(JNIEnv* env, jobject jvm, jclass clazz);\n+\n@@ -162,0 +166,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,3 +72,3 @@\n-      (char*)\"getEventWriter\", (char*)\"()Ljdk\/jfr\/internal\/EventWriter;\", (void*)jfr_get_event_writer,\n-      (char*)\"newEventWriter\", (char*)\"()Ljdk\/jfr\/internal\/EventWriter;\", (void*)jfr_new_event_writer,\n-      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/EventWriter;II)Z\", (void*)jfr_event_writer_flush,\n+      (char*)\"getEventWriter\", (char*)\"()Ljdk\/jfr\/internal\/event\/EventWriter;\", (void*)jfr_get_event_writer,\n+      (char*)\"newEventWriter\", (char*)\"()Ljdk\/jfr\/internal\/event\/EventWriter;\", (void*)jfr_new_event_writer,\n+      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/event\/EventWriter;II)Z\", (void*)jfr_event_writer_flush,\n@@ -92,3 +92,5 @@\n-      (char*)\"getHandler\", (char*)\"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", (void*)jfr_get_handler,\n-      (char*)\"setHandler\", (char*)\"(Ljava\/lang\/Class;Ljdk\/jfr\/internal\/handlers\/EventHandler;)Z\", (void*)jfr_set_handler,\n-      (char*)\"getTypeId\", (char*)\"(Ljava\/lang\/String;)J\", (void*)jfr_get_type_id_from_string\n+      (char*)\"getConfiguration\", (char*)\"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", (void*)jfr_get_configuration,\n+      (char*)\"setConfiguration\", (char*)\"(Ljava\/lang\/Class;Ljdk\/jfr\/internal\/event\/EventConfiguration;)Z\", (void*)jfr_set_configuration,\n+      (char*)\"getTypeId\", (char*)\"(Ljava\/lang\/String;)J\", (void*)jfr_get_type_id_from_string,\n+      (char*)\"isExcluded\", (char*)\"(Ljava\/lang\/Class;)Z\", (void*)jfr_is_class_excluded,\n+      (char*)\"isInstrumented\", (char*)\"(Ljava\/lang\/Class;)Z\", (void*) jfr_is_class_instrumented\n@@ -108,0 +110,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    on_retransform_signature_sym = SymbolTable::new_permanent_symbol(\"(JZLjava\/lang\/Class;[B)[B\");\n+    on_retransform_signature_sym = SymbolTable::new_permanent_symbol(\"(JZZLjava\/lang\/Class;[B)[B\");\n@@ -60,1 +60,1 @@\n-    bytes_for_eager_instrumentation_sig_sym = SymbolTable::new_permanent_symbol(\"(JZLjava\/lang\/Class;[B)[B\");\n+    bytes_for_eager_instrumentation_sig_sym = SymbolTable::new_permanent_symbol(\"(JZZLjava\/lang\/Class;[B)[B\");\n@@ -70,0 +70,1 @@\n+                                 jboolean boot_class_loader,\n@@ -86,0 +87,1 @@\n+  args.push_int(boot_class_loader);\n@@ -132,0 +134,1 @@\n+                                             false, \/\/ not used\n@@ -155,0 +158,1 @@\n+                                                 jboolean boot_class_loader,\n@@ -170,0 +174,1 @@\n+                                             boot_class_loader,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+                                              jboolean boot_class_loader,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n@@ -36,0 +34,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -37,1 +36,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -40,1 +38,2 @@\n-#include \"utilities\/debug.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -115,1 +114,1 @@\n-  assert(klass != NULL, \"invariant\");\n+  assert(klass != nullptr, \"invariant\");\n@@ -119,1 +118,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -124,0 +123,21 @@\n+    return;\n+  }\n+  \/\/ Redefining \/ retransforming?\n+  JavaThread* const jt = JavaThread::current();\n+  assert(jt != nullptr, \"invariant\");\n+  JvmtiThreadState* const state = jt->jvmti_thread_state();\n+  if (state == nullptr) {\n+    return;\n+  }\n+  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  if (redef_klasses == nullptr || redef_klasses->is_empty()) {\n+    return;\n+  }\n+  for (int i = 0; i < redef_klasses->length(); ++i) {\n+    if (klass->name() == redef_klasses->at(i)->name() && klass->class_loader_data() == redef_klasses->at(i)->class_loader_data()) {\n+      \/\/ 'klass' is a scratch klass. If the klass being redefined is a host klass, then tag the scratch klass as well.\n+      if (is_event_host(redef_klasses->at(i))) {\n+        SET_EVENT_HOST_KLASS(klass);\n+        assert(is_event_host(klass), \"invariant\");\n+      }\n+    }\n@@ -267,0 +287,9 @@\n+\n+void JfrTraceId::untag_jdk_jfr_event_sub(const Klass* k) {\n+  assert(k != NULL, \"invariant\");\n+  if (JfrTraceId::is_jdk_jfr_event_sub(k)) {\n+    CLEAR_JDK_JFR_EVENT_SUBKLASS(k);\n+  }\n+  assert(IS_NOT_AN_EVENT_SUB_KLASS(k), \"invariant\");\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+  static void untag_jdk_jfr_event_sub(const Klass* k);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#define BLESSED_METHOD_BIT                        (JDK_JFR_EVENT_SUBKLASS)\n@@ -107,0 +108,1 @@\n+#define IS_METHOD_BLESSED(method)                 (METHOD_FLAG_PREDICATE(method, BLESSED_METHOD_BIT))\n@@ -115,0 +117,1 @@\n+#define BLESS_METHOD(method)                      (METHOD_FLAG_TAG(method, BLESSED_METHOD_BIT))\n@@ -123,0 +126,2 @@\n+#define JDK_JFR_EVENT_SUBKLASS_MASK               (~(JDK_JFR_EVENT_SUBKLASS))\n+#define CLEAR_JDK_JFR_EVENT_SUBKLASS(kls)         (TRACE_ID_MASK_CLEAR(kls, JDK_JFR_EVENT_SUBKLASS_MASK))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,5 +49,7 @@\n-#define JFR_TEMPLATES(template)                                                                                   \\\n-  template(jdk_jfr_internal_JVM,                                      \"jdk\/jfr\/internal\/JVM\")                     \\\n-  template(jdk_jfr_internal_handlers_EventHandler_signature,          \"Ljdk\/jfr\/internal\/handlers\/EventHandler;\") \\\n-  template(eventHandler_name,                                         \"eventHandler\")                             \\\n-  template(void_eventWriter_signature,                                \"()Ljdk\/jfr\/internal\/EventWriter;\")         \\\n+#define JFR_TEMPLATES(template)                                                                                      \\\n+  template(jdk_jfr_internal_JVM,                                      \"jdk\/jfr\/internal\/JVM\")                        \\\n+  template(jdk_jfr_internal_event_EventWriterFactory,                 \"jdk\/jfr\/internal\/event\/EventWriterFactory\")   \\\n+  template(jdk_jfr_internal_event_EventConfiguration_signature,       \"Ljdk\/jfr\/internal\/event\/EventConfiguration;\") \\\n+  template(getEventWriter_signature,                                  \"()Ljdk\/jfr\/internal\/event\/EventWriter;\")      \\\n+  template(eventConfiguration_name,                                   \"eventConfiguration\")                          \\\n+  template(commit_name,                                               \"commit\")                                      \\\n@@ -55,7 +57,7 @@\n-#define JFR_INTRINSICS(do_intrinsic, do_class, do_name, do_signature, do_alias)                                   \\\n-  do_intrinsic(_counterTime,        jdk_jfr_internal_JVM, counterTime_name, void_long_signature, F_SN)            \\\n-    do_name(     counterTime_name,                             \"counterTime\")                                     \\\n-  do_intrinsic(_getClassId,         jdk_jfr_internal_JVM, getClassId_name, class_long_signature, F_SN)            \\\n-    do_name(     getClassId_name,                              \"getClassId\")                                      \\\n-  do_intrinsic(_getEventWriter,   jdk_jfr_internal_JVM, getEventWriter_name, void_eventWriter_signature, F_SN)    \\\n-    do_name(     getEventWriter_name,                          \"getEventWriter\")                                  \\\n+#define JFR_INTRINSICS(do_intrinsic, do_class, do_name, do_signature, do_alias)                                      \\\n+  do_intrinsic(_counterTime,        jdk_jfr_internal_JVM, counterTime_name, void_long_signature, F_SN)               \\\n+    do_name(     counterTime_name,                             \"counterTime\")                                        \\\n+  do_intrinsic(_getClassId,         jdk_jfr_internal_JVM, getClassId_name, class_long_signature, F_SN)               \\\n+    do_name(     getClassId_name,                              \"getClassId\")                                         \\\n+  do_intrinsic(_getEventWriter,   jdk_jfr_internal_JVM, getEventWriter_name, getEventWriter_signature, F_SN)         \\\n+    do_name(     getEventWriter_name,                          \"getEventWriter\")                                     \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,4 @@\n+  if (!JfrTraceId::is_jdk_jfr_event_sub(k)) {\n+    \/\/ Was excluded during initial class load.\n+    return false;\n+  }\n@@ -199,0 +203,4 @@\n+void JdkJfrEvent::remove(const Klass* k) {\n+  JfrTraceId::untag_jdk_jfr_event_sub(k);\n+}\n+\n@@ -222,0 +230,5 @@\n+\n+bool JdkJfrEvent::is_excluded(const jclass jc) {\n+  return !JfrTraceId::in_visible_set(jc);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  static void remove(const Klass* k);\n@@ -72,0 +73,1 @@\n+  static bool is_excluded(const jclass jc);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-#define ON_KLASS_CREATION(k, p, t) if (IS_EVENT_KLASS(k)) JfrEventClassTransformer::on_klass_creation(k, p, t)\n+#define IS_EVENT_OR_HOST_KLASS(ptr) (((ptr)->trace_id() & (JDK_JFR_EVENT_KLASS | JDK_JFR_EVENT_SUBKLASS | EVENT_HOST_KLASS)) != 0)\n+#define ON_KLASS_CREATION(k, p, t) if (IS_EVENT_OR_HOST_KLASS(k)) JfrEventClassTransformer::on_klass_creation(k, p, t)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  const char class_name[] = \"jdk\/jfr\/internal\/EventWriter\";\n+  const char class_name[] = \"jdk\/jfr\/internal\/event\/EventWriter\";\n@@ -210,1 +210,1 @@\n-  static const char klass[] = \"jdk\/jfr\/internal\/EventWriter\";\n+  static const char klass[] = \"jdk\/jfr\/internal\/event\/EventWriter\";\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -514,0 +518,1 @@\n+  JFR_ONLY(Jfr::on_resolution(this, holder, orig_callee);)\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3223,1 +3223,1 @@\n-  ciKlass* klass_EventWriter = env()->find_system_klass(ciSymbol::make(\"jdk\/jfr\/internal\/EventWriter\"));\n+  ciKlass* klass_EventWriter = env()->find_system_klass(ciSymbol::make(\"jdk\/jfr\/internal\/event\/EventWriter\"));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            throw new IllegalAccessError(\"Could not access constructor of generated event handler, \" + e.getMessage());\n+            throw new IllegalAccessError(\"Could not access constructor of generated event class, \" + e.getMessage());\n@@ -155,1 +155,1 @@\n-            throw new InternalError(\"Could not find constructor in generated event handler, \" + e.getMessage());\n+            throw new InternalError(\"Could not find constructor in generated event class, \" + e.getMessage());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    \/\/ EventHandler::write(..., String, Class)\n+    \/\/ commit(..., String, Class)\n@@ -47,0 +47,4 @@\n+\n+    public static void commit(long start, long duration, String message, Class<? extends Error> thrownClass) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ErrorThrownEvent.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.event.EventConfiguration;\n+\n+public final class EventConfigurations {\n+    public static final EventConfiguration SOCKET_READ = Utils.getConfiguration(SocketReadEvent.class);\n+    public static final EventConfiguration SOCKET_WRITE = Utils.getConfiguration(SocketWriteEvent.class);\n+    public static final EventConfiguration FILE_READ = Utils.getConfiguration(FileReadEvent.class);\n+    public static final EventConfiguration FILE_WRITE = Utils.getConfiguration(FileWriteEvent.class);\n+    public static final EventConfiguration FILE_FORCE = Utils.getConfiguration(FileForceEvent.class);\n+    public static final EventConfiguration ERROR_THROWN = Utils.getConfiguration(ErrorThrownEvent.class);\n+    public static final EventConfiguration EXCEPTION_THROWN = Utils.getConfiguration(ExceptionThrownEvent.class);\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/EventConfigurations.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    \/\/ EventHandler::write(..., String, Class)\n+    \/\/ commit(..., String, Class)\n@@ -48,0 +48,4 @@\n+\n+    public static void commit(long start, long duration, String message, Class<? extends Throwable> thrownClass) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ExceptionThrownEvent.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    \/\/ EventHandler::write(..., String, boolean)\n+    \/\/ commit(..., String, boolean)\n@@ -50,0 +50,4 @@\n+\n+    public static void commit(long start, long duration, String path, boolean metaData) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileForceEvent.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    \/\/ EventHandler::write(..., String, long, boolean)\n+    \/\/ commit(..., String, long, boolean)\n@@ -56,0 +56,4 @@\n+\n+    public static void commit(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileReadEvent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    \/\/ EventHandler::write(..., String, long)\n+    \/\/ commit(..., String, long)\n@@ -52,0 +52,4 @@\n+\n+    public static void commit(long start, long duration, String path, long bytesWritten) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileWriteEvent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-import jdk.jfr.internal.handlers.EventHandler;\n-import jdk.jfr.internal.Utils;\n-\n-public final class Handlers {\n-    public static final EventHandler SOCKET_READ = Utils.getHandler(SocketReadEvent.class);\n-    public static final EventHandler SOCKET_WRITE = Utils.getHandler(SocketWriteEvent.class);\n-    public static final EventHandler FILE_READ = Utils.getHandler(FileReadEvent.class);\n-    public static final EventHandler FILE_WRITE = Utils.getHandler(FileWriteEvent.class);\n-    public static final EventHandler FILE_FORCE = Utils.getHandler(FileForceEvent.class);\n-    public static final EventHandler ERROR_THROWN = Utils.getHandler(ErrorThrownEvent.class);\n-    public static final EventHandler EXCEPTION_THROWN = Utils.getHandler(ExceptionThrownEvent.class);\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/Handlers.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    \/\/ EventHandler::write(..., String, String, int, long, long, boolean)\n+    \/\/ commit(..., String, String, int, long, long, boolean)\n@@ -66,0 +66,4 @@\n+\n+    public static void commit(long start, long duration, String host, String address, int port, long timeout, long byteRead, boolean endOfStream) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketReadEvent.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    \/\/ EventHandler::write(..., String, String, int, long)\n+    \/\/ commit(..., String, String, int, long)\n@@ -57,0 +57,4 @@\n+\n+    public static void commit(long start, long duration, String host, String address, int port, long bytes) {\n+        \/\/ Generated\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketWriteEvent.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -33,2 +32,0 @@\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -36,1 +33,0 @@\n-import jdk.internal.org.objectweb.asm.commons.Method;\n@@ -39,18 +35,0 @@\n-import jdk.jfr.internal.EventInstrumentation.FieldInfo;\n-\n-final class ASMToolkit {\n-    private static Type TYPE_STRING = Type.getType(String.class);\n-    private static Type Type_THREAD = Type.getType(Thread.class);\n-    private static Type TYPE_CLASS = Type.getType(Class.class);\n-\n-    public static void invokeSpecial(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    public static void invokeStatic(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, className, m.getName(), m.getDescriptor(), false);\n-    }\n-\n-    public static void invokeVirtual(MethodVisitor methodVisitor, String className, Method m) {\n-        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, m.getName(), m.getDescriptor(), false);\n-    }\n@@ -58,0 +36,4 @@\n+public final class ASMToolkit {\n+    public static final Type TYPE_STRING = Type.getType(String.class);\n+    private static final Type TYPE_THREAD = Type.getType(Thread.class);\n+    private static final Type TYPE_CLASS = Type.getType(Class.class);\n@@ -82,1 +64,1 @@\n-            return Type_THREAD;\n+            return TYPE_THREAD;\n@@ -138,12 +120,0 @@\n-    public static Method makeWriteMethod(List<FieldInfo> fields) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (FieldInfo v : fields) {\n-            if (!v.fieldName.equals(EventInstrumentation.FIELD_EVENT_THREAD) && !v.fieldName.equals(EventInstrumentation.FIELD_STACK_TRACE)) {\n-                sb.append(v.fieldDescriptor);\n-            }\n-        }\n-        sb.append(\")V\");\n-        return new Method(\"write\", sb.toString());\n-    }\n-\n@@ -161,1 +131,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ASMToolkit.java","additions":6,"deletions":37,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-final class Bits {                            \/\/ package-private\n+public final class Bits {\n@@ -161,1 +161,1 @@\n-    static int putByte(long a, byte x) {\n+    public static int putByte(long a, byte x) {\n@@ -166,1 +166,1 @@\n-    static int putBoolean(long a, boolean x) {\n+    public static int putBoolean(long a, boolean x) {\n@@ -189,1 +189,1 @@\n-    static int putInt(long a, int x) {\n+    public static int putInt(long a, int x) {\n@@ -207,1 +207,1 @@\n-    static int putFloat(long a, float x) {\n+    public static int putFloat(long a, float x) {\n@@ -216,1 +216,1 @@\n-    static int putDouble(long a, double x) {\n+    public static int putDouble(long a, double x) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Bits.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -175,0 +175,4 @@\n+\n+    final SettingControl getSettingControl() {\n+        return delegate;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-        ASMToolkit.invokeSpecial(mv, TYPE_EVENT.getInternalName(), DEFAULT_CONSTRUCTOR);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, TYPE_EVENT.getInternalName(), DEFAULT_CONSTRUCTOR.getName(), DEFAULT_CONSTRUCTOR.getDescriptor(), false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,3 +173,2 @@\n-            SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);\n-            si.settingControl = instantiateSettingControl(settingsClass);\n-            Control c = new Control(si.settingControl, null);\n+            SettingControl settingControl = instantiateSettingControl(settingsClass);\n+            Control c = new Control(settingControl, null);\n@@ -190,1 +189,1 @@\n-                settingInfos.add(si);\n+                settingInfos.add(new SettingInfo(FIELD_SETTING_PREFIX + index, index, null, null, settingControl));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,337 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.StringJoiner;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.Method;\n-import jdk.jfr.Event;\n-import jdk.jfr.EventType;\n-import jdk.jfr.SettingControl;\n-import jdk.jfr.ValueDescriptor;\n-import jdk.jfr.internal.EventInstrumentation.FieldInfo;\n-import jdk.jfr.internal.EventInstrumentation.SettingInfo;\n-import jdk.jfr.internal.handlers.EventHandler;\n-\n-final class EventHandlerCreator {\n-    \/\/ TODO:\n-    \/\/ How can we find out class version without loading a\n-    \/\/ class as resource in a privileged block and use ASM to inspect\n-    \/\/ the contents. Using '52' even though we know later versions\n-    \/\/ are available. The reason for this is compatibility aspects\n-    \/\/ with for example WLS.\n-    private static final int CLASS_VERSION = 52;\n-\n-    \/\/ This is needed so a new EventHandler is automatically generated in MetadataRepository\n-    \/\/ if a user Event class is loaded using APPCDS\/CDS.\n-    private static final String SUFFIX  = \"_\" + System.currentTimeMillis() + \"-\" + JVM.getJVM().getPid();\n-\n-    private static final String FIELD_EVENT_TYPE = \"platformEventType\";\n-    private static final String FIELD_PREFIX_STRING_POOL = \"stringPool\";\n-\n-    private static final Type TYPE_STRING_POOL = Type.getType(StringPool.class);\n-    private static final Type TYPE_EVENT_WRITER = Type.getType(EventWriter.class);\n-    private static final Type TYPE_PLATFORM_EVENT_TYPE = Type.getType(PlatformEventType.class);\n-    private static final Type TYPE_EVENT_HANDLER = Type.getType(EventHandler.class);\n-    private static final Type TYPE_SETTING_CONTROL = Type.getType(SettingControl.class);\n-    private static final Type TYPE_EVENT_TYPE = Type.getType(EventType.class);\n-    private static final Type TYPE_EVENT_CONTROL = Type.getType(EventControl.class);\n-    private static final String DESCRIPTOR_EVENT_HANDLER = \"(\" + Type.BOOLEAN_TYPE.getDescriptor() + TYPE_EVENT_TYPE.getDescriptor() + TYPE_EVENT_CONTROL.getDescriptor() + \")V\";\n-    private static final Method METHOD_GET_EVENT_WRITER = new Method(\"getEventWriter\", \"()\" + TYPE_EVENT_WRITER.getDescriptor());\n-    private static final Method METHOD_EVENT_HANDLER_CONSTRUCTOR = new Method(\"<init>\", DESCRIPTOR_EVENT_HANDLER);\n-    private static final Method METHOD_RESET = new Method(\"reset\", \"()V\");\n-\n-    private final ClassWriter classWriter;\n-    private final String className;\n-    private final String internalClassName;\n-    private final List<SettingInfo> settingInfos;\n-    private final List<FieldInfo> fields;\n-\n-    public EventHandlerCreator(long id, List<SettingInfo> settingInfos, List<FieldInfo> fields) {\n-        this.classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-        this.className = makeEventHandlerName(id);\n-        this.internalClassName = ASMToolkit.getInternalName(className);\n-        this.settingInfos = settingInfos;\n-        this.fields = fields;\n-    }\n-\n-    public static String makeEventHandlerName(long id) {\n-        return EventHandler.class.getName() + id + SUFFIX;\n-    }\n-\n-    public EventHandlerCreator(long id, List<SettingInfo> settingInfos, EventType type, Class<? extends jdk.internal.event.Event> eventClass) {\n-        this(id, settingInfos, createFieldInfos(eventClass, type));\n-    }\n-\n-    private static List<FieldInfo> createFieldInfos(Class<? extends jdk.internal.event.Event> eventClass, EventType type) throws Error {\n-        List<FieldInfo> fieldInfos = new ArrayList<>();\n-        for (ValueDescriptor v : type.getFields()) {\n-            \/\/ Only value descriptors that are not fields on the event class.\n-            if (v != TypeLibrary.STACK_TRACE_FIELD && v != TypeLibrary.THREAD_FIELD) {\n-                String fieldName = PrivateAccess.getInstance().getFieldName(v);\n-                String fieldDescriptor = ASMToolkit.getDescriptor(v.getTypeName());\n-                Class<?> c = eventClass;\n-                String internalName = null;\n-                while (c != Event.class) {\n-                    try {\n-                        Field field = c.getDeclaredField(fieldName);\n-                        if (c == eventClass || !Modifier.isPrivate(field.getModifiers())) {\n-                            internalName = ASMToolkit.getInternalName(c.getName());\n-                            break;\n-                        }\n-                    } catch (NoSuchFieldException | SecurityException e) {\n-                        \/\/ ignore\n-                    }\n-                    c = c.getSuperclass();\n-                }\n-                if (internalName != null) {\n-                    fieldInfos.add(new FieldInfo(fieldName, fieldDescriptor, internalName));\n-                } else {\n-                    throw new InternalError(\"Could not locate field \" + fieldName + \" for event type \" + type.getName());\n-                }\n-            }\n-        }\n-        return fieldInfos;\n-    }\n-\n-    public Class<? extends EventHandler> makeEventHandlerClass() {\n-        buildClassInfo();\n-        buildConstructor();\n-        buildWriteMethod();\n-        byte[] bytes = classWriter.toByteArray();\n-        ASMToolkit.logASM(className, bytes);\n-        return SecuritySupport.defineClass(EventHandler.class, bytes).asSubclass(EventHandler.class);\n-    }\n-\n-    public static EventHandler instantiateEventHandler(Class<? extends EventHandler> handlerClass, boolean registered, EventType eventType, EventControl eventControl) throws Error {\n-        final Constructor<?> cc;\n-        try {\n-            cc = handlerClass.getDeclaredConstructors()[0];\n-        } catch (Exception e) {\n-            throw (Error) new InternalError(\"Could not get handler constructor for \" + eventType.getName()).initCause(e);\n-        }\n-        \/\/ Users should not be allowed to create instances of the event handler\n-        \/\/ so we need to unlock it here.\n-        SecuritySupport.setAccessible(cc);\n-        try {\n-            List<SettingInfo> settingInfos = eventControl.getSettingInfos();\n-            Object[] arguments = new Object[3 + settingInfos.size()];\n-            arguments[0] = registered;\n-            arguments[1] = eventType;\n-            arguments[2] = eventControl;\n-            for (SettingInfo si : settingInfos) {\n-                arguments[si.index + 3] = si.settingControl;\n-            }\n-            return (EventHandler) cc.newInstance(arguments);\n-        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-            throw (Error) new InternalError(\"Could not instantiate event handler for \" + eventType.getName() + \". \" + e.getMessage()).initCause(e);\n-        }\n-    }\n-\n-    private void buildConstructor() {\n-        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PRIVATE, METHOD_EVENT_HANDLER_CONSTRUCTOR.getName(), makeConstructorDescriptor(settingInfos), null, null);\n-        mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ this\n-        mv.visitVarInsn(Opcodes.ILOAD, 1); \/\/ registered\n-        mv.visitVarInsn(Opcodes.ALOAD, 2); \/\/ event type\n-        mv.visitVarInsn(Opcodes.ALOAD, 3); \/\/ event control\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(EventHandler.class), METHOD_EVENT_HANDLER_CONSTRUCTOR.getName(), METHOD_EVENT_HANDLER_CONSTRUCTOR.getDescriptor(), false);\n-        for (SettingInfo si : settingInfos) {\n-            mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ this\n-            mv.visitVarInsn(Opcodes.ALOAD, si.index + 4); \/\/ Setting Control\n-            mv.visitFieldInsn(Opcodes.PUTFIELD, internalClassName, si.fieldName, TYPE_SETTING_CONTROL.getDescriptor());\n-        }\n-        \/\/ initialized string field writers\n-        int fieldIndex = 0;\n-        for (FieldInfo field : fields) {\n-            if (field.isString()) {\n-                mv.visitVarInsn(Opcodes.ALOAD, 0);\n-                mv.visitVarInsn(Opcodes.ALOAD, 0);\n-                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(EventHandler.class), \"createStringFieldWriter\", \"()\" + TYPE_STRING_POOL.getDescriptor(), false);\n-                mv.visitFieldInsn(Opcodes.PUTFIELD, internalClassName, FIELD_PREFIX_STRING_POOL + fieldIndex, TYPE_STRING_POOL.getDescriptor());\n-            }\n-            fieldIndex++;\n-        }\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    private void buildClassInfo() {\n-        String internalSuperName = ASMToolkit.getInternalName(EventHandler.class.getName());\n-        classWriter.visit(CLASS_VERSION, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, internalClassName, null, internalSuperName, null);\n-        for (SettingInfo si : settingInfos) {\n-            classWriter.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL, si.fieldName, TYPE_SETTING_CONTROL.getDescriptor(), null, null);\n-        }\n-        int fieldIndex = 0;\n-        for (FieldInfo field : fields) {\n-            if (field.isString()) {\n-                classWriter.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, FIELD_PREFIX_STRING_POOL+ fieldIndex, TYPE_STRING_POOL.getDescriptor(), null, null);\n-            }\n-            fieldIndex++;\n-        }\n-    }\n-\n-    private void visitMethod(final MethodVisitor mv, final int opcode, final Type type, final Method method) {\n-        mv.visitMethodInsn(opcode, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n-    }\n-\n-    private void buildWriteMethod() {\n-        int argIndex = 0; \/\/ \/\/ indexes the argument type array, the argument type array does not include 'this'\n-        int slotIndex = 1; \/\/ indexes the proper slot in the local variable table, takes type size into account, therefore sometimes argIndex != slotIndex\n-        int fieldIndex = 0;\n-        Method desc = ASMToolkit.makeWriteMethod(fields);\n-        Type[] argumentTypes = Type.getArgumentTypes(desc.getDescriptor());\n-        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, desc.getName(), desc.getDescriptor(), null, null);\n-        mv.visitCode();\n-        Label start = new Label();\n-        Label endTryBlock = new Label();\n-        Label exceptionHandler = new Label();\n-        mv.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n-        mv.visitLabel(start);\n-        visitMethod(mv, Opcodes.INVOKESTATIC, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);\n-        \/\/ stack: [BW]\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [BW], [BW]\n-        \/\/ write begin event\n-        mv.visitVarInsn(Opcodes.ALOAD, 0);\n-        \/\/ stack: [BW], [BW], [this]\n-        mv.visitFieldInsn(Opcodes.GETFIELD, TYPE_EVENT_HANDLER.getInternalName(), FIELD_EVENT_TYPE, TYPE_PLATFORM_EVENT_TYPE.getDescriptor());\n-        \/\/ stack: [BW], [BW], [BS]\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asASM());\n-        \/\/ stack: [BW], [integer]\n-        Label excluded = new Label();\n-        mv.visitJumpInsn(Opcodes.IFEQ, excluded);\n-        \/\/ stack: [BW]\n-        \/\/ write startTime\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [BW], [BW]\n-        mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-        \/\/ stack: [BW], [BW], [long]\n-        slotIndex += argumentTypes[argIndex++].getSize();\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-        \/\/ stack: [BW]\n-        fieldIndex++;\n-        \/\/ write duration\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [BW], [BW]\n-        mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-        \/\/ stack: [BW], [BW], [long]\n-        slotIndex += argumentTypes[argIndex++].getSize();\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n-        \/\/ stack: [BW]\n-        fieldIndex++;\n-        \/\/ write eventThread\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [BW], [BW]\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n-        \/\/ stack: [BW]\n-        \/\/ write stackTrace\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [BW], [BW]\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n-        \/\/ stack: [BW]\n-        \/\/ write custom fields\n-        while (fieldIndex < fields.size()) {\n-            mv.visitInsn(Opcodes.DUP);\n-            \/\/ stack: [BW], [BW]\n-            mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n-            \/\/ stack:[BW], [BW], [field]\n-            slotIndex += argumentTypes[argIndex++].getSize();\n-            FieldInfo field = fields.get(fieldIndex);\n-            if (field.isString()) {\n-                mv.visitVarInsn(Opcodes.ALOAD, 0);\n-                \/\/ stack:[BW], [BW], [field], [this]\n-                mv.visitFieldInsn(Opcodes.GETFIELD, this.internalClassName, FIELD_PREFIX_STRING_POOL + fieldIndex, TYPE_STRING_POOL.getDescriptor());\n-                \/\/ stack:[BW], [BW], [field], [string]\n-            }\n-            EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n-            visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, eventMethod.asASM());\n-            \/\/ stack: [BW]\n-            fieldIndex++;\n-        }\n-        \/\/ stack: [BW]\n-        \/\/ write end event (writer already on stack)\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n-        \/\/ stack [integer]\n-        \/\/ notified -> restart event write attempt\n-        mv.visitJumpInsn(Opcodes.IFEQ, start);\n-        \/\/ stack:\n-        mv.visitLabel(endTryBlock);\n-        Label end = new Label();\n-        mv.visitJumpInsn(Opcodes.GOTO, end);\n-        mv.visitLabel(exceptionHandler);\n-        \/\/ stack: [ex]\n-        mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {\"java\/lang\/Throwable\"});\n-        visitMethod(mv, Opcodes.INVOKESTATIC, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);\n-        \/\/ stack: [ex] [BW]\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [ex] [BW] [BW]\n-        Label rethrow = new Label();\n-        mv.visitJumpInsn(Opcodes.IFNULL, rethrow);\n-        \/\/ stack: [ex] [BW]\n-        mv.visitInsn(Opcodes.DUP);\n-        \/\/ stack: [ex] [BW] [BW]\n-        visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n-        mv.visitLabel(rethrow);\n-        \/\/ stack:[ex] [BW]\n-        mv.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] {\"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName()});\n-        mv.visitInsn(Opcodes.POP);\n-        \/\/ stack:[ex]\n-        mv.visitInsn(Opcodes.ATHROW);\n-        mv.visitLabel(excluded);\n-        \/\/ stack: [BW]\n-        mv.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName()} );\n-        mv.visitInsn(Opcodes.POP);\n-        mv.visitLabel(end);\n-        \/\/ stack:\n-        mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    private static String makeConstructorDescriptor(List<SettingInfo> settingsInfos) {\n-        StringJoiner constructordescriptor = new StringJoiner(\"\", \"(\", \")V\");\n-        constructordescriptor.add(Type.BOOLEAN_TYPE.getDescriptor());\n-        constructordescriptor.add(Type.getType(EventType.class).getDescriptor());\n-        constructordescriptor.add(Type.getType(EventControl.class).getDescriptor());\n-        for (int i = 0; i < settingsInfos.size(); i++) {\n-            constructordescriptor.add(TYPE_SETTING_CONTROL.getDescriptor());\n-        }\n-        return constructordescriptor.toString();\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventHandlerCreator.java","additions":0,"deletions":337,"binary":false,"changes":337,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,2 @@\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.event.EventWriter;\n@@ -61,24 +62,0 @@\n-    static final class SettingInfo {\n-        private String methodName;\n-        private String internalSettingName;\n-        private String settingDescriptor;\n-        final String fieldName;\n-        final int index;\n-\n-        \/\/ The settingControl is passed to EventHandler where it is\n-        \/\/ used to check enablement before calling commit\n-        \/\/ Methods on settingControl must never be invoked\n-        \/\/ directly by JFR, instead use jdk.jfr.internal.Control\n-        SettingControl settingControl;\n-\n-        public SettingInfo(String fieldName, int index) {\n-            this.fieldName = fieldName;\n-            this.index = index;\n-        }\n-    }\n-\n-    static final class FieldInfo {\n-        private static final Type STRING = Type.getType(String.class);\n-        final String fieldName;\n-        final String fieldDescriptor;\n-        final String internalClassName;\n@@ -86,4 +63,8 @@\n-        public FieldInfo(String fieldName, String fieldDescriptor, String internalClassName) {\n-            this.fieldName = fieldName;\n-            this.fieldDescriptor = fieldDescriptor;\n-            this.internalClassName = internalClassName;\n+    record SettingInfo(String fieldName, int index, Type paramType, String methodName, SettingControl settingControl) {\n+        \/**\n+         * A malicious user must never be able to run a callback in the wrong\n+         * context. Methods on SettingControl must therefore never be invoked directly\n+         * by JFR, instead use jdk.jfr.internal.Control.\n+         *\/\n+        public SettingControl settingControl() {\n+            return this.settingControl;\n@@ -91,0 +72,1 @@\n+    }\n@@ -92,3 +74,1 @@\n-        public boolean isString() {\n-            return STRING.getDescriptor().equals(fieldDescriptor);\n-        }\n+    record FieldInfo(String fieldName, String fieldDescriptor, String internalClassName) {\n@@ -101,1 +81,1 @@\n-    static final String FIELD_EVENT_HANDLER = \"eventHandler\";\n+    static final String FIELD_EVENT_CONFIGURATION = \"eventConfiguration\";\n@@ -104,4 +84,6 @@\n-    private static final Type ANNOTATION_TYPE_NAME = Type.getType(Name.class);\n-    private static final Type ANNOTATION_TYPE_REGISTERED = Type.getType(Registered.class);\n-    private static final Type ANNOTATION_TYPE_ENABLED = Type.getType(Enabled.class);\n-    private static final Type TYPE_EVENT_HANDLER = Type.getType(EventHandler.class);\n+    private static final String ANNOTATION_NAME_DESCRIPTOR = Type.getDescriptor(Name.class);\n+    private static final String ANNOTATION_REGISTERED_DESCRIPTOR = Type.getDescriptor(Registered.class);\n+    private static final String ANNOTATION_ENABLED_DESCRIPTOR = Type.getDescriptor(Enabled.class);\n+    private static final Type TYPE_EVENT_CONFIGURATION = Type.getType(EventConfiguration.class);\n+    private static final Type TYPE_EVENT_WRITER = Type.getType(EventWriter.class);\n+    private static final Type TYPE_EVENT_WRITER_FACTORY = Type.getType(\"Ljdk\/jfr\/internal\/event\/EventWriterFactory;\");\n@@ -109,1 +91,3 @@\n-    private static final Type TYPE_OBJECT  = Type.getType(Object.class);\n+    private static final String TYPE_OBJECT_DESCRIPTOR = Type.getDescriptor(Object.class);\n+    private static final String TYPE_EVENT_CONFIGURATION_DESCRIPTOR = TYPE_EVENT_CONFIGURATION.getDescriptor();\n+    private static final String TYPE_SETTING_DEFINITION_DESCRIPTOR = Type.getDescriptor(SettingDefinition.class);\n@@ -115,0 +99,1 @@\n+    private static final Method METHOD_GET_EVENT_WRITER_KEY = new Method(\"getEventWriter\", TYPE_EVENT_WRITER, new Type[] { Type.LONG_TYPE });\n@@ -116,1 +101,2 @@\n-    private static final Method METHOD_EVENT_HANDLER_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n+    private static final Method METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n+    private static final Method METHOD_EVENT_CONFIGURATION_GET_SETTING = new Method(\"getSetting\", TYPE_SETTING_CONTROL, new Type[] { Type.INT_TYPE });\n@@ -118,0 +104,1 @@\n+    private static final Method METHOD_RESET = new Method(\"reset\", \"()V\");\n@@ -122,2 +109,0 @@\n-    private final Method writeMethod;\n-    private final String eventHandlerXInternalName;\n@@ -125,5 +110,8 @@\n-    private final boolean untypedEventHandler;\n-    private boolean guardHandlerReference;\n-    private Class<?> superClass;\n-\n-    EventInstrumentation(Class<?> superClass, byte[] bytes, long id) {\n+    private final Class<?> superClass;\n+    private final boolean untypedEventConfiguration;\n+    private final Method staticCommitMethod;\n+    private final long eventTypeId;\n+    private final boolean guardEventConfiguration;\n+\n+    EventInstrumentation(Class<?> superClass, byte[] bytes, long id, boolean bootClass, boolean guardEventConfiguration) {\n+        this.eventTypeId = id;\n@@ -134,4 +122,1 @@\n-        this.untypedEventHandler = hasUntypedHandler();\n-        this.writeMethod = makeWriteMethod(fieldInfos);\n-        this.eventHandlerXInternalName = ASMToolkit.getInternalName(EventHandlerCreator.makeEventHandlerName(id));\n-        String n =  annotationValue(classNode, ANNOTATION_TYPE_NAME.getDescriptor(), String.class);\n+        String n = annotationValue(classNode, ANNOTATION_NAME_DESCRIPTOR, String.class);\n@@ -139,0 +124,22 @@\n+        this.staticCommitMethod = bootClass ? findStaticCommitMethod(classNode, fieldInfos) : null;\n+        this.untypedEventConfiguration = hasUntypedConfiguration();\n+        \/\/ Corner case when we are forced to generate bytecode (bytesForEagerInstrumentation)\n+        \/\/ We can't reference EventConfiguration::isEnabled() before event class has been registered,\n+        \/\/ so we add a guard against a null reference.\n+        this.guardEventConfiguration = guardEventConfiguration;\n+    }\n+\n+    public static Method findStaticCommitMethod(ClassNode classNode, List<FieldInfo> fields) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"(\");\n+        for (FieldInfo v : fields) {\n+            sb.append(v.fieldDescriptor);\n+        }\n+        sb.append(\")V\");\n+        Method m = new Method(\"commit\", sb.toString());\n+        for (MethodNode method : classNode.methods) {\n+            if (\"commit\".equals(method.name) && m.getDescriptor().equals(method.desc)) {\n+                return m;\n+            }\n+        }\n+        return null;\n@@ -141,1 +148,1 @@\n-    private boolean hasUntypedHandler() {\n+    private boolean hasUntypedConfiguration() {\n@@ -143,2 +150,2 @@\n-            if (FIELD_EVENT_HANDLER.equals(field.name)) {\n-                return field.desc.equals(TYPE_OBJECT.getDescriptor());\n+            if (FIELD_EVENT_CONFIGURATION.equals(field.name)) {\n+                return field.desc.equals(TYPE_OBJECT_DESCRIPTOR);\n@@ -147,1 +154,1 @@\n-        throw new InternalError(\"Class missing handler field\");\n+        throw new InternalError(\"Class missing configuration field\");\n@@ -151,1 +158,1 @@\n-      return classNode.name.replace(\"\/\",\".\");\n+        return classNode.name.replace(\"\/\", \".\");\n@@ -162,1 +169,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_TYPE_REGISTERED.getDescriptor(), Boolean.class);\n+        Boolean result = annotationValue(classNode, ANNOTATION_REGISTERED_DESCRIPTOR, Boolean.class);\n@@ -176,1 +183,1 @@\n-        Boolean result = annotationValue(classNode, ANNOTATION_TYPE_ENABLED.getDescriptor(), Boolean.class);\n+        Boolean result = annotationValue(classNode, ANNOTATION_ENABLED_DESCRIPTOR, Boolean.class);\n@@ -201,1 +208,1 @@\n-                                   return (T) value;\n+                                    return (T) value;\n@@ -215,2 +222,0 @@\n-        String settingDescriptor = Type.getType(SettingDefinition.class).getDescriptor();\n-        String nameDescriptor = Type.getType(Name.class).getDescriptor();\n@@ -223,1 +228,1 @@\n-                    if (settingDescriptor.equals(an.desc)) {\n+                    if (TYPE_SETTING_DEFINITION_DESCRIPTOR.equals(an.desc)) {\n@@ -226,1 +231,1 @@\n-                            if (nameDescriptor.equals(nameCandidate.desc)) {\n+                            if (ANNOTATION_NAME_DESCRIPTOR.equals(nameCandidate.desc)) {\n@@ -228,1 +233,1 @@\n-                                if (values.size() == 1 && values.get(0) instanceof String s) {\n+                                if (values.size() == 1 && values.get(0)instanceof String s) {\n@@ -240,4 +245,0 @@\n-                                SettingInfo si = new SettingInfo(fieldName, index);\n-                                si.methodName = m.name;\n-                                si.settingDescriptor = paramType.getDescriptor();\n-                                si.internalSettingName = paramType.getInternalName();\n@@ -245,1 +246,1 @@\n-                                settingInfos.add(si);\n+                                settingInfos.add(new SettingInfo(fieldName, index, paramType, m.name, null));\n@@ -263,4 +264,0 @@\n-                                SettingInfo si = new SettingInfo(fieldName, index);\n-                                si.methodName = method.getName();\n-                                si.settingDescriptor = paramType.getDescriptor();\n-                                si.internalSettingName = paramType.getInternalName();\n@@ -268,1 +265,1 @@\n-                                settingInfos.add(si);\n+                                settingInfos.add(new SettingInfo(fieldName, index, paramType, method.getName(), null));\n@@ -281,1 +278,1 @@\n-        \/\/ These two field are added by native as transient so they will be\n+        \/\/ These two fields are added by native as 'transient' so they will be\n@@ -342,1 +339,0 @@\n-        \/\/ MyEvent#isEnabled()\n@@ -345,2 +341,2 @@\n-            if (guardHandlerReference) {\n-                getEventHandler(methodVisitor);\n+            if (guardEventConfiguration) {\n+                getEventConfiguration(methodVisitor);\n@@ -349,2 +345,2 @@\n-            getEventHandler(methodVisitor);\n-            ASMToolkit.invokeVirtual(methodVisitor, TYPE_EVENT_HANDLER.getInternalName(), METHOD_IS_ENABLED);\n+            getEventConfiguration(methodVisitor);\n+            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n@@ -352,1 +348,1 @@\n-            if (guardHandlerReference) {\n+            if (guardEventConfiguration) {\n@@ -363,1 +359,1 @@\n-            ASMToolkit.invokeStatic(methodVisitor, TYPE_EVENT_HANDLER.getInternalName(), METHOD_TIME_STAMP);\n+            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n@@ -373,1 +369,1 @@\n-            ASMToolkit.invokeStatic(methodVisitor, TYPE_EVENT_HANDLER.getInternalName(), METHOD_DURATION);\n+            invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_DURATION);\n@@ -379,56 +375,124 @@\n-        updateMethod(METHOD_COMMIT, methodVisitor -> {\n-            \/\/ if (!isEnable()) {\n-            \/\/ return;\n-            \/\/ }\n-            methodVisitor.visitCode();\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), METHOD_IS_ENABLED.getName(), METHOD_IS_ENABLED.getDescriptor(), false);\n-            Label l0 = new Label();\n-            methodVisitor.visitJumpInsn(Opcodes.IFNE, l0);\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n-            methodVisitor.visitLabel(l0);\n-            methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-            \/\/ if (startTime == 0) {\n-            \/\/ startTime = EventWriter.timestamp();\n-            \/\/ } else {\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            methodVisitor.visitInsn(Opcodes.LCONST_0);\n-            methodVisitor.visitInsn(Opcodes.LCMP);\n-            Label durationalEvent = new Label();\n-            methodVisitor.visitJumpInsn(Opcodes.IFNE, durationalEvent);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_HANDLER.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            Label commit = new Label();\n-            methodVisitor.visitJumpInsn(Opcodes.GOTO, commit);\n-            \/\/ if (duration == 0) {\n-            \/\/ duration = EventWriter.timestamp() - startTime;\n-            \/\/ }\n-            \/\/ }\n-            methodVisitor.visitLabel(durationalEvent);\n-            methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            methodVisitor.visitInsn(Opcodes.LCONST_0);\n-            methodVisitor.visitInsn(Opcodes.LCMP);\n-            methodVisitor.visitJumpInsn(Opcodes.IFNE, commit);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_HANDLER.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n-            methodVisitor.visitInsn(Opcodes.LSUB);\n-            methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n-            methodVisitor.visitLabel(commit);\n-            \/\/ if (shouldCommit()) {\n-            methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n-            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), METHOD_EVENT_SHOULD_COMMIT.getName(), METHOD_EVENT_SHOULD_COMMIT.getDescriptor(), false);\n-            Label end = new Label();\n-            \/\/ eventHandler.write(...);\n-            \/\/ }\n-            methodVisitor.visitJumpInsn(Opcodes.IFEQ, end);\n-            getEventHandler(methodVisitor);\n-\n-            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, eventHandlerXInternalName);\n-            for (FieldInfo fi : fieldInfos) {\n+        \/\/ MyEvent#commit() or MyEvent#commit(EventConfiguration, ...)\n+        if (staticCommitMethod != null) {\n+            updateExistingWithEmptyVoidMethod(METHOD_COMMIT);\n+            updateMethod(staticCommitMethod, mv -> {\n+                \/\/ indexes the argument type array, the argument type array does not include\n+                \/\/ 'this'\n+                int argIndex = 0;\n+                \/\/ indexes the proper slot in the local variable table, takes type size into\n+                \/\/ account, therefore sometimes argIndex != slotIndex\n+                int slotIndex = 0;\n+                int fieldIndex = 0;\n+                Type[] argumentTypes = Type.getArgumentTypes(staticCommitMethod.getDescriptor());\n+                mv.visitCode();\n+                Label start = new Label();\n+                Label endTryBlock = new Label();\n+                Label exceptionHandler = new Label();\n+                mv.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n+                mv.visitLabel(start);\n+                getEventWriter(mv);\n+                \/\/ stack: [EW]\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW], [EW]\n+                \/\/ write begin event\n+                getEventConfiguration(mv);\n+                \/\/ stack: [EW], [EW], [EventConfiguration]\n+                mv.visitLdcInsn(eventTypeId);\n+                \/\/ stack: [EW], [EW], [EventConfiguration] [long]\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asASM());\n+                \/\/ stack: [EW], [integer]\n+                Label excluded = new Label();\n+                mv.visitJumpInsn(Opcodes.IFEQ, excluded);\n+                \/\/ stack: [EW]\n+                \/\/ write startTime\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW], [EW]\n+                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n+                \/\/ stack: [EW], [EW], [long]\n+                slotIndex += argumentTypes[argIndex++].getSize();\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n+                \/\/ stack: [EW]\n+                fieldIndex++;\n+                \/\/ write duration\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW], [EW]\n+                mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n+                \/\/ stack: [EW], [EW], [long]\n+                slotIndex += argumentTypes[argIndex++].getSize();\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asASM());\n+                \/\/ stack: [EW]\n+                fieldIndex++;\n+                \/\/ write eventThread\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW], [EW]\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n+                \/\/ stack: [EW]\n+                \/\/ write stackTrace\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW], [EW]\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n+                \/\/ stack: [EW]\n+                \/\/ write custom fields\n+                while (fieldIndex < fieldInfos.size()) {\n+                    mv.visitInsn(Opcodes.DUP);\n+                    \/\/ stack: [EW], [EW]\n+                    mv.visitVarInsn(argumentTypes[argIndex].getOpcode(Opcodes.ILOAD), slotIndex);\n+                    \/\/ stack:[EW], [EW], [field]\n+                    slotIndex += argumentTypes[argIndex++].getSize();\n+                    FieldInfo field = fieldInfos.get(fieldIndex);\n+                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+                    visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, eventMethod.asASM());\n+                    \/\/ stack: [EW]\n+                    fieldIndex++;\n+                }\n+                \/\/ stack: [EW]\n+                \/\/ write end event (writer already on stack)\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n+                \/\/ stack [integer]\n+                \/\/ notified -> restart event write attempt\n+                mv.visitJumpInsn(Opcodes.IFEQ, start);\n+                \/\/ stack:\n+                mv.visitLabel(endTryBlock);\n+                Label end = new Label();\n+                mv.visitJumpInsn(Opcodes.GOTO, end);\n+                mv.visitLabel(exceptionHandler);\n+                \/\/ stack: [ex]\n+                mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n+                getEventWriter(mv);\n+                \/\/ stack: [ex] [EW]\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [ex] [EW] [EW]\n+                Label rethrow = new Label();\n+                mv.visitJumpInsn(Opcodes.IFNULL, rethrow);\n+                \/\/ stack: [ex] [EW]\n+                mv.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [ex] [EW] [EW]\n+                visitMethod(mv, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n+                mv.visitLabel(rethrow);\n+                \/\/ stack:[ex] [EW]\n+                mv.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n+                mv.visitInsn(Opcodes.POP);\n+                \/\/ stack:[ex]\n+                mv.visitInsn(Opcodes.ATHROW);\n+                mv.visitLabel(excluded);\n+                \/\/ stack: [EW]\n+                mv.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n+                mv.visitInsn(Opcodes.POP);\n+                mv.visitLabel(end);\n+                \/\/ stack:\n+                mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                mv.visitInsn(Opcodes.RETURN);\n+                mv.visitMaxs(0, 0);\n+                mv.visitEnd();\n+            });\n+        } else {\n+            updateMethod(METHOD_COMMIT, methodVisitor -> {\n+                \/\/ if (!isEnable()) {\n+                \/\/ return;\n+                \/\/ }\n+                methodVisitor.visitCode();\n+                Label start = new Label();\n+                Label endTryBlock = new Label();\n+                Label exceptionHandler = new Label();\n+                methodVisitor.visitTryCatchBlock(start, endTryBlock, exceptionHandler, \"java\/lang\/Throwable\");\n+                methodVisitor.visitLabel(start);\n@@ -436,9 +500,134 @@\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, fi.internalClassName, fi.fieldName, fi.fieldDescriptor);\n-            }\n-\n-            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, eventHandlerXInternalName, writeMethod.getName(), writeMethod.getDescriptor(), false);\n-            methodVisitor.visitLabel(end);\n-            methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-            methodVisitor.visitInsn(Opcodes.RETURN);\n-            methodVisitor.visitEnd();\n-        });\n+                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), METHOD_IS_ENABLED.getName(), METHOD_IS_ENABLED.getDescriptor(), false);\n+                Label l0 = new Label();\n+                methodVisitor.visitJumpInsn(Opcodes.IFNE, l0);\n+                methodVisitor.visitInsn(Opcodes.RETURN);\n+                methodVisitor.visitLabel(l0);\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                \/\/ if (startTime == 0) {\n+                \/\/ startTime = EventWriter.timestamp();\n+                \/\/ } else {\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitInsn(Opcodes.LCONST_0);\n+                methodVisitor.visitInsn(Opcodes.LCMP);\n+                Label durationalEvent = new Label();\n+                methodVisitor.visitJumpInsn(Opcodes.IFNE, durationalEvent);\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n+                methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                Label commit = new Label();\n+                methodVisitor.visitJumpInsn(Opcodes.GOTO, commit);\n+                \/\/ if (duration == 0) {\n+                \/\/ duration = EventWriter.timestamp() - startTime;\n+                \/\/ }\n+                \/\/ }\n+                methodVisitor.visitLabel(durationalEvent);\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n+                methodVisitor.visitInsn(Opcodes.LCONST_0);\n+                methodVisitor.visitInsn(Opcodes.LCMP);\n+                methodVisitor.visitJumpInsn(Opcodes.IFNE, commit);\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP.getName(), METHOD_TIME_STAMP.getDescriptor(), false);\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                methodVisitor.visitInsn(Opcodes.LSUB);\n+                methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n+                methodVisitor.visitLabel(commit);\n+                \/\/ if (shouldCommit()) {\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                invokeVirtual(methodVisitor, getInternalClassName(), METHOD_EVENT_SHOULD_COMMIT);\n+                Label end = new Label();\n+                methodVisitor.visitJumpInsn(Opcodes.IFEQ, end);\n+                getEventWriter(methodVisitor);\n+                \/\/ stack: [EW]\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW] [EW]\n+                getEventConfiguration(methodVisitor);\n+                \/\/ stack: [EW] [EW] [EC]\n+                methodVisitor.visitLdcInsn(eventTypeId);\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.BEGIN_EVENT.asmMethod);\n+                Label excluded = new Label();\n+                \/\/ stack: [EW] [int]\n+                methodVisitor.visitJumpInsn(Opcodes.IFEQ, excluded);\n+                \/\/ stack: [EW]\n+                int fieldIndex = 0;\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW] [EW]\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                \/\/ stack: [EW] [EW] [this]\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_START_TIME, \"J\");\n+                \/\/ stack: [EW] [EW] [long]\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n+                \/\/ stack: [EW]\n+                fieldIndex++;\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW] [EW]\n+                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                \/\/ stack: [EW] [EW] [this]\n+                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), FIELD_DURATION, \"J\");\n+                \/\/ stack: [EW] [EW] [long]\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_LONG.asmMethod);\n+                \/\/ stack: [EW]\n+                fieldIndex++;\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW] [EW]\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_EVENT_THREAD.asASM());\n+                \/\/ stack: [EW]\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [EW] [EW]\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.PUT_STACK_TRACE.asASM());\n+                \/\/ stack: [EW]\n+                while (fieldIndex < fieldInfos.size()) {\n+                    FieldInfo field = fieldInfos.get(fieldIndex);\n+                    methodVisitor.visitInsn(Opcodes.DUP);\n+                    \/\/ stack: [EW] [EW]\n+                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n+                    \/\/ stack: [EW] [EW] [this]\n+                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.fieldName, field.fieldDescriptor);\n+                    \/\/ stack: [EW] [EW] <T>\n+                    EventWriterMethod eventMethod = EventWriterMethod.lookupMethod(field);\n+                    invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, eventMethod.asmMethod);\n+                    \/\/ stack: [EW]\n+                    fieldIndex++;\n+                }\n+                \/\/ stack:[EW]\n+                invokeVirtual(methodVisitor, TYPE_EVENT_WRITER, EventWriterMethod.END_EVENT.asASM());\n+                \/\/ stack [int]\n+                \/\/ notified -> restart event write attempt\n+                methodVisitor.visitJumpInsn(Opcodes.IFEQ, start);\n+                methodVisitor.visitLabel(endTryBlock);\n+                methodVisitor.visitJumpInsn(Opcodes.GOTO, end);\n+                methodVisitor.visitLabel(exceptionHandler);\n+                \/\/ stack: [ex]\n+                methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { \"java\/lang\/Throwable\" });\n+                getEventWriter(methodVisitor);\n+                \/\/ stack: [ex] [EW]\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [ex] [EW] [EW]\n+                Label rethrow = new Label();\n+                methodVisitor.visitJumpInsn(Opcodes.IFNULL, rethrow);\n+                \/\/ stack: [ex] [EW]\n+                methodVisitor.visitInsn(Opcodes.DUP);\n+                \/\/ stack: [ex] [EW] [EW]\n+                visitMethod(methodVisitor, Opcodes.INVOKEVIRTUAL, TYPE_EVENT_WRITER, METHOD_RESET);\n+                methodVisitor.visitLabel(rethrow);\n+                \/\/ stack:[ex] [EW]\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 2, new Object[] { \"java\/lang\/Throwable\", TYPE_EVENT_WRITER.getInternalName() });\n+                methodVisitor.visitInsn(Opcodes.POP);\n+                \/\/ stack:[ex]\n+                methodVisitor.visitInsn(Opcodes.ATHROW);\n+                methodVisitor.visitLabel(excluded);\n+                \/\/ stack: [EW]\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 1, new Object[] { TYPE_EVENT_WRITER.getInternalName() });\n+                methodVisitor.visitInsn(Opcodes.POP);\n+                methodVisitor.visitLabel(end);\n+                \/\/ stack:\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                methodVisitor.visitInsn(Opcodes.RETURN);\n+                methodVisitor.visitMaxs(0, 0);\n+                methodVisitor.visitEnd();\n+            });\n+        }\n@@ -449,2 +638,2 @@\n-            if (guardHandlerReference) {\n-                getEventHandler(methodVisitor);\n+            if (guardEventConfiguration) {\n+                getEventConfiguration(methodVisitor);\n@@ -453,2 +642,2 @@\n-            \/\/ if (!eventHandler.shouldCommit(duration) goto fail;\n-            getEventHandler(methodVisitor);\n+            \/\/ if (!eventConfiguration.shouldCommit(duration) goto fail;\n+            getEventConfiguration(methodVisitor);\n@@ -457,1 +646,1 @@\n-            ASMToolkit.invokeVirtual(methodVisitor, TYPE_EVENT_HANDLER.getInternalName(), METHOD_EVENT_HANDLER_SHOULD_COMMIT);\n+            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n@@ -459,0 +648,1 @@\n+            int index = 0;\n@@ -460,1 +650,1 @@\n-                \/\/ if (!settingsMethod(eventHandler.settingX)) goto fail;\n+                \/\/ if (!settingsMethod(eventConfiguration.settingX)) goto fail;\n@@ -462,2 +652,2 @@\n-                if (untypedEventHandler) {\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_HANDLER, TYPE_OBJECT.getDescriptor());\n+                if (untypedEventConfiguration) {\n+                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n@@ -465,1 +655,1 @@\n-                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_HANDLER, Type.getDescriptor(EventHandler.class));\n+                    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n@@ -467,4 +657,5 @@\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, eventHandlerXInternalName);\n-                methodVisitor.visitFieldInsn(Opcodes.GETFIELD, eventHandlerXInternalName, si.fieldName, TYPE_SETTING_CONTROL.getDescriptor());\n-                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, si.internalSettingName);\n-                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), si.methodName, \"(\" + si.settingDescriptor + \")Z\", false);\n+                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, TYPE_EVENT_CONFIGURATION.getInternalName());\n+                methodVisitor.visitLdcInsn(index);\n+                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_GET_SETTING);\n+                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, si.paramType().getInternalName());\n+                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, getInternalClassName(), si.methodName, \"(\" + si.paramType().getDescriptor() + \")Z\", false);\n@@ -472,0 +663,1 @@\n+                index++;\n@@ -483,0 +675,20 @@\n+    private void getEventWriter(MethodVisitor mv) {\n+        mv.visitLdcInsn(EventWriterKey.getKey());\n+        visitMethod(mv, Opcodes.INVOKESTATIC, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n+    }\n+\n+    private void visitMethod(final MethodVisitor mv, final int opcode, final Type type, final Method method) {\n+        mv.visitMethodInsn(opcode, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n+    }\n+\n+    private static void invokeStatic(MethodVisitor methodVisitor, String className, Method m) {\n+        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, className, m.getName(), m.getDescriptor(), false);\n+    }\n+\n+    private static void invokeVirtual(MethodVisitor methodVisitor, String className, Method m) {\n+        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, m.getName(), m.getDescriptor(), false);\n+    }\n+\n+    private void invokeVirtual(MethodVisitor methodVisitor, Type type, Method method) {\n+        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type.getInternalName(), method.getName(), method.getDescriptor(), false);\n+    }\n@@ -484,4 +696,3 @@\n-    private void getEventHandler(MethodVisitor methodVisitor) {\n-        if (untypedEventHandler) {\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_HANDLER, TYPE_OBJECT.getDescriptor());\n-            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, TYPE_EVENT_HANDLER.getInternalName());\n+    private void getEventConfiguration(MethodVisitor methodVisitor) {\n+        if (untypedEventConfiguration) {\n+            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_OBJECT_DESCRIPTOR);\n@@ -489,1 +700,1 @@\n-            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_HANDLER, Type.getDescriptor(EventHandler.class));\n+            methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, getInternalClassName(), FIELD_EVENT_CONFIGURATION, TYPE_EVENT_CONFIGURATION_DESCRIPTOR);\n@@ -497,0 +708,3 @@\n+        if (staticCommitMethod != null) {\n+            updateExistingWithEmptyVoidMethod(staticCommitMethod);\n+        }\n@@ -536,10 +750,0 @@\n-    public static Method makeWriteMethod(List<FieldInfo> fields) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        for (FieldInfo v : fields) {\n-            sb.append(v.fieldDescriptor);\n-        }\n-        sb.append(\")V\");\n-        return new Method(\"write\", sb.toString());\n-    }\n-\n@@ -550,8 +754,0 @@\n-    public List<SettingInfo> getSettingInfos() {\n-        return settingInfos;\n-    }\n-\n-    public List<FieldInfo> getFieldInfos() {\n-        return fieldInfos;\n-    }\n-\n@@ -561,4 +757,0 @@\n-\n-    public void setGuardHandler(boolean guardHandlerReference) {\n-        this.guardHandlerReference = guardHandlerReference;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":380,"deletions":188,"binary":false,"changes":568,"status":"modified"},{"patch":"@@ -1,376 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.jfr.internal.consumer.StringParser;\n-\n-\/**\n- * Class must reside in a package with package restriction.\n- *\n- * Users should not have direct access to underlying memory.\n- *\n- *\/\n-public final class EventWriter {\n-\n-    \/\/ Event may not exceed size for a padded integer\n-    private static final long MAX_EVENT_SIZE = (1 << 28) -1;\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-    private static final JVM jvm = JVM.getJVM();\n-\n-    \/\/ The JVM needs access to these values. Don't remove\n-    private final long threadID;\n-    private long startPosition;\n-    private long startPositionAddress;\n-    private long currentPosition;\n-    private long maxPosition;\n-    private boolean valid;\n-    boolean notified; \/\/ Not private to avoid being optimized away\n-    boolean excluded;\n-\n-    private PlatformEventType eventType;\n-    private boolean flushOnEnd;\n-    private boolean largeSize = false;\n-\n-    public static EventWriter getEventWriter() {\n-        EventWriter ew = JVM.getEventWriter();\n-        return ew != null ? ew : JVM.newEventWriter();\n-    }\n-\n-    public void putBoolean(boolean i) {\n-        if (isValidForSize(Byte.BYTES)) {\n-            currentPosition += Bits.putBoolean(currentPosition, i);\n-        }\n-    }\n-\n-    public void putByte(byte i) {\n-        if (isValidForSize(Byte.BYTES)) {\n-            unsafe.putByte(currentPosition, i);\n-            ++currentPosition;\n-        }\n-    }\n-\n-    public void putChar(char v) {\n-        if (isValidForSize(Character.BYTES + 1)) {\n-            putUncheckedLong(v);\n-        }\n-    }\n-\n-    private void putUncheckedChar(char v) {\n-        putUncheckedLong(v);\n-    }\n-\n-    public void putShort(short v) {\n-        if (isValidForSize(Short.BYTES + 1)) {\n-            putUncheckedLong(v & 0xFFFF);\n-        }\n-    }\n-\n-    public void putInt(int v) {\n-        if (isValidForSize(Integer.BYTES + 1)) {\n-            putUncheckedLong(v & 0x00000000ffffffffL);\n-        }\n-    }\n-\n-    private void putUncheckedInt(int v) {\n-        putUncheckedLong(v & 0x00000000ffffffffL);\n-    }\n-\n-    public void putFloat(float i) {\n-        if (isValidForSize(Float.BYTES)) {\n-            currentPosition += Bits.putFloat(currentPosition, i);\n-        }\n-    }\n-\n-    public void putLong(long v) {\n-        if (isValidForSize(Long.BYTES + 1)) {\n-            putUncheckedLong(v);\n-        }\n-    }\n-\n-    public void putDouble(double i) {\n-        if (isValidForSize(Double.BYTES)) {\n-            currentPosition += Bits.putDouble(currentPosition, i);\n-        }\n-    }\n-\n-    public void putString(String s, StringPool pool) {\n-        if (s == null) {\n-            putByte(StringParser.Encoding.NULL.byteValue());\n-            return;\n-        }\n-        int length = s.length();\n-        if (length == 0) {\n-            putByte(StringParser.Encoding.EMPTY_STRING.byteValue());\n-            return;\n-        }\n-        if (length > StringPool.MIN_LIMIT && length < StringPool.MAX_LIMIT) {\n-            long l = StringPool.addString(s);\n-            if (l > 0) {\n-                putByte(StringParser.Encoding.CONSTANT_POOL.byteValue());\n-                putLong(l);\n-                return;\n-            }\n-        }\n-        putStringValue(s);\n-        return;\n-    }\n-\n-    private void putStringValue(String s) {\n-        int length = s.length();\n-        if (isValidForSize(1 + 5 + 3 * length)) {\n-            putUncheckedByte(StringParser.Encoding.CHAR_ARRAY.byteValue()); \/\/ 1 byte\n-            putUncheckedInt(length); \/\/ max 5 bytes\n-            for (int i = 0; i < length; i++) {\n-                putUncheckedChar(s.charAt(i)); \/\/ max 3 bytes\n-            }\n-        }\n-    }\n-\n-    public void putEventThread() {\n-        putLong(threadID);\n-    }\n-\n-    public void putThread(Thread athread) {\n-        if (athread == null) {\n-            putLong(0L);\n-        } else {\n-            putLong(jvm.getThreadId(athread));\n-        }\n-    }\n-\n-    public void putClass(Class<?> aClass) {\n-        if (aClass == null) {\n-            putLong(0L);\n-        } else {\n-            putLong(JVM.getClassId(aClass));\n-        }\n-    }\n-\n-    public void putStackTrace() {\n-        if (eventType.getStackTraceEnabled()) {\n-            putLong(jvm.getStackTraceId(eventType.getStackTraceOffset()));\n-        } else {\n-            putLong(0L);\n-        }\n-    }\n-\n-    private void reserveEventSizeField() {\n-        this.largeSize = eventType.isLargeSize();\n-        if (largeSize) {\n-            if (isValidForSize(Integer.BYTES)) {\n-                currentPosition +=  Integer.BYTES;\n-            }\n-        } else {\n-            if (isValidForSize(1)) {\n-                currentPosition += 1;\n-            }\n-        }\n-    }\n-\n-    public void reset() {\n-        currentPosition = startPosition;\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n-        }\n-        valid = true;\n-    }\n-\n-    private boolean isValidForSize(int requestedSize) {\n-        if (!valid) {\n-            return false;\n-        }\n-        if (currentPosition + requestedSize > maxPosition) {\n-            flushOnEnd = flush(usedSize(), requestedSize);\n-            \/\/ retry\n-            if (!valid) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isNotified() {\n-        return notified;\n-    }\n-\n-    private void resetNotified() {\n-        notified = false;\n-    }\n-\n-    private void resetStringPool() {\n-        StringPool.reset();\n-    }\n-\n-    private int usedSize() {\n-        return (int) (currentPosition - startPosition);\n-    }\n-\n-    private boolean flush() {\n-        return flush(usedSize(), 0);\n-    }\n-\n-    private boolean flush(int usedSize, int requestedSize) {\n-        return JVM.flush(this, usedSize, requestedSize);\n-    }\n-\n-    public boolean beginEvent(PlatformEventType eventType) {\n-        if (excluded) {\n-            \/\/ thread is excluded from writing events\n-            return false;\n-        }\n-        this.eventType = eventType;\n-        reserveEventSizeField();\n-        putLong(eventType.getId());\n-        return true;\n-    }\n-\n-    public boolean endEvent() {\n-        if (!valid) {\n-            reset();\n-            return true;\n-        }\n-        final int eventSize = usedSize();\n-        if (eventSize > MAX_EVENT_SIZE) {\n-            reset();\n-            return true;\n-        }\n-\n-        if (largeSize) {\n-            Bits.putInt(startPosition, makePaddedInt(eventSize));\n-        } else {\n-            if (eventSize < 128) {\n-                Bits.putByte(startPosition, (byte) eventSize);\n-            } else {\n-                eventType.setLargeSize();\n-                reset();\n-                \/\/ returning false will trigger restart of the\n-                \/\/ event write attempt\n-                return false;\n-            }\n-        }\n-\n-        if (isNotified()) {\n-            resetNotified();\n-            resetStringPool();\n-            reset();\n-            \/\/ returning false will trigger restart of the event write attempt\n-            return false;\n-        }\n-        startPosition = currentPosition;\n-        unsafe.storeStoreFence();\n-        unsafe.putAddress(startPositionAddress, currentPosition);\n-        \/\/ the event is now committed\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n-        }\n-        return true;\n-    }\n-\n-    private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid, boolean excluded) {\n-        startPosition = currentPosition = startPos;\n-        maxPosition = maxPos;\n-        startPositionAddress = startPosAddress;\n-        this.threadID = threadID;\n-        flushOnEnd = false;\n-        this.valid = valid;\n-        notified = false;\n-        this.excluded = excluded;\n-    }\n-\n-    private static int makePaddedInt(int v) {\n-        \/\/ bit  0-6 + pad => bit 24 - 31\n-        long b1 = (((v >>> 0) & 0x7F) | 0x80) << 24;\n-\n-        \/\/ bit  7-13 + pad => bit 16 - 23\n-        long b2 = (((v >>> 7) & 0x7F) | 0x80) << 16;\n-\n-        \/\/ bit 14-20 + pad => bit  8 - 15\n-        long b3 = (((v >>> 14) & 0x7F) | 0x80) << 8;\n-\n-        \/\/ bit 21-28       => bit  0 -  7\n-        long b4 = (((v >>> 21) & 0x7F)) << 0;\n-\n-        return (int) (b1 + b2 + b3 + b4);\n-    }\n-\n-    private void putUncheckedLong(long v) {\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 0-6\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 0-6\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 7-13\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 7-13\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 14-20\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 14-20\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 21-27\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 21-27\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 28-34\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 28-34\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 35-41\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 35-41\n-        v >>>= 7;\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 42-48\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 42-48\n-        v >>>= 7;\n-\n-        if ((v & ~0x7FL) == 0L) {\n-            putUncheckedByte((byte) v); \/\/ 49-55\n-            return;\n-        }\n-        putUncheckedByte((byte) (v | 0x80L)); \/\/ 49-55\n-        putUncheckedByte((byte) (v >>> 7)); \/\/ 56-63, last byte as is.\n-    }\n-\n-    private void putUncheckedByte(byte i) {\n-        unsafe.putByte(currentPosition, i);\n-        ++currentPosition;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriter.java","additions":0,"deletions":376,"binary":false,"changes":376,"status":"deleted"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+import jdk.jfr.internal.event.EventWriter;\n+\n+\/\/ This class is not directly used but renamed to\n+\/\/ jdk.jfr.event.EventWriterFactory and loaded dynamically\n+\/\/ when the first event class is bytecode instrumented.\n+\/\/ See JVMUpcall and EventWriterKey::ensureEventWriterFactory()\n+public final class EventWriterFactoryRecipe {\n+    private static final long KEY = EventWriterKey.getKey();\n+\n+    public static EventWriter getEventWriter(long key) {\n+        if (key == KEY) {\n+            EventWriter ew = JVM.getEventWriter();\n+            return ew != null ? ew : JVM.newEventWriter();\n+        }\n+        EventWriterKey.block();\n+        return null; \/\/ Can't reach here.\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterFactoryRecipe.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+import java.io.InputStream;\n+\n+\/\/ Purpose of this class is NOT to create a cryptographically\n+\/\/ strong random number. but to quickly generate a value hard to guess\n+\/\/ without the need to load classes or have an impact on security\n+\/\/ related events, like SecureRandom::getAlgorithm(\"NativePRNGNonBlocking\") does\n+public final class EventWriterKey {\n+    private final static long KEY = createKey();\n+    private static boolean loaded;\n+    private static boolean logged;\n+\n+    public static long getKey() {\n+        return KEY;\n+    }\n+\n+    private static long createKey() {\n+        JVM jvm = JVM.getJVM();\n+        long r = mixMurmur64(System.identityHashCode(new Object()));\n+        r = 31 * r + mixMurmur64(jvm.getPid().hashCode());\n+        r = 31 * r + mixMurmur64(System.nanoTime());\n+        r = 31 * r + mixMurmur64(Thread.currentThread().threadId());\n+        r = 31 * r + mixMurmur64(System.currentTimeMillis());\n+        r = 31 * r + mixMurmur64(jvm.getTypeId(JVM.class));\n+        r = 31 * r + mixMurmur64(JVM.counterTime());\n+        return mixMurmur64(r);\n+    }\n+\n+    \/\/ Copied from jdk.internal.util.random.RandomSupport.mixMurmur64(long)\n+    private static long mixMurmur64(long z) {\n+        z = (z ^ (z >>> 33)) * 0xff51afd7ed558ccdL;\n+        z = (z ^ (z >>> 33)) * 0xc4ceb9fe1a85ec53L;\n+        return z ^ (z >>> 33);\n+    }\n+\n+    public static void ensureEventWriterFactory() {\n+        if (loaded) {\n+            return;\n+        }\n+        String name = \"\/jdk\/jfr\/internal\/EventWriterFactoryRecipe.class\";\n+        try (InputStream is = EventWriterKey.class.getResourceAsStream(name)) {\n+            byte[] bytes = is.readAllBytes();\n+            bytes = replace(bytes,\n+                    \"jdk\/jfr\/internal\/EventWriterFactoryRecipe\",\n+                    \"jdk\/jfr\/internal\/event\/EventWriterFactory\");\n+            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+            SecuritySupport.defineClass(c, bytes);\n+            loaded = true;\n+        } catch (Throwable e) {\n+           throw new InternalError(\"Could not read bytecode for \" + name, e);\n+        }\n+        Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"EventWriterFactory created\");\n+    }\n+\n+    \/\/ Starve the system of resources to prevent further attempts.\n+    \/\/ Note, code that have the capability to invoke this method\n+    \/\/ could spin in a loop anyway. Alternatives, such as System.exit(1),\n+    \/\/ may provide caller with additional capabilities.\n+    public static void block() {\n+        \/\/ Making this field variable a local variable leads to CTW failure\n+        logged = false;\n+        while (true) {\n+            try {\n+                if (!logged) {\n+                    \/\/ Only log once to prevent flooding of log.\n+                    logged = true;\n+                    \/\/ Purposely don't call Thread::getName() since it can be overridden\n+                    Logger.log(LogTag.JFR, LogLevel.ERROR, \"Malicious attempt to access JFR buffers. Stopping thread from further execution.\");\n+                }\n+            } catch (Throwable t) {\n+                \/\/ Ensure code can't break out and retry\n+            }\n+        }\n+    }\n+\n+    private static byte[] replace(byte[] bytes, String match, String replacement) {\n+        if (match.length() != replacement.length()) {\n+            throw new IllegalArgumentException(\"Match must be same size as replacement\");\n+        }\n+        for (int i = 0; i < bytes.length - match.length(); i++) {\n+            if (match(bytes, i, match)) {\n+                for (int j = 0; j < replacement.length(); j++) {\n+                    bytes[i + j] = (byte) replacement.charAt(j);\n+                }\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    private static boolean match(byte[] bytes, int offset, String text) {\n+        for (int i = 0; i < text.length(); i++) {\n+            if (bytes[offset + i] != text.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterKey.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -33,1 +34,1 @@\n-    BEGIN_EVENT(\"(\" + jdk.internal.org.objectweb.asm.Type.getType(PlatformEventType.class).getDescriptor() + \")Z\", \"???\", \"beginEvent\"),\n+    BEGIN_EVENT(\"(\" + jdk.internal.org.objectweb.asm.Type.getType(EventConfiguration.class).getDescriptor() + \"J)Z\", \"???\", \"beginEvent\"),\n@@ -45,1 +46,1 @@\n-    PUT_STRING(\"(Ljava\/lang\/String;Ljdk\/jfr\/internal\/StringPool;)V\", Type.STRING.getName(), \"putString\"),\n+    PUT_STRING(\"(Ljava\/lang\/String;)V\", Type.STRING.getName(), \"putString\"),\n@@ -49,2 +50,2 @@\n-    private final Method asmMethod;\n-    private final String typeDescriptor;\n+    final Method asmMethod;\n+    final String typeDescriptor;\n@@ -71,1 +72,1 @@\n-        if (v.fieldName.equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (v.fieldName().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n@@ -75,1 +76,1 @@\n-            if (v.fieldDescriptor.equals(m.typeDescriptor)) {\n+            if (v.fieldDescriptor().equals(m.typeDescriptor)) {\n@@ -79,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + v.fieldDescriptor);\n+        throw new Error(\"Unknown type \" + v.fieldDescriptor());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-import jdk.jfr.internal.EventWriter;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.internal.event.EventWriter;\n@@ -215,1 +215,1 @@\n-    public synchronized native void retransformClasses(Class<?>[] classes);\n+     public synchronized native void retransformClasses(Class<?>[] classes);\n@@ -564,1 +564,1 @@\n-     * Test if a thread ius currently excluded from the jfr system.\n+     * Test if a thread is currently excluded from the jfr system.\n@@ -570,0 +570,18 @@\n+    \/**\n+     * Test if a class is excluded from the jfr system.\n+     *\n+     * @param eventClass the class, not {@code null}\n+     *\n+     * @return is class excluded\n+     *\/\n+    public native boolean isExcluded(Class<? extends jdk.internal.event.Event> eventClass);\n+\n+    \/**\n+     * Test if a class is instrumented.\n+     *\n+     * @param eventClass the class, not {@code null}\n+     *\n+     * @return is class instrumented\n+     *\/\n+    public native boolean isInstrumented(Class<? extends jdk.internal.event.Event> eventClass);\n+\n@@ -578,1 +596,1 @@\n-     * Stores an EventHandler to the eventHandler field of an event class.\n+     * Stores an EventConfiguration to the configuration field of an event class.\n@@ -582,1 +600,1 @@\n-     * @param handler the handler, may be {@code null}\n+     * @param configuration the configuration, may be {@code null}\n@@ -586,1 +604,1 @@\n-    public native boolean setHandler(Class<? extends jdk.internal.event.Event> eventClass, EventHandler handler);\n+    public native boolean setConfiguration(Class<? extends jdk.internal.event.Event> eventClass, EventConfiguration configuration);\n@@ -589,1 +607,1 @@\n-     * Retrieves the EventHandler for an event class.\n+     * Retrieves the EventConfiguration for an event class.\n@@ -593,1 +611,1 @@\n-     * @return the handler, may be {@code null}\n+     * @return the configuration, may be {@code null}\n@@ -595,1 +613,1 @@\n-    public native Object getHandler(Class<? extends jdk.internal.event.Event> eventClass);\n+    public native Object getConfiguration(Class<? extends jdk.internal.event.Event> eventClass);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -31,1 +31,0 @@\n-\n@@ -53,1 +52,1 @@\n-    static byte[] onRetransform(long traceId, boolean dummy, Class<?> clazz, byte[] oldBytes) throws Throwable {\n+    static byte[] onRetransform(long traceId, boolean dummy1, boolean dummy2, Class<?> clazz, byte[] oldBytes) throws Throwable {\n@@ -56,3 +55,4 @@\n-                EventHandler handler = Utils.getHandler(clazz.asSubclass(jdk.internal.event.Event.class));\n-                if (handler == null) {\n-                    Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"No event handler found for \" + clazz.getName() + \". Ignoring instrumentation request.\");\n+                EventWriterKey.ensureEventWriterFactory();\n+                EventConfiguration configuration = Utils.getConfiguration(clazz.asSubclass(jdk.internal.event.Event.class));\n+                if (configuration == null) {\n+                    Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"No event configuration found for \" + clazz.getName() + \". Ignoring instrumentation request.\");\n@@ -62,0 +62,1 @@\n+                boolean bootClassLoader = clazz.getClassLoader() == null;\n@@ -63,1 +64,1 @@\n-                EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId);\n+                EventInstrumentation ei = new EventInstrumentation(clazz.getSuperclass(), oldBytes, traceId, bootClassLoader, false);\n@@ -73,1 +74,0 @@\n-\n@@ -91,1 +91,1 @@\n-    static byte[] bytesForEagerInstrumentation(long traceId, boolean forceInstrumentation, Class<?> superClass, byte[] oldBytes) throws Throwable {\n+    static byte[] bytesForEagerInstrumentation(long traceId, boolean forceInstrumentation, boolean bootClassLoader, Class<?> superClass, byte[] oldBytes) throws Throwable {\n@@ -97,1 +97,1 @@\n-            EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId);\n+            EventInstrumentation ei = new EventInstrumentation(superClass, oldBytes, traceId, bootClassLoader, true);\n@@ -110,4 +110,1 @@\n-            \/\/ Corner case when we are forced to generate bytecode. We can't reference the event\n-            \/\/ handler in #isEnabled() before event class has been registered, so we add a\n-            \/\/ guard against a null reference.\n-            ei.setGuardHandler(true);\n+            EventWriterKey.ensureEventWriterFactory();\n@@ -115,4 +112,0 @@\n-            EventHandlerCreator eh = new EventHandlerCreator(traceId, ei.getSettingInfos(), ei.getFieldInfos());\n-            \/\/ Handler class must be loaded before instrumented event class can\n-            \/\/ be used\n-            eh.makeEventHandlerClass();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import static jdk.jfr.internal.LogLevel.DEBUG;\n-import static jdk.jfr.internal.LogTag.JFR_SYSTEM;\n-\n@@ -34,0 +31,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -42,0 +41,1 @@\n+import java.util.Set;\n@@ -50,0 +50,2 @@\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.internal.EventInstrumentation.SettingInfo;\n@@ -52,1 +54,1 @@\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -64,0 +66,1 @@\n+    private Constructor<EventConfiguration> cachedEventConfigurationConstructor;\n@@ -67,1 +70,0 @@\n-    private Instant outputChange;\n@@ -103,5 +105,5 @@\n-        List<EventHandler> handlers = getEventHandlers();\n-        List<EventType> eventTypes = new ArrayList<>(handlers.size() + nativeEventTypes.size());\n-        for (EventHandler h : handlers) {\n-            if (h.isRegistered()) {\n-                eventTypes.add(h.getEventType());\n+        List<EventConfiguration> configurations = getEventConfigurations();\n+        List<EventType> eventTypes = new ArrayList<>(configurations.size() + nativeEventTypes.size());\n+        for (EventConfiguration ec : configurations) {\n+            if (ec.isRegistered()) {\n+                eventTypes.add(ec.getEventType());\n@@ -119,3 +121,3 @@\n-        EventHandler h = getHandler(eventClass, false);\n-        if (h != null && h.isRegistered()) {\n-            return h.getEventType();\n+        EventConfiguration ec = getConfiguration(eventClass, false);\n+        if (ec != null && ec.isRegistered()) {\n+            return ec.getEventType();\n@@ -128,3 +130,3 @@\n-        EventHandler handler = getHandler(eventClass, false);\n-        if (handler != null) {\n-            handler.setRegistered(false);\n+        EventConfiguration configuration = getConfiguration(eventClass, false);\n+        if (configuration != null) {\n+            configuration.getPlatformEventType().setRegistered(false);\n@@ -140,2 +142,10 @@\n-        EventHandler handler = getHandler(eventClass, true);\n-        if (handler == null) {\n+        if (jvm.isExcluded(eventClass)) {\n+            \/\/ Event classes are marked as excluded during class load\n+            \/\/ if they override methods in the jdk.jfr.Event class, i.e. commit().\n+            \/\/ An excluded class lacks configuration field and can't be used by JFR.\n+            \/\/ The Event::commit() is marked as final, so javac won't\n+            \/\/ compile an override, but it can be constructed by other means.\n+            throw new IllegalArgumentException(\"Must not override methods declared in jdk.jfr.Event\");\n+        }\n+        EventConfiguration configuration = getConfiguration(eventClass, true);\n+        if (configuration == null) {\n@@ -143,1 +153,1 @@\n-                \/\/ don't register mirrors\n+                \/\/ don't register mirrors classes.\n@@ -147,1 +157,1 @@\n-            handler = makeHandler(eventClass, pe, dynamicAnnotations, dynamicFields);\n+            configuration = makeConfiguration(eventClass, pe, dynamicAnnotations, dynamicFields);\n@@ -149,2 +159,2 @@\n-        handler.setRegistered(true);\n-        typeLibrary.addType(handler.getPlatformEventType());\n+        configuration.getPlatformEventType().setRegistered(true);\n+        typeLibrary.addType(configuration.getPlatformEventType());\n@@ -152,1 +162,1 @@\n-            settingsManager.setEventControl(handler.getEventControl());\n+            settingsManager.setEventControl(configuration.getEventControl());\n@@ -156,1 +166,1 @@\n-       return handler.getEventType();\n+       return configuration.getEventType();\n@@ -173,1 +183,1 @@\n-    private EventHandler getHandler(Class<? extends jdk.internal.event.Event> eventClass, boolean ensureInitialized) {\n+    private EventConfiguration getConfiguration(Class<? extends jdk.internal.event.Event> eventClass, boolean ensureInitialized) {\n@@ -179,1 +189,15 @@\n-        return Utils.getHandler(eventClass);\n+        return Utils.getConfiguration(eventClass);\n+    }\n+\n+    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec, SettingControl[] settings) {\n+        try {\n+            if (cachedEventConfigurationConstructor == null) {\n+                var argClasses = new Class<?>[] { EventType.class, EventControl.class, SettingControl[].class };\n+                Constructor<EventConfiguration> c = EventConfiguration.class.getDeclaredConstructor(argClasses);\n+                SecuritySupport.setAccessible(c);\n+                cachedEventConfigurationConstructor = c;\n+            }\n+            return cachedEventConfigurationConstructor.newInstance(eventType, ec, settings);\n+        } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+            throw new InternalError(e);\n+        }\n@@ -182,2 +206,2 @@\n-    private EventHandler makeHandler(Class<? extends jdk.internal.event.Event> eventClass, PlatformEventType pEventType, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) throws InternalError {\n-        SecuritySupport.addHandlerExport(eventClass);\n+    private EventConfiguration makeConfiguration(Class<? extends jdk.internal.event.Event> eventClass, PlatformEventType pEventType, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) throws InternalError {\n+        SecuritySupport.addInternalEventExport(eventClass);\n@@ -189,15 +213,14 @@\n-        Class<? extends EventHandler> handlerClass = null;\n-        try {\n-            String eventHandlerName = EventHandlerCreator.makeEventHandlerName(eventType.getId());\n-            handlerClass = Class.forName(eventHandlerName, false, Event.class.getClassLoader()).asSubclass(EventHandler.class);\n-            \/\/ Created eagerly on class load, tag as instrumented\n-            pEventType.setInstrumented();\n-            Logger.log(JFR_SYSTEM, DEBUG, \"Found existing event handler for \" + eventType.getName());\n-       } catch (ClassNotFoundException cne) {\n-           EventHandlerCreator ehc = new EventHandlerCreator(eventType.getId(),  ec.getSettingInfos(), eventType, eventClass);\n-           handlerClass = ehc.makeEventHandlerClass();\n-           Logger.log(LogTag.JFR_SYSTEM, DEBUG, \"Created event handler for \" + eventType.getName());\n-       }\n-        EventHandler handler = EventHandlerCreator.instantiateEventHandler(handlerClass, true, eventType, ec);\n-        Utils.setHandler(eventClass, handler);\n-        return handler;\n+        List<SettingInfo> settingInfos = ec.getSettingInfos();\n+        SettingControl[] settings = new SettingControl[settingInfos.size()];\n+        int index = 0;\n+        for (var settingInfo : settingInfos) {\n+            settings[index++] = settingInfo.settingControl();\n+        }\n+        EventConfiguration configuration = newEventConfiguration(eventType, ec, settings);\n+        PlatformEventType pe = configuration.getPlatformEventType();\n+        pe.setRegistered(true);\n+        if (jvm.isInstrumented(eventClass)) {\n+            pe.setInstrumented();\n+        }\n+        Utils.setConfiguration(eventClass, configuration);\n+        return configuration;\n@@ -206,1 +229,0 @@\n-\n@@ -222,1 +244,1 @@\n-            EventHandler eh = Utils.getHandler(clazz);\n+            EventConfiguration eh = Utils.getConfiguration(clazz);\n@@ -235,1 +257,1 @@\n-    private static List<EventHandler> getEventHandlers() {\n+    private static List<EventConfiguration> getEventConfigurations() {\n@@ -237,1 +259,1 @@\n-        List<EventHandler> eventHandlers = new ArrayList<>(allEventClasses.size());\n+        List<EventConfiguration> eventConfigurations = new ArrayList<>(allEventClasses.size());\n@@ -239,3 +261,3 @@\n-            EventHandler eh = Utils.getHandler(clazz);\n-            if (eh != null) {\n-                eventHandlers.add(eh);\n+            EventConfiguration ec = Utils.getConfiguration(clazz);\n+            if (ec != null) {\n+                eventConfigurations.add(ec);\n@@ -244,1 +266,1 @@\n-        return eventHandlers;\n+        return eventConfigurations;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":73,"deletions":51,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    private static boolean isUsingHandler(String name) {\n+    private static boolean isUsingConfiguration(String name) {\n@@ -105,1 +105,1 @@\n-            if (isUsingHandler(name)) {\n+            if (isUsingConfiguration(name)) {\n@@ -109,1 +109,1 @@\n-        return 4;\n+        return 3;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -56,0 +57,1 @@\n+import java.security.SecureRandom;\n@@ -85,1 +87,1 @@\n-        addHandlerExport(Object.class);\n+        addInternalEventExport(Object.class);\n@@ -293,2 +295,2 @@\n-     * Adds a qualified export of the internal.jdk.jfr.internal.handlers package\n-     * (for EventHandler)\n+     * Adds a qualified export of the internal.jdk.jfr.internal.event package\n+     * (for EventConfiguration and EventWriter)\n@@ -296,2 +298,2 @@\n-    static void addHandlerExport(Class<?> clazz) {\n-        Modules.addExports(JFR_MODULE, Utils.HANDLERS_PACKAGE_NAME, clazz.getModule());\n+    static void addInternalEventExport(Class<?> clazz) {\n+        Modules.addExports(JFR_MODULE, Utils.EVENT_PACKAGE_NAME, clazz.getModule());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -157,3 +157,3 @@\n-            EventHandler eh = Utils.getHandler(eventClass);\n-            if (eh != null ) {\n-                PlatformEventType eventType = eh.getPlatformEventType();\n+            EventConfiguration ec = Utils.getConfiguration(eventClass);\n+            if (ec != null ) {\n+                PlatformEventType eventType = ec.getPlatformEventType();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SettingsManager.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-    static final int MIN_LIMIT = 16;\n-    static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n+    public static final int MIN_LIMIT = 16;\n+    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n@@ -36,1 +36,1 @@\n-    static long addString(String s) {\n+    public static long addString(String s) {\n@@ -40,1 +40,1 @@\n-    static void reset() {\n+    public static void reset() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -77,1 +77,1 @@\n-    public static final String HANDLERS_PACKAGE_NAME = \"jdk.jfr.internal.handlers\";\n+    public static final String EVENT_PACKAGE_NAME = \"jdk.jfr.internal.event\";\n@@ -448,1 +448,1 @@\n-    public static synchronized EventHandler getHandler(Class<? extends jdk.internal.event.Event> eventClass) {\n+    public static synchronized EventConfiguration getConfiguration(Class<? extends jdk.internal.event.Event> eventClass) {\n@@ -450,3 +450,3 @@\n-        Object handler = JVM.getJVM().getHandler(eventClass);\n-        if (handler == null || handler instanceof EventHandler) {\n-            return (EventHandler) handler;\n+        Object configuration = JVM.getJVM().getConfiguration(eventClass);\n+        if (configuration == null || configuration instanceof EventConfiguration) {\n+            return (EventConfiguration) configuration;\n@@ -454,1 +454,1 @@\n-        throw new InternalError(\"Could not access event handler\");\n+        throw new InternalError(\"Could not get configuration object on event class \" + eventClass.getName());\n@@ -457,1 +457,1 @@\n-    static synchronized void setHandler(Class<? extends jdk.internal.event.Event> eventClass, EventHandler handler) {\n+    static synchronized void setConfiguration(Class<? extends jdk.internal.event.Event> eventClass, EventConfiguration configuration) {\n@@ -459,2 +459,2 @@\n-        if (!JVM.getJVM().setHandler(eventClass, handler)) {\n-            throw new InternalError(\"Could not set event handler\");\n+        if (!JVM.getJVM().setConfiguration(eventClass, configuration)) {\n+            throw new InternalError(\"Could not set configuration object on event class \" + eventClass.getName());\n@@ -525,0 +525,1 @@\n+            className = className.substring(className.lastIndexOf(\"\/\") + 1, className.length());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.event;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.internal.EventControl;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.PrivateAccess;\n+import jdk.jfr.SettingControl;\n+\n+\/\/ Users should not be able to subclass or instantiate for security reasons.\n+public final class EventConfiguration {\n+    private final PlatformEventType platformEventType;\n+    private final EventType eventType;\n+    private final EventControl eventControl;\n+    private final SettingControl[] settings;\n+\n+    \/\/ Private constructor so user code can't instantiate\n+    private EventConfiguration(EventType eventType, EventControl eventControl, SettingControl[] settings) {\n+        this.eventType = eventType;\n+        this.platformEventType = PrivateAccess.getInstance().getPlatformEventType(eventType);\n+        this.eventControl = eventControl;\n+        this.settings = settings;\n+    }\n+\n+    \/\/ Class jdk.jfr.internal.PlatformEventType is not\n+    \/\/ accessible from event class by design\n+    public PlatformEventType getPlatformEventType() {\n+        return platformEventType;\n+    }\n+\n+    \/\/ Class jdk.jfr.internal.EventControl is not\n+    \/\/ accessible from event class by design\n+    public EventControl getEventControl() {\n+        return eventControl;\n+    }\n+\n+    \/\/ Accessed by generated code in event class\n+    public boolean shouldCommit(long duration) {\n+        return isEnabled() && duration >= platformEventType.getThresholdTicks();\n+    }\n+\n+    \/\/ Accessed by generated code in event class\n+    public SettingControl getSetting(int index) {\n+        return settings[index];\n+    }\n+\n+    \/\/ Accessed by generated code in event class\n+    public boolean isEnabled() {\n+        return platformEventType.isCommittable();\n+    }\n+\n+    \/\/ Accessed by generated code in event class\n+    public EventType getEventType() {\n+        return eventType;\n+    }\n+\n+    \/\/ Not really part of the configuration, but the method\n+    \/\/ needs to be somewhere the event class can access,\n+    \/\/ but not part of the public API.\n+    public static long timestamp() {\n+        return JVM.counterTime();\n+    }\n+\n+    \/\/ Accessed by generated code in event class\n+    public static long duration(long startTime) {\n+        if (startTime == 0) {\n+            \/\/ User forgot to invoke begin, or instrumentation was\n+            \/\/ added after the user invoked begin.\n+            \/\/ Returning 0 will make it an instant event\n+            return 0;\n+        }\n+        return timestamp() - startTime;\n+    }\n+\n+    public boolean isRegistered() {\n+        return platformEventType.isRegistered();\n+    }\n+\n+    public long getId() {\n+        return eventType.getId();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventConfiguration.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,402 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.event;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.jfr.internal.Bits;\n+import jdk.jfr.internal.EventWriterKey;\n+import jdk.jfr.internal.StringPool;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.consumer.StringParser;\n+\n+\/\/ User code should not be able to get access to an EventWriter instance as it\n+\/\/ would allow it to write arbitrary data into buffers, potentially from\n+\/\/ different threads.\n+\/\/\n+\/\/ This is prevented in three ways:\n+\/\/\n+\/\/ 1. For code to access the jdk.jfr.internal.event package\n+\/\/    at least one event class (for a particular module) must be\n+\/\/    registered having FlightRecorderPermission(\"registerEvent\").\n+\/\/\n+\/\/ 2. The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from\n+\/\/    the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.\n+\/\/    (The EventWriterFactory class is dynamically generated before the first event\n+\/\/    is instrumented. See EventWriterFactoryRecipe)\n+\/\/\n+\/\/ 3. Steps 1 and 2 are sufficient to make it fully secure, with or without a Security\n+\/\/    Manager, but as an add additional measure the method EventWriterFactory::getEventWriter(long)\n+\/\/    requires the caller to provide a key that is hard to guess. The key is generated\n+\/\/    into the bytecode of the method invoking getEventWriter(long).\n+\/\/\n+public final class EventWriter {\n+\n+    \/\/ Event may not exceed size for a padded integer\n+    private static final long MAX_EVENT_SIZE = (1 << 28) -1;\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final JVM jvm = JVM.getJVM();\n+\n+    \/\/ The JVM needs access to these values. Don't remove\n+    private final long threadID;\n+    private long startPosition;\n+    private long startPositionAddress;\n+    private long currentPosition;\n+    private long maxPosition;\n+    private boolean valid;\n+    boolean notified; \/\/ Not private to avoid being optimized away\n+    boolean excluded;\n+\n+    private PlatformEventType eventType;\n+    private boolean flushOnEnd;\n+    private boolean largeSize = false;\n+\n+    \/\/ User code must not be able to instantiate\n+    private EventWriter() {\n+        threadID = 0;\n+    }\n+\n+    public void putBoolean(boolean i) {\n+        if (isValidForSize(Byte.BYTES)) {\n+            currentPosition += Bits.putBoolean(currentPosition, i);\n+        }\n+    }\n+\n+    public void putByte(byte i) {\n+        if (isValidForSize(Byte.BYTES)) {\n+            unsafe.putByte(currentPosition, i);\n+            ++currentPosition;\n+        }\n+    }\n+\n+    public void putChar(char v) {\n+        if (isValidForSize(Character.BYTES + 1)) {\n+            putUncheckedLong(v);\n+        }\n+    }\n+\n+    private void putUncheckedChar(char v) {\n+        putUncheckedLong(v);\n+    }\n+\n+    public void putShort(short v) {\n+        if (isValidForSize(Short.BYTES + 1)) {\n+            putUncheckedLong(v & 0xFFFF);\n+        }\n+    }\n+\n+    public void putInt(int v) {\n+        if (isValidForSize(Integer.BYTES + 1)) {\n+            putUncheckedLong(v & 0x00000000ffffffffL);\n+        }\n+    }\n+\n+    private void putUncheckedInt(int v) {\n+        putUncheckedLong(v & 0x00000000ffffffffL);\n+    }\n+\n+    public void putFloat(float i) {\n+        if (isValidForSize(Float.BYTES)) {\n+            currentPosition += Bits.putFloat(currentPosition, i);\n+        }\n+    }\n+\n+    public void putLong(long v) {\n+        if (isValidForSize(Long.BYTES + 1)) {\n+            putUncheckedLong(v);\n+        }\n+    }\n+\n+    public void putDouble(double i) {\n+        if (isValidForSize(Double.BYTES)) {\n+            currentPosition += Bits.putDouble(currentPosition, i);\n+        }\n+    }\n+\n+    public void putString(String s) {\n+        if (s == null) {\n+            putByte(StringParser.Encoding.NULL.byteValue());\n+            return;\n+        }\n+        int length = s.length();\n+        if (length == 0) {\n+            putByte(StringParser.Encoding.EMPTY_STRING.byteValue());\n+            return;\n+        }\n+        if (length > StringPool.MIN_LIMIT && length < StringPool.MAX_LIMIT) {\n+            long l = StringPool.addString(s);\n+            if (l > 0) {\n+                putByte(StringParser.Encoding.CONSTANT_POOL.byteValue());\n+                putLong(l);\n+                return;\n+            }\n+        }\n+        putStringValue(s);\n+        return;\n+    }\n+\n+    private void putStringValue(String s) {\n+        int length = s.length();\n+        if (isValidForSize(1 + 5 + 3 * length)) {\n+            putUncheckedByte(StringParser.Encoding.CHAR_ARRAY.byteValue()); \/\/ 1 byte\n+            putUncheckedInt(length); \/\/ max 5 bytes\n+            for (int i = 0; i < length; i++) {\n+                putUncheckedChar(s.charAt(i)); \/\/ max 3 bytes\n+            }\n+        }\n+    }\n+\n+    public void putEventThread() {\n+        putLong(threadID);\n+    }\n+\n+    public void putThread(Thread athread) {\n+        if (athread == null) {\n+            putLong(0L);\n+        } else {\n+            putLong(jvm.getThreadId(athread));\n+        }\n+    }\n+\n+    public void putClass(Class<?> aClass) {\n+        if (aClass == null) {\n+            putLong(0L);\n+        } else {\n+            putLong(JVM.getClassId(aClass));\n+        }\n+    }\n+\n+    public void putStackTrace() {\n+        if (eventType.getStackTraceEnabled()) {\n+            putLong(jvm.getStackTraceId(eventType.getStackTraceOffset()));\n+        } else {\n+            putLong(0L);\n+        }\n+    }\n+\n+    private void reserveEventSizeField() {\n+        this.largeSize = eventType.isLargeSize();\n+        if (largeSize) {\n+            if (isValidForSize(Integer.BYTES)) {\n+                currentPosition +=  Integer.BYTES;\n+            }\n+        } else {\n+            if (isValidForSize(1)) {\n+                currentPosition += 1;\n+            }\n+        }\n+    }\n+\n+    public void reset() {\n+        currentPosition = startPosition;\n+        if (flushOnEnd) {\n+            flushOnEnd = flush();\n+        }\n+        valid = true;\n+    }\n+\n+    private boolean isValidForSize(int requestedSize) {\n+        if (!valid) {\n+            return false;\n+        }\n+        if (currentPosition + requestedSize > maxPosition) {\n+            flushOnEnd = flush(usedSize(), requestedSize);\n+            \/\/ retry\n+            if (!valid) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isNotified() {\n+        return notified;\n+    }\n+\n+    private void resetNotified() {\n+        notified = false;\n+    }\n+\n+    private void resetStringPool() {\n+        StringPool.reset();\n+    }\n+\n+    private int usedSize() {\n+        return (int) (currentPosition - startPosition);\n+    }\n+\n+    private boolean flush() {\n+        return flush(usedSize(), 0);\n+    }\n+\n+    private boolean flush(int usedSize, int requestedSize) {\n+        return JVM.flush(this, usedSize, requestedSize);\n+    }\n+\n+\n+    public boolean beginEvent(EventConfiguration configuration, long typeId) {\n+        \/\/ Malicious code could take the EventConfiguration object from one\n+        \/\/ event class field and assign it to another. This check makes sure\n+        \/\/ the event type matches what was added by instrumentation.\n+        if (configuration.getId() != typeId) {\n+            EventWriterKey.block();\n+        }\n+        if (excluded) {\n+            \/\/ thread is excluded from writing events\n+            return false;\n+        }\n+        this.eventType = configuration.getPlatformEventType();\n+        reserveEventSizeField();\n+        putLong(eventType.getId());\n+        return true;\n+    }\n+\n+    public boolean endEvent() {\n+        if (!valid) {\n+            reset();\n+            return true;\n+        }\n+        final int eventSize = usedSize();\n+        if (eventSize > MAX_EVENT_SIZE) {\n+            reset();\n+            return true;\n+        }\n+\n+        if (largeSize) {\n+            Bits.putInt(startPosition, makePaddedInt(eventSize));\n+        } else {\n+            if (eventSize < 128) {\n+                Bits.putByte(startPosition, (byte) eventSize);\n+            } else {\n+                eventType.setLargeSize();\n+                reset();\n+                \/\/ returning false will trigger restart of the\n+                \/\/ event write attempt\n+                return false;\n+            }\n+        }\n+\n+        if (isNotified()) {\n+            resetNotified();\n+            resetStringPool();\n+            reset();\n+            \/\/ returning false will trigger restart of the event write attempt\n+            return false;\n+        }\n+        startPosition = currentPosition;\n+        unsafe.storeStoreFence();\n+        unsafe.putAddress(startPositionAddress, currentPosition);\n+        \/\/ the event is now committed\n+        if (flushOnEnd) {\n+            flushOnEnd = flush();\n+        }\n+        return true;\n+    }\n+\n+    private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid, boolean excluded) {\n+        startPosition = currentPosition = startPos;\n+        maxPosition = maxPos;\n+        startPositionAddress = startPosAddress;\n+        this.threadID = threadID;\n+        flushOnEnd = false;\n+        this.valid = valid;\n+        notified = false;\n+        this.excluded = excluded;\n+    }\n+\n+    private static int makePaddedInt(int v) {\n+        \/\/ bit  0-6 + pad => bit 24 - 31\n+        long b1 = (((v >>> 0) & 0x7F) | 0x80) << 24;\n+\n+        \/\/ bit  7-13 + pad => bit 16 - 23\n+        long b2 = (((v >>> 7) & 0x7F) | 0x80) << 16;\n+\n+        \/\/ bit 14-20 + pad => bit  8 - 15\n+        long b3 = (((v >>> 14) & 0x7F) | 0x80) << 8;\n+\n+        \/\/ bit 21-28       => bit  0 -  7\n+        long b4 = (((v >>> 21) & 0x7F)) << 0;\n+\n+        return (int) (b1 + b2 + b3 + b4);\n+    }\n+\n+    private void putUncheckedLong(long v) {\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 0-6\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 0-6\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 7-13\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 7-13\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 14-20\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 14-20\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 21-27\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 21-27\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 28-34\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 28-34\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 35-41\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 35-41\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 42-48\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 42-48\n+        v >>>= 7;\n+\n+        if ((v & ~0x7FL) == 0L) {\n+            putUncheckedByte((byte) v); \/\/ 49-55\n+            return;\n+        }\n+        putUncheckedByte((byte) (v | 0x80L)); \/\/ 49-55\n+        putUncheckedByte((byte) (v >>> 7)); \/\/ 56-63, last byte as is.\n+    }\n+\n+    private void putUncheckedByte(byte i) {\n+        unsafe.putByte(currentPosition, i);\n+        ++currentPosition;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":402,"deletions":0,"binary":false,"changes":402,"status":"added"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.handlers;\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-\n-import jdk.jfr.EventType;\n-import jdk.jfr.internal.EventControl;\n-import jdk.jfr.internal.JVM;\n-import jdk.jfr.internal.PlatformEventType;\n-import jdk.jfr.internal.PrivateAccess;\n-import jdk.jfr.internal.StringPool;\n-\n-\/\/ Users should not be subclass for security reasons.\n-public abstract class EventHandler {\n-    \/\/ Accessed by generated sub class\n-    protected final PlatformEventType platformEventType;\n-\n-    private final EventType eventType;\n-    private final EventControl eventControl;\n-\n-    \/\/ Accessed by generated sub class\n-    EventHandler(boolean registered, EventType eventType, EventControl eventControl) {\n-        this.eventType = eventType;\n-        this.platformEventType = PrivateAccess.getInstance().getPlatformEventType(eventType);\n-        this.eventControl = eventControl;\n-        platformEventType.setRegistered(registered);\n-    }\n-\n-    protected final StringPool createStringFieldWriter() {\n-        return new StringPool();\n-    }\n-\n-    \/\/ Accessed by generated code in event class\n-    public final boolean shouldCommit(long duration) {\n-        return isEnabled() && duration >= platformEventType.getThresholdTicks();\n-    }\n-\n-    \/\/ Accessed by generated code in event class\n-    \/\/ Accessed by generated sub class\n-    public final boolean isEnabled() {\n-        return platformEventType.isCommittable();\n-    }\n-\n-    public final EventType getEventType() {\n-        return eventType;\n-    }\n-\n-    public final PlatformEventType getPlatformEventType() {\n-        return platformEventType;\n-    }\n-\n-    public final EventControl getEventControl() {\n-        return eventControl;\n-    }\n-\n-    public static long timestamp() {\n-        return JVM.counterTime();\n-    }\n-\n-    public static long duration(long startTime) {\n-        if (startTime == 0) {\n-            \/\/ User forgot to invoke begin, or instrumentation was\n-            \/\/ added after the user invoked begin.\n-            \/\/ Returning 0 will make it an instant event\n-            return 0;\n-        }\n-        return timestamp() - startTime;\n-    }\n-\n-    \/\/ Prevent a malicious user from instantiating a generated event handlers.\n-    @Override\n-    public final Object clone() throws java.lang.CloneNotSupportedException {\n-        throw new CloneNotSupportedException();\n-    }\n-\n-    private final void writeObject(ObjectOutputStream out) throws IOException {\n-        throw new IOException(\"Object cannot be serialized\");\n-    }\n-\n-    private final void readObject(ObjectInputStream in) throws IOException {\n-        throw new IOException(\"Class cannot be deserialized\");\n-    }\n-\n-    public boolean isRegistered() {\n-        return platformEventType.isRegistered();\n-    }\n-\n-    public boolean setRegistered(boolean registered) {\n-       return platformEventType.setRegistered(registered);\n-    }\n-\n-    public void write(long start, long duration, String host, String address, int port, long timeout, long bytesRead, boolean endOfSTream) {\n-        throwError(\"SocketReadEvent\");\n-    }\n-\n-    public void write(long start, long duration, String host, String address, int port, long bytesWritten) {\n-        throwError(\"SocketWriteEvent\");\n-    }\n-\n-    public void write(long start, long duration, String path, boolean metadata) {\n-        throwError(\"FileForceEvent\");\n-    }\n-\n-    public void write(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n-        throwError(\"FileReadEvent\");\n-    }\n-\n-    public void write(long start, long duration, String path, long bytesWritten) {\n-        throwError(\"FileWriteEvent\");\n-    }\n-\n-    public void write(long start, long duration, String path, Class<?> exceptionClass)  {\n-        throwError(\"ExceptionThrownEvent or ErrorThrownEvent\");\n-    }\n-\n-    private void throwError(String classes) {\n-        throw new InternalError(\"Method parameters don't match fields in class \" + classes);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/handlers\/EventHandler.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,5 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.FileForceEvent;\n+import jdk.jfr.events.FileReadEvent;\n+import jdk.jfr.events.FileWriteEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.events.EventConfigurations;\n@@ -48,2 +51,2 @@\n-        EventHandler handler = Handlers.FILE_FORCE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_FORCE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -55,1 +58,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -58,3 +61,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, metaData);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileForceEvent.commit(start, duration, path, metaData);\n@@ -68,2 +71,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -75,1 +78,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -78,2 +81,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -81,1 +84,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -83,1 +86,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -93,2 +96,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -100,1 +103,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -103,2 +106,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -106,1 +109,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -108,1 +111,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -118,2 +121,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -125,1 +128,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -128,2 +131,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -131,1 +134,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -133,1 +136,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -143,2 +146,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -150,1 +153,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -153,2 +156,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -156,1 +159,1 @@\n-                handler.write(start, duration, path, bytes);\n+                FileWriteEvent.commit(start, duration, path, bytes);\n@@ -165,2 +168,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -173,1 +176,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -176,2 +179,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -179,1 +182,1 @@\n-                handler.write(start, duration, path, bytes);\n+                FileWriteEvent.commit(start, duration, path, bytes);\n@@ -188,2 +191,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -195,1 +198,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -198,2 +201,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -201,1 +204,1 @@\n-                handler.write(start, duration, path, bytes);\n+                FileWriteEvent.commit(start, duration, path, bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileChannelImplInstrumentor.java","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,3 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.EventConfigurations;\n+import jdk.jfr.events.FileReadEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -47,2 +48,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -56,1 +57,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -64,3 +65,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesRead, endOfFile);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n@@ -75,2 +76,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -82,1 +83,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -85,2 +86,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -88,1 +89,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -90,1 +91,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -100,2 +101,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -107,1 +108,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -110,2 +111,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -113,1 +114,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -115,1 +116,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileInputStreamInstrumentor.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,3 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.FileWriteEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.events.EventConfigurations;\n@@ -47,2 +48,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -55,1 +56,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -59,3 +60,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n@@ -69,2 +70,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -77,1 +78,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -81,3 +82,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n@@ -91,2 +92,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -99,1 +100,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -103,3 +104,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileOutputStreamInstrumentor.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,4 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.FileReadEvent;\n+import jdk.jfr.events.FileWriteEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n+import jdk.jfr.events.EventConfigurations;\n@@ -47,2 +49,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -56,1 +58,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -64,3 +66,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesRead, endOfFile);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n@@ -75,2 +77,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -82,1 +84,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -85,2 +87,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -88,1 +90,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -90,1 +92,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -100,2 +102,2 @@\n-        EventHandler handler = Handlers.FILE_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -107,1 +109,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -110,2 +112,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -113,1 +115,1 @@\n-                    handler.write(start, duration, path, 0L, true);\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n@@ -115,1 +117,1 @@\n-                    handler.write(start, duration, path, bytesRead, false);\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n@@ -125,2 +127,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -133,1 +135,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -137,3 +139,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n@@ -147,2 +149,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -155,1 +157,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -159,3 +161,3 @@\n-            long duration = EventHandler.timestamp();\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp();\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n@@ -169,2 +171,2 @@\n-        EventHandler handler = Handlers.FILE_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -177,1 +179,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -181,3 +183,3 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n-                handler.write(start, duration, path, bytesWritten);\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/RandomAccessFileInstrumentor.java","additions":43,"deletions":41,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,4 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.EventConfigurations;\n+import jdk.jfr.events.SocketReadEvent;\n+import jdk.jfr.events.SocketWriteEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -48,2 +50,2 @@\n-        EventHandler handler = Handlers.SOCKET_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -55,1 +57,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();;\n@@ -58,2 +60,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration))  {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration))  {\n@@ -69,1 +71,1 @@\n-                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                        SocketReadEvent.commit(start, duration, host, address, port, 0, 0L, true);\n@@ -71,1 +73,1 @@\n-                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                        SocketReadEvent.commit(start, duration, host, address, port, 0, bytesRead, false);\n@@ -77,1 +79,1 @@\n-                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                        SocketReadEvent.commit(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n@@ -79,1 +81,1 @@\n-                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                        SocketReadEvent.commit(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n@@ -90,2 +92,2 @@\n-        EventHandler handler = Handlers.SOCKET_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -97,1 +99,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -100,2 +102,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -111,1 +113,1 @@\n-                        handler.write(start, duration, host, address, port, 0, 0L, true);\n+                        SocketReadEvent.commit(start, duration, host, address, port, 0, 0L, true);\n@@ -113,1 +115,1 @@\n-                        handler.write(start, duration, host, address, port, 0, bytesRead, false);\n+                        SocketReadEvent.commit(start, duration, host, address, port, 0, bytesRead, false);\n@@ -119,1 +121,1 @@\n-                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n+                        SocketReadEvent.commit(start, duration, \"Unix domain socket\", path, 0, 0, 0L, true);\n@@ -121,1 +123,1 @@\n-                        handler.write(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n+                        SocketReadEvent.commit(start, duration, \"Unix domain socket\", path, 0, 0, bytesRead, false);\n@@ -132,2 +134,2 @@\n-        EventHandler handler = Handlers.SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -139,1 +141,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -142,2 +144,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -153,1 +155,1 @@\n-                    handler.write(start, duration, host, address, port, bytes);\n+                    SocketWriteEvent.commit(start, duration, host, address, port, bytes);\n@@ -157,1 +159,1 @@\n-                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                    SocketWriteEvent.commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n@@ -172,2 +174,2 @@\n-        EventHandler handler = Handlers.SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -179,1 +181,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -182,2 +184,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -193,1 +195,1 @@\n-                    handler.write(start, duration, host, address, port, bytes);\n+                    SocketWriteEvent.commit(start, duration, host, address, port, bytes);\n@@ -197,1 +199,1 @@\n-                    handler.write(start, duration, \"Unix domain socket\", path, 0, bytes);\n+                    SocketWriteEvent.commit(start, duration, \"Unix domain socket\", path, 0, bytes);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","additions":37,"deletions":35,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.EventConfigurations;\n+import jdk.jfr.events.SocketReadEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -47,2 +48,2 @@\n-        EventHandler handler = Handlers.SOCKET_READ;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_READ;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -54,1 +55,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -57,2 +58,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -65,1 +66,1 @@\n-                    handler.write(start, duration, host, address, port, timeout, 0L, true);\n+                    SocketReadEvent.commit(start, duration, host, address, port, timeout, 0L, true);\n@@ -67,1 +68,1 @@\n-                    handler.write(start, duration, host, address, port, timeout, bytesRead, false);\n+                    SocketReadEvent.commit(start, duration, host, address, port, timeout, bytesRead, false);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketInputStreamInstrumentor.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.EventConfigurations;\n+import jdk.jfr.events.SocketWriteEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -47,2 +48,2 @@\n-        EventHandler handler = Handlers.SOCKET_WRITE;\n-        if (!handler.isEnabled()) {\n+        EventConfiguration eventConfiguration = EventConfigurations.SOCKET_WRITE;\n+        if (!eventConfiguration.isEnabled()) {\n@@ -55,1 +56,1 @@\n-            start = EventHandler.timestamp();\n+            start = EventConfiguration.timestamp();\n@@ -59,2 +60,2 @@\n-            long duration = EventHandler.timestamp() - start;\n-            if (handler.shouldCommit(duration)) {\n+            long duration = EventConfiguration.timestamp() - start;\n+            if (eventConfiguration.shouldCommit(duration)) {\n@@ -62,1 +63,1 @@\n-                handler.write(\n+                SocketWriteEvent.commit(\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketOutputStreamInstrumentor.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,4 @@\n-import jdk.jfr.events.Handlers;\n-import jdk.jfr.internal.handlers.EventHandler;\n+import jdk.jfr.events.EventConfigurations;\n+import jdk.jfr.events.ErrorThrownEvent;\n+import jdk.jfr.events.ExceptionThrownEvent;\n+import jdk.jfr.internal.event.EventConfiguration;\n@@ -41,1 +43,1 @@\n-        long timestamp = EventHandler.timestamp();\n+        long timestamp = EventConfiguration.timestamp();\n@@ -43,3 +45,3 @@\n-        EventHandler h1 = Handlers.ERROR_THROWN;\n-        if (h1.isEnabled()) {\n-            h1.write(timestamp, 0L, message, e.getClass());\n+        EventConfiguration eventConfiguration1 = EventConfigurations.ERROR_THROWN;\n+        if (eventConfiguration1.isEnabled()) {\n+            ErrorThrownEvent.commit(timestamp, 0L, message, e.getClass());\n@@ -47,3 +49,3 @@\n-        EventHandler h2 = Handlers.EXCEPTION_THROWN;\n-        if (h2.isEnabled()) {\n-            h2.write(timestamp, 0L, message, e.getClass());\n+        EventConfiguration eventConfiguration2 = EventConfigurations.EXCEPTION_THROWN;\n+        if (eventConfiguration2.isEnabled()) {\n+            ExceptionThrownEvent.commit(timestamp, 0L, message, e.getClass());\n@@ -55,4 +57,4 @@\n-        EventHandler h = Handlers.EXCEPTION_THROWN;\n-        if (h.isEnabled()) {\n-            long timestamp = EventHandler.timestamp();\n-            h.write(timestamp, 0L, message, t.getClass());\n+        EventConfiguration eventConfiguration = EventConfigurations.EXCEPTION_THROWN;\n+        if (eventConfiguration.isEnabled()) {\n+            long timestamp = EventConfiguration.timestamp();\n+            ExceptionThrownEvent.commit(timestamp, 0L, message, t.getClass());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ThrowableTracer.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+\/\/Purpose of this class is to have something to\n+\/\/statically link against for TestGetEventWriter.\n+\/\/\n+\/\/ When the class is loaded \"jdk.jfr.jvm.E\" will be\n+\/\/ replaced with \"jdk.jfr.Event\"\n+public class E {\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/E.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Registered;\n+\n+\/\/ Class used by TestGetEventWriter\n+@Registered(false)\n+public class MyCommitRegisteredFalseEvent extends E implements Runnable {\n+    public void myCommit() {\n+        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        myCommit();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/MyCommitRegisteredFalseEvent.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Registered;\n+\n+\/\/ Class used by TestGetEventWriter\n+@Registered(true)\n+public class MyCommitRegisteredTrueEvent extends E implements Runnable {\n+    public void myCommit() {\n+        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        myCommit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/MyCommitRegisteredTrueEvent.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+\/\/ Class used by TestGetEventWriter\n+public class NonEvent implements Runnable {\n+    public void commit() {\n+        PlaceholderEventWriter ew = PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here \" + ew);\n+    }\n+\n+    @Override\n+    public void run() {\n+        commit();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/NonEvent.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+\/\/ Purpose of this class is to have something to\n+\/\/ statically link against for TestGetEventWriter.\n+\/\/\n+\/\/ When the class is loaded \"jdk.jfr.jvm.PlaceholderEventWriter\"\n+\/\/ will be replaced with \"jdk.jfr.internal.event.EventWriter\"\n+public class PlaceholderEventWriter {\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/PlaceholderEventWriter.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+\/\/ Purpose of this class is to have something to\n+\/\/ statically link against for TestGetEventWriter.\n+\/\/\n+\/\/ When the class is loaded \"jdk.jfr.jvm.PlaceholderEventWriterFactory\"\n+\/\/ will be replaced with \"jdk.jfr.internal.event.EventWriterFactory\"\n+public class PlaceholderEventWriterFactory {\n+\n+    public static PlaceholderEventWriter getEventWriter(long value) {\n+        throw new RuntimeException(\"Test error. PlaceholderEventWriter class should have been replaced with EventWriter\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/PlaceholderEventWriterFactory.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Registered;\n+\n+\/\/ Class used by TestGetEventWriter\n+@Registered(false)\n+public class RegisteredFalseEvent extends E {\n+    public void commit() {\n+        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/RegisteredFalseEvent.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Registered;\n+\n+\/\/ Class used by TestGetEventWriter\n+@Registered(true)\n+public class RegisteredTrueEvent extends E {\n+    public void commit() {\n+        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/RegisteredTrueEvent.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+\/\/ Class used by TestGetEventWriter\n+public class StaticCommitEvent implements Runnable {\n+\n+    String message;\n+\n+    int value;\n+\n+    public static void commit(long start, long duration, String message, int value) {\n+        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        throw new RuntimeException(\"Should not reach here\");\n+    }\n+\n+    @Override\n+    public void run() {\n+        commit(System.nanoTime(), 0L, \"hello, world!\", 4711);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/StaticCommitEvent.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        output.shouldContain(\"extends jdk\/jfr\/internal\/handlers\/EventHandler\");\n+        output.shouldContain(\"extends jdk\/jfr\/events\/AbstractJDKEvent\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestEventWriterLog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,9 @@\n-import static jdk.test.lib.Asserts.assertNotNull;\n-\n-import jdk.jfr.internal.EventWriter;\n-import jdk.jfr.internal.JVM;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n@@ -36,1 +41,10 @@\n- * @modules jdk.jfr\/jdk.jfr.internal\n+ *\n+ * @compile PlaceholderEventWriter.java\n+ * @compile PlaceholderEventWriterFactory.java\n+ * @compile E.java\n+ * @compile NonEvent.java\n+ * @compile RegisteredTrueEvent.java\n+ * @compile RegisteredFalseEvent.java\n+ * @compile MyCommitRegisteredTrueEvent.java\n+ * @compile MyCommitRegisteredFalseEvent.java\n+ * @compile StaticCommitEvent.java\n@@ -39,0 +53,12 @@\n+ *\n+ * @run main\/othervm\/timeout=300 -Xint -XX:+UseInterpreter -Dinterpreted=true\n+ *      jdk.jfr.jvm.TestGetEventWriter\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:-UseInterpreter -Dinterpreted=false\n+ *      jdk.jfr.jvm.TestGetEventWriter\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:TieredStopAtLevel=1 -XX:-UseInterpreter -Dinterpreted=false\n+ *      jdk.jfr.jvm.TestGetEventWriter\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:TieredStopAtLevel=4 -XX:-TieredCompilation -XX:-UseInterpreter -Dinterpreted=false\n+ *      jdk.jfr.jvm.TestGetEventWriter\n@@ -42,6 +68,251 @@\n-    public static void main(String... args) {\n-        JVM jvm = JVM.getJVM();\n-        jvm.createNativeJFR();\n-        EventWriter writer = EventWriter.getEventWriter();\n-        assertNotNull(writer, \"EventWriter should not be null\");\n-        jvm.destroyNativeJFR();\n+    static class InitializationEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            \/\/ Unlocks access to jdk.jfr.internal.event\n+            InitializationEvent e  = new InitializationEvent();\n+            e.commit();\n+        }\n+        \/\/ Make sure EventWriterFactory can be accessed.\n+        Class<?> clazz = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n+        if (clazz == null) {\n+            throw new Exception(\"Test error, not able to access jdk.jfr.internal.event.EventWriterFactory class\");\n+        }\n+        testRegisteredTrueEvent();\n+        testRegisteredFalseEvent();\n+        testMyCommitRegisteredTrue();\n+        testMyCommitRegisteredFalse();\n+        testStaticCommit();\n+        testMethodHandleEvent();\n+        testReflectionEvent();\n+        testNonEvent();\n+    }\n+\n+    \/\/ The class does not inherit jdk.jfr.Event and, as such, does not implement the\n+    \/\/ API. It has its own stand-alone \"commit()V\", which is not an override, that\n+    \/\/ attempts to resolve and link against EventWriter. This user implementation\n+    \/\/ is not blessed for linkage.\n+    private static void testNonEvent() throws Throwable {\n+        Runnable e = newEventObject(\"NonEvent\");\n+        try {\n+            e.run(); \/\/ invokes commit()\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+            return;\n+        }\n+    }\n+\n+    \/\/ The user has defined a class which overrides and implements the \"commit()V\"\n+    \/\/ method declared final in jdk.jfr.Event.\n+    \/\/ This user implementation is not blessed for linkage.\n+    private static void testRegisteredTrueEvent() throws Throwable {\n+        Event e = newEventObject(\"RegisteredTrueEvent\");\n+        try {\n+            e.commit(); \/\/ throws\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+            return;\n+        }\n+    }\n+\n+    \/\/ The user has defined a class which overrides and implements the \"commit()V\"\n+    \/\/ method declared final in jdk.jfr.Event. This user implementation is not\n+    \/\/ blessed for linkage. If a class have user-defined implementations\n+    \/\/ of any methods declared final, it is not instrumented.\n+    \/\/ Although it is a subclass of jdk.jfr.Event, on initial load, we will\n+    \/\/ classify it as being outside of the JFR system. Attempting to register\n+    \/\/ such a class throws an IllegalArgumentException. The user-defined\n+    \/\/ \"commit()V\" method is still not blessed for linkage, even after registration.\n+    private static void testRegisteredFalseEvent() throws Throwable {\n+        Event e = newEventObject(\"RegisteredFalseEvent\");\n+        try {\n+            e.commit(); \/\/ throws\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+        }\n+        try {\n+            FlightRecorder.register(e.getClass());\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ OK, as expected.\n+            \/\/ Can't register an event class where the user has managed to override\n+            \/\/ methods in jdk.jfr.Event\n+        }\n+    }\n+\n+    \/\/ The user has implemented another method, \"myCommit()V\", not an override nor\n+    \/\/ overload. that attempts to resolve and link EventWriter. This will fail,\n+    \/\/ because \"myCommit()V\" is not blessed for linkage.\n+    private static void testMyCommitRegisteredTrue() throws Throwable {\n+        Runnable e = newEventObject(\"MyCommitRegisteredTrueEvent\");\n+        try {\n+            e.run(); \/\/ Invoking the user-defined method throws.\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+            return;\n+        }\n+    }\n+\n+    \/\/ The user has implemented another method, \"myCommit()V\", not an override,\n+    \/\/ nor overload. This linkage will fail because \"myCommit()V\" is not blessed.\n+    \/\/ Since the user has not defined any final methods in jdk.jfr.Event,\n+    \/\/ the class is not excluded wholesale from the JFR system.\n+    \/\/ Invoking the real \"commit()V\", installed by the framework, is OK.\n+    private static void testMyCommitRegisteredFalse() throws Throwable {\n+        Runnable e = newEventObject(\"MyCommitRegisteredFalseEvent\");\n+        try {\n+            e.run(); \/\/ Invoking the user-defined method throws.\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+        }\n+        \/\/ Instrumentation added.\n+        FlightRecorder.register(e.getClass().asSubclass(Event.class));\n+        Event event = (Event) e;\n+        event.commit(); \/\/ Invoking the JFR provided method is OK\n+    }\n+\n+    \/\/ Events located in the boot class loader can create a static\n+    \/\/ commit-method to emit events. It must not be used by code\n+    \/\/ outside of the boot class loader.\n+    private static void testStaticCommit() throws Throwable {\n+        Runnable e = newEventObject(\"StaticCommitEvent\");\n+        try {\n+            e.run(); \/\/ Invokes commit(long, long, String, int)\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessError iae) {\n+            \/\/ OK, as expected\n+        }\n+    }\n+\n+    static class MethodHandleEvent extends Event {\n+        public void myCommit() throws Throwable {\n+            try {\n+                Class<?> ew = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+                MethodType t = MethodType.methodType(ew, List.of(long.class));\n+                Class<?> factory = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n+                MethodHandle mh = MethodHandles.lookup().findStatic(factory, \"getEventWriter\", t);\n+                mh.invoke(Long.valueOf(4711)); \/\/ throws IllegalAccessException\n+            } catch (ClassNotFoundException | SecurityException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ The user has implemented another method, \"myCommit()V\", not an override,\n+    \/\/ nor overload. This linkage will fail, because \"myCommit()V\" is not blessed.\n+    \/\/ Using a MethodHandle for linkage is transparent and immaterial.\n+    private static void testMethodHandleEvent() throws Throwable {\n+        MethodHandleEvent e = new MethodHandleEvent();\n+        try {\n+            e.myCommit();\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (IllegalAccessException iaex) {\n+            if (iaex.getCause() instanceof IllegalAccessError iae) {\n+                if (iae.getMessage().contains(\"getEventWriter(long)\")) {\n+                    \/\/ OK, as expected\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    static class ReflectionEvent extends Event {\n+        public void myCommit() throws Throwable {\n+            Class<?> c;\n+            try {\n+                c = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n+                Method m = c.getMethod(\"getEventWriter\", new Class[] {long.class});\n+                m.invoke(null, Long.valueOf(4711)); \/\/ throws InternalError\n+            } catch (ClassNotFoundException | SecurityException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ The user has implemented another method, \"myCommit()V\", not an override,\n+    \/\/ nor overload, that uses Reflection. This linkage will fail, because\n+    \/\/ \"myCommit()V\" is not blessed. Reflection is using method handles,\n+    \/\/ but using a MethodHandle for linkage is transparent and immaterial.\n+    private static void testReflectionEvent() throws Throwable {\n+        ReflectionEvent e = new ReflectionEvent();\n+        try {\n+            e.myCommit(); \/\/ throws\n+            throw new RuntimeException(\"Should not reach here\");\n+        } catch (InternalError ie) {\n+            if (ie.getCause() instanceof IllegalAccessException iaex) {\n+                if (iaex.getCause() instanceof IllegalAccessError iae) {\n+                    if (iae.getMessage().contains(\"getEventWriter(long)\")) {\n+                        \/\/ OK, as expected\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class BytesClassLoader extends ClassLoader {\n+        private final byte[] bytes;\n+        private final String className;\n+\n+        BytesClassLoader(byte[] bytes, String name) {\n+            this.bytes = bytes;\n+            this.className = name;\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            if (name.equals(className)) {\n+                return defineClass(name, bytes, 0, bytes.length);\n+            } else {\n+                return super.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static byte[] replace(byte[] bytes, String match, String replacement) {\n+        if (match.length() != replacement.length()) {\n+            throw new IllegalArgumentException(\"Match must be same size as replacement\");\n+        }\n+        for (int i = 0; i < bytes.length - match.length(); i++) {\n+            if (match(bytes, i, match)) {\n+                for (int j = 0; j < replacement.length(); j++) {\n+                    bytes[i + j] = (byte) replacement.charAt(j);\n+                }\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    private static boolean match(byte[] bytes, int offset, String text) {\n+        for (int i = 0; i < text.length(); i++) {\n+            if (bytes[offset + i] != text.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T newEventObject(String name) throws Throwable {\n+        String r = name + \".class\";\n+        String fullName = \"jdk.jfr.jvm.\" + name;\n+        var is = TestGetEventWriter.class.getResourceAsStream(r);\n+        if (is == null) {\n+            throw new Exception(\"Test error, could not located class file for \" + name);\n+        }\n+        byte[] bytes = is.readAllBytes();\n+        is.close();\n+        bytes = replace(bytes, \"jdk\/jfr\/jvm\/E\", \"jdk\/jfr\/Event\");\n+        bytes = replace(bytes, \"jdk\/jfr\/jvm\/PlaceholderEventWriterFactory\", \"jdk\/jfr\/internal\/event\/EventWriterFactory\");\n+        bytes = replace(bytes, \"jdk\/jfr\/jvm\/PlaceholderEventWriter\", \"jdk\/jfr\/internal\/event\/EventWriter\");\n+        BytesClassLoader bc = new BytesClassLoader(bytes, fullName);\n+        Class<?> clazz = bc.loadClass(fullName);\n+        Constructor<?> constructor = clazz.getConstructor(new Class[0]);\n+        System.out.println(\"About to invoke \" + fullName + \".commit()\");\n+        return (T) constructor.newInstance();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriter.java","additions":283,"deletions":12,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Registered;\n+\/**\n+ * @test Tests that a module can't execute code in jdk.jfr.internal.event unless an event has been registered.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *   --add-opens jdk.jfr\/jdk.jfr.events=ALL-UNNAMED\n+ *    jdk.jfr.jvm.TestGetEventWriterPackage\n+ *\/\n+public class TestGetEventWriterPackage {\n+\n+    @Registered(false)\n+    static class PackageUnlockEvent extends Event {\n+    }\n+     public static void main(String... args) throws Throwable {\n+        \/\/ --add-opens jdk.jfr\/jdk.jfr.events=ALL-UNNAMED gives access to\n+        \/\/ the FileReadEvent class in the jdk.jfr modiule.\n+        \/\/ When JFR is initialized the FileReadEvent is registered and an EventConfiguration object\n+        \/\/ assigned to its static field eventConfiguration\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+        \/\/ The tests gets the EventConfiguration object from the class\n+        Class<?>c = Class.forName(\"jdk.jfr.events.FileReadEvent\");\n+        Field f = c.getDeclaredField(\"eventConfiguration\");\n+        f.setAccessible(true);\n+        Object o = f.get(null);\n+        Class<?> clazz = Class.forName(\"jdk.jfr.internal.event.EventConfiguration\");\n+        Method m = clazz.getDeclaredMethod(\"isRegistered\", new Class[0]);\n+        \/\/ it then tries to execute a method on the object from the unnamed module\n+        try {\n+            System.out.println(\"Is registered: \" +  m.invoke(o, new Object[0]));\n+            throw new Exception(\"Did NOT expect unnamed module to be able to execute method in EventConfiguration object before event registration\");\n+        }  catch (IllegalAccessException iae) {\n+            \/\/ OK, as expected\n+        }\n+        \/\/ The registration makes the jdk.jfr.internal.event accessible\n+        FlightRecorder.register(PackageUnlockEvent.class);\n+        try {\n+            System.out.println(\"Is registered: \" +  m.invoke(o, new Object[0]));\n+        }  catch (IllegalAccessException iae) {\n+            throw new Exception(\"Did expect unnamed module to be able to execute method in EventConfiguration object efter event registration\", iae);\n+        }\n+        \/\/ If a Security Manager would be present, the caller would need\n+        \/\/ to have FlightRecorderPermission(\"registerEvent\")\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriterPackage.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+import jdk.jfr.Event;\n+import jdk.jfr.Registered;\n+\/**\n+ * @test Tests that reflective access works as (normally) expected\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm jdk.jfr.jvm.TestGetEventWriterReflection\n+ *\/\n+public class TestGetEventWriterReflection {\n+\n+    @Registered(false)\n+    static class InitializeEvent extends Event {\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        testReflectionGetConstructor();\n+        testReflectionGetDeclaredConstructor();\n+        testReflectionGetDeclaredConstructorSetAccessible();\n+        testReflectionGetDeclaredFieldSetAccessible();\n+    }\n+\n+    \/\/ getConstructor() only return public members.\n+    private static void testReflectionGetConstructor() throws Exception {\n+        try {\n+            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+            Constructor<?> constructor = c.getConstructor(new Class[0]);\n+            throw new RuntimeException(\"Should not reach here \" + constructor);\n+        } catch (NoSuchMethodException nsme) {\n+            \/\/ OK, as expected. The constructor is private.\n+        }\n+    }\n+\n+    \/\/ getDeclaredConstructor() return also a private constructor.\n+    \/\/ Invoking a private constructor is an instance of IllegalAccess.\n+    private static void testReflectionGetDeclaredConstructor() throws Exception {\n+        try {\n+            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+            Constructor<?> constructor = c.getDeclaredConstructor(new Class[0]);\n+            constructor.newInstance();\n+            throw new RuntimeException(\"Should not reach here \" + constructor);\n+        } catch (IllegalAccessException iae) {\n+            if (iae.getMessage().contains(\"\"\"\n+                cannot access a member of class jdk.jfr.internal.event.EventWriter\n+                (in module jdk.jfr) with modifiers \\\"private\\\"\n+                                         \"\"\")) {\n+                \/\/ OK, as expected. Private protection in effect.\n+            }\n+        }\n+    }\n+\n+    \/\/ getDeclaredConstructor() return also a private constructor.\n+    \/\/ setAccessible(true) attempts to make the private constructor public for external access.\n+    \/\/ With JEP 403: Strongly Encapsulate JDK Internals, the module and package must first\n+    \/\/ be explicitly opened for setAccessible(true) to succeed.\n+    private static void testReflectionGetDeclaredConstructorSetAccessible() throws Exception {\n+        try {\n+            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+            Constructor<?> constructor = c.getDeclaredConstructor(new Class[0]);\n+            constructor.setAccessible(true);\n+            throw new RuntimeException(\"Should not reach here \" + constructor);\n+        } catch (InaccessibleObjectException ioe) {\n+            if (ioe.getMessage().contains(\"module jdk.jfr does not \\\"opens jdk.jfr.internal.event\")) {\n+                \/\/ OK, as expected. Even when using setAccessible(true), by default, the jdk.jfr module\n+                \/\/ is not open for reflective access to private members.\n+            }\n+        }\n+    }\n+\n+    \/\/ getDeclaredField() return also a private field.\n+    \/\/ setAccessible(true) attempts to make the private field public for external access.\n+    \/\/ With JEP 403: Strongly Encapsulate JDK Internals, the module and package must first\n+    \/\/ be explicitly opened for setAccessible(true) to succeed.\n+    private static void testReflectionGetDeclaredFieldSetAccessible() throws Exception {\n+        try {\n+            Class<?> c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+            Field field = c.getDeclaredField(\"jvm\");\n+            field.setAccessible(true);\n+            throw new RuntimeException(\"Should not reach here \" + field);\n+        } catch (InaccessibleObjectException ioe) {\n+            if (ioe.getMessage().contains(\"module jdk.jfr does not \\\"opens jdk.jfr.internal.event\")) {\n+                \/\/ OK, as expected. Even when using setAccessible(true), by default, the jdk.jfr module\n+                \/\/ is not open for reflective access to private members.\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriterReflection.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -63,1 +63,1 @@\n-        eventWriterClazz = Class.forName(\"jdk.jfr.internal.EventWriter\", true, TestJFRIntrinsic.class.getClassLoader());\n+        eventWriterClazz = Class.forName(\"jdk.jfr.internal.event.EventWriter\", true, TestJFRIntrinsic.class.getClassLoader());\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}