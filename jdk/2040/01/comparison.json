{"files":[{"patch":"@@ -127,6 +127,12 @@\n-  # Libatomic library\n-  # 32-bit MIPS needs fallback library for 8-byte atomic ops\n-  if test \"x$OPENJDK_TARGET_OS\" = xlinux &&\n-      (test \"x$OPENJDK_TARGET_CPU\" = xmips ||\n-       test \"x$OPENJDK_TARGET_CPU\" = xmipsel); then\n-    BASIC_JVM_LIBS=\"$BASIC_JVM_LIBS -latomic\"\n+  # Atomic library\n+  # 32-bit platforms needs fallback library for 8-byte atomic ops on Zero\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+    if test \"x$OPENJDK_TARGET_OS\" = xlinux &&\n+        (test \"x$OPENJDK_TARGET_CPU\" = xarm ||\n+         test \"x$OPENJDK_TARGET_CPU\" = xm68k ||\n+         test \"x$OPENJDK_TARGET_CPU\" = xmips ||\n+         test \"x$OPENJDK_TARGET_CPU\" = xmipsel ||\n+         test \"x$OPENJDK_TARGET_CPU\" = xppc ||\n+         test \"x$OPENJDK_TARGET_CPU\" = xsh); then\n+      BASIC_JVM_LIBS=\"$BASIC_JVM_LIBS -latomic\"\n+    fi\n","filename":"make\/autoconf\/libraries.m4","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-    \/\/ Use the existance of the top level README as indication of if this is\n+    \/\/ Use the existance of the top level README.md as indication of if this is\n@@ -1006,1 +1006,1 @@\n-    if (!new java.io.File(__DIR__, \"..\/..\/README\").exists()) {\n+    if (!new java.io.File(__DIR__, \"..\/..\/README.md\").exists()) {\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,10 @@\n-    return JNI_TRUE;\n+\n+    \/* Check for build 18362 or newer, due to Windows bug described in 8259014 *\/\n+\n+    OSVERSIONINFOEXW osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };\n+    DWORDLONG cond_mask = 0;\n+\n+    VER_SET_CONDITION(cond_mask, VER_BUILDNUMBER, VER_GREATER_EQUAL);\n+    osvi.dwBuildNumber  = 18362; \/\/ Windows 10 (1903) or newer\n+\n+    return VerifyVersionInfoW(&osvi, VER_BUILDNUMBER, cond_mask) != 0;\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            \/\/ ignore\n+            throw new IllegalStateException(\"doclint not available\");\n@@ -83,1 +83,4 @@\n-            return false;\n+            \/\/ passively accept all \"plausible\" options\n+            return s.equals(XMSGS_OPTION)\n+                    || s.startsWith(XMSGS_CUSTOM_PREFIX)\n+                    || s.startsWith(XCHECK_PACKAGE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/doclint\/DocLint.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -260,3 +261,6 @@\n-\n-        DocLint.newDocLint().init(this, docLintOpts.toArray(new String[docLintOpts.size()]));\n-        JavaCompiler.instance(context).keepComments = true;\n+        try {\n+            DocLint.newDocLint().init(this, docLintOpts.toArray(new String[docLintOpts.size()]));\n+            JavaCompiler.instance(context).keepComments = true;\n+        } catch (IllegalStateException e) {\n+            Log.instance(context).warning(Warnings.DoclintNotAvailable);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/BasicJavacTask.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2059,0 +2059,3 @@\n+compiler.warn.doclint.not.available=\\\n+    No service provider for doclint is available\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -879,4 +879,3 @@\n-     * @throws IllegalArgumentException if {@code bytesOffset < 0}.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n-     * @throws UnsupportedOperationException if an unsupported map mode is specified, or if the {@code path} is associated\n-     * with a provider that does not support creating file channels.\n+     * @throws IllegalArgumentException if {@code bytesOffset < 0}, {@code bytesSize < 0}, or if {@code path} is not associated\n+     * with the default file system.\n+     * @throws UnsupportedOperationException if an unsupported map mode is specified.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -117,2 +119,7 @@\n-        try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {\n-            UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, bytesOffset, bytesSize);\n+        FileSystem fs = path.getFileSystem();\n+        if (fs != FileSystems.getDefault() ||\n+                fs.getClass().getModule() != Object.class.getModule()) {\n+            throw new IllegalArgumentException(\"Unsupported file system\");\n+        }\n+        try (FileChannel channelImpl = FileChannel.open(path, openOptions(mapMode))) {\n+            UnmapperProxy unmapperProxy = ((FileChannelImpl)channelImpl).mapInternal(mapMode, bytesOffset, bytesSize);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import com.sun.tools.doclint.DocLint;\n@@ -41,0 +40,1 @@\n+import jdk.javadoc.internal.doclint.DocLint;\n@@ -408,1 +408,1 @@\n-                        if (!DocLint.newDocLint().isValidOption(dopt)) {\n+                        if (!(new DocLint()).isValidOption(dopt)) {\n@@ -421,1 +421,1 @@\n-                        if (!DocLint.newDocLint().isValidOption(dopt)) {\n+                        if (!(new DocLint()).isValidOption(dopt)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.net.URI;\n@@ -516,0 +517,6 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testMapCustomPath() throws IOException {\n+        Path path = Path.of(URI.create(\"jrt:\/\"));\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+compiler.warn.doclint.not.available                     # requires restricted image\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8253996\n+ * @summary Verify doclint behavior when doclint not available\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @run main\/othervm --limit-modules jdk.compiler,jdk.zipfs LimitedImage\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task.Expect;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class LimitedImage {\n+    public static void main(String... args) throws IOException {\n+        ToolBox tb = new ToolBox();\n+\n+        \/\/showing help should be OK\n+        new JavacTask(tb, Mode.CMDLINE)\n+                .options(\"--help\")\n+                .run().writeAll();\n+\n+        Path testSource = Path.of(\"Test.java\");\n+        tb.writeFile(testSource, \"class Test {}\");\n+\n+        List<String> actualOutput;\n+        List<String> expectedOutput = List.of(\n+                \"- compiler.warn.doclint.not.available\",\n+                \"1 warning\"\n+        );\n+\n+        \/\/check proper diagnostics when doclint provider not present:\n+        System.err.println(\"Test -Xdoclint when doclint not available\");\n+        actualOutput = new JavacTask(tb, Mode.CMDLINE)\n+                .options(\"-XDrawDiagnostics\", \"-Xdoclint\")\n+                .files(testSource)\n+                .outdir(\".\")\n+                .run(Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        tb.checkEqual(expectedOutput, actualOutput);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doclint\/LimitedImage.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}