{"files":[{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294985\n+ * @library \/test\/lib\n+ * @summary test for proper exception handling\n+ *\/\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.io.FileInputStream;\n+import java.nio.ByteBuffer;\n+import java.security.KeyStore;\n+import java.util.Base64;\n+\n+\n+public class Test8294985 {\n+\n+    \/\/ Test was originally written for TLSv1.2\n+    private static String proto = \"TLSv1.2\";\n+\n+    private static boolean debug = false;\n+\n+    private SSLContext sslc;\n+\n+    private SSLEngine serverEngine;     \/\/ server Engine\n+    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n+    private ByteBuffer clientOut;        \/\/ read side of serverEngine\n+\n+    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n+\n+    private static final String keyStoreFile =\n+        System.getProperty(\"test.src\", \".\/\")\n+            + \"\/..\/..\/..\/..\/javax\/net\/ssl\/etc\/keystore\";\n+\n+    private static byte[] payload = Base64.getDecoder().decode(\n+        \"FgMDAcsBAAHHAwPbDfeUCIStPzVIfXuGgCu56dSJOJ6xeus1W44frG5tciDEcBfYt\"\n+            + \"\/PN\/6MFCGojEVcmPw21mVyjYInMo0UozIn4NwBiEwITARMDwCzAK8ypwDDMqMAvA\"\n+            + \"J\/MqgCjAJ4AosAkwCjAI8AnAGsAagBnAEDALsAywC3AMcAmCgAFKsApJcDAFMAJw\"\n+            + \"BMAOQA4ADMAMsAFwA\/ABMAOAJ0AnAA9ADwANgAvAP8BAAEcAAUABQEAAAAAAAoAF\"\n+            + \"gAUAB0AFwAYABkAHgEAAQEBAgEDAQQACwACAQAAEQAJAAcCAAQAAAAAABcAAAAjA\"\n+            + \"AAADQAsACoEAwUDBgMIBwgICAQIBQgGCAkICggLBAEFAQYBBAIDAwMBAwICAwIBA\"\n+            + \"gIAKwAFBAMEAwMALQACAQEAMgAsACoEAwUDBgMIBwgICAQIBQgGCAkICggLBAEFA\"\n+            + \"QYBBAIDAwMBAwICAwIBAgIALwBrAGkAHQAAAAARACAAZMUAADkwsiaOwcsWAwAAA\"\n+            + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+            + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+            + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+            + \"AAAAAAtAAAAAAAAAAEAADAAAAA=\");\n+\n+    \/*\n+     * The following is to set up the keystores.\n+     *\/\n+    private static String passwd = \"passphrase\";\n+\n+    \/*\n+     * Main entry point for this demo.\n+     *\/\n+    public static void main(String args[]) throws Exception {\n+        if (debug) {\n+            System.setProperty(\"javax.net.debug\", \"all\");\n+        }\n+\n+        System.out.println(\"payload len:\" + payload.length);\n+\n+        Test8294985 test = new Test8294985();\n+\n+        try {\n+            test.runTest(payload);\n+            throw new Exception(\n+                \"TEST FAILED:  Didn't generate any exception\");\n+        } catch (SSLHandshakeException she) {\n+            System.out.println(\"TEST PASSED:  Caught expected exception\");\n+        }\n+    }\n+\n+    static Test8294985 fuzzdemoref = null;\n+\n+    \/*\n+     * Create an initialized SSLContext to use for this demo.\n+     *\/\n+\n+    public Test8294985() throws Exception {\n+\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        char[] passphrase = passwd.toCharArray();\n+\n+        ks.load(new FileInputStream(keyStoreFile), passphrase);\n+        ts.load(new FileInputStream(keyStoreFile), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(proto);\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        sslc = sslCtx;\n+    }\n+\n+\n+    private void runTest(byte[] injected) throws Exception {\n+\n+        createSSLEngines();\n+        createBuffers();\n+\n+        cTOs = ByteBuffer.wrap(injected);\n+\n+        System.out.println(\"injecting client hello\");\n+\n+        for (int i = 0; i < 10; i++) { \/\/retry if survived\n+            SSLEngineResult serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            System.out.println(\"server unwrap: \" + serverResult);\n+            runDelegatedTasks(serverResult, serverEngine);\n+        }\n+\n+        try {\n+            \/*\n+             * We should be getting a SSLHandshakeException.\n+             * If this changes, we'll need to update this test.\n+             * Anything else and we fail.\n+             *\/\n+            serverEngine.unwrap(cTOs, serverIn);\n+            throw new Exception(\n+                \"TEST FAILED:  Didn't generate any exception\");\n+        } catch (SSLHandshakeException e) {\n+            System.out.println(\"TEST PASSED:  Caught right exception\");\n+        } catch (SSLException e) {\n+            System.out.println(\"TEST FAILED:  Generated wrong exception\");\n+            throw e;\n+        }\n+    }\n+\n+    private void createSSLEngines() throws Exception {\n+\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n+\n+    }\n+\n+\n+    private void createBuffers() {\n+\n+        serverIn = ByteBuffer.allocateDirect(65536);\n+\n+        cTOs = ByteBuffer.allocateDirect(65536);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+                                          SSLEngine engine) throws Exception {\n+\n+        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                System.out.println(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\"handshake shouldn't need additional \" +\n+                    \"tasks\");\n+            }\n+            System.out.println(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/Test8294985.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"}]}