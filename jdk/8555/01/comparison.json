{"files":[{"patch":"@@ -374,0 +374,28 @@\n+Node *CastLLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+  \/\/ transform (CastLL (ConvI2L ..)) into (ConvI2L (CastII ..)) if the type of the CastLL is narrower than the type of\n+  \/\/ the ConvI2L.\n+  Node* in1 = in(1);\n+  if (in1 != NULL && in1->Opcode() == Op_ConvI2L) {\n+    const Type* t = Value(phase);\n+    const Type* t_in = phase->type(in1);\n+    if (t != Type::TOP && t_in != Type::TOP) {\n+      const TypeLong* tl = t->is_long();\n+      const TypeLong* t_in_l = t_in->is_long();\n+      assert(tl->_lo >= t_in_l->_lo && tl->_hi <= t_in_l->_hi, \"CastLL type should be narrower than or equal to the type of its input\");\n+      assert((tl != t_in_l) == (tl->_lo > t_in_l->_lo || tl->_hi < t_in_l->_hi), \"if type differs then this nodes's type must be narrower\");\n+      if (tl != t_in_l) {\n+        const TypeInt* ti = TypeInt::make(checked_cast<jint>(tl->_lo), checked_cast<jint>(tl->_hi), tl->_widen);\n+        Node* castii = phase->transform(new CastIINode(in(0), in1->in(1), ti));\n+        Node* convi2l = in1->clone();\n+        convi2l->set_req(1, castii);\n+        return convi2l;\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1078,0 +1078,5 @@\n+  \/\/ Pushing a shift through the iv Phi can get in the way of addressing optimizations or range check elimination\n+  if (n_blk->is_BaseCountedLoop() && n->Opcode() == Op_LShift(n_blk->as_BaseCountedLoop()->bt()) &&\n+      n->in(1) == n_blk->as_BaseCountedLoop()->phi()) {\n+    return n;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8286197\n+ * @summary C2: Optimize MemorySegment shape in int loop\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestConvI2LCastLongLoop\n+ *\/\n+\n+public class TestConvI2LCastLongLoop {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\", \"-XX:LoopMaxUnroll=0\", \"-XX:-UseCountedLoopSafepoints\");\n+    }\n+\n+    static int size = 1024;\n+    static long base = UNSAFE.allocateMemory(size * 4);\n+\n+    @Test\n+    @IR(failOn = { IRNode.CAST_LL })\n+    public static int test1() {\n+        \/\/ Make sure enough round of loop opts are executed\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                for (int k = 0; k < 10; k++) {\n+                }\n+            }\n+        }\n+        int v = 0;\n+        \/\/ In order to optimize the range check the loop is\n+        \/\/ transformed to:\n+        \/\/\n+        \/\/ for (int i1;;) {\n+        \/\/   for (int i2;;) {\n+        \/\/     long j = (i1 + i2) * UNSAFE.ARRAY_INT_INDEX_SCALE; \/\/ (i1 + i2) << 2\n+        \/\/     v += UNSAFE.getInt(base + j);\n+        \/\/   }\n+        \/\/ }\n+        \/\/\n+        \/\/ (i1 + i2) << 2 is transformed to (i1 << 2) + (i2 << 2)\n+        \/\/ because i1 is loop invariant in the inner loop.\n+        \/\/\n+        \/\/ long j = ... really is (CastLL (Convi2L ...))\n+        \/\/\n+        \/\/ With that transformed into (ConvI2L (CastII ...)), The AddL\n+        \/\/ (i1 << 2) + (i2 << 2) can be pushed through the CastII and\n+        \/\/ ConvI2L.\n+        \/\/ The address of the getInt is then:\n+        \/\/ (AddP base (AddL I V)) with I, loop invariant and V loop invariant\n+        \/\/ which can be transformed into:\n+        \/\/ (AddP (AddP base I) V)\n+        \/\/ The inner AddP is computed out of loop\n+        for (int i = 0; i < size; i++) {\n+            long j = i * UNSAFE.ARRAY_INT_INDEX_SCALE;\n+\n+            j = Objects.checkIndex(j, size * 4);\n+\n+            if (((base + j) & 3) != 0) {\n+                throw new RuntimeException();\n+            }\n+\n+            v += UNSAFE.getInt(base + j);\n+        }\n+        return v;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \">=1\", IRNode.CONV_I2L, \">=1\" })\n+    @IR(failOn = { IRNode.CAST_LL })\n+    public static long test2(int i) {\n+        \/\/ Convert (CastLL (ConvI2L ...)) into (ConvI2L (CastII ...))\n+        long j = i * UNSAFE.ARRAY_INT_INDEX_SCALE;\n+        j = Objects.checkIndex(j, size * 4);\n+        return j;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public static void test2_runner() {\n+        int i = RANDOM.nextInt(size);\n+        long res = test2(i);\n+        if (res != i * UNSAFE.ARRAY_INT_INDEX_SCALE) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.PHI, \"2\" })\n+    public static int test3() {\n+        int v = 0;\n+        \/\/ splif if should not push LshiftI through the iv Phi\n+        for (int i = 0; i < 1024; i++) {\n+            v += i * UNSAFE.ARRAY_INT_INDEX_SCALE;\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConvI2LCastLongLoop.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -179,0 +179,2 @@\n+    public static final String CAST_II = START + \"CastII\" + MID + END;\n+    public static final String CAST_LL = START + \"CastLL\" + MID + END;\n@@ -180,0 +182,1 @@\n+    public static final String PHI = START + \"Phi\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}