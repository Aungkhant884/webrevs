{"files":[{"patch":"@@ -3102,36 +3102,0 @@\n-\/\/\n-\/\/ Construct the method to copy _idx, inputs and operands to new node.\n-static void define_fill_new_machnode(bool used, FILE *fp_cpp) {\n-  fprintf(fp_cpp, \"\\n\");\n-  fprintf(fp_cpp, \"\/\/ Copy _idx, inputs and operands to new node\\n\");\n-  fprintf(fp_cpp, \"void MachNode::fill_new_machnode(MachNode* node) const {\\n\");\n-  if( !used ) {\n-    fprintf(fp_cpp, \"  \/\/ This architecture does not have cisc or short branch instructions\\n\");\n-    fprintf(fp_cpp, \"  ShouldNotCallThis();\\n\");\n-    fprintf(fp_cpp, \"}\\n\");\n-  } else {\n-    \/\/ New node must use same node index for access through allocator's tables\n-    fprintf(fp_cpp, \"  \/\/ New node must use same node index\\n\");\n-    fprintf(fp_cpp, \"  node->set_idx( _idx );\\n\");\n-    \/\/ Copy machine-independent inputs\n-    fprintf(fp_cpp, \"  \/\/ Copy machine-independent inputs\\n\");\n-    fprintf(fp_cpp, \"  for( uint j = 0; j < req(); j++ ) {\\n\");\n-    fprintf(fp_cpp, \"    node->add_req(in(j));\\n\");\n-    fprintf(fp_cpp, \"  }\\n\");\n-    \/\/ Copy machine operands to new MachNode\n-    fprintf(fp_cpp, \"  \/\/ Copy my operands, except for cisc position\\n\");\n-    fprintf(fp_cpp, \"  int nopnds = num_opnds();\\n\");\n-    fprintf(fp_cpp, \"  assert( node->num_opnds() == (uint)nopnds, \\\"Must have same number of operands\\\");\\n\");\n-    fprintf(fp_cpp, \"  MachOper **to = node->_opnds;\\n\");\n-    fprintf(fp_cpp, \"  for( int i = 0; i < nopnds; i++ ) {\\n\");\n-    fprintf(fp_cpp, \"    if( i != cisc_operand() ) \\n\");\n-    fprintf(fp_cpp, \"      to[i] = _opnds[i]->clone();\\n\");\n-    fprintf(fp_cpp, \"  }\\n\");\n-    fprintf(fp_cpp, \"  \/\/ Do not increment node index counter, since node reuses my index\\n\");\n-    fprintf(fp_cpp, \"  Compile* C = Compile::current();\\n\");\n-    fprintf(fp_cpp, \"  C->set_unique(C->unique() - 1);\\n\");\n-    fprintf(fp_cpp, \"}\\n\");\n-  }\n-  fprintf(fp_cpp, \"\\n\");\n-}\n-\n@@ -3233,1 +3197,0 @@\n-  bool used = false;\n@@ -3252,1 +3215,1 @@\n-    used |= instr->define_cisc_version(*this, fp);\n+    instr->define_cisc_version(*this, fp);\n@@ -3255,1 +3218,1 @@\n-    used |= instr->define_short_branch_methods(*this, fp);\n+    instr->define_short_branch_methods(*this, fp);\n@@ -3258,3 +3221,0 @@\n-  \/\/ Construct the method called by cisc_version() to copy inputs and operands.\n-  define_fill_new_machnode(used, fp);\n-\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -186,0 +186,21 @@\n+void MachNode::fill_new_machnode(MachNode* node) const {\n+  \/\/ New node must use same node index\n+  node->set_idx(_idx);\n+  \/\/ Copy machine-independent inputs\n+  for (uint j = 0; j < req(); j++) {\n+    node->add_req(in(j));\n+  }\n+  \/\/ Copy my operands, except for cisc position\n+  int nopnds = num_opnds();\n+  assert(node->num_opnds() == (uint)nopnds, \"Must have same number of operands\");\n+  MachOper** to = node->_opnds;\n+  for (int i = 0; i < nopnds; i++) {\n+    if (i != cisc_operand()) {\n+      to[i] = _opnds[i]->clone();\n+    }\n+  }\n+  \/\/ Do not increment node index counter, since node reuses my index\n+  Compile* C = Compile::current();\n+  C->set_unique(C->unique() - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-  \/\/ Copy inputs and operands to new node of instruction.\n+  \/\/ Copy index, inputs, and operands to a new version of the instruction.\n@@ -234,1 +234,0 @@\n-  \/\/ !!!! The method's body is defined in ad_<arch>.cpp file.\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}