{"files":[{"patch":"@@ -1874,3 +1874,1 @@\n-    ciInstanceKlass* sender_klass =\n-          calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                                 calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -644,9 +644,5 @@\n-    if (cpool->is_pseudo_string_at(index)) {\n-      string = cpool->pseudo_string_at(index, cache_index);\n-    } else {\n-      string = cpool->string_at(index, cache_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-        record_out_of_memory_failure();\n-        return ciConstant();\n-      }\n+    string = cpool->string_at(index, cache_index, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+      record_out_of_memory_failure();\n+      return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -231,2 +231,1 @@\n-  \/\/ Trust hidden classes and VM unsafe anonymous classes. They are created via\n-  \/\/ Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and\n+  \/\/ Trust hidden classes. They are created via Lookup.defineHiddenClass and\n@@ -234,1 +233,1 @@\n-  if (holder->is_hidden() || holder->is_unsafe_anonymous())\n+  if (holder->is_hidden())\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  _is_unsafe_anonymous = ik->is_unsafe_anonymous();\n@@ -84,1 +83,1 @@\n-    \/\/ non-strong hidden classes and VM unsafe anonymous classes alive (loader == NULL). Klass holder should\n+    \/\/ non-strong hidden classes alive (loader == NULL). Klass holder should\n@@ -88,1 +87,1 @@\n-    assert(holder != NULL, \"holder of hidden or unsafe anonymous class is the mirror which is never null\");\n+    assert(holder != NULL, \"holder of hidden class is the mirror which is never null\");\n@@ -131,1 +130,0 @@\n-  _is_unsafe_anonymous = false;\n@@ -663,10 +661,0 @@\n-ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {\n-  assert(is_loaded(), \"must be loaded\");\n-  if (is_unsafe_anonymous()) {\n-    VM_ENTRY_MARK\n-    Klass* unsafe_anonymous_host = get_instanceKlass()->unsafe_anonymous_host();\n-    return CURRENT_ENV->get_instance_klass(unsafe_anonymous_host);\n-  }\n-  return NULL;\n-}\n-\n@@ -756,1 +744,1 @@\n-    if (sub->is_instance_klass() && !sub->is_hidden() && !InstanceKlass::cast(sub)->is_unsafe_anonymous()) {\n+    if (sub->is_instance_klass() && !sub->is_hidden()) {\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  bool                   _is_unsafe_anonymous;\n@@ -197,4 +196,0 @@\n-  bool is_unsafe_anonymous() const {\n-    return _is_unsafe_anonymous;\n-  }\n-\n@@ -293,2 +288,0 @@\n-  ciInstanceKlass* unsafe_anonymous_host();\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -325,12 +325,0 @@\n-        if (has_cp_patch_at(index)) {\n-          Handle patch = clear_cp_patch_at(index);\n-          guarantee_property(java_lang_String::is_instance(patch()),\n-                             \"Illegal utf8 patch at %d in class file %s\",\n-                             index,\n-                             CHECK);\n-          const char* const str = java_lang_String::as_utf8_string(patch());\n-          \/\/ (could use java_lang_String::as_symbol instead, but might as well batch them)\n-          utf8_buffer = (const u1*) str;\n-          utf8_length = (u2) strlen(str);\n-        }\n-\n@@ -619,31 +607,1 @@\n-  _first_patched_klass_resolved_index = num_klasses;\n-  cp->allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);\n-\n-  if (_cp_patches != NULL) {\n-    \/\/ need to treat this_class specially...\n-\n-    \/\/ Add dummy utf8 entries in the space reserved for names of patched classes. We'll use \"*\"\n-    \/\/ for now. These will be replaced with actual names of the patched classes in patch_class().\n-    Symbol* s = vmSymbols::star_name();\n-    for (int n=_orig_cp_size; n<cp->length(); n++) {\n-      cp->symbol_at_put(n, s);\n-    }\n-\n-    int this_class_index;\n-    {\n-      stream->guarantee_more(8, CHECK);  \/\/ flags, this_class, super_class, infs_len\n-      const u1* const mark = stream->current();\n-      stream->skip_u2_fast(1); \/\/ skip flags\n-      this_class_index = stream->get_u2_fast();\n-      stream->set_current(mark);  \/\/ revert to mark\n-    }\n-\n-    for (index = 1; index < length; index++) {          \/\/ Index 0 is unused\n-      if (has_cp_patch_at(index)) {\n-        guarantee_property(index != this_class_index,\n-          \"Illegal constant pool patch to self at %d in class file %s\",\n-          index, CHECK);\n-        patch_constant_pool(cp, index, cp_patch_at(index), CHECK);\n-      }\n-    }\n-  }\n+  cp->allocate_resolved_klasses(_loader_data, num_klasses, CHECK);\n@@ -662,1 +620,1 @@\n-        \/\/ check the name, even if _cp_patches will overwrite it\n+        \/\/ check the name\n@@ -802,82 +760,0 @@\n-Handle ClassFileParser::clear_cp_patch_at(int index) {\n-  Handle patch = cp_patch_at(index);\n-  _cp_patches->at_put(index, Handle());\n-  assert(!has_cp_patch_at(index), \"\");\n-  return patch;\n-}\n-\n-void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {\n-  int name_index = _orig_cp_size + _num_patched_klasses;\n-  int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;\n-\n-  cp->klass_at_put(class_index, name_index, resolved_klass_index, k, name);\n-  _num_patched_klasses ++;\n-}\n-\n-void ClassFileParser::patch_constant_pool(ConstantPool* cp,\n-                                          int index,\n-                                          Handle patch,\n-                                          TRAPS) {\n-  assert(cp != NULL, \"invariant\");\n-\n-  BasicType patch_type = T_VOID;\n-\n-  switch (cp->tag_at(index).value()) {\n-\n-    case JVM_CONSTANT_UnresolvedClass: {\n-      \/\/ Patching a class means pre-resolving it.\n-      \/\/ The name in the constant pool is ignored.\n-      if (java_lang_Class::is_instance(patch())) {\n-        guarantee_property(!java_lang_Class::is_primitive(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Klass* k = java_lang_Class::as_Klass(patch());\n-        patch_class(cp, index, k, k->name());\n-      } else {\n-        guarantee_property(java_lang_String::is_instance(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Symbol* const name = java_lang_String::as_symbol(patch());\n-        patch_class(cp, index, NULL, name);\n-      }\n-      break;\n-    }\n-\n-    case JVM_CONSTANT_String: {\n-      \/\/ skip this patch and don't clear it.  Needs the oop array for resolved\n-      \/\/ references to be created first.\n-      return;\n-    }\n-    case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;\n-    case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;\n-    case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;\n-    case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;\n-    patch_prim:\n-    {\n-      jvalue value;\n-      BasicType value_type = java_lang_boxing_object::get_value(patch(), &value);\n-      guarantee_property(value_type == patch_type,\n-                         \"Illegal primitive patch at %d in class file %s\",\n-                         index, CHECK);\n-      switch (value_type) {\n-        case T_INT:    cp->int_at_put(index,   value.i); break;\n-        case T_FLOAT:  cp->float_at_put(index, value.f); break;\n-        case T_LONG:   cp->long_at_put(index,  value.j); break;\n-        case T_DOUBLE: cp->double_at_put(index, value.d); break;\n-        default:       assert(false, \"\");\n-      }\n-    } \/\/ end patch_prim label\n-    break;\n-\n-    default: {\n-      \/\/ %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.\n-      guarantee_property(!has_cp_patch_at(index),\n-                         \"Illegal unexpected patch at %d in class file %s\",\n-                         index, CHECK);\n-      return;\n-    }\n-  } \/\/ end of switch(tag)\n-\n-  \/\/ On fall-through, mark the patch as used.\n-  clear_cp_patch_at(index);\n-}\n@@ -5432,1 +5308,1 @@\n-  if (_is_hidden || is_unsafe_anonymous()) {\n+  if (_is_hidden) {\n@@ -5434,3 +5310,3 @@\n-    \/\/ hidden or anonymous class itself. If this class needs to refer to its own\n-    \/\/ methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n-    \/\/ _this_class_index. However, because this class is hidden or anonymous (it's\n+    \/\/ hidden class itself. If this class needs to refer to its own methods\n+    \/\/ or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n+    \/\/ _this_class_index. However, because this class is hidden (it's\n@@ -5448,4 +5324,0 @@\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert (ik->is_unsafe_anonymous(), \"should be the same\");\n-    ik->set_unsafe_anonymous_host(_unsafe_anonymous_host);\n-  }\n@@ -5617,51 +5489,0 @@\n-\/\/ For an unsafe anonymous class that is in the unnamed package, move it to its host class's\n-\/\/ package by prepending its host class's package name to its class name and setting\n-\/\/ its _class_name field.\n-void ClassFileParser::prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host) {\n-  ResourceMark rm(current);\n-  assert(strrchr(_class_name->as_C_string(), JVM_SIGNATURE_SLASH) == NULL,\n-         \"Unsafe anonymous class should not be in a package\");\n-  TempNewSymbol host_pkg_name =\n-    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());\n-\n-  if (host_pkg_name != NULL) {\n-    int host_pkg_len = host_pkg_name->utf8_length();\n-    int class_name_len = _class_name->utf8_length();\n-    int symbol_len = host_pkg_len + 1 + class_name_len;\n-    char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);\n-    int n = os::snprintf(new_anon_name, symbol_len + 1, \"%.*s\/%.*s\",\n-                         host_pkg_len, host_pkg_name->base(), class_name_len, _class_name->base());\n-    assert(n == symbol_len, \"Unexpected number of characters in string\");\n-\n-    \/\/ Decrement old _class_name to avoid leaking.\n-    _class_name->decrement_refcount();\n-\n-    \/\/ Create a symbol and update the anonymous class name.\n-    \/\/ The new class name is created with a refcount of one. When installed into the InstanceKlass,\n-    \/\/ it'll be two and when the ClassFileParser destructor runs, it'll go back to one and get deleted\n-    \/\/ when the class is unloaded.\n-    _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);\n-  }\n-}\n-\n-\/\/ If the host class and the anonymous class are in the same package then do\n-\/\/ nothing.  If the anonymous class is in the unnamed package then move it to its\n-\/\/ host's package.  If the classes are in different packages then throw an IAE\n-\/\/ exception.\n-void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {\n-  assert(_unsafe_anonymous_host != NULL, \"Expected an unsafe anonymous class\");\n-\n-  const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name->base(),\n-                                               _class_name->utf8_length(), JVM_SIGNATURE_SLASH);\n-  if (anon_last_slash == NULL) {  \/\/ Unnamed package\n-    prepend_host_package_name(THREAD, _unsafe_anonymous_host);\n-  } else {\n-    if (!_unsafe_anonymous_host->is_same_class_package(_unsafe_anonymous_host->class_loader(), _class_name)) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-        err_msg(\"Host class %s and anonymous class %s are in different packages\",\n-        _unsafe_anonymous_host->name()->as_C_string(), _class_name->as_C_string()));\n-    }\n-  }\n-}\n-\n@@ -5688,2 +5509,0 @@\n-  _unsafe_anonymous_host(cl_info->unsafe_anonymous_host()),\n-  _cp_patches(cl_info->cp_patches()),\n@@ -5692,2 +5511,0 @@\n-  _num_patched_klasses(0),\n-  _max_num_patched_klasses(0),\n@@ -5695,1 +5512,0 @@\n-  _first_patched_klass_resolved_index(0),\n@@ -5772,19 +5588,0 @@\n-  if (_cp_patches != NULL) {\n-    int len = _cp_patches->length();\n-    for (int i=0; i<len; i++) {\n-      if (has_cp_patch_at(i)) {\n-        Handle patch = cp_patch_at(i);\n-        if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {\n-          \/\/ We need to append the names of the patched classes to the end of the constant pool,\n-          \/\/ because a patched class may have a Utf8 name that's not already included in the\n-          \/\/ original constant pool. These class names are used when patch_constant_pool()\n-          \/\/ calls patch_class().\n-          \/\/\n-          \/\/ Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.\n-          \/\/ At this point, we don't know the tag for index i yet, because we haven't parsed the\n-          \/\/ constant pool. So we can only assume the worst -- every String is used to patch a Class.\n-          _max_num_patched_klasses++;\n-        }\n-      }\n-    }\n-  }\n@@ -5920,1 +5717,0 @@\n-    assert(_max_num_patched_klasses == 0, \"Sanity check\");\n@@ -5922,5 +5718,0 @@\n-  } else {\n-    if (int(cp_size) + _max_num_patched_klasses > 0xffff) {\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"not enough space for patched classes\");\n-    }\n-    cp_size += _max_num_patched_klasses;\n@@ -5990,5 +5781,0 @@\n-  assert(!(_is_hidden && (_unsafe_anonymous_host != NULL)), \"mutually exclusive variants\");\n-\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert(_class_name == vmSymbols::unknown_class_name(), \"A named anonymous class???\");\n-  }\n@@ -6000,2 +5786,1 @@\n-  \/\/ Update the _class_name as needed depending on whether this is a named,\n-  \/\/ un-named, hidden or unsafe-anonymous class.\n+  \/\/ Update the _class_name as needed depending on whether this is a named, un-named, or hidden class.\n@@ -6011,10 +5796,0 @@\n-  \/\/ NOTE: !_is_hidden does not imply \"findable\" as it could be an old-style\n-  \/\/       \"hidden\" unsafe-anonymous class\n-\n-  \/\/ If this is an anonymous class fix up its name if it is in the unnamed\n-  \/\/ package.  Otherwise, throw IAE if it is in a different package than\n-  \/\/ its host class.\n-  } else if (_unsafe_anonymous_host != NULL) {\n-    update_class_name(class_name_in_cp);\n-    fix_unsafe_anonymous_class_name(CHECK);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":232,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -116,2 +116,0 @@\n-  const InstanceKlass* _unsafe_anonymous_host;\n-  GrowableArray<Handle>* _cp_patches; \/\/ overrides for CP entries\n@@ -120,2 +118,0 @@\n-  int _num_patched_klasses;\n-  int _max_num_patched_klasses;\n@@ -123,1 +119,0 @@\n-  int _first_patched_klass_resolved_index;\n@@ -214,3 +209,0 @@\n-  void prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host);\n-  void fix_unsafe_anonymous_class_name(TRAPS);\n-\n@@ -497,20 +489,0 @@\n-  bool has_cp_patch_at(int index) const {\n-    assert(index >= 0, \"oob\");\n-    return (_cp_patches != NULL\n-            && index < _cp_patches->length()\n-            && _cp_patches->adr_at(index)->not_null());\n-  }\n-\n-  Handle cp_patch_at(int index) const {\n-    assert(has_cp_patch_at(index), \"oob\");\n-    return _cp_patches->at(index);\n-  }\n-\n-  Handle clear_cp_patch_at(int index);\n-\n-  void patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name);\n-  void patch_constant_pool(ConstantPool* cp,\n-                           int index,\n-                           Handle patch,\n-                           TRAPS);\n-\n@@ -585,1 +557,0 @@\n-  bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }\n@@ -589,2 +560,0 @@\n-  const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }\n-  const GrowableArray<Handle>* cp_patches() const { return _cp_patches; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-  const InstanceKlass*   _unsafe_anonymous_host;\n-  GrowableArray<Handle>* _cp_patches;\n@@ -67,2 +65,0 @@\n-    _unsafe_anonymous_host = NULL;\n-    _cp_patches = NULL;\n@@ -76,2 +72,1 @@\n-  ClassLoadInfo(Handle protection_domain, const InstanceKlass* unsafe_anonymous_host,\n-                GrowableArray<Handle>* cp_patches, InstanceKlass* dynamic_nest_host,\n+  ClassLoadInfo(Handle protection_domain, InstanceKlass* dynamic_nest_host,\n@@ -81,2 +76,0 @@\n-    _unsafe_anonymous_host = unsafe_anonymous_host;\n-    _cp_patches = cp_patches;\n@@ -91,2 +84,0 @@\n-  const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }\n-  GrowableArray<Handle>* cp_patches()    const { return _cp_patches; }\n","filename":"src\/hotspot\/share\/classfile\/classLoadInfo.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1259,2 +1259,2 @@\n-  if (ik->is_hidden() || ik->is_unsafe_anonymous()) {\n-    \/\/ We do not archive hidden or unsafe anonymous classes.\n+  if (ik->is_hidden()) {\n+    \/\/ We do not archive hidden classes.\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-  \/\/ An unsafe anonymous class loader data doesn't have anything to keep\n-  \/\/ it from being unloaded during parsing of the unsafe anonymous class.\n+  \/\/ A non-strong hidden class loader data doesn't have anything to keep\n+  \/\/ it from being unloaded during parsing of the non-strong hidden class.\n@@ -160,1 +160,1 @@\n-    \/\/ The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,\n+    \/\/ The holder is initialized later for non-strong hidden classes,\n@@ -164,3 +164,2 @@\n-    \/\/ A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should\n-    \/\/ never have a ModuleEntryTable or PackageEntryTable created for it. The defining package\n-    \/\/ and module for an unsafe anonymous class will be found in its host class.\n+    \/\/ A ClassLoaderData created solely for a non-strong hidden class should never\n+    \/\/ have a ModuleEntryTable or PackageEntryTable created for it.\n@@ -300,1 +299,1 @@\n-\/\/ Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive\n+\/\/ Weak hidden classes have their own ClassLoaderData that is marked to keep alive\n@@ -302,2 +301,2 @@\n-\/\/ Due to the uniqueness that no other class shares the hidden or unsafe anonymous class' name or\n-\/\/ ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while\n+\/\/ Due to the uniqueness that no other class shares the hidden class' name or\n+\/\/ ClassLoaderData, no other non-GC thread has knowledge of the hidden class while\n@@ -429,2 +428,2 @@\n-    \/\/ Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency\n-    \/\/ to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class\n+    \/\/ Just return if a non-strong hidden class class is attempting to record a dependency\n+    \/\/ to itself.  (Note that every non-strong hidden class has its own unique class\n@@ -435,1 +434,1 @@\n-    \/\/ Hidden and unsafe anonymous class dependencies are through the mirror.\n+    \/\/ Hidden class dependencies are through the mirror.\n@@ -629,1 +628,1 @@\n-  bool alive = keep_alive()         \/\/ null class loader and incomplete non-strong hidden class or unsafe anonymous class.\n+  bool alive = keep_alive()         \/\/ null class loader and incomplete non-strong hidden class.\n@@ -741,1 +740,1 @@\n-\/\/ loader data is for a non-strong hidden class or unsafe anonymous class then it may\n+\/\/ loader data is for a non-strong hidden class then it may\n@@ -751,1 +750,1 @@\n-\/\/ class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.\n+\/\/ class loaders and not the CLD for a non-strong hidden class.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                                 \/\/ the CLDs lifecycle.  For example, a non-strong hidden class or an\n-                                 \/\/ unsafe anonymous class.  Arrays of these classes are also assigned\n+                                 \/\/ the CLDs lifecycle.  For example, a non-strong hidden class.\n+                                 \/\/ Arrays of these classes are also assigned\n@@ -128,1 +128,1 @@\n-                           \/\/ Used for non-strong hidden classes, unsafe anonymous classes and the\n+                           \/\/ Used for non-strong hidden classes and the\n@@ -130,2 +130,1 @@\n-                           \/\/ atomic since there is one unique CLD per non-strong hidden class\n-                           \/\/ or unsafe anonymous class.\n+                           \/\/ atomic since there is one unique CLD per non-strong hidden class.\n@@ -241,1 +240,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -245,1 +244,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -249,1 +248,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -270,2 +269,1 @@\n-  \/\/ Used to refcount a non-strong hidden class's or unsafe anonymous class's CLD in order to\n-  \/\/ indicate their aliveness.\n+  \/\/ Used to refcount a non-strong hidden class's s CLD in order to indicate their aliveness.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  \/\/ Walking the ClassLoaderDataGraph also includes hidden and unsafe anonymous classes.\n+  \/\/ Walking the ClassLoaderDataGraph also includes hidden classes.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-             \"loaders for non-strong hidden classes or unsafe anonymous classes not supported\");\n+             \"loaders for non-strong hidden classes not supported\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,1 @@\n-            \/\/ non-strong hidden and unsafe anonymous classes should not live in\n+            \/\/ non-strong hidden classes should not live in\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  \/\/ for \"real\" classes and anonymous classes together\n+  \/\/ for \"real\" classes and hidden classes together\n@@ -74,1 +74,1 @@\n-    \/\/ If cld has a class holder then it must be either hidden or unsafe anonymous.\n+    \/\/ If cld has a class holder then it must be hidden.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -924,2 +924,2 @@\n-      \/\/ Copy resolved anonymous class into new constant pool.\n-      if (klass->is_unsafe_anonymous() || klass->is_hidden()) {\n+      \/\/ Copy resolved hidden class into new constant pool.\n+      if (klass->is_hidden()) {\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4065,1 +4065,1 @@\n-  \/\/ Add a reference to the loader (actually mirror because unsafe anonymous classes will not have\n+  \/\/ Add a reference to the loader (actually mirror because hidden classes may not have\n@@ -5011,1 +5011,1 @@\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymous classes\n+      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,5 +186,2 @@\n-  assert(!(cl_info.is_hidden() && (cl_info.unsafe_anonymous_host() != NULL)),\n-         \"hidden class has an anonymous host\");\n-\n-  \/\/ Skip this processing for VM hidden or anonymous classes\n-  if (!cl_info.is_hidden() && (cl_info.unsafe_anonymous_host() == NULL)) {\n+  \/\/ Skip this processing for VM hidden classes\n+  if (!cl_info.is_hidden()) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-  \/\/ Note that c_heap will be true for non-strong hidden classes and unsafe anonymous classes\n+  \/\/ Note that c_heap will be true for non-strong hidden classes.\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-\/\/ Handles Lookup.defineClass hidden and unsafe_DefineAnonymousClass.\n+\/\/ Handles Lookup.defineClass hidden.\n@@ -831,1 +831,0 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n@@ -833,2 +832,0 @@\n-  \/\/ - for unsafe anonymous class: create a new CLD whith a class holder that uses\n-  \/\/                               the same class loader as the unsafe_anonymous_host.\n@@ -838,4 +835,2 @@\n-  assert (is_unsafe_anon_class || cl_info.is_hidden(), \"only used for hidden classes\");\n-  guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n-              \"should be NULL or the same\");\n-  bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+  assert (cl_info.is_hidden(), \"only used for hidden classes\");\n+  bool create_mirror_cld = !cl_info.is_strong_hidden();\n@@ -855,4 +850,3 @@\n-  \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n-  \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n-  \/\/ longer referenced.\n-  if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+  \/\/ Hidden classes that are not strong must update ClassLoaderData holder\n+  \/\/ so that they can be unloaded when the mirror is no longer referenced.\n+  if (!cl_info.is_strong_hidden()) {\n@@ -869,1 +863,0 @@\n-  \/\/ Rewrite and patch constant pool here.\n@@ -871,8 +864,0 @@\n-  if (cl_info.cp_patches() != NULL) {\n-    k->constants()->patch_resolved_references(cl_info.cp_patches());\n-  }\n-\n-  \/\/ If it's anonymous, initialize it now, since nobody else will.\n-  if (is_unsafe_anon_class) {\n-    k->eager_initialize(CHECK_NULL);\n-  }\n@@ -888,3 +873,0 @@\n-  assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),\n-         \"cp_patches only found with unsafe_anonymous_host\");\n-\n@@ -968,2 +950,1 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n-  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n+  if (cl_info.is_hidden()) {\n@@ -1186,1 +1167,1 @@\n-  \/\/ CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).\n+  \/\/ CFLH check is skipped for VM hidden classes (see KlassFactory::create_from_stream).\n@@ -1621,1 +1602,0 @@\n-\/\/ Note: anonymous classes are not in the SD.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  \/\/ Parse the stream to create an unsafe anonymous or hidden class.\n-  \/\/ Used by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n+  \/\/ Parse the stream to create a hidden class.\n+  \/\/ Used by jvm_lookup_define_class.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1110,1 +1110,1 @@\n-  if (class_name == NULL) {  \/\/ don't do this for hidden and unsafe anonymous classes\n+  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n@@ -1336,5 +1336,0 @@\n-  if (k->is_unsafe_anonymous()) {\n-    warn_excluded(k, \"Unsafe anonymous class\");\n-    return true; \/\/ unsafe anonymous classes are not archived, skip\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2161,3 +2161,1 @@\n-  if (tag.is_string() && cp->is_pseudo_string_at(index)) {\n-    current_frame->push_stack(object_type(), CHECK_VERIFY(this));\n-  } else if (tag.is_string()) {\n+  if (tag.is_string()) {\n@@ -2879,15 +2877,2 @@\n-    if (!current_class()->is_unsafe_anonymous()) {\n-      subtype = ref_class_type.is_assignable_from(\n-                 current_type(), this, false, CHECK_VERIFY(this));\n-    } else {\n-      VerificationType unsafe_anonymous_host_type =\n-                        VerificationType::reference_type(current_class()->unsafe_anonymous_host()->name());\n-      subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));\n-\n-      \/\/ If invokespecial of IMR, need to recheck for same or\n-      \/\/ direct interface relative to the host class\n-      have_imr_indirect = (have_imr_indirect &&\n-                           !is_same_or_direct_interface(\n-                             current_class()->unsafe_anonymous_host(),\n-                             unsafe_anonymous_host_type, ref_class_type));\n-    }\n+    subtype = ref_class_type.is_assignable_from(\n+               current_type(), this, false, CHECK_VERIFY(this));\n@@ -2928,18 +2913,1 @@\n-        if (!current_class()->is_unsafe_anonymous()) {\n-          current_frame->pop_stack(current_type(), CHECK_VERIFY(this));\n-        } else {\n-          \/\/ anonymous class invokespecial calls: check if the\n-          \/\/ objectref is a subtype of the unsafe_anonymous_host of the current class\n-          \/\/ to allow an anonymous class to reference methods in the unsafe_anonymous_host\n-          VerificationType top = current_frame->pop_stack(CHECK_VERIFY(this));\n-          VerificationType hosttype =\n-            VerificationType::reference_type(current_class()->unsafe_anonymous_host()->name());\n-          bool subtype = hosttype.is_assignable_from(top, this, false, CHECK_VERIFY(this));\n-          if (!subtype) {\n-            verify_error( ErrorContext::bad_type(current_frame->offset(),\n-              current_frame->stack_top_ctx(),\n-              TypeOrigin::implicit(top)),\n-              \"Bad type on operand stack\");\n-            return;\n-          }\n-        }\n+        current_frame->pop_stack(current_type(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":4,"deletions":36,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -869,2 +869,2 @@\n-  \/\/ Get sender or sender's unsafe_anonymous_host, and only set cpCache entry to resolved if\n-  \/\/ it is not an interface.  The receiver for invokespecial calls within interface\n+  \/\/ Get sender and only set cpCache entry to resolved if it is not an\n+  \/\/ interface.  The receiver for invokespecial calls within interface\n@@ -873,1 +873,0 @@\n-  sender = sender->is_unsafe_anonymous() ? sender->unsafe_anonymous_host() : sender;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1157,4 +1157,1 @@\n-    InstanceKlass* ck = InstanceKlass::cast(current_klass);\n-    InstanceKlass *klass_to_check = !ck->is_unsafe_anonymous() ?\n-                                    ck :\n-                                    ck->unsafe_anonymous_host();\n+    InstanceKlass* klass_to_check = InstanceKlass::cast(current_klass);\n@@ -1250,1 +1247,0 @@\n-    sender = sender->is_unsafe_anonymous() ? sender->unsafe_anonymous_host() : sender;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    if (ik->is_unsafe_anonymous() || ik->is_hidden()) {\n+    if (ik->is_hidden()) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleDescription.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,6 +197,0 @@\n-static bool is_unsafe_anonymous(const Klass* klass) {\n-  assert(klass != NULL, \"invariant\");\n-  assert(!klass->is_objArray_klass(), \"invariant\");\n-  return klass->is_instance_klass() && InstanceKlass::cast(klass)->is_unsafe_anonymous();\n-}\n-\n@@ -209,2 +203,1 @@\n-  return is_unsafe_anonymous(klass) ?\n-    InstanceKlass::cast(klass)->unsafe_anonymous_host()->class_loader_data() : klass->class_loader_data();\n+  return klass->class_loader_data();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,2 +187,2 @@\n-* jsr292 anonymous classes symbol is the external name +\n-* the identity_hashcode slash appended:\n+* hidden classes symbol is the external name +\n+* the address of its InstanceKlass slash appended:\n@@ -194,1 +194,1 @@\n-uintptr_t JfrSymbolId::hidden_or_anon_klass_name_hash(const InstanceKlass* ik) {\n+uintptr_t JfrSymbolId::hidden_klass_name_hash(const InstanceKlass* ik) {\n@@ -196,1 +196,1 @@\n-  assert(ik->is_unsafe_anonymous() || ik->is_hidden(), \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n@@ -202,1 +202,1 @@\n-static const char* create_hidden_or_anon_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n+static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n@@ -204,1 +204,1 @@\n-  assert(ik->is_unsafe_anonymous() || ik->is_hidden(), \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n@@ -206,1 +206,1 @@\n-  char* hidden_or_anon_symbol = NULL;\n+  char* hidden_symbol = NULL;\n@@ -213,6 +213,6 @@\n-  hidden_or_anon_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_or_anon_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_or_anon_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_or_anon_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_or_anon_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_or_anon_symbol;\n+  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n+  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n+  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n+  strcpy(hidden_symbol + result_len, hash_buf);\n+  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n+  return hidden_symbol;\n@@ -221,1 +221,1 @@\n-bool JfrSymbolId::is_hidden_or_anon_klass(const Klass* k) {\n+bool JfrSymbolId::is_hidden_klass(const Klass* k) {\n@@ -223,3 +223,1 @@\n-  return k->is_instance_klass() &&\n-    (((const InstanceKlass*)k)->is_unsafe_anonymous() ||\n-     ((const InstanceKlass*)k)->is_hidden());\n+  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n@@ -228,1 +226,1 @@\n-traceid JfrSymbolId::mark_hidden_or_anon_klass_name(const InstanceKlass* ik, bool leakp) {\n+traceid JfrSymbolId::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n@@ -230,4 +228,4 @@\n-  assert(ik->is_unsafe_anonymous() || ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_or_anon_klass_name_hash(ik);\n-  const char* const hidden_or_anon_symbol = create_hidden_or_anon_klass_symbol(ik, hash);\n-  return mark(hash, hidden_or_anon_symbol, leakp);\n+  assert(ik->is_hidden(), \"invariant\");\n+  const uintptr_t hash = hidden_klass_name_hash(ik);\n+  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n+  return mark(hash, hidden_symbol, leakp);\n@@ -239,1 +237,1 @@\n-  if (is_hidden_or_anon_klass(k)) {\n+  if (is_hidden_klass(k)) {\n@@ -241,1 +239,1 @@\n-    symbol_id = mark_hidden_or_anon_klass_name((const InstanceKlass*)k, leakp);\n+    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n@@ -285,1 +283,1 @@\n-traceid JfrArtifactSet::mark_hidden_or_anon_klass_name(const Klass* klass, bool leakp) {\n+traceid JfrArtifactSet::mark_hidden_klass_name(const Klass* klass, bool leakp) {\n@@ -287,1 +285,1 @@\n-  return _symbol_id->mark_hidden_or_anon_klass_name((const InstanceKlass*)klass, leakp);\n+  return _symbol_id->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,3 +254,3 @@\n-  traceid mark_hidden_or_anon_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_or_anon_klass(const Klass* k);\n-  uintptr_t hidden_or_anon_klass_name_hash(const InstanceKlass* ik);\n+  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n+  bool is_hidden_klass(const Klass* k);\n+  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n@@ -318,1 +318,1 @@\n-  traceid mark_hidden_or_anon_klass_name(const Klass* klass, bool leakp);\n+  traceid mark_hidden_klass_name(const Klass* klass, bool leakp);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1572,8 +1572,0 @@\n-C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))\n-  InstanceKlass* k = InstanceKlass::cast(JVMCIENV->asKlass(jvmci_type));\n-  InstanceKlass* host = k->unsafe_anonymous_host();\n-  JVMCIKlassHandle handle(THREAD, host);\n-  JVMCIObject result = JVMCIENV->get_jvmci_type(handle, JVMCI_CHECK_NULL);\n-  return JVMCIENV->get_jobject(result);\n-C2V_END\n-\n@@ -2676,1 +2668,0 @@\n-  {CC \"getHostClass\",                                 CC \"(\" HS_RESOLVED_KLASS \")\" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -587,1 +587,0 @@\n-  declare_constant(InstanceKlass::_misc_is_unsafe_anonymous)              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-    \/\/ or    \"CLD for <hidden or anonymous class>, loaded by [<loader name>,] instance of <loader class name>\"\n+    \/\/ or    \"CLD for <hidden>, loaded by [<loader name>,] instance of <loader class name>\"\n@@ -136,1 +136,1 @@\n-      _out->print(\" <hidden or anonymous class>, loaded by\");\n+      _out->print(\" <hidden class>, loaded by\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printCLDMetaspaceInfoClosure.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -241,23 +241,1 @@\n-\/\/ Unsafe anonymous class support:\n-void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {\n-  assert(is_within_bounds(class_index), \"index out of bounds\");\n-  assert(is_within_bounds(name_index), \"index out of bounds\");\n-  assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n-  *int_at_addr(class_index) =\n-    build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n-\n-  symbol_at_put(name_index, name);\n-  name->increment_refcount();\n-  Klass** adr = resolved_klasses()->adr_at(resolved_klass_index);\n-  Atomic::release_store(adr, k);\n-\n-  \/\/ The interpreter assumes when the tag is stored, the klass is resolved\n-  \/\/ and the Klass* non-NULL, so we need hardware store ordering here.\n-  if (k != NULL) {\n-    release_tag_at_put(class_index, JVM_CONSTANT_Class);\n-  } else {\n-    release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);\n-  }\n-}\n-\n-\/\/ Unsafe anonymous class support:\n+\/\/ Hidden class support:\n@@ -333,1 +311,1 @@\n-    if (tag_at(index).is_string() && !cp->is_pseudo_string_at(index)) {\n+    if (tag_at(index).is_string()) {\n@@ -1066,4 +1044,0 @@\n-    if (this_cp->is_pseudo_string_at(index)) {\n-      result_oop = this_cp->pseudo_string_at(index, cache_index);\n-      break;\n-    }\n@@ -2261,32 +2235,0 @@\n-\/\/ JSR 292 support for patching constant pool oops after the class is linked and\n-\/\/ the oop array for resolved references are created.\n-\/\/ We can't do this during classfile parsing, which is how the other indexes are\n-\/\/ patched.  The other patches are applied early for some error checking\n-\/\/ so only defer the pseudo_strings.\n-void ConstantPool::patch_resolved_references(GrowableArray<Handle>* cp_patches) {\n-  for (int index = 1; index < cp_patches->length(); index++) { \/\/ Index 0 is unused\n-    Handle patch = cp_patches->at(index);\n-    if (patch.not_null()) {\n-      assert (tag_at(index).is_string(), \"should only be string left\");\n-      \/\/ Patching a string means pre-resolving it.\n-      \/\/ The spelling in the constant pool is ignored.\n-      \/\/ The constant reference may be any object whatever.\n-      \/\/ If it is not a real interned string, the constant is referred\n-      \/\/ to as a \"pseudo-string\", and must be presented to the CP\n-      \/\/ explicitly, because it may require scavenging.\n-      int obj_index = cp_to_object_index(index);\n-      pseudo_string_at_put(index, obj_index, patch());\n-     DEBUG_ONLY(cp_patches->at_put(index, Handle());)\n-    }\n-  }\n-#ifdef ASSERT\n-  \/\/ Ensure that all the patches have been used.\n-  for (int index = 0; index < cp_patches->length(); index++) {\n-    assert(cp_patches->at(index).is_null(),\n-           \"Unused constant pool patch at %d in class file %s\",\n-           index,\n-           pool_holder()->external_name());\n-  }\n-#endif \/\/ ASSERT\n-}\n-\n@@ -2345,7 +2287,1 @@\n-      if (is_pseudo_string_at(index)) {\n-        oop anObj = pseudo_string_at(index);\n-        anObj->print_value_on(st);\n-        st->print(\" {\" PTR_FORMAT \"}\", p2i(anObj));\n-      } else {\n-        unresolved_string_at(index)->print_value_on(st);\n-      }\n+      unresolved_string_at(index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":67,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool is_pseudo_string() { return (_ptr & _pseudo_bit) != 0; }\n@@ -313,2 +312,1 @@\n-  \/\/ Unsafe anonymous class support:\n-  void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);\n+  \/\/ Hidden class support:\n@@ -488,20 +486,0 @@\n-  \/\/ A \"pseudo-string\" is an non-string oop that has found its way into\n-  \/\/ a String entry.\n-  \/\/ This can happen if the user patches a live\n-  \/\/ object into a CONSTANT_String entry of an unsafe anonymous class.\n-  \/\/ Methods internally created for method handles may also\n-  \/\/ use pseudo-strings to link themselves to related metaobjects.\n-\n-  bool is_pseudo_string_at(int which);\n-\n-  oop pseudo_string_at(int which, int obj_index);\n-\n-  oop pseudo_string_at(int which);\n-\n-  void pseudo_string_at_put(int which, int obj_index, oop x) {\n-    assert(tag_at(which).is_string(), \"Corrupted constant pool\");\n-    Symbol* sym = unresolved_string_at(which);\n-    slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));\n-    string_at_put(which, obj_index, x);    \/\/ this works just fine\n-  }\n-\n@@ -857,3 +835,0 @@\n-  \/\/ patch JSR 292 resolved references after the class is linked.\n-  void patch_resolved_references(GrowableArray<Handle>* cp_patches);\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,18 +52,0 @@\n-inline bool ConstantPool::is_pseudo_string_at(int which) {\n-  assert(tag_at(which).is_string(), \"Corrupted constant pool\");\n-  return slot_at(which).is_pseudo_string();\n-}\n-\n-inline oop ConstantPool::pseudo_string_at(int which, int obj_index) {\n-  assert(is_pseudo_string_at(which), \"must be a pseudo-string\");\n-  oop s = resolved_references()->obj_at(obj_index);\n-  return s;\n-}\n-\n-inline oop ConstantPool::pseudo_string_at(int which) {\n-  assert(is_pseudo_string_at(which), \"must be a pseudo-string\");\n-  int obj_index = cp_to_object_index(which);\n-  oop s = resolved_references()->obj_at(obj_index);\n-  return s;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  \/\/ The InstanceClassLoaderKlass iterators also visit the CLD pointer (or mirror of anonymous klasses.)\n+  \/\/ The InstanceClassLoaderKlass iterators also visit the CLD pointer (or mirror of hidden klasses.)\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,1 +464,0 @@\n-  bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();\n@@ -468,2 +467,1 @@\n-                                       parser.is_interface(),\n-                                       parser.is_unsafe_anonymous());\n+                                       parser.is_interface());\n@@ -545,1 +543,0 @@\n-  set_is_unsafe_anonymous(parser.is_unsafe_anonymous());\n@@ -2718,7 +2715,0 @@\n-  \/\/ If this is an unsafe anonymous class, append a hash to make the name unique\n-  if (is_unsafe_anonymous()) {\n-    intptr_t hash = (java_mirror() != NULL) ? java_mirror()->identity_hash() : 0;\n-    jio_snprintf(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, (uintx)hash);\n-    hash_len = (int)strlen(hash_buf);\n-  }\n-\n@@ -2761,6 +2751,0 @@\n-  \/\/ For an unsafe anonymous class return the host class' module\n-  if (is_unsafe_anonymous()) {\n-    assert(unsafe_anonymous_host() != NULL, \"unsafe anonymous class must have a host class\");\n-    return unsafe_anonymous_host()->module();\n-  }\n-\n@@ -3035,1 +3019,1 @@\n-      \/\/ It may be a local or anonymous class; try for that.\n+      \/\/ It may be a local class; try for that.\n@@ -3410,1 +3394,0 @@\n-  st->print(BULLET\"unsafe anonymous host class:        \"); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st->cr();\n@@ -3836,4 +3819,0 @@\n-  const Klass* anonymous_host = unsafe_anonymous_host();\n-  if (anonymous_host != NULL) {\n-    guarantee(anonymous_host->is_klass(), \"should be klass\");\n-  }\n@@ -4171,1 +4150,1 @@\n-  if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+  if (is_hidden()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-\/\/    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)\n@@ -251,1 +250,1 @@\n-    _misc_is_unsafe_anonymous                 = 1 << 3,  \/\/ has embedded _unsafe_anonymous_host field\n+    _misc_unused                              = 1 << 3,  \/\/ not currently used\n@@ -332,7 +331,0 @@\n-  \/\/ embedded unsafe_anonymous_host klass follows here\n-  \/\/   The embedded host klass only exists in an unsafe anonymous class for\n-  \/\/   dynamic language support (JSR 292 enabled). The host class grants\n-  \/\/   its access privileges to this class also. The host class is either\n-  \/\/   named, or a previously loaded unsafe anonymous class. A non-anonymous class\n-  \/\/   or an anonymous class loaded through normal classloading does not\n-  \/\/   have this embedded field.\n@@ -689,14 +681,0 @@\n-  \/\/ host class\n-  inline InstanceKlass* unsafe_anonymous_host() const;\n-  inline void set_unsafe_anonymous_host(const InstanceKlass* host);\n-  bool is_unsafe_anonymous() const                {\n-    return (_misc_flags & _misc_is_unsafe_anonymous) != 0;\n-  }\n-  void set_is_unsafe_anonymous(bool value)        {\n-    if (value) {\n-      _misc_flags |= _misc_is_unsafe_anonymous;\n-    } else {\n-      _misc_flags &= ~_misc_is_unsafe_anonymous;\n-    }\n-  }\n-\n@@ -1047,1 +1025,1 @@\n-                  bool is_interface, bool is_unsafe_anonymous) {\n+                  bool is_interface) {\n@@ -1052,2 +1030,1 @@\n-           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0) +\n-           (is_unsafe_anonymous ? (int)sizeof(Klass*)\/wordSize : 0));\n+           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0));\n@@ -1055,0 +1032,1 @@\n+\n@@ -1058,2 +1036,1 @@\n-                                               is_interface(),\n-                                               is_unsafe_anonymous());\n+                                               is_interface());\n@@ -1062,0 +1039,1 @@\n+\n@@ -1071,1 +1049,0 @@\n-  inline InstanceKlass** adr_unsafe_anonymous_host() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,21 +40,0 @@\n-inline InstanceKlass* InstanceKlass::unsafe_anonymous_host() const {\n-  InstanceKlass** hk = adr_unsafe_anonymous_host();\n-  if (hk == NULL) {\n-    assert(!is_unsafe_anonymous(), \"Unsafe anonymous classes have host klasses\");\n-    return NULL;\n-  } else {\n-    assert(*hk != NULL, \"host klass should always be set if the address is not null\");\n-    assert(is_unsafe_anonymous(), \"Only unsafe anonymous classes have host klasses\");\n-    return *hk;\n-  }\n-}\n-\n-inline void InstanceKlass::set_unsafe_anonymous_host(const InstanceKlass* host) {\n-  assert(is_unsafe_anonymous(), \"not unsafe anonymous\");\n-  const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();\n-  assert(addr != NULL, \"no reversed space\");\n-  if (addr != NULL) {\n-    *addr = host;\n-  }\n-}\n-\n@@ -85,13 +64,0 @@\n-inline InstanceKlass** InstanceKlass::adr_unsafe_anonymous_host() const {\n-  if (is_unsafe_anonymous()) {\n-    InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();\n-    if (adr_impl != NULL) {\n-      return adr_impl + 1;\n-    } else {\n-      return (InstanceKlass **)end_of_nonstatic_oop_maps();\n-    }\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        \/\/ A non-strong hidden class or an unsafe anonymous class doesn't have its own class loader,\n+        \/\/ A non-strong hidden class doesn't have its own class loader,\n@@ -65,1 +65,1 @@\n-        \/\/ For non-anonymous classes the call to do_cld is made when the class\n+        \/\/ For non-strong hidden classes the call to do_cld is made when the class\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -680,13 +680,1 @@\n-    if (ik->is_unsafe_anonymous()) {\n-      char addr_buf[20];\n-      jio_snprintf(addr_buf, 20, \"\/\" INTPTR_FORMAT, p2i(ik));\n-      size_t addr_len = strlen(addr_buf);\n-      size_t name_len = name()->utf8_length();\n-      char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);\n-      name()->as_klass_external_name(result, (int) name_len + 1);\n-      assert(strlen(result) == name_len, \"\");\n-      strcpy(result + name_len, addr_buf);\n-      assert(strlen(result) == name_len + addr_len, \"\");\n-      return result;\n-\n-    } else if (ik->is_hidden()) {\n+    if (ik->is_hidden()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-\/\/ Iff the class loader (or mirror for unsafe anonymous classes) is alive the\n+\/\/ Iff the class loader (or mirror for non-strong hidden classes) is alive the\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,3 +565,1 @@\n-    ciInstanceKlass* sender_klass =\n-        calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                               calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -962,2 +962,0 @@\n-                          NULL, \/\/ unsafe_anonymous_host\n-                          NULL, \/\/ cp_patches\n@@ -1442,1 +1440,1 @@\n-  if (!inner_is_member)  return NULL;     \/\/ a hidden or unsafe anonymous class (inside a method)\n+  if (!inner_is_member)  return NULL;     \/\/ a hidden class (inside a method)\n@@ -3535,2 +3533,2 @@\n-  if (caller_ik->is_hidden() || caller_ik->is_unsafe_anonymous()) {\n-    \/\/ VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.\n+  if (caller_ik->is_hidden()) {\n+    \/\/ Hidden classes not of type lambda proxy classes are currently not being archived.\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    \/\/ classes for primitives, arrays, hidden and vm unsafe anonymous classes\n+    \/\/ classes for primitives, arrays, and hidden classes\n@@ -336,3 +336,2 @@\n-  \/\/ Cannot redefine or retransform a hidden or an unsafe anonymous class.\n-  if (InstanceKlass::cast(k)->is_hidden() ||\n-      InstanceKlass::cast(k)->is_unsafe_anonymous()) {\n+  \/\/ Cannot redefine or retransform a hidden class.\n+  if (InstanceKlass::cast(k)->is_hidden()) {\n@@ -2942,1 +2941,0 @@\n-    \/\/       (including the direct superclass of an unsafe anonymous class declaration),\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -282,2 +282,0 @@\n-    if (old_cp->is_pseudo_string_at(cpi_old) || new_cp->is_pseudo_string_at(cpi_new))\n-      return (old_cp->is_pseudo_string_at(cpi_old) == new_cp->is_pseudo_string_at(cpi_new));\n","filename":"src\/hotspot\/share\/prims\/methodComparator.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -730,174 +730,0 @@\n-\/\/ define a class but do not make it known to the class loader or system dictionary\n-\/\/ - host_class:  supplies context for linkage, access control, protection domain, and class loader\n-\/\/                if host_class is itself anonymous then it is replaced with its host class.\n-\/\/ - data:  bytes of a class file, a raw memory address (length gives the number of bytes)\n-\/\/ - cp_patches:  where non-null entries exist, they replace corresponding CP entries in data\n-\n-\/\/ When you load an anonymous class U, it works as if you changed its name just before loading,\n-\/\/ to a name that you will never use again.  Since the name is lost, no other class can directly\n-\/\/ link to any member of U.  Just after U is loaded, the only way to use it is reflectively,\n-\/\/ through java.lang.Class methods like Class.newInstance.\n-\n-\/\/ The package of an anonymous class must either match its host's class's package or be in the\n-\/\/ unnamed package.  If it is in the unnamed package then it will be put in its host class's\n-\/\/ package.\n-\/\/\n-\n-\/\/ Access checks for linkage sites within U continue to follow the same rules as for named classes.\n-\/\/ An anonymous class also has special privileges to access any member of its host class.\n-\/\/ This is the main reason why this loading operation is unsafe.  The purpose of this is to\n-\/\/ allow language implementations to simulate \"open classes\"; a host class in effect gets\n-\/\/ new code when an anonymous class is loaded alongside it.  A less convenient but more\n-\/\/ standard way to do this is with reflection, which can also be set to ignore access\n-\/\/ restrictions.\n-\n-\/\/ Access into an anonymous class is possible only through reflection.  Therefore, there\n-\/\/ are no special access rules for calling into an anonymous class.  The relaxed access\n-\/\/ rule for the host class is applied in the opposite direction:  A host class reflectively\n-\/\/ access one of its anonymous classes.\n-\n-\/\/ If you load the same bytecodes twice, you get two different classes.  You can reload\n-\/\/ the same bytecodes with or without varying CP patches.\n-\n-\/\/ By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.\n-\/\/ The bytecodes for U2 should refer to U1 by a symbolic name (doesn't matter what the name is).\n-\/\/ The CONSTANT_Class entry for that name can be patched to refer directly to U1.\n-\n-\/\/ This allows, for example, U2 to use U1 as a superclass or super-interface, or as\n-\/\/ an outer class (so that U2 is an anonymous inner class of anonymous U1).\n-\/\/ It is not possible for a named class, or an older anonymous class, to refer by\n-\/\/ name (via its CP) to a newer anonymous class.\n-\n-\/\/ CP patching may also be used to modify (i.e., hack) the names of methods, classes,\n-\/\/ or type descriptors used in the loaded anonymous class.\n-\n-\/\/ Finally, CP patching may be used to introduce \"live\" objects into the constant pool,\n-\/\/ instead of \"dead\" strings.  A compiled statement like println((Object)\"hello\") can\n-\/\/ be changed to println(greeting), where greeting is an arbitrary object created before\n-\/\/ the anonymous class is loaded.  This is useful in dynamic languages, in which\n-\/\/ various kinds of metaobjects must be introduced as constants into bytecode.\n-\/\/ Note the cast (Object), which tells the verifier to expect an arbitrary object,\n-\/\/ not just a literal string.  For such ldc instructions, the verifier uses the\n-\/\/ type Object instead of String, if the loaded constant is not in fact a String.\n-\n-static InstanceKlass*\n-Unsafe_DefineAnonymousClass_impl(JNIEnv *env,\n-                                 jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,\n-                                 u1** temp_alloc,\n-                                 TRAPS) {\n-  assert(host_class != NULL, \"host_class must not be NULL\");\n-  assert(data != NULL, \"data must not be NULL\");\n-\n-  if (UsePerfData) {\n-    ClassLoader::unsafe_defineClassCallCounter()->inc();\n-  }\n-\n-  jint length = typeArrayOop(JNIHandles::resolve_non_null(data))->length();\n-  assert(length >= 0, \"class_bytes_length must not be negative: %d\", length);\n-\n-  int class_bytes_length = (int) length;\n-\n-  u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);\n-  if (class_bytes == NULL) {\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  \/\/ caller responsible to free it:\n-  *temp_alloc = class_bytes;\n-\n-  ArrayAccess<>::arraycopy_to_native(arrayOop(JNIHandles::resolve_non_null(data)), typeArrayOopDesc::element_offset<jbyte>(0),\n-                                     reinterpret_cast<jbyte*>(class_bytes), length);\n-\n-  objArrayHandle cp_patches_h;\n-  if (cp_patches_jh != NULL) {\n-    oop p = JNIHandles::resolve_non_null(cp_patches_jh);\n-    assert(p->is_objArray(), \"cp_patches must be an object[]\");\n-    cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);\n-  }\n-\n-  const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));\n-\n-  \/\/ Make sure it's the real host class, not another anonymous class.\n-  while (host_klass != NULL && host_klass->is_instance_klass() &&\n-         InstanceKlass::cast(host_klass)->is_unsafe_anonymous()) {\n-    host_klass = InstanceKlass::cast(host_klass)->unsafe_anonymous_host();\n-  }\n-\n-  \/\/ Primitive types have NULL Klass* fields in their java.lang.Class instances.\n-  if (host_klass == NULL) {\n-    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Host class is null\");\n-  }\n-\n-  assert(host_klass->is_instance_klass(), \"Host class must be an instance class\");\n-\n-  const char* host_source = host_klass->external_name();\n-  Handle      host_loader(THREAD, host_klass->class_loader());\n-  Handle      host_domain(THREAD, host_klass->protection_domain());\n-\n-  GrowableArray<Handle>* cp_patches = NULL;\n-\n-  if (cp_patches_h.not_null()) {\n-    int alen = cp_patches_h->length();\n-\n-    for (int i = alen-1; i >= 0; i--) {\n-      oop p = cp_patches_h->obj_at(i);\n-      if (p != NULL) {\n-        Handle patch(THREAD, p);\n-\n-        if (cp_patches == NULL) {\n-          cp_patches = new GrowableArray<Handle>(i+1, i+1, Handle());\n-        }\n-\n-        cp_patches->at_put(i, patch);\n-      }\n-    }\n-  }\n-\n-  ClassFileStream st(class_bytes, class_bytes_length, host_source, ClassFileStream::verify);\n-\n-  Symbol* no_class_name = NULL;\n-  ClassLoadInfo cl_info(host_domain,\n-                        InstanceKlass::cast(host_klass),\n-                        cp_patches,\n-                        NULL,     \/\/ dynamic_nest_host\n-                        Handle(), \/\/ classData\n-                        false,    \/\/ is_hidden\n-                        false,    \/\/ is_strong_hidden\n-                        true);    \/\/ can_access_vm_annotations\n-\n-  InstanceKlass* anonk = SystemDictionary::resolve_from_stream(&st, no_class_name,\n-                                                               host_loader,\n-                                                               cl_info,\n-                                                               CHECK_NULL);\n-  assert(anonk != NULL, \"no klass created\");\n-  return anonk;\n-}\n-\n-UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {\n-  ResourceMark rm(THREAD);\n-\n-  jobject res_jh = NULL;\n-  u1* temp_alloc = NULL;\n-\n-  InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &temp_alloc, THREAD);\n-  if (anon_klass != NULL) {\n-    res_jh = JNIHandles::make_local(THREAD, anon_klass->java_mirror());\n-  }\n-\n-  \/\/ try\/finally clause:\n-  FREE_C_HEAP_ARRAY(u1, temp_alloc);\n-\n-  \/\/ The anonymous class loader data has been artificially been kept alive to\n-  \/\/ this point.   The mirror and any instances of this class have to keep\n-  \/\/ it alive afterwards.\n-  if (anon_klass != NULL) {\n-    anon_klass->class_loader_data()->dec_keep_alive();\n-  }\n-\n-  \/\/ let caller initialize it as needed...\n-\n-  return (jclass) res_jh;\n-} UNSAFE_END\n-\n-\n-\n@@ -1123,2 +949,0 @@\n-    {CC \"defineAnonymousClass0\", CC \"(\" DAC_Args \")\" CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},\n-\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":176,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -398,15 +398,0 @@\n-static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {\n-  DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);\n-  for (;;) {\n-    const InstanceKlass* hc = ik->unsafe_anonymous_host();\n-    if (hc == NULL)        return false;\n-    if (hc == unsafe_anonymous_host)  return true;\n-    ik = hc;\n-\n-    \/\/ There's no way to make a host class loop short of patching memory.\n-    \/\/ Therefore there cannot be a loop here unless there's another bug.\n-    \/\/ Still, let's check for it.\n-    assert(--inf_loop_check > 0, \"no unsafe_anonymous_host loop\");\n-  }\n-}\n-\n@@ -420,6 +405,0 @@\n-  \/\/ If either is on the other's unsafe_anonymous_host chain, access is OK,\n-  \/\/ because one is inside the other.\n-  if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||\n-    under_unsafe_anonymous_host(accessee_ik, accessor_ik))\n-    return true;\n-\n@@ -648,10 +627,1 @@\n-  const Klass* host_class = current_class;\n-  if (current_class->is_instance_klass() &&\n-      InstanceKlass::cast(current_class)->is_unsafe_anonymous()) {\n-    host_class = InstanceKlass::cast(current_class)->unsafe_anonymous_host();\n-    assert(host_class != NULL, \"Unsafe anonymous class has null host class\");\n-    assert(!(host_class->is_instance_klass() &&\n-           InstanceKlass::cast(host_class)->is_unsafe_anonymous()),\n-           \"unsafe_anonymous_host should not be unsafe anonymous itself\");\n-  }\n-  if (host_class == member_class) {\n+  if (current_class == member_class) {\n@@ -665,1 +635,1 @@\n-      if (!host_class->is_interface() && host_class->is_subclass_of(member_class)) {\n+      if (!current_class->is_interface() && current_class->is_subclass_of(member_class)) {\n@@ -669,2 +639,2 @@\n-            host_class->is_subclass_of(resolved_class) ||\n-            resolved_class->is_subclass_of(host_class)) {\n+            current_class->is_subclass_of(resolved_class) ||\n+            resolved_class->is_subclass_of(current_class)) {\n@@ -682,3 +652,2 @@\n-  \/\/ private access between different classes needs a nestmate check, but\n-  \/\/ not for unsafe anonymous classes - so check host_class\n-  if (access.is_private() && host_class == current_class) {\n+  \/\/ private access between different classes needs a nestmate check.\n+  if (access.is_private()) {\n@@ -715,1 +684,1 @@\n-\/\/ If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).\n+\/\/ If !inner_is_member, require the inner to be hidden (non-member).\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":7,"deletions":38,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2299,1 +2299,0 @@\n-  declare_constant(InstanceKlass::_misc_is_unsafe_anonymous)              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1015,2 +1015,0 @@\n-        if (ReflectUtil.isVMAnonymousClass(cls))   \/\/ FIXME: Unsafe::defineAnonymousClass to be removed\n-            return false;\n@@ -1048,2 +1046,0 @@\n-        if (ReflectUtil.isVMAnonymousClass(cls))   \/\/ FIXME: Unsafe::defineAnonymousClass to be removed\n-            return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1332,28 +1332,0 @@\n-    \/**\n-     * Defines a class but does not make it known to the class loader or system dictionary.\n-     * <p>\n-     * For each CP entry, the corresponding CP patch must either be null or have\n-     * the a format that matches its tag:\n-     * <ul>\n-     * <li>Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n-     * <li>Utf8: a string (must have suitable syntax if used as signature or name)\n-     * <li>Class: any java.lang.Class object\n-     * <li>String: any object (not just a java.lang.String)\n-     * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n-     * <\/ul>\n-     * @param hostClass context for linkage, access control, protection domain, and class loader\n-     * @param data      bytes of a class file\n-     * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data\n-     *\/\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {\n-        if (hostClass == null || data == null) {\n-            throw new NullPointerException();\n-        }\n-        if (hostClass.isArray() || hostClass.isPrimitive()) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return defineAnonymousClass0(hostClass, data, cpPatches);\n-    }\n-\n@@ -3858,1 +3830,0 @@\n-    private native Class<?> defineAnonymousClass0(Class<?> hostClass, byte[] data, Object[] cpPatches);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-                && !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeConstructorAccessorImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeMethodAccessorImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,2 +205,1 @@\n-        if (noInflation && !method.getDeclaringClass().isHidden()\n-                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {\n+        if (noInflation && !method.getDeclaringClass().isHidden()) {\n@@ -250,2 +249,1 @@\n-        if (noInflation && !c.getDeclaringClass().isHidden()\n-                && !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) {\n+        if (noInflation && !c.getDeclaringClass().isHidden()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -315,8 +315,0 @@\n-    \/**\n-     * Checks if {@code Class cls} is a VM-anonymous class\n-     * as defined by {@link jdk.internal.misc.Unsafe#defineAnonymousClass}\n-     * (not to be confused with a Java Language anonymous inner class).\n-     *\/\n-    public static boolean isVMAnonymousClass(Class<?> cls) {\n-        return cls.getName().indexOf('\/') > -1;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  private static int MISC_IS_UNSAFE_ANONYMOUS;\n@@ -131,1 +130,0 @@\n-    MISC_IS_UNSAFE_ANONYMOUS          = db.lookupIntConstant(\"InstanceKlass::_misc_is_unsafe_anonymous\").intValue();\n@@ -286,3 +284,0 @@\n-    if (isUnsafeAnonymous()) {\n-      size += wordLength;\n-    }\n@@ -296,4 +291,0 @@\n-  public boolean isUnsafeAnonymous() {\n-    return (getMiscFlags() & MISC_IS_UNSAFE_ANONYMOUS) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -726,5 +726,0 @@\n-    \/**\n-     * Gets the host class for {@code type}.\n-     *\/\n-    native HotSpotResolvedObjectTypeImpl getHostClass(HotSpotResolvedObjectTypeImpl type);\n-\n@@ -742,1 +737,1 @@\n-     * Get the array class for {@code type}. This can't be done symbolically since anonymous types\n+     * Get the array class for {@code type}. This can't be done symbolically since hidden classes\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,17 +111,0 @@\n-    \/**\n-     * Checks whether this type is an unsafe anonymous class.\n-     *\n-     * @return {@code true} if this type is an unsafe anonymous class\n-     *\/\n-    boolean isUnsafeAnonymous();\n-\n-    \/**\n-     * Checks whether this type is an unsafe anonymous class.\n-     * This method is here to maintain compatibility with JDK11.\n-     *\n-     * @return {@code true} if this type is an unsafe anonymous class\n-     *\/\n-    default boolean isAnonymous() {\n-      return isUnsafeAnonymous();\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectType.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,8 +451,0 @@\n-    @Override\n-    public ResolvedJavaType getHostClass() {\n-        if (isArray()) {\n-            return null;\n-        }\n-        return compilerToVM().getHostClass(this);\n-    }\n-\n@@ -1043,5 +1035,0 @@\n-    @Override\n-    public boolean isUnsafeAnonymous() {\n-        return (getMiscFlags() & config().instanceKlassMiscIsUnsafeAnonymous) != 0;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,5 +182,0 @@\n-    @Override\n-    public ResolvedJavaType getHostClass() {\n-        return null;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-    final int instanceKlassMiscIsUnsafeAnonymous = getConstant(\"InstanceKlass::_misc_is_unsafe_anonymous\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,7 +139,0 @@\n-    \/**\n-     * Returns the {@link ResolvedJavaType} object representing the host class of this VM anonymous\n-     * class (as opposed to the unrelated concept specified by {@link Class#isAnonymousClass()}) or\n-     * {@code null} if this object does not represent a VM anonymous class.\n-     *\/\n-    ResolvedJavaType getHostClass();\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-            \/\/ instead of the individual objects. (This anonymous class has always the same meaning)\n+            \/\/ instead of the individual objects.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/Value.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -857,28 +857,0 @@\n-    \/**\n-     * Defines a class but does not make it known to the class loader or system dictionary.\n-     * <p>\n-     * For each CP entry, the corresponding CP patch must either be null or have\n-     * the a format that matches its tag:\n-     * <ul>\n-     * <li>Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n-     * <li>Utf8: a string (must have suitable syntax if used as signature or name)\n-     * <li>Class: any java.lang.Class object\n-     * <li>String: any object (not just a java.lang.String)\n-     * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n-     * <\/ul>\n-     *\n-     * @deprecated Use {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n-     * or {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}\n-     * instead.\n-     *\n-     * @param hostClass context for linkage, access control, protection domain, and class loader\n-     * @param data      bytes of a class file\n-     * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data\n-     *\/\n-    @ForceInline\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    @SuppressWarnings(\"removal\")\n-    public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {\n-        return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);\n-    }\n-\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8054402\n- * @summary \"Tests unloading of anonymous classes.\"\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      -XX:-BackgroundCompilation\n- *      compiler.classUnloading.anonymousClass.TestAnonymousClassUnloading\n- *\/\n-\n-package compiler.classUnloading.anonymousClass;\n-\n-import jdk.internal.misc.Unsafe;\n-import sun.hotspot.WhiteBox;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import compiler.whitebox.CompilerWhiteBoxTest;\n-\n-public class TestAnonymousClassUnloading {\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/**\n-     * We override hashCode here to be able to access this implementation\n-     * via an Object reference (we cannot cast to TestAnonymousClassUnloading).\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return 42;\n-    }\n-\n-    \/**\n-     * Does some work by using the anonymousClass.\n-     * @param anonymousClass Class performing some work (will be unloaded)\n-     *\/\n-    static private void doWork(Class<?> anonymousClass) throws InstantiationException, IllegalAccessException {\n-        \/\/ Create a new instance\n-        Object anon = anonymousClass.newInstance();\n-        \/\/ We would like to call a method of anonymousClass here but we cannot cast because the class\n-        \/\/ was loaded by a different class loader. One solution would be to use reflection but since\n-        \/\/ we want C2 to implement the call as an IC we call Object::hashCode() here which actually\n-        \/\/ calls anonymousClass::hashCode(). C2 will then implement this call as an IC.\n-        if (anon.hashCode() != 42) {\n-            new RuntimeException(\"Work not done\");\n-        }\n-    }\n-\n-    \/**\n-     * Makes sure that method is compiled by forcing compilation if not yet compiled.\n-     * @param m Method to be checked\n-     *\/\n-    static private void makeSureIsCompiled(Method m) {\n-        \/\/ Make sure background compilation is disabled\n-        if (WHITE_BOX.getBooleanVMFlag(\"BackgroundCompilation\")) {\n-            throw new RuntimeException(\"Background compilation enabled\");\n-        }\n-\n-        \/\/ Check if already compiled\n-        if (!WHITE_BOX.isMethodCompiled(m)) {\n-            \/\/ If not, try to compile it with C2\n-            if(!WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION)) {\n-                \/\/ C2 compiler not available, try to compile with C1\n-                WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);\n-            }\n-            \/\/ Because background compilation is disabled, method should now be compiled\n-            if(!WHITE_BOX.isMethodCompiled(m)) {\n-                throw new RuntimeException(m + \" not compiled\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * This test creates stale Klass* metadata referenced by a compiled IC.\n-     *\n-     * The following steps are performed:\n-     * (1) An anonymous version of TestAnonymousClassUnloading is loaded by a custom class loader\n-     * (2) The method doWork that calls a method of the anonymous class is compiled. The call\n-     *     is implemented as an IC referencing Klass* metadata of the anonymous class.\n-     * (3) Unloading of the anonymous class is enforced. The IC now references dead metadata.\n-     *\/\n-    static public void main(String[] args) throws Exception {\n-        \/\/ (1) Load an anonymous version of this class using the corresponding Unsafe method\n-        String rn = TestAnonymousClassUnloading.class.getSimpleName() + \".class\";\n-        URL classUrl = TestAnonymousClassUnloading.class.getResource(rn);\n-        URLConnection connection = classUrl.openConnection();\n-\n-        int length = connection.getContentLength();\n-        byte[] classBytes = connection.getInputStream().readAllBytes();\n-        if (length != -1 && classBytes.length != length) {\n-            throw new IOException(\"Expected:\" + length + \", actual: \" + classBytes.length);\n-        }\n-\n-        Class<?> anonymousClass = UNSAFE.defineAnonymousClass(TestAnonymousClassUnloading.class, classBytes, null);\n-\n-        \/\/ (2) Make sure all paths of doWork are profiled and compiled\n-        for (int i = 0; i < 100000; ++i) {\n-            doWork(anonymousClass);\n-        }\n-\n-        \/\/ Make sure doWork is compiled now\n-        Method doWork = TestAnonymousClassUnloading.class.getDeclaredMethod(\"doWork\", Class.class);\n-        makeSureIsCompiled(doWork);\n-\n-        \/\/ (3) Throw away reference to anonymousClass to allow unloading\n-        anonymousClass = null;\n-\n-        \/\/ Force garbage collection to trigger unloading of anonymousClass\n-        \/\/ Dead metadata reference to anonymousClass triggers JDK-8054402\n-        WHITE_BOX.fullGC();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/classUnloading\/anonymousClass\/TestAnonymousClassUnloading.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -50,0 +49,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -64,1 +64,0 @@\n-    static final Unsafe               UNSAFE = Unsafe.getUnsafe();\n@@ -133,2 +132,3 @@\n-        Class<?> cls1 = UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"CS_1\"), null);\n-        Class<?> cls2 = UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"CS_2\"), null);\n+        Lookup lookup = MethodHandles.lookup();\n+        Class<?> cls1 = lookup.defineHiddenClass(getClassFile(\"CS_1\"), true).lookupClass();\n+        Class<?> cls2 = lookup.defineHiddenClass(getClassFile(\"CS_2\"), true).lookupClass();\n@@ -155,1 +155,2 @@\n-        Class<?> cls1 = UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"NonBound_1\"), null);\n+        Lookup lookup = MethodHandles.lookup();\n+        Class<?> cls1 = lookup.defineHiddenClass(getClassFile(\"NonBound_1\"), true).lookupClass();\n@@ -173,0 +174,1 @@\n+        Lookup lookup = MethodHandles.lookup();\n@@ -174,2 +176,2 @@\n-                UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"GC_1\" + id), null),\n-                UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"GC_2\" + id), null),\n+            lookup.defineHiddenClass(getClassFile(\"GC_1\"), true).lookupClass(),\n+            lookup.defineHiddenClass(getClassFile(\"GC_2\"), true).lookupClass(),\n@@ -189,1 +191,1 @@\n-        cls[0] = UNSAFE.defineAnonymousClass(CallSiteDepContextTest.class, getClassFile(\"GC_3\" + id), null);\n+        cls[0] = lookup.defineHiddenClass(getClassFile(\"GC_3\"), true).lookupClass();\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/CallSiteDepContextTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8058828\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- *\n- * @run main\/bootclasspath\/othervm -Xbatch compiler.jsr292.VMAnonymousClasses\n- *\/\n-\n-package compiler.jsr292;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-\n-import java.lang.invoke.ConstantCallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.MutableCallSite;\n-import java.lang.invoke.VolatileCallSite;\n-\n-public class VMAnonymousClasses {\n-    static final String TEST_METHOD_NAME = \"constant\";\n-\n-    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static int getConstantPoolSize(byte[] classFile) {\n-        \/\/ The first few bytes:\n-        \/\/ u4 magic;\n-        \/\/ u2 minor_version;\n-        \/\/ u2 major_version;\n-        \/\/ u2 constant_pool_count;\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n-    static void test(Object value) throws ReflectiveOperationException {\n-        System.out.printf(\"Test: %s\", value != null ? value.getClass() : \"null\");\n-\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER, \"Test\", null, \"java\/lang\/Object\", null);\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, TEST_METHOD_NAME, \"()Ljava\/lang\/Object;\", null, null);\n-\n-        String placeholder = \"CONSTANT\";\n-        int index = cw.newConst(placeholder);\n-        mv.visitLdcInsn(placeholder);\n-        mv.visitInsn(Opcodes.ARETURN);\n-\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        byte[] classFile = cw.toByteArray();\n-\n-        Object[] cpPatches = new Object[getConstantPoolSize(classFile)];\n-        cpPatches[index] = value;\n-\n-        Class<?> test = UNSAFE.defineAnonymousClass(VMAnonymousClasses.class, classFile, cpPatches);\n-\n-        Object expectedResult = (value != null) ? value : placeholder;\n-        for (int i = 0; i<15000; i++) {\n-            Object result = test.getMethod(TEST_METHOD_NAME).invoke(null);\n-            if (result != expectedResult) {\n-                throw new AssertionError(String.format(\"Wrong value returned: %s != %s\", value, result));\n-            }\n-        }\n-        System.out.println(\" PASSED\");\n-    }\n-\n-    public static void main(String[] args) throws ReflectiveOperationException  {\n-        \/\/ Objects\n-        test(new Object());\n-        test(\"TEST\");\n-        test(new VMAnonymousClasses());\n-        test(null);\n-\n-        \/\/ Class\n-        test(String.class);\n-\n-        \/\/ Arrays\n-        test(new boolean[0]);\n-        test(new byte[0]);\n-        test(new char[0]);\n-        test(new short[0]);\n-        test(new int[0]);\n-        test(new long[0]);\n-        test(new float[0]);\n-        test(new double[0]);\n-        test(new Object[0]);\n-\n-        \/\/ Multi-dimensional arrays\n-        test(new byte[0][0]);\n-        test(new Object[0][0]);\n-\n-        \/\/ MethodHandle-related\n-        MethodType   mt = MethodType.methodType(void.class, String[].class);\n-        MethodHandle mh = MethodHandles.lookup().findStatic(VMAnonymousClasses.class, \"main\", mt);\n-        test(mt);\n-        test(mh);\n-        test(new ConstantCallSite(mh));\n-        test(new MutableCallSite(MethodType.methodType(void.class)));\n-        test(new VolatileCallSite(MethodType.methodType(void.class)));\n-\n-        System.out.println(\"TEST PASSED\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/VMAnonymousClasses.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -87,4 +87,0 @@\n-    private static boolean isUnsafeAnonymous(ResolvedJavaType type) {\n-        return type.getHostClass() != null;\n-    }\n-\n@@ -96,1 +92,1 @@\n-            if (!isHiddenClass(c) && !isUnsafeAnonymous(type)) {\n+            if (!isHiddenClass(c)) {\n@@ -117,1 +113,1 @@\n-            if (!isHiddenClass(aClass) && !isUnsafeAnonymous(result[counter])) {\n+            if (!isHiddenClass(aClass)) {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestMetaAccessProvider.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,39 +165,0 @@\n-    private static Class<?> anonClass() throws Exception {\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, \"Anon\", null, \"java\/lang\/Object\", null);\n-        FieldVisitor intField = cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"intField\", \"I\", null, 0);\n-        intField.visitEnd();\n-        cw.visitEnd();\n-        return unsafe.defineAnonymousClass(TypeUniverse.class, cw.toByteArray(), null);\n-    }\n-\n-    @Test\n-    public void getHostClassTest() throws Exception {\n-        ResolvedJavaType type = metaAccess.lookupJavaType(anonClass());\n-        ResolvedJavaType host = type.getHostClass();\n-        assertNotNull(host);\n-        for (Class<?> c : classes) {\n-            type = metaAccess.lookupJavaType(c);\n-            host = type.getHostClass();\n-            assertNull(host);\n-            if (type.equals(predicateType)) {\n-                assertTrue(c.isHidden());\n-            }\n-        }\n-\n-        class LocalClass {\n-        }\n-        Cloneable clone = new Cloneable() {\n-        };\n-        assertNull(metaAccess.lookupJavaType(LocalClass.class).getHostClass());\n-        assertNull(metaAccess.lookupJavaType(clone.getClass()).getHostClass());\n-\n-        Supplier<Runnable> lambda = () -> () -> System.out.println(\"run\");\n-        ResolvedJavaType lambdaType = metaAccess.lookupJavaType(lambda.getClass());\n-        ResolvedJavaType nestedLambdaType = metaAccess.lookupJavaType(lambda.get().getClass());\n-        assertNull(lambdaType.getHostClass());\n-        assertTrue(lambda.getClass().isHidden());\n-        assertNull(nestedLambdaType.getHostClass());\n-        assertTrue(lambda.get().getClass().isHidden());\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8026365\n- * @summary Test invokespecial of host class method from an anonymous class\n- * @author  Robert Field\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile -XDignore.symbol.file InvokeSpecialAnonTest.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller InvokeSpecialAnonTest AnonTester\n- * @run main\/othervm -Xbootclasspath\/a:. -Xverify:all InvokeSpecialAnonTest\n- *\/\n-import jdk.internal.org.objectweb.asm.*;\n-import java.lang.reflect.Constructor;\n-import jdk.internal.misc.Unsafe;\n-\n-public class InvokeSpecialAnonTest implements Opcodes {\n-\n-    static byte[] anonClassBytes() throws Exception {\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(V1_8, ACC_FINAL + ACC_SUPER, \"Anon\", null, \"java\/lang\/Object\", null);\n-\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\");\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(2, 2);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"(LInvokeSpecialAnonTest;)I\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"InvokeSpecialAnonTest\", \"privMethod\", \"()I\");\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(2, 3);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-\n-        return cw.toByteArray();\n-    }\n-\n-    private int privMethod() { return 1234; }\n-\n-    public static void main(String[] args) throws Exception {\n-        Class<?> klass = InvokeSpecialAnonTest.class;\n-        try {\n-           Class<?> result = AnonTester.defineTest(klass, anonClassBytes());\n-           System.out.println(\"Passed.\");\n-        } catch (Exception e) {\n-           e.printStackTrace();\n-           throw e;\n-        }\n-    }\n-}\n-\n-\n-class AnonTester {\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    public static Class<?> defineTest(Class<?> targetClass, byte[] classBytes) throws Exception {\n-        return UNSAFE.defineAnonymousClass(targetClass, classBytes, null);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/8026365\/InvokeSpecialAnonTest.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,6 @@\n+ * DESCRIPTION\n+ *     Try to cast an object of a hidden class to its parent (called CastToParentTest)\n+ *         - (CastToParentTest) o\n+ *         - o.getClass().cast(<hiddenClassObj>);\n+ *     and cast to its grandparent (java.lang.Object).\n+ *\n@@ -38,1 +44,0 @@\n-\/\/ This test is based on vmTestbase\/vm\/mlvm\/anonloader\/func\/castToGrandparent\/Test.java\n@@ -61,0 +66,11 @@\n+\n+\n+        \/\/ Cast hidden class to its grandparent.\n+        java.lang.Object grandparentObj = (java.lang.Object)hiddenClassObj;\n+\n+        if (!grandparentObj.equals(hiddenClassObj)) {\n+            throw new RuntimeException(\"Hidden class object cannot be cast to grandparent\");\n+        }\n+\n+        \/\/ Try to cast using a different mechanism.\n+        new java.lang.Object().getClass().cast(hiddenClassObj);\n@@ -62,0 +78,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/CastToParentTest.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-\/\/ This test is based on test vmTestbase\/vm\/mlvm\/anonloader\/func\/isGarbageCollected\/Test.java\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/GCHiddenClass.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+ * DESCRIPTION\n+ *     An exception is thrown by a hidden class.  Verify that the exception's\n+ *     stack trace contains the name of the current test class (i.e., verify\n+ *     that the stack trace is not broken).\n@@ -41,1 +45,0 @@\n-\/\/ This test is based on vmTestbase\/vm\/mlvm\/anonloader\/func\/classNameInStackTrace\/Test.java\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/HiddenClassStack.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\/\/ This test is based on vmTestbase\/vm\/mlvm\/anonloader\/share\/StressClassLoadingTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/StressHiddenClasses.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\/\/ This is based on test compiler\/classUnloading\/anonymousClass\/TestAnonymousClassUnloading.java\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/TestHiddenClassUnloading.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Creates an anonymous class inside of an anonymous class.\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.management\n- * @run main NestedUnsafe\n- *\/\n-\n-import java.lang.*;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-import jdk.internal.misc.Unsafe;\n-\n-\/\/ package p;\n-\n-public class NestedUnsafe {\n-    \/\/ The String concatenation should create the nested anonymous class.\n-    static byte klassbuf[] = InMemoryJavaCompiler.compile(\"TestClass\",\n-        \"public class TestClass { \" +\n-        \"    public static void concat(String one, String two) throws Throwable { \" +\n-        \"        System.out.println(one + two);\" +\n-        \" } } \");\n-\n-    public static void main(String args[]) throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        Class klass = unsafe.defineAnonymousClass(NestedUnsafe.class, klassbuf, new Object[0]);\n-        unsafe.ensureClassInitialized(klass);\n-        Class[] cArgs = new Class[2];\n-        cArgs[0] = String.class;\n-        cArgs[1] = String.class;\n-        try {\n-            klass.getMethod(\"concat\", cArgs).invoke(null, \"AA\", \"BB\");\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"Exception: \" + ex.toString());\n-        }\n-\n-        \/\/ The anonymous class calls defineAnonymousClass creating a nested anonymous class.\n-        byte klassbuf2[] = InMemoryJavaCompiler.compile(\"TestClass2\",\n-            \"import jdk.internal.misc.Unsafe; \" +\n-            \"public class TestClass2 { \" +\n-            \"    public static void doit() throws Throwable { \" +\n-            \"        Unsafe unsafe = jdk.internal.misc.Unsafe.getUnsafe(); \" +\n-            \"        Class klass2 = unsafe.defineAnonymousClass(TestClass2.class, NestedUnsafe.klassbuf, new Object[0]); \" +\n-            \"        unsafe.ensureClassInitialized(klass2); \" +\n-            \"        Class[] dArgs = new Class[2]; \" +\n-            \"        dArgs[0] = String.class; \" +\n-            \"        dArgs[1] = String.class; \" +\n-            \"        try { \" +\n-            \"            klass2.getMethod(\\\"concat\\\", dArgs).invoke(null, \\\"CC\\\", \\\"DD\\\"); \" +\n-            \"        } catch (Throwable ex) { \" +\n-            \"            throw new RuntimeException(\\\"Exception: \\\" + ex.toString()); \" +\n-            \"        } \" +\n-            \"} } \",\n-            \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n-        Class klass2 = unsafe.defineAnonymousClass(NestedUnsafe.class, klassbuf2, new Object[0]);\n-        try {\n-            klass2.getMethod(\"doit\").invoke(null);\n-        } catch (Throwable ex) {\n-            throw new RuntimeException(\"Exception: \" + ex.toString());\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/NestedUnsafe.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Component;\n-import java.lang.reflect.Field;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-import jdk.internal.org.objectweb.asm.*;\n-import jdk.internal.misc.Unsafe;\n-\n-\/*\n- * @test PrimitiveHostClass\n- * @bug 8140665\n- * @summary Throws IllegalArgumentException if host class is a primitive class.\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @compile -XDignore.symbol.file PrimitiveHostClass.java\n- * @run main\/othervm PrimitiveHostClass\n- *\/\n-\n-public class PrimitiveHostClass {\n-\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n-    public static void testVMAnonymousClass(Class<?> hostClass) {\n-\n-        \/\/ choose a class name in the same package as the host class\n-        String prefix = packageName(hostClass);\n-        if (prefix.length() > 0)\n-            prefix = prefix.replace('.', '\/') + \"\/\";\n-        String className = prefix + \"Anon\";\n-\n-        \/\/ create the class\n-        String superName = \"java\/lang\/Object\";\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V1_8, ACC_PUBLIC + ACC_FINAL + ACC_SUPER,\n-                 className, null, superName, null);\n-        byte[] classBytes = cw.toByteArray();\n-        int cpPoolSize = constantPoolSize(classBytes);\n-        Class<?> anonClass =\n-            U.defineAnonymousClass(hostClass, classBytes, new Object[cpPoolSize]);\n-    }\n-\n-    private static String packageName(Class<?> c) {\n-        if (c.isArray()) {\n-            return packageName(c.getComponentType());\n-        } else {\n-            String name = c.getName();\n-            int dot = name.lastIndexOf('.');\n-            if (dot == -1) return \"\";\n-            return name.substring(0, dot);\n-        }\n-    }\n-\n-    private static int constantPoolSize(byte[] classFile) {\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n-    public static void main(String args[]) {\n-        testVMAnonymousClass(PrimitiveHostClass.class);\n-        try {\n-            testVMAnonymousClass(int.class);\n-            throw new RuntimeException(\n-                \"Expected IllegalArgumentException not thrown\");\n-        } catch (IllegalArgumentException e) {\n-            \/\/ Expected\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/PrimitiveHostClass.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary LambdaMetafactory does not support VM anonymous classes.\n- *          This is a sanity test to make sure CDS can handle this case and\n- *          the VM anonymous class should not be archived.\n- * @requires vm.cds\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n- * @modules java.base\/jdk.internal.misc\n- * @compile test-classes\/UnsafeAndLambdaApp.java\n- *          ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar unsafeandlambda.jar UnsafeAndLambdaApp\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$FileManagerWrapper$1\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$FileManagerWrapper\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$MemoryJavaFileObject\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. UnsafeAndLambda\n- *\/\n-\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class UnsafeAndLambda extends DynamicArchiveTestBase {\n-    public static void main(String[] args) throws Exception {\n-        runTest(UnsafeAndLambda::test);\n-    }\n-\n-    static void test() throws Exception {\n-        String topArchiveName = getNewArchiveName();\n-        String appJar = ClassFileInstaller.getJarPath(\"unsafeandlambda.jar\");\n-        String mainClass = \"UnsafeAndLambdaApp\";\n-\n-        dump(topArchiveName,\n-            \"-Xlog:class+load=debug,cds+dynamic,cds\",\n-            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-            \"-cp\", appJar, mainClass)\n-            .assertNormalExit(output -> {\n-                output.shouldContain(\"Skipping LambdaHello: Unsafe anonymous class\")\n-                      .shouldHaveExitValue(0);\n-            });\n-\n-        run(topArchiveName,\n-            \"-Xlog:class+load=debug,cds+dynamic,cds\",\n-            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-            \"-cp\", appJar, mainClass)\n-            .assertNormalExit(output -> {\n-                output.shouldMatch(\"class.load.*LambdaHello\/0x.*source.*UnsafeAndLambdaApp\")\n-                      .shouldHaveExitValue(0);\n-            });\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/UnsafeAndLambda.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary VM unsafe anonymous classes will not be archived.\n- * @requires vm.cds\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n- * @modules java.base\/jdk.internal.misc\n- * @compile test-classes\/UnsafeAnonymousApp.java\n- *          ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar unsafe.jar UnsafeAnonymousApp\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$FileManagerWrapper$1\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$FileManagerWrapper\n- *                 jdk\/test\/lib\/compiler\/InMemoryJavaCompiler$MemoryJavaFileObject\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. UnsafeAnonymous\n- *\/\n-\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class UnsafeAnonymous extends DynamicArchiveTestBase {\n-    public static void main(String[] args) throws Exception {\n-        runTest(UnsafeAnonymous::test);\n-    }\n-\n-    static void test() throws Exception {\n-        String topArchiveName = getNewArchiveName();\n-        String appJar = ClassFileInstaller.getJarPath(\"unsafe.jar\");\n-        String mainClass = \"UnsafeAnonymousApp\";\n-\n-        dump(topArchiveName,\n-            \"-Xlog:class+load=debug,cds+dynamic,cds\",\n-            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-            \"-cp\", appJar, mainClass)\n-            .assertNormalExit(output -> {\n-                output.shouldContain(\"Skipping TestClass: Unsafe anonymous class\")\n-                      .shouldHaveExitValue(0);\n-            });\n-\n-        run(topArchiveName,\n-            \"-Xlog:class+load=debug,cds+dynamic,cds\",\n-            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-            \"-cp\", appJar, mainClass)\n-            .assertNormalExit(output -> {\n-                output.shouldMatch(\"class.load.*TestClass\/0x.*source.*UnsafeAnonymousApp\")\n-                      .shouldHaveExitValue(0);\n-            });\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/UnsafeAnonymous.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-import jdk.internal.misc.Unsafe;\n-\n-public class UnsafeAndLambdaApp {\n-\n-    static byte klassbuf[] = InMemoryJavaCompiler.compile(\"LambdaHello\",\n-        \"public class LambdaHello { \" +\n-        \"    public LambdaHello() { \" +\n-        \"        doit(() -> { \" +\n-        \"            System.out.println(\\\"Hello from Lambda\\\"); \" +\n-        \"        }); \" +\n-        \"    } \" +\n-        \"    static void doit (Runnable r) { \" +\n-        \"        r.run(); \" +\n-        \"    } \" +\n-        \"} \");\n-\n-    public static void main(String args[]) throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        Class klass = unsafe.defineAnonymousClass(UnsafeAndLambdaApp.class, klassbuf, new Object[0]);\n-        try {\n-            Object obj = klass.newInstance();\n-            \/\/ If we come to here, LambdaMetafactory has probably been modified\n-            \/\/ to support vm-anon classes. In that case, we will need more tests for CDS.\n-            throw new RuntimeException(\"Unexpected support for lambda classes in VM anonymous classes\");\n-        } catch (java.lang.InternalError expected) {\n-            System.out.println(\"Caught expected java.lang.InternalError\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/UnsafeAndLambdaApp.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-import jdk.internal.misc.Unsafe;\n-\n-public class UnsafeAnonymousApp {\n-\n-    static byte klassbuf[] = InMemoryJavaCompiler.compile(\"TestClass\",\n-        \"public class TestClass { \" +\n-        \"} \");\n-\n-    public static void main(String args[]) throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        Class klass = unsafe.defineAnonymousClass(UnsafeAnonymousApp.class, klassbuf, new Object[0]);\n-        Object obj = klass.newInstance();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/UnsafeAnonymousApp.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ This is copied from DefineAnon to test Symbol Refcounting for the package prepended name.\n-\n-package p1;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.misc.Unsafe;\n-\n-\n-class T {\n-    static           protected void test0() { System.out.println(\"test0 (public)\"); }\n-    static           protected void test1() { System.out.println(\"test1 (protected)\"); }\n-    static \/*package-private*\/ void test2() { System.out.println(\"test2 (package)\"); }\n-    static             private void test3() { System.out.println(\"test3 (private)\"); }\n-}\n-\n-public class AnonSymbolLeak {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static Class<?> getAnonClass(Class<?> hostClass, final String className) {\n-        final String superName = \"java\/lang\/Object\";\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, \"test\", \"()V\", null, null);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test0\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test1\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test2\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test3\", \"()V\", false);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        final byte[] classBytes = cw.toByteArray();\n-        Class<?> invokerClass = UNSAFE.defineAnonymousClass(hostClass, classBytes, new Object[0]);\n-        UNSAFE.ensureClassInitialized(invokerClass);\n-        return invokerClass;\n-    }\n-\n-    public static void test() throws Throwable {\n-        \/\/ AnonClass is injected into package p1.\n-        System.out.println(\"Injecting from the same package (p1):\");\n-        Class<?> p1cls = getAnonClass(T.class, \"AnonClass\");\n-        p1cls.getMethod(\"test\").invoke(null);\n-    }\n-\n-    public static void main(java.lang.String[] unused) throws Throwable {\n-        test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/AnonSymbolLeak.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test DefineAnon\n- * @bug 8058575\n- * @library \/testlibrary\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.management\n- *          java.base\/jdk.internal.misc\n- * @compile -XDignore.symbol.file=true DefineAnon.java\n- * @run main\/othervm p1.DefineAnon\n- *\/\n-\n-package p1;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.misc.Unsafe;\n-\n-\n-class T {\n-    static           protected void test0() { System.out.println(\"test0 (public)\"); }\n-    static           protected void test1() { System.out.println(\"test1 (protected)\"); }\n-    static \/*package-private*\/ void test2() { System.out.println(\"test2 (package)\"); }\n-    static             private void test3() { System.out.println(\"test3 (private)\"); }\n-}\n-\n-public class DefineAnon {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static Class<?> getAnonClass(Class<?> hostClass, final String className) {\n-        final String superName = \"java\/lang\/Object\";\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, \"test\", \"()V\", null, null);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test0\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test1\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test2\", \"()V\", false);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"p1\/T\", \"test3\", \"()V\", false);\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        final byte[] classBytes = cw.toByteArray();\n-        Class<?> invokerClass = UNSAFE.defineAnonymousClass(hostClass, classBytes, new Object[0]);\n-        UNSAFE.ensureClassInitialized(invokerClass);\n-        return invokerClass;\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        Throwable fail = null;\n-\n-        \/\/ Anonymous class has the privileges of its host class, so test[0123] should all work.\n-        System.out.println(\"Injecting from the same package (p1):\");\n-        Class<?> p1cls = getAnonClass(T.class, \"p1\/AnonClass\");\n-        try {\n-            p1cls.getMethod(\"test\").invoke(null);\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            fail = ex;  \/\/ throw this to make test fail, since subtest failed\n-        }\n-\n-        \/\/ Anonymous class has different package name from host class.  Should throw\n-        \/\/ IllegalArgumentException.\n-        System.out.println(\"Injecting from the wrong package (p2):\");\n-        try {\n-            Class<?> p2cls = getAnonClass(DefineAnon.class, \"p2\/AnonClass\");\n-            p2cls.getMethod(\"test\").invoke(null);\n-            System.out.println(\"Failed, did not get expected IllegalArgumentException\");\n-        } catch (java.lang.IllegalArgumentException e) {\n-            if (e.getMessage().contains(\"Host class p1\/DefineAnon and anonymous class p2\/AnonClass\")) {\n-                System.out.println(\"Got expected IllegalArgumentException: \" + e.getMessage());\n-            } else {\n-                throw new RuntimeException(\"Unexpected message: \" + e.getMessage());\n-            }\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            fail = ex;  \/\/ throw this to make test fail, since subtest failed\n-        }\n-\n-        \/\/ Inject a class in the unnamed package into p1.T.  It should be able\n-        \/\/ to access all methods in p1.T.\n-        System.out.println(\"Injecting unnamed package into correct host class:\");\n-        try {\n-            Class<?> p3cls = getAnonClass(T.class, \"AnonClass\");\n-            p3cls.getMethod(\"test\").invoke(null);\n-        } catch (Throwable ex) {\n-            ex.printStackTrace();\n-            fail = ex;  \/\/ throw this to make test fail, since subtest failed\n-        }\n-\n-        \/\/ Try using an array class as the host class.  This should throw IllegalArgumentException.\n-        try {\n-            Class<?> p3cls = getAnonClass(String[].class, \"AnonClass\");\n-            throw new RuntimeException(\"Expected IllegalArgumentException not thrown\");\n-        } catch (IllegalArgumentException ex) {\n-        }\n-\n-        if (fail != null) throw fail;  \/\/ make test fail, since subtest failed\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/DefineAnon.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8058575\n- * @summary Creates an anonymous class inside of an anonymous class.\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.management\n- * @run main p.NestedUnsafe\n- *\/\n-\n-package p;\n-\n-import java.lang.*;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-\n-\/\/ Test that an anonymous class in package 'p' cannot define its own anonymous class\n-\/\/ in another package.\n-public class NestedUnsafe {\n-    \/\/ The String concatenation should create the nested anonymous class.\n-    static byte klassbuf[] = InMemoryJavaCompiler.compile(\"q.TestClass\",\n-        \"package q; \" +\n-        \"public class TestClass { \" +\n-        \"    public static void concat(String one, String two) throws Throwable { \" +\n-        \"        System.out.println(one + two);\" +\n-        \" } } \");\n-\n-    public static void main(String args[]) throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        \/\/ The anonymous class calls defineAnonymousClass creating a nested anonymous class.\n-        byte klassbuf2[] = InMemoryJavaCompiler.compile(\"p.TestClass2\",\n-            \"package p; \" +\n-            \"import jdk.internal.misc.Unsafe; \" +\n-            \"public class TestClass2 { \" +\n-            \"    public static void doit() throws Throwable { \" +\n-            \"        Unsafe unsafe = jdk.internal.misc.Unsafe.getUnsafe(); \" +\n-            \"        Class klass2 = unsafe.defineAnonymousClass(TestClass2.class, p.NestedUnsafe.klassbuf, new Object[0]); \" +\n-            \"        unsafe.ensureClassInitialized(klass2); \" +\n-            \"        Class[] dArgs = new Class[2]; \" +\n-            \"        dArgs[0] = String.class; \" +\n-            \"        dArgs[1] = String.class; \" +\n-            \"        try { \" +\n-            \"            klass2.getMethod(\\\"concat\\\", dArgs).invoke(null, \\\"CC\\\", \\\"DD\\\"); \" +\n-            \"        } catch (Throwable ex) { \" +\n-            \"            throw new RuntimeException(\\\"Exception: \\\" + ex.toString()); \" +\n-            \"        } \" +\n-            \"} } \",\n-            \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n-\n-        Class klass2 = unsafe.defineAnonymousClass(p.NestedUnsafe.class, klassbuf2, new Object[0]);\n-        try {\n-            klass2.getMethod(\"doit\").invoke(null);\n-            throw new RuntimeException(\"Expected exception not thrown\");\n-        } catch (Throwable ex) {\n-            Throwable iae = ex.getCause();\n-            if (!iae.toString().contains(\n-                \"IllegalArgumentException: Host class p\/NestedUnsafe and anonymous class q\/TestClass\")) {\n-                throw new RuntimeException(\"Exception: \" + iae.toString());\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/NestedUnsafe.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8058575\n- * @summary Creates an anonymous class inside of an anonymous class.\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.management\n- * @run main p.NestedUnsafe2\n- *\/\n-\n-package p;\n-\n-import java.lang.*;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.test.lib.compiler.InMemoryJavaCompiler;\n-\n-\n-\/\/ Test that an anonymous class that gets put in its host's package cannot define\n-\/\/ an anonymous class in another package.\n-public class NestedUnsafe2 {\n-    \/\/ The String concatenation should create the nested anonymous class.\n-    public static byte klassbuf[] = InMemoryJavaCompiler.compile(\"q.TestClass\",\n-        \"package q; \" +\n-        \"public class TestClass { \" +\n-        \"    public static void concat(String one, String two) throws Throwable { \" +\n-        \"        System.out.println(one + two);\" +\n-        \" } } \");\n-\n-    public static void main(String args[]) throws Exception {\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        \/\/ The anonymous class calls defineAnonymousClass creating a nested anonymous class.\n-        byte klassbuf2[] = InMemoryJavaCompiler.compile(\"TestClass2\",\n-            \"import jdk.internal.misc.Unsafe; \" +\n-            \"public class TestClass2 { \" +\n-            \"    public static void doit() throws Throwable { \" +\n-            \"        Unsafe unsafe = jdk.internal.misc.Unsafe.getUnsafe(); \" +\n-            \"        Class klass2 = unsafe.defineAnonymousClass(TestClass2.class, p.NestedUnsafe2.klassbuf, new Object[0]); \" +\n-            \"        unsafe.ensureClassInitialized(klass2); \" +\n-            \"        Class[] dArgs = new Class[2]; \" +\n-            \"        dArgs[0] = String.class; \" +\n-            \"        dArgs[1] = String.class; \" +\n-            \"        try { \" +\n-            \"            klass2.getMethod(\\\"concat\\\", dArgs).invoke(null, \\\"CC\\\", \\\"DD\\\"); \" +\n-            \"        } catch (Throwable ex) { \" +\n-            \"            throw new RuntimeException(\\\"Exception: \\\" + ex.toString()); \" +\n-            \"        } \" +\n-            \"} } \",\n-            \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n-\n-        Class klass2 = unsafe.defineAnonymousClass(p.NestedUnsafe2.class, klassbuf2, new Object[0]);\n-        try {\n-            klass2.getMethod(\"doit\").invoke(null);\n-            throw new RuntimeException(\"Expected exception not thrown\");\n-        } catch (Throwable ex) {\n-            Throwable iae = ex.getCause();\n-            if (!iae.toString().contains(\n-                \"IllegalArgumentException: Host class p\/NestedUnsafe2 and anonymous class q\/TestClass\")) {\n-                throw new RuntimeException(\"Exception: \" + iae.toString());\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/NestedUnsafe2.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test TestAnonSymbolLeak\n- * @bug 8218755\n- * @requires vm.opt.final.ClassUnloading\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.org.objectweb.asm\n- *          java.management\n- * @library \/test\/lib\n- * @build p1.AnonSymbolLeak\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -Xmn8m -XX:+UnlockDiagnosticVMOptions -Xlog:class+unload -XX:+WhiteBoxAPI TestAnonSymbolLeak\n- *\/\n-\n-import java.lang.reflect.Method;\n-import sun.hotspot.WhiteBox;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.classloader.ClassUnloadCommon;\n-\n-public class TestAnonSymbolLeak {\n-    static String className = \"p1.AnonSymbolLeak\";\n-\n-    private static class ClassUnloadTestMain {\n-        public static void test() throws Exception {\n-            \/\/ Load the AnonSymbolLeak class in a new class loader, run it, which loads\n-            \/\/ an unsafe anonymous class in the same package p1.  Then unload it.\n-            \/\/ Then test that the refcount of the symbol created for the prepended name doesn't leak.\n-            ClassLoader cl = ClassUnloadCommon.newClassLoader();\n-            Class<?> c = cl.loadClass(className);\n-            c.getMethod(\"test\").invoke(null);\n-            cl = null; c = null;\n-            ClassUnloadCommon.triggerUnloading();\n-        }\n-    }\n-\n-    public static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    public static void main(String... args) throws Exception {\n-        String oldName = \"AnonClass\";\n-        String prependedName = \"p1\/AnonClass\";\n-        ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should not be loaded\");\n-        int countBeforeOld = wb.getSymbolRefcount(oldName);\n-        int countBefore = wb.getSymbolRefcount(prependedName);\n-        ClassUnloadTestMain.test();\n-        ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should be unloaded\");\n-        int countAfterOld = wb.getSymbolRefcount(oldName);\n-        int countAfter = wb.getSymbolRefcount(prependedName);\n-        Asserts.assertEquals(countBeforeOld, countAfterOld); \/\/ no leaks to the old name\n-        System.out.println(\"count before and after \" + countBeforeOld + \" \" + countAfterOld);\n-        Asserts.assertEquals(countBefore, countAfter);       \/\/ no leaks to the prepended name\n-        System.out.println(\"count before and after \" + countBefore + \" \" + countAfter);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/TestAnonSymbolLeak.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8200261\n- * @summary Tests an anonymous class that implements interfaces with default methods.\n- * @library \/testlibrary\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.management\n- *          java.base\/jdk.internal.misc\n- * @compile -XDignore.symbol.file=true UnsafeDefMeths.java\n- * @run main UnsafeDefMeths\n- *\/\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.misc.Unsafe;\n-\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.DUP;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.PUTFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V1_8;\n-\n-public class UnsafeDefMeths {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    interface Resource {\n-        Pointer ptr();\n-    }\n-\n-    interface Struct extends Resource {\n-       StructPointer ptr();\n-    }\n-\n-    interface Pointer { }\n-\n-    interface StructPointer extends Pointer { }\n-\n-    interface I extends Struct {\n-        void m();\n-    }\n-\n-    static String IMPL_PREFIX = \"$$impl\";\n-    static String PTR_FIELD_NAME = \"ptr\";\n-\n-    public static void main(String[] args) throws Throwable {\n-        byte[] bytes = new UnsafeDefMeths().generate(I.class);\n-        Class<?> cl = UNSAFE.defineAnonymousClass(I.class, bytes, new Object[0]);\n-        I i = (I)cl.getConstructors()[0].newInstance(new Object[] { null }); \/\/exception here!\n-    }\n-\n-    \/\/ Generate a class similar to:\n-    \/\/\n-    \/\/ public class UnsafeDefMeths$I$$impl implements UnsafeDefMeths$I, UnsafeDefMeths$Struct {\n-    \/\/\n-    \/\/     public UnsafeDefMeths$StructPointer ptr;\n-    \/\/\n-    \/\/     public UnsafeDefMeths$I$$impl(UnsafeDefMeths$StructPointer p) {\n-    \/\/         ptr = p;\n-    \/\/     }\n-    \/\/\n-    \/\/     public UnsafeDefMeths$StructPointer ptr() {\n-    \/\/         return ptr;\n-    \/\/     }\n-    \/\/ }\n-    \/\/\n-    byte[] generate(Class<?> iface) {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-\n-        String ifaceTypeName = Type.getInternalName(iface);\n-        String proxyClassName = ifaceTypeName + IMPL_PREFIX;\n-        \/\/ class definition\n-        cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, proxyClassName,\n-                desc(Object.class) + desc(ifaceTypeName) + desc(Struct.class),\n-                name(Object.class),\n-                new String[] { ifaceTypeName, name(Struct.class) });\n-\n-        cw.visitField(ACC_PUBLIC, PTR_FIELD_NAME, desc(StructPointer.class), desc(StructPointer.class), null);\n-        cw.visitEnd();\n-\n-        \/\/ constructor\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\",\n-                meth(desc(void.class), desc(StructPointer.class)),\n-                meth(desc(void.class), desc(StructPointer.class)), null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL, name(Object.class), \"<init>\", meth(desc(void.class)), false);\n-        mv.visitVarInsn(ALOAD, 1);\n-        \/\/ Execution of this PUTFIELD instruction causes the bug's ClassNotFoundException.\n-        mv.visitFieldInsn(PUTFIELD, proxyClassName, PTR_FIELD_NAME, desc(StructPointer.class));\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ ptr() impl\n-        mv = cw.visitMethod(ACC_PUBLIC, PTR_FIELD_NAME, meth(desc(StructPointer.class)),\n-                meth(desc(StructPointer.class)), null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitFieldInsn(GETFIELD, proxyClassName, PTR_FIELD_NAME, desc(StructPointer.class));\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        return cw.toByteArray();\n-    }\n-\n-    String name(Class<?> clazz) {\n-        if (clazz.isPrimitive()) {\n-            throw new IllegalStateException();\n-        } else if (clazz.isArray()) {\n-            return desc(clazz);\n-        } else {\n-            return clazz.getName().replaceAll(\"\\\\.\", \"\/\");\n-        }\n-    }\n-\n-    String desc(Class<?> clazz) {\n-        String mdesc = MethodType.methodType(clazz).toMethodDescriptorString();\n-        return mdesc.substring(mdesc.indexOf(')') + 1);\n-    }\n-\n-    String desc(String clazzName) {\n-        return \"L\" + clazzName + \";\";\n-    }\n-\n-    String gen(String clazz, String... typeargs) {\n-        return clazz.substring(0, clazz.length() - 1) + Stream.of(typeargs).collect(Collectors.joining(\"\", \"<\", \">\")) + \";\";\n-    }\n-\n-    String meth(String restype, String... argtypes) {\n-        return Stream.of(argtypes).collect(Collectors.joining(\"\", \"(\", \")\")) + restype;\n-    }\n-\n-    String meth(Method m) {\n-        return MethodType.methodType(m.getReturnType(), m.getParameterTypes()).toMethodDescriptorString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/defineAnonClass\/UnsafeDefMeths.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-import jdk.internal.misc.Unsafe;\n-\n@@ -64,1 +62,1 @@\n-    \/\/                                                                  2      2048      1088   + hidden classes\n+    \/\/                                                                  1       256       131   + hidden classes\n@@ -107,3 +105,2 @@\n-                    if (!m2.group(1).equals(\"2\")) {\n-                        \/\/ anonymous classes are included in the hidden classes count.\n-                        Assert.fail(\"Should have loaded 2 hidden classes, but found : \" + m2.group(1));\n+                    if (!m2.group(1).equals(\"1\")) {\n+                        Assert.fail(\"Should have loaded 1 hidden class, but found : \" + m2.group(1));\n@@ -126,2 +123,0 @@\n-        public static final String CLASS_NAME = \"TestClass\";\n-\n@@ -180,1 +175,0 @@\n-    static Unsafe unsafe = Unsafe.getUnsafe();\n@@ -184,1 +178,1 @@\n-            \/\/ Create a hidden non-strong class and an anonymous class.\n+            \/\/ Create a hidden non-strong class\n@@ -187,1 +181,0 @@\n-            Class ac = unsafe.defineAnonymousClass(TestClass.class, klassBuf, new Object[0]);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderStatsTest.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-                 \"InstanceKlass::_misc_is_unsafe_anonymous 8\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestIntConstant.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-          \"anonymous_classloader\".\n+          \"hidden_classloader\".\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-    PLAIN, REFLECTION, JNI, ANONYMOUS_CLASSLOADER\n+    PLAIN, REFLECTION, JNI, HIDDEN_CLASSLOADER\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/configuration\/ClassloadingMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-\/\/import gc.g1.unloading.check.*;\n@@ -45,1 +44,3 @@\n-import jdk.internal.misc.Unsafe;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -74,0 +75,4 @@\n+    \/\/ This should be TRUE for bytecode generators that use ASM to create the bytecodes\n+    \/\/ instead of creating Java source and then compiling with InMemoryJavaCompiler.\n+    private boolean prepend_package = true;\n+\n@@ -92,0 +97,1 @@\n+            prepend_package = false;\n@@ -110,1 +116,5 @@\n-        Bytecode kit = bf.createBytecode(className_);\n+        \/\/ if generating the bytecodes using ASM then prepend the package name to\n+        \/\/ the classname so that, when created as a hidden class, it will be in the\n+        \/\/ same package as its lookup class.\n+        Bytecode kit = bf.createBytecode(prepend_package ?\n+                                         \"gc.g1.unloading.loading.\" + className_ : className_);\n@@ -121,6 +131,2 @@\n-        \/\/ The JVM prepends the host class's package to the anonymous class name.\n-        if (configuration.getClassloadingMethod() != ClassloadingMethod.ANONYMOUS_CLASSLOADER) {\n-            assertion = new ClassAssertion(className, true);\n-        } else {\n-            assertion = new ClassAssertion(\"gc\/g1\/unloading\/loading\/\" + className, true);\n-        }\n+        assertion = new ClassAssertion(className, true);\n+\n@@ -181,1 +187,5 @@\n-        Bytecode kit = bf.createBytecode(className_);\n+        \/\/ if generating the bytecodes using ASM then prepend the package name to\n+        \/\/ the classname so that, when created as a hidden class, it will be in the\n+        \/\/ same package as its lookup class.\n+        Bytecode kit = bf.createBytecode(prepend_package ?\n+                                         \"gc.g1.unloading.loading.\" + className_ : className_);\n@@ -196,6 +206,1 @@\n-        \/\/ The JVM prepends the host class's package to the anonymous class name.\n-        if (configuration.getClassloadingMethod() != ClassloadingMethod.ANONYMOUS_CLASSLOADER) {\n-            assertion = new ClassAssertion(className, false);\n-        } else {\n-            assertion = new ClassAssertion(\"gc\/g1\/unloading\/loading\/\" + className, false);\n-        }\n+        assertion = new ClassAssertion(className, false);\n@@ -249,2 +254,3 @@\n-                case ANONYMOUS_CLASSLOADER:\n-                    return getUnsafe().defineAnonymousClass(ClassLoadingHelper.class, bytecode, NO_CP_PATCHES);\n+                case HIDDEN_CLASSLOADER:\n+                    Lookup lookup = MethodHandles.lookup();\n+                    return lookup.defineHiddenClass(bytecode, true).lookupClass();\n@@ -253,1 +259,1 @@\n-        } catch (ClassNotFoundException e) {\n+        } catch (ClassNotFoundException | IllegalAccessException e) {\n@@ -327,4 +333,0 @@\n-    private static Unsafe getUnsafe() {\n-        return Unsafe.getUnsafe();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/loading\/ClassLoadingHelper.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *      -classloadingMethod anonymous_classloader\n+ *      -classloadingMethod hidden_classloader\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_class\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *      -classloadingMethod anonymous_classloader\n+ *      -classloadingMethod hidden_classloader\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_obj\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *      -classloadingMethod anonymous_classloader\n+ *      -classloadingMethod hidden_classloader\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_class\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *      -classloadingMethod anonymous_classloader\n+ *      -classloadingMethod hidden_classloader\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_obj\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-package metaspace.staticReferences;\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/staticReferences\/OneUsageClassloader.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- *      metaspace.staticReferences.StaticReferences\n+ *      StaticReferences\n@@ -44,2 +44,2 @@\n-package metaspace.staticReferences;\n-\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -62,1 +62,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -68,1 +67,1 @@\n- * 1.) Load class either by regular classloader or by Unsafe.defineAnonymousClass.\n+ * 1.) Load class either by regular classloader or by defineHiddenClass.\n@@ -99,4 +98,0 @@\n-    private static Unsafe getUnsafe() {\n-        return Unsafe.getUnsafe();\n-    }\n-\n@@ -126,1 +121,1 @@\n-            boolean anonymous = random.nextBoolean();\n+            boolean hidden = random.nextBoolean();\n@@ -129,1 +124,1 @@\n-            Class clazz = loadClass(classBytecode, anonymous);\n+            Class clazz = loadClass(classBytecode, hidden);\n@@ -158,1 +153,1 @@\n-            clazz = loadClass(classBytecode, anonymous);\n+            clazz = loadClass(classBytecode, hidden);\n@@ -167,2 +162,1 @@\n-        private Class loadClass(byte[] classBytecode,\n-                        boolean anonymous) {\n+        private Class loadClass(byte[] classBytecode, boolean hidden) {\n@@ -170,2 +164,9 @@\n-                if (anonymous) {\n-                        clazz = getUnsafe().defineAnonymousClass(StaticReferences.class, classBytecode, NO_CP_PATCHES);\n+                if (hidden) {\n+                    Lookup lookup = MethodHandles.lookup();\n+                    try {\n+                        clazz = lookup.defineHiddenClass(classBytecode, false).lookupClass();\n+                    } catch (IllegalAccessException e) {\n+                        e.printStackTrace();\n+                        throw new RuntimeException(\n+                            \"Lookup.defineHiddenClass failed: \" + e.getMessage());\n+                    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/staticReferences\/StaticReferences.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -28,1 +30,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -38,1 +39,1 @@\n- * This class uses Unsafe.defineAnonymousClass for class loading\n+ * This class uses hidden classes for class loading\n@@ -57,2 +58,3 @@\n-    private Class generateClass(List<Instruction> instructions) throws ClassNotFoundException {\n-        String classNameForASM = \"ExecClass\";\n+    private Class generateClass(List<Instruction> instructions) throws ReflectiveOperationException {\n+        \/\/ Needs to be in the same package as the lookup class.\n+        String classNameForASM = \"vm\/compiler\/coverage\/parentheses\/share\/ExecClass\";\n@@ -74,5 +76,3 @@\n-        return getUnsafe().defineAnonymousClass(ClassWriter.class, cw.toByteArray(), NO_CP_PATCHES);\n-    }\n-\n-    private static Unsafe getUnsafe() {\n-        return Unsafe.getUnsafe();\n+        Lookup lookup = MethodHandles.lookup();\n+        Class<?> hc = lookup.defineHiddenClass(cw.toByteArray(), false).lookupClass();\n+        return hc;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/coverage\/parentheses\/share\/HotspotInstructionsExecutor.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/castToGrandparent.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Cast an object loaded with Unsafe.defineAnonymousClass to superclass of its parent class. This cast should succeed.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.castToGrandparent.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.castToGrandparent.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.castToGrandparent;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.anonloader.share.AnonkTestee02;\n-import vm.mlvm.share.Env;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee02.class;\n-\n-    @Override\n-    public boolean run() throws Exception {\n-        byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-        Class<?> cls = UnsafeAccess.unsafe.defineAnonymousClass(\n-                PARENT, classBytes, null);\n-        Object anonObject = cls.newInstance();\n-        \/\/ Try to cast anonymous class to its grandparent\n-        AnonkTestee01 anonCastToParent = (AnonkTestee01) anonObject;\n-        if ( anonCastToParent.equals(anonObject) )\n-            Env.traceNormal(\"Anonymous object can be cast to original one\");\n-\n-        \/\/ Try to cast using another method\n-        new AnonkTestee01().getClass().cast(anonObject);\n-\n-        Env.traceNormal(\"Anonymous class can be cast to original one\");\n-\n-        return true;\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/castToGrandparent\/Test.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/castToParent.\n- * VM Testbase keywords: [feature_mlvm, clarify-spec, exclude]\n- * VM Testbase comments: 8199227\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Try to cast an object of a class, which is loaded by Unsafe.defineAnonymousClass to its\n- *     parent (called AnonkTestee01) using the following cast methods:\n- *         - (AnonkTestee01) o\n- *         - o.getClass().cast(new AnonkTestee01());\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @ignore 8199227\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.castToParent.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.castToParent.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.castToParent;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.Env;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee01.class;\n-\n-    public boolean run() throws Exception {\n-        byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-        Class<?> cls = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                classBytes, null);\n-        Object o = cls.newInstance();\n-        \/\/ Try to cast anonymous class to its parent\n-        AnonkTestee01 anonCastToParent = (AnonkTestee01) o;\n-        if ( anonCastToParent.equals(o) )\n-            Env.traceNormal(\"Anonymous object can be cast to original one\");\n-\n-        \/\/ Cast the class\n-        new AnonkTestee01().getClass().cast(o);\n-\n-        Env.traceNormal(\"Anonymous can be cast to original class\");\n-\n-        return true;\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/castToParent\/Test.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/classNameInStackTrace.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     An exception is thrown by class loaded by Unsafe.defineAnonymousClass. Verify that\n- *     the exception's stack trace contains name of the current test class (i.e.,\n- *     verify that the stack trace is not broken)\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.classNameInStackTrace.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.classNameInStackTrace.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.classNameInStackTrace;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee01.class;\n-\n-    public boolean run() throws Exception {\n-        byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-        Class<?> cls = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                classBytes, null);\n-        try {\n-            \/\/ hashCode() in AnonkTestee01 always throws an exception\n-            cls.newInstance().hashCode();\n-            return false;\n-\n-        } catch ( RuntimeException e ) {\n-            ByteArrayOutputStream byteOS = new ByteArrayOutputStream();\n-            PrintStream printStream = new PrintStream(byteOS);\n-            e.printStackTrace(printStream);\n-            printStream.close();\n-            String stackTrace = byteOS.toString(\"ASCII\");\n-            getLog().display(\"Caught exception stack trace: \" + stackTrace);\n-            return stackTrace.contains(Test.class.getName());\n-        }\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/classNameInStackTrace\/Test.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/finalSuperclass.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Try to load anonymous class derived from java.lang.System. The class file\n- *     loader should reject such attempt and throw IncompatibleClassChangeError\n- *     because java.lang.System is a final class.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.share.ReplaceClassParentTest\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm\n- *      vm.mlvm.anonloader.share.ReplaceClassParentTest\n- *      -newParent java\/lang\/System\n- *      -requireExceptions java.lang.IncompatibleClassChangeError\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/finalSuperclass\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *     Try to find a class loaded using Unsafe.defineAnonymousClass through the VM system dictionary\n+ *     Try to find a class loaded as a hidden class through the VM system dictionary\n@@ -48,0 +48,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n@@ -51,1 +54,0 @@\n-import vm.share.UnsafeAccess;\n@@ -59,3 +61,4 @@\n-            Class<?> c = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                    classBytes, null);\n-            getLog().display(\"Anonymous class name: \" + c.getName());\n+            Lookup lookup = MethodHandles.lookup();\n+            Lookup ank_lookup = MethodHandles.privateLookupIn(PARENT, lookup);\n+            Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+            getLog().display(\"Hidden class name: \" + c.getName());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/findByName\/Test.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/invalidSuperclass.\n- * VM Testbase keywords: [feature_mlvm]\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.invalidSuperclass.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm -Xverify:all vm.mlvm.anonloader.func.invalidSuperclass.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.invalidSuperclass;\n-\n-import vm.mlvm.anonloader.share.ReplaceClassParentTest;\n-import vm.mlvm.share.MlvmTestExecutor;\n-\n-\/**\n- * Using Unsafe.defineAnonymousClass to load a class that has a patched superclass name, which is invalid.\n- * Verify that such class cannot be loaded.\n- *\n- *\/\n-public class Test extends ReplaceClassParentTest {\n-\n-    @Override\n-    protected void initializeTest() throws Throwable {\n-        super.initializeTest();\n-        setReplaceParent(String.format(\"%9999s\", \"Can you find me?\"));\n-        setRequiredExceptions(java.lang.NoClassDefFoundError.class);\n-    }\n-\n-    public static void main(String[] args) {\n-        MlvmTestExecutor.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/invalidSuperclass\/Test.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/isGarbageCollected.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Load an anonymous class, drop all references to it and verify that it is collected\n- *     by GC afterwards (call System.gc() just in case). PhantomReference is used to\n- *     check that the anonymous class is gone.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.isGarbageCollected.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.isGarbageCollected.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.isGarbageCollected;\n-\n-import java.lang.ref.PhantomReference;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee01.class;\n-\n-    public boolean run() throws Exception {\n-        ReferenceQueue<Class<?>> refQueue = new ReferenceQueue<Class<?>>();\n-        PhantomReference<Class<?>> anonClassRef = createClass(refQueue);\n-        System.gc();\n-        Reference<? extends Class<?>> deletedObject = refQueue.remove();\n-        return anonClassRef.equals(deletedObject);\n-    }\n-\n-    \/\/ a private method is great to keep anonClass reference local to make it GCed on the next cycle\n-    private PhantomReference<Class<?>> createClass(ReferenceQueue<Class<?>> refQueue) throws Exception {\n-        byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-        Class<?> anonClass = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                classBytes, null);\n-        return new PhantomReference<Class<?>>(anonClass, refQueue);\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/isGarbageCollected\/Test.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key randomness\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n- *\n- * @summary converted from VM Testbase vm\/mlvm\/anonloader\/func\/uniqueClassAndObject.\n- * VM Testbase keywords: [feature_mlvm]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Create two anonymous classes and instantiate an object from each of them.\n- *     Verify that the references to these objects are different and references\n- *     to their classes are not equal too.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment build test class and indify classes\n- * @build vm.mlvm.anonloader.func.uniqueClassAndObject.Test\n- * @run driver vm.mlvm.share.IndifiedClassesBuilder\n- *\n- * @run main\/othervm vm.mlvm.anonloader.func.uniqueClassAndObject.Test\n- *\/\n-\n-package vm.mlvm.anonloader.func.uniqueClassAndObject;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import vm.mlvm.anonloader.share.AnonkTestee01;\n-import vm.mlvm.share.MlvmTest;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-\n-public class Test extends MlvmTest {\n-    private static final Class<?> PARENT = AnonkTestee01.class;\n-\n-    @Override\n-    public boolean run() throws Exception {\n-        byte[] classBytes = FileUtils.readClass(PARENT.getName());\n-        ClassReader reader = new ClassReader(classBytes);\n-        Object o1 = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                    classBytes, null).newInstance();\n-        int cpLength = reader.getItemCount();\n-        Object cpPatch[] = new Object[cpLength];\n-        Object o2 = UnsafeAccess.unsafe.defineAnonymousClass(PARENT,\n-                    classBytes, cpPatch).newInstance();\n-        if ( o1 == o2 ) {\n-            getLog().complain(\"Error: The objects are equal\");\n-            return false;\n-        }\n-\n-        if ( o1.getClass() == o2.getClass() ) {\n-            getLog().complain(\"Error: The classes are equal\");\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    public static void main(String[] args) { MlvmTest.launch(args); }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/func\/uniqueClassAndObject\/Test.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.mlvm.anonloader.share;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import vm.mlvm.share.MlvmTest;\n-import vm.mlvm.share.MlvmTestExecutor;\n-import vm.mlvm.share.Env;\n-import vm.share.FileUtils;\n-import vm.share.UnsafeAccess;\n-import vm.share.options.Option;\n-\n-\/**\n- * This is a base class for kind of tests, which modify the parent class name of test dummy class vm.mlvm.share.AnonkTestee01\n- * with an arbitrary string, load the modified class using Unsafe.defineAnonymousClass and instantiate it.\n- * <p>\n- * The tests can extend this class or use it from command-line to provide the actual data:\n- * <ul>\n- *   <li>new parent class name,\n- *   <li>optionally the list of expected exceptions to be thrown during class loading and instantiation\n- *       (see {@link vm.mlvm.share.MlvmTest#setRequiredExceptions(Class<? extends Throwable>... classes)} for details)\n- * <\/ul>\n- *\/\n-\n-public class ReplaceClassParentTest extends MlvmTest {\n-\n-    @Option(name = \"newParent\", default_value = \"\", description = \"String to replace the name of the parent class of the testee\")\n-    private String newParentOpt;\n-\n-    public void setReplaceParent(String newParent) {\n-        newParentOpt = newParent;\n-    }\n-\n-    private static final Class<?> TESTEE_CLASS = AnonkTestee01.class;\n-\n-    public ReplaceClassParentTest() {\n-    }\n-\n-    public boolean run() throws Throwable {\n-        byte[] classBytes = FileUtils.readClass(TESTEE_CLASS.getName());\n-        ClassReader reader = new ClassReader(classBytes);\n-        int superclassNameIdx = reader.readUnsignedShort(reader.header + 4);\n-        int cpLength = reader.getItemCount();\n-        if (superclassNameIdx == 0) {\n-            throw new RuntimeException(\"Test bug: unable to find super class\"\n-                    + \" name index\");\n-        }\n-        Env.traceDebug(\"Superclass name CP index: \" + superclassNameIdx\n-                + \"; replacing CP entry with '\" + newParentOpt + \"'\");\n-        \/\/ now, construction of cp patch\n-        Object cpPatch[] = new Object[cpLength];\n-        cpPatch[superclassNameIdx] = newParentOpt;\n-        \/\/ define and instantiate\n-        UnsafeAccess.unsafe.defineAnonymousClass(TESTEE_CLASS, classBytes,\n-                cpPatch).newInstance();\n-        \/\/ Whether test should pass or fail should be specified via requireExceptions mechanism in MlvmTest\n-        return true;\n-\n-    }\n-\n-    public static void main(String[] args) {\n-        MlvmTestExecutor.launch(args);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/share\/ReplaceClassParentTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n@@ -53,1 +56,1 @@\n- *    <li>{@link sun.misc.Unsafe#defineAnonymousClass} call.\n+ *    <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass} call.\n@@ -95,6 +98,3 @@\n-    @Option(name = \"unsafeLoad\", default_value = \"false\",\n-            description = \"An option for adhoc experiments: load class via \"\n-                    + \"Unsafe.defineAnonymousClass(). Since in this way the \"\n-                    + \"loading process skips several security checks, if the \"\n-                    + \"class is not valid, crashes and assertions are normal.\")\n-    private static boolean unsafeLoad;\n+    @Option(name = \"hiddenLoad\", default_value = \"false\",\n+            description = \"An option for adhoc experiments: load class as a hidden class.\")\n+    private static boolean hiddenLoad;\n@@ -128,1 +128,1 @@\n-                    Env.traceNormal(\"StressClassLoadingTest options: unsafeLoad: \" + unsafeLoad);\n+                    Env.traceNormal(\"StressClassLoadingTest options: hiddenLoad: \" + hiddenLoad);\n@@ -165,2 +165,4 @@\n-                        if (unsafeLoad) {\n-                            c = UnsafeAccess.unsafe.defineAnonymousClass(hostClass, classBytes, null);\n+                        if (hiddenLoad) {\n+                            Lookup lookup = MethodHandles.lookup();\n+                            c = lookup.defineHiddenClass(classBytes, true).lookupClass();\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/share\/StressClassLoadingTest.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n- *       <li>{@link sun.misc.Unsafe#defineAnonymousClass}\n- *           when {@code -unsafeLoad true} option is passed to the test.\n+ *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+ *           when {@code -hiddenLoad true} option is passed to the test.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/byteMutation\/Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -53,1 +55,0 @@\n-import vm.share.UnsafeAccess;\n@@ -56,1 +57,1 @@\n- * This test loads a class using Unsafe.defineAnonymousClass, creates instances\n+ * This test loads a class using defineHiddenClass, creates instances\n@@ -79,2 +80,4 @@\n-                list.add(UnsafeAccess.unsafe.defineAnonymousClass(AnonkTestee01.class,\n-                    classBytes, null).newInstance());\n+                Lookup lookup = MethodHandles.lookup();\n+                Lookup ank_lookup = MethodHandles.privateLookupIn(AnonkTestee01.class, lookup);\n+                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+                list.add(c.newInstance());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/heap\/Test.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -52,1 +54,0 @@\n-import vm.share.UnsafeAccess;\n@@ -55,1 +56,1 @@\n- * This test loads classes using Unsafe.defineAnonymousClass and stores them,\n+ * This test loads classes using defineHiddenClass and stores them,\n@@ -76,4 +77,10 @@\n-        while (true) {\n-            list.add(UnsafeAccess.unsafe.defineAnonymousClass(AnonkTestee01.class,\n-                    classBytes, null));\n-        }\n+        try {\n+            while (true) {\n+                Lookup lookup = MethodHandles.lookup();\n+                Lookup ank_lookup = MethodHandles.privateLookupIn(AnonkTestee01.class, lookup);\n+                Class<?> c = ank_lookup.defineHiddenClass(classBytes, true).lookupClass();\n+                list.add(c.newInstance());\n+             }\n+         } catch (InstantiationException | IllegalAccessException e) {\n+             Env.throwAsUncheckedException(e);\n+         }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/oome\/metaspace\/Test.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- *      -unsafeLoad true\n+ *      -hiddenLoad true\n@@ -58,1 +58,1 @@\n- * {@link sun.misc.Unsafe#defineAnonymousClass}\n+ * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n@@ -93,1 +93,1 @@\n-     * using {@link sun.misc.Unsafe#defineAnonymousClass}\n+     * using {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/parallelLoad\/Test.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,2 @@\n- *       <li>{@link sun.misc.Unsafe#defineAnonymousClass}\n- *           when {@code -unsafeLoad true} is set.\n+ *       <li>{@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass}\n+ *           when {@code -hiddenLoad true} is set.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/anonloader\/stress\/randomBytecodes\/Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- *          java.desktop\n+ * @modules java.desktop\n@@ -35,4 +33,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-import jdk.internal.misc.Unsafe;\n-\n@@ -45,2 +39,0 @@\n-    private static final Unsafe U = Unsafe.getUnsafe();\n-\n@@ -87,42 +79,0 @@\n-\n-    @DataProvider(name = \"hostclasses\")\n-    public Object[][] hostClasses() {\n-        return new Object[][] {\n-\n-            { GetModuleTest.class,      null },\n-            { Object.class,             null },\n-            { Component.class,          null },\n-\n-        };\n-    }\n-\n-    \/**\n-     * Exercise Class::getModule on VM anonymous classes\n-     *\/\n-    @Test(dataProvider = \"hostclasses\")\n-    public void testGetModuleOnVMAnonymousClass(Class<?> hostClass, String ignore) {\n-\n-        \/\/ choose a class name in the same package as the host class\n-        String prefix = hostClass.getPackageName();\n-        if (prefix.length() > 0)\n-            prefix = prefix.replace('.', '\/') + \"\/\";\n-        String className = prefix + \"Anon\";\n-\n-        \/\/ create the class\n-        String superName = \"java\/lang\/Object\";\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V1_8, ACC_PUBLIC + ACC_FINAL + ACC_SUPER,\n-                 className, null, superName, null);\n-        byte[] classBytes = cw.toByteArray();\n-        int cpPoolSize = constantPoolSize(classBytes);\n-        Class<?> anonClass\n-            = U.defineAnonymousClass(hostClass, classBytes, new Object[cpPoolSize]);\n-\n-        assertTrue(anonClass.getModule() == hostClass.getModule());\n-    }\n-\n-    private static int constantPoolSize(byte[] classFile) {\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Class\/GetModuleTest.java","additions":2,"deletions":52,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-        \/\/ Lambdas may be VM anonymous classes, but are named, non-local classes\n+        \/\/ Lambdas may be hidden classes, but are named, non-local classes\n","filename":"test\/jdk\/java\/lang\/Class\/attributes\/ClassAttributesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8046903\n- * @summary VM anonymous class members can't be statically invocable\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n- * @run junit test.java.lang.invoke.VMAnonymousClass\n- *\/\n-package test.java.lang.invoke;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import org.junit.Test;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.org.objectweb.asm.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-public class VMAnonymousClass {\n-    public static void main(String[] args) throws Throwable {\n-        VMAnonymousClass test = new VMAnonymousClass();\n-        test.testJavaLang();\n-        test.testJavaUtil();\n-        test.testJdkInternalMisc();\n-        test.testJavaLangInvoke();\n-        test.testProhibitedJavaPkg();\n-        System.out.println(\"TEST PASSED\");\n-    }\n-\n-    \/\/ Test VM anonymous classes from different packages\n-    \/\/ (see j.l.i.InvokerBytecodeGenerator::isStaticallyInvocable).\n-    @Test public void testJavaLang()        throws Throwable { test(\"java\/lang\");         }\n-    @Test public void testJavaUtil()        throws Throwable { test(\"java\/util\");         }\n-    @Test public void testJdkInternalMisc() throws Throwable { test(\"jdk\/internal\/misc\"); }\n-    @Test public void testJavaLangInvoke()  throws Throwable { test(\"java\/lang\/invoke\");  }\n-    @Test public void testProhibitedJavaPkg() throws Throwable {\n-       try {\n-           test(\"java\/prohibited\");\n-       } catch (IllegalArgumentException e) {\n-           return;\n-       }\n-       throw new RuntimeException(\"Expected SecurityException\");\n-     }\n-\n-    private static Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    private static void test(String pkg) throws Throwable {\n-        byte[] bytes = dumpClass(pkg);\n-        Class host_class;\n-        if (pkg.equals(\"java\/prohibited\")) {\n-            VMAnonymousClass sampleclass = new VMAnonymousClass();\n-            host_class = (Class)sampleclass.getClass();\n-        } else if (pkg.equals(\"java\/lang\")) {\n-          host_class = Object.class;\n-        } else if (pkg.equals(\"java\/util\")) {\n-            host_class = java.util.ArrayList.class;\n-        } else if (pkg.equals(\"jdk\/internal\/misc\")) {\n-            host_class = jdk.internal.misc.Signal.class;\n-        } else if (pkg.equals(\"java\/lang\/invoke\")) {\n-            host_class = java.lang.invoke.CallSite.class;\n-        } else {\n-            throw new RuntimeException(\"Unexpected pkg: \" + pkg);\n-        }\n-        \/\/ Define VM anonymous class\n-        Class anonClass = unsafe.defineAnonymousClass(host_class, bytes, null);\n-\n-        MethodType t = MethodType.methodType(Object.class, int.class);\n-        MethodHandle target = MethodHandles.lookup().findStatic(anonClass, \"get\", t);\n-\n-        \/\/ Wrap target into LF (convert) to get \"target\" referenced from LF\n-        MethodHandle wrappedMH = target.asType(MethodType.methodType(Object.class, Integer.class));\n-\n-        \/\/ Invoke enough times to provoke LF compilation to bytecode.\n-        for (int i = 0; i<100; i++) {\n-            Object r = wrappedMH.invokeExact((Integer)1);\n-        }\n-    }\n-\n-    \/*\n-     * Constructs bytecode for the following class:\n-     * public class pkg.MyClass {\n-     *     MyClass() {}\n-     *     public Object get(int i) { return null; }\n-     * }\n-     *\/\n-    public static byte[] dumpClass(String pkg) {\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_SUPER | ACC_PUBLIC, pkg+\"\/MyClass\", null, \"java\/lang\/Object\", null);\n-        {\n-            mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"get\", \"(I)Ljava\/lang\/Object;\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/VMAnonymousClass.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8058575\n- * @summary Test that bad host classes cause exceptions to get thrown.\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.org.objectweb.asm\n- * @run main TestBadHostClass\n- *\/\n-\n-\n-import java.lang.*;\n-import java.lang.reflect.Field;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-\/\/ Test that bad host classes cause exceptions.\n-public class TestBadHostClass {\n-\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    private static String packageName(Class<?> c) {\n-        if (c.isArray()) {\n-            return packageName(c.getComponentType());\n-        } else {\n-            String name = c.getName();\n-            int dot = name.lastIndexOf('.');\n-            if (dot == -1) return \"\";\n-            return name.substring(0, dot);\n-        }\n-    }\n-\n-    private static int constantPoolSize(byte[] classFile) {\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n-    static public void badHostClass(Class<?> hostClass) {\n-        \/\/ choose a class name in the same package as the host class\n-        String className;\n-        if (hostClass != null) {\n-            String prefix = packageName(hostClass);\n-            if (prefix.length() > 0)\n-                prefix = prefix.replace('.', '\/') + \"\/\";\n-            className = prefix + \"Anon\";\n-        } else {\n-           className = \"Anon\";\n-        }\n-\n-        \/\/ create the class\n-        String superName = \"java\/lang\/Object\";\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V1_8, ACC_PUBLIC + ACC_FINAL + ACC_SUPER,\n-                 className, null, superName, null);\n-        byte[] classBytes = cw.toByteArray();\n-        int cpPoolSize = constantPoolSize(classBytes);\n-        Class<?> anonClass\n-            = unsafe.defineAnonymousClass(hostClass, classBytes, new Object[cpPoolSize]);\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        \/\/ host class is an array of java.lang.Objects.\n-        try {\n-            badHostClass(Object[].class);\n-        } catch (IllegalArgumentException ex) {\n-        }\n-\n-        \/\/ host class is an array of objects of this class.\n-        try {\n-            badHostClass(TestBadHostClass[].class);\n-        } catch (IllegalArgumentException ex) {\n-        }\n-\n-        \/\/ host class is null.\n-        try {\n-            badHostClass(null);\n-        } catch (NullPointerException ex) {\n-        }\n-\n-        \/\/ host class is a primitive array class.\n-        try {\n-            badHostClass(int[].class);\n-        } catch (IllegalArgumentException ex) {\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/misc\/Unsafe\/TestBadHostClass.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 7194897\n- * @summary JSR 292: Cannot create more than 16 instances of an anonymous class\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @library \/test\/lib\n- * @author  Robert Field\n- * @compile -XDignore.symbol.file ManyNewInstanceAnonTest.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller ManyNewInstanceAnonTest\n- * @run main\/othervm -Xbootclasspath\/a:. -Xverify:all ManyNewInstanceAnonTest\n- * @run main\/othervm -Xbootclasspath\/a:. -Xverify:all -Dsun.reflection.noInflation=true ManyNewInstanceAnonTest\n- *\/\n-import java.io.ByteArrayOutputStream;\n-import java.io.InputStream;\n-import jdk.internal.misc.Unsafe;\n-\n-public class ManyNewInstanceAnonTest {\n-\n-    static final int REPS = 20;\n-    static final Class<?> klass = ManyNewInstanceAnonTest.class;\n-\n-    public static void main(String[] args) throws Exception {\n-        Class<?> c = Unsafe.getUnsafe().defineAnonymousClass(klass, readClassFile(), null);\n-        for (int i = 0; i < REPS; ++i) {\n-            System.out.printf(\"%d: %s\\n\", i, c.newInstance());\n-        }\n-        System.out.println(\"Passed.\");\n-    }\n-\n-    private static byte[] readClassFile() throws Exception {\n-        try (InputStream in = klass.getResourceAsStream(klass.getSimpleName() + \".class\");\n-             ByteArrayOutputStream out = new ByteArrayOutputStream())\n-        {\n-            int b;\n-            while ((b = in.read()) != -1) {\n-                out.write(b);\n-            }\n-            return out.toByteArray();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/reflect\/AnonymousNewInstance\/ManyNewInstanceAnonTest.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-                \/\/ Hidden classes stats include both hidden and unsafe anonymous classes.\n-                Events.assertField(event, \"hiddenClassCount\").equal(4L);\n+                Events.assertField(event, \"hiddenClassCount\").equal(2L);\n@@ -100,2 +99,2 @@\n-        \/\/ Compile a class for method createNonFindableClasses() to use to create both a\n-        \/\/ weak hidden class and an anonymous class.\n+        \/\/ Compile a class for method createNonFindableClasses() to use to create a\n+        \/\/ non-strong hidden class.\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestClassLoaderStatsEvent.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import jdk.internal.misc.Unsafe;\n-\n@@ -95,5 +93,0 @@\n-\n-        \/\/ Create an Unsafe anonymous class and an array of unsafe anonymous classes.\n-        Unsafe unsafe = Unsafe.getUnsafe();\n-        Class<?> clu = unsafe.defineAnonymousClass(TestClass.class, klassbuf, new Object[0]);\n-        final Class<?> arrayOfUAC = Array.newInstance(clu, 15).getClass();\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestClasses.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,39 +288,0 @@\n-    @State(Scope.Thread)\n-    @Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-    @Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-    @Fork(3)\n-    @BenchmarkMode(Mode.AverageTime)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public static class UnsafeAnonymousClass {\n-        static final sun.misc.Unsafe unsafe = getUnsafe();\n-\n-        private static final MethodHandles.Lookup lookup =\n-                defineHostClass(new Loader(\"anonymous-class-loader\"),\"foo.AnonymousHost\", FOO_HOST_BYTES);\n-\n-        @SuppressWarnings(\"removal\")\n-        @Benchmark\n-        public Class<?> load() throws ClassNotFoundException {\n-            return unsafe.defineAnonymousClass(lookup.lookupClass(), X_BYTECODE, null);\n-        }\n-\n-        public static void main(String[] args) throws RunnerException {\n-            Options opt = new OptionsBuilder()\n-                    .include(LookupDefineClass.UnsafeAnonymousClass.class.getSimpleName())\n-                    \/\/ .addProfiler(ClassloaderProfiler.class)\n-                    \/\/ .addProfiler(CompilerProfiler.class)\n-                    .build();\n-\n-            new Runner(opt).run();\n-        }\n-    }\n-\n-    static sun.misc.Unsafe getUnsafe() {\n-        try {\n-            Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n-            f.setAccessible(true);\n-            return (sun.misc.Unsafe)f.get(null);\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LookupDefineClass.java","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"}]}