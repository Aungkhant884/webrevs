{"files":[{"patch":"@@ -2202,1 +2202,2 @@\n-        long flags = adjustFieldFlags(nextChar());\n+        char rawFlags = nextChar();\n+        long flags = adjustFieldFlags(rawFlags);\n@@ -2207,0 +2208,3 @@\n+        if (Integer.bitCount(rawFlags & (PUBLIC | PRIVATE | PROTECTED)) > 1 ||\n+            Integer.bitCount(rawFlags & (FINAL | VOLATILE)) > 1)\n+            throw badClassFile(\"illegal.flag.combo\", String.format(\"0x%04x\", (int)rawFlags), \"field\", v);\n@@ -2213,1 +2217,2 @@\n-        long flags = adjustMethodFlags(nextChar());\n+        char rawFlags = nextChar();\n+        long flags = adjustMethodFlags(rawFlags);\n@@ -2262,0 +2267,2 @@\n+        if (Integer.bitCount(rawFlags & (PUBLIC | PRIVATE | PROTECTED)) > 1)\n+            throw badClassFile(\"illegal.flag.combo\", String.format(\"0x%04x\", (int)rawFlags), \"method\", m);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2495,0 +2495,3 @@\n+compiler.misc.illegal.flag.combo=\\\n+    class file contains illegal flag combination {0} for {1} {2}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/\/\n+\/\/  class BadFieldFlags {\n+\/\/      protected int my_field;\n+\/\/  }\n+\/\/\n+class BadFieldFlags {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  63; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"BadFieldFlags\"; \/\/ #8\n+    Utf8 \"my_field\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"BadFieldFlags.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0006; \/\/ access *** SHOULD BE 0x0004 ***\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class BadFieldFlags\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadFieldFlags.jcod","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8219810\n+ * @summary Verify ClassReader detects invalid field access flags combinations\n+ * @build BadFieldFlags\n+ * @compile\/fail\/ref=BadFieldFlagsTest.out -XDrawDiagnostics BadFieldFlagsTest.java\n+ *\/\n+public class BadFieldFlagsTest {\n+    {\n+        System.out.println(new BadFieldFlags().my_field);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadFieldFlagsTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+BadFieldFlagsTest.java:10:32: compiler.err.cant.access: BadFieldFlags, (compiler.misc.bad.class.file.header: BadFieldFlags.class, (compiler.misc.illegal.flag.combo: 0x0006, field, my_field))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadFieldFlagsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/\/\n+\/\/  class BadMethodFlags {\n+\/\/      protected native int my_method();\n+\/\/  }\n+\/\/\n+class BadMethodFlags {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  63; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"BadMethodFlags\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"my_method\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"BadMethodFlags.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0105; \/\/ access *** SHOULD BE 0x0104 ***\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class BadMethodFlags\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadMethodFlags.jcod","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8219810\n+ * @summary Verify ClassReader detects invalid method access flags combinations\n+ * @build BadMethodFlags\n+ * @compile\/fail\/ref=BadMethodFlagsTest.out -XDrawDiagnostics BadMethodFlagsTest.java\n+ *\/\n+public class BadMethodFlagsTest {\n+    {\n+        new BadMethodFlags().my_method();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadMethodFlagsTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+BadMethodFlagsTest.java:10:13: compiler.err.cant.access: BadMethodFlags, (compiler.misc.bad.class.file.header: BadMethodFlags.class, (compiler.misc.illegal.flag.combo: 0x0105, method, my_method()))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/classreader\/8219810\/BadMethodFlagsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -69,0 +69,1 @@\n+compiler.misc.illegal.flag.combo                        # ClassReader\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}