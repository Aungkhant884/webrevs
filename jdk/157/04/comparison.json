{"files":[{"patch":"@@ -75,0 +75,1 @@\n+#include \"signals_posix.hpp\"\n@@ -189,4 +190,0 @@\n-static sigset_t check_signal_done;         \/\/ For diagnostics to print a message once (see run_periodic_checks)\n-static bool     check_signals      = true;\n-static int      SR_signum          = SIGUSR2; \/\/ Signal used to suspend\/resume a thread (must be > SIGSEGV, see 4355769)\n-static sigset_t SR_sigset;\n@@ -619,84 +616,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal support\n-\n-debug_only(static bool signal_sets_initialized = false);\n-static sigset_t unblocked_sigs, vm_sigs;\n-\n-void os::Aix::signal_sets_init() {\n-  \/\/ Should also have an assertion stating we are still single-threaded.\n-  assert(!signal_sets_initialized, \"Already initialized\");\n-  \/\/ Fill in signals that are necessarily unblocked for all threads in\n-  \/\/ the VM. Currently, we unblock the following signals:\n-  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n-  \/\/                         by -Xrs (=ReduceSignalUsage));\n-  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n-  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n-  \/\/ the dispositions or masks wrt these signals.\n-  \/\/ Programs embedding the VM that want to use the above signals for their\n-  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n-  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n-  \/\/ (See bug 4345157, and other related bugs).\n-  \/\/ In reality, though, unblocking these signals is really a nop, since\n-  \/\/ these signals are not blocked by default.\n-  sigemptyset(&unblocked_sigs);\n-  sigaddset(&unblocked_sigs, SIGILL);\n-  sigaddset(&unblocked_sigs, SIGSEGV);\n-  sigaddset(&unblocked_sigs, SIGBUS);\n-  sigaddset(&unblocked_sigs, SIGFPE);\n-  sigaddset(&unblocked_sigs, SIGTRAP);\n-  sigaddset(&unblocked_sigs, SR_signum);\n-\n-  if (!ReduceSignalUsage) {\n-   if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n-     sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n-   }\n-   if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n-     sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n-   }\n-   if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n-     sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n-   }\n-  }\n-  \/\/ Fill in signals that are blocked by all but the VM thread.\n-  sigemptyset(&vm_sigs);\n-  if (!ReduceSignalUsage)\n-    sigaddset(&vm_sigs, BREAK_SIGNAL);\n-  debug_only(signal_sets_initialized = true);\n-}\n-\n-\/\/ These are signals that are unblocked while a thread is running Java.\n-\/\/ (For some reason, they get blocked by default.)\n-sigset_t* os::Aix::unblocked_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &unblocked_sigs;\n-}\n-\n-\/\/ These are the signals that are blocked while a (non-VM) thread is\n-\/\/ running Java. Only the VM thread handles these signals.\n-sigset_t* os::Aix::vm_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &vm_sigs;\n-}\n-\n-void os::Aix::hotspot_sigmask(Thread* thread) {\n-\n-  \/\/Save caller's signal mask before setting VM signal mask\n-  sigset_t caller_sigmask;\n-  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n-\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_caller_sigmask(caller_sigmask);\n-\n-  pthread_sigmask(SIG_UNBLOCK, os::Aix::unblocked_signals(), NULL);\n-\n-  if (!ReduceSignalUsage) {\n-    if (thread->is_VM_thread()) {\n-      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n-      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n-    } else {\n-      \/\/ ... all other threads block BREAK_SIGNAL\n-      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n-    }\n-  }\n-}\n-\n@@ -822,1 +735,1 @@\n-  os::Aix::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -989,1 +902,1 @@\n-  os::Aix::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -1529,3 +1442,0 @@\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen);\n-\n@@ -1534,12 +1444,12 @@\n-  print_signal_handler(st, SIGSEGV, buf, buflen);\n-  print_signal_handler(st, SIGBUS , buf, buflen);\n-  print_signal_handler(st, SIGFPE , buf, buflen);\n-  print_signal_handler(st, SIGPIPE, buf, buflen);\n-  print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  print_signal_handler(st, SIGILL , buf, buflen);\n-  print_signal_handler(st, SR_signum, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n-  print_signal_handler(st, SIGTRAP, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SR_signum, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGTRAP, buf, buflen);\n@@ -1548,1 +1458,1 @@\n-  print_signal_handler(st, SIGDANGER, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGDANGER, buf, buflen);\n@@ -1643,183 +1553,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ sun.misc.Signal support\n-\n-static void\n-UserHandler(int sig, void *siginfo, void *context) {\n-  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n-  \/\/ handler fails to abort. Let VM die immediately.\n-  if (sig == SIGINT && VMError::is_error_reported()) {\n-    os::die();\n-  }\n-\n-  os::signal_notify(sig);\n-}\n-\n-void* os::user_handler() {\n-  return CAST_FROM_FN_PTR(void*, UserHandler);\n-}\n-\n-extern \"C\" {\n-  typedef void (*sa_handler_t)(int);\n-  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n-}\n-\n-void* os::signal(int signal_number, void* handler) {\n-  struct sigaction sigAct, oldSigAct;\n-\n-  sigfillset(&(sigAct.sa_mask));\n-\n-  \/\/ Do not block out synchronous signals in the signal handler.\n-  \/\/ Blocking synchronous signals only makes sense if you can really\n-  \/\/ be sure that those signals won't happen during signal handling,\n-  \/\/ when the blocking applies. Normal signal handlers are lean and\n-  \/\/ do not cause signals. But our signal handlers tend to be \"risky\"\n-  \/\/ - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n-  \/\/ On AIX, PASE there was a case where a SIGSEGV happened, followed\n-  \/\/ by a SIGILL, which was blocked due to the signal mask. The process\n-  \/\/ just hung forever. Better to crash from a secondary signal than to hang.\n-  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n-  sigdelset(&(sigAct.sa_mask), SIGBUS);\n-  sigdelset(&(sigAct.sa_mask), SIGILL);\n-  sigdelset(&(sigAct.sa_mask), SIGFPE);\n-  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n-\n-  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n-\n-  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n-\n-  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n-    \/\/ -1 means registration failed\n-    return (void *)-1;\n-  }\n-\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n-}\n-\n-void os::signal_raise(int signal_number) {\n-  ::raise(signal_number);\n-}\n-\n-\/\/\n-\/\/ The following code is moved from os.cpp for making this\n-\/\/ code platform specific, which it is by its very nature.\n-\/\/\n-\n-\/\/ Will be modified when max signal is changed to be dynamic\n-int os::sigexitnum_pd() {\n-  return NSIG;\n-}\n-\n-\/\/ a counter for each possible signal value\n-static volatile jint pending_signals[NSIG+1] = { 0 };\n-\n-\/\/ Wrapper functions for: sem_init(), sem_post(), sem_wait()\n-\/\/ On AIX, we use sem_init(), sem_post(), sem_wait()\n-\/\/ On Pase, we need to use msem_lock() and msem_unlock(), because Posix Semaphores\n-\/\/ do not seem to work at all on PASE (unimplemented, will cause SIGILL).\n-\/\/ Note that just using msem_.. APIs for both PASE and AIX is not an option either, as\n-\/\/ on AIX, msem_..() calls are suspected of causing problems.\n-static sem_t sig_sem;\n-static msemaphore* p_sig_msem = 0;\n-\n-static void local_sem_init() {\n-  if (os::Aix::on_aix()) {\n-    int rc = ::sem_init(&sig_sem, 0, 0);\n-    guarantee(rc != -1, \"sem_init failed\");\n-  } else {\n-    \/\/ Memory semaphores must live in shared mem.\n-    guarantee0(p_sig_msem == NULL);\n-    p_sig_msem = (msemaphore*)os::reserve_memory(sizeof(msemaphore));\n-    guarantee(p_sig_msem, \"Cannot allocate memory for memory semaphore\");\n-    guarantee(::msem_init(p_sig_msem, 0) == p_sig_msem, \"msem_init failed\");\n-  }\n-}\n-\n-static void local_sem_post() {\n-  static bool warn_only_once = false;\n-  if (os::Aix::on_aix()) {\n-    int rc = ::sem_post(&sig_sem);\n-    if (rc == -1 && !warn_only_once) {\n-      trcVerbose(\"sem_post failed (errno = %d, %s)\", errno, os::errno_name(errno));\n-      warn_only_once = true;\n-    }\n-  } else {\n-    guarantee0(p_sig_msem != NULL);\n-    int rc = ::msem_unlock(p_sig_msem, 0);\n-    if (rc == -1 && !warn_only_once) {\n-      trcVerbose(\"msem_unlock failed (errno = %d, %s)\", errno, os::errno_name(errno));\n-      warn_only_once = true;\n-    }\n-  }\n-}\n-\n-static void local_sem_wait() {\n-  static bool warn_only_once = false;\n-  if (os::Aix::on_aix()) {\n-    int rc = ::sem_wait(&sig_sem);\n-    if (rc == -1 && !warn_only_once) {\n-      trcVerbose(\"sem_wait failed (errno = %d, %s)\", errno, os::errno_name(errno));\n-      warn_only_once = true;\n-    }\n-  } else {\n-    guarantee0(p_sig_msem != NULL); \/\/ must init before use\n-    int rc = ::msem_lock(p_sig_msem, 0);\n-    if (rc == -1 && !warn_only_once) {\n-      trcVerbose(\"msem_lock failed (errno = %d, %s)\", errno, os::errno_name(errno));\n-      warn_only_once = true;\n-    }\n-  }\n-}\n-\n-static void jdk_misc_signal_init() {\n-  \/\/ Initialize signal structures\n-  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n-\n-  \/\/ Initialize signal semaphore\n-  local_sem_init();\n-}\n-\n-void os::signal_notify(int sig) {\n-  Atomic::inc(&pending_signals[sig]);\n-  local_sem_post();\n-}\n-\n-static int check_pending_signals() {\n-  for (;;) {\n-    for (int i = 0; i < NSIG + 1; i++) {\n-      jint n = pending_signals[i];\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n-        return i;\n-      }\n-    }\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-\n-      local_sem_wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        \/\/\n-\n-        local_sem_post();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n-  }\n-}\n-\n-int os::signal_wait() {\n-  return check_pending_signals();\n-}\n-\n@@ -2670,698 +2397,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ suspend\/resume support\n-\n-\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n-\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n-\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n-\/\/\n-\/\/  The remaining code is greatly simplified from the more general suspension\n-\/\/  code that used to be used.\n-\/\/\n-\/\/  The protocol is quite simple:\n-\/\/  - suspend:\n-\/\/      - sends a signal to the target thread\n-\/\/      - polls the suspend state of the osthread using a yield loop\n-\/\/      - target thread signal handler (SR_handler) sets suspend state\n-\/\/        and blocks in sigsuspend until continued\n-\/\/  - resume:\n-\/\/      - sets target osthread state to continue\n-\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n-\/\/\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n-\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n-\/\/  by SR_handler(), so that fetch_frame_from_context() works,\n-\/\/  which in part is used by:\n-\/\/    - Forte Analyzer: AsyncGetCallTrace()\n-\/\/    - StackBanging: get_frame_at_stack_banging_point()\n-\n-static void resume_clear_context(OSThread *osthread) {\n-  osthread->set_ucontext(NULL);\n-  osthread->set_siginfo(NULL);\n-}\n-\n-static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n-  osthread->set_ucontext(context);\n-  osthread->set_siginfo(siginfo);\n-}\n-\n-\/\/\n-\/\/ Handler function invoked when a thread's execution is suspended or\n-\/\/ resumed. We have to be careful that only async-safe functions are\n-\/\/ called here (Note: most pthread functions are not async safe and\n-\/\/ should be avoided.)\n-\/\/\n-\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n-\/\/ interface point of view, but sigwait() prevents the signal hander\n-\/\/ from being run. libpthread would get very confused by not having\n-\/\/ its signal handlers run and prevents sigwait()'s use with the\n-\/\/ mutex granting granting signal.\n-\/\/\n-\/\/ Currently only ever called on the VMThread and JavaThreads (PC sampling).\n-\/\/\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n-  \/\/ Save and restore errno to avoid confusing native code with EINTR\n-  \/\/ after sigsuspend.\n-  int old_errno = errno;\n-\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"Missing current thread in SR_handler\");\n-\n-  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n-  \/\/ mask is changed as part of thread termination. Check that the current thread\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n-  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n-  \/\/ destructor has completed.\n-\n-  if (thread->SR_lock() == NULL) {\n-    return;\n-  }\n-\n-  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n-\n-  OSThread* osthread = thread->osthread();\n-\n-  os::SuspendResume::State current = osthread->sr.state();\n-  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    suspend_save_context(osthread, siginfo, context);\n-\n-    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n-    os::SuspendResume::State state = osthread->sr.suspended();\n-    if (state == os::SuspendResume::SR_SUSPENDED) {\n-      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n-      sigemptyset(&suspend_set);\n-      \/\/ get current set of blocked signals and unblock resume signal\n-      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n-      sigdelset(&suspend_set, SR_signum);\n-\n-      \/\/ wait here until we are resumed\n-      while (1) {\n-        sigsuspend(&suspend_set);\n-\n-        os::SuspendResume::State result = osthread->sr.running();\n-        if (result == os::SuspendResume::SR_RUNNING) {\n-          break;\n-        }\n-      }\n-\n-    } else if (state == os::SuspendResume::SR_RUNNING) {\n-      \/\/ request was cancelled, continue\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-\n-    resume_clear_context(osthread);\n-  } else if (current == os::SuspendResume::SR_RUNNING) {\n-    \/\/ request was cancelled, continue\n-  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ ignore\n-  } else {\n-    ShouldNotReachHere();\n-  }\n-\n-  errno = old_errno;\n-}\n-\n-static int SR_initialize() {\n-  struct sigaction act;\n-  char *s;\n-  \/\/ Get signal number to use for suspend\/resume\n-  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n-    int sig = ::strtol(s, 0, 10);\n-    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n-        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n-      SR_signum = sig;\n-    } else {\n-      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n-    }\n-  }\n-\n-  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n-        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n-\n-  sigemptyset(&SR_sigset);\n-  sigaddset(&SR_sigset, SR_signum);\n-\n-  \/\/ Set up signal handler for suspend\/resume.\n-  act.sa_flags = SA_RESTART|SA_SIGINFO;\n-  act.sa_handler = (void (*)(int)) SR_handler;\n-\n-  \/\/ SR_signum is blocked by default.\n-  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n-\n-  if (sigaction(SR_signum, &act, 0) == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ Save signal flag\n-  os::Aix::set_our_sigflags(SR_signum, act.sa_flags);\n-  return 0;\n-}\n-\n-static int SR_finalize() {\n-  return 0;\n-}\n-\n-static int sr_notify(OSThread* osthread) {\n-  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n-  assert_status(status == 0, status, \"pthread_kill\");\n-  return status;\n-}\n-\n-\/\/ \"Randomly\" selected value for how long we want to spin\n-\/\/ before bailing out on suspending a thread, also how often\n-\/\/ we send a signal to a thread we want to resume\n-static const int RANDOMLY_LARGE_INTEGER = 1000000;\n-static const int RANDOMLY_LARGE_INTEGER2 = 100;\n-\n-\/\/ returns true on success and false on error - really an error is fatal\n-\/\/ but this seems the normal response to library errors\n-static bool do_suspend(OSThread* osthread) {\n-  assert(osthread->sr.is_running(), \"thread should be running\");\n-  \/\/ mark as suspended and send signal\n-\n-  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    \/\/ failed to switch, state wasn't running?\n-    ShouldNotReachHere();\n-    return false;\n-  }\n-\n-  if (sr_notify(osthread) != 0) {\n-    \/\/ try to cancel, switch to running\n-\n-    os::SuspendResume::State result = osthread->sr.cancel_suspend();\n-    if (result == os::SuspendResume::SR_RUNNING) {\n-      \/\/ cancelled\n-      return false;\n-    } else if (result == os::SuspendResume::SR_SUSPENDED) {\n-      \/\/ somehow managed to suspend\n-      return true;\n-    } else {\n-      ShouldNotReachHere();\n-      return false;\n-    }\n-  }\n-\n-  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n-\n-  for (int n = 0; !osthread->sr.is_suspended(); n++) {\n-    for (int i = 0; i < RANDOMLY_LARGE_INTEGER2 && !osthread->sr.is_suspended(); i++) {\n-      os::naked_yield();\n-    }\n-\n-    \/\/ timeout, try to cancel the request\n-    if (n >= RANDOMLY_LARGE_INTEGER) {\n-      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n-      if (cancelled == os::SuspendResume::SR_RUNNING) {\n-        return false;\n-      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n-        return true;\n-      } else {\n-        ShouldNotReachHere();\n-        return false;\n-      }\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n-  return true;\n-}\n-\n-static void do_resume(OSThread* osthread) {\n-  \/\/assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n-\n-  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ failed to switch to WAKEUP_REQUEST\n-    ShouldNotReachHere();\n-    return;\n-  }\n-\n-  while (!osthread->sr.is_running()) {\n-    if (sr_notify(osthread) == 0) {\n-      for (int n = 0; n < RANDOMLY_LARGE_INTEGER && !osthread->sr.is_running(); n++) {\n-        for (int i = 0; i < 100 && !osthread->sr.is_running(); i++) {\n-          os::naked_yield();\n-        }\n-      }\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_running(), \"Must be running!\");\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal handling (except suspend\/resume)\n-\n-\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n-\/\/ The user-defined signal handler must pass unrecognized signals to this\n-\/\/ routine, and if it returns true (non-zero), then the signal handler must\n-\/\/ return immediately. If the flag \"abort_if_unrecognized\" is true, then this\n-\/\/ routine will never retun false (zero), but instead will execute a VM panic\n-\/\/ routine kill the process.\n-\/\/\n-\/\/ If this routine returns false, it is OK to call it again. This allows\n-\/\/ the user-defined signal handler to perform checks either before or after\n-\/\/ the VM performs its own checks. Naturally, the user code would be making\n-\/\/ a serious error if it tried to handle an exception (such as a null check\n-\/\/ or breakpoint) that the VM was generating for its own correct operation.\n-\/\/\n-\/\/ This routine may recognize any of the following kinds of signals:\n-\/\/   SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n-\/\/ It should be consulted by handlers for any of those signals.\n-\/\/\n-\/\/ The caller of this routine must pass in the three arguments supplied\n-\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n-\/\/ field of the structure passed to sigaction(). This routine assumes that\n-\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n-\/\/\n-\/\/ Note that the VM will print warnings if it detects conflicting signal\n-\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n-\/\/\n-extern \"C\" JNIEXPORT int\n-JVM_handle_aix_signal(int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized);\n-\n-\/\/ Set thread signal mask (for some reason on AIX sigthreadmask() seems\n-\/\/ to be the thing to call; documentation is not terribly clear about whether\n-\/\/ pthread_sigmask also works, and if it does, whether it does the same.\n-bool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n-  const int rc = ::pthread_sigmask(how, set, oset);\n-  \/\/ return value semantics differ slightly for error case:\n-  \/\/ pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n-  \/\/ (so, pthread_sigmask is more theadsafe for error handling)\n-  \/\/ But success is always 0.\n-  return rc == 0 ? true : false;\n-}\n-\n-\/\/ Function to unblock all signals which are, according\n-\/\/ to POSIX, typical program error signals. If they happen while being blocked,\n-\/\/ they typically will bring down the process immediately.\n-bool unblock_program_error_signals() {\n-  sigset_t set;\n-  ::sigemptyset(&set);\n-  ::sigaddset(&set, SIGILL);\n-  ::sigaddset(&set, SIGBUS);\n-  ::sigaddset(&set, SIGFPE);\n-  ::sigaddset(&set, SIGSEGV);\n-  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n-}\n-\n-\/\/ Renamed from 'signalHandler' to avoid collision with other shared libs.\n-static void javaSignalHandler(int sig, siginfo_t* info, void* uc) {\n-  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n-\n-  \/\/ Never leave program error signals blocked;\n-  \/\/ on all our platforms they would bring down the process immediately when\n-  \/\/ getting raised while being blocked.\n-  unblock_program_error_signals();\n-\n-  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n-  JVM_handle_aix_signal(sig, info, uc, true);\n-  errno = orig_errno;\n-}\n-\n-\/\/ This boolean allows users to forward their own non-matching signals\n-\/\/ to JVM_handle_aix_signal, harmlessly.\n-bool os::Aix::signal_handlers_are_installed = false;\n-\n-\/\/ For signal-chaining\n-bool os::Aix::libjsig_is_loaded = false;\n-typedef struct sigaction *(*get_signal_t)(int);\n-get_signal_t os::Aix::get_signal_action = NULL;\n-\n-struct sigaction* os::Aix::get_chained_signal_action(int sig) {\n-  struct sigaction *actp = NULL;\n-\n-  if (libjsig_is_loaded) {\n-    \/\/ Retrieve the old signal handler from libjsig\n-    actp = (*get_signal_action)(sig);\n-  }\n-  if (actp == NULL) {\n-    \/\/ Retrieve the preinstalled signal handler from jvm\n-    actp = os::Posix::get_preinstalled_handler(sig);\n-  }\n-\n-  return actp;\n-}\n-\n-static bool call_chained_handler(struct sigaction *actp, int sig,\n-                                 siginfo_t *siginfo, void *context) {\n-  \/\/ Call the old signal handler\n-  if (actp->sa_handler == SIG_DFL) {\n-    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n-    \/\/ instead of taking the default action.\n-    return false;\n-  } else if (actp->sa_handler != SIG_IGN) {\n-    if ((actp->sa_flags & SA_NODEFER) == 0) {\n-      \/\/ automaticlly block the signal\n-      sigaddset(&(actp->sa_mask), sig);\n-    }\n-\n-    sa_handler_t hand = NULL;\n-    sa_sigaction_t sa = NULL;\n-    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n-    \/\/ retrieve the chained handler\n-    if (siginfo_flag_set) {\n-      sa = actp->sa_sigaction;\n-    } else {\n-      hand = actp->sa_handler;\n-    }\n-\n-    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n-      actp->sa_handler = SIG_DFL;\n-    }\n-\n-    \/\/ try to honor the signal mask\n-    sigset_t oset;\n-    sigemptyset(&oset);\n-    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n-\n-    \/\/ call into the chained handler\n-    if (siginfo_flag_set) {\n-      (*sa)(sig, siginfo, context);\n-    } else {\n-      (*hand)(sig);\n-    }\n-\n-    \/\/ restore the signal mask\n-    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n-  }\n-  \/\/ Tell jvm's signal handler the signal is taken care of.\n-  return true;\n-}\n-\n-bool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n-  bool chained = false;\n-  \/\/ signal-chaining\n-  if (UseSignalChaining) {\n-    struct sigaction *actp = get_chained_signal_action(sig);\n-    if (actp != NULL) {\n-      chained = call_chained_handler(actp, sig, siginfo, context);\n-    }\n-  }\n-  return chained;\n-}\n-\n-\/\/ for diagnostic\n-int sigflags[NSIG];\n-\n-int os::Aix::get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-void os::Aix::set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n-void os::Aix::set_signal_handler(int sig, bool set_installed) {\n-  \/\/ Check for overwrite.\n-  struct sigaction oldAct;\n-  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n-\n-  void* oldhand = oldAct.sa_sigaction\n-    ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-    : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n-    if (AllowUserSignalHandlers || !set_installed) {\n-      \/\/ Do not overwrite; user takes responsibility to forward to us.\n-      return;\n-    } else if (UseSignalChaining) {\n-      \/\/ save the old handler in jvm\n-      os::Posix::save_preinstalled_handler(sig, oldAct);\n-      \/\/ libjsig also interposes the sigaction() call below and saves the\n-      \/\/ old sigaction on it own.\n-    } else {\n-      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n-            \"%#lx for signal %d.\", (long)oldhand, sig);\n-    }\n-  }\n-\n-  struct sigaction sigAct;\n-  sigfillset(&(sigAct.sa_mask));\n-  if (!set_installed) {\n-    sigAct.sa_handler = SIG_DFL;\n-    sigAct.sa_flags = SA_RESTART;\n-  } else {\n-    sigAct.sa_sigaction = javaSignalHandler;\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  }\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n-\n-  int ret = sigaction(sig, &sigAct, &oldAct);\n-  assert(ret == 0, \"check\");\n-\n-  void* oldhand2 = oldAct.sa_sigaction\n-                 ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-                 : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n-  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n-}\n-\n-\/\/ install signal handlers for signals that HotSpot needs to\n-\/\/ handle in order to support Java-level exception handling.\n-void os::Aix::install_signal_handlers() {\n-  if (!signal_handlers_are_installed) {\n-    signal_handlers_are_installed = true;\n-\n-    \/\/ signal-chaining\n-    typedef void (*signal_setting_t)();\n-    signal_setting_t begin_signal_setting = NULL;\n-    signal_setting_t end_signal_setting = NULL;\n-    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n-    if (begin_signal_setting != NULL) {\n-      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n-      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n-                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n-      libjsig_is_loaded = true;\n-      assert(UseSignalChaining, \"should enable signal-chaining\");\n-    }\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm is setting signal handlers.\n-      (*begin_signal_setting)();\n-    }\n-\n-    set_signal_handler(SIGSEGV, true);\n-    set_signal_handler(SIGPIPE, true);\n-    set_signal_handler(SIGBUS, true);\n-    set_signal_handler(SIGILL, true);\n-    set_signal_handler(SIGFPE, true);\n-    set_signal_handler(SIGTRAP, true);\n-    set_signal_handler(SIGXFSZ, true);\n-\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm finishes setting signal handlers.\n-      (*end_signal_setting)();\n-    }\n-\n-    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n-    \/\/ and if UserSignalHandler is installed all bets are off.\n-    \/\/ Log that signal checking is off only if -verbose:jni is specified.\n-    if (CheckJNICalls) {\n-      if (libjsig_is_loaded) {\n-        tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      if (AllowUserSignalHandlers) {\n-        tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      \/\/ Need to initialize check_signal_done.\n-      ::sigemptyset(&check_signal_done);\n-    }\n-  }\n-}\n-\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-    \/\/ The way os::dll_address_to_library_name is implemented on Aix\n-    \/\/ right now, it always returns -1 for the offset which is not\n-    \/\/ terribly informative.\n-    \/\/ Will fix that. For now, omit the offset.\n-    jio_snprintf(buf, buflen, \"%s\", p1);\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n-}\n-\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-  sigaction(sig, NULL, &sa);\n-\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n-\n-  address handler = (sa.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n-    st->print(\"SIG_DFL\");\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n-    st->print(\"SIG_IGN\");\n-  } else {\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n-  }\n-\n-  \/\/ Print readable mask.\n-  st->print(\", sa_mask[0]=\");\n-  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n-\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n-  }\n-\n-  \/\/ Print textual representation of sa_flags.\n-  st->print(\", sa_flags=\");\n-  os::Posix::print_sa_flags(st, sa.sa_flags);\n-\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler.\n-    \/\/ Check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != os::Aix::get_our_sigflags(sig)) {\n-      st->print(\", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                os::Aix::get_our_sigflags(sig));\n-    }\n-  }\n-  st->cr();\n-}\n-\n-#define DO_SIGNAL_CHECK(sig) \\\n-  if (!sigismember(&check_signal_done, sig)) \\\n-    os::Aix::check_signal_handler(sig)\n-\n-\/\/ This method is a periodic task to check for misbehaving JNI applications\n-\/\/ under CheckJNI, we can add any periodic checks here\n-\n-void os::run_periodic_checks() {\n-\n-  if (check_signals == false) return;\n-\n-  \/\/ SEGV and BUS if overridden could potentially prevent\n-  \/\/ generation of hs*.log in the event of a crash, debugging\n-  \/\/ such a case can be very challenging, so we absolutely\n-  \/\/ check the following for a good measure:\n-  DO_SIGNAL_CHECK(SIGSEGV);\n-  DO_SIGNAL_CHECK(SIGILL);\n-  DO_SIGNAL_CHECK(SIGFPE);\n-  DO_SIGNAL_CHECK(SIGBUS);\n-  DO_SIGNAL_CHECK(SIGPIPE);\n-  DO_SIGNAL_CHECK(SIGXFSZ);\n-  if (UseSIGTRAP) {\n-    DO_SIGNAL_CHECK(SIGTRAP);\n-  }\n-\n-  \/\/ ReduceSignalUsage allows the user to override these handlers\n-  \/\/ see comments at the very top and jvm_md.h\n-  if (!ReduceSignalUsage) {\n-    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n-    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n-  }\n-\n-  DO_SIGNAL_CHECK(SR_signum);\n-}\n-\n-typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n-\n-static os_sigaction_t os_sigaction = NULL;\n-\n-void os::Aix::check_signal_handler(int sig) {\n-  char buf[O_BUFLEN];\n-  address jvmHandler = NULL;\n-\n-  struct sigaction act;\n-  if (os_sigaction == NULL) {\n-    \/\/ only trust the default sigaction, in case it has been interposed\n-    os_sigaction = CAST_TO_FN_PTR(os_sigaction_t, dlsym(RTLD_DEFAULT, \"sigaction\"));\n-    if (os_sigaction == NULL) return;\n-  }\n-\n-  os_sigaction(sig, (struct sigaction*)NULL, &act);\n-\n-  address thisHandler = (act.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, act.sa_handler);\n-\n-  switch(sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)user_handler();\n-    break;\n-\n-  default:\n-    if (sig == SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n-\n-  if (thisHandler != jvmHandler) {\n-    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n-                    exception_name(sig, buf, O_BUFLEN));\n-    }\n-  } else if (os::Aix::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Aix::get_our_sigflags(sig)) {\n-    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    os::Posix::print_sa_flags(tty, os::Aix::get_our_sigflags(sig));\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    os::Posix::print_sa_flags(tty, act.sa_flags);\n-    tty->cr();\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-  }\n-\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n-    print_signal_handlers(tty, buf, O_BUFLEN);\n-  }\n-}\n-\n@@ -3515,1 +2544,1 @@\n-  if (SR_initialize() != 0) {\n+  if (PosixSignals::SR_initialize() != 0) {\n@@ -3520,2 +2549,2 @@\n-  Aix::signal_sets_init();\n-  Aix::install_signal_handlers();\n+  PosixSignals::signal_sets_init();\n+  PosixSignals::install_signal_handlers();\n@@ -3524,1 +2553,1 @@\n-    jdk_misc_signal_init();\n+    PosixSignals::jdk_misc_signal_init();\n@@ -3597,1 +2626,1 @@\n-  if (do_suspend(_thread->osthread())) {\n+  if (PosixSignals::do_suspend(_thread->osthread())) {\n@@ -3600,1 +2629,1 @@\n-    do_resume(_thread->osthread());\n+    PosixSignals::do_resume(_thread->osthread());\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":22,"deletions":993,"binary":false,"changes":1015,"status":"modified"},{"patch":"@@ -37,6 +37,0 @@\n-  static bool libjsig_is_loaded;        \/\/ libjsig that interposes sigaction(),\n-                                        \/\/ __sigaction(), signal() is loaded\n-  static struct sigaction *(*get_signal_action)(int);\n-\n-  static void check_signal_handler(int sig);\n-\n@@ -92,1 +86,0 @@\n-  static void hotspot_sigmask(Thread* thread);\n@@ -110,17 +103,0 @@\n-  \/\/ This boolean allows users to forward their own non-matching signals\n-  \/\/ to JVM_handle_aix_signal, harmlessly.\n-  static bool signal_handlers_are_installed;\n-\n-  static int get_our_sigflags(int);\n-  static void set_our_sigflags(int, int);\n-  static void signal_sets_init();\n-  static void install_signal_handlers();\n-  static void set_signal_handler(int, bool);\n-\n-  static sigset_t* unblocked_signals();\n-  static sigset_t* vm_signals();\n-\n-  \/\/ For signal-chaining\n-  static struct sigaction *get_chained_signal_action(int sig);\n-  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n-\n@@ -207,1 +183,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"signals_posix.hpp\"\n@@ -134,10 +135,0 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n-\n-\/\/ Signal number used to suspend\/resume a thread\n-\n-\/\/ do not use any signal number less than SIGSEGV, see 4355769\n-static int SR_signum = SIGUSR2;\n-sigset_t SR_sigset;\n-\n@@ -155,2 +146,0 @@\n-static int SR_initialize();\n-\n@@ -545,87 +534,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal support\n-\n-debug_only(static bool signal_sets_initialized = false);\n-static sigset_t unblocked_sigs, vm_sigs;\n-\n-void os::Bsd::signal_sets_init() {\n-  \/\/ Should also have an assertion stating we are still single-threaded.\n-  assert(!signal_sets_initialized, \"Already initialized\");\n-  \/\/ Fill in signals that are necessarily unblocked for all threads in\n-  \/\/ the VM. Currently, we unblock the following signals:\n-  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n-  \/\/                         by -Xrs (=ReduceSignalUsage));\n-  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n-  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n-  \/\/ the dispositions or masks wrt these signals.\n-  \/\/ Programs embedding the VM that want to use the above signals for their\n-  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n-  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n-  \/\/ (See bug 4345157, and other related bugs).\n-  \/\/ In reality, though, unblocking these signals is really a nop, since\n-  \/\/ these signals are not blocked by default.\n-  sigemptyset(&unblocked_sigs);\n-  sigaddset(&unblocked_sigs, SIGILL);\n-  sigaddset(&unblocked_sigs, SIGSEGV);\n-  sigaddset(&unblocked_sigs, SIGBUS);\n-  sigaddset(&unblocked_sigs, SIGFPE);\n-  sigaddset(&unblocked_sigs, SR_signum);\n-\n-  if (!ReduceSignalUsage) {\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n-\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n-    }\n-  }\n-  \/\/ Fill in signals that are blocked by all but the VM thread.\n-  sigemptyset(&vm_sigs);\n-  if (!ReduceSignalUsage) {\n-    sigaddset(&vm_sigs, BREAK_SIGNAL);\n-  }\n-  debug_only(signal_sets_initialized = true);\n-\n-}\n-\n-\/\/ These are signals that are unblocked while a thread is running Java.\n-\/\/ (For some reason, they get blocked by default.)\n-sigset_t* os::Bsd::unblocked_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &unblocked_sigs;\n-}\n-\n-\/\/ These are the signals that are blocked while a (non-VM) thread is\n-\/\/ running Java. Only the VM thread handles these signals.\n-sigset_t* os::Bsd::vm_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &vm_sigs;\n-}\n-\n-void os::Bsd::hotspot_sigmask(Thread* thread) {\n-\n-  \/\/Save caller's signal mask before setting VM signal mask\n-  sigset_t caller_sigmask;\n-  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n-\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_caller_sigmask(caller_sigmask);\n-\n-  pthread_sigmask(SIG_UNBLOCK, os::Bsd::unblocked_signals(), NULL);\n-\n-  if (!ReduceSignalUsage) {\n-    if (thread->is_VM_thread()) {\n-      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n-      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n-    } else {\n-      \/\/ ... all other threads block BREAK_SIGNAL\n-      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n-    }\n-  }\n-}\n-\n-\n@@ -675,1 +577,1 @@\n-  os::Bsd::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -832,1 +734,1 @@\n-  os::Bsd::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -1640,3 +1542,0 @@\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen);\n-\n@@ -1645,11 +1544,11 @@\n-  print_signal_handler(st, SIGSEGV, buf, buflen);\n-  print_signal_handler(st, SIGBUS , buf, buflen);\n-  print_signal_handler(st, SIGFPE , buf, buflen);\n-  print_signal_handler(st, SIGPIPE, buf, buflen);\n-  print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  print_signal_handler(st, SIGILL , buf, buflen);\n-  print_signal_handler(st, SR_signum, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SR_signum, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n@@ -1768,108 +1667,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ sun.misc.Signal support\n-\n-static void UserHandler(int sig, void *siginfo, void *context) {\n-  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n-  \/\/ handler fails to abort. Let VM die immediately.\n-  if (sig == SIGINT && VMError::is_error_reported()) {\n-    os::die();\n-  }\n-\n-  os::signal_notify(sig);\n-}\n-\n-void* os::user_handler() {\n-  return CAST_FROM_FN_PTR(void*, UserHandler);\n-}\n-\n-extern \"C\" {\n-  typedef void (*sa_handler_t)(int);\n-  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n-}\n-\n-void* os::signal(int signal_number, void* handler) {\n-  struct sigaction sigAct, oldSigAct;\n-\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n-  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n-\n-  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n-    \/\/ -1 means registration failed\n-    return (void *)-1;\n-  }\n-\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n-}\n-\n-void os::signal_raise(int signal_number) {\n-  ::raise(signal_number);\n-}\n-\n-\/\/ The following code is moved from os.cpp for making this\n-\/\/ code platform specific, which it is by its very nature.\n-\n-\/\/ Will be modified when max signal is changed to be dynamic\n-int os::sigexitnum_pd() {\n-  return NSIG;\n-}\n-\n-\/\/ a counter for each possible signal value\n-static volatile jint pending_signals[NSIG+1] = { 0 };\n-static Semaphore* sig_sem = NULL;\n-\n-static void jdk_misc_signal_init() {\n-  \/\/ Initialize signal structures\n-  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n-\n-  \/\/ Initialize signal semaphore\n-  sig_sem = new Semaphore();\n-}\n-\n-void os::signal_notify(int sig) {\n-  if (sig_sem != NULL) {\n-    Atomic::inc(&pending_signals[sig]);\n-    sig_sem->signal();\n-  } else {\n-    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n-    \/\/ initialization isn't called.\n-    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n-  }\n-}\n-\n-static int check_pending_signals() {\n-  for (;;) {\n-    for (int i = 0; i < NSIG + 1; i++) {\n-      jint n = pending_signals[i];\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n-        return i;\n-      }\n-    }\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n-  }\n-}\n-\n-int os::signal_wait() {\n-  return check_pending_signals();\n-}\n-\n@@ -2307,716 +2098,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ suspend\/resume support\n-\n-\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n-\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n-\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n-\/\/\n-\/\/  The remaining code is greatly simplified from the more general suspension\n-\/\/  code that used to be used.\n-\/\/\n-\/\/  The protocol is quite simple:\n-\/\/  - suspend:\n-\/\/      - sends a signal to the target thread\n-\/\/      - polls the suspend state of the osthread using a yield loop\n-\/\/      - target thread signal handler (SR_handler) sets suspend state\n-\/\/        and blocks in sigsuspend until continued\n-\/\/  - resume:\n-\/\/      - sets target osthread state to continue\n-\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n-\/\/\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n-\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n-\/\/  by SR_handler(), so that fetch_frame_from_context() works,\n-\/\/  which in part is used by:\n-\/\/    - Forte Analyzer: AsyncGetCallTrace()\n-\/\/    - StackBanging: get_frame_at_stack_banging_point()\n-\n-static void resume_clear_context(OSThread *osthread) {\n-  osthread->set_ucontext(NULL);\n-  osthread->set_siginfo(NULL);\n-}\n-\n-static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n-  osthread->set_ucontext(context);\n-  osthread->set_siginfo(siginfo);\n-}\n-\n-\/\/ Handler function invoked when a thread's execution is suspended or\n-\/\/ resumed. We have to be careful that only async-safe functions are\n-\/\/ called here (Note: most pthread functions are not async safe and\n-\/\/ should be avoided.)\n-\/\/\n-\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n-\/\/ interface point of view, but sigwait() prevents the signal hander\n-\/\/ from being run. libpthread would get very confused by not having\n-\/\/ its signal handlers run and prevents sigwait()'s use with the\n-\/\/ mutex granting granting signal.\n-\/\/\n-\/\/ Currently only ever called on the VMThread or JavaThread\n-\/\/\n-#ifdef __APPLE__\n-static OSXSemaphore sr_semaphore;\n-#else\n-static PosixSemaphore sr_semaphore;\n-#endif\n-\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n-  \/\/ Save and restore errno to avoid confusing native code with EINTR\n-  \/\/ after sigsuspend.\n-  int old_errno = errno;\n-\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"Missing current thread in SR_handler\");\n-\n-  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n-  \/\/ mask is changed as part of thread termination. Check that the current thread\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n-  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n-  \/\/ destructor has completed.\n-\n-  if (thread->SR_lock() == NULL) {\n-    return;\n-  }\n-\n-  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n-\n-  OSThread* osthread = thread->osthread();\n-\n-  os::SuspendResume::State current = osthread->sr.state();\n-  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    suspend_save_context(osthread, siginfo, context);\n-\n-    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n-    os::SuspendResume::State state = osthread->sr.suspended();\n-    if (state == os::SuspendResume::SR_SUSPENDED) {\n-      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n-\n-      \/\/ get current set of blocked signals and unblock resume signal\n-      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n-      sigdelset(&suspend_set, SR_signum);\n-\n-      sr_semaphore.signal();\n-      \/\/ wait here until we are resumed\n-      while (1) {\n-        sigsuspend(&suspend_set);\n-\n-        os::SuspendResume::State result = osthread->sr.running();\n-        if (result == os::SuspendResume::SR_RUNNING) {\n-          sr_semaphore.signal();\n-          break;\n-        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n-          ShouldNotReachHere();\n-        }\n-      }\n-\n-    } else if (state == os::SuspendResume::SR_RUNNING) {\n-      \/\/ request was cancelled, continue\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-\n-    resume_clear_context(osthread);\n-  } else if (current == os::SuspendResume::SR_RUNNING) {\n-    \/\/ request was cancelled, continue\n-  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ ignore\n-  } else {\n-    \/\/ ignore\n-  }\n-\n-  errno = old_errno;\n-}\n-\n-\n-static int SR_initialize() {\n-  struct sigaction act;\n-  char *s;\n-  \/\/ Get signal number to use for suspend\/resume\n-  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n-    int sig = ::strtol(s, 0, 10);\n-    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n-        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n-      SR_signum = sig;\n-    } else {\n-      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n-    }\n-  }\n-\n-  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n-         \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n-\n-  sigemptyset(&SR_sigset);\n-  sigaddset(&SR_sigset, SR_signum);\n-\n-  \/\/ Set up signal handler for suspend\/resume\n-  act.sa_flags = SA_RESTART|SA_SIGINFO;\n-  act.sa_handler = (void (*)(int)) SR_handler;\n-\n-  \/\/ SR_signum is blocked by default.\n-  \/\/ 4528190 - We also need to block pthread restart signal (32 on all\n-  \/\/ supported Bsd platforms). Note that BsdThreads need to block\n-  \/\/ this signal for all threads to work properly. So we don't have\n-  \/\/ to use hard-coded signal number when setting up the mask.\n-  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n-\n-  if (sigaction(SR_signum, &act, 0) == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ Save signal flag\n-  os::Bsd::set_our_sigflags(SR_signum, act.sa_flags);\n-  return 0;\n-}\n-\n-static int sr_notify(OSThread* osthread) {\n-  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n-  assert_status(status == 0, status, \"pthread_kill\");\n-  return status;\n-}\n-\n-\/\/ \"Randomly\" selected value for how long we want to spin\n-\/\/ before bailing out on suspending a thread, also how often\n-\/\/ we send a signal to a thread we want to resume\n-static const int RANDOMLY_LARGE_INTEGER = 1000000;\n-static const int RANDOMLY_LARGE_INTEGER2 = 100;\n-\n-\/\/ returns true on success and false on error - really an error is fatal\n-\/\/ but this seems the normal response to library errors\n-static bool do_suspend(OSThread* osthread) {\n-  assert(osthread->sr.is_running(), \"thread should be running\");\n-  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n-\n-  \/\/ mark as suspended and send signal\n-  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    \/\/ failed to switch, state wasn't running?\n-    ShouldNotReachHere();\n-    return false;\n-  }\n-\n-  if (sr_notify(osthread) != 0) {\n-    ShouldNotReachHere();\n-  }\n-\n-  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n-  while (true) {\n-    if (sr_semaphore.timedwait(2)) {\n-      break;\n-    } else {\n-      \/\/ timeout\n-      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n-      if (cancelled == os::SuspendResume::SR_RUNNING) {\n-        return false;\n-      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n-        \/\/ make sure that we consume the signal on the semaphore as well\n-        sr_semaphore.wait();\n-        break;\n-      } else {\n-        ShouldNotReachHere();\n-        return false;\n-      }\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n-  return true;\n-}\n-\n-static void do_resume(OSThread* osthread) {\n-  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n-  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n-\n-  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ failed to switch to WAKEUP_REQUEST\n-    ShouldNotReachHere();\n-    return;\n-  }\n-\n-  while (true) {\n-    if (sr_notify(osthread) == 0) {\n-      if (sr_semaphore.timedwait(2)) {\n-        if (osthread->sr.is_running()) {\n-          return;\n-        }\n-      }\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_running(), \"Must be running!\");\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal handling (except suspend\/resume)\n-\n-\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n-\/\/ The user-defined signal handler must pass unrecognized signals to this\n-\/\/ routine, and if it returns true (non-zero), then the signal handler must\n-\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n-\/\/ routine will never retun false (zero), but instead will execute a VM panic\n-\/\/ routine kill the process.\n-\/\/\n-\/\/ If this routine returns false, it is OK to call it again.  This allows\n-\/\/ the user-defined signal handler to perform checks either before or after\n-\/\/ the VM performs its own checks.  Naturally, the user code would be making\n-\/\/ a serious error if it tried to handle an exception (such as a null check\n-\/\/ or breakpoint) that the VM was generating for its own correct operation.\n-\/\/\n-\/\/ This routine may recognize any of the following kinds of signals:\n-\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n-\/\/ It should be consulted by handlers for any of those signals.\n-\/\/\n-\/\/ The caller of this routine must pass in the three arguments supplied\n-\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n-\/\/ field of the structure passed to sigaction().  This routine assumes that\n-\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n-\/\/\n-\/\/ Note that the VM will print warnings if it detects conflicting signal\n-\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n-\/\/\n-extern \"C\" JNIEXPORT int JVM_handle_bsd_signal(int signo, siginfo_t* siginfo,\n-                                               void* ucontext,\n-                                               int abort_if_unrecognized);\n-\n-static void signalHandler(int sig, siginfo_t* info, void* uc) {\n-  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n-  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n-  JVM_handle_bsd_signal(sig, info, uc, true);\n-  errno = orig_errno;\n-}\n-\n-\n-\/\/ This boolean allows users to forward their own non-matching signals\n-\/\/ to JVM_handle_bsd_signal, harmlessly.\n-bool os::Bsd::signal_handlers_are_installed = false;\n-\n-\/\/ For signal-chaining\n-bool os::Bsd::libjsig_is_loaded = false;\n-typedef struct sigaction *(*get_signal_t)(int);\n-get_signal_t os::Bsd::get_signal_action = NULL;\n-\n-struct sigaction* os::Bsd::get_chained_signal_action(int sig) {\n-  struct sigaction *actp = NULL;\n-\n-  if (libjsig_is_loaded) {\n-    \/\/ Retrieve the old signal handler from libjsig\n-    actp = (*get_signal_action)(sig);\n-  }\n-  if (actp == NULL) {\n-    \/\/ Retrieve the preinstalled signal handler from jvm\n-    actp = os::Posix::get_preinstalled_handler(sig);\n-  }\n-\n-  return actp;\n-}\n-\n-static bool call_chained_handler(struct sigaction *actp, int sig,\n-                                 siginfo_t *siginfo, void *context) {\n-  \/\/ Call the old signal handler\n-  if (actp->sa_handler == SIG_DFL) {\n-    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n-    \/\/ instead of taking the default action.\n-    return false;\n-  } else if (actp->sa_handler != SIG_IGN) {\n-    if ((actp->sa_flags & SA_NODEFER) == 0) {\n-      \/\/ automaticlly block the signal\n-      sigaddset(&(actp->sa_mask), sig);\n-    }\n-\n-    sa_handler_t hand;\n-    sa_sigaction_t sa;\n-    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n-    \/\/ retrieve the chained handler\n-    if (siginfo_flag_set) {\n-      sa = actp->sa_sigaction;\n-    } else {\n-      hand = actp->sa_handler;\n-    }\n-\n-    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n-      actp->sa_handler = SIG_DFL;\n-    }\n-\n-    \/\/ try to honor the signal mask\n-    sigset_t oset;\n-    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n-\n-    \/\/ call into the chained handler\n-    if (siginfo_flag_set) {\n-      (*sa)(sig, siginfo, context);\n-    } else {\n-      (*hand)(sig);\n-    }\n-\n-    \/\/ restore the signal mask\n-    pthread_sigmask(SIG_SETMASK, &oset, 0);\n-  }\n-  \/\/ Tell jvm's signal handler the signal is taken care of.\n-  return true;\n-}\n-\n-bool os::Bsd::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n-  bool chained = false;\n-  \/\/ signal-chaining\n-  if (UseSignalChaining) {\n-    struct sigaction *actp = get_chained_signal_action(sig);\n-    if (actp != NULL) {\n-      chained = call_chained_handler(actp, sig, siginfo, context);\n-    }\n-  }\n-  return chained;\n-}\n-\n-\/\/ for diagnostic\n-int sigflags[NSIG];\n-\n-int os::Bsd::get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-void os::Bsd::set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n-void os::Bsd::set_signal_handler(int sig, bool set_installed) {\n-  \/\/ Check for overwrite.\n-  struct sigaction oldAct;\n-  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n-\n-  void* oldhand = oldAct.sa_sigaction\n-                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n-                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n-    if (AllowUserSignalHandlers || !set_installed) {\n-      \/\/ Do not overwrite; user takes responsibility to forward to us.\n-      return;\n-    } else if (UseSignalChaining) {\n-      \/\/ save the old handler in jvm\n-      os::Posix::save_preinstalled_handler(sig, oldAct);\n-      \/\/ libjsig also interposes the sigaction() call below and saves the\n-      \/\/ old sigaction on it own.\n-    } else {\n-      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n-            \"%#lx for signal %d.\", (long)oldhand, sig);\n-    }\n-  }\n-\n-  struct sigaction sigAct;\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_handler = SIG_DFL;\n-  if (!set_installed) {\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  } else {\n-    sigAct.sa_sigaction = signalHandler;\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  }\n-#ifdef __APPLE__\n-  \/\/ Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n-  \/\/ (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n-  \/\/ if the signal handler declares it will handle it on alternate stack.\n-  \/\/ Notice we only declare we will handle it on alt stack, but we are not\n-  \/\/ actually going to use real alt stack - this is just a workaround.\n-  \/\/ Please see ux_exception.c, method catch_mach_exception_raise for details\n-  \/\/ link http:\/\/www.opensource.apple.com\/source\/xnu\/xnu-2050.18.24\/bsd\/uxkern\/ux_exception.c\n-  if (sig == SIGSEGV) {\n-    sigAct.sa_flags |= SA_ONSTACK;\n-  }\n-#endif\n-\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n-\n-  int ret = sigaction(sig, &sigAct, &oldAct);\n-  assert(ret == 0, \"check\");\n-\n-  void* oldhand2  = oldAct.sa_sigaction\n-                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n-  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n-}\n-\n-\/\/ install signal handlers for signals that HotSpot needs to\n-\/\/ handle in order to support Java-level exception handling.\n-\n-void os::Bsd::install_signal_handlers() {\n-  if (!signal_handlers_are_installed) {\n-    signal_handlers_are_installed = true;\n-\n-    \/\/ signal-chaining\n-    typedef void (*signal_setting_t)();\n-    signal_setting_t begin_signal_setting = NULL;\n-    signal_setting_t end_signal_setting = NULL;\n-    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n-    if (begin_signal_setting != NULL) {\n-      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n-      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n-                                         dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n-      libjsig_is_loaded = true;\n-      assert(UseSignalChaining, \"should enable signal-chaining\");\n-    }\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm is setting signal handlers\n-      (*begin_signal_setting)();\n-    }\n-\n-    set_signal_handler(SIGSEGV, true);\n-    set_signal_handler(SIGPIPE, true);\n-    set_signal_handler(SIGBUS, true);\n-    set_signal_handler(SIGILL, true);\n-    set_signal_handler(SIGFPE, true);\n-    set_signal_handler(SIGXFSZ, true);\n-\n-#if defined(__APPLE__)\n-    \/\/ In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n-    \/\/ signals caught and handled by the JVM. To work around this, we reset the mach task\n-    \/\/ signal handler that's placed on our process by CrashReporter. This disables\n-    \/\/ CrashReporter-based reporting.\n-    \/\/\n-    \/\/ This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n-    \/\/ on caught fatal signals.\n-    \/\/\n-    \/\/ Additionally, gdb installs both standard BSD signal handlers, and mach exception\n-    \/\/ handlers. By replacing the existing task exception handler, we disable gdb's mach\n-    \/\/ exception handling, while leaving the standard BSD signal handlers functional.\n-    kern_return_t kr;\n-    kr = task_set_exception_ports(mach_task_self(),\n-                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n-                                  MACH_PORT_NULL,\n-                                  EXCEPTION_STATE_IDENTITY,\n-                                  MACHINE_THREAD_STATE);\n-\n-    assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n-#endif\n-\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm finishes setting signal handlers\n-      (*end_signal_setting)();\n-    }\n-\n-    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n-    \/\/ and if UserSignalHandler is installed all bets are off\n-    if (CheckJNICalls) {\n-      if (libjsig_is_loaded) {\n-        log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      if (AllowUserSignalHandlers) {\n-        log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-    }\n-  }\n-}\n-\n-\n-\/\/\/\/\/\n-\/\/ glibc on Bsd platform uses non-documented flag\n-\/\/ to indicate, that some special sort of signal\n-\/\/ trampoline is used.\n-\/\/ We will never set this flag, and we should\n-\/\/ ignore this flag in our diagnostic\n-#ifdef SIGNIFICANT_SIGNAL_MASK\n-  #undef SIGNIFICANT_SIGNAL_MASK\n-#endif\n-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n-\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n-}\n-\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-\n-  sigaction(sig, NULL, &sa);\n-\n-  \/\/ See comment for SIGNIFICANT_SIGNAL_MASK define\n-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n-\n-  address handler = (sa.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n-    st->print(\"SIG_DFL\");\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n-    st->print(\"SIG_IGN\");\n-  } else {\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n-  }\n-\n-  st->print(\", sa_mask[0]=\");\n-  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n-\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n-  }\n-\n-  st->print(\", sa_flags=\");\n-  os::Posix::print_sa_flags(st, sa.sa_flags);\n-\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                os::Bsd::get_our_sigflags(sig));\n-    }\n-  }\n-  st->cr();\n-}\n-\n-\n-#define DO_SIGNAL_CHECK(sig)                      \\\n-  do {                                            \\\n-    if (!sigismember(&check_signal_done, sig)) {  \\\n-      os::Bsd::check_signal_handler(sig);         \\\n-    }                                             \\\n-  } while (0)\n-\n-\/\/ This method is a periodic task to check for misbehaving JNI applications\n-\/\/ under CheckJNI, we can add any periodic checks here\n-\n-void os::run_periodic_checks() {\n-\n-  if (check_signals == false) return;\n-\n-  \/\/ SEGV and BUS if overridden could potentially prevent\n-  \/\/ generation of hs*.log in the event of a crash, debugging\n-  \/\/ such a case can be very challenging, so we absolutely\n-  \/\/ check the following for a good measure:\n-  DO_SIGNAL_CHECK(SIGSEGV);\n-  DO_SIGNAL_CHECK(SIGILL);\n-  DO_SIGNAL_CHECK(SIGFPE);\n-  DO_SIGNAL_CHECK(SIGBUS);\n-  DO_SIGNAL_CHECK(SIGPIPE);\n-  DO_SIGNAL_CHECK(SIGXFSZ);\n-\n-\n-  \/\/ ReduceSignalUsage allows the user to override these handlers\n-  \/\/ see comments at the very top and jvm_md.h\n-  if (!ReduceSignalUsage) {\n-    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n-    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n-  }\n-\n-  DO_SIGNAL_CHECK(SR_signum);\n-}\n-\n-typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n-\n-static os_sigaction_t os_sigaction = NULL;\n-\n-void os::Bsd::check_signal_handler(int sig) {\n-  char buf[O_BUFLEN];\n-  address jvmHandler = NULL;\n-\n-\n-  struct sigaction act;\n-  if (os_sigaction == NULL) {\n-    \/\/ only trust the default sigaction, in case it has been interposed\n-    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n-    if (os_sigaction == NULL) return;\n-  }\n-\n-  os_sigaction(sig, (struct sigaction*)NULL, &act);\n-\n-\n-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  address thisHandler = (act.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, act.sa_handler);\n-\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)user_handler();\n-    break;\n-\n-  default:\n-    if (sig == SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n-\n-  if (thisHandler != jvmHandler) {\n-    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n-                    exception_name(sig, buf, O_BUFLEN));\n-    }\n-  } else if(os::Bsd::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n-    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    os::Posix::print_sa_flags(tty, os::Bsd::get_our_sigflags(sig));\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    os::Posix::print_sa_flags(tty, act.sa_flags);\n-    tty->cr();\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-  }\n-\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n-    print_signal_handlers(tty, buf, O_BUFLEN);\n-  }\n-}\n-\n@@ -3068,1 +2143,1 @@\n-  if (SR_initialize() != 0) {\n+  if (PosixSignals::SR_initialize() != 0) {\n@@ -3073,2 +2148,2 @@\n-  Bsd::signal_sets_init();\n-  Bsd::install_signal_handlers();\n+  PosixSignals::signal_sets_init();\n+  PosixSignals::install_signal_handlers();\n@@ -3077,1 +2152,1 @@\n-    jdk_misc_signal_init();\n+    PosixSignals::jdk_misc_signal_init();\n@@ -3211,1 +2286,1 @@\n-  if (do_suspend(_thread->osthread())) {\n+  if (PosixSignals::do_suspend(_thread->osthread())) {\n@@ -3214,1 +2289,1 @@\n-    do_resume(_thread->osthread());\n+    PosixSignals::do_resume(_thread->osthread());\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":20,"deletions":945,"binary":false,"changes":965,"status":"modified"},{"patch":"@@ -36,7 +36,0 @@\n-  \/\/ For signal-chaining\n-  static bool libjsig_is_loaded;        \/\/ libjsig that interposes sigaction(),\n-                                        \/\/ __sigaction(), signal() is loaded\n-  static struct sigaction *(*get_signal_action)(int);\n-\n-  static void check_signal_handler(int sig);\n-\n@@ -73,2 +66,0 @@\n-  static void hotspot_sigmask(Thread* thread);\n-\n@@ -87,17 +78,0 @@\n-  \/\/ This boolean allows users to forward their own non-matching signals\n-  \/\/ to JVM_handle_bsd_signal, harmlessly.\n-  static bool signal_handlers_are_installed;\n-\n-  static int get_our_sigflags(int);\n-  static void set_our_sigflags(int, int);\n-  static void signal_sets_init();\n-  static void install_signal_handlers();\n-  static void set_signal_handler(int, bool);\n-\n-  static sigset_t* unblocked_signals();\n-  static sigset_t* vm_signals();\n-\n-  \/\/ For signal-chaining\n-  static struct sigaction *get_chained_signal_action(int sig);\n-  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"signals_posix.hpp\"\n@@ -173,10 +174,0 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n-\n-\/\/ Signal number used to suspend\/resume a thread\n-\n-\/\/ do not use any signal number less than SIGSEGV, see 4355769\n-static int SR_signum = SIGUSR2;\n-sigset_t SR_sigset;\n-\n@@ -185,2 +176,0 @@\n-static int SR_initialize();\n-\n@@ -514,88 +503,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal support\n-\n-debug_only(static bool signal_sets_initialized = false);\n-static sigset_t unblocked_sigs, vm_sigs;\n-\n-void os::Linux::signal_sets_init() {\n-  \/\/ Should also have an assertion stating we are still single-threaded.\n-  assert(!signal_sets_initialized, \"Already initialized\");\n-  \/\/ Fill in signals that are necessarily unblocked for all threads in\n-  \/\/ the VM. Currently, we unblock the following signals:\n-  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n-  \/\/                         by -Xrs (=ReduceSignalUsage));\n-  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n-  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n-  \/\/ the dispositions or masks wrt these signals.\n-  \/\/ Programs embedding the VM that want to use the above signals for their\n-  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n-  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n-  \/\/ (See bug 4345157, and other related bugs).\n-  \/\/ In reality, though, unblocking these signals is really a nop, since\n-  \/\/ these signals are not blocked by default.\n-  sigemptyset(&unblocked_sigs);\n-  sigaddset(&unblocked_sigs, SIGILL);\n-  sigaddset(&unblocked_sigs, SIGSEGV);\n-  sigaddset(&unblocked_sigs, SIGBUS);\n-  sigaddset(&unblocked_sigs, SIGFPE);\n-#if defined(PPC64)\n-  sigaddset(&unblocked_sigs, SIGTRAP);\n-#endif\n-  sigaddset(&unblocked_sigs, SR_signum);\n-\n-  if (!ReduceSignalUsage) {\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n-    }\n-  }\n-  \/\/ Fill in signals that are blocked by all but the VM thread.\n-  sigemptyset(&vm_sigs);\n-  if (!ReduceSignalUsage) {\n-    sigaddset(&vm_sigs, BREAK_SIGNAL);\n-  }\n-  debug_only(signal_sets_initialized = true);\n-\n-}\n-\n-\/\/ These are signals that are unblocked while a thread is running Java.\n-\/\/ (For some reason, they get blocked by default.)\n-sigset_t* os::Linux::unblocked_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &unblocked_sigs;\n-}\n-\n-\/\/ These are the signals that are blocked while a (non-VM) thread is\n-\/\/ running Java. Only the VM thread handles these signals.\n-sigset_t* os::Linux::vm_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &vm_sigs;\n-}\n-\n-void os::Linux::hotspot_sigmask(Thread* thread) {\n-\n-  \/\/Save caller's signal mask before setting VM signal mask\n-  sigset_t caller_sigmask;\n-  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n-\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_caller_sigmask(caller_sigmask);\n-\n-  pthread_sigmask(SIG_UNBLOCK, os::Linux::unblocked_signals(), NULL);\n-\n-  if (!ReduceSignalUsage) {\n-    if (thread->is_VM_thread()) {\n-      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n-      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n-    } else {\n-      \/\/ ... all other threads block BREAK_SIGNAL\n-      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n-    }\n-  }\n-}\n-\n@@ -772,1 +673,1 @@\n-  os::Linux::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -1037,1 +938,2 @@\n-    address addr = thread->stack_reserved_zone_base();\n+    JavaThread *jt = (JavaThread *)thread;\n+    address addr = jt->stack_reserved_zone_base();\n@@ -1039,1 +941,1 @@\n-    assert(thread->stack_available(addr) > 0, \"stack guard should not be enabled\");\n+    assert(jt->stack_available(addr) > 0, \"stack guard should not be enabled\");\n@@ -1042,1 +944,1 @@\n-    os::Linux::manually_expand_stack(thread, addr);\n+    os::Linux::manually_expand_stack(jt, addr);\n@@ -1048,1 +950,1 @@\n-  os::Linux::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -1777,0 +1679,1 @@\n+        assert(Thread::current()->is_Java_thread(), \"must be Java thread\");\n@@ -2702,3 +2605,0 @@\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen);\n-\n@@ -2707,11 +2607,11 @@\n-  print_signal_handler(st, SIGSEGV, buf, buflen);\n-  print_signal_handler(st, SIGBUS , buf, buflen);\n-  print_signal_handler(st, SIGFPE , buf, buflen);\n-  print_signal_handler(st, SIGPIPE, buf, buflen);\n-  print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  print_signal_handler(st, SIGILL , buf, buflen);\n-  print_signal_handler(st, SR_signum, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SR_signum, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n@@ -2719,1 +2619,1 @@\n-  print_signal_handler(st, SIGTRAP, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGTRAP, buf, buflen);\n@@ -2822,111 +2722,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ sun.misc.Signal support\n-\n-static void UserHandler(int sig, void *siginfo, void *context) {\n-  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n-  \/\/ handler fails to abort. Let VM die immediately.\n-  if (sig == SIGINT && VMError::is_error_reported()) {\n-    os::die();\n-  }\n-\n-  os::signal_notify(sig);\n-}\n-\n-void* os::user_handler() {\n-  return CAST_FROM_FN_PTR(void*, UserHandler);\n-}\n-\n-extern \"C\" {\n-  typedef void (*sa_handler_t)(int);\n-  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n-}\n-\n-void* os::signal(int signal_number, void* handler) {\n-  struct sigaction sigAct, oldSigAct;\n-\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n-  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n-\n-  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n-    \/\/ -1 means registration failed\n-    return (void *)-1;\n-  }\n-\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n-}\n-\n-void os::signal_raise(int signal_number) {\n-  ::raise(signal_number);\n-}\n-\n-\/\/ The following code is moved from os.cpp for making this\n-\/\/ code platform specific, which it is by its very nature.\n-\n-\/\/ Will be modified when max signal is changed to be dynamic\n-int os::sigexitnum_pd() {\n-  return NSIG;\n-}\n-\n-\/\/ a counter for each possible signal value\n-static volatile jint pending_signals[NSIG+1] = { 0 };\n-\n-\/\/ Linux(POSIX) specific hand shaking semaphore.\n-static Semaphore* sig_sem = NULL;\n-static PosixSemaphore sr_semaphore;\n-\n-static void jdk_misc_signal_init() {\n-  \/\/ Initialize signal structures\n-  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n-\n-  \/\/ Initialize signal semaphore\n-  sig_sem = new Semaphore();\n-}\n-\n-void os::signal_notify(int sig) {\n-  if (sig_sem != NULL) {\n-    Atomic::inc(&pending_signals[sig]);\n-    sig_sem->signal();\n-  } else {\n-    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n-    \/\/ initialization isn't called.\n-    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n-  }\n-}\n-\n-static int check_pending_signals() {\n-  for (;;) {\n-    for (int i = 0; i < NSIG + 1; i++) {\n-      jint n = pending_signals[i];\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n-        return i;\n-      }\n-    }\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n-  }\n-}\n-\n-int os::signal_wait() {\n-  return check_pending_signals();\n-}\n-\n@@ -4518,481 +4307,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ suspend\/resume support\n-\n-\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n-\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n-\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n-\/\/\n-\/\/  The remaining code is greatly simplified from the more general suspension\n-\/\/  code that used to be used.\n-\/\/\n-\/\/  The protocol is quite simple:\n-\/\/  - suspend:\n-\/\/      - sends a signal to the target thread\n-\/\/      - polls the suspend state of the osthread using a yield loop\n-\/\/      - target thread signal handler (SR_handler) sets suspend state\n-\/\/        and blocks in sigsuspend until continued\n-\/\/  - resume:\n-\/\/      - sets target osthread state to continue\n-\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n-\/\/\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n-\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n-\/\/  by SR_handler(), so that fetch_frame_from_context() works,\n-\/\/  which in part is used by:\n-\/\/    - Forte Analyzer: AsyncGetCallTrace()\n-\/\/    - StackBanging: get_frame_at_stack_banging_point()\n-\n-static void resume_clear_context(OSThread *osthread) {\n-  osthread->set_ucontext(NULL);\n-  osthread->set_siginfo(NULL);\n-}\n-\n-static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo,\n-                                 ucontext_t* context) {\n-  osthread->set_ucontext(context);\n-  osthread->set_siginfo(siginfo);\n-}\n-\n-\/\/ Handler function invoked when a thread's execution is suspended or\n-\/\/ resumed. We have to be careful that only async-safe functions are\n-\/\/ called here (Note: most pthread functions are not async safe and\n-\/\/ should be avoided.)\n-\/\/\n-\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n-\/\/ interface point of view, but sigwait() prevents the signal hander\n-\/\/ from being run. libpthread would get very confused by not having\n-\/\/ its signal handlers run and prevents sigwait()'s use with the\n-\/\/ mutex granting granting signal.\n-\/\/\n-\/\/ Currently only ever called on the VMThread and JavaThreads (PC sampling)\n-\/\/\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n-  \/\/ Save and restore errno to avoid confusing native code with EINTR\n-  \/\/ after sigsuspend.\n-  int old_errno = errno;\n-\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"Missing current thread in SR_handler\");\n-\n-  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n-  \/\/ mask is changed as part of thread termination. Check that the current thread\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n-  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n-  \/\/ destructor has completed.\n-\n-  if (thread->SR_lock() == NULL) {\n-    return;\n-  }\n-\n-  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n-\n-  OSThread* osthread = thread->osthread();\n-\n-  os::SuspendResume::State current = osthread->sr.state();\n-  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    suspend_save_context(osthread, siginfo, context);\n-\n-    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n-    os::SuspendResume::State state = osthread->sr.suspended();\n-    if (state == os::SuspendResume::SR_SUSPENDED) {\n-      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n-      sigemptyset(&suspend_set);\n-      \/\/ get current set of blocked signals and unblock resume signal\n-      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n-      sigdelset(&suspend_set, SR_signum);\n-\n-      sr_semaphore.signal();\n-      \/\/ wait here until we are resumed\n-      while (1) {\n-        sigsuspend(&suspend_set);\n-\n-        os::SuspendResume::State result = osthread->sr.running();\n-        if (result == os::SuspendResume::SR_RUNNING) {\n-          sr_semaphore.signal();\n-          break;\n-        }\n-      }\n-\n-    } else if (state == os::SuspendResume::SR_RUNNING) {\n-      \/\/ request was cancelled, continue\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-\n-    resume_clear_context(osthread);\n-  } else if (current == os::SuspendResume::SR_RUNNING) {\n-    \/\/ request was cancelled, continue\n-  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ ignore\n-  } else {\n-    \/\/ ignore\n-  }\n-\n-  errno = old_errno;\n-}\n-\n-static int SR_initialize() {\n-  struct sigaction act;\n-  char *s;\n-\n-  \/\/ Get signal number to use for suspend\/resume\n-  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n-    int sig = ::strtol(s, 0, 10);\n-    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n-        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n-      SR_signum = sig;\n-    } else {\n-      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n-    }\n-  }\n-\n-  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n-         \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n-\n-  sigemptyset(&SR_sigset);\n-  sigaddset(&SR_sigset, SR_signum);\n-\n-  \/\/ Set up signal handler for suspend\/resume\n-  act.sa_flags = SA_RESTART|SA_SIGINFO;\n-  act.sa_handler = (void (*)(int)) SR_handler;\n-\n-  \/\/ SR_signum is blocked by default.\n-  \/\/ 4528190 - We also need to block pthread restart signal (32 on all\n-  \/\/ supported Linux platforms). Note that LinuxThreads need to block\n-  \/\/ this signal for all threads to work properly. So we don't have\n-  \/\/ to use hard-coded signal number when setting up the mask.\n-  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n-\n-  if (sigaction(SR_signum, &act, 0) == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ Save signal flag\n-  os::Linux::set_our_sigflags(SR_signum, act.sa_flags);\n-  return 0;\n-}\n-\n-static int sr_notify(OSThread* osthread) {\n-  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n-  assert_status(status == 0, status, \"pthread_kill\");\n-  return status;\n-}\n-\n-\/\/ \"Randomly\" selected value for how long we want to spin\n-\/\/ before bailing out on suspending a thread, also how often\n-\/\/ we send a signal to a thread we want to resume\n-static const int RANDOMLY_LARGE_INTEGER = 1000000;\n-static const int RANDOMLY_LARGE_INTEGER2 = 100;\n-\n-\/\/ returns true on success and false on error - really an error is fatal\n-\/\/ but this seems the normal response to library errors\n-static bool do_suspend(OSThread* osthread) {\n-  assert(osthread->sr.is_running(), \"thread should be running\");\n-  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n-\n-  \/\/ mark as suspended and send signal\n-  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    \/\/ failed to switch, state wasn't running?\n-    ShouldNotReachHere();\n-    return false;\n-  }\n-\n-  if (sr_notify(osthread) != 0) {\n-    ShouldNotReachHere();\n-  }\n-\n-  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n-  while (true) {\n-    if (sr_semaphore.timedwait(2)) {\n-      break;\n-    } else {\n-      \/\/ timeout\n-      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n-      if (cancelled == os::SuspendResume::SR_RUNNING) {\n-        return false;\n-      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n-        \/\/ make sure that we consume the signal on the semaphore as well\n-        sr_semaphore.wait();\n-        break;\n-      } else {\n-        ShouldNotReachHere();\n-        return false;\n-      }\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n-  return true;\n-}\n-\n-static void do_resume(OSThread* osthread) {\n-  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n-  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n-\n-  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ failed to switch to WAKEUP_REQUEST\n-    ShouldNotReachHere();\n-    return;\n-  }\n-\n-  while (true) {\n-    if (sr_notify(osthread) == 0) {\n-      if (sr_semaphore.timedwait(2)) {\n-        if (osthread->sr.is_running()) {\n-          return;\n-        }\n-      }\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_running(), \"Must be running!\");\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal handling (except suspend\/resume)\n-\n-\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n-\/\/ The user-defined signal handler must pass unrecognized signals to this\n-\/\/ routine, and if it returns true (non-zero), then the signal handler must\n-\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n-\/\/ routine will never retun false (zero), but instead will execute a VM panic\n-\/\/ routine kill the process.\n-\/\/\n-\/\/ If this routine returns false, it is OK to call it again.  This allows\n-\/\/ the user-defined signal handler to perform checks either before or after\n-\/\/ the VM performs its own checks.  Naturally, the user code would be making\n-\/\/ a serious error if it tried to handle an exception (such as a null check\n-\/\/ or breakpoint) that the VM was generating for its own correct operation.\n-\/\/\n-\/\/ This routine may recognize any of the following kinds of signals:\n-\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n-\/\/ It should be consulted by handlers for any of those signals.\n-\/\/\n-\/\/ The caller of this routine must pass in the three arguments supplied\n-\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n-\/\/ field of the structure passed to sigaction().  This routine assumes that\n-\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n-\/\/\n-\/\/ Note that the VM will print warnings if it detects conflicting signal\n-\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n-\/\/\n-extern \"C\" JNIEXPORT int JVM_handle_linux_signal(int signo,\n-                                                 siginfo_t* siginfo,\n-                                                 void* ucontext,\n-                                                 int abort_if_unrecognized);\n-\n-static void signalHandler(int sig, siginfo_t* info, void* uc) {\n-  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n-  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n-  JVM_handle_linux_signal(sig, info, uc, true);\n-  errno = orig_errno;\n-}\n-\n-\n-\/\/ This boolean allows users to forward their own non-matching signals\n-\/\/ to JVM_handle_linux_signal, harmlessly.\n-bool os::Linux::signal_handlers_are_installed = false;\n-\n-\/\/ For signal-chaining\n-bool os::Linux::libjsig_is_loaded = false;\n-typedef struct sigaction *(*get_signal_t)(int);\n-get_signal_t os::Linux::get_signal_action = NULL;\n-\n-struct sigaction* os::Linux::get_chained_signal_action(int sig) {\n-  struct sigaction *actp = NULL;\n-\n-  if (libjsig_is_loaded) {\n-    \/\/ Retrieve the old signal handler from libjsig\n-    actp = (*get_signal_action)(sig);\n-  }\n-  if (actp == NULL) {\n-    \/\/ Retrieve the preinstalled signal handler from jvm\n-    actp = os::Posix::get_preinstalled_handler(sig);\n-  }\n-\n-  return actp;\n-}\n-\n-static bool call_chained_handler(struct sigaction *actp, int sig,\n-                                 siginfo_t *siginfo, void *context) {\n-  \/\/ Call the old signal handler\n-  if (actp->sa_handler == SIG_DFL) {\n-    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n-    \/\/ instead of taking the default action.\n-    return false;\n-  } else if (actp->sa_handler != SIG_IGN) {\n-    if ((actp->sa_flags & SA_NODEFER) == 0) {\n-      \/\/ automaticlly block the signal\n-      sigaddset(&(actp->sa_mask), sig);\n-    }\n-\n-    sa_handler_t hand = NULL;\n-    sa_sigaction_t sa = NULL;\n-    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n-    \/\/ retrieve the chained handler\n-    if (siginfo_flag_set) {\n-      sa = actp->sa_sigaction;\n-    } else {\n-      hand = actp->sa_handler;\n-    }\n-\n-    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n-      actp->sa_handler = SIG_DFL;\n-    }\n-\n-    \/\/ try to honor the signal mask\n-    sigset_t oset;\n-    sigemptyset(&oset);\n-    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n-\n-    \/\/ call into the chained handler\n-    if (siginfo_flag_set) {\n-      (*sa)(sig, siginfo, context);\n-    } else {\n-      (*hand)(sig);\n-    }\n-\n-    \/\/ restore the signal mask\n-    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n-  }\n-  \/\/ Tell jvm's signal handler the signal is taken care of.\n-  return true;\n-}\n-\n-bool os::Linux::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n-  bool chained = false;\n-  \/\/ signal-chaining\n-  if (UseSignalChaining) {\n-    struct sigaction *actp = get_chained_signal_action(sig);\n-    if (actp != NULL) {\n-      chained = call_chained_handler(actp, sig, siginfo, context);\n-    }\n-  }\n-  return chained;\n-}\n-\n-\/\/ for diagnostic\n-int sigflags[NSIG];\n-\n-int os::Linux::get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-void os::Linux::set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n-void os::Linux::set_signal_handler(int sig, bool set_installed) {\n-  \/\/ Check for overwrite.\n-  struct sigaction oldAct;\n-  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n-\n-  void* oldhand = oldAct.sa_sigaction\n-                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n-                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n-    if (AllowUserSignalHandlers || !set_installed) {\n-      \/\/ Do not overwrite; user takes responsibility to forward to us.\n-      return;\n-    } else if (UseSignalChaining) {\n-      \/\/ save the old handler in jvm\n-      os::Posix::save_preinstalled_handler(sig, oldAct);\n-      \/\/ libjsig also interposes the sigaction() call below and saves the\n-      \/\/ old sigaction on it own.\n-    } else {\n-      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n-            \"%#lx for signal %d.\", (long)oldhand, sig);\n-    }\n-  }\n-\n-  struct sigaction sigAct;\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_handler = SIG_DFL;\n-  if (!set_installed) {\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  } else {\n-    sigAct.sa_sigaction = signalHandler;\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  }\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n-\n-  int ret = sigaction(sig, &sigAct, &oldAct);\n-  assert(ret == 0, \"check\");\n-\n-  void* oldhand2  = oldAct.sa_sigaction\n-                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n-  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n-}\n-\n-\/\/ install signal handlers for signals that HotSpot needs to\n-\/\/ handle in order to support Java-level exception handling.\n-\n-void os::Linux::install_signal_handlers() {\n-  if (!signal_handlers_are_installed) {\n-    signal_handlers_are_installed = true;\n-\n-    \/\/ signal-chaining\n-    typedef void (*signal_setting_t)();\n-    signal_setting_t begin_signal_setting = NULL;\n-    signal_setting_t end_signal_setting = NULL;\n-    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n-    if (begin_signal_setting != NULL) {\n-      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n-      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n-                                         dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n-      libjsig_is_loaded = true;\n-      assert(UseSignalChaining, \"should enable signal-chaining\");\n-    }\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm is setting signal handlers\n-      (*begin_signal_setting)();\n-    }\n-\n-    set_signal_handler(SIGSEGV, true);\n-    set_signal_handler(SIGPIPE, true);\n-    set_signal_handler(SIGBUS, true);\n-    set_signal_handler(SIGILL, true);\n-    set_signal_handler(SIGFPE, true);\n-#if defined(PPC64)\n-    set_signal_handler(SIGTRAP, true);\n-#endif\n-    set_signal_handler(SIGXFSZ, true);\n-\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm finishes setting signal handlers\n-      (*end_signal_setting)();\n-    }\n-\n-    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n-    \/\/ and if UserSignalHandler is installed all bets are off.\n-    \/\/ Log that signal checking is off only if -verbose:jni is specified.\n-    if (CheckJNICalls) {\n-      if (libjsig_is_loaded) {\n-        log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      if (AllowUserSignalHandlers) {\n-        log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-    }\n-  }\n-}\n-\n@@ -5014,199 +4322,0 @@\n-\/\/\/\/\/\n-\/\/ glibc on Linux platform uses non-documented flag\n-\/\/ to indicate, that some special sort of signal\n-\/\/ trampoline is used.\n-\/\/ We will never set this flag, and we should\n-\/\/ ignore this flag in our diagnostic\n-#ifdef SIGNIFICANT_SIGNAL_MASK\n-  #undef SIGNIFICANT_SIGNAL_MASK\n-#endif\n-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n-\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset = 0;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n-}\n-\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-\n-  sigaction(sig, NULL, &sa);\n-\n-  \/\/ See comment for SIGNIFICANT_SIGNAL_MASK define\n-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n-\n-  address handler = (sa.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n-\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n-    st->print(\"SIG_DFL\");\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n-    st->print(\"SIG_IGN\");\n-  } else {\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n-  }\n-\n-  st->print(\", sa_mask[0]=\");\n-  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n-\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n-  }\n-\n-  st->print(\", sa_flags=\");\n-  os::Posix::print_sa_flags(st, sa.sa_flags);\n-\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != os::Linux::get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                os::Linux::get_our_sigflags(sig));\n-    }\n-  }\n-  st->cr();\n-}\n-\n-\n-#define DO_SIGNAL_CHECK(sig)                      \\\n-  do {                                            \\\n-    if (!sigismember(&check_signal_done, sig)) {  \\\n-      os::Linux::check_signal_handler(sig);       \\\n-    }                                             \\\n-  } while (0)\n-\n-\/\/ This method is a periodic task to check for misbehaving JNI applications\n-\/\/ under CheckJNI, we can add any periodic checks here\n-\n-void os::run_periodic_checks() {\n-  if (check_signals == false) return;\n-\n-  \/\/ SEGV and BUS if overridden could potentially prevent\n-  \/\/ generation of hs*.log in the event of a crash, debugging\n-  \/\/ such a case can be very challenging, so we absolutely\n-  \/\/ check the following for a good measure:\n-  DO_SIGNAL_CHECK(SIGSEGV);\n-  DO_SIGNAL_CHECK(SIGILL);\n-  DO_SIGNAL_CHECK(SIGFPE);\n-  DO_SIGNAL_CHECK(SIGBUS);\n-  DO_SIGNAL_CHECK(SIGPIPE);\n-  DO_SIGNAL_CHECK(SIGXFSZ);\n-#if defined(PPC64)\n-  DO_SIGNAL_CHECK(SIGTRAP);\n-#endif\n-\n-  \/\/ ReduceSignalUsage allows the user to override these handlers\n-  \/\/ see comments at the very top and jvm_md.h\n-  if (!ReduceSignalUsage) {\n-    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n-    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n-  }\n-\n-  DO_SIGNAL_CHECK(SR_signum);\n-}\n-\n-typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n-\n-static os_sigaction_t os_sigaction = NULL;\n-\n-void os::Linux::check_signal_handler(int sig) {\n-  char buf[O_BUFLEN];\n-  address jvmHandler = NULL;\n-\n-\n-  struct sigaction act;\n-  if (os_sigaction == NULL) {\n-    \/\/ only trust the default sigaction, in case it has been interposed\n-    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n-    if (os_sigaction == NULL) return;\n-  }\n-\n-  os_sigaction(sig, (struct sigaction*)NULL, &act);\n-\n-\n-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  address thisHandler = (act.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, act.sa_handler);\n-\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n-    break;\n-\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)user_handler();\n-    break;\n-\n-  default:\n-    if (sig == SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n-  }\n-\n-  if (thisHandler != jvmHandler) {\n-    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n-                    exception_name(sig, buf, O_BUFLEN));\n-    }\n-  } else if(os::Linux::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Linux::get_our_sigflags(sig)) {\n-    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    os::Posix::print_sa_flags(tty, act.sa_flags);\n-    tty->cr();\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-  }\n-\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n-    print_signal_handlers(tty, buf, O_BUFLEN);\n-  }\n-}\n-\n@@ -5352,1 +4461,1 @@\n-  if (SR_initialize() != 0) {\n+  if (PosixSignals::SR_initialize() != 0) {\n@@ -5357,2 +4466,2 @@\n-  Linux::signal_sets_init();\n-  Linux::install_signal_handlers();\n+  PosixSignals::signal_sets_init();\n+  PosixSignals::install_signal_handlers();\n@@ -5361,1 +4470,1 @@\n-    jdk_misc_signal_init();\n+    PosixSignals::jdk_misc_signal_init();\n@@ -5604,1 +4713,1 @@\n-  if (do_suspend(_thread->osthread())) {\n+  if (PosixSignals::do_suspend(_thread->osthread())) {\n@@ -5607,1 +4716,1 @@\n-    do_resume(_thread->osthread());\n+    PosixSignals::do_resume(_thread->osthread());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":917,"binary":false,"changes":943,"status":"modified"},{"patch":"@@ -39,6 +39,0 @@\n-  static bool libjsig_is_loaded;        \/\/ libjsig that interposes sigaction(),\n-                                        \/\/ __sigaction(), signal() is loaded\n-  static struct sigaction *(*get_signal_action)(int);\n-\n-  static void check_signal_handler(int sig);\n-\n@@ -136,1 +130,0 @@\n-  static void hotspot_sigmask(Thread* thread);\n@@ -151,17 +144,0 @@\n-  \/\/ This boolean allows users to forward their own non-matching signals\n-  \/\/ to JVM_handle_linux_signal, harmlessly.\n-  static bool signal_handlers_are_installed;\n-\n-  static int get_our_sigflags(int);\n-  static void set_our_sigflags(int, int);\n-  static void signal_sets_init();\n-  static void install_signal_handlers();\n-  static void set_signal_handler(int, bool);\n-\n-  static sigset_t* unblocked_signals();\n-  static sigset_t* vm_signals();\n-\n-  \/\/ For signal-chaining\n-  static struct sigaction *get_chained_signal_action(int sig);\n-  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"signals_posix.hpp\"\n@@ -81,1 +82,1 @@\n-      if (os::Posix::is_sig_ignored(sig)) return (void*)1;\n+      if (PosixSignals::is_sig_ignored(sig)) return (void*)1;\n@@ -105,1 +106,1 @@\n-            sig == SHUTDOWN3_SIGNAL) && os::Posix::is_sig_ignored(sig)) {\n+            sig == SHUTDOWN3_SIGNAL) && PosixSignals::is_sig_ignored(sig)) {\n","filename":"src\/hotspot\/os\/posix\/jvm_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,7 +56,0 @@\n-\/\/ Todo: provide a os::get_max_process_id() or similar. Number of processes\n-\/\/ may have been configured, can be read more accurately from proc fs etc.\n-#ifndef MAX_PID\n-#define MAX_PID INT_MAX\n-#endif\n-#define IS_VALID_PID(p) (p > 0 && p < MAX_PID)\n-\n@@ -707,597 +700,0 @@\n-static const struct {\n-  int sig; const char* name;\n-}\n- g_signal_info[] =\n-  {\n-  {  SIGABRT,     \"SIGABRT\" },\n-#ifdef SIGAIO\n-  {  SIGAIO,      \"SIGAIO\" },\n-#endif\n-  {  SIGALRM,     \"SIGALRM\" },\n-#ifdef SIGALRM1\n-  {  SIGALRM1,    \"SIGALRM1\" },\n-#endif\n-  {  SIGBUS,      \"SIGBUS\" },\n-#ifdef SIGCANCEL\n-  {  SIGCANCEL,   \"SIGCANCEL\" },\n-#endif\n-  {  SIGCHLD,     \"SIGCHLD\" },\n-#ifdef SIGCLD\n-  {  SIGCLD,      \"SIGCLD\" },\n-#endif\n-  {  SIGCONT,     \"SIGCONT\" },\n-#ifdef SIGCPUFAIL\n-  {  SIGCPUFAIL,  \"SIGCPUFAIL\" },\n-#endif\n-#ifdef SIGDANGER\n-  {  SIGDANGER,   \"SIGDANGER\" },\n-#endif\n-#ifdef SIGDIL\n-  {  SIGDIL,      \"SIGDIL\" },\n-#endif\n-#ifdef SIGEMT\n-  {  SIGEMT,      \"SIGEMT\" },\n-#endif\n-  {  SIGFPE,      \"SIGFPE\" },\n-#ifdef SIGFREEZE\n-  {  SIGFREEZE,   \"SIGFREEZE\" },\n-#endif\n-#ifdef SIGGFAULT\n-  {  SIGGFAULT,   \"SIGGFAULT\" },\n-#endif\n-#ifdef SIGGRANT\n-  {  SIGGRANT,    \"SIGGRANT\" },\n-#endif\n-  {  SIGHUP,      \"SIGHUP\" },\n-  {  SIGILL,      \"SIGILL\" },\n-#ifdef SIGINFO\n-  {  SIGINFO,     \"SIGINFO\" },\n-#endif\n-  {  SIGINT,      \"SIGINT\" },\n-#ifdef SIGIO\n-  {  SIGIO,       \"SIGIO\" },\n-#endif\n-#ifdef SIGIOINT\n-  {  SIGIOINT,    \"SIGIOINT\" },\n-#endif\n-#ifdef SIGIOT\n-\/\/ SIGIOT is there for BSD compatibility, but on most Unices just a\n-\/\/ synonym for SIGABRT. The result should be \"SIGABRT\", not\n-\/\/ \"SIGIOT\".\n-#if (SIGIOT != SIGABRT )\n-  {  SIGIOT,      \"SIGIOT\" },\n-#endif\n-#endif\n-#ifdef SIGKAP\n-  {  SIGKAP,      \"SIGKAP\" },\n-#endif\n-  {  SIGKILL,     \"SIGKILL\" },\n-#ifdef SIGLOST\n-  {  SIGLOST,     \"SIGLOST\" },\n-#endif\n-#ifdef SIGLWP\n-  {  SIGLWP,      \"SIGLWP\" },\n-#endif\n-#ifdef SIGLWPTIMER\n-  {  SIGLWPTIMER, \"SIGLWPTIMER\" },\n-#endif\n-#ifdef SIGMIGRATE\n-  {  SIGMIGRATE,  \"SIGMIGRATE\" },\n-#endif\n-#ifdef SIGMSG\n-  {  SIGMSG,      \"SIGMSG\" },\n-#endif\n-  {  SIGPIPE,     \"SIGPIPE\" },\n-#ifdef SIGPOLL\n-  {  SIGPOLL,     \"SIGPOLL\" },\n-#endif\n-#ifdef SIGPRE\n-  {  SIGPRE,      \"SIGPRE\" },\n-#endif\n-  {  SIGPROF,     \"SIGPROF\" },\n-#ifdef SIGPTY\n-  {  SIGPTY,      \"SIGPTY\" },\n-#endif\n-#ifdef SIGPWR\n-  {  SIGPWR,      \"SIGPWR\" },\n-#endif\n-  {  SIGQUIT,     \"SIGQUIT\" },\n-#ifdef SIGRECONFIG\n-  {  SIGRECONFIG, \"SIGRECONFIG\" },\n-#endif\n-#ifdef SIGRECOVERY\n-  {  SIGRECOVERY, \"SIGRECOVERY\" },\n-#endif\n-#ifdef SIGRESERVE\n-  {  SIGRESERVE,  \"SIGRESERVE\" },\n-#endif\n-#ifdef SIGRETRACT\n-  {  SIGRETRACT,  \"SIGRETRACT\" },\n-#endif\n-#ifdef SIGSAK\n-  {  SIGSAK,      \"SIGSAK\" },\n-#endif\n-  {  SIGSEGV,     \"SIGSEGV\" },\n-#ifdef SIGSOUND\n-  {  SIGSOUND,    \"SIGSOUND\" },\n-#endif\n-#ifdef SIGSTKFLT\n-  {  SIGSTKFLT,    \"SIGSTKFLT\" },\n-#endif\n-  {  SIGSTOP,     \"SIGSTOP\" },\n-  {  SIGSYS,      \"SIGSYS\" },\n-#ifdef SIGSYSERROR\n-  {  SIGSYSERROR, \"SIGSYSERROR\" },\n-#endif\n-#ifdef SIGTALRM\n-  {  SIGTALRM,    \"SIGTALRM\" },\n-#endif\n-  {  SIGTERM,     \"SIGTERM\" },\n-#ifdef SIGTHAW\n-  {  SIGTHAW,     \"SIGTHAW\" },\n-#endif\n-  {  SIGTRAP,     \"SIGTRAP\" },\n-#ifdef SIGTSTP\n-  {  SIGTSTP,     \"SIGTSTP\" },\n-#endif\n-  {  SIGTTIN,     \"SIGTTIN\" },\n-  {  SIGTTOU,     \"SIGTTOU\" },\n-#ifdef SIGURG\n-  {  SIGURG,      \"SIGURG\" },\n-#endif\n-  {  SIGUSR1,     \"SIGUSR1\" },\n-  {  SIGUSR2,     \"SIGUSR2\" },\n-#ifdef SIGVIRT\n-  {  SIGVIRT,     \"SIGVIRT\" },\n-#endif\n-  {  SIGVTALRM,   \"SIGVTALRM\" },\n-#ifdef SIGWAITING\n-  {  SIGWAITING,  \"SIGWAITING\" },\n-#endif\n-#ifdef SIGWINCH\n-  {  SIGWINCH,    \"SIGWINCH\" },\n-#endif\n-#ifdef SIGWINDOW\n-  {  SIGWINDOW,   \"SIGWINDOW\" },\n-#endif\n-  {  SIGXCPU,     \"SIGXCPU\" },\n-  {  SIGXFSZ,     \"SIGXFSZ\" },\n-#ifdef SIGXRES\n-  {  SIGXRES,     \"SIGXRES\" },\n-#endif\n-  { -1, NULL }\n-};\n-\n-\/\/ Returned string is a constant. For unknown signals \"UNKNOWN\" is returned.\n-const char* os::Posix::get_signal_name(int sig, char* out, size_t outlen) {\n-\n-  const char* ret = NULL;\n-\n-#ifdef SIGRTMIN\n-  if (sig >= SIGRTMIN && sig <= SIGRTMAX) {\n-    if (sig == SIGRTMIN) {\n-      ret = \"SIGRTMIN\";\n-    } else if (sig == SIGRTMAX) {\n-      ret = \"SIGRTMAX\";\n-    } else {\n-      jio_snprintf(out, outlen, \"SIGRTMIN+%d\", sig - SIGRTMIN);\n-      return out;\n-    }\n-  }\n-#endif\n-\n-  if (sig > 0) {\n-    for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n-      if (g_signal_info[idx].sig == sig) {\n-        ret = g_signal_info[idx].name;\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (!ret) {\n-    if (!is_valid_signal(sig)) {\n-      ret = \"INVALID\";\n-    } else {\n-      ret = \"UNKNOWN\";\n-    }\n-  }\n-\n-  if (out && outlen > 0) {\n-    strncpy(out, ret, outlen);\n-    out[outlen - 1] = '\\0';\n-  }\n-  return out;\n-}\n-\n-int os::Posix::get_signal_number(const char* signal_name) {\n-  char tmp[30];\n-  const char* s = signal_name;\n-  if (s[0] != 'S' || s[1] != 'I' || s[2] != 'G') {\n-    jio_snprintf(tmp, sizeof(tmp), \"SIG%s\", signal_name);\n-    s = tmp;\n-  }\n-  for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n-    if (strcmp(g_signal_info[idx].name, s) == 0) {\n-      return g_signal_info[idx].sig;\n-    }\n-  }\n-  return -1;\n-}\n-\n-int os::get_signal_number(const char* signal_name) {\n-  return os::Posix::get_signal_number(signal_name);\n-}\n-\n-\/\/ Returns true if signal number is valid.\n-bool os::Posix::is_valid_signal(int sig) {\n-  \/\/ MacOS not really POSIX compliant: sigaddset does not return\n-  \/\/ an error for invalid signal numbers. However, MacOS does not\n-  \/\/ support real time signals and simply seems to have just 33\n-  \/\/ signals with no holes in the signal range.\n-#ifdef __APPLE__\n-  return sig >= 1 && sig < NSIG;\n-#else\n-  \/\/ Use sigaddset to check for signal validity.\n-  sigset_t set;\n-  sigemptyset(&set);\n-  if (sigaddset(&set, sig) == -1 && errno == EINVAL) {\n-    return false;\n-  }\n-  return true;\n-#endif\n-}\n-\n-bool os::Posix::is_sig_ignored(int sig) {\n-  struct sigaction oact;\n-  sigaction(sig, (struct sigaction*)NULL, &oact);\n-  void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n-                                 : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n-  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ Returns:\n-\/\/ NULL for an invalid signal number\n-\/\/ \"SIG<num>\" for a valid but unknown signal number\n-\/\/ signal name otherwise.\n-const char* os::exception_name(int sig, char* buf, size_t size) {\n-  if (!os::Posix::is_valid_signal(sig)) {\n-    return NULL;\n-  }\n-  const char* const name = os::Posix::get_signal_name(sig, buf, size);\n-  if (strcmp(name, \"UNKNOWN\") == 0) {\n-    jio_snprintf(buf, size, \"SIG%d\", sig);\n-  }\n-  return buf;\n-}\n-\n-#define NUM_IMPORTANT_SIGS 32\n-\/\/ Returns one-line short description of a signal set in a user provided buffer.\n-const char* os::Posix::describe_signal_set_short(const sigset_t* set, char* buffer, size_t buf_size) {\n-  assert(buf_size == (NUM_IMPORTANT_SIGS + 1), \"wrong buffer size\");\n-  \/\/ Note: for shortness, just print out the first 32. That should\n-  \/\/ cover most of the useful ones, apart from realtime signals.\n-  for (int sig = 1; sig <= NUM_IMPORTANT_SIGS; sig++) {\n-    const int rc = sigismember(set, sig);\n-    if (rc == -1 && errno == EINVAL) {\n-      buffer[sig-1] = '?';\n-    } else {\n-      buffer[sig-1] = rc == 0 ? '0' : '1';\n-    }\n-  }\n-  buffer[NUM_IMPORTANT_SIGS] = 0;\n-  return buffer;\n-}\n-\n-\/\/ Prints one-line description of a signal set.\n-void os::Posix::print_signal_set_short(outputStream* st, const sigset_t* set) {\n-  char buf[NUM_IMPORTANT_SIGS + 1];\n-  os::Posix::describe_signal_set_short(set, buf, sizeof(buf));\n-  st->print(\"%s\", buf);\n-}\n-\n-\/\/ Writes one-line description of a combination of sigaction.sa_flags into a user\n-\/\/ provided buffer. Returns that buffer.\n-const char* os::Posix::describe_sa_flags(int flags, char* buffer, size_t size) {\n-  char* p = buffer;\n-  size_t remaining = size;\n-  bool first = true;\n-  int idx = 0;\n-\n-  assert(buffer, \"invalid argument\");\n-\n-  if (size == 0) {\n-    return buffer;\n-  }\n-\n-  strncpy(buffer, \"none\", size);\n-\n-  const struct {\n-    \/\/ NB: i is an unsigned int here because SA_RESETHAND is on some\n-    \/\/ systems 0x80000000, which is implicitly unsigned.  Assignining\n-    \/\/ it to an int field would be an overflow in unsigned-to-signed\n-    \/\/ conversion.\n-    unsigned int i;\n-    const char* s;\n-  } flaginfo [] = {\n-    { SA_NOCLDSTOP, \"SA_NOCLDSTOP\" },\n-    { SA_ONSTACK,   \"SA_ONSTACK\"   },\n-    { SA_RESETHAND, \"SA_RESETHAND\" },\n-    { SA_RESTART,   \"SA_RESTART\"   },\n-    { SA_SIGINFO,   \"SA_SIGINFO\"   },\n-    { SA_NOCLDWAIT, \"SA_NOCLDWAIT\" },\n-    { SA_NODEFER,   \"SA_NODEFER\"   },\n-#ifdef AIX\n-    { SA_ONSTACK,   \"SA_ONSTACK\"   },\n-    { SA_OLDSTYLE,  \"SA_OLDSTYLE\"  },\n-#endif\n-    { 0, NULL }\n-  };\n-\n-  for (idx = 0; flaginfo[idx].s && remaining > 1; idx++) {\n-    if (flags & flaginfo[idx].i) {\n-      if (first) {\n-        jio_snprintf(p, remaining, \"%s\", flaginfo[idx].s);\n-        first = false;\n-      } else {\n-        jio_snprintf(p, remaining, \"|%s\", flaginfo[idx].s);\n-      }\n-      const size_t len = strlen(p);\n-      p += len;\n-      remaining -= len;\n-    }\n-  }\n-\n-  buffer[size - 1] = '\\0';\n-\n-  return buffer;\n-}\n-\n-\/\/ Prints one-line description of a combination of sigaction.sa_flags.\n-void os::Posix::print_sa_flags(outputStream* st, int flags) {\n-  char buffer[0x100];\n-  os::Posix::describe_sa_flags(flags, buffer, sizeof(buffer));\n-  st->print(\"%s\", buffer);\n-}\n-\n-\/\/ Helper function for os::Posix::print_siginfo_...():\n-\/\/ return a textual description for signal code.\n-struct enum_sigcode_desc_t {\n-  const char* s_name;\n-  const char* s_desc;\n-};\n-\n-static bool get_signal_code_description(const siginfo_t* si, enum_sigcode_desc_t* out) {\n-\n-  const struct {\n-    int sig; int code; const char* s_code; const char* s_desc;\n-  } t1 [] = {\n-    { SIGILL,  ILL_ILLOPC,   \"ILL_ILLOPC\",   \"Illegal opcode.\" },\n-    { SIGILL,  ILL_ILLOPN,   \"ILL_ILLOPN\",   \"Illegal operand.\" },\n-    { SIGILL,  ILL_ILLADR,   \"ILL_ILLADR\",   \"Illegal addressing mode.\" },\n-    { SIGILL,  ILL_ILLTRP,   \"ILL_ILLTRP\",   \"Illegal trap.\" },\n-    { SIGILL,  ILL_PRVOPC,   \"ILL_PRVOPC\",   \"Privileged opcode.\" },\n-    { SIGILL,  ILL_PRVREG,   \"ILL_PRVREG\",   \"Privileged register.\" },\n-    { SIGILL,  ILL_COPROC,   \"ILL_COPROC\",   \"Coprocessor error.\" },\n-    { SIGILL,  ILL_BADSTK,   \"ILL_BADSTK\",   \"Internal stack error.\" },\n-#if defined(IA64) && defined(LINUX)\n-    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n-    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n-#endif\n-    { SIGFPE,  FPE_INTDIV,   \"FPE_INTDIV\",   \"Integer divide by zero.\" },\n-    { SIGFPE,  FPE_INTOVF,   \"FPE_INTOVF\",   \"Integer overflow.\" },\n-    { SIGFPE,  FPE_FLTDIV,   \"FPE_FLTDIV\",   \"Floating-point divide by zero.\" },\n-    { SIGFPE,  FPE_FLTOVF,   \"FPE_FLTOVF\",   \"Floating-point overflow.\" },\n-    { SIGFPE,  FPE_FLTUND,   \"FPE_FLTUND\",   \"Floating-point underflow.\" },\n-    { SIGFPE,  FPE_FLTRES,   \"FPE_FLTRES\",   \"Floating-point inexact result.\" },\n-    { SIGFPE,  FPE_FLTINV,   \"FPE_FLTINV\",   \"Invalid floating-point operation.\" },\n-    { SIGFPE,  FPE_FLTSUB,   \"FPE_FLTSUB\",   \"Subscript out of range.\" },\n-    { SIGSEGV, SEGV_MAPERR,  \"SEGV_MAPERR\",  \"Address not mapped to object.\" },\n-    { SIGSEGV, SEGV_ACCERR,  \"SEGV_ACCERR\",  \"Invalid permissions for mapped object.\" },\n-#ifdef AIX\n-    \/\/ no explanation found what keyerr would be\n-    { SIGSEGV, SEGV_KEYERR,  \"SEGV_KEYERR\",  \"key error\" },\n-#endif\n-#if defined(IA64) && !defined(AIX)\n-    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n-#endif\n-    { SIGBUS,  BUS_ADRALN,   \"BUS_ADRALN\",   \"Invalid address alignment.\" },\n-    { SIGBUS,  BUS_ADRERR,   \"BUS_ADRERR\",   \"Nonexistent physical address.\" },\n-    { SIGBUS,  BUS_OBJERR,   \"BUS_OBJERR\",   \"Object-specific hardware error.\" },\n-    { SIGTRAP, TRAP_BRKPT,   \"TRAP_BRKPT\",   \"Process breakpoint.\" },\n-    { SIGTRAP, TRAP_TRACE,   \"TRAP_TRACE\",   \"Process trace trap.\" },\n-    { SIGCHLD, CLD_EXITED,   \"CLD_EXITED\",   \"Child has exited.\" },\n-    { SIGCHLD, CLD_KILLED,   \"CLD_KILLED\",   \"Child has terminated abnormally and did not create a core file.\" },\n-    { SIGCHLD, CLD_DUMPED,   \"CLD_DUMPED\",   \"Child has terminated abnormally and created a core file.\" },\n-    { SIGCHLD, CLD_TRAPPED,  \"CLD_TRAPPED\",  \"Traced child has trapped.\" },\n-    { SIGCHLD, CLD_STOPPED,  \"CLD_STOPPED\",  \"Child has stopped.\" },\n-    { SIGCHLD, CLD_CONTINUED,\"CLD_CONTINUED\",\"Stopped child has continued.\" },\n-#ifdef SIGPOLL\n-    { SIGPOLL, POLL_OUT,     \"POLL_OUT\",     \"Output buffers available.\" },\n-    { SIGPOLL, POLL_MSG,     \"POLL_MSG\",     \"Input message available.\" },\n-    { SIGPOLL, POLL_ERR,     \"POLL_ERR\",     \"I\/O error.\" },\n-    { SIGPOLL, POLL_PRI,     \"POLL_PRI\",     \"High priority input available.\" },\n-    { SIGPOLL, POLL_HUP,     \"POLL_HUP\",     \"Device disconnected. [Option End]\" },\n-#endif\n-    { -1, -1, NULL, NULL }\n-  };\n-\n-  \/\/ Codes valid in any signal context.\n-  const struct {\n-    int code; const char* s_code; const char* s_desc;\n-  } t2 [] = {\n-    { SI_USER,      \"SI_USER\",     \"Signal sent by kill().\" },\n-    { SI_QUEUE,     \"SI_QUEUE\",    \"Signal sent by the sigqueue().\" },\n-    { SI_TIMER,     \"SI_TIMER\",    \"Signal generated by expiration of a timer set by timer_settime().\" },\n-    { SI_ASYNCIO,   \"SI_ASYNCIO\",  \"Signal generated by completion of an asynchronous I\/O request.\" },\n-    { SI_MESGQ,     \"SI_MESGQ\",    \"Signal generated by arrival of a message on an empty message queue.\" },\n-    \/\/ Linux specific\n-#ifdef SI_TKILL\n-    { SI_TKILL,     \"SI_TKILL\",    \"Signal sent by tkill (pthread_kill)\" },\n-#endif\n-#ifdef SI_DETHREAD\n-    { SI_DETHREAD,  \"SI_DETHREAD\", \"Signal sent by execve() killing subsidiary threads\" },\n-#endif\n-#ifdef SI_KERNEL\n-    { SI_KERNEL,    \"SI_KERNEL\",   \"Signal sent by kernel.\" },\n-#endif\n-#ifdef SI_SIGIO\n-    { SI_SIGIO,     \"SI_SIGIO\",    \"Signal sent by queued SIGIO\" },\n-#endif\n-\n-#ifdef AIX\n-    { SI_UNDEFINED, \"SI_UNDEFINED\",\"siginfo contains partial information\" },\n-    { SI_EMPTY,     \"SI_EMPTY\",    \"siginfo contains no useful information\" },\n-#endif\n-\n-#ifdef __sun\n-    { SI_NOINFO,    \"SI_NOINFO\",   \"No signal information\" },\n-    { SI_RCTL,      \"SI_RCTL\",     \"kernel generated signal via rctl action\" },\n-    { SI_LWP,       \"SI_LWP\",      \"Signal sent via lwp_kill\" },\n-#endif\n-\n-    { -1, NULL, NULL }\n-  };\n-\n-  const char* s_code = NULL;\n-  const char* s_desc = NULL;\n-\n-  for (int i = 0; t1[i].sig != -1; i ++) {\n-    if (t1[i].sig == si->si_signo && t1[i].code == si->si_code) {\n-      s_code = t1[i].s_code;\n-      s_desc = t1[i].s_desc;\n-      break;\n-    }\n-  }\n-\n-  if (s_code == NULL) {\n-    for (int i = 0; t2[i].s_code != NULL; i ++) {\n-      if (t2[i].code == si->si_code) {\n-        s_code = t2[i].s_code;\n-        s_desc = t2[i].s_desc;\n-      }\n-    }\n-  }\n-\n-  if (s_code == NULL) {\n-    out->s_name = \"unknown\";\n-    out->s_desc = \"unknown\";\n-    return false;\n-  }\n-\n-  out->s_name = s_code;\n-  out->s_desc = s_desc;\n-\n-  return true;\n-}\n-\n-bool os::signal_sent_by_kill(const void* siginfo) {\n-  const siginfo_t* const si = (const siginfo_t*)siginfo;\n-  return si->si_code == SI_USER || si->si_code == SI_QUEUE\n-#ifdef SI_TKILL\n-         || si->si_code == SI_TKILL\n-#endif\n-  ;\n-}\n-\n-void os::print_siginfo(outputStream* os, const void* si0) {\n-\n-  const siginfo_t* const si = (const siginfo_t*) si0;\n-\n-  char buf[20];\n-  os->print(\"siginfo:\");\n-\n-  if (!si) {\n-    os->print(\" <null>\");\n-    return;\n-  }\n-\n-  const int sig = si->si_signo;\n-\n-  os->print(\" si_signo: %d (%s)\", sig, os::Posix::get_signal_name(sig, buf, sizeof(buf)));\n-\n-  enum_sigcode_desc_t ed;\n-  get_signal_code_description(si, &ed);\n-  os->print(\", si_code: %d (%s)\", si->si_code, ed.s_name);\n-\n-  if (si->si_errno) {\n-    os->print(\", si_errno: %d\", si->si_errno);\n-  }\n-\n-  \/\/ Output additional information depending on the signal code.\n-\n-  \/\/ Note: Many implementations lump si_addr, si_pid, si_uid etc. together as unions,\n-  \/\/ so it depends on the context which member to use. For synchronous error signals,\n-  \/\/ we print si_addr, unless the signal was sent by another process or thread, in\n-  \/\/ which case we print out pid or tid of the sender.\n-  if (signal_sent_by_kill(si)) {\n-    const pid_t pid = si->si_pid;\n-    os->print(\", si_pid: %ld\", (long) pid);\n-    if (IS_VALID_PID(pid)) {\n-      const pid_t me = getpid();\n-      if (me == pid) {\n-        os->print(\" (current process)\");\n-      }\n-    } else {\n-      os->print(\" (invalid)\");\n-    }\n-    os->print(\", si_uid: %ld\", (long) si->si_uid);\n-    if (sig == SIGCHLD) {\n-      os->print(\", si_status: %d\", si->si_status);\n-    }\n-  } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n-             sig == SIGTRAP || sig == SIGFPE) {\n-    os->print(\", si_addr: \" PTR_FORMAT, p2i(si->si_addr));\n-#ifdef SIGPOLL\n-  } else if (sig == SIGPOLL) {\n-    os->print(\", si_band: %ld\", si->si_band);\n-#endif\n-  }\n-\n-}\n-\n-bool os::signal_thread(Thread* thread, int sig, const char* reason) {\n-  OSThread* osthread = thread->osthread();\n-  if (osthread) {\n-    int status = pthread_kill(osthread->pthread_id(), sig);\n-    if (status == 0) {\n-      Events::log(Thread::current(), \"sent signal %d to Thread \" INTPTR_FORMAT \" because %s.\",\n-                  sig, p2i(thread), reason);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-int os::Posix::unblock_thread_signal_mask(const sigset_t *set) {\n-  return pthread_sigmask(SIG_UNBLOCK, set, NULL);\n-}\n-\n-address os::Posix::ucontext_get_pc(const ucontext_t* ctx) {\n-#if defined(AIX)\n-   return Aix::ucontext_get_pc(ctx);\n-#elif defined(BSD)\n-   return Bsd::ucontext_get_pc(ctx);\n-#elif defined(LINUX)\n-   return Linux::ucontext_get_pc(ctx);\n-#else\n-   VMError::report_and_die(\"unimplemented ucontext_get_pc\");\n-#endif\n-}\n-\n-void os::Posix::ucontext_set_pc(ucontext_t* ctx, address pc) {\n-#if defined(AIX)\n-   Aix::ucontext_set_pc(ctx, pc);\n-#elif defined(BSD)\n-   Bsd::ucontext_set_pc(ctx, pc);\n-#elif defined(LINUX)\n-   Linux::ucontext_set_pc(ctx, pc);\n-#else\n-   VMError::report_and_die(\"unimplemented ucontext_get_pc\");\n-#endif\n-}\n-\n@@ -1616,16 +1012,0 @@\n-sigset_t sigs;\n-struct sigaction sigact[NSIG];\n-\n-struct sigaction* os::Posix::get_preinstalled_handler(int sig) {\n-  if (sigismember(&sigs, sig)) {\n-    return &sigact[sig];\n-  }\n-  return NULL;\n-}\n-\n-void os::Posix::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigact[sig] = oldAct;\n-  sigaddset(&sigs, sig);\n-}\n-\n@@ -1734,1 +1114,0 @@\n-  sigemptyset(&sigs);\n@@ -1747,1 +1126,0 @@\n-  sigemptyset(&sigs);\n@@ -2077,1 +1455,3 @@\n-  JavaThread *jt = JavaThread::current();\n+  Thread* thread = Thread::current();\n+  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n+  JavaThread *jt = (JavaThread *)thread;\n@@ -2122,1 +1502,1 @@\n-  OSThreadWaitState osts(jt->osthread(), false \/* not Object.wait() *\/);\n+  OSThreadWaitState osts(thread->osthread(), false \/* not Object.wait() *\/);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":624,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -66,34 +66,0 @@\n-  \/\/ Returns true if signal is valid.\n-  static bool is_valid_signal(int sig);\n-  static bool is_sig_ignored(int sig);\n-\n-  \/\/ Helper function, returns a string (e.g. \"SIGILL\") for a signal.\n-  \/\/ Returned string is a constant. For unknown signals \"UNKNOWN\" is returned.\n-  static const char* get_signal_name(int sig, char* out, size_t outlen);\n-\n-  \/\/ Helper function, returns a signal number for a given signal name, e.g. 11\n-  \/\/ for \"SIGSEGV\". Name can be given with or without \"SIG\" prefix, so both\n-  \/\/ \"SEGV\" or \"SIGSEGV\" work. Name must be uppercase.\n-  \/\/ Returns -1 for an unknown signal name.\n-  static int get_signal_number(const char* signal_name);\n-\n-  \/\/ Returns one-line short description of a signal set in a user provided buffer.\n-  static const char* describe_signal_set_short(const sigset_t* set, char* buffer, size_t size);\n-\n-  \/\/ Prints a short one-line description of a signal set.\n-  static void print_signal_set_short(outputStream* st, const sigset_t* set);\n-\n-  \/\/ unblocks the signal masks for current thread\n-  static int unblock_thread_signal_mask(const sigset_t *set);\n-\n-  \/\/ Writes a one-line description of a combination of sigaction.sa_flags\n-  \/\/ into a user provided buffer. Returns that buffer.\n-  static const char* describe_sa_flags(int flags, char* buffer, size_t size);\n-\n-  \/\/ Prints a one-line description of a combination of sigaction.sa_flags.\n-  static void print_sa_flags(outputStream* st, int flags);\n-\n-  static address ucontext_get_pc(const ucontext_t* ctx);\n-  \/\/ Set PC into context. Needed for continuation after signal.\n-  static void ucontext_set_pc(ucontext_t* ctx, address pc);\n-\n@@ -121,3 +87,0 @@\n-  static struct sigaction *get_preinstalled_handler(int);\n-  static void save_preinstalled_handler(int, struct sigaction&);\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,1653 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled\/precompiled.hpp\"\n+\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\/\/ Various signal related mechanism are laid out in the following order:\n+\/\/\n+\/\/ sun.misc.Signal\n+\/\/ signal chaining\n+\/\/ signal handling (except suspend\/resume)\n+\/\/ suspend\/resume\n+\n+\/\/ glibc on Bsd platform uses non-documented flag\n+\/\/ to indicate, that some special sort of signal\n+\/\/ trampoline is used.\n+\/\/ We will never set this flag, and we should\n+\/\/ ignore this flag in our diagnostic\n+#ifdef SIGNIFICANT_SIGNAL_MASK\n+  #undef SIGNIFICANT_SIGNAL_MASK\n+#endif\n+#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n+\n+\/\/ Todo: provide a os::get_max_process_id() or similar. Number of processes\n+\/\/ may have been configured, can be read more accurately from proc fs etc.\n+#ifndef MAX_PID\n+  #define MAX_PID INT_MAX\n+#endif\n+#define IS_VALID_PID(p) (p > 0 && p < MAX_PID)\n+\n+#define NUM_IMPORTANT_SIGS 32\n+\n+extern \"C\" {\n+  typedef void (*sa_handler_t)(int);\n+  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n+}\n+\n+\/\/ For diagnostics to print a message once. see run_periodic_checks\n+static sigset_t check_signal_done;\n+static bool check_signals = true;\n+\n+\/\/ This boolean allows users to forward their own non-matching signals\n+\/\/ to JVM_handle_bsd_signal\/JVM_handle_linux_signal, harmlessly.\n+static bool signal_handlers_are_installed = false;\n+\n+debug_only(static bool signal_sets_initialized = false);\n+static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+struct sigaction sigact[NSIG];\n+\n+\/\/ For signal-chaining\n+static bool libjsig_is_loaded = false;\n+typedef struct sigaction *(*get_signal_t)(int);\n+static get_signal_t get_signal_action = NULL;\n+\n+\/\/ For diagnostic\n+int sigflags[NSIG];\n+\n+\/\/ suspend\/resume support\n+#if defined(__APPLE__)\n+  static OSXSemaphore sr_semaphore;\n+#else\n+  static PosixSemaphore sr_semaphore;\n+#endif\n+\n+\/\/ sun.misc.Signal support\n+static Semaphore* sig_semaphore = NULL;\n+\/\/ a counter for each possible signal value\n+static volatile jint pending_signals[NSIG+1] = { 0 };\n+\n+static const struct {\n+  int sig; const char* name;\n+}\n+\n+g_signal_info[] = {\n+  {  SIGABRT,     \"SIGABRT\" },\n+#ifdef SIGAIO\n+  {  SIGAIO,      \"SIGAIO\" },\n+#endif\n+  {  SIGALRM,     \"SIGALRM\" },\n+#ifdef SIGALRM1\n+  {  SIGALRM1,    \"SIGALRM1\" },\n+#endif\n+  {  SIGBUS,      \"SIGBUS\" },\n+#ifdef SIGCANCEL\n+  {  SIGCANCEL,   \"SIGCANCEL\" },\n+#endif\n+  {  SIGCHLD,     \"SIGCHLD\" },\n+#ifdef SIGCLD\n+  {  SIGCLD,      \"SIGCLD\" },\n+#endif\n+  {  SIGCONT,     \"SIGCONT\" },\n+#ifdef SIGCPUFAIL\n+  {  SIGCPUFAIL,  \"SIGCPUFAIL\" },\n+#endif\n+#ifdef SIGDANGER\n+  {  SIGDANGER,   \"SIGDANGER\" },\n+#endif\n+#ifdef SIGDIL\n+  {  SIGDIL,      \"SIGDIL\" },\n+#endif\n+#ifdef SIGEMT\n+  {  SIGEMT,      \"SIGEMT\" },\n+#endif\n+  {  SIGFPE,      \"SIGFPE\" },\n+#ifdef SIGFREEZE\n+  {  SIGFREEZE,   \"SIGFREEZE\" },\n+#endif\n+#ifdef SIGGFAULT\n+  {  SIGGFAULT,   \"SIGGFAULT\" },\n+#endif\n+#ifdef SIGGRANT\n+  {  SIGGRANT,    \"SIGGRANT\" },\n+#endif\n+  {  SIGHUP,      \"SIGHUP\" },\n+  {  SIGILL,      \"SIGILL\" },\n+#ifdef SIGINFO\n+  {  SIGINFO,     \"SIGINFO\" },\n+#endif\n+  {  SIGINT,      \"SIGINT\" },\n+#ifdef SIGIO\n+  {  SIGIO,       \"SIGIO\" },\n+#endif\n+#ifdef SIGIOINT\n+  {  SIGIOINT,    \"SIGIOINT\" },\n+#endif\n+#ifdef SIGIOT\n+\/\/ SIGIOT is there for BSD compatibility, but on most Unices just a\n+\/\/ synonym for SIGABRT. The result should be \"SIGABRT\", not\n+\/\/ \"SIGIOT\".\n+#if (SIGIOT != SIGABRT )\n+  {  SIGIOT,      \"SIGIOT\" },\n+#endif\n+#endif\n+#ifdef SIGKAP\n+  {  SIGKAP,      \"SIGKAP\" },\n+#endif\n+  {  SIGKILL,     \"SIGKILL\" },\n+#ifdef SIGLOST\n+  {  SIGLOST,     \"SIGLOST\" },\n+#endif\n+#ifdef SIGLWP\n+  {  SIGLWP,      \"SIGLWP\" },\n+#endif\n+#ifdef SIGLWPTIMER\n+  {  SIGLWPTIMER, \"SIGLWPTIMER\" },\n+#endif\n+#ifdef SIGMIGRATE\n+  {  SIGMIGRATE,  \"SIGMIGRATE\" },\n+#endif\n+#ifdef SIGMSG\n+  {  SIGMSG,      \"SIGMSG\" },\n+#endif\n+  {  SIGPIPE,     \"SIGPIPE\" },\n+#ifdef SIGPOLL\n+  {  SIGPOLL,     \"SIGPOLL\" },\n+#endif\n+#ifdef SIGPRE\n+  {  SIGPRE,      \"SIGPRE\" },\n+#endif\n+  {  SIGPROF,     \"SIGPROF\" },\n+#ifdef SIGPTY\n+  {  SIGPTY,      \"SIGPTY\" },\n+#endif\n+#ifdef SIGPWR\n+  {  SIGPWR,      \"SIGPWR\" },\n+#endif\n+  {  SIGQUIT,     \"SIGQUIT\" },\n+#ifdef SIGRECONFIG\n+  {  SIGRECONFIG, \"SIGRECONFIG\" },\n+#endif\n+#ifdef SIGRECOVERY\n+  {  SIGRECOVERY, \"SIGRECOVERY\" },\n+#endif\n+#ifdef SIGRESERVE\n+  {  SIGRESERVE,  \"SIGRESERVE\" },\n+#endif\n+#ifdef SIGRETRACT\n+  {  SIGRETRACT,  \"SIGRETRACT\" },\n+#endif\n+#ifdef SIGSAK\n+  {  SIGSAK,      \"SIGSAK\" },\n+#endif\n+  {  SIGSEGV,     \"SIGSEGV\" },\n+#ifdef SIGSOUND\n+  {  SIGSOUND,    \"SIGSOUND\" },\n+#endif\n+#ifdef SIGSTKFLT\n+  {  SIGSTKFLT,    \"SIGSTKFLT\" },\n+#endif\n+  {  SIGSTOP,     \"SIGSTOP\" },\n+  {  SIGSYS,      \"SIGSYS\" },\n+#ifdef SIGSYSERROR\n+  {  SIGSYSERROR, \"SIGSYSERROR\" },\n+#endif\n+#ifdef SIGTALRM\n+  {  SIGTALRM,    \"SIGTALRM\" },\n+#endif\n+  {  SIGTERM,     \"SIGTERM\" },\n+#ifdef SIGTHAW\n+  {  SIGTHAW,     \"SIGTHAW\" },\n+#endif\n+  {  SIGTRAP,     \"SIGTRAP\" },\n+#ifdef SIGTSTP\n+  {  SIGTSTP,     \"SIGTSTP\" },\n+#endif\n+  {  SIGTTIN,     \"SIGTTIN\" },\n+  {  SIGTTOU,     \"SIGTTOU\" },\n+#ifdef SIGURG\n+  {  SIGURG,      \"SIGURG\" },\n+#endif\n+  {  SIGUSR1,     \"SIGUSR1\" },\n+  {  SIGUSR2,     \"SIGUSR2\" },\n+#ifdef SIGVIRT\n+  {  SIGVIRT,     \"SIGVIRT\" },\n+#endif\n+  {  SIGVTALRM,   \"SIGVTALRM\" },\n+#ifdef SIGWAITING\n+  {  SIGWAITING,  \"SIGWAITING\" },\n+#endif\n+#ifdef SIGWINCH\n+  {  SIGWINCH,    \"SIGWINCH\" },\n+#endif\n+#ifdef SIGWINDOW\n+  {  SIGWINDOW,   \"SIGWINDOW\" },\n+#endif\n+  {  SIGXCPU,     \"SIGXCPU\" },\n+  {  SIGXFSZ,     \"SIGXFSZ\" },\n+#ifdef SIGXRES\n+  {  SIGXRES,     \"SIGXRES\" },\n+#endif\n+  { -1, NULL }\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ sun.misc.Signal support\n+\n+void PosixSignals::jdk_misc_signal_init() {\n+  \/\/ Initialize signal structures\n+  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n+\n+  \/\/ Initialize signal semaphore\n+  sig_semaphore = new Semaphore();\n+}\n+\n+void os::signal_notify(int sig) {\n+  if (sig_semaphore != NULL) {\n+    Atomic::inc(&pending_signals[sig]);\n+    sig_semaphore->signal();\n+  } else {\n+    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n+    \/\/ initialization isn't called.\n+    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n+  }\n+}\n+\n+static int check_pending_signals() {\n+  for (;;) {\n+    for (int i = 0; i < NSIG + 1; i++) {\n+      jint n = pending_signals[i];\n+      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n+        return i;\n+      }\n+    }\n+    JavaThread *thread = JavaThread::current();\n+    ThreadBlockInVM tbivm(thread);\n+\n+    bool threadIsSuspended;\n+    do {\n+      thread->set_suspend_equivalent();\n+      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n+      sig_semaphore->wait();\n+\n+      \/\/ were we externally suspended while we were waiting?\n+      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n+      if (threadIsSuspended) {\n+        \/\/ The semaphore has been incremented, but while we were waiting\n+        \/\/ another thread suspended us. We don't want to continue running\n+        \/\/ while suspended because that would surprise the thread that\n+        \/\/ suspended us.\n+        sig_semaphore->signal();\n+\n+        thread->java_suspend_self();\n+      }\n+    } while (threadIsSuspended);\n+  }\n+}\n+\n+int os::signal_wait() {\n+  return check_pending_signals();\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ signal chaining support\n+\n+static struct sigaction* get_preinstalled_handler(int sig) {\n+  if (sigismember(&preinstalled_sigs, sig)) {\n+    return &sigact[sig];\n+  }\n+  return NULL;\n+}\n+\n+static void save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n+  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n+  sigact[sig] = oldAct;\n+  sigaddset(&preinstalled_sigs, sig);\n+}\n+\n+struct sigaction* get_chained_signal_action(int sig) {\n+  struct sigaction *actp = NULL;\n+\n+  if (libjsig_is_loaded) {\n+    \/\/ Retrieve the old signal handler from libjsig\n+    actp = (*get_signal_action)(sig);\n+  }\n+  if (actp == NULL) {\n+    \/\/ Retrieve the preinstalled signal handler from jvm\n+    actp = get_preinstalled_handler(sig);\n+  }\n+\n+  return actp;\n+}\n+\n+static bool call_chained_handler(struct sigaction *actp, int sig,\n+                                 siginfo_t *siginfo, void *context) {\n+  \/\/ Call the old signal handler\n+  if (actp->sa_handler == SIG_DFL) {\n+    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n+    \/\/ instead of taking the default action.\n+    return false;\n+  } else if (actp->sa_handler != SIG_IGN) {\n+    if ((actp->sa_flags & SA_NODEFER) == 0) {\n+      \/\/ automaticlly block the signal\n+      sigaddset(&(actp->sa_mask), sig);\n+    }\n+\n+    sa_handler_t hand = NULL;\n+    sa_sigaction_t sa = NULL;\n+    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n+    \/\/ retrieve the chained handler\n+    if (siginfo_flag_set) {\n+      sa = actp->sa_sigaction;\n+    } else {\n+      hand = actp->sa_handler;\n+    }\n+\n+    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n+      actp->sa_handler = SIG_DFL;\n+    }\n+\n+    \/\/ try to honor the signal mask\n+    sigset_t oset;\n+    sigemptyset(&oset);\n+    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n+\n+    \/\/ call into the chained handler\n+    if (siginfo_flag_set) {\n+      (*sa)(sig, siginfo, context);\n+    } else {\n+      (*hand)(sig);\n+    }\n+\n+    \/\/ restore the signal mask\n+    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n+  }\n+  \/\/ Tell jvm's signal handler the signal is taken care of.\n+  return true;\n+}\n+\n+bool PosixSignals::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n+  bool chained = false;\n+  \/\/ signal-chaining\n+  if (UseSignalChaining) {\n+    struct sigaction *actp = get_chained_signal_action(sig);\n+    if (actp != NULL) {\n+      chained = call_chained_handler(actp, sig, siginfo, context);\n+    }\n+  }\n+  return chained;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ signal handling (except suspend\/resume)\n+\n+\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n+\/\/ The user-defined signal handler must pass unrecognized signals to this\n+\/\/ routine, and if it returns true (non-zero), then the signal handler must\n+\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n+\/\/ routine will never retun false (zero), but instead will execute a VM panic\n+\/\/ routine kill the process.\n+\/\/\n+\/\/ If this routine returns false, it is OK to call it again.  This allows\n+\/\/ the user-defined signal handler to perform checks either before or after\n+\/\/ the VM performs its own checks.  Naturally, the user code would be making\n+\/\/ a serious error if it tried to handle an exception (such as a null check\n+\/\/ or breakpoint) that the VM was generating for its own correct operation.\n+\/\/\n+\/\/ This routine may recognize any of the following kinds of signals:\n+\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n+\/\/ It should be consulted by handlers for any of those signals.\n+\/\/\n+\/\/ The caller of this routine must pass in the three arguments supplied\n+\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n+\/\/ field of the structure passed to sigaction().  This routine assumes that\n+\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n+\/\/\n+\/\/ Note that the VM will print warnings if it detects conflicting signal\n+\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n+\/\/\n+\n+#if defined(__APPLE__)\n+extern \"C\" JNIEXPORT int JVM_handle_bsd_signal(int signo, siginfo_t* siginfo,\n+                                               void* ucontext,\n+                                               int abort_if_unrecognized);\n+#elif defined(AIX)\n+extern \"C\" JNIEXPORT int JVM_handle_aix_signal(int signo, siginfo_t* siginfo,\n+                                               void* ucontext,\n+                                               int abort_if_unrecognized);\n+#else\n+extern \"C\" JNIEXPORT int JVM_handle_linux_signal(int signo, siginfo_t* siginfo,\n+                                               void* ucontext,\n+                                               int abort_if_unrecognized);\n+#endif\n+\n+\/\/ Set thread signal mask (for some reason on AIX sigthreadmask() seems\n+\/\/ to be the thing to call; documentation is not terribly clear about whether\n+\/\/ pthread_sigmask also works, and if it does, whether it does the same.\n+bool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n+  const int rc = ::pthread_sigmask(how, set, oset);\n+  \/\/ return value semantics differ slightly for error case:\n+  \/\/ pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n+  \/\/ (so, pthread_sigmask is more theadsafe for error handling)\n+  \/\/ But success is always 0.\n+  return rc == 0 ? true : false;\n+}\n+\n+\/\/ Function to unblock all signals which are, according\n+\/\/ to POSIX, typical program error signals. If they happen while being blocked,\n+\/\/ they typically will bring down the process immediately.\n+bool unblock_program_error_signals() {\n+  sigset_t set;\n+  sigemptyset(&set);\n+  sigaddset(&set, SIGILL);\n+  sigaddset(&set, SIGBUS);\n+  sigaddset(&set, SIGFPE);\n+  sigaddset(&set, SIGSEGV);\n+  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n+}\n+\n+\/\/ Renamed from 'signalHandler' to avoid collision with other shared libs.\n+static void javaSignalHandler(int sig, siginfo_t* info, void* uc) {\n+  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n+\n+\/\/ TODO: reconcile the differences between Linux\/BSD vs AIX here!\n+#if defined(AIX)\n+  \/\/ Never leave program error signals blocked;\n+  \/\/ on all our platforms they would bring down the process immediately when\n+  \/\/ getting raised while being blocked.\n+  unblock_program_error_signals();\n+#endif\n+\n+  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n+#if defined(__APPLE__)\n+  JVM_handle_bsd_signal(sig, info, uc, true);\n+#elif defined(AIX)\n+  JVM_handle_aix_signal(sig, info, uc, true);\n+#else\n+  JVM_handle_linux_signal(sig, info, uc, true);\n+#endif\n+  errno = orig_errno;\n+}\n+\n+static void UserHandler(int sig, void *siginfo, void *context) {\n+  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n+  \/\/ handler fails to abort. Let VM die immediately.\n+  if (sig == SIGINT && VMError::is_error_reported()) {\n+    os::die();\n+  }\n+\n+  os::signal_notify(sig);\n+}\n+\n+static const char* get_signal_handler_name(address handler,\n+                                           char* buf, int buflen) {\n+  int offset = 0;\n+  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n+  if (found) {\n+    \/\/ skip directory names\n+    const char *p1, *p2;\n+    p1 = buf;\n+    size_t len = strlen(os::file_separator());\n+    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n+#if !defined(AIX)\n+    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n+#else\n+    \/\/ The way os::dll_address_to_library_name is implemented on Aix\n+    \/\/ right now, it always returns -1 for the offset which is not\n+    \/\/ terribly informative.\n+    \/\/ Will fix that. For now, omit the offset.\n+    jio_snprintf(buf, buflen, \"%s\", p1);\n+#endif\n+  } else {\n+    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n+  }\n+  return buf;\n+}\n+\n+\/\/ Writes one-line description of a combination of sigaction.sa_flags into a user\n+\/\/ provided buffer. Returns that buffer.\n+static const char* describe_sa_flags(int flags, char* buffer, size_t size) {\n+  char* p = buffer;\n+  size_t remaining = size;\n+  bool first = true;\n+  int idx = 0;\n+\n+  assert(buffer, \"invalid argument\");\n+\n+  if (size == 0) {\n+    return buffer;\n+  }\n+\n+  strncpy(buffer, \"none\", size);\n+\n+  const struct {\n+    \/\/ NB: i is an unsigned int here because SA_RESETHAND is on some\n+    \/\/ systems 0x80000000, which is implicitly unsigned.  Assignining\n+    \/\/ it to an int field would be an overflow in unsigned-to-signed\n+    \/\/ conversion.\n+    unsigned int i;\n+    const char* s;\n+  } flaginfo [] = {\n+    { SA_NOCLDSTOP, \"SA_NOCLDSTOP\" },\n+    { SA_ONSTACK,   \"SA_ONSTACK\"   },\n+    { SA_RESETHAND, \"SA_RESETHAND\" },\n+    { SA_RESTART,   \"SA_RESTART\"   },\n+    { SA_SIGINFO,   \"SA_SIGINFO\"   },\n+    { SA_NOCLDWAIT, \"SA_NOCLDWAIT\" },\n+    { SA_NODEFER,   \"SA_NODEFER\"   },\n+#if defined(AIX)\n+    { SA_ONSTACK,   \"SA_ONSTACK\"   },\n+    { SA_OLDSTYLE,  \"SA_OLDSTYLE\"  },\n+#endif\n+    { 0, NULL }\n+  };\n+\n+  for (idx = 0; flaginfo[idx].s && remaining > 1; idx++) {\n+    if (flags & flaginfo[idx].i) {\n+      if (first) {\n+        jio_snprintf(p, remaining, \"%s\", flaginfo[idx].s);\n+        first = false;\n+      } else {\n+        jio_snprintf(p, remaining, \"|%s\", flaginfo[idx].s);\n+      }\n+      const size_t len = strlen(p);\n+      p += len;\n+      remaining -= len;\n+    }\n+  }\n+\n+  buffer[size - 1] = '\\0';\n+\n+  return buffer;\n+}\n+\n+\/\/ Prints one-line description of a combination of sigaction.sa_flags.\n+static void print_sa_flags(outputStream* st, int flags) {\n+  char buffer[0x100];\n+  describe_sa_flags(flags, buffer, sizeof(buffer));\n+  st->print(\"%s\", buffer);\n+}\n+\n+static int get_our_sigflags(int sig) {\n+  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n+  return sigflags[sig];\n+}\n+\n+static void set_our_sigflags(int sig, int flags) {\n+  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n+  if (sig > 0 && sig < NSIG) {\n+    sigflags[sig] = flags;\n+  }\n+}\n+\n+typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n+\n+static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context);\n+\n+static void check_signal_handler(int sig) {\n+  char buf[O_BUFLEN];\n+  address jvmHandler = NULL;\n+\n+  struct sigaction act;\n+  static os_sigaction_t os_sigaction = NULL;\n+  if (os_sigaction == NULL) {\n+    \/\/ only trust the default sigaction, in case it has been interposed\n+    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n+    if (os_sigaction == NULL) return;\n+  }\n+\n+  os_sigaction(sig, (struct sigaction*)NULL, &act);\n+\n+\n+  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n+\n+  address thisHandler = (act.sa_flags & SA_SIGINFO)\n+    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n+    : CAST_FROM_FN_PTR(address, act.sa_handler);\n+\n+\n+  switch (sig) {\n+  case SIGSEGV:\n+  case SIGBUS:\n+  case SIGFPE:\n+  case SIGPIPE:\n+  case SIGILL:\n+  case SIGXFSZ:\n+    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n+    break;\n+\n+  case SHUTDOWN1_SIGNAL:\n+  case SHUTDOWN2_SIGNAL:\n+  case SHUTDOWN3_SIGNAL:\n+  case BREAK_SIGNAL:\n+    jvmHandler = (address)os::user_handler();\n+    break;\n+\n+  default:\n+    if (sig == SR_signum) {\n+      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n+    } else {\n+      return;\n+    }\n+    break;\n+  }\n+\n+  if (thisHandler != jvmHandler) {\n+    tty->print(\"Warning: %s handler \", os::exception_name(sig, buf, O_BUFLEN));\n+    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n+    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n+    \/\/ No need to check this sig any longer\n+    sigaddset(&check_signal_done, sig);\n+    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n+    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n+      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n+                    os::exception_name(sig, buf, O_BUFLEN));\n+    }\n+  } else if (get_our_sigflags(sig) != 0 && (int)act.sa_flags != get_our_sigflags(sig)) {\n+    tty->print(\"Warning: %s handler flags \", os::exception_name(sig, buf, O_BUFLEN));\n+    tty->print(\"expected:\");\n+    print_sa_flags(tty, get_our_sigflags(sig));\n+    tty->cr();\n+    tty->print(\"  found:\");\n+    print_sa_flags(tty, act.sa_flags);\n+    tty->cr();\n+    \/\/ No need to check this sig any longer\n+    sigaddset(&check_signal_done, sig);\n+  }\n+\n+  \/\/ Dump all the signal\n+  if (sigismember(&check_signal_done, sig)) {\n+    os::print_signal_handlers(tty, buf, O_BUFLEN);\n+  }\n+}\n+\n+void* os::user_handler() {\n+  return CAST_FROM_FN_PTR(void*, UserHandler);\n+}\n+\n+void* os::signal(int signal_number, void* handler) {\n+  struct sigaction sigAct, oldSigAct;\n+\n+  sigfillset(&(sigAct.sa_mask));\n+\n+#if defined(AIX)\n+  \/\/ Do not block out synchronous signals in the signal handler.\n+  \/\/ Blocking synchronous signals only makes sense if you can really\n+  \/\/ be sure that those signals won't happen during signal handling,\n+  \/\/ when the blocking applies. Normal signal handlers are lean and\n+  \/\/ do not cause signals. But our signal handlers tend to be \"risky\"\n+  \/\/ - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n+  \/\/ On AIX, PASE there was a case where a SIGSEGV happened, followed\n+  \/\/ by a SIGILL, which was blocked due to the signal mask. The process\n+  \/\/ just hung forever. Better to crash from a secondary signal than to hang.\n+  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n+  sigdelset(&(sigAct.sa_mask), SIGBUS);\n+  sigdelset(&(sigAct.sa_mask), SIGILL);\n+  sigdelset(&(sigAct.sa_mask), SIGFPE);\n+  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n+#endif\n+\n+  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n+  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n+\n+  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n+    \/\/ -1 means registration failed\n+    return (void *)-1;\n+  }\n+\n+  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n+}\n+\n+void os::signal_raise(int signal_number) {\n+  ::raise(signal_number);\n+}\n+\n+\/\/ Will be modified when max signal is changed to be dynamic\n+int os::sigexitnum_pd() {\n+  return NSIG;\n+}\n+\n+static void do_signal_check(int signal) {\n+  if (!sigismember(&check_signal_done, signal)) {\n+    check_signal_handler(signal);\n+  }\n+}\n+\n+\/\/ This method is a periodic task to check for misbehaving JNI applications\n+\/\/ under CheckJNI, we can add any periodic checks here\n+\n+void os::run_periodic_checks() {\n+\n+  if (check_signals == false) return;\n+\n+  \/\/ SEGV and BUS if overridden could potentially prevent\n+  \/\/ generation of hs*.log in the event of a crash, debugging\n+  \/\/ such a case can be very challenging, so we absolutely\n+  \/\/ check the following for a good measure:\n+  do_signal_check(SIGSEGV);\n+  do_signal_check(SIGILL);\n+  do_signal_check(SIGFPE);\n+  do_signal_check(SIGBUS);\n+  do_signal_check(SIGPIPE);\n+  do_signal_check(SIGXFSZ);\n+#if defined(PPC64)\n+  do_signal_check(SIGTRAP);\n+#endif\n+\n+  \/\/ ReduceSignalUsage allows the user to override these handlers\n+  \/\/ see comments at the very top and jvm_md.h\n+  if (!ReduceSignalUsage) {\n+    do_signal_check(SHUTDOWN1_SIGNAL);\n+    do_signal_check(SHUTDOWN2_SIGNAL);\n+    do_signal_check(SHUTDOWN3_SIGNAL);\n+    do_signal_check(BREAK_SIGNAL);\n+  }\n+\n+  do_signal_check(SR_signum);\n+}\n+\n+\/\/ Helper function for PosixSignals::print_siginfo_...():\n+\/\/ return a textual description for signal code.\n+struct enum_sigcode_desc_t {\n+  const char* s_name;\n+  const char* s_desc;\n+};\n+\n+static bool get_signal_code_description(const siginfo_t* si, enum_sigcode_desc_t* out) {\n+\n+  const struct {\n+    int sig; int code; const char* s_code; const char* s_desc;\n+  } t1 [] = {\n+    { SIGILL,  ILL_ILLOPC,   \"ILL_ILLOPC\",   \"Illegal opcode.\" },\n+    { SIGILL,  ILL_ILLOPN,   \"ILL_ILLOPN\",   \"Illegal operand.\" },\n+    { SIGILL,  ILL_ILLADR,   \"ILL_ILLADR\",   \"Illegal addressing mode.\" },\n+    { SIGILL,  ILL_ILLTRP,   \"ILL_ILLTRP\",   \"Illegal trap.\" },\n+    { SIGILL,  ILL_PRVOPC,   \"ILL_PRVOPC\",   \"Privileged opcode.\" },\n+    { SIGILL,  ILL_PRVREG,   \"ILL_PRVREG\",   \"Privileged register.\" },\n+    { SIGILL,  ILL_COPROC,   \"ILL_COPROC\",   \"Coprocessor error.\" },\n+    { SIGILL,  ILL_BADSTK,   \"ILL_BADSTK\",   \"Internal stack error.\" },\n+#if defined(IA64) && defined(LINUX)\n+    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n+    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n+#endif\n+    { SIGFPE,  FPE_INTDIV,   \"FPE_INTDIV\",   \"Integer divide by zero.\" },\n+    { SIGFPE,  FPE_INTOVF,   \"FPE_INTOVF\",   \"Integer overflow.\" },\n+    { SIGFPE,  FPE_FLTDIV,   \"FPE_FLTDIV\",   \"Floating-point divide by zero.\" },\n+    { SIGFPE,  FPE_FLTOVF,   \"FPE_FLTOVF\",   \"Floating-point overflow.\" },\n+    { SIGFPE,  FPE_FLTUND,   \"FPE_FLTUND\",   \"Floating-point underflow.\" },\n+    { SIGFPE,  FPE_FLTRES,   \"FPE_FLTRES\",   \"Floating-point inexact result.\" },\n+    { SIGFPE,  FPE_FLTINV,   \"FPE_FLTINV\",   \"Invalid floating-point operation.\" },\n+    { SIGFPE,  FPE_FLTSUB,   \"FPE_FLTSUB\",   \"Subscript out of range.\" },\n+    { SIGSEGV, SEGV_MAPERR,  \"SEGV_MAPERR\",  \"Address not mapped to object.\" },\n+    { SIGSEGV, SEGV_ACCERR,  \"SEGV_ACCERR\",  \"Invalid permissions for mapped object.\" },\n+#if defined(AIX)\n+    \/\/ no explanation found what keyerr would be\n+    { SIGSEGV, SEGV_KEYERR,  \"SEGV_KEYERR\",  \"key error\" },\n+#endif\n+#if defined(IA64) && !defined(AIX)\n+    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n+#endif\n+    { SIGBUS,  BUS_ADRALN,   \"BUS_ADRALN\",   \"Invalid address alignment.\" },\n+    { SIGBUS,  BUS_ADRERR,   \"BUS_ADRERR\",   \"Nonexistent physical address.\" },\n+    { SIGBUS,  BUS_OBJERR,   \"BUS_OBJERR\",   \"Object-specific hardware error.\" },\n+    { SIGTRAP, TRAP_BRKPT,   \"TRAP_BRKPT\",   \"Process breakpoint.\" },\n+    { SIGTRAP, TRAP_TRACE,   \"TRAP_TRACE\",   \"Process trace trap.\" },\n+    { SIGCHLD, CLD_EXITED,   \"CLD_EXITED\",   \"Child has exited.\" },\n+    { SIGCHLD, CLD_KILLED,   \"CLD_KILLED\",   \"Child has terminated abnormally and did not create a core file.\" },\n+    { SIGCHLD, CLD_DUMPED,   \"CLD_DUMPED\",   \"Child has terminated abnormally and created a core file.\" },\n+    { SIGCHLD, CLD_TRAPPED,  \"CLD_TRAPPED\",  \"Traced child has trapped.\" },\n+    { SIGCHLD, CLD_STOPPED,  \"CLD_STOPPED\",  \"Child has stopped.\" },\n+    { SIGCHLD, CLD_CONTINUED,\"CLD_CONTINUED\",\"Stopped child has continued.\" },\n+#ifdef SIGPOLL\n+    { SIGPOLL, POLL_OUT,     \"POLL_OUT\",     \"Output buffers available.\" },\n+    { SIGPOLL, POLL_MSG,     \"POLL_MSG\",     \"Input message available.\" },\n+    { SIGPOLL, POLL_ERR,     \"POLL_ERR\",     \"I\/O error.\" },\n+    { SIGPOLL, POLL_PRI,     \"POLL_PRI\",     \"High priority input available.\" },\n+    { SIGPOLL, POLL_HUP,     \"POLL_HUP\",     \"Device disconnected. [Option End]\" },\n+#endif\n+    { -1, -1, NULL, NULL }\n+  };\n+\n+  \/\/ Codes valid in any signal context.\n+  const struct {\n+    int code; const char* s_code; const char* s_desc;\n+  } t2 [] = {\n+    { SI_USER,      \"SI_USER\",     \"Signal sent by kill().\" },\n+    { SI_QUEUE,     \"SI_QUEUE\",    \"Signal sent by the sigqueue().\" },\n+    { SI_TIMER,     \"SI_TIMER\",    \"Signal generated by expiration of a timer set by timer_settime().\" },\n+    { SI_ASYNCIO,   \"SI_ASYNCIO\",  \"Signal generated by completion of an asynchronous I\/O request.\" },\n+    { SI_MESGQ,     \"SI_MESGQ\",    \"Signal generated by arrival of a message on an empty message queue.\" },\n+    \/\/ Linux specific\n+#ifdef SI_TKILL\n+    { SI_TKILL,     \"SI_TKILL\",    \"Signal sent by tkill (pthread_kill)\" },\n+#endif\n+#ifdef SI_DETHREAD\n+    { SI_DETHREAD,  \"SI_DETHREAD\", \"Signal sent by execve() killing subsidiary threads\" },\n+#endif\n+#ifdef SI_KERNEL\n+    { SI_KERNEL,    \"SI_KERNEL\",   \"Signal sent by kernel.\" },\n+#endif\n+#ifdef SI_SIGIO\n+    { SI_SIGIO,     \"SI_SIGIO\",    \"Signal sent by queued SIGIO\" },\n+#endif\n+\n+#if defined(AIX)\n+    { SI_UNDEFINED, \"SI_UNDEFINED\",\"siginfo contains partial information\" },\n+    { SI_EMPTY,     \"SI_EMPTY\",    \"siginfo contains no useful information\" },\n+#endif\n+\n+    { -1, NULL, NULL }\n+  };\n+\n+  const char* s_code = NULL;\n+  const char* s_desc = NULL;\n+\n+  for (int i = 0; t1[i].sig != -1; i ++) {\n+    if (t1[i].sig == si->si_signo && t1[i].code == si->si_code) {\n+      s_code = t1[i].s_code;\n+      s_desc = t1[i].s_desc;\n+      break;\n+    }\n+  }\n+\n+  if (s_code == NULL) {\n+    for (int i = 0; t2[i].s_code != NULL; i ++) {\n+      if (t2[i].code == si->si_code) {\n+        s_code = t2[i].s_code;\n+        s_desc = t2[i].s_desc;\n+      }\n+    }\n+  }\n+\n+  if (s_code == NULL) {\n+    out->s_name = \"unknown\";\n+    out->s_desc = \"unknown\";\n+    return false;\n+  }\n+\n+  out->s_name = s_code;\n+  out->s_desc = s_desc;\n+\n+  return true;\n+}\n+\n+bool os::signal_sent_by_kill(const void* siginfo) {\n+  const siginfo_t* const si = (const siginfo_t*)siginfo;\n+  return si->si_code == SI_USER || si->si_code == SI_QUEUE\n+#ifdef SI_TKILL\n+         || si->si_code == SI_TKILL\n+#endif\n+  ;\n+}\n+\n+\/\/ Returns true if signal number is valid.\n+static bool is_valid_signal(int sig) {\n+  \/\/ MacOS not really POSIX compliant: sigaddset does not return\n+  \/\/ an error for invalid signal numbers. However, MacOS does not\n+  \/\/ support real time signals and simply seems to have just 33\n+  \/\/ signals with no holes in the signal range.\n+#if defined(__APPLE__)\n+  return sig >= 1 && sig < NSIG;\n+#else\n+  \/\/ Use sigaddset to check for signal validity.\n+  sigset_t set;\n+  sigemptyset(&set);\n+  if (sigaddset(&set, sig) == -1 && errno == EINVAL) {\n+    return false;\n+  }\n+  return true;\n+#endif\n+}\n+\n+\/\/ Returned string is a constant. For unknown signals \"UNKNOWN\" is returned.\n+static const char* get_signal_name(int sig, char* out, size_t outlen) {\n+\n+  const char* ret = NULL;\n+\n+#ifdef SIGRTMIN\n+  if (sig >= SIGRTMIN && sig <= SIGRTMAX) {\n+    if (sig == SIGRTMIN) {\n+      ret = \"SIGRTMIN\";\n+    } else if (sig == SIGRTMAX) {\n+      ret = \"SIGRTMAX\";\n+    } else {\n+      jio_snprintf(out, outlen, \"SIGRTMIN+%d\", sig - SIGRTMIN);\n+      return out;\n+    }\n+  }\n+#endif\n+\n+  if (sig > 0) {\n+    for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n+      if (g_signal_info[idx].sig == sig) {\n+        ret = g_signal_info[idx].name;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (!ret) {\n+    if (!is_valid_signal(sig)) {\n+      ret = \"INVALID\";\n+    } else {\n+      ret = \"UNKNOWN\";\n+    }\n+  }\n+\n+  if (out && outlen > 0) {\n+    strncpy(out, ret, outlen);\n+    out[outlen - 1] = '\\0';\n+  }\n+  return out;\n+}\n+\n+void os::print_siginfo(outputStream* os, const void* si0) {\n+\n+  const siginfo_t* const si = (const siginfo_t*) si0;\n+\n+  char buf[20];\n+  os->print(\"siginfo:\");\n+\n+  if (!si) {\n+    os->print(\" <null>\");\n+    return;\n+  }\n+\n+  const int sig = si->si_signo;\n+\n+  os->print(\" si_signo: %d (%s)\", sig, get_signal_name(sig, buf, sizeof(buf)));\n+\n+  enum_sigcode_desc_t ed;\n+  get_signal_code_description(si, &ed);\n+  os->print(\", si_code: %d (%s)\", si->si_code, ed.s_name);\n+\n+  if (si->si_errno) {\n+    os->print(\", si_errno: %d\", si->si_errno);\n+  }\n+\n+  \/\/ Output additional information depending on the signal code.\n+\n+  \/\/ Note: Many implementations lump si_addr, si_pid, si_uid etc. together as unions,\n+  \/\/ so it depends on the context which member to use. For synchronous error signals,\n+  \/\/ we print si_addr, unless the signal was sent by another process or thread, in\n+  \/\/ which case we print out pid or tid of the sender.\n+  if (os::signal_sent_by_kill(si)) {\n+    const pid_t pid = si->si_pid;\n+    os->print(\", si_pid: %ld\", (long) pid);\n+    if (IS_VALID_PID(pid)) {\n+      const pid_t me = getpid();\n+      if (me == pid) {\n+        os->print(\" (current process)\");\n+      }\n+    } else {\n+      os->print(\" (invalid)\");\n+    }\n+    os->print(\", si_uid: %ld\", (long) si->si_uid);\n+    if (sig == SIGCHLD) {\n+      os->print(\", si_status: %d\", si->si_status);\n+    }\n+  } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n+             sig == SIGTRAP || sig == SIGFPE) {\n+    os->print(\", si_addr: \" PTR_FORMAT, p2i(si->si_addr));\n+#ifdef SIGPOLL\n+  } else if (sig == SIGPOLL) {\n+    os->print(\", si_band: %ld\", si->si_band);\n+#endif\n+  }\n+}\n+\n+bool os::signal_thread(Thread* thread, int sig, const char* reason) {\n+  OSThread* osthread = thread->osthread();\n+  if (osthread) {\n+    int status = pthread_kill(osthread->pthread_id(), sig);\n+    if (status == 0) {\n+      Events::log(Thread::current(), \"sent signal %d to Thread \" INTPTR_FORMAT \" because %s.\",\n+                  sig, p2i(thread), reason);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Returns:\n+\/\/ NULL for an invalid signal number\n+\/\/ \"SIG<num>\" for a valid but unknown signal number\n+\/\/ signal name otherwise.\n+const char* os::exception_name(int sig, char* buf, size_t size) {\n+  if (!is_valid_signal(sig)) {\n+    return NULL;\n+  }\n+  const char* const name = get_signal_name(sig, buf, size);\n+  if (strcmp(name, \"UNKNOWN\") == 0) {\n+    jio_snprintf(buf, size, \"SIG%d\", sig);\n+  }\n+  return buf;\n+}\n+\n+int os::get_signal_number(const char* signal_name) {\n+  char tmp[30];\n+  const char* s = signal_name;\n+  if (s[0] != 'S' || s[1] != 'I' || s[2] != 'G') {\n+    jio_snprintf(tmp, sizeof(tmp), \"SIG%s\", signal_name);\n+    s = tmp;\n+  }\n+  for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n+    if (strcmp(g_signal_info[idx].name, s) == 0) {\n+      return g_signal_info[idx].sig;\n+    }\n+  }\n+  return -1;\n+}\n+\n+void set_signal_handler(int sig, bool set_installed) {\n+  \/\/ Check for overwrite.\n+  struct sigaction oldAct;\n+  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n+\n+  void* oldhand = oldAct.sa_sigaction\n+                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n+                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n+  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n+      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n+      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n+    if (AllowUserSignalHandlers || !set_installed) {\n+      \/\/ Do not overwrite; user takes responsibility to forward to us.\n+      return;\n+    } else if (UseSignalChaining) {\n+      \/\/ save the old handler in jvm\n+      save_preinstalled_handler(sig, oldAct);\n+      \/\/ libjsig also interposes the sigaction() call below and saves the\n+      \/\/ old sigaction on it own.\n+    } else {\n+      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n+            \"%#lx for signal %d.\", (long)oldhand, sig);\n+    }\n+  }\n+\n+  struct sigaction sigAct;\n+  sigfillset(&(sigAct.sa_mask));\n+  sigAct.sa_handler = SIG_DFL;\n+  if (!set_installed) {\n+    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n+  } else {\n+    sigAct.sa_sigaction = javaSignalHandler;\n+    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n+  }\n+#if defined(__APPLE__)\n+  \/\/ Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n+  \/\/ (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n+  \/\/ if the signal handler declares it will handle it on alternate stack.\n+  \/\/ Notice we only declare we will handle it on alt stack, but we are not\n+  \/\/ actually going to use real alt stack - this is just a workaround.\n+  \/\/ Please see ux_exception.c, method catch_mach_exception_raise for details\n+  \/\/ link http:\/\/www.opensource.apple.com\/source\/xnu\/xnu-2050.18.24\/bsd\/uxkern\/ux_exception.c\n+  if (sig == SIGSEGV) {\n+    sigAct.sa_flags |= SA_ONSTACK;\n+  }\n+#endif\n+\n+  \/\/ Save flags, which are set by ours\n+  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n+  sigflags[sig] = sigAct.sa_flags;\n+\n+  int ret = sigaction(sig, &sigAct, &oldAct);\n+  assert(ret == 0, \"check\");\n+\n+  void* oldhand2  = oldAct.sa_sigaction\n+                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n+                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n+  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n+}\n+\n+\/\/ install signal handlers for signals that HotSpot needs to\n+\/\/ handle in order to support Java-level exception handling.\n+\n+bool PosixSignals::are_signal_handlers_installed() {\n+  return signal_handlers_are_installed;\n+}\n+\n+\/\/ install signal handlers for signals that HotSpot needs to\n+\/\/ handle in order to support Java-level exception handling.\n+void PosixSignals::install_signal_handlers() {\n+  if (!signal_handlers_are_installed) {\n+    signal_handlers_are_installed = true;\n+\n+    \/\/ signal-chaining\n+    typedef void (*signal_setting_t)();\n+    signal_setting_t begin_signal_setting = NULL;\n+    signal_setting_t end_signal_setting = NULL;\n+    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                          dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n+    if (begin_signal_setting != NULL) {\n+      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                          dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n+      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n+                                         dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n+      libjsig_is_loaded = true;\n+      assert(UseSignalChaining, \"should enable signal-chaining\");\n+    }\n+    if (libjsig_is_loaded) {\n+      \/\/ Tell libjsig jvm is setting signal handlers\n+      (*begin_signal_setting)();\n+    }\n+\n+    set_signal_handler(SIGSEGV, true);\n+    set_signal_handler(SIGPIPE, true);\n+    set_signal_handler(SIGBUS, true);\n+    set_signal_handler(SIGILL, true);\n+    set_signal_handler(SIGFPE, true);\n+#if defined(PPC64) || defined(AIX)\n+    set_signal_handler(SIGTRAP, true);\n+#endif\n+    set_signal_handler(SIGXFSZ, true);\n+\n+#if defined(__APPLE__)\n+    \/\/ In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n+    \/\/ signals caught and handled by the JVM. To work around this, we reset the mach task\n+    \/\/ signal handler that's placed on our process by CrashReporter. This disables\n+    \/\/ CrashReporter-based reporting.\n+    \/\/\n+    \/\/ This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n+    \/\/ on caught fatal signals.\n+    \/\/\n+    \/\/ Additionally, gdb installs both standard BSD signal handlers, and mach exception\n+    \/\/ handlers. By replacing the existing task exception handler, we disable gdb's mach\n+    \/\/ exception handling, while leaving the standard BSD signal handlers functional.\n+    kern_return_t kr;\n+    kr = task_set_exception_ports(mach_task_self(),\n+                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                  MACH_PORT_NULL,\n+                                  EXCEPTION_STATE_IDENTITY,\n+                                  MACHINE_THREAD_STATE);\n+\n+    assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n+#endif\n+\n+    if (libjsig_is_loaded) {\n+      \/\/ Tell libjsig jvm finishes setting signal handlers\n+      (*end_signal_setting)();\n+    }\n+\n+    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n+    \/\/ and if UserSignalHandler is installed all bets are off.\n+    \/\/ Log that signal checking is off only if -verbose:jni is specified.\n+    if (CheckJNICalls) {\n+      if (libjsig_is_loaded) {\n+        log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n+        check_signals = false;\n+      }\n+      if (AllowUserSignalHandlers) {\n+        log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n+        check_signals = false;\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Returns one-line short description of a signal set in a user provided buffer.\n+static const char* describe_signal_set_short(const sigset_t* set, char* buffer, size_t buf_size) {\n+  assert(buf_size == (NUM_IMPORTANT_SIGS + 1), \"wrong buffer size\");\n+  \/\/ Note: for shortness, just print out the first 32. That should\n+  \/\/ cover most of the useful ones, apart from realtime signals.\n+  for (int sig = 1; sig <= NUM_IMPORTANT_SIGS; sig++) {\n+    const int rc = sigismember(set, sig);\n+    if (rc == -1 && errno == EINVAL) {\n+      buffer[sig-1] = '?';\n+    } else {\n+      buffer[sig-1] = rc == 0 ? '0' : '1';\n+    }\n+  }\n+  buffer[NUM_IMPORTANT_SIGS] = 0;\n+  return buffer;\n+}\n+\n+\/\/ Prints one-line description of a signal set.\n+static void print_signal_set_short(outputStream* st, const sigset_t* set) {\n+  char buf[NUM_IMPORTANT_SIGS + 1];\n+  describe_signal_set_short(set, buf, sizeof(buf));\n+  st->print(\"%s\", buf);\n+}\n+\n+void PosixSignals::print_signal_handler(outputStream* st, int sig,\n+                                 char* buf, size_t buflen) {\n+  struct sigaction sa;\n+  sigaction(sig, NULL, &sa);\n+\n+  \/\/ See comment for SIGNIFICANT_SIGNAL_MASK define\n+  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n+\n+  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n+\n+  address handler = (sa.sa_flags & SA_SIGINFO)\n+    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n+    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n+\n+  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n+    st->print(\"SIG_DFL\");\n+  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n+    st->print(\"SIG_IGN\");\n+  } else {\n+    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n+  }\n+\n+  st->print(\", sa_mask[0]=\");\n+  print_signal_set_short(st, &sa.sa_mask);\n+\n+  address rh = VMError::get_resetted_sighandler(sig);\n+  \/\/ May be, handler was resetted by VMError?\n+  if (rh != NULL) {\n+    handler = rh;\n+    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n+  }\n+\n+  \/\/ Print textual representation of sa_flags.\n+  st->print(\", sa_flags=\");\n+  print_sa_flags(st, sa.sa_flags);\n+\n+  \/\/ Check: is it our handler?\n+  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n+      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n+    \/\/ It is our signal handler\n+    \/\/ check for flags, reset system-used one!\n+    if ((int)sa.sa_flags != get_our_sigflags(sig)) {\n+      st->print(\n+                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n+                get_our_sigflags(sig));\n+    }\n+  }\n+  st->cr();\n+}\n+\n+bool PosixSignals::is_sig_ignored(int sig) {\n+  struct sigaction oact;\n+  sigaction(sig, (struct sigaction*)NULL, &oact);\n+  void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n+                                 : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n+  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+int PosixSignals::unblock_thread_signal_mask(const sigset_t *set) {\n+  return pthread_sigmask(SIG_UNBLOCK, set, NULL);\n+}\n+\n+address PosixSignals::ucontext_get_pc(const ucontext_t* ctx) {\n+#if defined(AIX)\n+   return os::Aix::ucontext_get_pc(ctx);\n+#elif defined(BSD)\n+   return os::Bsd::ucontext_get_pc(ctx);\n+#elif defined(LINUX)\n+   return os::Linux::ucontext_get_pc(ctx);\n+#else\n+   VMError::report_and_die(\"unimplemented ucontext_get_pc\");\n+#endif\n+}\n+\n+void PosixSignals::ucontext_set_pc(ucontext_t* ctx, address pc) {\n+#if defined(AIX)\n+   os::Aix::ucontext_set_pc(ctx, pc);\n+#elif defined(BSD)\n+   os::Bsd::ucontext_set_pc(ctx, pc);\n+#elif defined(LINUX)\n+   os::Linux::ucontext_set_pc(ctx, pc);\n+#else\n+   VMError::report_and_die(\"unimplemented ucontext_set_pc\");\n+#endif\n+}\n+\n+void PosixSignals::signal_sets_init() {\n+  sigemptyset(&preinstalled_sigs);\n+\n+  \/\/ Should also have an assertion stating we are still single-threaded.\n+  assert(!signal_sets_initialized, \"Already initialized\");\n+  \/\/ Fill in signals that are necessarily unblocked for all threads in\n+  \/\/ the VM. Currently, we unblock the following signals:\n+  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n+  \/\/                         by -Xrs (=ReduceSignalUsage));\n+  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n+  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n+  \/\/ the dispositions or masks wrt these signals.\n+  \/\/ Programs embedding the VM that want to use the above signals for their\n+  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n+  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n+  \/\/ (See bug 4345157, and other related bugs).\n+  \/\/ In reality, though, unblocking these signals is really a nop, since\n+  \/\/ these signals are not blocked by default.\n+  sigemptyset(&unblocked_sigs);\n+  sigaddset(&unblocked_sigs, SIGILL);\n+  sigaddset(&unblocked_sigs, SIGSEGV);\n+  sigaddset(&unblocked_sigs, SIGBUS);\n+  sigaddset(&unblocked_sigs, SIGFPE);\n+  #if defined(PPC64) || defined(AIX)\n+    sigaddset(&unblocked_sigs, SIGTRAP);\n+  #endif\n+  sigaddset(&unblocked_sigs, SR_signum);\n+\n+  if (!ReduceSignalUsage) {\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n+    }\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n+    }\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n+    }\n+  }\n+  \/\/ Fill in signals that are blocked by all but the VM thread.\n+  sigemptyset(&vm_sigs);\n+  if (!ReduceSignalUsage) {\n+    sigaddset(&vm_sigs, BREAK_SIGNAL);\n+  }\n+  debug_only(signal_sets_initialized = true);\n+}\n+\n+\/\/ These are signals that are unblocked while a thread is running Java.\n+\/\/ (For some reason, they get blocked by default.)\n+static sigset_t* unblocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &unblocked_sigs;\n+}\n+\n+\/\/ These are the signals that are blocked while a (non-VM) thread is\n+\/\/ running Java. Only the VM thread handles these signals.\n+static sigset_t* vm_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &vm_sigs;\n+}\n+\n+void PosixSignals::hotspot_sigmask(Thread* thread) {\n+\n+  \/\/Save caller's signal mask before setting VM signal mask\n+  sigset_t caller_sigmask;\n+  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n+\n+  OSThread* osthread = thread->osthread();\n+  osthread->set_caller_sigmask(caller_sigmask);\n+\n+  pthread_sigmask(SIG_UNBLOCK, unblocked_signals(), NULL);\n+\n+  if (!ReduceSignalUsage) {\n+    if (thread->is_VM_thread()) {\n+      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n+      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n+    } else {\n+      \/\/ ... all other threads block BREAK_SIGNAL\n+      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n+    }\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ suspend\/resume support\n+\n+\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n+\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n+\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n+\/\/\n+\/\/  The remaining code is greatly simplified from the more general suspension\n+\/\/  code that used to be used.\n+\/\/\n+\/\/  The protocol is quite simple:\n+\/\/  - suspend:\n+\/\/      - sends a signal to the target thread\n+\/\/      - polls the suspend state of the osthread using a yield loop\n+\/\/      - target thread signal handler (SR_handler) sets suspend state\n+\/\/        and blocks in sigsuspend until continued\n+\/\/  - resume:\n+\/\/      - sets target osthread state to continue\n+\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n+\/\/\n+\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n+\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n+\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n+\/\/\n+\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n+\/\/  by SR_handler(), so that fetch_frame_from_context() works,\n+\/\/  which in part is used by:\n+\/\/    - Forte Analyzer: AsyncGetCallTrace()\n+\/\/    - StackBanging: get_frame_at_stack_banging_point()\n+\n+sigset_t SR_sigset;\n+\n+static void resume_clear_context(OSThread *osthread) {\n+  osthread->set_ucontext(NULL);\n+  osthread->set_siginfo(NULL);\n+}\n+\n+static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n+  osthread->set_ucontext(context);\n+  osthread->set_siginfo(siginfo);\n+}\n+\n+\/\/ Handler function invoked when a thread's execution is suspended or\n+\/\/ resumed. We have to be careful that only async-safe functions are\n+\/\/ called here (Note: most pthread functions are not async safe and\n+\/\/ should be avoided.)\n+\/\/\n+\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n+\/\/ interface point of view, but sigwait() prevents the signal handler\n+\/\/ from being run. libpthread would get very confused by not having\n+\/\/ its signal handlers run and prevents sigwait()'s use with the\n+\/\/ mutex granting signal.\n+\/\/\n+\/\/ Currently only ever called on the VMThread and JavaThreads (PC sampling)\n+\/\/\n+static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n+  \/\/ Save and restore errno to avoid confusing native code with EINTR\n+  \/\/ after sigsuspend.\n+  int old_errno = errno;\n+\n+  Thread* thread = Thread::current_or_null_safe();\n+  assert(thread != NULL, \"Missing current thread in SR_handler\");\n+\n+  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n+  \/\/ mask is changed as part of thread termination. Check that the current thread\n+  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n+  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n+  \/\/ destructor has completed.\n+\n+  if (thread->SR_lock() == NULL) {\n+    return;\n+  }\n+\n+  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n+\n+  OSThread* osthread = thread->osthread();\n+\n+  os::SuspendResume::State current = osthread->sr.state();\n+\n+  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n+    suspend_save_context(osthread, siginfo, context);\n+\n+    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n+    os::SuspendResume::State state = osthread->sr.suspended();\n+    if (state == os::SuspendResume::SR_SUSPENDED) {\n+      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n+      sigemptyset(&suspend_set);\n+\n+      \/\/ get current set of blocked signals and unblock resume signal\n+      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n+      sigdelset(&suspend_set, SR_signum);\n+\n+      sr_semaphore.signal();\n+\n+      \/\/ wait here until we are resumed\n+      while (1) {\n+        sigsuspend(&suspend_set);\n+\n+        os::SuspendResume::State result = osthread->sr.running();\n+        if (result == os::SuspendResume::SR_RUNNING) {\n+          \/\/ double check AIX doesn't need this!\n+          sr_semaphore.signal();\n+          break;\n+        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n+          ShouldNotReachHere();\n+        }\n+      }\n+\n+    } else if (state == os::SuspendResume::SR_RUNNING) {\n+      \/\/ request was cancelled, continue\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+\n+    resume_clear_context(osthread);\n+  } else if (current == os::SuspendResume::SR_RUNNING) {\n+    \/\/ request was cancelled, continue\n+  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n+    \/\/ ignore\n+  } else {\n+    \/\/ ignore\n+  }\n+\n+  errno = old_errno;\n+}\n+\n+int PosixSignals::SR_initialize() {\n+  struct sigaction act;\n+  char *s;\n+  \/\/ Get signal number to use for suspend\/resume\n+  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n+    int sig = ::strtol(s, 0, 10);\n+    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n+        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n+      SR_signum = sig;\n+    } else {\n+      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n+              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n+    }\n+  }\n+\n+  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n+         \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n+\n+  sigemptyset(&SR_sigset);\n+  sigaddset(&SR_sigset, SR_signum);\n+\n+  \/\/ Set up signal handler for suspend\/resume\n+  act.sa_flags = SA_RESTART|SA_SIGINFO;\n+  act.sa_handler = (void (*)(int)) SR_handler;\n+\n+  \/\/ SR_signum is blocked by default.\n+  \/\/ 4528190 - We also need to block pthread restart signal (32 on all\n+  \/\/ supported Bsd platforms). Note that BsdThreads\/LinuxThreads need to block\n+  \/\/ this signal for all threads to work properly. So we don't have\n+  \/\/ to use hard-coded signal number when setting up the mask.\n+  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n+\n+  if (sigaction(SR_signum, &act, 0) == -1) {\n+    return -1;\n+  }\n+\n+  \/\/ Save signal flag\n+  set_our_sigflags(SR_signum, act.sa_flags);\n+  return 0;\n+}\n+\n+static int sr_notify(OSThread* osthread) {\n+  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n+  assert_status(status == 0, status, \"pthread_kill\");\n+  return status;\n+}\n+\n+\/\/ returns true on success and false on error - really an error is fatal\n+\/\/ but this seems the normal response to library errors\n+bool PosixSignals::do_suspend(OSThread* osthread) {\n+  assert(osthread->sr.is_running(), \"thread should be running\");\n+  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n+\n+  \/\/ mark as suspended and send signal\n+  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n+    \/\/ failed to switch, state wasn't running?\n+    ShouldNotReachHere();\n+    return false;\n+  }\n+\n+  if (sr_notify(osthread) != 0) {\n+    ShouldNotReachHere();\n+  }\n+\n+  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n+  while (true) {\n+    if (sr_semaphore.timedwait(2)) {\n+      break;\n+    } else {\n+      \/\/ timeout\n+      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n+      if (cancelled == os::SuspendResume::SR_RUNNING) {\n+        return false;\n+      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n+        \/\/ make sure that we consume the signal on the semaphore as well\n+        sr_semaphore.wait();\n+        break;\n+      } else {\n+        ShouldNotReachHere();\n+        return false;\n+      }\n+    }\n+  }\n+\n+  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n+  return true;\n+}\n+\n+void PosixSignals::do_resume(OSThread* osthread) {\n+  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n+  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n+\n+  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n+    \/\/ failed to switch to WAKEUP_REQUEST\n+    ShouldNotReachHere();\n+    return;\n+  }\n+\n+  while (true) {\n+    if (sr_notify(osthread) == 0) {\n+      if (sr_semaphore.timedwait(2)) {\n+        if (osthread->sr.is_running()) {\n+          return;\n+        }\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  guarantee(osthread->sr.is_running(), \"Must be running!\");\n+}\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1653,"deletions":0,"binary":false,"changes":1653,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_SIGNALS_POSIX_HPP\n+#define OS_POSIX_SIGNALS_POSIX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <signal.h>\n+\n+\/\/ Signal number used to suspend\/resume a thread\n+\/\/ do not use any signal number less than SIGSEGV, see 4355769\n+static int SR_signum = SIGUSR2;\n+\n+class PosixSignals : public AllStatic {\n+\n+public:\n+\n+  static bool are_signal_handlers_installed();\n+  static void install_signal_handlers();\n+\n+  static bool is_sig_ignored(int sig);\n+  static void signal_sets_init();\n+\n+  \/\/ unblocks the signal masks for current thread\n+  static int unblock_thread_signal_mask(const sigset_t *set);\n+  static void hotspot_sigmask(Thread* thread);\n+\n+  static void print_signal_handler(outputStream* st, int sig, char* buf, size_t buflen);\n+\n+  static address ucontext_get_pc(const ucontext_t* ctx);\n+  \/\/ Set PC into context. Needed for continuation after signal.\n+  static void ucontext_set_pc(ucontext_t* ctx, address pc);\n+\n+  \/\/ Suspend-resume\n+  static int SR_initialize();\n+  static bool do_suspend(OSThread* osthread);\n+  static void do_resume(OSThread* osthread);\n+\n+  \/\/ For signal-chaining\n+  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n+\n+  \/\/ sun.misc.Signal support\n+  static void jdk_misc_signal_init();\n+};\n+\n+#endif \/\/ OS_POSIX_SIGNALS_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"signals_posix.hpp\"\n@@ -35,1 +36,0 @@\n-#include <signal.h>\n@@ -112,1 +112,1 @@\n-  os::Posix::unblock_thread_signal_mask(&newset);\n+  PosixSignals::unblock_thread_signal_mask(&newset);\n@@ -116,1 +116,1 @@\n-  address pc = (uc != NULL) ? os::Posix::ucontext_get_pc(uc) : NULL;\n+  address pc = (uc != NULL) ? PosixSignals::ucontext_get_pc(uc) : NULL;\n@@ -125,1 +125,1 @@\n-    os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+    PosixSignals::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n@@ -151,2 +151,1 @@\n-  os::Posix::unblock_thread_signal_mask(&newset);\n-\n+  PosixSignals::unblock_thread_signal_mask(&newset);\n@@ -173,1 +172,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"signals_posix.hpp\"\n@@ -218,1 +219,1 @@\n-    if (os::Aix::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -228,1 +229,1 @@\n-  if (os::Aix::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -231,1 +232,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -530,1 +531,1 @@\n-  if (os::Aix::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"signals_posix.hpp\"\n@@ -447,1 +448,1 @@\n-    if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -457,1 +458,1 @@\n-  if (os::Bsd::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -460,1 +461,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -742,1 +743,1 @@\n-  if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"signals_posix.hpp\"\n@@ -146,1 +147,1 @@\n-    if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -156,1 +157,1 @@\n-  if (os::Bsd::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -159,1 +160,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -206,1 +207,1 @@\n-  if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"signals_posix.hpp\"\n@@ -219,1 +220,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -237,1 +238,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -240,1 +241,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -428,1 +429,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"signals_posix.hpp\"\n@@ -278,1 +279,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -296,1 +297,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -299,1 +300,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -443,1 +444,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"signals_posix.hpp\"\n@@ -240,1 +241,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -280,1 +281,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -283,1 +284,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -550,1 +551,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"signals_posix.hpp\"\n@@ -260,1 +261,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -280,1 +281,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -283,1 +284,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -502,1 +503,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"signals_posix.hpp\"\n@@ -258,1 +259,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -276,1 +277,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -279,1 +280,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -557,1 +558,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"signals_posix.hpp\"\n@@ -142,1 +143,1 @@\n-    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n@@ -152,1 +153,1 @@\n-  if (os::Linux::signal_handlers_are_installed) {\n+  if (PosixSignals::are_signal_handlers_installed()) {\n@@ -155,1 +156,1 @@\n-        thread = t->as_Java_thread();\n+        thread = (JavaThread*)t;\n@@ -220,1 +221,1 @@\n-  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}