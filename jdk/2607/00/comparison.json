{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+        public boolean isCFG;\n@@ -66,0 +67,1 @@\n+        \/\/ Initialize data structures.\n@@ -73,0 +75,14 @@\n+        Map<InputBlock, Set<Node>> terminators = new HashMap<>();\n+        \/\/ Pre-compute control successors of each node, excluding self edges.\n+        Map<Node, Set<Node>> controlSuccs = new HashMap<>();\n+        for (Node n : nodes) {\n+            if (n.isCFG) {\n+                Set<Node> nControlSuccs = new HashSet<>();\n+                for (Node s : n.succs) {\n+                    if (s.isCFG && s != n) {\n+                        nControlSuccs.add(s);\n+                    }\n+                }\n+                controlSuccs.put(n, nControlSuccs);\n+            }\n+        }\n@@ -74,1 +90,2 @@\n-        int blockCount = 0;\n+        \/\/ Start from 1 to follow the style of compiler-generated CFGs.\n+        int blockCount = 1;\n@@ -77,1 +94,1 @@\n-\n+        \/\/ Traverse the control-flow subgraph forwards, starting from the root.\n@@ -79,30 +96,29 @@\n-            Node proj = stack.pop();\n-            Node parent = proj;\n-            if (proj.isBlockProjection && proj.preds.size() > 0) {\n-                parent = proj.preds.get(0);\n-            }\n-\n-            if (!visited.contains(parent)) {\n-                visited.add(parent);\n-                InputBlock block = graph.addBlock(Integer.toString(blockCount));\n-                blocks.add(block);\n-                if (parent == root) {\n-                    rootBlock = block;\n-                }\n-                blockCount++;\n-                parent.block = block;\n-                if (proj != parent && proj.succs.size() == 1 && proj.succs.contains(root)) {\n-                    \/\/ Special treatment of Halt-nodes\n-                    proj.block = block;\n-                }\n-\n-                Node p = proj;\n-                do {\n-                    if (p.preds.size() == 0 || p.preds.get(0) == null) {\n-                        p = parent;\n-                        break;\n-                    }\n-\n-                    p = p.preds.get(0);\n-                    if (p == proj) {\n-                        \/\/ Cycle, stop\n+            \/\/ Pop a node, mark it as visited, and create a new block.\n+            Node n = stack.pop();\n+            if (visited.contains(n)) {\n+                continue;\n+            }\n+            visited.add(n);\n+            InputBlock block = graph.addBlock(Integer.toString(blockCount));\n+            blocks.add(block);\n+            if (n == root) {\n+                rootBlock = block;\n+            }\n+            blockCount++;\n+            Set<Node> blockTerminators = new HashSet<Node>();\n+            \/\/ Move forwards until a terminator node is found, assigning all\n+            \/\/ visited nodes to the current block.\n+            while (true) {\n+                \/\/ Assign n to current block.\n+                n.block = block;\n+                if (controlSuccs.get(n).size() == 0) {\n+                    \/\/ No successors: end the block.\n+                    blockTerminators.add(n);\n+                    break;\n+                } else if (controlSuccs.get(n).size() == 1) {\n+                    \/\/ One successor: end the block if it is a block start node.\n+                    Node s = controlSuccs.get(n).iterator().next();\n+                    if (s.isBlockStart) {\n+                        \/\/ Block start: end the block.\n+                        blockTerminators.add(n);\n+                        stack.push(s);\n@@ -110,0 +126,3 @@\n+                    } else {\n+                        \/\/ Not a block start: keep filling the current block.\n+                        n = s;\n@@ -111,14 +130,15 @@\n-\n-                    if (p.block == null) {\n-                        p.block = block;\n-                    }\n-                } while (!p.isBlockProjection && !p.isBlockStart);\n-\n-                if (block != rootBlock) {\n-                    for (Node n : p.preds) {\n-                        if (n != null && n != p) {\n-                            if (n.isBlockProjection) {\n-                                n = n.preds.get(0);\n-                            }\n-                            if (n.block != null) {\n-                                graph.addBlockEdge(n.block, block);\n+                } else {\n+                    \/\/ Multiple successors: end the block.\n+                    for (Node s : controlSuccs.get(n)) {\n+                        if (s.isBlockProjection && s != root) {\n+                            \/\/ Assign block projections to the current block,\n+                            \/\/ and push their successors to the stack. In the\n+                            \/\/ normal case, we would expect control projections\n+                            \/\/ to have only one successor, but there are some\n+                            \/\/ intermediate graphs (e.g. 'Before RemoveUseless')\n+                            \/\/ where 'IfX' nodes flow both to 'Region' and\n+                            \/\/ (dead) 'Safepoint' nodes.\n+                            s.block = block;\n+                            blockTerminators.add(s);\n+                            for (Node ps : controlSuccs.get(s)) {\n+                                stack.push(ps);\n@@ -126,0 +146,3 @@\n+                        } else {\n+                            blockTerminators.add(n);\n+                            stack.push(s);\n@@ -128,0 +151,1 @@\n+                    break;\n@@ -129,0 +153,3 @@\n+            }\n+            terminators.put(block, blockTerminators);\n+        }\n@@ -130,26 +157,9 @@\n-                for (Node n : parent.succs) {\n-                    if (n != root && n.isBlockProjection) {\n-                        for (Node n2 : n.succs) {\n-\n-                            if (n2 != parent && n2.block != null && n2.block != rootBlock) {\n-                                graph.addBlockEdge(block, n2.block);\n-                            }\n-                        }\n-                    } else {\n-                        if (n != parent && n.block != null && n.block != rootBlock) {\n-                            graph.addBlockEdge(block, n.block);\n-                        }\n-                    }\n-                }\n-\n-                int num_preds = p.preds.size();\n-                int bottom = -1;\n-                if (isRegion(p) || isPhi(p)) {\n-                    bottom = 0;\n-                }\n-\n-                int pushed = 0;\n-                for (int i = num_preds - 1; i > bottom; i--) {\n-                    if (p.preds.get(i) != null && p.preds.get(i) != p) {\n-                        stack.push(p.preds.get(i));\n-                        pushed++;\n+        \/\/ Add block edges based on terminator successors. Note that a block\n+        \/\/ might have multiple terminators preceding the same successor block.\n+        for (Map.Entry<InputBlock, Set<Node>> terms : terminators.entrySet()) {\n+            \/\/ Unique set of terminator successors.\n+            Set<Node> uniqueSuccs = new HashSet<>();\n+            for (Node t : terms.getValue()) {\n+                for (Node s : controlSuccs.get(t)) {\n+                    if (s.block != rootBlock) {\n+                        uniqueSuccs.add(s);\n@@ -158,4 +168,3 @@\n-\n-                if (pushed == 0 && p == root) {\n-                    \/\/ TODO: special handling when root backedges are not built yet\n-                }\n+            }\n+            for (Node s : uniqueSuccs) {\n+                graph.addBlockEdge(terms.getKey(), s.block);\n@@ -165,0 +174,1 @@\n+        \/\/ Fill the blocks.\n@@ -172,0 +182,1 @@\n+        \/\/ Compute block index map for dominator computation.\n@@ -623,0 +634,60 @@\n+\n+        \/\/ Mark nodes that form the CFG (same as shown by the 'Show control flow\n+        \/\/ only' filter, plus the Root node).\n+        for (Node n : nodes) {\n+            String category = n.inputNode.getProperties().get(\"category\");\n+            assert category != null :\n+                \"Node category not found, please use input from a compatible \" +\n+                \"compiler version\";\n+            if (category.equals(\"control\") || category.equals(\"mixed\")) {\n+                \/\/ Example: If, IfTrue, CallStaticJava.\n+                n.isCFG = true;\n+            } else if (n.inputNode.getProperties().get(\"type\").equals(\"bottom\")\n+                       && n.preds.size() > 0 &&\n+                       n.preds.get(0) != null &&\n+                       n.preds.get(0).inputNode.getProperties()\n+                       .get(\"category\").equals(\"control\")) {\n+                \/\/ Example: Halt, Return, Rethrow.\n+                n.isCFG = true;\n+            } else if (n.isBlockStart || n.isBlockProjection) {\n+                \/\/ Example: Root.\n+                n.isCFG = true;\n+            } else {\n+                n.isCFG = false;\n+            }\n+        }\n+\n+        \/\/ Fix ill-formed graphs with orphan\/widow control-flow nodes by adding\n+        \/\/ edges from\/to the Root node. Such edges are assumed by different\n+        \/\/ parts of the scheduling algorithm, but are not always present, e.g.\n+        \/\/ for certain 'Safepoint' nodes in the 'Before RemoveUseless' phase.\n+        Node root = findRoot();\n+        if (root == null) {\n+            return;\n+        }\n+        for (Node n : nodes) {\n+            if (n.isCFG) {\n+                boolean orphan = true;\n+                for (Node p : n.preds) {\n+                    if (p != n && p.isCFG) {\n+                        orphan = false;\n+                    }\n+                }\n+                if (orphan) {\n+                    \/\/ Add edge from root to this node.\n+                    root.succs.add(n);\n+                    n.preds.add(0, root);\n+                }\n+                boolean widow = true;\n+                for (Node s : n.succs) {\n+                    if (s != n && s.isCFG) {\n+                        widow = false;\n+                    }\n+                }\n+                if (widow) {\n+                    \/\/ Add edge from this node to root.\n+                    root.preds.add(n);\n+                    n.succs.add(root);\n+                }\n+            }\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":148,"deletions":77,"binary":false,"changes":225,"status":"modified"}]}