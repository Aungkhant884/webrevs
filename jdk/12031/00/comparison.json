{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-CompiledICProtectionBehaviour* CompiledICProtectionBehaviour::_current = NULL;\n+CompiledICProtectionBehaviour* CompiledICProtectionBehaviour::_current = nullptr;\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, NULL, false \/* caller_must_gc_arguments *\/)\n+  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, nullptr, false \/* caller_must_gc_arguments *\/)\n@@ -165,1 +165,1 @@\n-  assert(blob != NULL, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n@@ -178,1 +178,1 @@\n-  _oop_maps = NULL;\n+  _oop_maps = nullptr;\n@@ -186,1 +186,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -189,1 +189,1 @@\n-    _oop_maps = NULL;\n+    _oop_maps = nullptr;\n@@ -198,1 +198,1 @@\n-  if (stub != NULL && (PrintStubCode ||\n+  if (stub != nullptr && (PrintStubCode ||\n@@ -210,1 +210,1 @@\n-      if ((stub->oop_maps() != NULL) && AbstractDisassembler::show_structs()) {\n+      if ((stub->oop_maps() != nullptr) && AbstractDisassembler::show_structs()) {\n@@ -233,1 +233,1 @@\n-  assert(_oop_maps != NULL, \"nope\");\n+  assert(_oop_maps != nullptr, \"nope\");\n@@ -253,1 +253,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -258,1 +258,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -271,1 +271,1 @@\n-  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)\n+  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, nullptr)\n@@ -277,1 +277,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -279,1 +279,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -312,1 +312,1 @@\n-  AdapterBlob* blob = NULL;\n+  AdapterBlob* blob = nullptr;\n@@ -341,1 +341,1 @@\n-  VtableBlob* blob = NULL;\n+  VtableBlob* blob = nullptr;\n@@ -346,1 +346,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -359,1 +359,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -376,1 +376,1 @@\n-  MethodHandlesAdapterBlob* blob = NULL;\n+  MethodHandlesAdapterBlob* blob = nullptr;\n@@ -384,1 +384,1 @@\n-    if (blob == NULL) {\n+    if (blob == nullptr) {\n@@ -417,1 +417,1 @@\n-  RuntimeStub* stub = NULL;\n+  RuntimeStub* stub = nullptr;\n@@ -476,1 +476,1 @@\n-  DeoptimizationBlob* blob = NULL;\n+  DeoptimizationBlob* blob = nullptr;\n@@ -515,1 +515,1 @@\n-  UncommonTrapBlob* blob = NULL;\n+  UncommonTrapBlob* blob = nullptr;\n@@ -551,1 +551,1 @@\n-  ExceptionBlob* blob = NULL;\n+  ExceptionBlob* blob = nullptr;\n@@ -586,1 +586,1 @@\n-  SafepointBlob* blob = NULL;\n+  SafepointBlob* blob = nullptr;\n@@ -618,1 +618,1 @@\n-    if (i != NULL) {\n+    if (i != nullptr) {\n@@ -635,1 +635,1 @@\n-    if (d != NULL) {\n+    if (d != nullptr) {\n@@ -651,1 +651,1 @@\n-    if (v != NULL) {\n+    if (v != nullptr) {\n@@ -778,1 +778,1 @@\n-  assert(blob != nullptr, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : nullptr; }\n@@ -170,1 +170,1 @@\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : nullptr; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  assert(_oop_maps != NULL, \"nope\");\n+  assert(_oop_maps != nullptr, \"nope\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-#define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))\n+#define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != nullptr; cb = next_blob(heap, cb))\n@@ -171,1 +171,1 @@\n-ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;\n+ExceptionCache* volatile CodeCache::_exception_cache_purge_list = nullptr;\n@@ -401,1 +401,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -458,1 +458,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -462,1 +462,1 @@\n-  assert(cb != NULL, \"CodeBlob is null\");\n+  assert(cb != nullptr, \"CodeBlob is null\");\n@@ -469,1 +469,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -478,1 +478,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -483,1 +483,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -491,1 +491,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -497,1 +497,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -512,1 +512,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -514,1 +514,1 @@\n-  CodeBlob* cb = NULL;\n+  CodeBlob* cb = nullptr;\n@@ -518,1 +518,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -522,1 +522,1 @@\n-    if (cb != NULL) break;\n+    if (cb != nullptr) break;\n@@ -561,1 +561,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -635,1 +635,1 @@\n-  S390_ONLY(if (_heaps == NULL) return false;)\n+  S390_ONLY(if (_heaps == nullptr) return false;)\n@@ -653,1 +653,1 @@\n-  if (_heaps != NULL) {\n+  if (_heaps != nullptr) {\n@@ -655,1 +655,1 @@\n-    if (heap != NULL) {\n+    if (heap != nullptr) {\n@@ -659,1 +659,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -874,1 +874,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -920,1 +920,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -950,1 +950,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -955,1 +955,1 @@\n-  _exception_cache_purge_list = NULL;\n+  _exception_cache_purge_list = nullptr;\n@@ -960,1 +960,1 @@\n-  assert(nm->unlinked_next() == NULL, \"Only register for unloading once\");\n+  assert(nm->unlinked_next() == nullptr, \"Only register for unloading once\");\n@@ -965,1 +965,1 @@\n-    nmethod* next = head != NULL ? head : nm; \/\/ Self looped means end of list\n+    nmethod* next = head != nullptr ? head : nm; \/\/ Self looped means end of list\n@@ -976,1 +976,1 @@\n-  _unlinked_head = NULL;\n+  _unlinked_head = nullptr;\n@@ -978,1 +978,1 @@\n-  while (nm != NULL) {\n+  while (nm != nullptr) {\n@@ -1001,1 +1001,1 @@\n-nmethod* volatile CodeCache::_unlinked_head = NULL;\n+nmethod* volatile CodeCache::_unlinked_head = nullptr;\n@@ -1040,1 +1040,1 @@\n-  return (heap != NULL) ? heap->blob_count() : 0;\n+  return (heap != nullptr) ? heap->blob_count() : 0;\n@@ -1053,1 +1053,1 @@\n-  return (heap != NULL) ? heap->nmethod_count() : 0;\n+  return (heap != nullptr) ? heap->nmethod_count() : 0;\n@@ -1066,1 +1066,1 @@\n-  return (heap != NULL) ? heap->adapter_count() : 0;\n+  return (heap != nullptr) ? heap->adapter_count() : 0;\n@@ -1079,1 +1079,1 @@\n-  return (heap != NULL) ? (address)heap->low_boundary() : NULL;\n+  return (heap != nullptr) ? (address)heap->low_boundary() : nullptr;\n@@ -1084,1 +1084,1 @@\n-  return (heap != NULL) ? (address)heap->high_boundary() : NULL;\n+  return (heap != nullptr) ? (address)heap->high_boundary() : nullptr;\n@@ -1097,1 +1097,1 @@\n-  return (heap != NULL) ? heap->unallocated_capacity() : 0;\n+  return (heap != nullptr) ? heap->unallocated_capacity() : 0;\n@@ -1269,1 +1269,1 @@\n-  assert(cb == NULL || cb->is_compiled(), \"did not find an compiled_method\");\n+  assert(cb == nullptr || cb->is_compiled(), \"did not find an compiled_method\");\n@@ -1276,1 +1276,1 @@\n-static GrowableArray<CompiledMethod*>* old_compiled_method_table = NULL;\n+static GrowableArray<CompiledMethod*>* old_compiled_method_table = nullptr;\n@@ -1279,1 +1279,1 @@\n-  if (old_compiled_method_table == NULL) {\n+  if (old_compiled_method_table == nullptr) {\n@@ -1286,1 +1286,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1288,1 +1288,1 @@\n-    old_compiled_method_table = NULL;\n+    old_compiled_method_table = nullptr;\n@@ -1295,1 +1295,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1306,1 +1306,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1471,1 +1471,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -1539,1 +1539,1 @@\n-      for (CodeBlob* cb = (CodeBlob*)curr_heap->first(); cb != NULL; cb = (CodeBlob*)curr_heap->next(cb)) {\n+      for (CodeBlob* cb = (CodeBlob*)curr_heap->first(); cb != nullptr; cb = (CodeBlob*)curr_heap->next(cb)) {\n@@ -1589,1 +1589,1 @@\n-        if (Verbose && nm->method() != NULL) {\n+        if (Verbose && nm->method() != nullptr) {\n@@ -1599,1 +1599,1 @@\n-        if(nm->method() != NULL && nm->is_native_method()) { nmethodNative++; }\n+        if(nm->method() != nullptr && nm->is_native_method()) { nmethodNative++; }\n@@ -1601,1 +1601,1 @@\n-        if(nm->method() != NULL && nm->is_java_method()) {\n+        if(nm->method() != nullptr && nm->is_java_method()) {\n@@ -1627,1 +1627,1 @@\n-    if(nm->method() != NULL && nm->is_java_method()) {\n+    if(nm->method() != nullptr && nm->is_java_method()) {\n@@ -1740,1 +1740,1 @@\n-        if (set != NULL) {\n+        if (set != nullptr) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-  static CodeHeap* get_code_heap_containing(void* p);         \/\/ Returns the CodeHeap containing the given pointer, or NULL\n+  static CodeHeap* get_code_heap_containing(void* p);         \/\/ Returns the CodeHeap containing the given pointer, or nullptr\n@@ -324,1 +324,1 @@\n-    return (heap != NULL) ? heap->full_count() : 0;\n+    return (heap != nullptr) ? heap->full_count() : 0;\n@@ -369,1 +369,1 @@\n-        if (cm != NULL && cm->is_unloading()) {\n+        if (cm != nullptr && cm->is_unloading()) {\n@@ -379,1 +379,1 @@\n-  CodeBlobIterator(LivenessFilter filter, T* nm = NULL)\n+  CodeBlobIterator(LivenessFilter filter, T* nm = nullptr)\n@@ -382,1 +382,1 @@\n-    if (Filter::heaps() == NULL) {\n+    if (Filter::heaps() == nullptr) {\n@@ -391,1 +391,1 @@\n-    \/\/ If set to NULL, initialized by first call to next()\n+    \/\/ If set to nullptr, initialized by first call to next()\n@@ -393,1 +393,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -412,1 +412,1 @@\n-  bool end()  const { return _code_blob == NULL; }\n+  bool end()  const { return _code_blob == nullptr; }\n@@ -424,1 +424,1 @@\n-    if (_code_blob == NULL) {\n+    if (_code_blob == nullptr) {\n@@ -426,1 +426,1 @@\n-      if (_code_blob == NULL) {\n+      if (_code_blob == nullptr) {\n@@ -434,1 +434,1 @@\n-    while (_code_blob != NULL && !Filter::apply(_code_blob)) {\n+    while (_code_blob != nullptr && !Filter::apply(_code_blob)) {\n@@ -437,1 +437,1 @@\n-    return _code_blob != NULL;\n+    return _code_blob != nullptr;\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  if (nop != NULL && nop->displacement() != 0) {\n+  if (nop != nullptr && nop->displacement() != 0) {\n@@ -49,1 +49,1 @@\n-  assert(cb != NULL, \"must be\");\n+  assert(cb != nullptr, \"must be\");\n@@ -55,1 +55,1 @@\n-  return (nop != NULL && nop->displacement() != 0)\n+  return (nop != nullptr && nop->displacement() != 0)\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -156,1 +156,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -196,1 +196,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -240,2 +240,2 @@\n-\/\/ static struct StatElement *StatArray      = NULL;\n-static StatElement* StatArray             = NULL;\n+\/\/ static struct StatElement *StatArray      = nullptr;\n+static StatElement* StatArray             = nullptr;\n@@ -252,1 +252,1 @@\n-static struct FreeBlk*          FreeArray = NULL;\n+static struct FreeBlk*          FreeArray = nullptr;\n@@ -255,1 +255,1 @@\n-static struct TopSizeBlk*    TopSizeArray = NULL;\n+static struct TopSizeBlk*    TopSizeArray = nullptr;\n@@ -259,1 +259,1 @@\n-static struct SizeDistributionElement*  SizeDistributionArray = NULL;\n+static struct SizeDistributionElement*  SizeDistributionArray = nullptr;\n@@ -274,1 +274,1 @@\n-  if (heapName == NULL) {\n+  if (heapName == nullptr) {\n@@ -280,1 +280,1 @@\n-      if (CodeHeapStatArray[i].heapName != NULL && strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {\n+      if (CodeHeapStatArray[i].heapName != nullptr && strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {\n@@ -321,1 +321,1 @@\n-    StatArray             = NULL;\n+    StatArray             = nullptr;\n@@ -331,1 +331,1 @@\n-    FreeArray             = NULL;\n+    FreeArray             = nullptr;\n@@ -333,1 +333,1 @@\n-    TopSizeArray          = NULL;\n+    TopSizeArray          = nullptr;\n@@ -336,1 +336,1 @@\n-    SizeDistributionArray = NULL;\n+    SizeDistributionArray = nullptr;\n@@ -363,1 +363,1 @@\n-  if (StatArray == NULL) {\n+  if (StatArray == nullptr) {\n@@ -370,1 +370,1 @@\n-  if (StatArray == NULL) {\n+  if (StatArray == nullptr) {\n@@ -384,1 +384,1 @@\n-  if (FreeArray == NULL) {\n+  if (FreeArray == nullptr) {\n@@ -390,1 +390,1 @@\n-  if (FreeArray == NULL) {\n+  if (FreeArray == nullptr) {\n@@ -402,1 +402,1 @@\n-  if (TopSizeArray == NULL) {\n+  if (TopSizeArray == nullptr) {\n@@ -409,1 +409,1 @@\n-  if (TopSizeArray == NULL) {\n+  if (TopSizeArray == nullptr) {\n@@ -422,1 +422,1 @@\n-  if (SizeDistributionArray == NULL) {\n+  if (SizeDistributionArray == nullptr) {\n@@ -426,1 +426,1 @@\n-  if (SizeDistributionArray == NULL) {\n+  if (SizeDistributionArray == nullptr) {\n@@ -443,1 +443,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -455,1 +455,1 @@\n-  if (StatArray != NULL) {\n+  if (StatArray != nullptr) {\n@@ -457,1 +457,1 @@\n-    StatArray        = NULL;\n+    StatArray        = nullptr;\n@@ -464,1 +464,1 @@\n-  if (FreeArray != NULL) {\n+  if (FreeArray != nullptr) {\n@@ -466,1 +466,1 @@\n-    FreeArray        = NULL;\n+    FreeArray        = nullptr;\n@@ -472,1 +472,1 @@\n-  if (TopSizeArray != NULL) {\n+  if (TopSizeArray != nullptr) {\n@@ -474,1 +474,1 @@\n-      if (TopSizeArray[i].blob_name != NULL) {\n+      if (TopSizeArray[i].blob_name != nullptr) {\n@@ -479,1 +479,1 @@\n-    TopSizeArray        = NULL;\n+    TopSizeArray        = nullptr;\n@@ -486,1 +486,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -488,1 +488,1 @@\n-    SizeDistributionArray = NULL;\n+    SizeDistributionArray = nullptr;\n@@ -507,1 +507,1 @@\n-      CodeHeapStatArray[ix].heapName = NULL;\n+      CodeHeapStatArray[ix].heapName = nullptr;\n@@ -541,1 +541,1 @@\n-    printBox(ast, '=', \"C O D E   H E A P   A N A L Y S I S   (general remarks)\", NULL);\n+    printBox(ast, '=', \"C O D E   H E A P   A N A L Y S I S   (general remarks)\", nullptr);\n@@ -654,1 +654,1 @@\n-    if (StatArray == NULL) {\n+    if (StatArray == nullptr) {\n@@ -672,1 +672,1 @@\n-    HeapBlock*   maxFreeBlock           = NULL;\n+    HeapBlock*   maxFreeBlock           = nullptr;\n@@ -677,1 +677,1 @@\n-    for (HeapBlock *h = heap->first_block(); h != NULL && !insane; h = heap->next_block(h)) {\n+    for (HeapBlock *h = heap->first_block(); h != nullptr && !insane; h = heap->next_block(h)) {\n@@ -725,1 +725,1 @@\n-        cbType = get_cbType(cb);  \/\/ Will check for cb == NULL and other safety things.\n+        cbType = get_cbType(cb);  \/\/ Will check for cb == nullptr and other safety things.\n@@ -730,1 +730,1 @@\n-          if (nm != NULL) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n+          if (nm != nullptr) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n@@ -793,1 +793,1 @@\n-              blob_name  = NULL; \/\/ indicate blob_name was consumed\n+              blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -809,1 +809,1 @@\n-              blob_name  = NULL; \/\/ indicate blob_name was consumed\n+              blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -849,1 +849,1 @@\n-                      blob_name  = NULL; \/\/ indicate blob_name was consumed\n+                      blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -873,1 +873,1 @@\n-                        if (TopSizeArray[j].blob_name != NULL) {\n+                        if (TopSizeArray[j].blob_name != nullptr) {\n@@ -905,1 +905,1 @@\n-                        blob_name  = NULL; \/\/ indicate blob_name was consumed\n+                        blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -920,1 +920,1 @@\n-          if (blob_name != NULL) {\n+          if (blob_name != nullptr) {\n@@ -922,1 +922,1 @@\n-            blob_name = NULL;\n+            blob_name = nullptr;\n@@ -1141,1 +1141,1 @@\n-    if (FreeArray == NULL) {\n+    if (FreeArray == nullptr) {\n@@ -1153,1 +1153,1 @@\n-    while (cur != NULL) {\n+    while (cur != nullptr) {\n@@ -1188,1 +1188,1 @@\n-  if (FreeArray != NULL) {\n+  if (FreeArray != nullptr) {\n@@ -1194,1 +1194,1 @@\n-      for (HeapBlock *h = heap->next_block(FreeArray[ix].start); (h != NULL) && (h != FreeArray[ix+1].start); h = heap->next_block(h)) {\n+      for (HeapBlock *h = heap->next_block(FreeArray[ix].start); (h != nullptr) && (h != FreeArray[ix+1].start); h = heap->next_block(h)) {\n@@ -1196,1 +1196,1 @@\n-        if ((cb != NULL) && !cb->is_nmethod()) { \/\/ checks equivalent to those in get_cbType()\n+        if ((cb != nullptr) && !cb->is_nmethod()) { \/\/ checks equivalent to those in get_cbType()\n@@ -1225,1 +1225,1 @@\n-  if ((StatArray == NULL) || (TopSizeArray == NULL) || (used_topSizeBlocks == 0)) {\n+  if ((StatArray == nullptr) || (TopSizeArray == nullptr) || (used_topSizeBlocks == 0)) {\n@@ -1266,1 +1266,1 @@\n-        if (TopSizeArray[i].blob_name == NULL) {\n+        if (TopSizeArray[i].blob_name == nullptr) {\n@@ -1270,1 +1270,1 @@\n-        \/\/ Returns NULL or void*. Returned CodeBlob may be uninitialized.\n+        \/\/ Returns nullptr or void*. Returned CodeBlob may be uninitialized.\n@@ -1273,1 +1273,1 @@\n-        if (this_blob != NULL) {\n+        if (this_blob != nullptr) {\n@@ -1332,1 +1332,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -1435,1 +1435,1 @@\n-  if ((StatArray == NULL) || (FreeArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (FreeArray == nullptr) || (alloc_granules == 0)) {\n@@ -1486,1 +1486,1 @@\n-      for (iy = 0; iy < nTop && FreeTopTen[iy] != NULL; iy++) {\n+      for (iy = 0; iy < nTop && FreeTopTen[iy] != nullptr; iy++) {\n@@ -1492,1 +1492,1 @@\n-          if (FreeTopTen[nTop-1] != NULL) {\n+          if (FreeTopTen[nTop-1] != nullptr) {\n@@ -1503,1 +1503,1 @@\n-      if (FreeTopTen[iy] == NULL) {\n+      if (FreeTopTen[iy] == nullptr) {\n@@ -1517,1 +1517,1 @@\n-    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTen[iy] != NULL); iy++) {\n+    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTen[iy] != nullptr); iy++) {\n@@ -1551,1 +1551,1 @@\n-      for (iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != NULL); iy++) {\n+      for (iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != nullptr); iy++) {\n@@ -1557,1 +1557,1 @@\n-          if (FreeTopTenTriple[nTop-1] != NULL) {\n+          if (FreeTopTenTriple[nTop-1] != nullptr) {\n@@ -1568,1 +1568,1 @@\n-      if (FreeTopTenTriple[iy] == NULL) {\n+      if (FreeTopTenTriple[iy] == nullptr) {\n@@ -1587,1 +1587,1 @@\n-    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != NULL); iy++) {\n+    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != nullptr); iy++) {\n@@ -1609,1 +1609,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1633,1 +1633,1 @@\n-      printBox(ast, '-', \"Total (all types) count for granule size == segment size\", NULL);\n+      printBox(ast, '-', \"Total (all types) count for granule size == segment size\", nullptr);\n@@ -1641,1 +1641,1 @@\n-      printBox(ast, '-', \"Total (all tiers) count, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Total (all tiers) count, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1656,1 +1656,1 @@\n-      printBox(ast, '-', \"Tier1 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Tier1 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1676,1 +1676,1 @@\n-      printBox(ast, '-', \"Tier2 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Tier2 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1696,1 +1696,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1716,1 +1716,1 @@\n-      printBox(ast, '-', \"Stub & Blob count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Stub & Blob count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1736,1 +1736,1 @@\n-      printBox(ast, '-', \"Count by tier (combined): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", NULL);\n+      printBox(ast, '-', \"Count by tier (combined): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", nullptr);\n@@ -1767,1 +1767,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1794,1 +1794,1 @@\n-      printBox(ast, '-', \"Total (all types) space consumption for granule size == segment size\", NULL);\n+      printBox(ast, '-', \"Total (all types) space consumption for granule size == segment size\", nullptr);\n@@ -1802,1 +1802,1 @@\n-      printBox(ast, '-', \"Total (all types) space consumption. ' ' indicates empty, '*' indicates full.\", NULL);\n+      printBox(ast, '-', \"Total (all types) space consumption. ' ' indicates empty, '*' indicates full.\", nullptr);\n@@ -1817,1 +1817,1 @@\n-      printBox(ast, '-', \"Tier1 space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Tier1 space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1837,1 +1837,1 @@\n-      printBox(ast, '-', \"Tier2 space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Tier2 space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1857,1 +1857,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1877,1 +1877,1 @@\n-      printBox(ast, '-', \"Stub and Blob space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Stub and Blob space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1897,1 +1897,1 @@\n-      printBox(ast, '-', \"Space consumption by tier (combined): <t1%>:<t2%>:<s%>. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Space consumption by tier (combined): <t1%>:<t2%>:<s%>. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1936,1 +1936,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1957,1 +1957,1 @@\n-    printBox(ast, '-', \"Age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+    printBox(ast, '-', \"Age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -1975,1 +1975,1 @@\n-      printBox(ast, '-', \"Tier1 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"Tier1 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -1991,1 +1991,1 @@\n-      printBox(ast, '-', \"Tier2 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"Tier2 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2007,1 +2007,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2023,1 +2023,1 @@\n-      printBox(ast, '-', \"age distribution by tier <a1>:<a2>. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"age distribution by tier <a1>:<a2>. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2048,1 +2048,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -2055,1 +2055,1 @@\n-  CodeBlob*    last_blob           = NULL;\n+  CodeBlob*    last_blob           = nullptr;\n@@ -2093,1 +2093,1 @@\n-      \/\/ Returns NULL or void*. Returned CodeBlob may be uninitialized.\n+      \/\/ Returns nullptr or void*. Returned CodeBlob may be uninitialized.\n@@ -2115,1 +2115,1 @@\n-        nmethod*           nm = NULL;\n+        nmethod*           nm = nullptr;\n@@ -2119,2 +2119,2 @@\n-          \/\/ this_blob->name() could return NULL if no name was given to CTOR. Inlined, maybe invisible on stack\n-          if (blob_name == NULL) {\n+          \/\/ this_blob->name() could return nullptr if no name was given to CTOR. Inlined, maybe invisible on stack\n+          if (blob_name == nullptr) {\n@@ -2143,1 +2143,1 @@\n-        \/\/ This fact is implicitly transported via nm != NULL.\n+        \/\/ This fact is implicitly transported via nm != nullptr.\n@@ -2163,2 +2163,2 @@\n-            const char*   methNameS = (methName == NULL) ? NULL : methName->as_C_string();\n-            methNameS = (methNameS == NULL) ? \"<method name unavailable>\" : methNameS;\n+            const char*   methNameS = (methName == nullptr) ? nullptr : methName->as_C_string();\n+            methNameS = (methNameS == nullptr) ? \"<method name unavailable>\" : methNameS;\n@@ -2166,2 +2166,2 @@\n-            const char*   methSigS  = (methSig  == NULL) ? NULL : methSig->as_C_string();\n-            methSigS  = (methSigS  == NULL) ? \"<method signature unavailable>\" : methSigS;\n+            const char*   methSigS  = (methSig  == nullptr) ? nullptr : methSig->as_C_string();\n+            methSigS  = (methSigS  == nullptr) ? \"<method signature unavailable>\" : methSigS;\n@@ -2189,1 +2189,1 @@\n-      } else if (!blob_is_safe && (this_blob != last_blob) && (this_blob != NULL)) {\n+      } else if (!blob_is_safe && (this_blob != last_blob) && (this_blob != nullptr)) {\n@@ -2203,1 +2203,1 @@\n-  if (text1 != NULL) {\n+  if (text1 != nullptr) {\n@@ -2206,1 +2206,1 @@\n-  if (text2 != NULL) {\n+  if (text2 != nullptr) {\n@@ -2224,1 +2224,1 @@\n-  if (text1 != NULL) {\n+  if (text1 != nullptr) {\n@@ -2227,1 +2227,1 @@\n-  if (text2 != NULL) {\n+  if (text2 != nullptr) {\n@@ -2241,1 +2241,1 @@\n-  printBox(out, '-', \"Block types used in the following CodeHeap dump\", NULL);\n+  printBox(out, '-', \"Block types used in the following CodeHeap dump\", nullptr);\n@@ -2252,1 +2252,1 @@\n-  printBox(out, '-', \"Space ranges, based on granule occupancy\", NULL);\n+  printBox(out, '-', \"Space ranges, based on granule occupancy\", nullptr);\n@@ -2267,1 +2267,1 @@\n-  printBox(out, '-', \"Age ranges, based on compilation id\", NULL);\n+  printBox(out, '-', \"Age ranges, based on compilation id\", nullptr);\n@@ -2349,1 +2349,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -2363,1 +2363,1 @@\n-      if (nm != NULL) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n+      if (nm != nullptr) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n@@ -2375,1 +2375,1 @@\n-  return (this_blob != NULL) && \/\/ a blob must have been found, obviously\n+  return (this_blob != nullptr) && \/\/ a blob must have been found, obviously\n@@ -2384,2 +2384,2 @@\n-  Method* method = (nm == NULL) ? NULL : nm->method(); \/\/ nm->method() was found to be uninitialized, i.e. != NULL, but invalid.\n-  return (nm != NULL) && (method != NULL) && (method->signature() != NULL);\n+  Method* method = (nm == nullptr) ? nullptr : nm->method(); \/\/ nm->method() was found to be uninitialized, i.e. != nullptr, but invalid.\n+  return (nm != nullptr) && (method != nullptr) && (method->signature() != nullptr);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":112,"deletions":112,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+  assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -88,1 +88,1 @@\n-    assert(data != NULL || Universe::non_oop_word() == NULL,\n+    assert(data != nullptr || Universe::non_oop_word() == nullptr,\n@@ -90,1 +90,1 @@\n-    return (data == (void*)Universe::non_oop_word()) ? NULL : data;\n+    return (data == (void*)Universe::non_oop_word()) ? nullptr : data;\n@@ -98,1 +98,1 @@\n-  assert(entry_point != NULL, \"must set legal entry point\");\n+  assert(entry_point != nullptr, \"must set legal entry point\");\n@@ -100,2 +100,2 @@\n-  assert (!is_optimized() || cache == NULL, \"an optimized virtual call does not have a cached metadata\");\n-  assert (cache == NULL || cache != (Metadata*)badOopVal, \"invalid metadata\");\n+  assert (!is_optimized() || cache == nullptr, \"an optimized virtual call does not have a cached metadata\");\n+  assert (cache == nullptr || cache != (Metadata*)badOopVal, \"invalid metadata\");\n@@ -132,1 +132,1 @@\n-    assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+    assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -140,1 +140,1 @@\n-    assert(cache == NULL, \"must be null\");\n+    assert(cache == nullptr, \"must be null\");\n@@ -144,1 +144,1 @@\n-  if (cache == NULL)  cache = Universe::non_oop_word();\n+  if (cache == nullptr)  cache = Universe::non_oop_word();\n@@ -151,1 +151,1 @@\n-  internal_set_ic_destination(stub->code_begin(), true, NULL, false);\n+  internal_set_ic_destination(stub->code_begin(), true, nullptr, false);\n@@ -205,1 +205,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -215,2 +215,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(cm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(cm != nullptr, \"must pass compiled method\");\n@@ -235,2 +235,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(nm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(nm != nullptr, \"must pass compiled method\");\n@@ -258,1 +258,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -281,1 +281,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -284,1 +284,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -292,1 +292,1 @@\n-    assert(call_info->selected_method() != NULL, \"Unexpected null selected method\");\n+    assert(call_info->selected_method() != nullptr, \"Unexpected null selected method\");\n@@ -314,1 +314,1 @@\n-  return VtableStubs::entry_point(ic_destination()) != NULL;\n+  return VtableStubs::entry_point(ic_destination()) != nullptr;\n@@ -321,1 +321,1 @@\n-  bool is_monomorphic = (cb != NULL && cb->is_compiled());\n+  bool is_monomorphic = (cb != nullptr && cb->is_compiled());\n@@ -324,1 +324,1 @@\n-  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == NULL).\n+  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == nullptr).\n@@ -333,1 +333,1 @@\n-         (cached_metadata() != NULL && cached_metadata()->is_klass()), \"sanity check\");\n+         (cached_metadata() != nullptr && cached_metadata()->is_klass()), \"sanity check\");\n@@ -346,2 +346,2 @@\n-    is_call_to_interpreted = (cb != NULL && cb->is_adapter_blob());\n-    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != NULL), \"sanity check\");\n+    is_call_to_interpreted = (cb != nullptr && cb->is_adapter_blob());\n+    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != nullptr), \"sanity check\");\n@@ -378,1 +378,1 @@\n-      set_ic_destination_and_value(entry, (void*)NULL);\n+      set_ic_destination_and_value(entry, (void*)nullptr);\n@@ -382,1 +382,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -401,1 +401,1 @@\n-  assert(!is_clean || is_optimized() || cached_value() == NULL, \"sanity check\");\n+  assert(!is_clean || is_optimized() || cached_value() == nullptr, \"sanity check\");\n@@ -428,1 +428,1 @@\n-      assert(info.cached_metadata() != NULL && info.cached_metadata()->is_method(), \"sanity check\");\n+      assert(info.cached_metadata() != nullptr && info.cached_metadata()->is_method(), \"sanity check\");\n@@ -452,1 +452,1 @@\n-    bool static_bound = info.is_optimized() || (info.cached_metadata() == NULL);\n+    bool static_bound = info.is_optimized() || (info.cached_metadata() == nullptr);\n@@ -455,1 +455,1 @@\n-    assert (cb != NULL && cb->is_compiled(), \"must be compiled!\");\n+    assert (cb != nullptr && cb->is_compiled(), \"must be compiled!\");\n@@ -477,1 +477,1 @@\n-      assert(info.cached_metadata() == NULL || info.cached_metadata()->is_klass(), \"must be\");\n+      assert(info.cached_metadata() == nullptr || info.cached_metadata()->is_klass(), \"must be\");\n@@ -480,1 +480,1 @@\n-        (info.cached_metadata() != NULL) ? ((Klass*)info.cached_metadata())->print_value_string() : \"NULL\",\n+        (info.cached_metadata() != nullptr) ? ((Klass*)info.cached_metadata())->print_value_string() : \"nullptr\",\n@@ -509,2 +509,2 @@\n-  address entry = NULL;\n-  if (method_code != NULL && method_code->is_in_use() && !method_code->is_unloading()) {\n+  address entry = nullptr;\n+  if (method_code != nullptr && method_code->is_in_use() && !method_code->is_unloading()) {\n@@ -535,1 +535,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -537,1 +537,1 @@\n-    info.set_compiled_entry(entry, is_optimized ? NULL : receiver_klass, is_optimized);\n+    info.set_compiled_entry(entry, is_optimized ? nullptr : receiver_klass, is_optimized);\n@@ -544,1 +544,1 @@\n-      assert(method_code == NULL || method_code->is_compiled(), \"must be compiled\");\n+      assert(method_code == nullptr || method_code->is_compiled(), \"must be compiled\");\n@@ -555,1 +555,1 @@\n-  if (cb != NULL && cb->is_adapter_blob()) {\n+  if (cb != nullptr && cb->is_adapter_blob()) {\n@@ -559,1 +559,1 @@\n-  if (cb != NULL && cb->is_vtable_blob()) {\n+  if (cb != nullptr && cb->is_vtable_blob()) {\n@@ -561,1 +561,1 @@\n-    return (s != NULL) && s->is_itable_stub();\n+    return (s != nullptr) && s->is_itable_stub();\n@@ -636,1 +636,1 @@\n-  if (m_code != NULL && m_code->is_in_use() && !m_code->is_unloading()) {\n+  if (m_code != nullptr && m_code->is_in_use() && !m_code->is_unloading()) {\n@@ -657,1 +657,1 @@\n-  RelocIterator iter((nmethod*)NULL, instruction);\n+  RelocIterator iter((nmethod*)nullptr, instruction);\n@@ -674,1 +674,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -702,1 +702,1 @@\n-             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? NULL : cached_value()));\n+             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? nullptr : cached_value()));\n@@ -725,1 +725,1 @@\n-  assert(old_method == NULL || old_method == callee() ||\n+  assert(old_method == nullptr || old_method == callee() ||\n@@ -733,1 +733,1 @@\n-         || old_method == NULL || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n+         || old_method == nullptr || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    assert(_cached_value != NULL, \"must be non-NULL\");\n+    assert(_cached_value != nullptr, \"must be non-nullptr\");\n@@ -129,1 +129,1 @@\n-  CompiledICInfo(): _entry(NULL), _cached_value(NULL), _is_icholder(false),\n+  CompiledICInfo(): _entry(nullptr), _cached_value(nullptr), _is_icholder(false),\n@@ -189,1 +189,1 @@\n-    internal_set_ic_destination(entry_point, false, NULL, false);\n+    internal_set_ic_destination(entry_point, false, nullptr, false);\n@@ -341,1 +341,1 @@\n-  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = NULL);\n+  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -71,1 +71,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -78,4 +78,4 @@\n-    _scopes_data_begin          = NULL;\n-    _deopt_handler_begin        = NULL;\n-    _deopt_mh_handler_begin     = NULL;\n-    _exception_cache            = NULL;\n+    _scopes_data_begin          = nullptr;\n+    _deopt_handler_begin        = nullptr;\n+    _deopt_mh_handler_begin     = nullptr;\n+    _exception_cache            = nullptr;\n@@ -92,1 +92,1 @@\n-  if (pd == NULL)\n+  if (pd == nullptr)\n@@ -111,1 +111,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -118,1 +118,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -133,2 +133,2 @@\n-  assert(new_entry != NULL,\"Must be non null\");\n-  assert(new_entry->next() == NULL, \"Must be null\");\n+  assert(new_entry != nullptr,\"Must be non null\");\n+  assert(new_entry->next() == nullptr, \"Must be null\");\n@@ -138,1 +138,1 @@\n-    if (ec != NULL) {\n+    if (ec != nullptr) {\n@@ -154,1 +154,1 @@\n-      if (ec != NULL) {\n+      if (ec != nullptr) {\n@@ -180,1 +180,1 @@\n-  ExceptionCache* prev = NULL;\n+  ExceptionCache* prev = nullptr;\n@@ -183,1 +183,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -187,1 +187,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -192,1 +192,1 @@\n-          prev = NULL;\n+          prev = nullptr;\n@@ -220,1 +220,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -222,1 +222,1 @@\n-    if ((ret_val = ec->match(exception,pc)) != NULL) {\n+    if ((ret_val = ec->match(exception,pc)) != nullptr) {\n@@ -227,1 +227,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -240,1 +240,1 @@\n-  if (target_entry == NULL || !target_entry->add_address_and_handler(pc,handler)) {\n+  if (target_entry == nullptr || !target_entry->add_address_and_handler(pc,handler)) {\n@@ -251,1 +251,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -257,1 +257,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -284,1 +284,1 @@\n-  RelocIterator iter(this, NULL, NULL);\n+  RelocIterator iter(this, nullptr, nullptr);\n@@ -298,1 +298,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -304,1 +304,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -325,1 +325,1 @@\n-  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == NULL, \"Not safe oop scan\");\n+  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == nullptr, \"Not safe oop scan\");\n@@ -351,1 +351,1 @@\n-        assert(ic->cached_icholder() != NULL, \"must be non-NULL\");\n+        assert(ic->cached_icholder() != nullptr, \"must be non-nullptr\");\n@@ -363,1 +363,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -381,1 +381,1 @@\n-    if (callee != NULL) {\n+    if (callee != nullptr) {\n@@ -415,1 +415,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -423,1 +423,1 @@\n-  return NULL; \/\/ not a call\n+  return nullptr; \/\/ not a call\n@@ -452,1 +452,1 @@\n-    Klass* klass = NULL;\n+    Klass* klass = nullptr;\n@@ -483,1 +483,1 @@\n-    if (ic_metdata != NULL) {\n+    if (ic_metdata != nullptr) {\n@@ -512,2 +512,2 @@\n-  CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n-  if (nm != NULL) {\n+  CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -564,1 +564,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -570,1 +570,1 @@\n-    if (nm != NULL && bs_nm->is_armed(nm)) {\n+    if (nm != nullptr && bs_nm->is_armed(nm)) {\n@@ -658,1 +658,1 @@\n-      if (md != NULL && md->is_method()) {\n+      if (md != nullptr && md->is_method()) {\n@@ -661,1 +661,1 @@\n-          Atomic::store(r->metadata_addr(), (Method*)NULL);\n+          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n@@ -689,1 +689,1 @@\n-    assert(cb != NULL && cb == this, \"\");\n+    assert(cb != nullptr && cb == this, \"\");\n@@ -700,1 +700,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  PcDescCache() { debug_only(_pc_descs[0] = NULL); }\n+  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n@@ -133,1 +133,1 @@\n-    if (desc != NULL && desc->pc_offset() == pc - base_address) {\n+    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n@@ -224,2 +224,2 @@\n-  bool is_native_method() const { return _method != NULL && _method->is_native(); }\n-  bool is_java_method() const { return _method != NULL && !_method->is_native(); }\n+  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n+  bool is_java_method() const { return _method != nullptr && !_method->is_native(); }\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  if (fr->cb() == NULL)  return NULL;\n+  if (fr->cb() == nullptr)  return nullptr;\n@@ -64,1 +64,1 @@\n-  if (cm != NULL && cm->is_deopt_pc(fr->pc()))\n+  if (cm != nullptr && cm->is_deopt_pc(fr->pc()))\n@@ -67,1 +67,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-CompressedWriteStream::CompressedWriteStream(int initial_size) : CompressedStream(NULL, 0) {\n+CompressedWriteStream::CompressedWriteStream(int initial_size) : CompressedStream(nullptr, 0) {\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -71,1 +71,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -85,1 +85,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -93,1 +93,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -104,1 +104,1 @@\n-  ScopeValue* result = NULL;\n+  ScopeValue* result = nullptr;\n@@ -247,1 +247,1 @@\n-    assert(JNIHandles::resolve(value()) == NULL ||\n+    assert(JNIHandles::resolve(value()) == nullptr ||\n@@ -268,1 +268,1 @@\n-  assert(_value() == NULL ||\n+  assert(_value() == nullptr ||\n@@ -277,1 +277,1 @@\n-  if (value()() != NULL) {\n+  if (value()() != nullptr) {\n@@ -280,1 +280,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-     , _klass(NULL)\n+     , _klass(nullptr)\n@@ -304,1 +304,1 @@\n-  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = NULL) :\n+  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = nullptr) :\n@@ -315,1 +315,1 @@\n-    assert(o == NULL || o->is_metadata(), \"meta data only\");\n+    assert(o == nullptr || o->is_metadata(), \"meta data only\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  _next_chunk = _next_chunk_limit = NULL;\n+  _next_chunk = _next_chunk_limit = nullptr;\n@@ -199,1 +199,1 @@\n-  if (monitors == NULL || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (monitors == nullptr || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -220,1 +220,1 @@\n-  if (values == NULL || values->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (values == nullptr || values->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -318,1 +318,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -323,1 +323,1 @@\n-    method_enc = NULL;\n+    method_enc = nullptr;\n@@ -328,1 +328,1 @@\n-  assert(method == NULL ||\n+  assert(method == nullptr ||\n@@ -355,1 +355,1 @@\n-  if (objects != NULL) {\n+  if (objects != nullptr) {\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,3 @@\n-                      DebugToken* locals      = NULL,\n-                      DebugToken* expressions = NULL,\n-                      DebugToken* monitors    = NULL);\n+                      DebugToken* locals      = nullptr,\n+                      DebugToken* expressions = nullptr,\n+                      DebugToken* monitors    = nullptr);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  DEBUG_ONLY(_deps[end_marker] = NULL);\n+  DEBUG_ONLY(_deps[end_marker] = nullptr);\n@@ -74,1 +74,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -142,1 +142,1 @@\n-  DEBUG_ONLY(_dep_values[end_marker] = NULL);\n+  DEBUG_ONLY(_dep_values[end_marker] = nullptr);\n@@ -146,1 +146,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -484,1 +484,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -496,1 +496,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -633,1 +633,1 @@\n-    if (witness != NULL) {\n+    if (witness != nullptr) {\n@@ -636,1 +636,1 @@\n-        if (failure_detail != NULL && klass_violations == 0) {\n+        if (failure_detail != nullptr && klass_violations == 0) {\n@@ -646,1 +646,1 @@\n-      if (xtty == NULL) {\n+      if (xtty == nullptr) {\n@@ -660,1 +660,1 @@\n-  if (log() == NULL)  return;\n+  if (log() == nullptr)  return;\n@@ -687,1 +687,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -710,1 +710,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -723,1 +723,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -742,1 +742,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -753,1 +753,1 @@\n-  if (xtty == NULL) {\n+  if (xtty == nullptr) {\n@@ -760,1 +760,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -789,1 +789,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -801,1 +801,1 @@\n-                (witness == NULL)? \"Dependency\": \"Failed dependency\",\n+                (witness == nullptr)? \"Dependency\": \"Failed dependency\",\n@@ -816,1 +816,1 @@\n-      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), NULL);\n+      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), nullptr);\n@@ -835,1 +835,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -844,1 +844,1 @@\n-  if (_deps == NULL && xtty == NULL)  return;  \/\/ fast cutout for runtime\n+  if (_deps == nullptr && xtty == nullptr)  return;  \/\/ fast cutout for runtime\n@@ -856,2 +856,2 @@\n-  if (_deps != NULL && _deps->log() != NULL) {\n-    if (ciEnv::current() != NULL) {\n+  if (_deps != nullptr && _deps->log() != nullptr) {\n+    if (ciEnv::current() != nullptr) {\n@@ -883,1 +883,1 @@\n-    if (_code != NULL) {\n+    if (_code != nullptr) {\n@@ -900,1 +900,1 @@\n-  assert((_code!=NULL) + (_deps!=NULL) == 1, \"one or t'other\");\n+  assert((_code!=nullptr) + (_deps!=nullptr) == 1, \"one or t'other\");\n@@ -906,1 +906,1 @@\n-  if (_bytes.position() == 0 && _code != NULL\n+  if (_bytes.position() == 0 && _code != nullptr\n@@ -937,2 +937,2 @@\n-  Metadata* o = NULL;\n-  if (_code != NULL) {\n+  Metadata* o = nullptr;\n+  if (_code != nullptr) {\n@@ -947,1 +947,1 @@\n-  return (_code != NULL)\n+  return (_code != nullptr)\n@@ -955,1 +955,1 @@\n-  if (result == NULL) { \/\/ Explicit context argument can be compressed\n+  if (result == nullptr) { \/\/ Explicit context argument can be compressed\n@@ -962,1 +962,1 @@\n-  assert(result == NULL || result->is_klass() || result->is_method(), \"must be\");\n+  assert(result == nullptr || result->is_klass() || result->is_method(), \"must be\");\n@@ -991,1 +991,1 @@\n-      assert(k != NULL && k->is_klass(), \"type check\");\n+      assert(k != nullptr && k->is_klass(), \"type check\");\n@@ -1002,1 +1002,1 @@\n-      assert(k != NULL, \"type check\");\n+      assert(k != nullptr, \"type check\");\n@@ -1009,1 +1009,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1061,1 +1061,1 @@\n-      _participants[i] = NULL;\n+      _participants[i] = nullptr;\n@@ -1063,1 +1063,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1112,1 +1112,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1129,1 +1129,1 @@\n-  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = NULL);\n+  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = nullptr);\n@@ -1135,3 +1135,3 @@\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = NULL;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = nullptr;\n@@ -1158,1 +1158,1 @@\n-  assert(changes == NULL || changes->involves_context(context_type), \"irrelevant dependency\");\n+  assert(changes == nullptr || changes->involves_context(context_type), \"irrelevant dependency\");\n@@ -1166,1 +1166,1 @@\n-      return NULL; \/\/ no implementors\n+      return nullptr; \/\/ no implementors\n@@ -1182,1 +1182,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -1204,1 +1204,1 @@\n-  ConcreteSubtypeFinder(Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {}\n+  ConcreteSubtypeFinder(Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {}\n@@ -1225,1 +1225,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1232,1 +1232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1247,1 +1247,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1267,2 +1267,2 @@\n-  ConcreteMethodFinder(Method* m, Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {\n-    assert(m != NULL && m->is_method(), \"sanity\");\n+  ConcreteMethodFinder(Method* m, Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {\n+    assert(m != nullptr && m->is_method(), \"sanity\");\n@@ -1273,1 +1273,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1277,1 +1277,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1281,2 +1281,2 @@\n-    assert(n == num_participants() || fm != NULL, \"proper usage\");\n-    if (fm != NULL && fm->method_holder() != participant(n)) {\n+    assert(n == num_participants() || fm != nullptr, \"proper usage\");\n+    if (fm != nullptr && fm->method_holder() != participant(n)) {\n@@ -1287,1 +1287,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1294,1 +1294,1 @@\n-    _found_methods[num_participants()] = NULL;\n+    _found_methods[num_participants()] = nullptr;\n@@ -1325,1 +1325,1 @@\n-      if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n+      if (!ik->is_interface() && m != nullptr && m->is_abstract()) {\n@@ -1335,1 +1335,1 @@\n-        if (w != NULL) {\n+        if (w != nullptr) {\n@@ -1347,1 +1347,1 @@\n-      if (default_methods != NULL) {\n+      if (default_methods != nullptr) {\n@@ -1349,1 +1349,1 @@\n-        if (Dependencies::is_concrete_method(dm, NULL)) {\n+        if (Dependencies::is_concrete_method(dm, nullptr)) {\n@@ -1374,1 +1374,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1384,1 +1384,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1387,1 +1387,1 @@\n-      for (InstanceKlass* super = k->java_super(); super != NULL; super = super->java_super()) {\n+      for (InstanceKlass* super = k->java_super(); super != nullptr; super = super->java_super()) {\n@@ -1389,1 +1389,1 @@\n-        if (m != NULL) { \/\/ inherited method found\n+        if (m != nullptr) { \/\/ inherited method found\n@@ -1413,1 +1413,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1455,1 +1455,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1457,1 +1457,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1475,1 +1475,1 @@\n-  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = NULL) : AbstractClassHierarchyWalker(NULL) {\n+  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = nullptr) : AbstractClassHierarchyWalker(nullptr) {\n@@ -1490,1 +1490,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1493,1 +1493,1 @@\n-    assert(participant(n) != NULL || n == num_participants(), \"proper usage\");\n+    assert(participant(n) != nullptr || n == num_participants(), \"proper usage\");\n@@ -1506,1 +1506,1 @@\n-  return NULL; \/\/ No witness found.  The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found.  The dependency remains unbroken.\n@@ -1519,1 +1519,1 @@\n-  return NULL; \/\/ No witness found. The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found. The dependency remains unbroken.\n@@ -1539,1 +1539,1 @@\n-  Method* selected_method = NULL;\n+  Method* selected_method = nullptr;\n@@ -1549,1 +1549,1 @@\n-  return selected_method; \/\/ NULL when corresponding slot is empty (AbstractMethodError case)\n+  return selected_method; \/\/ nullptr when corresponding slot is empty (AbstractMethodError case)\n@@ -1600,1 +1600,1 @@\n-  if (lm == NULL && ctxk->is_instance_klass()) {\n+  if (lm == nullptr && ctxk->is_instance_klass()) {\n@@ -1609,1 +1609,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1636,1 +1636,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1653,2 +1653,2 @@\n-  \/\/ NULL is not a concrete method.\n-  if (m == NULL) {\n+  \/\/ nullptr is not a concrete method.\n+  if (m == nullptr) {\n@@ -1666,1 +1666,1 @@\n-  if (m->is_overpass() && k != NULL) {\n+  if (m->is_overpass() && k != nullptr) {\n@@ -1669,1 +1669,1 @@\n-  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == NULL,\n+  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == nullptr,\n@@ -1681,1 +1681,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -1708,1 +1708,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1723,1 +1723,1 @@\n-  if (sub != NULL) {\n+  if (sub != nullptr) {\n@@ -1729,1 +1729,1 @@\n-    assert(impl != NULL, \"must be set\");\n+    assert(impl != nullptr, \"must be set\");\n@@ -1732,1 +1732,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1749,1 +1749,1 @@\n-\/\/ Find the unique concrete proper subtype of ctxk, or NULL if there\n+\/\/ Find the unique concrete proper subtype of ctxk, or nullptr if there\n@@ -1753,1 +1753,1 @@\n-\/\/ That is, return CC1 for CX > CC1 > CC2, but NULL for CX > { CC1, CC2 }.\n+\/\/ That is, return CC1 for CX > CC1 > CC2, but nullptr for CX > { CC1, CC2 }.\n@@ -1758,1 +1758,1 @@\n-  if (wit != NULL)  return NULL;   \/\/ Too many witnesses.\n+  if (wit != nullptr)  return nullptr;   \/\/ Too many witnesses.\n@@ -1760,1 +1760,1 @@\n-  if (conck == NULL) {\n+  if (conck == nullptr) {\n@@ -1769,1 +1769,1 @@\n-        guarantee(NULL == (void *)\n+        guarantee(nullptr == (void *)\n@@ -1793,1 +1793,1 @@\n-  if (uniqm == NULL) {\n+  if (uniqm == nullptr) {\n@@ -1813,1 +1813,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1820,1 +1820,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -1823,1 +1823,1 @@\n-  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != NULL) {\n+  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != nullptr) {\n@@ -1825,1 +1825,1 @@\n-    if (conck != NULL) {\n+    if (conck != nullptr) {\n@@ -1830,1 +1830,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1838,1 +1838,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1849,2 +1849,2 @@\n-  if (m != NULL) {\n-    if (changes != NULL) {\n+  if (m != nullptr) {\n+    if (changes != nullptr) {\n@@ -1861,1 +1861,1 @@\n-      if (conck != NULL) {\n+      if (conck != nullptr) {\n@@ -1869,1 +1869,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1875,2 +1875,2 @@\n-  assert(base_m != NULL, \"base method should be non null\");\n-  if (sub_m == NULL) {\n+  assert(base_m != nullptr, \"base method should be non null\");\n+  if (sub_m == nullptr) {\n@@ -1898,1 +1898,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1900,1 +1900,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1903,1 +1903,1 @@\n-    return NULL; \/\/ not supported\n+    return nullptr; \/\/ not supported\n@@ -1909,3 +1909,3 @@\n-  if (wit != NULL)  return NULL;  \/\/ Too many witnesses.\n-  Method* fm = wf.found_method(0);  \/\/ Will be NULL if num_parts == 0.\n-  if (participant != NULL) {\n+  if (wit != nullptr)  return nullptr;  \/\/ Too many witnesses.\n+  Method* fm = wf.found_method(0);  \/\/ Will be nullptr if num_parts == 0.\n+  if (participant != nullptr) {\n@@ -1914,2 +1914,2 @@\n-  if (!Dependencies::is_concrete_method(fm, NULL)) {\n-    fm = NULL; \/\/ ignore abstract methods\n+  if (!Dependencies::is_concrete_method(fm, nullptr)) {\n+    fm = nullptr; \/\/ ignore abstract methods\n@@ -1918,1 +1918,1 @@\n-    if (fm == NULL) {\n+    if (fm == nullptr) {\n@@ -1924,1 +1924,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1926,1 +1926,1 @@\n-  } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {\n+  } else if (Dependencies::find_witness_AME(ctxk, fm) != nullptr) {\n@@ -1928,1 +1928,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1931,1 +1931,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1936,2 +1936,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == (void *)check_unique_concrete_method(ctxk, fm),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == (void *)check_unique_concrete_method(ctxk, fm),\n@@ -1944,1 +1944,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1960,1 +1960,1 @@\n-    return NULL; \/\/ no vtable index available\n+    return nullptr; \/\/ no vtable index available\n@@ -1974,1 +1974,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1976,1 +1976,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1987,2 +1987,2 @@\n-  if (wit != NULL) {\n-    return NULL;  \/\/ Too many witnesses.\n+  if (wit != nullptr) {\n+    return nullptr;  \/\/ Too many witnesses.\n@@ -1990,4 +1990,4 @@\n-  \/\/ p == NULL when no participants are found (wf.num_participants() == 0).\n-  \/\/ fm == NULL case has 2 meanings:\n-  \/\/  * when p == NULL: no method found;\n-  \/\/  * when p != NULL: AbstractMethodError-throwing method found.\n+  \/\/ p == nullptr when no participants are found (wf.num_participants() == 0).\n+  \/\/ fm == nullptr case has 2 meanings:\n+  \/\/  * when p == nullptr: no method found;\n+  \/\/  * when p != nullptr: AbstractMethodError-throwing method found.\n@@ -1997,2 +1997,2 @@\n-  assert(fm == NULL || p != NULL, \"no participant\");\n-  \/\/ Normalize all error-throwing cases to NULL.\n+  assert(fm == nullptr || p != nullptr, \"no participant\");\n+  \/\/ Normalize all error-throwing cases to nullptr.\n@@ -2002,1 +2002,1 @@\n-    fm = NULL; \/\/ error-throwing method\n+    fm = nullptr; \/\/ error-throwing method\n@@ -2005,1 +2005,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -2007,1 +2007,1 @@\n-      assert(fm == NULL, \"sanity\");\n+      assert(fm == nullptr, \"sanity\");\n@@ -2013,2 +2013,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n@@ -2018,1 +2018,1 @@\n-  assert(fm == NULL || !fm->is_abstract(), \"sanity\");\n+  assert(fm == nullptr || !fm->is_abstract(), \"sanity\");\n@@ -2023,1 +2023,1 @@\n-  Klass*  uniqp = NULL;\n+  Klass*  uniqp = nullptr;\n@@ -2025,1 +2025,1 @@\n-  assert(uniqm == NULL || uniqm == fm ||\n+  assert(uniqm == nullptr || uniqm == fm ||\n@@ -2028,1 +2028,1 @@\n-         (fm == NULL && uniqm != NULL && uniqp != NULL && !InstanceKlass::cast(uniqp)->is_linked()),\n+         (fm == nullptr && uniqm != nullptr && uniqp != nullptr && !InstanceKlass::cast(uniqp)->is_linked()),\n@@ -2036,1 +2036,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2043,2 +2043,2 @@\n-  assert(call_site != NULL, \"sanity\");\n-  assert(method_handle != NULL, \"sanity\");\n+  assert(call_site != nullptr, \"sanity\");\n+  assert(method_handle != nullptr, \"sanity\");\n@@ -2047,1 +2047,1 @@\n-  if (changes == NULL) {\n+  if (changes == nullptr) {\n@@ -2058,1 +2058,1 @@\n-  return NULL;  \/\/ assertion still valid\n+  return nullptr;  \/\/ assertion still valid\n@@ -2062,1 +2062,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -2075,1 +2075,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2099,1 +2099,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2111,1 +2111,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2117,1 +2117,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2128,1 +2128,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2135,1 +2135,1 @@\n-    Klass* witness = check_new_klass_dependency(NULL);\n+    Klass* witness = check_new_klass_dependency(nullptr);\n@@ -2137,1 +2137,1 @@\n-    assert(witness != NULL || check_klass_init_dependency(NULL) == NULL, \"missed dependency\");\n+    assert(witness != nullptr || check_klass_init_dependency(nullptr) == nullptr, \"missed dependency\");\n@@ -2146,1 +2146,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2152,1 +2152,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2170,1 +2170,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2206,2 +2206,2 @@\n-  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) NULL);\n-  _change_type = (type == NULL ? NO_CHANGE : Start_Klass);\n+  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) nullptr);\n+  _change_type = (type == nullptr ? NO_CHANGE : Start_Klass);\n@@ -2209,1 +2209,1 @@\n-  _ti_base = NULL;\n+  _ti_base = nullptr;\n@@ -2228,1 +2228,1 @@\n-      if (_klass != NULL) {\n+      if (_klass != nullptr) {\n@@ -2233,1 +2233,1 @@\n-    _ti_limit = (_ti_base == NULL) ? 0 : _ti_base->length();\n+    _ti_limit = (_ti_base == nullptr) ? 0 : _ti_base->length();\n@@ -2273,1 +2273,1 @@\n-  if (k == NULL || !k->is_instance_klass()) {\n+  if (k == nullptr || !k->is_instance_klass()) {\n@@ -2300,1 +2300,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":164,"deletions":164,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,3 +206,3 @@\n-    DepValue(OopRecorder* rec, Metadata* metadata, DepValue* candidate = NULL) {\n-      assert(candidate == NULL || candidate->is_metadata(), \"oops\");\n-      if (candidate != NULL && candidate->as_metadata(rec) == metadata) {\n+    DepValue(OopRecorder* rec, Metadata* metadata, DepValue* candidate = nullptr) {\n+      assert(candidate == nullptr || candidate->is_metadata(), \"oops\");\n+      if (candidate != nullptr && candidate->as_metadata(rec) == metadata) {\n@@ -214,3 +214,3 @@\n-    DepValue(OopRecorder* rec, jobject obj, DepValue* candidate = NULL) {\n-      assert(candidate == NULL || candidate->is_object(), \"oops\");\n-      if (candidate != NULL && candidate->as_object(rec) == obj) {\n+    DepValue(OopRecorder* rec, jobject obj, DepValue* candidate = nullptr) {\n+      assert(candidate == nullptr || candidate->is_object(), \"oops\");\n+      if (candidate != nullptr && candidate->as_object(rec) == obj) {\n@@ -236,1 +236,1 @@\n-      assert(m != NULL, \"as_metadata returned NULL\");\n+      assert(m != nullptr, \"as_metadata returned nullptr\");\n@@ -242,1 +242,1 @@\n-      assert(m != NULL, \"as_metadata returned NULL\");\n+      assert(m != nullptr, \"as_metadata returned nullptr\");\n@@ -269,1 +269,1 @@\n-    assert(_dep_seen != NULL, \"deps must be writable\");\n+    assert(_dep_seen != nullptr, \"deps must be writable\");\n@@ -281,1 +281,1 @@\n-    assert(_dep_seen != NULL, \"deps must be writable\");\n+    assert(_dep_seen != nullptr, \"deps must be writable\");\n@@ -394,1 +394,1 @@\n-  static Klass* find_witness_AME(InstanceKlass* ctxk, Method* m, KlassDepChange* changes = NULL);\n+  static Klass* find_witness_AME(InstanceKlass* ctxk, Method* m, KlassDepChange* changes = nullptr);\n@@ -421,8 +421,8 @@\n-  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_implementor(InstanceKlass* ctxk, Klass* uniqk, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, Klass* resolved_klass, Method* resolved_method, KlassDepChange* changes = NULL);\n-  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes = NULL);\n-  static Klass* check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes = NULL);\n-  \/\/ A returned Klass* is NULL if the dependency assertion is still\n-  \/\/ valid.  A non-NULL Klass* is a 'witness' to the assertion\n+  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_implementor(InstanceKlass* ctxk, Klass* uniqk, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, Klass* resolved_klass, Method* resolved_method, KlassDepChange* changes = nullptr);\n+  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes = nullptr);\n+  \/\/ A returned Klass* is nullptr if the dependency assertion is still\n+  \/\/ valid.  A non-nullptr Klass* is a 'witness' to the assertion\n@@ -431,1 +431,1 @@\n-  \/\/ non-NULL, the value is a subtype of the supposed leaf type.  This\n+  \/\/ non-nullptr, the value is a subtype of the supposed leaf type.  This\n@@ -444,1 +444,1 @@\n-                                             Klass** participant = NULL); \/\/ out parameter\n+                                             Klass** participant = nullptr); \/\/ out parameter\n@@ -455,1 +455,1 @@\n-    assert(_content_bytes != NULL, \"encode it first\");\n+    assert(_content_bytes != nullptr, \"encode it first\");\n@@ -459,1 +459,1 @@\n-    assert(_content_bytes != NULL, \"encode it first\");\n+    assert(_content_bytes != nullptr, \"encode it first\");\n@@ -468,1 +468,1 @@\n-  DepType validate_dependencies(CompileTask* task, char** failure_detail = NULL);\n+  DepType validate_dependencies(CompileTask* task, char** failure_detail = nullptr);\n@@ -482,4 +482,4 @@\n-                      ciBaseObject* x1 = NULL,\n-                      ciBaseObject* x2 = NULL,\n-                      ciBaseObject* x3 = NULL) {\n-    if (log() == NULL) {\n+                      ciBaseObject* x1 = nullptr,\n+                      ciBaseObject* x2 = nullptr,\n+                      ciBaseObject* x3 = nullptr) {\n+    if (log() == nullptr) {\n@@ -491,1 +491,1 @@\n-    assert (x0 != NULL, \"no log x0\");\n+    assert (x0 != nullptr, \"no log x0\");\n@@ -494,1 +494,1 @@\n-    if (x1 != NULL) {\n+    if (x1 != nullptr) {\n@@ -497,1 +497,1 @@\n-    if (x2 != NULL) {\n+    if (x2 != nullptr) {\n@@ -500,1 +500,1 @@\n-    if (x3 != NULL) {\n+    if (x3 != nullptr) {\n@@ -513,1 +513,1 @@\n-    DepArgument() : _is_oop(false), _valid(false), _value(NULL) {}\n+    DepArgument() : _is_oop(false), _valid(false), _value(nullptr) {}\n@@ -517,1 +517,1 @@\n-    bool is_null() const               { return _value == NULL; }\n+    bool is_null() const               { return _value == nullptr; }\n@@ -529,1 +529,1 @@\n-                               Klass* witness = NULL, outputStream* st = tty);\n+                               Klass* witness = nullptr, outputStream* st = tty);\n@@ -540,1 +540,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -544,1 +544,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -548,1 +548,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -588,1 +588,1 @@\n-      : _code(NULL),\n+      : _code(nullptr),\n@@ -596,1 +596,1 @@\n-        _deps(NULL),\n+        _deps(nullptr),\n@@ -630,3 +630,3 @@\n-      Klass* result = check_klass_dependency(NULL);\n-      if (result != NULL)  return result;\n-      return check_call_site_dependency(NULL);\n+      Klass* result = check_klass_dependency(nullptr);\n+      if (result != nullptr)  return result;\n+      return check_call_site_dependency(nullptr);\n@@ -640,1 +640,1 @@\n-    void log_dependency(Klass* witness = NULL);\n+    void log_dependency(Klass* witness = nullptr);\n@@ -643,1 +643,1 @@\n-    void print_dependency(Klass* witness = NULL, bool verbose = false, outputStream* st = tty);\n+    void print_dependency(Klass* witness = nullptr, bool verbose = false, outputStream* st = tty);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,5 @@\n-PerfCounter* DependencyContext::_perf_total_buckets_allocated_count   = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_deallocated_count = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_stale_count       = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_stale_acc_count   = NULL;\n-nmethodBucket* volatile DependencyContext::_purge_list                = NULL;\n+PerfCounter* DependencyContext::_perf_total_buckets_allocated_count   = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_deallocated_count = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_stale_count       = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_stale_acc_count   = nullptr;\n+nmethodBucket* volatile DependencyContext::_purge_list                = nullptr;\n@@ -69,1 +69,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -94,1 +94,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -100,1 +100,1 @@\n-  nmethodBucket* new_head = new nmethodBucket(nm, NULL);\n+  nmethodBucket* new_head = new nmethodBucket(nm, nullptr);\n@@ -143,1 +143,1 @@\n-  for (nmethodBucket* b = _purge_list; b != NULL;) {\n+  for (nmethodBucket* b = _purge_list; b != nullptr;) {\n@@ -152,1 +152,1 @@\n-  _purge_list = NULL;\n+  _purge_list = nullptr;\n@@ -166,1 +166,1 @@\n-  while (b != NULL) {\n+  while (b != nullptr) {\n@@ -182,1 +182,1 @@\n-  set_dependencies(NULL);\n+  set_dependencies(nullptr);\n@@ -188,1 +188,1 @@\n-  set_dependencies(NULL);\n+  set_dependencies(nullptr);\n@@ -190,1 +190,1 @@\n-  while (b != NULL) {\n+  while (b != nullptr) {\n@@ -204,1 +204,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -220,1 +220,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -255,1 +255,1 @@\n-    if (head == NULL || !head->get_nmethod()->is_unloading()) {\n+    if (head == nullptr || !head->get_nmethod()->is_unloading()) {\n@@ -309,1 +309,1 @@\n-    if (next == NULL || !next->get_nmethod()->is_unloading()) {\n+    if (next == nullptr || !next->get_nmethod()->is_unloading()) {\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    _nmethod(nmethod), _count(1), _next(next), _purge_list_next(NULL) {}\n+    _nmethod(nmethod), _count(1), _next(next), _purge_list_next(nullptr) {}\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -81,1 +81,1 @@\n-  assert(subtable_for(catch_pco) == NULL, \"catch handlers for this catch_pco added twice\");\n+  assert(subtable_for(catch_pco) == nullptr, \"catch handlers for this catch_pco added twice\");\n@@ -83,1 +83,1 @@\n-  assert(scope_depths_from_top_scope == NULL || handler_bcis->length() == scope_depths_from_top_scope->length(), \"bci & scope_depths table have different length\");\n+  assert(scope_depths_from_top_scope == nullptr || handler_bcis->length() == scope_depths_from_top_scope->length(), \"bci & scope_depths table have different length\");\n@@ -90,1 +90,1 @@\n-      if (scope_depths_from_top_scope != NULL) {\n+      if (scope_depths_from_top_scope != nullptr) {\n@@ -112,1 +112,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -119,1 +119,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -125,1 +125,1 @@\n-  bool have_base_addr = (base != NULL);\n+  bool have_base_addr = (base != nullptr);\n@@ -157,1 +157,1 @@\n-  if( subtable != NULL ) { print_subtable( subtable ); }\n+  if( subtable != nullptr ) { print_subtable( subtable ); }\n@@ -221,1 +221,1 @@\n-    _data = NULL;\n+    _data = nullptr;\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,2 +126,2 @@\n-  void print_subtable(HandlerTableEntry* t, address base = NULL) const;\n-  void print(address base = NULL) const;\n+  void print_subtable(HandlerTableEntry* t, address base = nullptr) const;\n+  void print(address base = nullptr) const;\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-StubQueue* InlineCacheBuffer::_buffer    = NULL;\n+StubQueue* InlineCacheBuffer::_buffer    = nullptr;\n@@ -47,1 +47,1 @@\n-CompiledICHolder* InlineCacheBuffer::_pending_released = NULL;\n+CompiledICHolder* InlineCacheBuffer::_pending_released = nullptr;\n@@ -56,1 +56,1 @@\n-  assert(thread->missed_ic_stub_refill_verifier() == NULL, \"nesting not supported\");\n+  assert(thread->missed_ic_stub_refill_verifier() == nullptr, \"nesting not supported\");\n@@ -63,1 +63,1 @@\n-  Thread::current()->set_missed_ic_stub_refill_verifier(NULL);\n+  Thread::current()->set_missed_ic_stub_refill_verifier(nullptr);\n@@ -68,1 +68,1 @@\n-  assert(thread->missed_ic_stub_refill_verifier() == NULL, \"nesting not supported\");\n+  assert(thread->missed_ic_stub_refill_verifier() == nullptr, \"nesting not supported\");\n@@ -73,1 +73,1 @@\n-  Thread::current()->set_missed_ic_stub_refill_verifier(NULL);\n+  Thread::current()->set_missed_ic_stub_refill_verifier(nullptr);\n@@ -79,1 +79,1 @@\n-  assert(verifier != NULL, \"need a verifier for safety\");\n+  assert(verifier != nullptr, \"need a verifier for safety\");\n@@ -88,1 +88,1 @@\n-    assert(CodeCache::find_compiled(ic->instruction_address()) != NULL, \"inline cache in non-compiled?\");\n+    assert(CodeCache::find_compiled(ic->instruction_address()) != nullptr, \"inline cache in non-compiled?\");\n@@ -122,1 +122,1 @@\n-  _ic_site = NULL;\n+  _ic_site = nullptr;\n@@ -142,1 +142,1 @@\n-  if (_buffer != NULL) return; \/\/ already initialized\n+  if (_buffer != nullptr) return; \/\/ already initialized\n@@ -144,1 +144,1 @@\n-  assert (_buffer != NULL, \"cannot allocate InlineCacheBuffer\");\n+  assert (_buffer != nullptr, \"cannot allocate InlineCacheBuffer\");\n@@ -199,1 +199,1 @@\n-  if (ic_stub == NULL) {\n+  if (ic_stub == nullptr) {\n@@ -237,2 +237,2 @@\n-  _pending_released = NULL;\n-  while (holder != NULL) {\n+  _pending_released = nullptr;\n+  while (holder != nullptr) {\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  void    initialize(int size)                   { _size = size; _ic_site = NULL; }\n+  void    initialize(int size)                   { _size = size; _ic_site = nullptr; }\n@@ -80,1 +80,1 @@\n-  bool    is_empty() const                       { return _ic_site == NULL; }\n+  bool    is_empty() const                       { return _ic_site == nullptr; }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    if (m != NULL) {                                                      \\\n+    if (m != nullptr) {                                                      \\\n@@ -271,1 +271,1 @@\n-  assert(pc != NULL, \"Must be non null\");\n+  assert(pc != nullptr, \"Must be non null\");\n@@ -273,1 +273,1 @@\n-  assert(handler != NULL, \"Must be non null\");\n+  assert(handler != nullptr, \"Must be non null\");\n@@ -277,2 +277,2 @@\n-  _next = NULL;\n-  _purge_list_next = NULL;\n+  _next = nullptr;\n+  _purge_list_next = nullptr;\n@@ -285,1 +285,1 @@\n-  assert(pc != NULL,\"Must be non null\");\n+  assert(pc != nullptr,\"Must be non null\");\n@@ -291,1 +291,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -349,2 +349,2 @@\n-  if (initial_pc_desc == NULL) {\n-    _pc_descs[0] = NULL; \/\/ native method; no PcDescs at all\n+  if (initial_pc_desc == nullptr) {\n+    _pc_descs[0] = nullptr; \/\/ native method; no PcDescs at all\n@@ -376,1 +376,1 @@\n-  if (res == NULL) return NULL;  \/\/ native method; no PcDescs at all\n+  if (res == nullptr) return nullptr;  \/\/ native method; no PcDescs at all\n@@ -393,1 +393,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -432,1 +432,1 @@\n-  if (method() != NULL && is_native_method()) {\n+  if (method() != nullptr && is_native_method()) {\n@@ -438,1 +438,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -447,2 +447,2 @@\n-  _oops_do_mark_link       = NULL;\n-  _osr_link                = NULL;\n+  _oops_do_mark_link       = nullptr;\n+  _osr_link                = nullptr;\n@@ -502,1 +502,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -525,1 +525,1 @@\n-    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n+    NOT_PRODUCT(if (nm != nullptr) native_nmethod_stats.note_native_nmethod(nm));\n@@ -528,1 +528,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -562,1 +562,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -595,1 +595,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -617,1 +617,1 @@\n-          if (klass == NULL) {\n+          if (klass == nullptr) {\n@@ -624,1 +624,1 @@\n-      NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));\n+      NOT_PRODUCT(if (nm != nullptr)  note_java_nmethod(nm));\n@@ -628,1 +628,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -649,1 +649,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -690,3 +690,3 @@\n-    _osr_entry_point         = NULL;\n-    _exception_cache         = NULL;\n-    _pc_desc_container.reset_to(NULL);\n+    _osr_entry_point         = nullptr;\n+    _exception_cache         = nullptr;\n+    _pc_desc_container.reset_to(nullptr);\n@@ -718,1 +718,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -732,1 +732,1 @@\n-        if (oop_maps != NULL) {\n+        if (oop_maps != nullptr) {\n@@ -750,1 +750,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -792,1 +792,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -828,1 +828,1 @@\n-        _deopt_handler_begin = NULL;\n+        _deopt_handler_begin = nullptr;\n@@ -833,1 +833,1 @@\n-        _deopt_mh_handler_begin = NULL;\n+        _deopt_mh_handler_begin = nullptr;\n@@ -847,1 +847,1 @@\n-        _deopt_mh_handler_begin  = NULL;\n+        _deopt_mh_handler_begin  = nullptr;\n@@ -874,1 +874,1 @@\n-    _exception_cache         = NULL;\n+    _exception_cache         = nullptr;\n@@ -917,1 +917,1 @@\n-  if (nm_kind != NULL)  log->print(\" compile_kind='%s'\", nm_kind);\n+  if (nm_kind != nullptr)  log->print(\" compile_kind='%s'\", nm_kind);\n@@ -923,1 +923,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -925,1 +925,1 @@\n-    if (jvmci_name != NULL) {\n+    if (jvmci_name != nullptr) {\n@@ -942,1 +942,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -972,1 +972,1 @@\n-  if (st != NULL) {\n+  if (st != nullptr) {\n@@ -992,1 +992,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1022,1 +1022,1 @@\n-      if (oop_maps() != NULL) {\n+      if (oop_maps() != nullptr) {\n@@ -1064,1 +1064,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1072,1 +1072,1 @@\n-  if (handle == NULL ||\n+  if (handle == nullptr ||\n@@ -1096,1 +1096,1 @@\n-  fix_oop_relocations(NULL, NULL, \/*initialize_immediates=*\/ true);\n+  fix_oop_relocations(nullptr, nullptr, \/*initialize_immediates=*\/ true);\n@@ -1163,1 +1163,1 @@\n-  assert(method() == NULL || can_be_deoptimized(), \"\");\n+  assert(method() == nullptr || can_be_deoptimized(), \"\");\n@@ -1178,1 +1178,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1189,1 +1189,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1216,1 +1216,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1218,1 +1218,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1229,1 +1229,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1231,1 +1231,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1259,1 +1259,1 @@\n-  if (m == NULL)  return;\n+  if (m == nullptr)  return;\n@@ -1261,1 +1261,1 @@\n-  if (mdo == NULL)  return;\n+  if (mdo == nullptr)  return;\n@@ -1281,1 +1281,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1288,1 +1288,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -1305,1 +1305,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1331,1 +1331,1 @@\n-    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1379,1 +1379,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1385,1 +1385,1 @@\n-  if (is_osr_method() && method() != NULL) {\n+  if (is_osr_method() && method() != nullptr) {\n@@ -1397,1 +1397,1 @@\n-  if (_unlinked_next != NULL) {\n+  if (_unlinked_next != nullptr) {\n@@ -1420,1 +1420,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1448,1 +1448,1 @@\n-  while(ec != NULL) {\n+  while(ec != nullptr) {\n@@ -1463,1 +1463,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1470,1 +1470,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1489,1 +1489,1 @@\n-        if (klass == NULL) {\n+        if (klass == nullptr) {\n@@ -1509,1 +1509,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -1543,1 +1543,1 @@\n-    if (state == NULL) {\n+    if (state == nullptr) {\n@@ -1556,1 +1556,1 @@\n-  assert(_method != NULL, \"just checking\");\n+  assert(_method != nullptr, \"just checking\");\n@@ -1585,1 +1585,1 @@\n-        if (r->metadata_is_immediate() && r->metadata_value() != NULL) {\n+        if (r->metadata_is_immediate() && r->metadata_value() != nullptr) {\n@@ -1599,1 +1599,1 @@\n-          if (ic_oop != NULL) {\n+          if (ic_oop != nullptr) {\n@@ -1609,1 +1609,1 @@\n-    if (*p == Universe::non_oop_word() || *p == NULL)  continue;  \/\/ skip non-oops\n+    if (*p == Universe::non_oop_word() || *p == nullptr)  continue;  \/\/ skip non-oops\n@@ -1615,1 +1615,1 @@\n-  if (_method != NULL) f->do_metadata(_method);\n+  if (_method != nullptr) f->do_metadata(_method);\n@@ -1742,1 +1742,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -1761,1 +1761,1 @@\n-        if (r->oop_is_immediate() && r->oop_value() != NULL) {\n+        if (r->oop_is_immediate() && r->oop_value() != nullptr) {\n@@ -1803,1 +1803,1 @@\n-    assert(result == NULL, \"adding to global list as weak done must always succeed.\");\n+    assert(result == nullptr, \"adding to global list as weak done must always succeed.\");\n@@ -1812,1 +1812,1 @@\n-  if ((_oops_do_mark_link == NULL) &&\n+  if ((_oops_do_mark_link == nullptr) &&\n@@ -1827,2 +1827,2 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n-  if (old_next == NULL) {\n+  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n+  if (old_next == nullptr) {\n@@ -1866,1 +1866,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1872,1 +1872,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1883,1 +1883,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1902,1 +1902,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1919,1 +1919,1 @@\n-  if (next_raw == NULL) {\n+  if (next_raw == nullptr) {\n@@ -1952,1 +1952,1 @@\n-  assert(_oops_do_mark_nmethods == NULL, \"must be empty\");\n+  assert(_oops_do_mark_nmethods == nullptr, \"must be empty\");\n@@ -1959,2 +1959,2 @@\n-  _oops_do_mark_nmethods = NULL;\n-  if (next != NULL) {\n+  _oops_do_mark_nmethods = nullptr;\n+  if (next != nullptr) {\n@@ -1965,1 +1965,1 @@\n-      cur->_oops_do_mark_link = NULL;\n+      cur->_oops_do_mark_link = nullptr;\n@@ -2008,1 +2008,1 @@\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), \"must have deopt mh handler\");\n+  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != nullptr), \"must have deopt mh handler\");\n@@ -2039,1 +2039,1 @@\n-  PcDesc* res = NULL;\n+  PcDesc* res = nullptr;\n@@ -2043,1 +2043,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -2059,1 +2059,1 @@\n-    return NULL;  \/\/ PC is wildly out of range\n+    return nullptr;  \/\/ PC is wildly out of range\n@@ -2066,1 +2066,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -2078,1 +2078,1 @@\n-  if (lower >= upper)  return NULL;  \/\/ native method; no PcDescs at all\n+  if (lower >= upper)  return nullptr;  \/\/ native method; no PcDescs at all\n@@ -2131,2 +2131,2 @@\n-    assert(NULL == linear_search(search, pc_offset, approximate), \"search ok\");\n-    return NULL;\n+    assert(nullptr == linear_search(search, pc_offset, approximate), \"search ok\");\n+    return nullptr;\n@@ -2165,1 +2165,1 @@\n-          if (deps.check_dependency() != NULL) {\n+          if (deps.check_dependency() != nullptr) {\n@@ -2188,1 +2188,1 @@\n-    if (deps.spot_check_dependency_at(changes) != NULL) {\n+    if (deps.spot_check_dependency_at(changes) != nullptr) {\n@@ -2284,1 +2284,1 @@\n-        assert(pc_desc_at(code_begin() + exec_offset) != NULL, \"missing PcDesc\");\n+        assert(pc_desc_at(code_begin() + exec_offset) != nullptr, \"missing PcDesc\");\n@@ -2304,1 +2304,1 @@\n-  assert(_oops_do_mark_link == NULL, \"_oops_do_mark_link for %s should be NULL but is \" PTR_FORMAT,\n+  assert(_oops_do_mark_link == nullptr, \"_oops_do_mark_link for %s should be nullptr but is \" PTR_FORMAT,\n@@ -2329,1 +2329,1 @@\n-  assert(pd != NULL, \"PcDesc must exist\");\n+  assert(pd != nullptr, \"PcDesc must exist\");\n@@ -2343,1 +2343,1 @@\n-    address stub = NULL;\n+    address stub = nullptr;\n@@ -2367,1 +2367,1 @@\n-    assert(stub == NULL || stub_contains(stub), \"static call stub outside stub section\");\n+    assert(stub == nullptr || stub_contains(stub), \"static call stub outside stub section\");\n@@ -2395,1 +2395,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -2480,1 +2480,1 @@\n-    if (ctxk != NULL) {\n+    if (ctxk != nullptr) {\n@@ -2505,2 +2505,2 @@\n-      if (*p == NULL) {\n-        st->print_cr(\"NULL-oop\");\n+      if (*p == nullptr) {\n+        st->print_cr(\"nullptr-oop\");\n@@ -2548,1 +2548,1 @@\n-      while (sd != NULL) {\n+      while (sd != nullptr) {\n@@ -2593,1 +2593,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -2610,1 +2610,1 @@\n-      tty->print(\"NULL-oop\");\n+      tty->print(\"nullptr-oop\");\n@@ -2644,2 +2644,2 @@\n-      } else if (m == NULL) {\n-        tty->print(\"NULL-oop\");\n+      } else if (m == nullptr) {\n+        tty->print(\"nullptr-oop\");\n@@ -2774,1 +2774,1 @@\n-  if ((start == NULL) || (end == NULL)) {\n+  if ((start == nullptr) || (end == nullptr)) {\n@@ -2787,1 +2787,1 @@\n-    const char* header = NULL;\n+    const char* header = nullptr;\n@@ -2791,1 +2791,1 @@\n-      while ((p < end) && (header == NULL)) {\n+      while ((p < end) && (header == nullptr)) {\n@@ -2800,2 +2800,2 @@\n-        header = NULL;\n-      } else if (header != NULL) {\n+        header = nullptr;\n+      } else if (header != nullptr) {\n@@ -2804,1 +2804,1 @@\n-        header = NULL;\n+        header = nullptr;\n@@ -2821,1 +2821,1 @@\n-    while ((p < end) && (p != NULL)) {\n+    while ((p < end) && (p != nullptr)) {\n@@ -2901,1 +2901,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2911,1 +2911,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2923,1 +2923,1 @@\n-          if (cb != NULL) {\n+          if (cb != nullptr) {\n@@ -2944,1 +2944,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2955,1 +2955,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2966,1 +2966,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2985,1 +2985,1 @@\n-  return have_one ? \"other\" : NULL;\n+  return have_one ? \"other\" : nullptr;\n@@ -2991,1 +2991,1 @@\n-  if (p != NULL && p->real_pc(this) <= end) {\n+  if (p != nullptr && p->real_pc(this) <= end) {\n@@ -2994,1 +2994,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2998,1 +2998,1 @@\n-  const char* label = NULL;\n+  const char* label = nullptr;\n@@ -3007,1 +3007,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_begin != NULL &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_begin != nullptr &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n@@ -3014,1 +3014,1 @@\n-    if (label != NULL) {\n+    if (label != nullptr) {\n@@ -3022,1 +3022,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -3027,1 +3027,1 @@\n-    if (m != NULL && !is_osr_method()) {\n+    if (m != nullptr && !is_osr_method()) {\n@@ -3117,1 +3117,1 @@\n-  if (sd != NULL) return true;\n+  if (sd != nullptr) return true;\n@@ -3121,1 +3121,1 @@\n-  if (str != NULL) return true;\n+  if (str != nullptr) return true;\n@@ -3152,1 +3152,1 @@\n-  if (oms != NULL) {\n+  if (oms != nullptr) {\n@@ -3181,1 +3181,1 @@\n-  if (sd != NULL) {\n+  if (sd != nullptr) {\n@@ -3196,2 +3196,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3211,1 +3211,1 @@\n-            if (invoke.name() != NULL)\n+            if (invoke.name() != nullptr)\n@@ -3224,1 +3224,1 @@\n-            if (field.name() != NULL)\n+            if (field.name() != nullptr)\n@@ -3237,1 +3237,1 @@\n-    for (;sd != NULL; sd = sd->sender()) {\n+    for (;sd != nullptr; sd = sd->sender()) {\n@@ -3243,2 +3243,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3262,2 +3262,2 @@\n-  if (str != NULL) {\n-    if (sd != NULL) st->cr();\n+  if (str != nullptr) {\n+    if (sd != nullptr) st->cr();\n@@ -3309,1 +3309,1 @@\n-    assert(db != NULL && !db->is_adapter_blob(), \"must use stub!\");\n+    assert(db != nullptr && !db->is_adapter_blob(), \"must use stub!\");\n@@ -3345,1 +3345,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3363,1 +3363,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -3391,1 +3391,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='nmethod'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='nmethod'\");\n@@ -3408,1 +3408,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -3417,1 +3417,1 @@\n-    guarantee(jvmci_nmethod_data() != NULL, \"failed speculation in nmethod without failed speculation list\");\n+    guarantee(jvmci_nmethod_data() != nullptr, \"failed speculation in nmethod without failed speculation list\");\n@@ -3424,1 +3424,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -3427,1 +3427,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":156,"deletions":156,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  \/\/   _oops_do_mark_link == NULL: the nmethod has not been visited at all yet, i.e.\n+  \/\/   _oops_do_mark_link == nullptr: the nmethod has not been visited at all yet, i.e.\n@@ -176,1 +176,1 @@\n-  \/\/ Attempt N|WR -> X|WD transition. Returns NULL if successful, X otherwise.\n+  \/\/ Attempt N|WR -> X|WD transition. Returns nullptr if successful, X otherwise.\n@@ -344,1 +344,1 @@\n-                              , char* speculations = NULL,\n+                              , char* speculations = nullptr,\n@@ -347,2 +347,2 @@\n-                              const char* nmethod_mirror_name = NULL,\n-                              FailedSpeculation** failed_speculations = NULL\n+                              const char* nmethod_mirror_name = nullptr,\n+                              FailedSpeculation** failed_speculations = nullptr\n@@ -381,1 +381,1 @@\n-  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : NULL; }\n+  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : nullptr; }\n@@ -489,1 +489,1 @@\n-  Metadata*     metadata_at(int index) const      { return index == 0 ? NULL: *metadata_addr_at(index); }\n+  Metadata*     metadata_at(int index) const      { return index == 0 ? nullptr: *metadata_addr_at(index); }\n@@ -506,1 +506,1 @@\n-  void fix_oop_relocations()                           { fix_oop_relocations(NULL, NULL, false); }\n+  void fix_oop_relocations()                           { fix_oop_relocations(nullptr, nullptr, false); }\n@@ -540,1 +540,1 @@\n-  \/\/ This returns a non-NULL value iff this nmethod was\n+  \/\/ This returns a non-nullptr value iff this nmethod was\n@@ -543,1 +543,1 @@\n-    return jvmci_data_size() == 0 ? NULL : (JVMCINMethodData*) jvmci_data_begin();\n+    return jvmci_data_size() == 0 ? nullptr : (JVMCINMethodData*) jvmci_data_begin();\n@@ -599,1 +599,1 @@\n-  void post_compiled_method_load_event(JvmtiThreadState* state = NULL);\n+  void post_compiled_method_load_event(JvmtiThreadState* state = nullptr);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-  _handles  = NULL;\n-  _indexes  = NULL;\n+  _handles  = nullptr;\n+  _indexes  = nullptr;\n@@ -57,1 +57,1 @@\n-  if (_handles == NULL)  return 0;\n+  if (_handles == nullptr)  return 0;\n@@ -68,2 +68,2 @@\n-  if (_handles == NULL) {\n-    if (_arena != NULL) {\n+  if (_handles == nullptr) {\n+    if (_arena != nullptr) {\n@@ -81,2 +81,2 @@\n-  \/\/ there is always a NULL virtually present as first object\n-  if (index == null_index)  return NULL;\n+  \/\/ there is always a nullptr virtually present as first object\n+  if (index == null_index)  return nullptr;\n@@ -98,1 +98,1 @@\n-    if (_indexes != NULL) {\n+    if (_indexes != nullptr) {\n@@ -101,1 +101,1 @@\n-    } else if (index == index_cache_threshold && _arena != NULL) {\n+    } else if (index == index_cache_threshold && _arena != nullptr) {\n@@ -114,1 +114,1 @@\n-    \/\/ an argument of NULL or Universe::non_oop_word.\n+    \/\/ an argument of nullptr or Universe::non_oop_word.\n@@ -127,1 +127,1 @@\n-  if (h == NULL)  return null_index;\n+  if (h == nullptr)  return null_index;\n@@ -129,2 +129,2 @@\n-  int* cloc = (_indexes == NULL)? NULL: _indexes->cache_location(h);\n-  if (cloc != NULL) {\n+  int* cloc = (_indexes == nullptr)? nullptr: _indexes->cache_location(h);\n+  if (cloc != nullptr) {\n@@ -150,1 +150,1 @@\n-      if (cloc != NULL) {\n+      if (cloc != nullptr) {\n@@ -191,1 +191,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -211,1 +211,1 @@\n-    _object_lookup = NULL;\n+    _object_lookup = nullptr;\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  \/\/ Use the given arena to manage storage, if not NULL.\n+  \/\/ Use the given arena to manage storage, if not nullptr.\n@@ -43,1 +43,1 @@\n-  ValueRecorder(Arena* arena = NULL);\n+  ValueRecorder(Arena* arena = nullptr);\n@@ -73,2 +73,2 @@\n-    if (_handles == NULL) return 0;\n-    \/\/ there is always a NULL virtually present as first object\n+    if (_handles == nullptr) return 0;\n+    \/\/ there is always a nullptr virtually present as first object\n@@ -78,1 +78,1 @@\n-  \/\/ Helper function; returns false for NULL or Universe::non_oop_word().\n+  \/\/ Helper function; returns false for nullptr or Universe::non_oop_word().\n@@ -84,1 +84,1 @@\n-  bool is_unused() { return _handles == NULL && !_complete; }\n+  bool is_unused() { return _handles == nullptr && !_complete; }\n@@ -135,1 +135,1 @@\n-  GrowableArray<T>*        _handles;  \/\/ ordered list (first is always NULL)\n+  GrowableArray<T>*        _handles;  \/\/ ordered list (first is always nullptr)\n@@ -157,1 +157,1 @@\n-    ObjectEntry() : _value(NULL), _index(0) {}\n+    ObjectEntry() : _value(nullptr), _index(0) {}\n@@ -184,1 +184,1 @@\n-  OopRecorder(Arena* arena = NULL, bool deduplicate = false);\n+  OopRecorder(Arena* arena = nullptr, bool deduplicate = false);\n@@ -190,1 +190,1 @@\n-    return _object_lookup != NULL ? _object_lookup->find_index(h, this) : _oops.find_index(h);\n+    return _object_lookup != nullptr ? _object_lookup->find_index(h, this) : _oops.find_index(h);\n","filename":"src\/hotspot\/share\/code\/oopRecorder.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  return h != NULL && h != (T)Universe::non_oop_word();\n+  return h != nullptr && h != (T)Universe::non_oop_word();\n","filename":"src\/hotspot\/share\/code\/oopRecorder.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-       sd != NULL;\n+       sd != nullptr;\n","filename":"src\/hotspot\/share\/code\/pcDesc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-  if (nm == NULL && begin != NULL) {\n+  if (nm == nullptr && begin != nullptr) {\n@@ -125,1 +125,1 @@\n-    nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+    nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n@@ -127,1 +127,1 @@\n-  guarantee(nm != NULL, \"must be able to deduce nmethod from other arguments\");\n+  guarantee(nm != nullptr, \"must be able to deduce nmethod from other arguments\");\n@@ -144,2 +144,2 @@\n-  assert(begin == NULL || begin >= nm->code_begin(), \"in bounds\");\n-  assert(limit == NULL || limit <= nm->code_end(),   \"in bounds\");\n+  assert(begin == nullptr || begin >= nm->code_begin(), \"in bounds\");\n+  assert(limit == nullptr || limit <= nm->code_end(),   \"in bounds\");\n@@ -156,1 +156,1 @@\n-  _code    = NULL; \/\/ Not cb->blob();\n+  _code    = nullptr; \/\/ Not cb->blob();\n@@ -168,2 +168,2 @@\n-  assert(begin == NULL || begin >= cs->start(), \"in bounds\");\n-  assert(limit == NULL || limit <= cs->end(),   \"in bounds\");\n+  assert(begin == nullptr || begin >= cs->start(), \"in bounds\");\n+  assert(limit == nullptr || limit <= cs->end(),   \"in bounds\");\n@@ -183,1 +183,1 @@\n-  if (begin != NULL) {\n+  if (begin != nullptr) {\n@@ -224,2 +224,2 @@\n-    _section_start[i] = NULL;  \/\/ these will be lazily computed, if needed\n-    _section_end  [i] = NULL;\n+    _section_start[i] = nullptr;  \/\/ these will be lazily computed, if needed\n+    _section_end  [i] = nullptr;\n@@ -307,1 +307,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -364,1 +364,1 @@\n-  for (; src != NULL; src = src->before_expand()) {\n+  for (; src != nullptr; src = src->before_expand()) {\n@@ -376,1 +376,1 @@\n-  if (addr0 == NULL || dest->allocates2(addr0))  return;\n+  if (addr0 == nullptr || dest->allocates2(addr0))  return;\n@@ -439,1 +439,1 @@\n-  _cached_value = x0==0? NULL: address_from_scaled_offset(x0, point);\n+  _cached_value = x0==0? nullptr: address_from_scaled_offset(x0, point);\n@@ -511,1 +511,1 @@\n-  if (sindex == CodeBuffer::SECT_NONE && _target != NULL\n+  if (sindex == CodeBuffer::SECT_NONE && _target != nullptr\n@@ -527,1 +527,1 @@\n-    guarantee(_target == NULL || dest->allocates2(_target), \"must be within the given code section\");\n+    guarantee(_target == nullptr || dest->allocates2(_target), \"must be within the given code section\");\n@@ -529,1 +529,1 @@\n-    assert(!(x0 == 0 && _target != NULL), \"correct encoding of null target\");\n+    assert(!(x0 == 0 && _target != nullptr), \"correct encoding of null target\");\n@@ -532,1 +532,1 @@\n-    assert(_target != NULL, \"sanity\");\n+    assert(_target != nullptr, \"sanity\");\n@@ -548,1 +548,1 @@\n-  _target = x0==0? NULL: address_from_scaled_offset(x0, addr());\n+  _target = x0==0? nullptr: address_from_scaled_offset(x0, addr());\n@@ -579,1 +579,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -616,1 +616,1 @@\n-  if (v == (Metadata*)Universe::non_oop_word())  v = NULL;\n+  if (v == (Metadata*)Universe::non_oop_word())  v = nullptr;\n@@ -629,1 +629,1 @@\n-  assert(_cached_value != NULL && _cached_value < addr(), \"must precede ic_call\");\n+  assert(_cached_value != nullptr && _cached_value < addr(), \"must precede ic_call\");\n@@ -635,1 +635,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -637,2 +637,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -663,1 +663,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -665,2 +665,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -696,1 +696,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -701,1 +701,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -703,2 +703,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -737,1 +737,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -741,1 +741,1 @@\n-\/\/ found NULL is returned which can be handled by the caller.\n+\/\/ found nullptr is returned which can be handled by the caller.\n@@ -746,1 +746,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -757,1 +757,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -769,1 +769,1 @@\n-  if (_target != NULL) {\n+  if (_target != nullptr) {\n@@ -774,1 +774,1 @@\n-  \/\/ If target is NULL, this is  an absolute embedded reference to an external\n+  \/\/ If target is nullptr, this is  an absolute embedded reference to an external\n@@ -784,1 +784,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -793,1 +793,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -802,1 +802,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -859,4 +859,4 @@\n-      oop* oop_addr  = NULL;\n-      oop  raw_oop   = NULL;\n-      oop  oop_value = NULL;\n-      if (code() != NULL || r->oop_is_immediate()) {\n+      oop* oop_addr  = nullptr;\n+      oop  raw_oop   = nullptr;\n+      oop  oop_value = nullptr;\n+      if (code() != nullptr || r->oop_is_immediate()) {\n@@ -871,1 +871,1 @@\n-      if (WizardMode && oop_value != NULL) {\n+      if (WizardMode && oop_value != nullptr) {\n@@ -882,4 +882,4 @@\n-      Metadata** metadata_addr  = NULL;\n-      Metadata*    raw_metadata   = NULL;\n-      Metadata*    metadata_value = NULL;\n-      if (code() != NULL || r->metadata_is_immediate()) {\n+      Metadata** metadata_addr  = nullptr;\n+      Metadata*    raw_metadata   = nullptr;\n+      Metadata*    metadata_value = nullptr;\n+      if (code() != nullptr || r->metadata_is_immediate()) {\n@@ -892,1 +892,1 @@\n-      if (metadata_value != NULL) {\n+      if (metadata_value != nullptr) {\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -583,1 +583,1 @@\n-    debug_only(_data = NULL);\n+    debug_only(_data = nullptr);\n@@ -607,2 +607,2 @@\n-  RelocIterator(CompiledMethod* nm, address begin = NULL, address limit = NULL);\n-  RelocIterator(CodeSection* cb, address begin = NULL, address limit = NULL);\n+  RelocIterator(CompiledMethod* nm, address begin = nullptr, address limit = nullptr);\n+  RelocIterator(CodeSection* cb, address begin = nullptr, address limit = nullptr);\n@@ -627,1 +627,1 @@\n-    if (_limit != NULL && _addr >= _limit) {\n+    if (_limit != nullptr && _addr >= _limit) {\n@@ -692,1 +692,1 @@\n-    assert(_binding != NULL, \"must be bound\");\n+    assert(_binding != nullptr, \"must be bound\");\n@@ -696,1 +696,1 @@\n-    assert(_binding == NULL, \"must be unbound\");\n+    assert(_binding == nullptr, \"must be unbound\");\n@@ -698,1 +698,1 @@\n-    assert(_binding != NULL, \"must now be bound\");\n+    assert(_binding != nullptr, \"must now be bound\");\n@@ -701,1 +701,1 @@\n-  explicit Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n+  explicit Relocation(relocInfo::relocType rtype) : _binding(nullptr), _rtype(rtype) { }\n@@ -791,1 +791,1 @@\n-  address    pd_call_destination     (address orig_addr = NULL);\n+  address    pd_call_destination     (address orig_addr = nullptr);\n@@ -808,1 +808,1 @@\n-    \/\/ Some relocations treat offset=0 as meaning NULL.\n+    \/\/ Some relocations treat offset=0 as meaning nullptr.\n@@ -810,1 +810,1 @@\n-    if (x == NULL)  return 0;\n+    if (x == nullptr)  return 0;\n@@ -1023,1 +1023,1 @@\n-  \/\/ Note:  oop_value transparently converts Universe::non_oop_word to NULL.\n+  \/\/ Note:  oop_value transparently converts Universe::non_oop_word to nullptr.\n@@ -1077,1 +1077,1 @@\n-  \/\/ Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.\n+  \/\/ Note:  metadata_value transparently converts Universe::non_metadata_word to nullptr.\n@@ -1101,1 +1101,1 @@\n-    assert(cached_value != NULL, \"first oop address must be specified\");\n+    assert(cached_value != nullptr, \"first oop address must be specified\");\n@@ -1299,1 +1299,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n@@ -1314,2 +1314,2 @@\n-    assert(target == NULL || (uintptr_t)target >= (uintptr_t)OSInfo::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n-    return target != NULL;\n+    assert(target == nullptr || (uintptr_t)target >= (uintptr_t)OSInfo::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n+    return target != nullptr;\n@@ -1331,1 +1331,1 @@\n-  \/\/ If the \"a\" value is 0 (i.e., _target is NULL), the address is stored\n+  \/\/ If the \"a\" value is 0 (i.e., _target is nullptr), the address is stored\n@@ -1337,1 +1337,1 @@\n-  address  target();        \/\/ if _target==NULL, fetch addr from code stream\n+  address  target();        \/\/ if _target==nullptr, fetch addr from code stream\n@@ -1345,1 +1345,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n@@ -1374,1 +1374,1 @@\n-  \/\/ If the \"o\" value is 0 (i.e., _target is NULL), the offset is stored\n+  \/\/ If the \"o\" value is 0 (i.e., _target is nullptr), the offset is stored\n@@ -1381,1 +1381,1 @@\n-  address  target();        \/\/ if _target==NULL, fetch addr from code stream\n+  address  target();        \/\/ if _target==nullptr, fetch addr from code stream\n@@ -1396,1 +1396,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -108,1 +108,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -123,1 +123,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -158,1 +158,1 @@\n-  if (is_top()) return NULL;\n+  if (is_top()) return nullptr;\n@@ -181,1 +181,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -186,1 +186,1 @@\n-  if (pd != NULL) {\n+  if (pd != nullptr) {\n@@ -204,1 +204,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -215,1 +215,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -226,1 +226,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -237,1 +237,1 @@\n-  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != NULL) {\n+  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != nullptr) {\n@@ -260,1 +260,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    assert(pc_desc != NULL, \"Must be able to find matching PcDesc\");\n+    assert(pc_desc != nullptr, \"Must be able to find matching PcDesc\");\n@@ -85,1 +85,1 @@\n-  \/\/ Stack walking, returns NULL if this is the outer most scope.\n+  \/\/ Stack walking, returns nullptr if this is the outer most scope.\n@@ -93,1 +93,1 @@\n-  \/\/ Tells whether sender() returns NULL\n+  \/\/ Tells whether sender() returns nullptr\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-  if( blob == NULL) {\n+  if( blob == nullptr) {\n@@ -102,1 +102,1 @@\n-    for (Stub* s = first(); s != NULL; s = next(s)) {\n+    for (Stub* s = first(); s != nullptr; s = next(s)) {\n@@ -106,1 +106,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -112,1 +112,1 @@\n-  if (s != NULL) commit(code_size);\n+  if (s != nullptr) commit(code_size);\n@@ -125,1 +125,1 @@\n-  if (_mutex != NULL) _mutex->lock_without_safepoint_check();\n+  if (_mutex != nullptr) _mutex->lock_without_safepoint_check();\n@@ -156,2 +156,2 @@\n-  if (_mutex != NULL) _mutex->unlock();\n-  return NULL;\n+  if (_mutex != nullptr) _mutex->unlock();\n+  return nullptr;\n@@ -169,1 +169,1 @@\n-  if (_mutex != NULL) _mutex->unlock();\n+  if (_mutex != nullptr) _mutex->unlock();\n@@ -212,1 +212,1 @@\n-  if (_stub_buffer == NULL) return;\n+  if (_stub_buffer == nullptr) return;\n@@ -230,1 +230,1 @@\n-  for (Stub* s = first(); s != NULL; s = next(s)) {\n+  for (Stub* s = first(); s != nullptr; s = next(s)) {\n@@ -241,1 +241,1 @@\n-  for (Stub* s = first(); s != NULL; s = next(s)) {\n+  for (Stub* s = first(); s != nullptr; s = next(s)) {\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-  address code_begin() const                     { ShouldNotCallThis(); return NULL; }   \/\/ points to the first byte of    the code\n-  address code_end() const                       { ShouldNotCallThis(); return NULL; }   \/\/ points to the first byte after the code\n+  address code_begin() const                     { ShouldNotCallThis(); return nullptr; }   \/\/ points to the first byte of    the code\n+  address code_end() const                       { ShouldNotCallThis(); return nullptr; }   \/\/ points to the first byte after the code\n@@ -204,1 +204,1 @@\n-  Stub* first() const                            { return number_of_stubs() > 0 ? stub_at(_queue_begin) : NULL; }\n+  Stub* first() const                            { return number_of_stubs() > 0 ? stub_at(_queue_begin) : nullptr; }\n@@ -208,1 +208,1 @@\n-                                                   return (i == _queue_end) ? NULL : stub_at(i);\n+                                                   return (i == _queue_end) ? nullptr : stub_at(i);\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[\" INTPTR_FORMAT \"] returns NULL\", value());\n+    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[\" INTPTR_FORMAT \"] returns nullptr\", value());\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-address VtableStub::_chunk             = NULL;\n-address VtableStub::_chunk_end         = NULL;\n+address VtableStub::_chunk             = nullptr;\n+address VtableStub::_chunk_end         = nullptr;\n@@ -62,1 +62,1 @@\n-  if (_chunk == NULL || _chunk + real_size > _chunk_end) {\n+  if (_chunk == nullptr || _chunk + real_size > _chunk_end) {\n@@ -68,2 +68,2 @@\n-    if (blob == NULL) {\n-      return NULL;\n+    if (blob == nullptr) {\n+      return nullptr;\n@@ -135,1 +135,1 @@\n-      _table[i] = NULL;\n+      _table[i] = nullptr;\n@@ -219,1 +219,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -227,2 +227,2 @@\n-      if (s == NULL) {\n-        return NULL;\n+      if (s == nullptr) {\n+        return nullptr;\n@@ -282,2 +282,2 @@\n-  for (s = _table[hash]; s != NULL && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : NULL;\n+  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  return (s == stub) ? s : nullptr;\n@@ -289,1 +289,1 @@\n-  return stub_containing(pc) != NULL;\n+  return stub_containing(pc) != nullptr;\n@@ -298,1 +298,1 @@\n-    for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n@@ -302,1 +302,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-        for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or NULL\n+  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or nullptr\n@@ -134,1 +134,1 @@\n-        : _next(NULL), _index(index), _ame_offset(-1), _npe_offset(-1),\n+        : _next(nullptr), _index(index), _ame_offset(-1), _npe_offset(-1),\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}