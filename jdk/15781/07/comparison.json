{"files":[{"patch":"@@ -1896,0 +1896,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1614,0 +1614,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2836,0 +2836,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2888,0 +2897,24 @@\n+  }\n+}\n+\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    if (::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      int err = errno;\n+      if (err == EINVAL) { \/\/ Not supported\n+        \/\/ When using THP we need to always pre-touch using small pages as the\n+        \/\/ OS will initially always use small pages.\n+        pretouch_memory_common(first, last, os::vm_page_size());\n+      } else {\n+        log_warning(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT\n+                            \", %d) failed; error='%s' (errno=%d)\",\n+                            p2i(first), len, MADV_POPULATE_WRITE,\n+                            os::strerror(err), err);\n+      }\n+    }\n+  } else {\n+    pretouch_memory_common(first, last, page_size);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3823,0 +3823,5 @@\n+\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2108,1 +2108,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -2110,1 +2110,1 @@\n-    assert(cur <= last, \"invariant\");\n+    assert(first <= last, \"invariant\");\n@@ -2113,4 +2113,11 @@\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n-    }\n+    pd_pretouch_memory(first, last, page_size);\n+  }\n+}\n+\n+void os::pretouch_memory_common(void* first, void* last, size_t page_size) {\n+  assert(is_aligned(first, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(first), page_size);\n+  assert(is_aligned(last, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(last), page_size);\n+  assert(first <= last, \"invalid range: \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(first), p2i(last));\n+  for (char* cur = static_cast<char*>(first); \/* break *\/; cur += page_size) {\n+    Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+    if (cur >= last) break;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -226,0 +226,6 @@\n+  static void   pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n+  \/\/ Some platforms may have special treatment for pretouch, while most\n+  \/\/ platforms do the same thing. So the common part of the code was extracted\n+  \/\/ here to avoid copying it around.\n+  static void   pretouch_memory_common(void* first, void* last, size_t page_size);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) Ampere Computing and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestTransparentHugePageUsage\n+ * @bug 8315923\n+ * @requires vm.gc.Parallel & os.family == \"linux\" & os.maxMemory > 2G\n+ * @summary Check if the usage of THP is zero when enabled.\n+ * @comment The test is not ParallelGC-specific, but a multi-threaded GC is\n+ *          required. So ParallelGC is used here.\n+ *\n+ * @run main\/othervm -XX:+UseTransparentHugePages\n+ *                   -XX:+UseParallelGC -XX:ParallelGCThreads=${os.processors}\n+ *                   -Xlog:startuptime,pagesize,gc+heap=debug\n+ *                   -Xms1G -Xmx1G -XX:+AlwaysPreTouch\n+ *                   runtime.os.TestTransparentHugePageUsage\n+ *\/\n+\n+package runtime.os;\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.lang.management.ManagementFactory;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTransparentHugePageUsage {\n+  private static boolean foundHeapFrom(BufferedReader reader) throws Exception {\n+    String line = null;\n+    \/\/ Read the size. It is given right after the start of the mapping.\n+    Pattern size = Pattern.compile(\"^Size:\\\\s+(\\\\d+)\\\\skB\");\n+    if ((line = reader.readLine()) != null) {\n+      Matcher matcher = size.matcher(line);\n+      \/\/ Found the heap based on its size.\n+      if (matcher.matches() &&\n+          Integer.valueOf(line.substring(matcher.start(1), matcher.end(1))) >= 1 * 1024 * 1024) {\n+        Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n+        while ((line = reader.readLine()) != null) {\n+          matcher = thpUsage.matcher(line);\n+          if (matcher.matches()) {\n+            if (Integer.valueOf(line.substring(matcher.start(1), matcher.end(1))) == 0) {\n+              \/\/ Trigger failure when the usage is 0. This does not cover\n+              \/\/ all cases considered to be failures, but we can just say\n+              \/\/ the non-usage of THP failes for sure.\n+              throw new RuntimeException(\"The usage of THP should not be zero.\");\n+            }\n+            break;\n+          }\n+        }\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    HotSpotDiagnosticMXBean mxBean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+    \/\/ Ensure THP is not disabled by OS.\n+    if (mxBean.getVMOption(\"UseTransparentHugePages\").getValue() == \"true\") {\n+      BufferedReader reader = new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"));\n+      \/\/ Match the start of a mapping, for example:\n+      \/\/ 200000000-800000000 rw-p 00000000 00:00 0\n+      Pattern mapping = Pattern.compile(\"^\\\\p{XDigit}+-\\\\p{XDigit}+.*\");\n+      String line = null;\n+      while ((line = reader.readLine()) != null) {\n+        if (mapping.matcher(line).matches()) {\n+          if (foundHeapFrom(reader)) break;\n+        }\n+      }\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTransparentHugePageUsage.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}