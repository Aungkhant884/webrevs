{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -31,6 +32,1 @@\n- *\n- * @run main\/othervm -XX:+UseTransparentHugePages\n- *                   -XX:+UseParallelGC -XX:ParallelGCThreads=${os.processors}\n- *                   -Xlog:startuptime,pagesize,gc+heap=debug\n- *                   -Xms1G -Xmx1G -XX:+AlwaysPreTouch\n- *                   runtime.os.TestTransparentHugePageUsage\n+ * @run driver runtime.os.TestTransparentHugePageUsage ${os.processors}\n@@ -41,1 +37,0 @@\n-import com.sun.management.HotSpotDiagnosticMXBean;\n@@ -44,1 +39,5 @@\n-import java.lang.management.ManagementFactory;\n+import java.io.InputStreamReader;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Optional;\n@@ -47,0 +46,2 @@\n+import java.util.stream.Stream;\n+import jdk.test.lib.process.ProcessTools;\n@@ -49,24 +50,10 @@\n-  private static boolean foundHeapFrom(BufferedReader reader) throws Exception {\n-    String line = null;\n-    \/\/ Read the size. It is given right after the start of the mapping.\n-    Pattern size = Pattern.compile(\"^Size:\\\\s+(\\\\d+)\\\\skB\");\n-    if ((line = reader.readLine()) != null) {\n-      Matcher matcher = size.matcher(line);\n-      \/\/ Found the heap based on its size.\n-      if (matcher.matches() &&\n-          Integer.valueOf(line.substring(matcher.start(1), matcher.end(1))) >= 1 * 1024 * 1024) {\n-        Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n-        while ((line = reader.readLine()) != null) {\n-          matcher = thpUsage.matcher(line);\n-          if (matcher.matches()) {\n-            if (Integer.valueOf(line.substring(matcher.start(1), matcher.end(1))) == 0) {\n-              \/\/ Trigger failure when the usage is 0. This does not cover\n-              \/\/ all cases considered to be failures, but we can just say\n-              \/\/ the non-usage of THP failes for sure.\n-              throw new RuntimeException(\"The usage of THP should not be zero.\");\n-            }\n-            break;\n-          }\n-        }\n-        return true;\n-      }\n+  private static final String[] fixedCmdLine = {\n+    \"-XX:+UseTransparentHugePages\", \"-XX:+AlwaysPreTouch\",\n+    \"-Xlog:startuptime,pagesize,gc+heap=debug\",\n+    \"-XX:+UseParallelGC\", \"-Xms1G\", \"-Xmx1G\",\n+  };\n+\n+  public static void main(String[] args) throws Exception {\n+    ArrayList<String> cmdLine = new ArrayList<>(Arrays.asList(fixedCmdLine));\n+    if (args.length > 0) {\n+      cmdLine.add(\"-XX:ParallelGCThreads=\" + args[0]);\n@@ -74,1 +61,3 @@\n-    return false;\n+    cmdLine.add(\"runtime.os.TestTransparentHugePageUsage$CatSmaps\");\n+    ProcessBuilder builder = ProcessTools.createTestJvm(cmdLine);\n+    checkUsage(new BufferedReader(new InputStreamReader(builder.start().getInputStream())));\n@@ -77,2 +66,2 @@\n-  public static void main(String[] args) throws Exception {\n-    HotSpotDiagnosticMXBean mxBean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+  private static void checkUsage(BufferedReader reader) throws Exception {\n+    final Pattern useThp = Pattern.compile(\".*\\\\[info\\\\]\\\\[pagesize\\\\].+UseTransparentHugePages=1.*\");\n@@ -80,2 +69,8 @@\n-    if (mxBean.getVMOption(\"UseTransparentHugePages\").getValue() == \"true\") {\n-      BufferedReader reader = new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"));\n+    if (reader.lines().filter(line -> useThp.matcher(line).matches()).findFirst().isPresent()) {\n+      final Pattern heapAddr = Pattern.compile(\".*\\\\sHeap:\\\\s.+base=0x0*(\\\\p{XDigit}+).*\");\n+      final Optional<Long> addr = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, heapAddr.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1)), 16));\n+      if (!addr.isPresent()) throw new RuntimeException(\"Heap base was not found in smaps.\");\n@@ -84,7 +79,27 @@\n-      Pattern mapping = Pattern.compile(\"^\\\\p{XDigit}+-\\\\p{XDigit}+.*\");\n-      String line = null;\n-      while ((line = reader.readLine()) != null) {\n-        if (mapping.matcher(line).matches()) {\n-          if (foundHeapFrom(reader)) break;\n-        }\n-      }\n+      final Pattern mapping = Pattern.compile(\"^(\\\\p{XDigit}+)-\\\\p{XDigit}+.*\");\n+      reader.lines()\n+            .filter(line -> {\n+                  Matcher matcher = mapping.matcher(line);\n+                  if (matcher.matches()) {\n+                    Long mappingAddr = Long.valueOf(line.substring(matcher.start(1), matcher.end(1)), 16);\n+                    if (mappingAddr.equals(addr.get())) return true;\n+                  }\n+                  return false;\n+                })\n+            .findFirst();\n+      final Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n+      final Optional<Long> usage = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, thpUsage.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1))));\n+      if (!usage.isPresent()) throw new RuntimeException(\"The usage of THP was not found.\");\n+      if (usage.get() == 0) throw new RuntimeException(\"The usage of THP should not be zero.\");\n+    }\n+  }\n+\n+  public static class CatSmaps {\n+    public static void main(String[] args) throws Exception {\n+      new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"))\n+          .lines()\n+          .forEach(line -> System.out.println(line));\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTransparentHugePageUsage.java","additions":59,"deletions":44,"binary":false,"changes":103,"status":"modified"}]}