{"files":[{"patch":"@@ -1896,0 +1896,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1614,0 +1614,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2836,0 +2836,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2888,0 +2897,24 @@\n+  }\n+}\n+\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    if (::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      int err = errno;\n+      if (err == EINVAL) { \/\/ Not supported\n+        \/\/ When using THP we need to always pre-touch using small pages as the\n+        \/\/ OS will initially always use small pages.\n+        pretouch_memory_common(first, last, os::vm_page_size());\n+      } else {\n+        log_warning(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT\n+                            \", %d) failed; error='%s' (errno=%d)\",\n+                            p2i(first), len, MADV_POPULATE_WRITE,\n+                            os::strerror(err), err);\n+      }\n+    }\n+  } else {\n+    pretouch_memory_common(first, last, page_size);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3823,0 +3823,5 @@\n+\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2108,1 +2108,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -2110,1 +2110,1 @@\n-    assert(cur <= last, \"invariant\");\n+    assert(first <= last, \"invariant\");\n@@ -2113,4 +2113,11 @@\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n-    }\n+    pd_pretouch_memory(first, last, page_size);\n+  }\n+}\n+\n+void os::pretouch_memory_common(void* first, void* last, size_t page_size) {\n+  assert(is_aligned(first, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(first), page_size);\n+  assert(is_aligned(last, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(last), page_size);\n+  assert(first <= last, \"invalid range: \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(first), p2i(last));\n+  for (char* cur = static_cast<char*>(first); \/* break *\/; cur += page_size) {\n+    Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+    if (cur >= last) break;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -226,0 +226,6 @@\n+  static void   pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n+  \/\/ Some platforms may have special treatment for pretouch, while most\n+  \/\/ platforms do the same thing. So the common part of the code was extracted\n+  \/\/ here to avoid copying it around.\n+  static void   pretouch_memory_common(void* first, void* last, size_t page_size);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) Ampere Computing and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestParallelAlwaysPreTouch\n+ * @bug 8315923\n+ * @requires vm.gc.Parallel & os.family == \"linux\" & os.maxMemory > 30G\n+ * @summary Check if parallel pretouch performs normally with and without THP.\n+ * @comment The test is not ParallelGC-specific, but a multi-threaded GC is\n+ *          required. So ParallelGC is used here.\n+ *\n+ * @run main\/othervm -XX:-UseTransparentHugePages\n+ *                   -XX:+UseParallelGC -XX:ParallelGCThreads=${os.processors}\n+ *                   -Xlog:startuptime,pagesize,gc+heap=debug\n+ *                   -Xms24G -Xmx24G -XX:+AlwaysPreTouch\n+ *                   gc.parallel.TestParallelAlwaysPreTouch\n+ *\n+ * @run main\/othervm -XX:+UseTransparentHugePages\n+ *                   -XX:+UseParallelGC -XX:ParallelGCThreads=${os.processors}\n+ *                   -Xlog:startuptime,pagesize,gc+heap=debug\n+ *                   -Xms24G -Xmx24G -XX:+AlwaysPreTouch\n+ *                   gc.parallel.TestParallelAlwaysPreTouch\n+ *\/\n+\n+package gc.parallel;\n+\n+public class TestParallelAlwaysPreTouch {\n+  public static void main(String[] args) throws Exception {\n+    \/\/ everything should happen before entry point\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestParallelAlwaysPreTouch.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}