{"files":[{"patch":"@@ -1724,0 +1724,8 @@\n+    if (in(0)->is_BaseCountedLoopEnd()) {\n+      Node* head = unique_ctrl_out();\n+      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+        Node* new_head = new LoopNode(head->in(LoopNode::EntryControl), this);\n+        phase->is_IterGVN()->register_new_node_with_optimizer(new_head);\n+        phase->is_IterGVN()->replace_node(head, new_head);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275854\n+ * @summary Crashes in PhaseIdealLoop::transform_long_counted_loop\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main TestLoopEndNodeEliminate\n+ *\n+ *\/\n+\n+public class TestLoopEndNodeEliminate {\n+    public volatile boolean bFld=true;\n+    public double dFld=1.20070;\n+    public volatile byte byFld=0;\n+    public volatile short sArrFld[]=new short[N];\n+    public int iArrFld[]=new int[N];\n+    public volatile byte byArrFld[]=new byte[N];\n+    public boolean bArrFld[]=new boolean[N];\n+\n+    public static int iFld=10;\n+    public static final int N = 400;\n+    public static long instanceCount=0L;\n+    public static long vSmallMeth_check_sum = 0;\n+    public static long bMeth_check_sum = 0;\n+    public static long lMeth_check_sum = 0;\n+    public static long bMeth1_check_sum = 0;\n+\n+    public static int[] int1array(int sz, int seed) {\n+        int[] ret = new int[sz];\n+\n+        init(ret, seed);\n+        return ret;\n+    }\n+\n+    public static byte[] byte1array(int sz, byte seed) {\n+        byte[] ret = new byte[sz];\n+\n+        init(ret, seed);\n+        return ret;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void init(byte[] a, byte seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (byte) ((j % 2 == 0) ? seed + j : seed - j);\n+        }\n+    }\n+\n+    public static long checkSum(int[] a) {\n+        long sum = 0;\n+\n+        for (int j = 0; j < a.length; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+        return sum;\n+    }\n+\n+    public static void vSmallMeth(boolean b, int i12) {\n+        int iArr[]=new int[N];\n+\n+        init(iArr, -115);\n+        iArr = int1array(N, (int)10852);\n+        iArr = (iArr = iArr);\n+        vSmallMeth_check_sum += (b ? 1 : 0) + i12 + checkSum(iArr);\n+    }\n+\n+    public long lMeth() {\n+        long l1=-33582180L;\n+        int i14=-5, i15=-14, i16=0, i17=25699, i18=97, i19=-3, i20=0, i21=0, i22=42, i23=0, i24=25699, i25=97;\n+\n+        for (l1 = 286; l1 > 16; l1 -= 3) {\n+            for (i15 = 17; i15 > l1; --i15) {\n+                switch (((iArrFld[i15] >>> 1) % 7) + 101) {\n+                case 101:\n+                case 102:\n+                case 103:\n+                case 104:\n+                    for (i17 = (int)(l1); i17 < 1; i17++) {\n+                        bArrFld[i17] = bFld;\n+                    }\n+                    break;\n+                case 105:\n+                case 106:\n+                case 107:\n+                }\n+            }\n+            for (i19 = 1; i19 < 27; ++i19) {\n+                TestLoopEndNodeEliminate.iFld += byFld;\n+                i21 = 1;\n+                while (++i21 < 2) {\n+                    bFld = true;\n+                }\n+                for (i22 = 1; 2 > i22; ++i22) {\n+                    bFld = true;\n+                }\n+                for (i24 = 1; 2 > i24; ++i24) {\n+                    bFld = true;\n+                }\n+                bArrFld[(int)(l1)] = bFld;\n+                sArrFld[i19 - 1] ^= (short)(++TestLoopEndNodeEliminate.instanceCount);\n+            }\n+        }\n+        long meth_res = l1 + i14 + i15 + i16 + i17 + i18 + i19 + i20 + i21 + i22 + i23 + i24 + i25;\n+        lMeth_check_sum += meth_res;\n+        return (long)meth_res;\n+    }\n+\n+    public static boolean bMeth1() {\n+        int i26=0, i27=42, i28=0, i29=25699;\n+\n+        for (i26 = 1; 151 > i26; ++i26) {\n+            for (i28 = i26; i28 < 11; i28++) {\n+                TestLoopEndNodeEliminate.instanceCount = TestLoopEndNodeEliminate.iFld;\n+            }\n+        }\n+        long meth_res = i26 + i27 + i28 + i29;\n+        bMeth1_check_sum += meth_res;\n+        return meth_res % 2 > 0;\n+    }\n+\n+    public boolean bMeth(int i13) {\n+        long l2=-12L;\n+        int i30=-108, i31=0, i32=42, i33=0, i34=25699, i35=97, i36=-3, i37=0;\n+\n+        iArrFld = (iArrFld = (iArrFld = iArrFld));\n+        dFld = Math.min(lMeth(), TestLoopEndNodeEliminate.instanceCount);\n+        bArrFld[(i13 >>> 1) % N] = bMeth1();\n+        iArrFld = (iArrFld = (iArrFld = iArrFld));\n+        dFld = Math.min(lMeth(), -5L);\n+        for (l2 = 286; l2 > 16; l2 -= 3) {\n+            for (i31 = 17; i31 > l2; --i31) {\n+                switch (((iArrFld[i31] >>> 1) % 7) + 101) {\n+                case 101:\n+                case 102:\n+                case 103:\n+                case 104:\n+                    for (i33 = (int)(l2); i33 < 1; ++i33) {\n+                        bArrFld[i33] = bFld;\n+                    }\n+                    break;\n+                case 105:\n+                case 106:\n+                case 107:\n+                }\n+            }\n+            for (i35 = 1; i35 < 17; ++i35) {\n+                TestLoopEndNodeEliminate.iFld += byFld;\n+                i37 = 1;\n+                while (++i37 < 2) {\n+                    bFld = true;\n+                }\n+                bArrFld[(int)(l2)] = bFld;\n+            }\n+        }\n+        long meth_res = i13 + l2 + i30 + i31 + i32 + i33 + i34 + i35 + i36 + i37;\n+        bMeth_check_sum += meth_res;\n+        return meth_res % 2 > 0;\n+    }\n+\n+    public void mainTest(String[] strArr1) {\n+        long l=12L, l3=-512L;\n+        int i11=0, i38=25699, i39=97, i40=-3, i41=0, i42=0, i43=42, i44=0, i45=25699, i46=97, i47=-3, i48=42, i49=0,\n+            i50=25699, i51=97, i52=-3;\n+\n+        bFld = (-97 == TestLoopEndNodeEliminate.iFld);\n+        for (l = 286; l > 16; l -= 3) {\n+            for (int smallinvoc=0; smallinvoc<62; smallinvoc++) {\n+                vSmallMeth(bMeth(TestLoopEndNodeEliminate.iFld), TestLoopEndNodeEliminate.iFld);\n+            }\n+            for (i38 = 10; 278 > i38; ++i38) {\n+                bFld = true;\n+            }\n+            for (i40 = 1; 278 > i40; ++i40) {\n+                bFld = true;\n+            }\n+            for (i42 = 1; 278 > i42; ++i42) {\n+                bFld = true;\n+            }\n+            for (i44 = 1; 278 > i44; ++i44) {\n+                bFld = true;\n+            }\n+            for (i46 = 1; 278 > i46; i46++) {\n+                bFld = true;\n+            }\n+        }\n+        dFld = Math.min(lMeth(), -5L);\n+        for (l3 = 286; l3 > 16; l3 -= 3) {\n+            for (i49 = 10; 278 > i49; i49++) {\n+                bFld = true;\n+            }\n+            for (i51 = 1; 278 > i51; ++i51) {\n+                bFld = true;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            TestLoopEndNodeEliminate _instance = new TestLoopEndNodeEliminate();\n+            for (int i = 0; i < 10; i++ ) {\n+                _instance.mainTest(strArr);\n+            }\n+         } catch (Exception ex) {\n+            System.out.println(ex.getClass().getCanonicalName());\n+         }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopEndNodeEliminate.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"}]}