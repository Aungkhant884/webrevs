{"files":[{"patch":"@@ -1724,0 +1724,10 @@\n+    if (in(0)->is_BaseCountedLoopEnd()) {\n+      \/\/ CountedLoopEndNode may be eliminated by if subsuming, replace CountedLoopNode with LoopNode to\n+      \/\/ avoid mismatching between CountedLoopNode and CountedLoopEndNode in the following optimization.\n+      Node* head = unique_ctrl_out();\n+      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+        Node* new_head = new LoopNode(head->in(LoopNode::EntryControl), this);\n+        phase->is_IterGVN()->register_new_node_with_optimizer(new_head);\n+        phase->is_IterGVN()->replace_node(head, new_head);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275854\n+ * @summary Crashes in PhaseIdealLoop::transform_long_counted_loop\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,TestLoopEndNodeEliminate::lMeth TestLoopEndNodeEliminate\n+ *\n+ *\/\n+\n+public class TestLoopEndNodeEliminate {\n+     public volatile boolean bFld=true;\n+     public volatile byte byFld=0;\n+     public volatile short sArrFld[]=new short[N];\n+     public int iArrFld[]=new int[N];\n+     public boolean bArrFld[]=new boolean[N];\n+\n+     public static int iFld=10;\n+     public static final int N = 400;\n+     public static long instanceCount=0L;\n+     public static long lMeth_check_sum = 0;\n+\n+     public long lMeth() {\n+         long l1=-33582180L;\n+         int i14=-5, i15=-14, i16=0, i17=25699, i18=97, i19=-3, i20=0, i21=0, i22=42, i23=0, i24=25699, i25=97;\n+\n+         for (l1 = 286; l1 > 16; l1 -= 3) {\n+             for (i15 = 17; i15 > l1; --i15) {\n+                 switch (((iArrFld[i15] >>> 1) % 7) + 101) {\n+                 case 101:\n+                 case 102:\n+                 case 103:\n+                 case 104:\n+                     for (i17 = (int)(l1); i17 < 1; i17++) {\n+                         bArrFld[i17] = bFld;\n+                     }\n+                     break;\n+                 case 105:\n+                 case 106:\n+                 case 107:\n+                 }\n+             }\n+             for (i19 = 1; i19 < 270; ++i19) {\n+                 TestLoopEndNodeEliminate.iFld += byFld;\n+                 i21 = 1;\n+                 while (++i21 < 2) {\n+                     bFld = true;\n+                 }\n+                 for (i22 = 1; 2 > i22; ++i22) {\n+                     bFld = true;\n+                 }\n+                 for (i24 = 1; 2 > i24; ++i24) {\n+                     bFld = true;\n+                 }\n+                 bArrFld[(int)(l1) % N] = bFld;\n+                 sArrFld[i19 - 1] ^= (short)(++TestLoopEndNodeEliminate.instanceCount);\n+             }\n+         }\n+         long meth_res = l1 + i14 + i15 + i16 + i17 + i18 + i19 + i20 + i21 + i22 + i23 + i24 + i25;\n+         lMeth_check_sum += meth_res;\n+         return (long)meth_res;\n+     }\n+\n+     public static void main(String[] strArr) {\n+        TestLoopEndNodeEliminate _instance = new TestLoopEndNodeEliminate();\n+        for (int i = 0; i < 10000; i++ ) {\n+            _instance.lMeth();\n+        }\n+     }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopEndNodeEliminate.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}