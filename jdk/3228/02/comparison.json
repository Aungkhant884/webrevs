{"files":[{"patch":"@@ -2395,0 +2395,1 @@\n+  INSN(uqsubv, 1, 0b001011, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2409,0 +2410,1 @@\n+  INSN(cmhi,   1, 0b001101, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2430,0 +2432,1 @@\n+  INSN(umaxv,  1, 0b110000101010, 1); \/\/ accepted arrangements: T8B, T16B, T4H, T8H,      T4S\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5576,0 +5576,301 @@\n+  void generate_base64_decode_simdround(Register src, Register dst,\n+        FloatRegister codecL, FloatRegister codecH, int size, Label& Exit) {\n+\n+    FloatRegister in0  = v16, in1  = v17,  in2 = v18,  in3 = v19;\n+    FloatRegister out0 = v20, out1 = v21, out2 = v22;\n+\n+    FloatRegister decL0 = v23, decL1 = v24, decL2 = v25, decL3 = v26;\n+    FloatRegister decH0 = v28, decH1 = v29, decH2 = v30, decH3 = v31;\n+\n+    Label NoIllegalData, ErrorInLowerHalf, StoreLegalData;\n+\n+    Assembler::SIMD_Arrangement arrangement = size == 16 ? __ T16B : __ T8B;\n+\n+    __ ld4(in0, in1, in2, in3, arrangement, __ post(src, 4 * size));\n+\n+    \/\/ we need unsigned saturating substract, to make sure all input values\n+    \/\/ in range [0, 63] will have 0U value in the higher half lookup\n+    __ uqsubv(decH0, __ T16B, in0, v27);\n+    __ uqsubv(decH1, __ T16B, in1, v27);\n+    __ uqsubv(decH2, __ T16B, in2, v27);\n+    __ uqsubv(decH3, __ T16B, in3, v27);\n+\n+    \/\/ lower half lookup\n+    __ tbl(decL0, arrangement, codecL, 4, in0);\n+    __ tbl(decL1, arrangement, codecL, 4, in1);\n+    __ tbl(decL2, arrangement, codecL, 4, in2);\n+    __ tbl(decL3, arrangement, codecL, 4, in3);\n+\n+    \/\/ higher half lookup\n+    __ tbx(decH0, arrangement, codecH, 4, decH0);\n+    __ tbx(decH1, arrangement, codecH, 4, decH1);\n+    __ tbx(decH2, arrangement, codecH, 4, decH2);\n+    __ tbx(decH3, arrangement, codecH, 4, decH3);\n+\n+    \/\/ combine lower and higher\n+    __ orr(decL0, arrangement, decL0, decH0);\n+    __ orr(decL1, arrangement, decL1, decH1);\n+    __ orr(decL2, arrangement, decL2, decH2);\n+    __ orr(decL3, arrangement, decL3, decH3);\n+\n+    \/\/ check illegal inputs, value larger than 63 (maximum of 6 bits)\n+    __ cmhi(decH0, arrangement, decL0, v27);\n+    __ cmhi(decH1, arrangement, decL1, v27);\n+    __ cmhi(decH2, arrangement, decL2, v27);\n+    __ cmhi(decH3, arrangement, decL3, v27);\n+    __ orr(in0, arrangement, decH0, decH1);\n+    __ orr(in1, arrangement, decH2, decH3);\n+    __ orr(in2, arrangement, in0,   in1);\n+    __ umaxv(in3, arrangement, in2);\n+    __ umov(rscratch2, in3, __ B, 0);\n+\n+    \/\/ get the data to output\n+    __ shl(out0,  arrangement, decL0, 2);\n+    __ ushr(out1, arrangement, decL1, 4);\n+    __ orr(out0,  arrangement, out0,  out1);\n+    __ shl(out1,  arrangement, decL1, 4);\n+    __ ushr(out2, arrangement, decL2, 2);\n+    __ orr(out1,  arrangement, out1,  out2);\n+    __ shl(out2,  arrangement, decL2, 6);\n+    __ orr(out2,  arrangement, out2,  decL3);\n+\n+    __ cbz(rscratch2, NoIllegalData);\n+\n+    \/\/ handle illegal input\n+    __ umov(r10, in2, __ D, 0);\n+    if (size == 16) {\n+      __ cbnz(r10, ErrorInLowerHalf);\n+\n+      \/\/ illegal input is in higher half, store the lower half now.\n+      __ st3(out0, out1, out2, __ T8B, __ post(dst, 24));\n+\n+      __ umov(r10, in2,  __ D, 1);\n+      __ umov(r11, out0, __ D, 1);\n+      __ umov(r12, out1, __ D, 1);\n+      __ umov(r13, out2, __ D, 1);\n+      __ b(StoreLegalData);\n+\n+      __ BIND(ErrorInLowerHalf);\n+    }\n+    __ umov(r11, out0, __ D, 0);\n+    __ umov(r12, out1, __ D, 0);\n+    __ umov(r13, out2, __ D, 0);\n+\n+    __ BIND(StoreLegalData);\n+    __ tbnz(r10, 5, Exit); \/\/ 0xff indicates illegal input\n+    __ strb(r11, __ post(dst, 1));\n+    __ strb(r12, __ post(dst, 1));\n+    __ strb(r13, __ post(dst, 1));\n+    __ lsr(r10, r10, 8);\n+    __ lsr(r11, r11, 8);\n+    __ lsr(r12, r12, 8);\n+    __ lsr(r13, r13, 8);\n+    __ b(StoreLegalData);\n+\n+    __ BIND(NoIllegalData);\n+    __ st3(out0, out1, out2, arrangement, __ post(dst, 3 * size));\n+  }\n+\n+\n+   \/**\n+   *  Arguments:\n+   *\n+   *  Input:\n+   *  c_rarg0   - src_start\n+   *  c_rarg1   - src_offset\n+   *  c_rarg2   - src_length\n+   *  c_rarg3   - dest_start\n+   *  c_rarg4   - dest_offset\n+   *  c_rarg5   - isURL\n+   *\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    \/\/ The SIMD part of this Base64 decode intrinsic is based on the algorithm outlined\n+    \/\/ on http:\/\/0x80.pl\/articles\/base64-simd-neon.html#encoding-quadwords, in section\n+    \/\/ titled \"Base64 decoding\".\n+\n+    \/\/ Non-SIMD lookup tables are mostly dumped from fromBase64 array used in java.util.Base64,\n+    \/\/ except the trailing character '=' is also treated illegal value in this instrinsic. That\n+    \/\/ is java.util.Base64.fromBase64['='] = -2, while fromBase(URL)64ForNoSIMD['='] = 255 here.\n+    static const uint8_t fromBase64ForNoSIMD[256] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URLForNoSIMD[256] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    \/\/ A legal value of base64 code is in range [0, 127].  We need two lookups\n+    \/\/ with tbl\/tbx and combine them to get the decode data. The 1st table vector\n+    \/\/ lookup use tbl, out of range indices are set to 0 in destination. The 2nd\n+    \/\/ table vector lookup use tbx, out of range indices are unchanged in\n+    \/\/ destination. Input [64..126] is mapped to index [65, 127] in second lookup.\n+    \/\/ The value of index 64 is set to 0, so that we know that we already get the\n+    \/\/ decoded data with the 1st lookup.\n+    static const uint8_t fromBase64ForSIMD[128] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+      255u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URLForSIMD[128] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+       63u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+\n+    Register src   = c_rarg0;  \/\/ source array\n+    Register soff  = c_rarg1;  \/\/ source start offset\n+    Register send  = c_rarg2;  \/\/ source end offset\n+    Register dst   = c_rarg3;  \/\/ dest array\n+    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+\n+    Register length = send;    \/\/ reuse send as length of source data to process\n+\n+    Register simd_codec   = c_rarg6;\n+    Register nosimd_codec = c_rarg7;\n+\n+    Label ProcessData, Process64B, Process32B, Process4B, SIMDEnter, SIMDExit, Exit;\n+\n+    __ enter();\n+\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+\n+    __ mov(doff, dst);\n+\n+    __ sub(length, send, soff);\n+    __ bfm(length, zr, 0, 1);\n+\n+    __ lea(nosimd_codec, ExternalAddress((address) fromBase64ForNoSIMD));\n+    __ cbz(isURL, ProcessData);\n+    __ lea(nosimd_codec, ExternalAddress((address) fromBase64URLForNoSIMD));\n+\n+    __ BIND(ProcessData);\n+    __ mov(rscratch1, length);\n+    __ cmp(length, (u1)144); \/\/ 144 = 80 + 64\n+    __ br(Assembler::LT, Process4B);\n+\n+    \/\/ The 1st character of the input can be illegal if the data is MIME encoded.\n+    \/\/ We cannot benefits from SIMD for this case. The max line size of MIME\n+    \/\/ encoding is 76, with the PreProcess80B blob, we actually use no-simd\n+    \/\/ instructions for all MIME encoded data.\n+    __ movw(rscratch1, 79);\n+\n+    __ BIND(Process4B);\n+    __ ldrb(r10, __ post(src, 1));\n+    __ ldrb(r11, __ post(src, 1));\n+    __ ldrb(r12, __ post(src, 1));\n+    __ ldrb(r13, __ post(src, 1));\n+    \/\/ get the de-code\n+    __ ldrb(r10, Address(nosimd_codec, r10, Address::uxtw(0)));\n+    __ ldrb(r11, Address(nosimd_codec, r11, Address::uxtw(0)));\n+    __ ldrb(r12, Address(nosimd_codec, r12, Address::uxtw(0)));\n+    __ ldrb(r13, Address(nosimd_codec, r13, Address::uxtw(0)));\n+    \/\/ error detection, 255u indicates an illegal input\n+    __ orrw(r14, r10, r11);\n+    __ orrw(r15, r12, r13);\n+    __ orrw(r14, r14, r15);\n+    __ tbnz(r14, 7, Exit);\n+    \/\/ recover the data\n+    __ lslw(r14, r10, 2);\n+    __ bfmw(r14, r11, 4, 5);\n+    __ lslw(r15, r11, 4);\n+    __ bfmw(r15, r12, 2, 5);\n+    __ orrw(r13, r13, r12, Assembler::LSL, 6);\n+    __ strb(r14, __ post(dst, 1));\n+    __ strb(r15, __ post(dst, 1));\n+    __ strb(r13, __ post(dst, 1));\n+    \/\/ non-simd loop\n+    __ subsw(rscratch1, rscratch1, 4);\n+    __ br(Assembler::GT, Process4B);\n+\n+    \/\/ if exiting from PreProcess80B, rscratch1 == -1;\n+    \/\/ otherwise, rscratch1 == 0.\n+    __ cbzw(rscratch1, Exit);\n+    __ sub(length, length, 80);\n+\n+    __ lea(simd_codec, ExternalAddress((address) fromBase64ForSIMD));\n+    __ cbz(isURL, SIMDEnter);\n+    __ lea(simd_codec, ExternalAddress((address) fromBase64URLForSIMD));\n+\n+    __ BIND(SIMDEnter);\n+    __ ld1(v0, v1, v2, v3, __ T16B, __ post(simd_codec, 64));\n+    __ ld1(v4, v5, v6, v7, __ T16B, Address(simd_codec));\n+    __ mov(rscratch1, 63);\n+    __ dup(v27, __ T16B, rscratch1);\n+\n+    __ BIND(Process64B);\n+    __ cmp(length, (u1)64);\n+    __ br(Assembler::LT, Process32B);\n+    generate_base64_decode_simdround(src, dst, v0, v4, 16, Exit);\n+    __ sub(length, length, 64);\n+    __ b(Process64B);\n+\n+    __ BIND(Process32B);\n+    __ cmp(length, (u1)32);\n+    __ br(Assembler::LT, SIMDExit);\n+    generate_base64_decode_simdround(src, dst, v0, v4, 8, Exit);\n+    __ sub(length, length, 32);\n+    __ b(Process32B);\n+\n+    __ BIND(SIMDExit);\n+    __ cbz(length, Exit);\n+    __ movw(rscratch1, length);\n+    __ b(Process4B);\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, doff);\n+\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6818,0 +7119,1 @@\n+        StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":302,"deletions":0,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.micro.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class Base64Decode {\n+\n+    private Base64.Encoder encoder, mimeEncoder;\n+    private Base64.Decoder decoder, mimeDecoder;\n+    private ArrayList<byte[]> encoded, mimeEncoded;\n+    private byte[] decoded, mimeDecoded;\n+\n+    private static final int TESTSIZE = 1000;\n+\n+    @Param({\"1\", \"3\", \"7\", \"32\", \"64\", \"80\", \"96\",\n+            \"112\", \"512\", \"1000\", \"20000\", \"50000\"})\n+    private int maxNumBytes;\n+\n+    @Param({\"4\"})\n+    private int lineSize;\n+\n+    private byte[] lineSeparator = {'\\r', '\\n'};\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        decoded = new byte[maxNumBytes + 1];\n+        encoder = Base64.getEncoder();\n+        decoder = Base64.getDecoder();\n+        encoded = new ArrayList<byte[]> ();\n+\n+        mimeDecoded = new byte[maxNumBytes + 1];\n+        mimeEncoder = Base64.getMimeEncoder(lineSize, lineSeparator);\n+        mimeDecoder = Base64.getMimeDecoder();\n+        mimeEncoded = new ArrayList<byte[]> ();\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int srcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] src = new byte[srcLen];\n+            byte[] dst = new byte[((srcLen + 2) \/ 3) * 4];\n+            r.nextBytes(src);\n+            encoder.encode(src, dst);\n+            encoded.add(dst);\n+\n+            int mimeSrcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] mimeSrc = new byte[mimeSrcLen];\n+            byte[] mimeDst = new byte[((mimeSrcLen + 2) \/ 3) * 4 * (lineSize + lineSeparator.length) \/ lineSize];\n+            r.nextBytes(mimeSrc);\n+            mimeEncoder.encode(mimeSrc, mimeDst);\n+            mimeEncoded.add(mimeDst);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64Decode(Blackhole bh) {\n+        for (byte[] s : encoded) {\n+            decoder.decode(s, decoded);\n+            bh.consume(decoded);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64MIMEDecode(Blackhole bh) {\n+        for (byte[] s : mimeEncoded) {\n+            mimeDecoder.decode(s, mimeDecoded);\n+            bh.consume(mimeDecoded);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}