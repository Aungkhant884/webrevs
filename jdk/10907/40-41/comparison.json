{"files":[{"patch":"@@ -819,3 +819,9 @@\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            UseFastLocking ? obj_reg : lock_reg);\n+    if (UseFastLocking) {\n+      call_VM(noreg,\n+              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n+              obj_reg);\n+    } else {\n+      call_VM(noreg,\n+              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+              lock_reg);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1297,4 +1297,9 @@\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            UseFastLocking ? obj_reg : lock_reg);\n-\n+    if (UseFastLocking) {\n+      call_VM(noreg,\n+              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n+              obj_reg);\n+    } else {\n+      call_VM(noreg,\n+              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+              lock_reg);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -9742,1 +9742,1 @@\n-  movl(tmp, Address(r15_thread, JavaThread::lock_stack_offset_offset()));\n+  movl(tmp, Address(thread, JavaThread::lock_stack_offset_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -737,17 +737,2 @@\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, void* elem))\n-  if (!UseHeavyMonitors && UseFastLocking) {\n-    \/\/ TODO: We accept elem as void* to workaround a limitation of registers in x86_32. Interpreter\n-    \/\/ code is really sending an oopDesc* here.\n-    \/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n-    \/\/ but we are using that register to hold the thread. We don't have enough registers to\n-    \/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n-    \/\/ the object. See also InterpreterMacroAssembler::lock_object().\n-    \/\/ As soon as traditional stack-locking goes away we can change elem to be oopDesc*\n-    \/\/ (also in monitorexit below).\n-    Handle h_obj(current, oop((reinterpret_cast<oopDesc*>(elem))));\n-    assert(Universe::heap()->is_in_or_null(h_obj()),\n-           \"must be null or an object\");\n-    ObjectSynchronizer::enter(h_obj, nullptr, current);\n-    return;\n-  }\n-  BasicObjectLock* lock = reinterpret_cast<BasicObjectLock*>(elem);\n+JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, BasicObjectLock* elem))\n+  assert(!UseFastLocking, \"Should call monitorenter_obj() when using UseFastLocking\");\n@@ -755,1 +740,1 @@\n-  current->last_frame().interpreter_frame_verify_monitor(lock);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -757,1 +742,1 @@\n-  Handle h_obj(current, lock->obj());\n+  Handle h_obj(current, elem->obj());\n@@ -760,2 +745,2 @@\n-  ObjectSynchronizer::enter(h_obj, lock->lock(), current);\n-  assert(Universe::heap()->is_in_or_null(lock->obj()),\n+  ObjectSynchronizer::enter(h_obj, elem->lock(), current);\n+  assert(Universe::heap()->is_in_or_null(elem->obj()),\n@@ -764,1 +749,1 @@\n-  current->last_frame().interpreter_frame_verify_monitor(lock);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -768,0 +753,16 @@\n+\/\/ NOTE: We provide a separate implementation for UseFastLocking to workaround a limitation\n+\/\/ of registers in x86_32. This entry point accepts an oop instead of a BasicObjectLock*.\n+\/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n+\/\/ but we are using that register to hold the thread. We don't have enough registers to\n+\/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n+\/\/ the object. See also InterpreterMacroAssembler::lock_object().\n+\/\/ As soon as traditional stack-locking goes away we could remove the other monitorenter() entry\n+\/\/ point, and only use oop-accepting entries (same for monitorexit() below).\n+JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter_obj(JavaThread* current, oopDesc* obj))\n+  assert(!UseHeavyMonitors && UseFastLocking, \"Should call monitorenter() when not using UseFastLocking\");\n+  Handle h_obj(current, cast_to_oop(obj));\n+  assert(Universe::heap()->is_in_or_null(h_obj()),\n+         \"must be null or an object\");\n+  ObjectSynchronizer::enter(h_obj, nullptr, current);\n+  return;\n+JRT_END\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-  static void    monitorenter(JavaThread* current, void* elem);\n+  static void    monitorenter(JavaThread* current, BasicObjectLock* elem);\n+  static void    monitorenter_obj(JavaThread* current, oopDesc* obj);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}