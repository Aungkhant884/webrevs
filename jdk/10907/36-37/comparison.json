{"files":[{"patch":"@@ -71,1 +71,1 @@\n-  return 20;\n+  return 24;\n@@ -86,0 +86,3 @@\n+#ifdef ASSERT\n+  __ str(zr, Address(rthread, t));\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6277,0 +6277,3 @@\n+#ifdef ASSERT\n+  str(zr, Address(rthread, t1));\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1150,2 +1150,3 @@\n-  static ByteSize lock_stack_offset_offset()    { return byte_offset_of(JavaThread, _lock_stack) + LockStack::offset_offset(); }\n-  static ByteSize lock_stack_base_offset()      { return byte_offset_of(JavaThread, _lock_stack) + LockStack::base_offset(); }\n+  static ByteSize lock_stack_offset()        { return byte_offset_of(JavaThread, _lock_stack); }\n+  static ByteSize lock_stack_offset_offset() { return lock_stack_offset() + LockStack::offset_offset(); }\n+  static ByteSize lock_stack_base_offset()   { return lock_stack_offset() + LockStack::base_offset(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+const size_t LockStack::lock_stack_offset =        in_bytes(JavaThread::lock_stack_offset());\n+const size_t LockStack::lock_stack_offset_offset = in_bytes(JavaThread::lock_stack_offset_offset());\n+const size_t LockStack::lock_stack_base_offset =   in_bytes(JavaThread::lock_stack_base_offset());\n+\n@@ -36,1 +40,2 @@\n-  _offset(in_bytes(JavaThread::lock_stack_base_offset())), _base()\n+  _offset(lock_stack_base_offset), _base()\n+{\n@@ -38,1 +43,3 @@\n-  , _thread(jt)\n+  for (int i = 0; i < CAPACITY; i++) {\n+    _base[i] = nullptr;\n+  }\n@@ -40,1 +47,1 @@\n-{ }\n+}\n@@ -43,1 +50,1 @@\n-  int offset = in_bytes(JavaThread::lock_stack_base_offset());\n+  int offset = lock_stack_base_offset;\n@@ -49,1 +56,1 @@\n-  int offset = in_bytes(JavaThread::lock_stack_base_offset()) + CAPACITY * oopSize;\n+  int offset = lock_stack_base_offset + CAPACITY * oopSize;\n@@ -61,1 +68,2 @@\n-  assert(is_self() || SafepointSynchronize::is_at_safepoint() || _thread->is_handshake_safe_for(Thread::current()) || _thread->is_suspended() || _thread->is_obj_deopt_suspend() || is_stack_watermark_processing(_thread),\n+  JavaThread* thread = get_thread();\n+  assert(is_self() || SafepointSynchronize::is_at_safepoint() || thread->is_handshake_safe_for(Thread::current()) || thread->is_suspended() || thread->is_obj_deopt_suspend() || is_stack_watermark_processing(thread),\n@@ -68,1 +76,1 @@\n-  assert((_offset <=  end_offset()), \"lockstack overflow: _offset %d end_offset %d\", _offset, end_offset());\n+  assert((_offset <  end_offset()), \"lockstack overflow: _offset %d end_offset %d\", _offset, end_offset());\n@@ -70,4 +78,4 @@\n-  int end = to_index(_offset);\n-  for (int i = 0; i < end; i++) {\n-    assert(_base[i] != nullptr, \"no null on lock-stack\");\n-    for (int j = i + 1; j < end; j++) {\n+  int top = to_index(_offset);\n+  for (int i = 0; i < top; i++) {\n+    assert(_base[i] != nullptr, \"no zapped before top\");\n+    for (int j = i + 1; j < top; j++) {\n@@ -77,0 +85,3 @@\n+  for (int i = top; i < CAPACITY; i++) {\n+    assert(_base[i] == nullptr, \"only zapped entries after top: i: %d, top: %d, entry: \" PTR_FORMAT, i, top, p2i(_base[i]));\n+  }\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+\n+  \/\/ TODO: It would be very useful if JavaThread::lock_stack_offset() and friends were constexpr,\n+  \/\/ but this is currently not the case because we're using offset_of() which is non-constexpr,\n+  \/\/ GCC would warn about non-standard-layout types if we were using offsetof() (which *is* constexpr).\n+  static const size_t lock_stack_offset;\n+  static const size_t lock_stack_offset_offset;\n+  static const size_t lock_stack_base_offset;\n+\n@@ -44,3 +52,2 @@\n-#ifdef ASSERT\n-  JavaThread* const _thread;\n-#endif\n+\n+  inline JavaThread* get_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,6 @@\n-  return (offset - in_bytes(JavaThread::lock_stack_base_offset())) \/ oopSize;\n+  return (offset - lock_stack_base_offset) \/ oopSize;\n+}\n+\n+JavaThread* LockStack::get_thread() const {\n+  char* addr = reinterpret_cast<char*>(const_cast<LockStack*>(this));\n+  return reinterpret_cast<JavaThread*>(addr - lock_stack_offset);\n@@ -50,1 +55,1 @@\n-  assert(is_self == (_thread == thread), \"is_self sanity\");\n+  assert(is_self == (get_thread() == thread), \"is_self sanity\");\n@@ -59,0 +64,1 @@\n+  assert(_base[to_index(_offset)] == nullptr, \"expect zapped entry\");\n@@ -69,0 +75,3 @@\n+#ifdef ASSERT\n+  _base[to_index(_offset)] = nullptr;\n+#endif\n@@ -85,0 +94,3 @@\n+#ifdef ASSERT\n+      _base[to_index(_offset)] = nullptr;\n+#endif\n@@ -95,1 +107,1 @@\n-    StackWatermark* watermark = StackWatermarkSet::get(_thread, StackWatermarkKind::gc);\n+    StackWatermark* watermark = StackWatermarkSet::get(get_thread(), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}