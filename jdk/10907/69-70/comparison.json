{"files":[{"patch":"@@ -654,1 +654,2 @@\n-  xorptr(tmpReg, tmpReg);\n+  \/\/ Optimistic form: consider XORL tmpReg,tmpReg\n+  movptr(tmpReg, NULL_WORD);\n@@ -656,1 +657,7 @@\n-  \/\/ Appears unlocked - try to swing _owner from null to current thread.\n+  \/\/ Appears unlocked - try to swing _owner from null to non-null.\n+  \/\/ Ideally, I'd manifest \"Self\" with get_thread and then attempt\n+  \/\/ to CAS the register containing Self into m->Owner.\n+  \/\/ But we don't have enough registers, so instead we can either try to CAS\n+  \/\/ rsp or the address of the box (in scr) into &m->owner.  If the CAS succeeds\n+  \/\/ we later store \"Self\" into m->Owner.  Transiently storing a stack address\n+  \/\/ (rsp or the address of the box) into  m->owner is harmless.\n@@ -659,1 +666,1 @@\n-  cmpxchgptr(thread, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+  cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1984,3 +1984,3 @@\n-          \"0: monitors only, \"                                              \\\n-          \"1: monitors & legacy stack-locking (default), \"                  \\\n-          \"2: monitors & new lightweight locking\")                          \\\n+          \"0: monitors only (LM_MONITOR), \"                                 \\\n+          \"1: monitors & legacy stack-locking (LM_LEGACY, default), \"       \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1156,0 +1156,3 @@\n+  \/\/ Those offsets are used in code generators to access the LockStack that is embedded in this\n+  \/\/ JavaThread structure. Those accesses are relative to the current thread, which\n+  \/\/ is typically in a dedicated register.\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  \/\/ Get the owning thread of this lock-stack.\n@@ -56,1 +57,4 @@\n-  bool is_self() const;\n+  \/\/ Tests if the calling thread is the thread that owns this lock-stack.\n+  bool is_owning_thread() const;\n+\n+  \/\/ Verifies consistency of the lock-stack.\n@@ -59,0 +63,1 @@\n+  \/\/ Given an offset (in bytes) calculate the index into the lock-stack.\n@@ -67,0 +72,1 @@\n+  \/\/ The boundary indicies of the lock-stack.\n@@ -69,0 +75,2 @@\n+\n+  \/\/ Return true if we have room to push onto this lock-stack, false otherwise.\n@@ -70,0 +78,2 @@\n+\n+  \/\/ Pushes an oop on this lock-stack.\n@@ -71,0 +81,2 @@\n+\n+  \/\/ Pops an oop from this lock-stack.\n@@ -72,0 +84,2 @@\n+\n+  \/\/ Removes an oop from an arbitrary location of this lock-stack.\n@@ -74,0 +88,1 @@\n+  \/\/ Tests whether the object is on this lock-stack.\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -49,5 +49,5 @@\n-inline bool LockStack::is_self() const {\n-  Thread* thread = Thread::current();\n-  bool is_self = &JavaThread::cast(thread)->lock_stack() == this;\n-  assert(is_self == (get_thread() == thread), \"is_self sanity\");\n-  return is_self;\n+inline bool LockStack::is_owning_thread() const {\n+  JavaThread* thread = JavaThread::current();\n+  bool is_owning = &JavaThread::cast(thread)->lock_stack() == this;\n+  assert(is_owning == (get_thread() == thread), \"is_owning sanity\");\n+  return is_owning;\n@@ -103,1 +103,1 @@\n-  if (!SafepointSynchronize::is_at_safepoint() && !is_self()) {\n+  if (!SafepointSynchronize::is_at_safepoint() && !is_owning_thread()) {\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}