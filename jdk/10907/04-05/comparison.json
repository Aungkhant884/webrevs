{"files":[{"patch":"@@ -53,1 +53,2 @@\n-\/\/    [ptr             | 00]  locked             ptr points to real header on stack\n+\/\/    [ptr             | 00]  locked             ptr points to real header on stack (stack-locking in use)\n+\/\/    [header          | 00]  locked             locked regular object header (fast-locking in use)\n@@ -55,1 +56,1 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is wapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n@@ -57,1 +58,1 @@\n-\/\/    [0 ............ 0| 00]  inflating          inflation in progress\n+\/\/    [0 ............ 0| 00]  inflating          inflation in progress (stack-locking in use)\n@@ -159,0 +160,1 @@\n+  \/\/ Fast-locking does not use INFLATING.\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-  \/\/ at a safepoint, it must not be zero.\n+  \/\/ at a safepoint, it must not be zero. fast-locking does allow the\n+  \/\/ mark to be zero at a safepoint.\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  \/\/   we achieve this by using the lowest two bits\n+  \/\/   we achieve this by using the lowest two bits.\n@@ -152,1 +152,1 @@\n-  \/\/   and small values encode much better\n+  \/\/   and small values encode much better.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-    \/\/ stack-locked by caller so by definition the implied waitset is empty.\n+    \/\/ fast-locked or stack-locked by caller so by definition the implied waitset is empty.\n@@ -390,9 +390,0 @@\n-    \/\/ This Java Monitor is inflated so obj's header will never be\n-    \/\/ displaced to this thread's BasicLock. Make the displaced header\n-    \/\/ non-null so this BasicLock is not seen as recursive nor as\n-    \/\/ being locked. We do this unconditionally so that this thread's\n-    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-    \/\/ performance reasons, stack walkers generally first check for\n-    \/\/ stack-locking in the object's header, the second check is for\n-    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n@@ -400,0 +391,9 @@\n+      \/\/ This Java Monitor is inflated so obj's header will never be\n+      \/\/ displaced to this thread's BasicLock. Make the displaced header\n+      \/\/ non-null so this BasicLock is not seen as recursive nor as\n+      \/\/ being locked. We do this unconditionally so that this thread's\n+      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+      \/\/ performance reasons, stack walkers generally first check for\n+      \/\/ stack-locking in the object's header, the second check is for\n+      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n@@ -491,0 +491,1 @@\n+      \/\/ fast-locking does not use the 'lock' parameter.\n@@ -537,1 +538,1 @@\n-    guarantee(!obj->mark().has_locker() && !obj->mark().is_fast_locked(), \"must not be stack-locked\");\n+    guarantee(!obj->mark().has_locker() && !obj->mark().is_fast_locked(), \"must not be stack-locked or fast-locked\");\n@@ -557,0 +558,1 @@\n+      \/\/ fast-locking does not use the 'lock' parameter.\n@@ -561,2 +563,4 @@\n-          \/\/ Another thread beat us, it can only have installed an anonymously locked monitor at this point.\n-          \/\/ Fetch that monitor, set owner correctly to this thread, and exit it (allowing waiting threads to enter).\n+          \/\/ Another thread beat us and inflated the monitor, it can only\n+          \/\/ have installed an anonymously locked monitor at this point.\n+          \/\/ Fetch that monitor, set owner correctly to this thread, and\n+          \/\/ exit it (allowing waiting threads to enter).\n@@ -622,1 +626,1 @@\n-    \/\/ It must be us. Pop lock object from lock stack.\n+    \/\/ It must be owned by us. Pop lock object from lock stack.\n@@ -800,0 +804,1 @@\n+    \/\/ fast-locking does not use the markWord::INFLATING() protocol.\n@@ -928,1 +933,1 @@\n-      guarantee(!mark.has_locker(), \"must not be stack locked\");\n+      guarantee(!mark.has_locker(), \"must not be stack-locked\");\n@@ -974,1 +979,1 @@\n-      \/\/ This is a fast lock owned by the calling thread so use the\n+      \/\/ This is a fast-lock owned by the calling thread so use the\n@@ -981,1 +986,1 @@\n-      \/\/ This is a stack lock owned by the calling thread so fetch the\n+      \/\/ This is a stack-lock owned by the calling thread so fetch the\n@@ -992,1 +997,1 @@\n-      \/\/ So we have to inflate the stack lock into an ObjectMonitor\n+      \/\/ So we have to inflate the stack-lock into an ObjectMonitor\n@@ -1045,1 +1050,0 @@\n-  \/\/ Uncontended case, header points to stack\n@@ -1047,0 +1051,1 @@\n+    \/\/ stack-locked case, header points into owner's stack\n@@ -1050,1 +1055,0 @@\n-  \/\/ Fast-locking case.\n@@ -1052,0 +1056,1 @@\n+    \/\/ fast-locking case, see if lock is in current's lock stack\n@@ -1055,1 +1060,0 @@\n-  \/\/ Contended case, header points to ObjectMonitor (tagged pointer)\n@@ -1057,0 +1061,1 @@\n+    \/\/ inflated monitor so header points to ObjectMonitor (tagged pointer).\n@@ -1071,1 +1076,0 @@\n-  \/\/ Uncontended case, header points to stack\n@@ -1073,0 +1077,2 @@\n+    \/\/ stack-locked so header points into owner's stack.\n+    \/\/ owning_thread_from_monitor_owner() may also return null here:\n@@ -1077,0 +1083,2 @@\n+    \/\/ fast-locked so get owner from the object.\n+    \/\/ owning_thread_from_object() may also return null here:\n@@ -1080,1 +1088,0 @@\n-  \/\/ Contended case, header points to ObjectMonitor (tagged pointer)\n@@ -1082,0 +1089,1 @@\n+    \/\/ inflated monitor so header points to ObjectMonitor (tagged pointer).\n@@ -1086,0 +1094,1 @@\n+    \/\/ owning_thread_from_monitor() may also return null here:\n@@ -1089,1 +1098,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1095,1 +1104,1 @@\n-\/\/ ObjectMonitors where owner is set to a stack lock address in thread.\n+\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n@@ -1105,1 +1114,1 @@\n-      \/\/ is set to a stack lock address in the target thread.\n+      \/\/ is set to a stack-lock address in the target thread.\n@@ -1131,1 +1140,1 @@\n-    \/\/ Owner set to a stack lock address in thread should never be seen here:\n+    \/\/ Owner set to a stack-lock address in thread should never be seen here:\n@@ -1276,4 +1285,11 @@\n-    \/\/ *  Inflated     - just return\n-    \/\/ *  Stack-locked - coerce it to inflated\n-    \/\/ *  INFLATING    - busy wait for conversion to complete\n-    \/\/ *  Neutral      - aggressively inflate the object.\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the current thread owns the\n+    \/\/                   object lock, then we make the current thread the\n+    \/\/                   ObjectMonitor owner and remove the lock from the\n+    \/\/                   current thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  stack-locked - Coerce it to inflated from stack-locked.\n+    \/\/ *  INFLATING    - Busy wait for conversion from stack-locked to\n+    \/\/                   inflated.\n+    \/\/ *  neutral      - Aggressively inflate the object.\n@@ -1294,12 +1310,12 @@\n-    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-    \/\/ Some other thread is converting from stack-locked to inflated.\n-    \/\/ Only that thread can complete inflation -- other threads must wait.\n-    \/\/ The INFLATING value is transient.\n-    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-    \/\/ NOTE: We need to check UseFastLocking here, because with fast-locking, the header\n-    \/\/ may legitimately be zero: cleared lock-bits and all upper header bits zero.\n-    \/\/ With fast-locking, the INFLATING protocol is not used.\n-    if (mark == markWord::INFLATING() && !UseFastLocking) {\n-      read_stable_mark(object);\n-      continue;\n+    if (!UseFastLocking) {\n+      \/\/ Fast-locking does not use INFLATING.\n+      \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+      \/\/ Some other thread is converting from stack-locked to inflated.\n+      \/\/ Only that thread can complete inflation -- other threads must wait.\n+      \/\/ The INFLATING value is transient.\n+      \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+      \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+      if (mark == markWord::INFLATING()) {\n+        read_stable_mark(object);\n+        continue;\n+      }\n@@ -1308,2 +1324,9 @@\n-    \/\/ CASE: stack-locked\n-    \/\/ Could be stack-locked either by this thread or by some other thread.\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by current or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ this thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to this thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n@@ -1311,7 +1334,0 @@\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n-    \/\/ to install INFLATING into the mark word.  We originally installed INFLATING,\n-    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n-    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n-    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n-    \/\/ the odds of inflation contention.\n-\n@@ -1348,1 +1364,1 @@\n-          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n+          lsh.print_cr(\"inflate(fast-locked): object=\" INTPTR_FORMAT \", mark=\"\n@@ -1358,1 +1374,1 @@\n-        continue;\n+        continue;  \/\/ Interference -- just retry\n@@ -1362,0 +1378,11 @@\n+    \/\/ CASE: stack-locked\n+    \/\/ Could be stack-locked either by current or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n+    \/\/ to install INFLATING into the mark word.  We originally installed INFLATING,\n+    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n+    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n+    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n+    \/\/ the odds of inflation contention. If we lose the race to set INFLATING,\n+    \/\/ then we just delete the ObjectMonitor and loop around again.\n+    \/\/\n@@ -1363,1 +1390,1 @@\n-      assert(!UseFastLocking, \"can not happen with fast-locking\");\n+      assert(!UseFastLocking, \"cannot happen with fast-locking\");\n@@ -1525,2 +1552,2 @@\n-\/\/ is set to a stack lock address are NOT associated with the JavaThread\n-\/\/ that holds that stack lock. All of the current consumers of\n+\/\/ is set to a stack-lock address are NOT associated with the JavaThread\n+\/\/ that holds that stack-lock. All of the current consumers of\n@@ -1528,1 +1555,1 @@\n-\/\/ those do not have the owner set to a stack lock address.\n+\/\/ those do not have the owner set to a stack-lock address.\n@@ -1545,1 +1572,1 @@\n-      \/\/ not include when owner is set to a stack lock address in thread.\n+      \/\/ not include when owner is set to a stack-lock address in thread.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":86,"deletions":59,"binary":false,"changes":145,"status":"modified"}]}