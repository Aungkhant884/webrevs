{"files":[{"patch":"@@ -3840,4 +3840,1 @@\n-        Label slow;\n-        __ fast_lock(oop, disp_hdr, tmp, rscratch1, slow);\n-\n-        \/\/ Indicate success on completion.\n+        __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n@@ -3846,3 +3843,0 @@\n-        __ bind(slow);\n-        __ tst(oop, oop); \/\/ Force ZF=0 to indicate failure and take slow-path. We know that oop != null.\n-        __ b(no_count);\n@@ -3951,3 +3945,1 @@\n-\n-        \/\/ Indicate success on completion.\n-        __ cmp(oop, oop);\n+        __ cmp(oop, oop);  \/\/ Force ZF=1 to indicate success.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-     orr(hdr, hdr, markWord::unlocked_value);\n+    orr(hdr, hdr, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6215,3 +6215,4 @@\n-\/\/ Attempt to fast-lock an object. Fall-through on success, branch to slow label\n-\/\/ on failure.\n-\/\/ Registers:\n+\/\/ Implements fast-locking.\n+\/\/ Branches to slow upon failure to lock the object, with ZF cleared.\n+\/\/ Falls through upon success with unspecified ZF.\n+\/\/\n@@ -6227,2 +6228,2 @@\n-  cmpw(t1, (unsigned)LockStack::end_offset());\n-  br(Assembler::GE, slow);\n+  cmpw(t1, (unsigned)LockStack::end_offset() - 1);\n+  br(Assembler::GT, slow);\n@@ -6241,0 +6242,5 @@\n+  \/\/ Strictly speaking we should emit an IN_NATIVE store. However, non\n+  \/\/ of the GCs currently need any special treatment, and some currently\n+  \/\/ would not correctly handle IN_NATIVE store and the possibly non-null\n+  \/\/ stale previous value.\n+  \/\/ access_store_at(T_OBJECT, IN_NATIVE, Address(rthread, t1), obj, noreg, noreg, noreg);\n@@ -6246,0 +6252,7 @@\n+\/\/ Implements fast-unlocking.\n+\/\/ Branches to slow upon failure, with ZF cleared.\n+\/\/ Falls through upon success, with unspecified ZF.\n+\/\/\n+\/\/ - obj: the object to be unlocked\n+\/\/ - hdr: the (pre-loaded) header of the object\n+\/\/ - t1, t2: temporary registers\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  _lock_stack() {\n+  _lock_stack(this) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n@@ -33,2 +35,11 @@\n-LockStack::LockStack() :\n-  _offset(in_bytes(JavaThread::lock_stack_base_offset())) {\n+LockStack::LockStack(JavaThread* jt) :\n+  _offset(in_bytes(JavaThread::lock_stack_base_offset())), _base()\n+#ifdef ASSERT\n+  , _thread(jt)\n+#endif\n+{ }\n+\n+uint32_t LockStack::end_offset() {\n+  int offset = in_bytes(JavaThread::lock_stack_base_offset()) + CAPACITY * oopSize;\n+  assert(offset > 0, \"must be positive offset\");\n+  return static_cast<uint32_t>(offset);\n@@ -37,2 +48,3 @@\n-int LockStack::end_offset() {\n-  return in_bytes(JavaThread::lock_stack_base_offset()) + CAPACITY * oopSize;\n+static bool is_stack_watermark_processing(JavaThread* thread) {\n+  StackWatermark* watermark = StackWatermarkSet::get(thread, StackWatermarkKind::gc);\n+  return watermark->processing_started() && !watermark->processing_completed();\n@@ -42,1 +54,3 @@\n-void LockStack::validate(const char* msg) const {\n+void LockStack::verify(const char* msg) const {\n+  assert(is_self() || SafepointSynchronize::is_at_safepoint() || _thread->is_handshake_safe_for(Thread::current()) || _thread->is_suspended() || _thread->is_obj_deopt_suspend() || is_stack_watermark_processing(_thread),\n+         \"access only thread-local, or when target thread safely holds stil\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  int _offset;\n+  uint32_t _offset;\n@@ -44,0 +44,3 @@\n+#ifdef ASSERT\n+  JavaThread* const _thread;\n+#endif\n@@ -45,1 +48,2 @@\n-  void validate(const char* msg) const PRODUCT_RETURN;\n+  bool is_self() const;\n+  void verify(const char* msg) const PRODUCT_RETURN;\n@@ -47,1 +51,1 @@\n-  static inline int to_index(int offset);\n+  static inline int to_index(uint32_t offset);\n@@ -53,1 +57,1 @@\n-  LockStack();\n+  LockStack(JavaThread* jt);\n@@ -55,1 +59,1 @@\n-  static int end_offset();\n+  static uint32_t end_offset();\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/access.hpp\"\n@@ -31,0 +32,3 @@\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n@@ -32,1 +36,1 @@\n-inline int LockStack::to_index(int offset) {\n+inline int LockStack::to_index(uint32_t offset) {\n@@ -40,0 +44,10 @@\n+inline bool LockStack::is_self() const {\n+  Thread* thread = Thread::current();\n+  if (!thread->is_Java_thread()) {\n+    return false;\n+  }\n+  bool is_self = &JavaThread::cast(thread)->lock_stack() == this;\n+  assert(is_self == (_thread == thread), \"is_self sanity\");\n+  return is_self;\n+}\n+\n@@ -41,1 +55,1 @@\n-  validate(\"pre-push\");\n+  verify(\"pre-push\");\n@@ -47,1 +61,1 @@\n-  validate(\"post-push\");\n+  verify(\"post-push\");\n@@ -51,1 +65,1 @@\n-  validate(\"pre-pop\");\n+  verify(\"pre-pop\");\n@@ -56,1 +70,1 @@\n-  validate(\"post-pop\");\n+  verify(\"post-pop\");\n@@ -61,1 +75,1 @@\n-  validate(\"pre-remove\");\n+  verify(\"pre-remove\");\n@@ -75,1 +89,1 @@\n-  validate(\"post-remove\");\n+  verify(\"post-remove\");\n@@ -79,1 +93,5 @@\n-  validate(\"pre-contains\");\n+  verify(\"pre-contains\");\n+  if (!is_self() && !SafepointSynchronize::is_at_safepoint()) {\n+    StackWatermark* watermark = StackWatermarkSet::get(_thread, StackWatermarkKind::gc);\n+    watermark->start_processing();\n+  }\n@@ -82,2 +100,2 @@\n-    if (_base[i] == o) {\n-      validate(\"post-contains\");\n+    if (NativeAccess<>::oop_load(&_base[i]) == o) {\n+      verify(\"post-contains\");\n@@ -87,1 +105,1 @@\n-  validate(\"post-contains\");\n+  verify(\"post-contains\");\n@@ -92,1 +110,1 @@\n-  validate(\"pre-oops-do\");\n+  verify(\"pre-oops-do\");\n@@ -97,1 +115,1 @@\n-  validate(\"post-oops-do\");\n+  verify(\"post-oops-do\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -315,5 +315,12 @@\n-  if ((mark.is_fast_locked() && current->lock_stack().contains(oop(obj))) ||\n-      (mark.has_locker() && current->is_lock_owned((address)mark.locker()))) {\n-    \/\/ Degenerate notify\n-    \/\/ fast-locked or stack-locked by caller so by definition the implied waitset is empty.\n-    return true;\n+  if (UseFastLocking) {\n+    if (mark.is_fast_locked() && current->lock_stack().contains(oop(obj))) {\n+      \/\/ Degenerate notify\n+      \/\/ fast-locked or stack-locked by caller so by definition the implied waitset is empty.\n+      return true;\n+    }\n+  } else {\n+    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+      \/\/ Degenerate notify\n+      \/\/ fast-locked or stack-locked by caller so by definition the implied waitset is empty.\n+      return true;\n+    }\n@@ -935,1 +942,1 @@\n-  return thread->is_Java_thread() ? reinterpret_cast<JavaThread*>(thread)->lock_stack().contains(obj) : false;\n+  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n@@ -1319,1 +1326,1 @@\n-        reinterpret_cast<JavaThread*>(current)->lock_stack().remove(object);\n+        JavaThread::cast(current)->lock_stack().remove(object);\n@@ -1367,1 +1374,1 @@\n-          reinterpret_cast<JavaThread*>(current)->lock_stack().remove(object);\n+          JavaThread::cast(current)->lock_stack().remove(object);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1423,0 +1423,1 @@\n+  assert(SafepointSynchronize::is_at_safepoint(), \"not safe outside of safepoint\");\n@@ -1433,1 +1434,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"not safe outside of safepoint\");\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -703,1 +703,1 @@\n-  nonstatic_field(LockStack,                   _offset,                                       int)                                   \\\n+  nonstatic_field(LockStack,                   _offset,                                       uint32_t)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1124,1 +1124,1 @@\n-  if (!UseFastLocking && maxDepth == 0) {\n+  if (maxDepth == 0) {\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}