{"files":[{"patch":"@@ -3842,35 +3842,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-        __ b(count);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-        __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-        \/\/ Initialize the box. (Must happen before we update the object mark!)\n-        __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-        \/\/ Compare object markWord with an unlocked value (tmp) and if\n-        \/\/ equal exchange the stack address of our box with object markWord.\n-        \/\/ On failure disp_hdr contains the possibly locked markWord.\n-        __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                   \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-        __ br(Assembler::EQ, cont);\n-\n-        assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-        \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-        \/\/ object, will have now locked it will continue at label cont\n-\n-        \/\/ Check if the owner is self by comparing the value in the\n-        \/\/ markWord of object (disp_hdr) with the stack pointer.\n-        __ mov(rscratch1, sp);\n-        __ sub(disp_hdr, disp_hdr, rscratch1);\n-        __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-        \/\/ If condition is true we are cont and hence we can store 0 as the\n-        \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-        __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-        __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-        __ b(cont);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -3879,0 +3845,33 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+      \/\/ Initialize the box. (Must happen before we update the object mark!)\n+      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+      \/\/ Compare object markWord with an unlocked value (tmp) and if\n+      \/\/ equal exchange the stack address of our box with object markWord.\n+      \/\/ On failure disp_hdr contains the possibly locked markWord.\n+      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+      __ br(Assembler::EQ, cont);\n+\n+      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object, will have now locked it will continue at label cont\n+\n+      \/\/ Check if the owner is self by comparing the value in the\n+      \/\/ markWord of object (disp_hdr) with the stack pointer.\n+      __ mov(rscratch1, sp);\n+      __ sub(disp_hdr, disp_hdr, rscratch1);\n+      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+      \/\/ If condition is true we are cont and hence we can store 0 as the\n+      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+      __ b(cont);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n+      __ b(count);\n@@ -3892,1 +3891,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -3932,1 +3931,1 @@\n-    if (LockingMode == LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -3945,14 +3944,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n-        __ b(count);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Check if it is still a light weight lock, this is is true if we\n-        \/\/ see the stack address of the basicLock in the markWord of the\n-        \/\/ object.\n-\n-        __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                   \/*release*\/ true, \/*weak*\/ false, tmp);\n-        __ b(cont);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -3961,0 +3947,12 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Check if it is still a light weight lock, this is is true if we\n+      \/\/ see the stack address of the basicLock in the markWord of the\n+      \/\/ object.\n+\n+      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+                 \/*release*\/ true, \/*weak*\/ false, tmp);\n+      __ b(cont);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n+      __ b(count);\n@@ -3970,1 +3968,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":50,"deletions":52,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    if (UseHeavyMonitors) {\n+    if (LockingMode == LM_MONITOR) {\n@@ -2561,1 +2561,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -87,1 +87,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -134,1 +134,1 @@\n-  if (LockingMode != LIGHTWEIGHT) {\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -146,1 +146,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -153,1 +153,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -733,1 +733,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -761,1 +761,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -765,1 +765,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -819,1 +819,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -853,1 +853,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -864,1 +864,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -876,1 +876,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -897,1 +897,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6223,1 +6223,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6255,1 +6255,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1781,35 +1781,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ ldr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Load (object->mark() | 1) into swap_reg %r0\n-        __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ orr(swap_reg, rscratch1, 1);\n-\n-        \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-        __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-        \/\/ src -> dest iff dest == r0 else r0 <- dest\n-        __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n-\n-        \/\/ Hmm should this move to the slow path code area???\n-\n-        \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-        \/\/  1) (mark & 3) == 0, and\n-        \/\/  2) sp <= mark < mark + os::pagesize()\n-        \/\/ These 3 tests can be done by evaluating the following\n-        \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-        \/\/ assuming both stack pointer and pagesize have their\n-        \/\/ least significant 2 bits clear.\n-        \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n-\n-        __ sub(swap_reg, sp, swap_reg);\n-        __ neg(swap_reg, swap_reg);\n-        __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n-\n-        \/\/ Save the test result, for recursive case, the result is zero\n-        __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-        __ br(Assembler::NE, slow_path_lock);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -1817,0 +1783,33 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Load (object->mark() | 1) into swap_reg %r0\n+      __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ orr(swap_reg, rscratch1, 1);\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n+\n+      \/\/ src -> dest iff dest == r0 else r0 <- dest\n+      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n+\n+      \/\/ Hmm should this move to the slow path code area???\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) sp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n+\n+      __ sub(swap_reg, sp, swap_reg);\n+      __ neg(swap_reg, swap_reg);\n+      __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n+      __ br(Assembler::NE, slow_path_lock);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ ldr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n@@ -1925,1 +1924,1 @@\n-    if (LockingMode == LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -1940,16 +1939,12 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ ldr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ tbnz(old_hdr, exact_log2(markWord::monitor_value), slow_path_unlock);\n-        __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ get address of the stack lock\n-        __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-        \/\/  get old displaced header\n-        __ ldr(old_hdr, Address(r0, 0));\n-\n-        \/\/ Atomic swap old header if oop still contains the stack lock\n-        Label count;\n-        __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, count, &slow_path_unlock);\n-        __ bind(count);\n-      }\n+    if (LockingMode == LM_MONITOR) {\n+      __ b(slow_path_unlock);\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ get address of the stack lock\n+      __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ ldr(old_hdr, Address(r0, 0));\n+\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      Label count;\n+      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, count, &slow_path_unlock);\n+      __ bind(count);\n@@ -1958,1 +1953,5 @@\n-      __ b(slow_path_unlock);\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ ldr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ tbnz(old_hdr, exact_log2(markWord::monitor_value), slow_path_unlock);\n+      __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":52,"deletions":53,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2434,1 +2434,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -227,1 +227,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -279,1 +279,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -292,1 +292,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -105,1 +105,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -147,1 +147,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -158,1 +158,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -892,1 +892,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -900,1 +900,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -969,1 +969,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -990,1 +990,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -1011,1 +1011,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1029,1 +1029,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1767,1 +1767,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -1825,1 +1825,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1157,1 +1157,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1162,1 +1162,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -1242,1 +1242,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1246,1 +1246,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-    if (UseHeavyMonitors) {\n+    if (LockingMode == LM_MONITOR) {\n@@ -1502,1 +1502,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -77,1 +77,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -124,1 +124,1 @@\n-  if (LockingMode != LIGHTWEIGHT) {\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -136,1 +136,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -141,1 +141,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -784,1 +784,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -812,1 +812,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -816,1 +816,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -850,1 +850,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -884,1 +884,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -895,1 +895,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -907,1 +907,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -931,1 +931,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4495,1 +4495,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -4529,1 +4529,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2419,43 +2419,34 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        Label slow;\n-        __ fast_lock(oop, disp_hdr, tmp, t0, slow);\n-\n-        \/\/ Indicate success on completion.\n-        __ mv(flag, zr);\n-        __ j(count);\n-        __ bind(slow);\n-        __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n-        __ j(no_count);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-        __ ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-        \/\/ Initialize the box. (Must happen before we update the object mark!)\n-        __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-        \/\/ Compare object markWord with an unlocked value (tmp) and if\n-        \/\/ equal exchange the stack address of our box with object markWord.\n-        \/\/ On failure disp_hdr contains the possibly locked markWord.\n-        __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n-                   Assembler::rl, \/*result*\/disp_hdr);\n-        __ mv(flag, zr);\n-        __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n-\n-        assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-        \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-        \/\/ object, will have now locked it will continue at label cont\n-        \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-        \/\/ Check if the owner is self by comparing the value in the\n-        \/\/ markWord of object (disp_hdr) with the stack pointer.\n-        __ sub(disp_hdr, disp_hdr, sp);\n-        __ mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-        \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n-        \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-        \/\/ recursive lock.\n-        __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-        __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-        __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n-      }\n+    if (LockingMode == LM_MONITOR) {\n+      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+      __ j(cont);\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+      __ ori(tmp, disp_hdr, markWord::unlocked_value);\n+\n+      \/\/ Initialize the box. (Must happen before we update the object mark!)\n+      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+      \/\/ Compare object markWord with an unlocked value (tmp) and if\n+      \/\/ equal exchange the stack address of our box with object markWord.\n+      \/\/ On failure disp_hdr contains the possibly locked markWord.\n+      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n+                 Assembler::rl, \/*result*\/disp_hdr);\n+      __ mv(flag, zr);\n+      __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n+\n+      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object, will have now locked it will continue at label cont\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if the owner is self by comparing the value in the\n+      \/\/ markWord of object (disp_hdr) with the stack pointer.\n+      __ sub(disp_hdr, disp_hdr, sp);\n+      __ mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n+      \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n+      \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n+      \/\/ recursive lock.\n+      __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n+      __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+      __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n@@ -2464,0 +2455,8 @@\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      Label slow;\n+      __ fast_lock(oop, disp_hdr, tmp, t0, slow);\n+\n+      \/\/ Indicate success on completion.\n+      __ mv(flag, zr);\n+      __ j(count);\n+      __ bind(slow);\n@@ -2465,1 +2464,1 @@\n-      __ j(cont);\n+      __ j(no_count);\n@@ -2478,1 +2477,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -2520,1 +2519,1 @@\n-    if (LockingMode == LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -2534,22 +2533,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        Label slow;\n-        __ fast_unlock(oop, tmp, box, disp_hdr, slow);\n-\n-        \/\/ Indicate success on completion.\n-        __ mv(flag, zr);\n-        __ j(count);\n-        __ bind(slow);\n-        __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n-        __ j(no_count);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Check if it is still a light weight lock, this is true if we\n-        \/\/ see the stack address of the basicLock in the markWord of the\n-        \/\/ object.\n-\n-        __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n-                   Assembler::rl, \/*result*\/tmp);\n-        __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n-        __ j(cont);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -2558,0 +2536,20 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Check if it is still a light weight lock, this is true if we\n+      \/\/ see the stack address of the basicLock in the markWord of the\n+      \/\/ object.\n+\n+      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n+                 Assembler::rl, \/*result*\/tmp);\n+      __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n+      __ j(cont);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      Label slow;\n+      __ fast_unlock(oop, tmp, box, disp_hdr, slow);\n+\n+      \/\/ Indicate success on completion.\n+      __ mv(flag, zr);\n+      __ j(count);\n+      __ bind(slow);\n+      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+      __ j(no_count);\n@@ -2567,1 +2565,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":67,"deletions":69,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1673,32 +1673,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ ld(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ fast_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Load (object->mark() | 1) into swap_reg % x10\n-        __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ ori(swap_reg, t0, 1);\n-\n-        \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-        __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-        \/\/ src -> dest if dest == x10 else x10 <- dest\n-        __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n-\n-        \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-        \/\/  1) (mark & 3) == 0, and\n-        \/\/  2) sp <= mark < mark + os::pagesize()\n-        \/\/ These 3 tests can be done by evaluating the following\n-        \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-        \/\/ assuming both stack pointer and pagesize have their\n-        \/\/ least significant 2 bits clear.\n-        \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n-\n-        __ sub(swap_reg, swap_reg, sp);\n-        __ andi(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n-\n-        \/\/ Save the test result, for recursive case, the result is zero\n-        __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-        __ bnez(swap_reg, slow_path_lock);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -1706,0 +1675,30 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Load (object->mark() | 1) into swap_reg % x10\n+      __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ ori(swap_reg, t0, 1);\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n+\n+      \/\/ src -> dest if dest == x10 else x10 <- dest\n+      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) sp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n+\n+      __ sub(swap_reg, swap_reg, sp);\n+      __ andi(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n+      __ bnez(swap_reg, slow_path_lock);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ ld(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n@@ -1798,1 +1797,1 @@\n-    if (LockingMode == LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -1813,17 +1812,12 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ ld(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ andi(t0, old_hdr, markWord::monitor_value);\n-        __ bnez(t0, slow_path_unlock);\n-        __ fast_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ get address of the stack lock\n-        __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-        \/\/  get old displaced header\n-        __ ld(old_hdr, Address(x10, 0));\n-\n-        \/\/ Atomic swap old header if oop still contains the stack lock\n-        Label count;\n-        __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, count, &slow_path_unlock);\n-        __ bind(count);\n-      }\n+    if (LockingMode == LM_MONITOR) {\n+      __ j(slow_path_unlock);\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ get address of the stack lock\n+      __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ ld(old_hdr, Address(x10, 0));\n+\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      Label count;\n+      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, count, &slow_path_unlock);\n+      __ bind(count);\n@@ -1832,1 +1826,6 @@\n-      __ j(slow_path_unlock);\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ ld(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ andi(t0, old_hdr, markWord::monitor_value);\n+      __ bnez(t0, slow_path_unlock);\n+      __ fast_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n+      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":50,"deletions":51,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-    if (UseHeavyMonitors) {\n+    if (LockingMode == LM_MONITOR) {\n@@ -3503,1 +3503,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -3511,1 +3511,1 @@\n-    Register tmp = LockingMode == LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n+    Register tmp = LockingMode == LM_LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  LIR_Opr tmp = LockingMode == LIGHTWEIGHT ? new_register(T_ADDRESS) : LIR_OprFact::illegalOpr;\n+  LIR_Opr tmp = LockingMode == LM_LIGHTWEIGHT ? new_register(T_ADDRESS) : LIR_OprFact::illegalOpr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -73,1 +73,1 @@\n-  } else  if (LockingMode == LEGACY) {\n+  } else  if (LockingMode == LM_LEGACY) {\n@@ -122,1 +122,1 @@\n-  if (LockingMode != LIGHTWEIGHT) {\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -135,1 +135,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -139,1 +139,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -593,1 +593,1 @@\n-    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n+    assert(LockingMode != LM_MONITOR, \"LockingMode == 0 (LM_MONITOR) and +UseRTMForStackLocks are mutually exclusive\");\n@@ -604,21 +604,1 @@\n-  if (!UseHeavyMonitors) {\n-    if (LockingMode == LIGHTWEIGHT) {\n-      fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n-      jmp(COUNT);\n-    } else if (LockingMode == LEGACY) {\n-      \/\/ Attempt stack-locking ...\n-      orptr (tmpReg, markWord::unlocked_value);\n-      movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n-      lock();\n-      cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n-      jcc(Assembler::equal, COUNT);           \/\/ Success\n-\n-      \/\/ Recursive locking.\n-      \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n-      \/\/ Locked by current thread if difference with current SP is less than one page.\n-      subptr(tmpReg, rsp);\n-      \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n-      andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - (int)os::vm_page_size())) );\n-      movptr(Address(boxReg, 0), tmpReg);\n-    }\n-  } else {\n+  if (LockingMode == LM_MONITOR) {\n@@ -627,0 +607,19 @@\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Attempt stack-locking ...\n+    orptr (tmpReg, markWord::unlocked_value);\n+    movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n+    lock();\n+    cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n+    jcc(Assembler::equal, COUNT);           \/\/ Success\n+\n+    \/\/ Recursive locking.\n+    \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n+    \/\/ Locked by current thread if difference with current SP is less than one page.\n+    subptr(tmpReg, rsp);\n+    \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n+    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - (int)os::vm_page_size())) );\n+    movptr(Address(boxReg, 0), tmpReg);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+    fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n+    jmp(COUNT);\n@@ -757,1 +756,1 @@\n-    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n+    assert(LockingMode != LM_MONITOR, \"LockingMode == 0 (LM_MONITOR) and +UseRTMForStackLocks are mutually exclusive\");\n@@ -769,1 +768,1 @@\n-  if (LockingMode == LEGACY) {\n+  if (LockingMode == LM_LEGACY) {\n@@ -774,1 +773,1 @@\n-  if (!UseHeavyMonitors) {\n+  if (LockingMode != LM_MONITOR) {\n@@ -777,1 +776,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -914,1 +913,1 @@\n-  if (!UseHeavyMonitors) {\n+  if (LockingMode != LM_MONITOR) {\n@@ -916,1 +915,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -920,1 +919,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -1226,1 +1226,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1236,1 +1236,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -1297,1 +1297,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1327,1 +1327,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -1338,1 +1338,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -1350,1 +1350,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1366,1 +1366,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1683,38 +1683,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        \/\/ Load object header\n-        __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ fast_lock_impl(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Load immediate 1 into swap_reg %rax,\n-        __ movptr(swap_reg, 1);\n-\n-        \/\/ Load (object->mark() | 1) into swap_reg %rax,\n-        __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-        \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-        __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-        \/\/ src -> dest iff dest == rax, else rax, <- dest\n-        \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n-        __ lock();\n-        __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ jcc(Assembler::equal, count_mon);\n-\n-        \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-        \/\/  1) (mark & 3) == 0, and\n-        \/\/  2) rsp <= mark < mark + os::pagesize()\n-        \/\/ These 3 tests can be done by evaluating the following\n-        \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-        \/\/ assuming both stack pointer and pagesize have their\n-        \/\/ least significant 2 bits clear.\n-        \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n-\n-        __ subptr(swap_reg, rsp);\n-        __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n-\n-        \/\/ Save the test result, for recursive case, the result is zero\n-        __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-        __ jcc(Assembler::notEqual, slow_path_lock);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -1722,0 +1685,36 @@\n+    } else if (LockingMode == LEGACY) {\n+      \/\/ Load immediate 1 into swap_reg %rax,\n+      __ movptr(swap_reg, 1);\n+\n+      \/\/ Load (object->mark() | 1) into swap_reg %rax,\n+      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::equal, count_mon);\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) rsp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg\n+\n+      __ subptr(swap_reg, rsp);\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+      __ jcc(Assembler::notEqual, slow_path_lock);\n+    } else {\n+      assert(LockingMode == LIGHTWEIGHT, \"\");\n+      \/\/ Load object header\n+      __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_lock_impl(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n@@ -1858,19 +1857,15 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ andptr(swap_reg, ~(int32_t)markWord::lock_mask_in_place);\n-        __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/  get old displaced header\n-        __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n-\n-        \/\/ get address of the stack lock\n-        __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n-\n-        \/\/ Atomic swap old header if oop still contains the stack lock\n-        \/\/ src -> dest iff dest == rax, else rax, <- dest\n-        \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n-        __ lock();\n-        __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ jcc(Assembler::notEqual, slow_path_unlock);\n-      }\n+    if (LockingMode == LM_MONITOR) {\n+      __ jmp(slow_path_unlock);\n+    } else if (LockingMode == LEGACY) {\n+      \/\/  get old displaced header\n+      __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));\n+\n+      \/\/ get address of the stack lock\n+      __ lea(rax, Address(rbp, lock_slot_rbp_offset));\n+\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      \/\/ src -> dest iff dest == rax, else rax, <- dest\n+      \/\/ *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)\n+      __ lock();\n+      __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::notEqual, slow_path_unlock);\n@@ -1879,1 +1874,5 @@\n-      __ jmp(slow_path_unlock);\n+      assert(LockingMode == LIGHTWEIGHT, \"\");\n+      __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ andptr(swap_reg, ~(int32_t)markWord::lock_mask_in_place);\n+      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ dec_held_monitor_count();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":57,"deletions":58,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2152,39 +2152,1 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        \/\/ Load object header\n-        __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ Load immediate 1 into swap_reg %rax\n-        __ movl(swap_reg, 1);\n-\n-        \/\/ Load (object->mark() | 1) into swap_reg %rax\n-        __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-        \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-        __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-        \/\/ src -> dest iff dest == rax else rax <- dest\n-        __ lock();\n-        __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ jcc(Assembler::equal, count_mon);\n-\n-        \/\/ Hmm should this move to the slow path code area???\n-\n-        \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-        \/\/  1) (mark & 3) == 0, and\n-        \/\/  2) rsp <= mark < mark + os::pagesize()\n-        \/\/ These 3 tests can be done by evaluating the following\n-        \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-        \/\/ assuming both stack pointer and pagesize have their\n-        \/\/ least significant 2 bits clear.\n-        \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n-\n-        __ subptr(swap_reg, rsp);\n-        __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n-\n-        \/\/ Save the test result, for recursive case, the result is zero\n-        __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-        __ jcc(Assembler::notEqual, slow_path_lock);\n-      }\n-    } else {\n+    if (LockingMode == LM_MONITOR) {\n@@ -2192,0 +2154,37 @@\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ Load immediate 1 into swap_reg %rax\n+      __ movl(swap_reg, 1);\n+\n+      \/\/ Load (object->mark() | 1) into swap_reg %rax\n+      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+\n+      \/\/ src -> dest iff dest == rax else rax <- dest\n+      __ lock();\n+      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::equal, count_mon);\n+\n+      \/\/ Hmm should this move to the slow path code area???\n+\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) rsp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n+\n+      __ subptr(swap_reg, rsp);\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n+      __ jcc(Assembler::notEqual, slow_path_lock);\n+    } else {\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      \/\/ Load object header\n+      __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2303,1 +2302,1 @@\n-    if (LockingMode == LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -2318,16 +2317,12 @@\n-    if (!UseHeavyMonitors) {\n-      if (LockingMode == LIGHTWEIGHT) {\n-        __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ andptr(swap_reg, ~(int32_t)markWord::lock_mask_in_place);\n-        __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n-      } else if (LockingMode == LEGACY) {\n-        \/\/ get address of the stack lock\n-        __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-        \/\/  get old displaced header\n-        __ movptr(old_hdr, Address(rax, 0));\n-\n-        \/\/ Atomic swap old header if oop still contains the stack lock\n-        __ lock();\n-        __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-        __ jcc(Assembler::notEqual, slow_path_unlock);\n-      }\n+    if (LockingMode == LM_MONITOR) {\n+      __ jmp(slow_path_unlock);\n+    } else if (LockingMode == LM_LEGACY) {\n+      \/\/ get address of the stack lock\n+      __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ movptr(old_hdr, Address(rax, 0));\n+\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      __ lock();\n+      __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ jcc(Assembler::notEqual, slow_path_unlock);\n@@ -2336,1 +2331,5 @@\n-      __ jmp(slow_path_unlock);\n+      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+      __ movptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ andptr(swap_reg, ~(int32_t)markWord::lock_mask_in_place);\n+      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ dec_held_monitor_count();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":56,"deletions":57,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    bool call_vm = UseHeavyMonitors;\n+    bool call_vm = (LockingMode == LM_MONITOR);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, !UseHeavyMonitors, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, LockingMode != LM_MONITOR, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-  if (UseHeavyMonitors) {\n+  if (LockingMode == LM_MONITOR) {\n@@ -760,2 +760,2 @@\n-  assert(LockingMode == LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n-  SharedRuntime::monitor_enter_helper(obj, LockingMode == LIGHTWEIGHT ? nullptr : lock->lock(), current);\n+  assert(LockingMode == LM_LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n+  SharedRuntime::monitor_enter_helper(obj, LockingMode == LM_LIGHTWEIGHT ? nullptr : lock->lock(), current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-  assert(LockingMode != LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n@@ -762,1 +762,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-        bool call_vm = UseHeavyMonitors;\n+        bool call_vm = (LockingMode == LM_MONITOR);\n@@ -726,1 +726,1 @@\n-      bool call_vm = UseHeavyMonitors;\n+      bool call_vm = (LockingMode == LM_MONITOR);\n@@ -1656,1 +1656,1 @@\n-          bool call_vm = UseHeavyMonitors;\n+          bool call_vm = (LockingMode == LM_MONITOR);\n@@ -1692,1 +1692,1 @@\n-            bool call_vm = UseHeavyMonitors;\n+            bool call_vm = (LockingMode == LM_MONITOR);\n@@ -3192,1 +3192,1 @@\n-          } else if (UseHeavyMonitors) {\n+          } else if (LockingMode == LM_MONITOR) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    assert(LockingMode == LEGACY, \"should only be called with traditional stack locking\");\n+    assert(LockingMode == LM_LEGACY, \"should only be called with traditional stack locking\");\n@@ -184,1 +184,1 @@\n-    assert(LockingMode == LIGHTWEIGHT, \"should only be called with new lightweight locking\");\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"should only be called with new lightweight locking\");\n@@ -202,2 +202,2 @@\n-    return LockingMode == LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n-                                       : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    return LockingMode == LM_LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n+                                          : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  return LockingMode == LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n+  return LockingMode == LM_LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1983,1 +1983,8 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64)\n+\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM)\n+  if (LockingMode == LIGHTWEIGHT) {\n+    FLAG_SET_CMDLINE(LockingMode, LEGACY);\n+    warning(\"New lightweight locking not supported on this platform\");\n+  }\n+#endif\n+\n@@ -1985,0 +1992,5 @@\n+    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n+  }\n+\n+#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64)\n+  if (LockingMode == LM_MONITOR) {\n@@ -1986,1 +1998,1 @@\n-                \"UseHeavyMonitors is not fully implemented on this architecture\");\n+                \"LockingMode == 0 (LM_MONITOR) is not fully implemented on this architecture\");\n@@ -1991,1 +2003,1 @@\n-  if (UseHeavyMonitors && UseRTMForStackLocks) {\n+  if (LockingMode == LM_MONITOR && UseRTMForStackLocks) {\n@@ -1993,1 +2005,1 @@\n-                \"-XX:+UseHeavyMonitors and -XX:+UseRTMForStackLocks are mutually exclusive\");\n+                \"LockingMode == 0 (LM_MONITOR) and -XX:+UseRTMForStackLocks are mutually exclusive\");\n@@ -1998,1 +2010,1 @@\n-  if (VerifyHeavyMonitors && !UseHeavyMonitors) {\n+  if (VerifyHeavyMonitors && LockingMode != LM_MONITOR) {\n@@ -2000,1 +2012,1 @@\n-                \"-XX:+VerifyHeavyMonitors requires -XX:+UseHeavyMonitors\");\n+                \"-XX:+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\");\n@@ -2003,11 +2015,0 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM)\n-  if (LockingMode == LIGHTWEIGHT) {\n-    FLAG_SET_CMDLINE(LockingMode, LEGACY);\n-    warning(\"New lightweight locking not supported on this platform\");\n-  }\n-#endif\n-  if (UseHeavyMonitors) {\n-    FLAG_SET_CMDLINE(LockingMode, 0);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1607,1 +1607,1 @@\n-          if (LockingMode == LEGACY && mark.has_locker() && fr.sp() > (intptr_t*)mark.locker()) {\n+          if (LockingMode == LM_LEGACY && mark.has_locker() && fr.sp() > (intptr_t*)mark.locker()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1978,1 +1978,1 @@\n-  product(int, LockingMode, LEGACY, EXPERIMENTAL,                           \\\n+  product(int, LockingMode, LM_LEGACY, EXPERIMENTAL,                        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -993,1 +993,1 @@\n-  assert(LockingMode != LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n@@ -1388,1 +1388,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"never use lock-stack when fast-locking is disabled\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"never use lock-stack when fast-locking is disabled\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  if (LockingMode != LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n@@ -1138,1 +1138,1 @@\n-    if (LockingMode != LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n@@ -1353,1 +1353,1 @@\n-    if (LockingMode != LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+    if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n@@ -1392,1 +1392,1 @@\n-  if (LockingMode != LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -321,1 +321,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -397,1 +397,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -477,1 +477,1 @@\n-  return UseHeavyMonitors;\n+  return LockingMode == LM_MONITOR;\n@@ -497,1 +497,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -515,1 +515,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -559,1 +559,1 @@\n-    if (LockingMode == LIGHTWEIGHT) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -579,1 +579,1 @@\n-    } else if (LockingMode == LEGACY) {\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -627,1 +627,1 @@\n-  if (LockingMode == LIGHTWEIGHT && monitor->is_owner_anonymous()) {\n+  if (LockingMode == LM_LIGHTWEIGHT && monitor->is_owner_anonymous()) {\n@@ -724,1 +724,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -729,1 +729,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -746,1 +746,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -751,1 +751,1 @@\n-  } else if (LockingMode == LEGACY) {\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -781,1 +781,1 @@\n-  if (!mark.is_being_inflated() || LockingMode == LIGHTWEIGHT) {\n+  if (!mark.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT) {\n@@ -900,1 +900,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n@@ -912,1 +912,1 @@\n-      assert(UseHeavyMonitors, \"+VerifyHeavyMonitors requires +UseHeavyMonitors\");\n+      assert(LockingMode == LM_MONITOR, \"+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\");\n@@ -958,1 +958,1 @@\n-    } else if (LockingMode == LIGHTWEIGHT && mark.is_fast_locked() && is_lock_owned(current, obj)) {\n+    } else if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked() && is_lock_owned(current, obj)) {\n@@ -965,1 +965,1 @@\n-    } else if (LockingMode == LEGACY && mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    } else if (LockingMode == LM_LEGACY && mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n@@ -1030,1 +1030,1 @@\n-  if (LockingMode == LEGACY && mark.has_locker()) {\n+  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n@@ -1035,1 +1035,1 @@\n-  if (LockingMode == LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n@@ -1056,1 +1056,1 @@\n-  if (LockingMode == LEGACY && mark.has_locker()) {\n+  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n@@ -1062,1 +1062,1 @@\n-  if (LockingMode == LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n@@ -1282,1 +1282,1 @@\n-      if (LockingMode == LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n@@ -1289,1 +1289,1 @@\n-    if (LockingMode != LIGHTWEIGHT) {\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n@@ -1314,1 +1314,1 @@\n-    if (LockingMode == LIGHTWEIGHT && mark.is_fast_locked()) {\n+    if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n@@ -1366,2 +1366,2 @@\n-    if (LockingMode == LEGACY && mark.has_locker()) {\n-      assert(LockingMode != LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n+    if (LockingMode == LM_LEGACY && mark.has_locker()) {\n+      assert(LockingMode != LM_LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-  assert(LockingMode != LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1394,1 +1394,1 @@\n-  assert(LockingMode != LIGHTWEIGHT, \"Not with new lightweight locking\");\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Not with new lightweight locking\");\n@@ -1406,1 +1406,1 @@\n-  if (UseHeavyMonitors) return nullptr;\n+  if (LockingMode == LM_MONITOR) return nullptr;\n@@ -1425,1 +1425,1 @@\n-  assert(LockingMode == LIGHTWEIGHT, \"Only with new lightweight locking\");\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"Only with new lightweight locking\");\n@@ -1435,1 +1435,1 @@\n-  if (LockingMode == LIGHTWEIGHT) {\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1047,1 +1047,1 @@\n-  MONITOR     = 0,\n+  LM_MONITOR     = 0,\n@@ -1049,1 +1049,1 @@\n-  LEGACY      = 1,\n+  LM_LEGACY      = 1,\n@@ -1051,1 +1051,1 @@\n-  LIGHTWEIGHT = 2\n+  LM_LIGHTWEIGHT = 2\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}