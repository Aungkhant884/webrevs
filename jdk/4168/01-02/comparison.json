{"files":[{"patch":"@@ -39,1 +39,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -195,3 +195,6 @@\n-  int _table_size;\n-  KVHashtable<void *, bool, mtThread, &ThreadScanHashtable::ptr_hash,\n-                            &ThreadScanHashtable::ptr_equals> _ptrs;\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  typedef ResourceHashtable<void *, int, &ThreadScanHashtable::ptr_hash,\n+                            &ThreadScanHashtable::ptr_equals, 1031,\n+                            ResourceObj::C_HEAP, mtThread> PtrTable;\n+  PtrTable * _ptrs;\n@@ -200,3 +203,4 @@\n-  ThreadScanHashtable(int table_size) : _table_size(table_size), _ptrs(table_size) {\n-      log_trace(thread, smr)(\"tid=\" UINTX_FORMAT \": allocate ThreadScanHashtable(%d) at \" INTPTR_FORMAT, os::current_thread_id(), _table_size, p2i(this));\n-  }\n+  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ different places so we allocate it using C_HEAP to make it immune\n+  \/\/ from any ResourceMarks that happen to be in the code paths.\n+  ThreadScanHashtable() : _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable()) {}\n@@ -204,3 +208,1 @@\n-  ~ThreadScanHashtable() {\n-      log_trace(thread, smr)(\"tid=\" UINTX_FORMAT \": deallocate ThreadScanHashtable(%d) at \" INTPTR_FORMAT, os::current_thread_id(), _table_size, p2i(this));\n-  }\n+  ~ThreadScanHashtable() { delete _ptrs; }\n@@ -208,4 +210,3 @@\n-  bool add_if_absent(void* pointer) {\n-    bool created;\n-    _ptrs.add_if_absent(pointer, true, &created);\n-    return created;\n+  bool has_entry(void *pointer) {\n+    int *val_ptr = _ptrs->get(pointer);\n+    return val_ptr != NULL && *val_ptr == 1;\n@@ -214,2 +215,2 @@\n-  bool has_entry(void* pointer) {\n-    return (_ptrs.lookup(pointer) != NULL);\n+  void add_entry(void *pointer) {\n+    _ptrs->put(pointer, 1);\n@@ -232,4 +233,6 @@\n-    \/\/ The same JavaThread might be on more than one ThreadsList or\n-    \/\/ more than one thread might be using the same ThreadsList. In\n-    \/\/ either case, we only need a single entry for a JavaThread.\n-    (void)_table->add_if_absent((void*)thread);\n+    if (!_table->has_entry((void*)thread)) {\n+      \/\/ The same JavaThread might be on more than one ThreadsList or\n+      \/\/ more than one thread might be using the same ThreadsList. In\n+      \/\/ either case, we only need a single entry for a JavaThread.\n+      _table->add_entry((void*)thread);\n+    }\n@@ -324,1 +327,3 @@\n-    (void)_table->add_if_absent((void*)hazard_ptr);\n+    if (!_table->has_entry((void*)hazard_ptr)) {\n+      _table->add_entry((void*)hazard_ptr);\n+    }\n@@ -843,8 +848,0 @@\n-\/\/ Hash table size should be first power of two higher than twice the\n-\/\/ length of the ThreadsList\n-static int hash_table_size() {\n-  ThreadsList* threads = ThreadsSMRSupport::get_java_thread_list();\n-  int hash_table_size = MIN2((int)threads->length(), 32) << 1;\n-  return round_up_power_of_2(hash_table_size);\n-}\n-\n@@ -875,1 +872,1 @@\n-  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size());\n+  ThreadScanHashtable *scan_table = new ThreadScanHashtable();\n@@ -931,1 +928,1 @@\n-  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size());\n+  ThreadScanHashtable *scan_table = new ThreadScanHashtable();\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -282,1 +282,0 @@\n-template class BasicHashtable<mtThread>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}