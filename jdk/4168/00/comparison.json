{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"utilities\/hashtable.inline.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -196,7 +196,12 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so our\n-  \/\/ dynamic _table_size is unused for now; 1031 is the first prime\n-  \/\/ after 1024.\n-  typedef ResourceHashtable<void *, int, &ThreadScanHashtable::ptr_hash,\n-                            &ThreadScanHashtable::ptr_equals, 1031,\n-                            ResourceObj::C_HEAP, mtThread> PtrTable;\n-  PtrTable * _ptrs;\n+  \/\/ Note: I want this to be mtThread, but that causes linkage errors:\n+  \/\/\n+  \/\/   Undefined symbols for architecture x86_64:\n+  \/\/   \"BasicHashtable<(MEMFLAGS)2>::free_buckets()\", referenced from:\n+  \/\/   ThreadsSMRSupport::free_list(ThreadsList*) in threadSMR.o\n+  \/\/   ThreadsSMRSupport::is_a_protected_JavaThread(JavaThread*) in threadSMR.o\n+  \/\/   \"BasicHashtable<(MEMFLAGS)2>::new_entry(unsigned int)\", referenced from:\n+  \/\/   KVHashtable<void*, bool, (MEMFLAGS)2, &(unsigned int primitive_hash<void*>(void* const&)), &(bool primitive_equals<void*>(void* const&, void* const&))>::add_if_absent(void*, bool, bool*) in threadSMR.o\n+  \/\/\n+  \/\/ so I'm using mtInternal instead.\n+  KVHashtable<void *, bool, mtInternal, &ThreadScanHashtable::ptr_hash,\n+                            &ThreadScanHashtable::ptr_equals> _ptrs;\n@@ -205,4 +210,3 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n-  \/\/ different places so we allocate it using C_HEAP to make it immune\n-  \/\/ from any ResourceMarks that happen to be in the code paths.\n-  ThreadScanHashtable(int table_size) : _table_size(table_size), _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable()) {}\n+  ThreadScanHashtable(int table_size) : _table_size(table_size), _ptrs(table_size) {\n+      log_trace(thread, smr)(\"tid=\" UINTX_FORMAT \": allocate ThreadScanHashtable(%d) at \" INTPTR_FORMAT, os::current_thread_id(), _table_size, p2i(this));\n+  }\n@@ -210,1 +214,3 @@\n-  ~ThreadScanHashtable() { delete _ptrs; }\n+  ~ThreadScanHashtable() {\n+      log_trace(thread, smr)(\"tid=\" UINTX_FORMAT \": deallocate ThreadScanHashtable(%d) at \" INTPTR_FORMAT, os::current_thread_id(), _table_size, p2i(this));\n+  }\n@@ -212,3 +218,4 @@\n-  bool has_entry(void *pointer) {\n-    int *val_ptr = _ptrs->get(pointer);\n-    return val_ptr != NULL && *val_ptr == 1;\n+  bool add_if_absent(void* pointer) {\n+    bool created;\n+    _ptrs.add_if_absent(pointer, true, &created);\n+    return created;\n@@ -217,2 +224,2 @@\n-  void add_entry(void *pointer) {\n-    _ptrs->put(pointer, 1);\n+  bool has_entry(void* pointer) {\n+    return (_ptrs.lookup(pointer) != NULL);\n@@ -235,6 +242,4 @@\n-    if (!_table->has_entry((void*)thread)) {\n-      \/\/ The same JavaThread might be on more than one ThreadsList or\n-      \/\/ more than one thread might be using the same ThreadsList. In\n-      \/\/ either case, we only need a single entry for a JavaThread.\n-      _table->add_entry((void*)thread);\n-    }\n+    \/\/ The same JavaThread might be on more than one ThreadsList or\n+    \/\/ more than one thread might be using the same ThreadsList. In\n+    \/\/ either case, we only need a single entry for a JavaThread.\n+    (void)_table->add_if_absent((void*)thread);\n@@ -329,3 +334,1 @@\n-    if (!_table->has_entry((void*)hazard_ptr)) {\n-      _table->add_entry((void*)hazard_ptr);\n-    }\n+    (void)_table->add_if_absent((void*)hazard_ptr);\n@@ -850,0 +853,8 @@\n+\/\/ Hash table size should be first power of two higher than twice the\n+\/\/ length of the ThreadsList\n+static int hash_table_size() {\n+  ThreadsList* threads = ThreadsSMRSupport::get_java_thread_list();\n+  int hash_table_size = MIN2((int)threads->length(), 32) << 1;\n+  return round_up_power_of_2(hash_table_size);\n+}\n+\n@@ -873,4 +884,0 @@\n-  \/\/ Hash table size should be first power of two higher than twice the length of the ThreadsList\n-  int hash_table_size = MIN2((int)get_java_thread_list()->length(), 32) << 1;\n-  hash_table_size = round_up_power_of_2(hash_table_size);\n-\n@@ -878,1 +885,1 @@\n-  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);\n+  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size());\n@@ -932,5 +939,0 @@\n-  \/\/ Hash table size should be first power of two higher than twice\n-  \/\/ the length of the Threads list.\n-  int hash_table_size = MIN2((int)get_java_thread_list()->length(), 32) << 1;\n-  hash_table_size = round_up_power_of_2(hash_table_size);\n-\n@@ -939,1 +941,1 @@\n-  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);\n+  ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size());\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"}]}