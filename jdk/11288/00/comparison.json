{"files":[{"patch":"@@ -173,17 +173,1 @@\n-  JvmtiTagMapEntry* entry = tag_map->hashmap()->find(o);\n-  if (entry == NULL) {\n-    return 0;\n-  } else {\n-    jlong tag = entry->tag();\n-    assert(tag != 0, \"should not be zero\");\n-    return entry->tag();\n-  }\n-}\n-\n-\n-\/\/ A CallbackWrapper is a support class for querying and tagging an object\n-\/\/ around a callback to a profiler. The constructor does pre-callback\n-\/\/ work to get the tag value, klass tag value, ... and the destructor\n-\/\/ does the post-callback work of tagging or untagging the object.\n-\/\/\n-\/\/ {\n+  return tag_map->hashmap()->find(o); } \/\/ A CallbackWrapper is a support class for querying and tagging an object \/\/ around a callback to a profiler. The constructor does pre-callback \/\/ work to get the tag value, klass tag value, ... and the destructor \/\/ does the post-callback work of tagging or untagging the object. \/\/ \/\/ {\n@@ -202,1 +186,1 @@\n-  JvmtiTagMapEntry* _entry;\n+  bool _entry_found;\n@@ -213,1 +197,1 @@\n-                                       JvmtiTagMapEntry* entry, jlong obj_tag);\n+                                       jlong obj_tag);\n@@ -228,1 +212,1 @@\n-    _entry = _hashmap->find(_o);\n+    _obj_tag  = _hashmap->find(_o);\n@@ -231,1 +215,0 @@\n-    _obj_tag = (_entry == NULL) ? 0 : _entry->tag();\n@@ -240,1 +223,1 @@\n-    post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);\n+    post_callback_tag_update(_o, _hashmap,  _obj_tag);\n@@ -252,0 +235,1 @@\n+\n@@ -254,1 +238,0 @@\n-                                                      JvmtiTagMapEntry* entry,\n@@ -256,1 +239,2 @@\n-  if (entry == NULL) {\n+  jlong current_tag = hashmap->find(o);\n+  if (current_tag == 0 ) {\n@@ -268,2 +252,3 @@\n-      if (obj_tag != entry->tag()) {\n-         entry->set_tag(obj_tag);\n+      if (obj_tag != current_tag ) {\n+        hashmap->remove(o);\n+        hashmap->add(o, obj_tag);\n@@ -294,1 +279,1 @@\n-  JvmtiTagMapEntry* _referrer_entry;\n+\n@@ -316,1 +301,1 @@\n-      _referrer_entry = _referrer_hashmap->find(_referrer);\n+      _referrer_obj_tag  = _referrer_hashmap->find(_referrer);\n@@ -319,1 +304,0 @@\n-      _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry->tag();\n@@ -329,0 +313,1 @@\n+\n@@ -331,1 +316,0 @@\n-                               _referrer_entry,\n@@ -360,1 +344,3 @@\n-  \/\/ see if the object is already tagged\n+  \/\/JvmtiTagMapEntry entry ;\n+  \/\/_hashmap->add_update_remove(&entry, o, tag);\n+  \/\/see if the object is already tagged\n@@ -362,1 +348,1 @@\n-  JvmtiTagMapEntry* entry = hashmap->find(o);\n+  jlong found_tag  = hashmap->find(o);\n@@ -365,1 +351,1 @@\n-  if (entry == NULL) {\n+  if (found_tag == 0) {\n@@ -378,1 +364,2 @@\n-      entry->set_tag(tag);\n+        hashmap->remove(o);\n+        hashmap->add(o,tag);\n@@ -1274,1 +1261,1 @@\n-  void do_entry(JvmtiTagMapEntry* entry) {\n+  bool do_entry(JvmtiTagMapEntry & key , jlong & value ) {\n@@ -1276,1 +1263,1 @@\n-      if (_tags[i] == entry->tag()) {\n+      if (_tags[i] == value) {\n@@ -1281,1 +1268,1 @@\n-        oop o = entry->object();\n+        oop o = key.object();\n@@ -1285,1 +1272,1 @@\n-          return;\n+          return true;\n@@ -1290,1 +1277,1 @@\n-        _tag_results->append((uint64_t)entry->tag());\n+        _tag_results->append(value);\n@@ -1293,0 +1280,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":27,"deletions":39,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/oopStorage.hpp\"\n@@ -41,24 +42,17 @@\n-oop JvmtiTagMapEntry::object() {\n-  return literal().resolve();\n-}\n-\n-oop JvmtiTagMapEntry::object_no_keepalive() {\n-  \/\/ Just peek at the object without keeping it alive.\n-  return literal().peek();\n-}\n-\n-JvmtiTagMapTable::JvmtiTagMapTable()\n-  : Hashtable<WeakHandle, mtServiceability>(_table_size, sizeof(JvmtiTagMapEntry)) {}\n-\n-void JvmtiTagMapTable::clear() {\n-  \/\/ Clear this table\n-  log_debug(jvmti, table)(\"JvmtiTagMapTable cleared\");\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* m = bucket(i); m != NULL;) {\n-      JvmtiTagMapEntry* entry = m;\n-      \/\/ read next before freeing.\n-      m = m->next();\n-      free_entry(entry);\n-    }\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    *p = NULL; \/\/ clear out buckets.\n+JvmtiTagMapEntry::JvmtiTagMapEntry(oop obj): _obj(obj){}\n+\n+JvmtiTagMapEntry::JvmtiTagMapEntry(const JvmtiTagMapEntry& src) {\n+   \/\/ move object into WeakHandle when copying into the table\n+   assert(src._obj != nullptr, \"must be set\");\n+   _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n+   _obj = nullptr;\n+ }\n+\n+JvmtiTagMapEntry::~JvmtiTagMapEntry(){\n+   \/\/ If obj is set null it out, this is called for stack object on lookup,\n+   \/\/ and it should not have a WeakHandle created for it yet.\n+   if (_obj != nullptr) {\n+     _obj = nullptr;\n+     assert(_wh.is_null(), \"WeakHandle should be null\");\n+   } else {\n+     _wh.release(JvmtiExport::weak_tag_storage());\n@@ -66,6 +60,0 @@\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n-}\n-\n-JvmtiTagMapTable::~JvmtiTagMapTable() {\n-  clear();\n-  \/\/ base class ~BasicHashtable deallocates the buckets.\n@@ -74,5 +62,3 @@\n-\/\/ Entries are C_Heap allocated\n-JvmtiTagMapEntry* JvmtiTagMapTable::new_entry(unsigned int hash, WeakHandle w, jlong tag) {\n-  JvmtiTagMapEntry* entry = (JvmtiTagMapEntry*)Hashtable<WeakHandle, mtServiceability>::new_entry(hash, w);\n-  entry->set_tag(tag);\n-  return entry;\n+oop JvmtiTagMapEntry::object() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.resolve();\n@@ -81,3 +67,3 @@\n-void JvmtiTagMapTable::free_entry(JvmtiTagMapEntry* entry) {\n-  entry->literal().release(JvmtiExport::weak_tag_storage()); \/\/ release to OopStorage\n-  BasicHashtable<mtServiceability>::free_entry(entry);\n+oop JvmtiTagMapEntry::object_no_keepalive() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.peek();\n@@ -86,3 +72,2 @@\n-unsigned int JvmtiTagMapTable::compute_hash(oop obj) {\n-  assert(obj != NULL, \"obj is null\");\n-  return obj->identity_hash();\n+JvmtiTagMapTable::JvmtiTagMapTable()\n+  :_rrht_table(Constants::_table_size){\n@@ -91,19 +76,5 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(int index, unsigned int hash, oop obj) {\n-  assert(obj != NULL, \"Cannot search for a NULL object\");\n-\n-  for (JvmtiTagMapEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->hash() == hash) {\n-\n-      \/\/ Peek the object to check if it is the right target.\n-      oop target = p->object_no_keepalive();\n-\n-      \/\/ The obj is in the table as a target already\n-      if (target == obj) {\n-        ResourceMark rm;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry found for %s index %d\",\n-                                obj->print_value_string(), index);\n-        \/\/ The object() accessor makes sure the target object is kept alive before\n-        \/\/ leaking out.\n-        (void)p->object();\n-        return p;\n-      }\n+void JvmtiTagMapTable::clear() {\n+  struct RemoveAll{\n+    bool do_entry(JvmtiTagMapEntry   & entry, jlong const &  tag)\n+    {\n+      return true;\n@@ -111,3 +82,2 @@\n-  }\n-  return NULL;\n-}\n+  }RemoveAll;\n+  _rrht_table.unlink(&RemoveAll);\n@@ -115,8 +85,1 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(oop obj) {\n-  if (obj->fast_no_hash_check()) {\n-    \/\/ Objects in the table all have a hashcode.\n-    return NULL;\n-  }\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  return find(index, hash, obj);\n+  assert(_rrht_table.number_of_entries() == 0, \"should have removed all entries\");\n@@ -125,19 +88,3 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::add(oop obj, jlong tag) {\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  \/\/ One was added while acquiring the lock\n-  assert(find(index, hash, obj) == NULL, \"shouldn't already be present\");\n-\n-  \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent.\n-  \/\/ The object needs to be kept alive when it is published.\n-  Universe::heap()->keep_alive(obj);\n-\n-  WeakHandle w(JvmtiExport::weak_tag_storage(), obj);\n-  JvmtiTagMapEntry* p = new_entry(hash, w, tag);\n-  Hashtable<WeakHandle, mtServiceability>::add_entry(index, p);\n-  ResourceMark rm;\n-  log_trace(jvmti, table)(\"JvmtiTagMap entry added for %s index %d\",\n-                          obj->print_value_string(), index);\n-\n-  \/\/ Resize if the table is getting too big.\n-  resize_if_needed();\n+JvmtiTagMapTable::~JvmtiTagMapTable() {\n+  clear();\n+}\n@@ -145,1 +92,15 @@\n-  return p;\n+jlong JvmtiTagMapTable::find(oop obj) {\n+   \/\/if (obj->fast_no_hash_check()) {\n+   \/\/  return 0;\n+   \/\/} else {\n+     JvmtiTagMapEntry jtme(obj);\n+     jlong* found = _rrht_table.get(jtme);\n+     return found == NULL ? 0 : *found;\n+   \/\/}\n+ }\n+\n+bool JvmtiTagMapTable::add(oop obj, jlong tag) {\n+  JvmtiTagMapEntry new_entry(obj);\n+  bool is_added = _rrht_table.put(new_entry, tag);\n+  assert(is_added, \"should be added\");\n+  return is_added;\n@@ -148,17 +109,3 @@\n-void JvmtiTagMapTable::remove(oop obj) {\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  JvmtiTagMapEntry** p = bucket_addr(index);\n-  JvmtiTagMapEntry* entry = bucket(index);\n-  while (entry != NULL) {\n-    oop target = entry->object_no_keepalive();\n-    if (target != NULL && target == obj) {\n-      log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", index);\n-      *p = entry->next();\n-      free_entry(entry);\n-      return; \/\/ done\n-    }\n-    \/\/ get next entry and address\n-    p = entry->next_addr();\n-    entry = entry->next();\n-  }\n+bool JvmtiTagMapTable::remove(oop obj) {\n+  JvmtiTagMapEntry jtme(obj);\n+  return _rrht_table.remove(jtme);\n@@ -168,5 +115,1 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      closure->do_entry(p);\n-    }\n-  }\n+  _rrht_table.iterate(closure);\n@@ -175,3 +118,0 @@\n-const int _resize_load_trigger = 5;       \/\/ load factor that will trigger the resize\n-static bool _resizable = true;\n-\n@@ -179,12 +119,1 @@\n-  if (_resizable && number_of_entries() > (_resize_load_trigger*table_size())) {\n-    int desired_size = calculate_resize(true);\n-    if (desired_size == table_size()) {\n-      _resizable = false; \/\/ hit max\n-    } else {\n-      if (!resize(desired_size)) {\n-        \/\/ Something went wrong, turn resizing off\n-        _resizable = false;\n-      }\n-      log_info(jvmti, table) (\"JvmtiTagMap table resized to %d\", table_size());\n-    }\n-  }\n+  _rrht_table.maybe_grow();\n@@ -193,2 +122,0 @@\n-\/\/ Serially remove entries for dead oops from the table and store dead oops'\n-\/\/ tag in objects array if provided.\n@@ -196,21 +123,7 @@\n-  int oops_removed = 0;\n-  int oops_counted = 0;\n-  for (int i = 0; i < table_size(); ++i) {\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    JvmtiTagMapEntry* entry = bucket(i);\n-    while (entry != NULL) {\n-      oops_counted++;\n-      oop l = entry->object_no_keepalive();\n-      if (l != NULL) {\n-        p = entry->next_addr();\n-      } else {\n-        \/\/ Entry has been removed.\n-        oops_removed++;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", i);\n-        jlong tag = entry->tag();\n-        *p = entry->next();\n-        free_entry(entry);\n-\n-        \/\/ collect object tags for posting JVMTI events later\n-        if (objects != NULL) {\n-          objects->append(tag);\n+  struct IsDead{\n+    GrowableArray<jlong>* _objects;\n+    IsDead(GrowableArray<jlong>* objects) : _objects(objects){}\n+    bool do_entry(JvmtiTagMapEntry const & entry, jlong tag){\n+      if ( entry.object_no_keepalive() == NULL){\n+        if(_objects!=NULL){\n+          _objects->append(tag);\n@@ -218,0 +131,1 @@\n+        return true;\n@@ -219,2 +133,1 @@\n-      \/\/ get next entry\n-      entry = *p;\n+      return false;;\n@@ -222,4 +135,2 @@\n-  }\n-\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n-                          oops_counted, oops_removed);\n+  }IsDead(objects);\n+  _rrht_table.unlink(&IsDead);\n@@ -227,0 +138,2 @@\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":70,"deletions":157,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -32,2 +35,0 @@\n-\n-\/\/ Hashtable to record oops used for JvmtiTagMap\n@@ -36,6 +37,3 @@\n-class JvmtiTagMapEntry : public HashtableEntry<WeakHandle, mtServiceability> {\n-  jlong _tag;                           \/\/ the tag\n- public:\n-  JvmtiTagMapEntry* next() const {\n-    return (JvmtiTagMapEntry*)HashtableEntry<WeakHandle, mtServiceability>::next();\n-  }\n+class JvmtiTagMapEntry : public CHeapObj<mtInternal> {\n+   WeakHandle _wh;\n+   oop _obj; \/\/ temporarily hold obj while searching\n@@ -43,3 +41,4 @@\n-  JvmtiTagMapEntry** next_addr() {\n-    return (JvmtiTagMapEntry**)HashtableEntry<WeakHandle, mtServiceability>::next_addr();\n-  }\n+  public:\n+   JvmtiTagMapEntry(oop obj);\n+   JvmtiTagMapEntry(const JvmtiTagMapEntry& src);\n+   JvmtiTagMapEntry& operator=(JvmtiTagMapEntry const&) = delete;\n@@ -47,5 +46,1 @@\n-  oop object();\n-  oop object_no_keepalive();\n-  jlong tag() const       { return _tag; }\n-  void set_tag(jlong tag) { _tag = tag; }\n-};\n+   ~JvmtiTagMapEntry();\n@@ -53,4 +48,3 @@\n-class JvmtiTagMapTable : public Hashtable<WeakHandle, mtServiceability> {\n-  enum Constants {\n-    _table_size  = 1007\n-  };\n+  void resolve();\n+  oop object() const;\n+  oop object_no_keepalive() const;\n@@ -58,3 +52,3 @@\n-private:\n-  JvmtiTagMapEntry* bucket(int i) {\n-    return (JvmtiTagMapEntry*) Hashtable<WeakHandle, mtServiceability>::bucket(i);\n+  static unsigned get_hash(JvmtiTagMapEntry const &entry)  {\n+    assert(entry._obj != NULL, \"must lookup obj to hash\");\n+    return entry._obj->identity_hash();\n@@ -63,2 +57,4 @@\n-  JvmtiTagMapEntry** bucket_addr(int i) {\n-    return (JvmtiTagMapEntry**) Hashtable<WeakHandle, mtServiceability>::bucket_addr(i);\n+  static bool equals(JvmtiTagMapEntry const & lhs, JvmtiTagMapEntry const & rhs) {\n+    oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n+    oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n+    return lhs_obj == rhs_obj;\n@@ -66,0 +62,1 @@\n+};\n@@ -67,2 +64,6 @@\n-  JvmtiTagMapEntry* new_entry(unsigned int hash, WeakHandle w, jlong tag);\n-  void free_entry(JvmtiTagMapEntry* entry);\n+  typedef\n+  ResizeableResourceHashtable <JvmtiTagMapEntry, jlong,\n+                               AnyObj::C_HEAP, mtInternal,\n+                               JvmtiTagMapEntry::get_hash,\n+                               JvmtiTagMapEntry::equals\n+                               > ResizableResourceHT ;\n@@ -70,1 +71,4 @@\n-  unsigned int compute_hash(oop obj);\n+class JvmtiTagMapTable : public CHeapObj<mtInternal> {\n+  enum Constants {\n+    _table_size  = 1007\n+  };\n@@ -72,1 +76,1 @@\n-  JvmtiTagMapEntry* find(int index, unsigned int hash, oop obj);\n+private:\n@@ -75,0 +79,1 @@\n+  ResizableResourceHT  _rrht_table;\n@@ -80,2 +85,3 @@\n-  JvmtiTagMapEntry* find(oop obj);\n-  JvmtiTagMapEntry* add(oop obj, jlong tag);\n+  jlong find(oop obj);\n+  bool add(oop obj, jlong tag);\n+\n@@ -83,1 +89,1 @@\n-  void remove(oop obj);\n+  bool remove(oop obj);\n@@ -88,1 +94,1 @@\n-  bool is_empty() const { return number_of_entries() == 0; }\n+  bool is_empty() const { return _rrht_table.number_of_entries() == 0; }\n@@ -97,2 +103,2 @@\n- public:\n-  virtual void do_entry(JvmtiTagMapEntry* entry) = 0;\n+  public:\n+  virtual bool do_entry(JvmtiTagMapEntry & key , jlong & value) = 0;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":41,"deletions":35,"binary":false,"changes":76,"status":"modified"}]}