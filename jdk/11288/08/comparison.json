{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-void JvmtiTagMap::entry_iterate(JvmtiTagMapEntryClosure* closure) {\n+void JvmtiTagMap::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n@@ -173,8 +173,1 @@\n-  JvmtiTagMapEntry* entry = tag_map->hashmap()->find(o);\n-  if (entry == NULL) {\n-    return 0;\n-  } else {\n-    jlong tag = entry->tag();\n-    assert(tag != 0, \"should not be zero\");\n-    return entry->tag();\n-  }\n+  return tag_map->hashmap()->find(o);\n@@ -183,1 +176,0 @@\n-\n@@ -194,3 +186,4 @@\n-\/\/ } \/\/ wrapper goes out of scope here which results in the destructor\n-\/\/      checking to see if the object has been tagged, untagged, or the\n-\/\/      tag value has changed.\n+\/\/ }\n+\/\/ wrapper goes out of scope here which results in the destructor\n+\/\/ checking to see if the object has been tagged, untagged, or the\n+\/\/ tag value has changed.\n@@ -202,1 +195,0 @@\n-  JvmtiTagMapEntry* _entry;\n@@ -209,1 +201,1 @@\n-  JvmtiTagMap* tag_map() const      { return _tag_map; }\n+  JvmtiTagMap* tag_map() const { return _tag_map; }\n@@ -213,1 +205,1 @@\n-                                       JvmtiTagMapEntry* entry, jlong obj_tag);\n+                                       jlong obj_tag);\n@@ -228,1 +220,0 @@\n-    _entry = _hashmap->find(_o);\n@@ -231,1 +222,1 @@\n-    _obj_tag = (_entry == NULL) ? 0 : _entry->tag();\n+    _obj_tag = _hashmap->find(_o);\n@@ -240,1 +231,1 @@\n-    post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);\n+    post_callback_tag_update(_o, _hashmap, _obj_tag);\n@@ -249,2 +240,0 @@\n-\n-\n@@ -254,1 +243,0 @@\n-                                                      JvmtiTagMapEntry* entry,\n@@ -256,1 +244,2 @@\n-  if (entry == NULL) {\n+  jlong current_tag = hashmap->find(o);\n+  if (current_tag == 0) {\n@@ -268,2 +257,2 @@\n-      if (obj_tag != entry->tag()) {\n-         entry->set_tag(obj_tag);\n+      if (obj_tag != current_tag) {\n+        hashmap->update(o, obj_tag);\n@@ -286,3 +275,4 @@\n-\/\/ } \/\/ wrapper goes out of scope here which results in the destructor\n-\/\/      checking to see if the referrer object has been tagged, untagged,\n-\/\/      or the tag value has changed.\n+\/\/ }\n+\/\/ wrapper goes out of scope here which results in the destructor\n+\/\/ checking to see if the referrer object has been tagged, untagged,\n+\/\/ or the tag value has changed.\n@@ -294,1 +284,0 @@\n-  JvmtiTagMapEntry* _referrer_entry;\n@@ -316,1 +305,0 @@\n-      _referrer_entry = _referrer_hashmap->find(_referrer);\n@@ -319,1 +307,2 @@\n-      _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry->tag();\n+      _referrer_obj_tag = _referrer_hashmap->find(_referrer);\n+\n@@ -328,1 +317,1 @@\n-    if (!is_reference_to_self()){\n+    if (!is_reference_to_self()) {\n@@ -331,1 +320,0 @@\n-                               _referrer_entry,\n@@ -338,1 +326,1 @@\n-  inline jlong* referrer_tag_p()        { return _referrer_tag_p; }\n+  inline jlong* referrer_tag_p() { return _referrer_tag_p; }\n@@ -341,1 +329,1 @@\n-  inline jlong referrer_klass_tag()     { return _referrer_klass_tag; }\n+  inline jlong referrer_klass_tag() { return _referrer_klass_tag; }\n@@ -362,1 +350,1 @@\n-  JvmtiTagMapEntry* entry = hashmap->find(o);\n+  jlong found_tag = hashmap->find(o);\n@@ -365,1 +353,1 @@\n-  if (entry == NULL) {\n+  if (found_tag == 0) {\n@@ -378,1 +366,1 @@\n-      entry->set_tag(tag);\n+      hashmap->update(o, tag);\n@@ -517,1 +505,1 @@\n-   enum {\n+  enum {\n@@ -519,1 +507,1 @@\n-   };\n+  };\n@@ -522,1 +510,1 @@\n-  ClassFieldMap* field_map() const          { return _field_map; }\n+  ClassFieldMap* field_map() const { return _field_map; }\n@@ -576,1 +564,0 @@\n-\n@@ -1242,1 +1229,1 @@\n-class TagObjectCollector : public JvmtiTagMapEntryClosure {\n+class TagObjectCollector : public JvmtiTagMapKeyClosure {\n@@ -1274,3 +1261,3 @@\n-  void do_entry(JvmtiTagMapEntry* entry) {\n-    for (int i=0; i<_tag_count; i++) {\n-      if (_tags[i] == entry->tag()) {\n+  bool do_entry(JvmtiTagMapKey& key, jlong& value) {\n+    for (int i = 0; i < _tag_count; i++) {\n+      if (_tags[i] == value) {\n@@ -1281,1 +1268,1 @@\n-        oop o = entry->object();\n+        oop o = key.object();\n@@ -1285,1 +1272,1 @@\n-          return;\n+          return true;\n@@ -1290,1 +1277,1 @@\n-        _tag_results->append((uint64_t)entry->tag());\n+        _tag_results->append(value);\n@@ -1293,0 +1280,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":38,"deletions":50,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-class JvmtiTagMapEntryClosure;\n+class JvmtiTagMapKeyClosure;\n@@ -37,1 +37,1 @@\n-class JvmtiTagMap :  public CHeapObj<mtInternal> {\n+class JvmtiTagMap :  public CHeapObj<mtServiceability> {\n@@ -56,1 +56,1 @@\n-  void entry_iterate(JvmtiTagMapEntryClosure* closure);\n+  void entry_iterate(JvmtiTagMapKeyClosure* closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n-oop JvmtiTagMapEntry::object() {\n-  return literal().resolve();\n-}\n@@ -45,4 +42,1 @@\n-oop JvmtiTagMapEntry::object_no_keepalive() {\n-  \/\/ Just peek at the object without keeping it alive.\n-  return literal().peek();\n-}\n+JvmtiTagMapKey::JvmtiTagMapKey(oop obj) : _obj(obj) {}\n@@ -50,2 +44,6 @@\n-JvmtiTagMapTable::JvmtiTagMapTable()\n-  : Hashtable<WeakHandle, mtServiceability>(_table_size, sizeof(JvmtiTagMapEntry)) {}\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) {\n+  \/\/ move object into WeakHandle when copying into the table\n+  assert(src._obj != nullptr, \"must be set\");\n+  _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n+  _obj = nullptr;\n+}\n@@ -53,12 +51,8 @@\n-void JvmtiTagMapTable::clear() {\n-  \/\/ Clear this table\n-  log_debug(jvmti, table)(\"JvmtiTagMapTable cleared\");\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* m = bucket(i); m != NULL;) {\n-      JvmtiTagMapEntry* entry = m;\n-      \/\/ read next before freeing.\n-      m = m->next();\n-      free_entry(entry);\n-    }\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    *p = NULL; \/\/ clear out buckets.\n+JvmtiTagMapKey::~JvmtiTagMapKey() {\n+  \/\/ If obj is set null it out, this is called for stack object on lookup,\n+  \/\/ and it should not have a WeakHandle created for it yet.\n+  if (_obj != nullptr) {\n+    _obj = nullptr;\n+    assert(_wh.is_null(), \"WeakHandle should be null\");\n+  } else {\n+    _wh.release(JvmtiExport::weak_tag_storage());\n@@ -66,1 +60,0 @@\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n@@ -69,3 +62,3 @@\n-JvmtiTagMapTable::~JvmtiTagMapTable() {\n-  clear();\n-  \/\/ base class ~BasicHashtable deallocates the buckets.\n+oop JvmtiTagMapKey::object() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.resolve();\n@@ -74,5 +67,3 @@\n-\/\/ Entries are C_Heap allocated\n-JvmtiTagMapEntry* JvmtiTagMapTable::new_entry(unsigned int hash, WeakHandle w, jlong tag) {\n-  JvmtiTagMapEntry* entry = (JvmtiTagMapEntry*)Hashtable<WeakHandle, mtServiceability>::new_entry(hash, w);\n-  entry->set_tag(tag);\n-  return entry;\n+oop JvmtiTagMapKey::object_no_keepalive() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.peek();\n@@ -81,4 +72,1 @@\n-void JvmtiTagMapTable::free_entry(JvmtiTagMapEntry* entry) {\n-  entry->literal().release(JvmtiExport::weak_tag_storage()); \/\/ release to OopStorage\n-  BasicHashtable<mtServiceability>::free_entry(entry);\n-}\n+JvmtiTagMapTable::JvmtiTagMapTable() : _table(Constants::_table_size) {}\n@@ -86,7 +74,7 @@\n-unsigned int JvmtiTagMapTable::compute_hash(oop obj) {\n-  assert(obj != NULL, \"obj is null\");\n-  return obj->identity_hash();\n-}\n-\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(int index, unsigned int hash, oop obj) {\n-  assert(obj != NULL, \"Cannot search for a NULL object\");\n+void JvmtiTagMapTable::clear() {\n+  struct RemoveAll {\n+    bool do_entry(const JvmtiTagMapKey& entry, const jlong& tag) {\n+      return true;\n+    }\n+  } remove_all;\n+  _table.unlink(&remove_all);\n@@ -94,2 +82,2 @@\n-  for (JvmtiTagMapEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->hash() == hash) {\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+}\n@@ -97,2 +85,3 @@\n-      \/\/ Peek the object to check if it is the right target.\n-      oop target = p->object_no_keepalive();\n+JvmtiTagMapTable::~JvmtiTagMapTable() {\n+  clear();\n+}\n@@ -100,11 +89,3 @@\n-      \/\/ The obj is in the table as a target already\n-      if (target == obj) {\n-        ResourceMark rm;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry found for %s index %d\",\n-                                obj->print_value_string(), index);\n-        \/\/ The object() accessor makes sure the target object is kept alive before\n-        \/\/ leaking out.\n-        (void)p->object();\n-        return p;\n-      }\n-    }\n+jlong JvmtiTagMapTable::find(oop obj) {\n+  if (is_empty()) {\n+    return 0;\n@@ -112,2 +93,0 @@\n-  return NULL;\n-}\n@@ -115,1 +94,0 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(oop obj) {\n@@ -118,1 +96,1 @@\n-    return NULL;\n+    return 0;\n@@ -120,14 +98,0 @@\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  return find(index, hash, obj);\n-}\n-\n-JvmtiTagMapEntry* JvmtiTagMapTable::add(oop obj, jlong tag) {\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  \/\/ One was added while acquiring the lock\n-  assert(find(index, hash, obj) == NULL, \"shouldn't already be present\");\n-\n-  \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent.\n-  \/\/ The object needs to be kept alive when it is published.\n-  Universe::heap()->keep_alive(obj);\n@@ -135,6 +99,4 @@\n-  WeakHandle w(JvmtiExport::weak_tag_storage(), obj);\n-  JvmtiTagMapEntry* p = new_entry(hash, w, tag);\n-  Hashtable<WeakHandle, mtServiceability>::add_entry(index, p);\n-  ResourceMark rm;\n-  log_trace(jvmti, table)(\"JvmtiTagMap entry added for %s index %d\",\n-                          obj->print_value_string(), index);\n+  JvmtiTagMapKey jtme(obj);\n+  jlong* found = _table.get(jtme);\n+  return found == NULL ? 0 : *found;\n+}\n@@ -142,2 +104,6 @@\n-  \/\/ Resize if the table is getting too big.\n-  resize_if_needed();\n+void JvmtiTagMapTable::add(oop obj, jlong tag) {\n+  JvmtiTagMapKey new_entry(obj);\n+  bool is_added = false;\n+  _table.put_if_absent(new_entry, tag, &is_added);\n+  assert(is_added, \"should be added\");\n+}\n@@ -145,1 +111,4 @@\n-  return p;\n+void JvmtiTagMapTable::update(oop obj, jlong tag) {\n+  JvmtiTagMapKey new_entry(obj);\n+  bool is_updated = _table.put(new_entry, tag) == false;\n+  assert(is_updated, \"should be updated and not added\");\n@@ -149,16 +118,3 @@\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  JvmtiTagMapEntry** p = bucket_addr(index);\n-  JvmtiTagMapEntry* entry = bucket(index);\n-  while (entry != NULL) {\n-    oop target = entry->object_no_keepalive();\n-    if (target != NULL && target == obj) {\n-      log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", index);\n-      *p = entry->next();\n-      free_entry(entry);\n-      return; \/\/ done\n-    }\n-    \/\/ get next entry and address\n-    p = entry->next_addr();\n-    entry = entry->next();\n-  }\n+  JvmtiTagMapKey jtme(obj);\n+  bool is_removed = _table.remove(jtme);\n+  assert(is_removed, \"remove not succesfull.\")\n@@ -167,6 +123,2 @@\n-void JvmtiTagMapTable::entry_iterate(JvmtiTagMapEntryClosure* closure) {\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      closure->do_entry(p);\n-    }\n-  }\n+void JvmtiTagMapTable::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n+  _table.iterate(closure);\n@@ -175,3 +127,0 @@\n-const int _resize_load_trigger = 5;       \/\/ load factor that will trigger the resize\n-static bool _resizable = true;\n-\n@@ -179,12 +128,1 @@\n-  if (_resizable && number_of_entries() > (_resize_load_trigger*table_size())) {\n-    int desired_size = calculate_resize(true);\n-    if (desired_size == table_size()) {\n-      _resizable = false; \/\/ hit max\n-    } else {\n-      if (!resize(desired_size)) {\n-        \/\/ Something went wrong, turn resizing off\n-        _resizable = false;\n-      }\n-      log_info(jvmti, table) (\"JvmtiTagMap table resized to %d\", table_size());\n-    }\n-  }\n+  _table.maybe_grow();\n@@ -193,2 +131,0 @@\n-\/\/ Serially remove entries for dead oops from the table and store dead oops'\n-\/\/ tag in objects array if provided.\n@@ -196,21 +132,7 @@\n-  int oops_removed = 0;\n-  int oops_counted = 0;\n-  for (int i = 0; i < table_size(); ++i) {\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    JvmtiTagMapEntry* entry = bucket(i);\n-    while (entry != NULL) {\n-      oops_counted++;\n-      oop l = entry->object_no_keepalive();\n-      if (l != NULL) {\n-        p = entry->next_addr();\n-      } else {\n-        \/\/ Entry has been removed.\n-        oops_removed++;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", i);\n-        jlong tag = entry->tag();\n-        *p = entry->next();\n-        free_entry(entry);\n-\n-        \/\/ collect object tags for posting JVMTI events later\n-        if (objects != NULL) {\n-          objects->append(tag);\n+  struct IsDead {\n+    GrowableArray<jlong>* _objects;\n+    IsDead(GrowableArray<jlong>* objects) : _objects(objects) {}\n+    bool do_entry(const JvmtiTagMapKey& entry, jlong tag) {\n+      if (entry.object_no_keepalive() == NULL) {\n+        if (_objects != NULL) {\n+          _objects->append(tag);\n@@ -218,0 +140,1 @@\n+        return true;\n@@ -219,2 +142,1 @@\n-      \/\/ get next entry\n-      entry = *p;\n+      return false;;\n@@ -222,4 +144,2 @@\n-  }\n-\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n-                          oops_counted, oops_removed);\n+  } is_dead(objects);\n+  _table.unlink(&is_dead);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":70,"deletions":150,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -32,6 +35,12 @@\n-\n-\/\/ Hashtable to record oops used for JvmtiTagMap\n-class JvmtiTagMapEntryClosure;\n-\n-class JvmtiTagMapEntry : public HashtableEntry<WeakHandle, mtServiceability> {\n-  jlong _tag;                           \/\/ the tag\n+class JvmtiTagMapKeyClosure;\n+\n+\/\/ The oop is needed for lookup rather than creating a WeakHandle during\n+\/\/ lookup because the HeapWalker may walk soon to be dead objects and\n+\/\/ creating a WeakHandle for an otherwise dead object makes G1 unhappy.\n+\/\/\n+\/\/ This class is the Key type for inserting in ResizeableResourceHashTable\n+\/\/ Its get_hash() and equals() methods are also used for getting the hash\n+\/\/ value of a Key and comparing two Keys, respectively.\n+class JvmtiTagMapKey : public CHeapObj<mtServiceability> {\n+  WeakHandle _wh;\n+  oop _obj; \/\/ temporarily hold obj while searching\n@@ -39,3 +48,3 @@\n-  JvmtiTagMapEntry* next() const {\n-    return (JvmtiTagMapEntry*)HashtableEntry<WeakHandle, mtServiceability>::next();\n-  }\n+  JvmtiTagMapKey(oop obj);\n+  JvmtiTagMapKey(const JvmtiTagMapKey& src);\n+  JvmtiTagMapKey& operator=(const JvmtiTagMapKey&) = delete;\n@@ -43,3 +52,1 @@\n-  JvmtiTagMapEntry** next_addr() {\n-    return (JvmtiTagMapEntry**)HashtableEntry<WeakHandle, mtServiceability>::next_addr();\n-  }\n+  ~JvmtiTagMapKey();\n@@ -47,5 +54,3 @@\n-  oop object();\n-  oop object_no_keepalive();\n-  jlong tag() const       { return _tag; }\n-  void set_tag(jlong tag) { _tag = tag; }\n-};\n+  void resolve();\n+  oop object() const;\n+  oop object_no_keepalive() const;\n@@ -53,8 +58,3 @@\n-class JvmtiTagMapTable : public Hashtable<WeakHandle, mtServiceability> {\n-  enum Constants {\n-    _table_size  = 1007\n-  };\n-\n-private:\n-  JvmtiTagMapEntry* bucket(int i) {\n-    return (JvmtiTagMapEntry*) Hashtable<WeakHandle, mtServiceability>::bucket(i);\n+  static unsigned get_hash(const JvmtiTagMapKey& entry) {\n+    assert(entry._obj != NULL, \"must lookup obj to hash\");\n+    return entry._obj->identity_hash();\n@@ -63,2 +63,4 @@\n-  JvmtiTagMapEntry** bucket_addr(int i) {\n-    return (JvmtiTagMapEntry**) Hashtable<WeakHandle, mtServiceability>::bucket_addr(i);\n+  static bool equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n+    oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n+    oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n+    return lhs_obj == rhs_obj;\n@@ -66,0 +68,1 @@\n+};\n@@ -67,4 +70,5 @@\n-  JvmtiTagMapEntry* new_entry(unsigned int hash, WeakHandle w, jlong tag);\n-  void free_entry(JvmtiTagMapEntry* entry);\n-\n-  unsigned int compute_hash(oop obj);\n+typedef\n+ResizeableResourceHashtable <JvmtiTagMapKey, jlong,\n+                              AnyObj::C_HEAP, mtServiceability,\n+                              JvmtiTagMapKey::get_hash,\n+                              JvmtiTagMapKey::equals> ResizableResourceHT;\n@@ -72,1 +76,4 @@\n-  JvmtiTagMapEntry* find(int index, unsigned int hash, oop obj);\n+class JvmtiTagMapTable : public CHeapObj<mtServiceability> {\n+ enum Constants {\n+  _table_size  = 1007\n+ };\n@@ -74,0 +81,1 @@\n+ private:\n@@ -75,0 +83,1 @@\n+  ResizableResourceHT _table;\n@@ -76,1 +85,1 @@\n-public:\n+ public:\n@@ -80,2 +89,3 @@\n-  JvmtiTagMapEntry* find(oop obj);\n-  JvmtiTagMapEntry* add(oop obj, jlong tag);\n+  jlong find(oop obj);\n+  void add(oop obj, jlong tag);\n+  void update(oop obj, jlong tag);\n@@ -86,1 +96,1 @@\n-  void entry_iterate(JvmtiTagMapEntryClosure* closure);\n+  void entry_iterate(JvmtiTagMapKeyClosure* closure);\n@@ -88,1 +98,1 @@\n-  bool is_empty() const { return number_of_entries() == 0; }\n+  bool is_empty() const { return _table.number_of_entries() == 0; }\n@@ -96,1 +106,1 @@\n-class JvmtiTagMapEntryClosure {\n+class JvmtiTagMapKeyClosure {\n@@ -98,1 +108,1 @@\n-  virtual void do_entry(JvmtiTagMapEntry* entry) = 0;\n+  virtual bool do_entry(JvmtiTagMapKey& key, jlong& value) = 0;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"}]}