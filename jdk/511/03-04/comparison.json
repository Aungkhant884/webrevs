{"files":[{"patch":"@@ -239,2 +239,6 @@\n-\/\/ Get a bitmask for expression: \"(a & 0xFF) << 8\" -> 0xFF00\n-static juint get_bitmask(PhaseGVN *phase, Node* value) {\n+\/\/ Assuming only And, Or and Shift (and also their replacement BitfieldInsert) are involved\n+\/\/ in the expression, compute a bit mask covering all possible values of the expression.\n+\/\/ Mask information can be used in\n+\/\/ - Add into Or conversion (when value range masks of Add arguments do not intersect)\n+\/\/ - Or(And+Shift,And+Shift) into BitfieldInsert conversion (when masks of Or arguments do not intersect)\n+static juint value_range_mask(PhaseGVN *phase, Node* value) {\n@@ -244,1 +248,1 @@\n-    return get_bitmask(phase, value->in(1)) << lshift;\n+    return value_range_mask(phase, value->in(1)) << lshift;\n@@ -251,1 +255,1 @@\n-    return mask | get_bitmask(phase, value->in(1));\n+    return mask | value_range_mask(phase, value->in(1));\n@@ -253,2 +257,2 @@\n-    return get_bitmask(phase, value->in(1)) |\n-           get_bitmask(phase, value->in(2));\n+    return value_range_mask(phase, value->in(1)) |\n+           value_range_mask(phase, value->in(2));\n@@ -259,1 +263,3 @@\n-static julong get_bitmaskL(PhaseGVN *phase, Node* value) {\n+\/\/ Assuming only AndL, OrL and ShiftL (and also their replacement BitfieldInsertL) are involved\n+\/\/ in the expression, compute a bit mask covering all possible values of the expression.\n+static julong value_range_maskL(PhaseGVN *phase, Node* value) {\n@@ -263,1 +269,1 @@\n-    return get_bitmaskL(phase, value->in(1)) << lshift;\n+    return value_range_maskL(phase, value->in(1)) << lshift;\n@@ -270,1 +276,1 @@\n-    return mask | get_bitmaskL(phase, value->in(1));\n+    return mask | value_range_maskL(phase, value->in(1));\n@@ -272,2 +278,2 @@\n-    return get_bitmaskL(phase, value->in(1)) |\n-           get_bitmaskL(phase, value->in(2));\n+    return value_range_maskL(phase, value->in(1)) |\n+           value_range_maskL(phase, value->in(2));\n@@ -363,4 +369,4 @@\n-  \/\/ Convert \"((a & 0xFF) << 8) + (b & 0xFF)\" into \"((a & 0xFF) << 8) | (b & 0xFF)\"\n-  int bitmask1 = get_bitmask(phase, in(1));\n-  int bitmask2 = get_bitmask(phase, in(2));\n-  if ((bitmask1 & bitmask2) == 0) {\n+  \/\/ Convert \"a + b\" into \"a | b\" when value range masks do not intersect\n+  int mask1 = value_range_mask(phase, in(1));\n+  int mask2 = value_range_mask(phase, in(2));\n+  if ((mask1 & mask2) == 0) {\n@@ -487,4 +493,4 @@\n-  \/\/ Convert \"((a & 0xFF) << 8) + (b & 0xFF)\" into \"((a & 0xFF) << 8) | (b & 0xFF)\"\n-  julong bitmask1 = get_bitmaskL(phase, in(1));\n-  julong bitmask2 = get_bitmaskL(phase, in(2));\n-  if ((bitmask1 & bitmask2) == 0) {\n+  \/\/ Convert \"a + b\" into \"a | b\" when value range masks do not intersect\n+  julong mask1 = value_range_maskL(phase, in(1));\n+  julong mask2 = value_range_maskL(phase, in(2));\n+  if ((mask1 & mask2) == 0) {\n@@ -848,1 +854,3 @@\n-    \/\/ Convert Or(v1, Shift(And(v2, 0xFF), shift)) into BitfieldInsert(dst, src, width, offset)\n+    \/\/ Perform the following transformations if the Or argument value range masks do not overlap:\n+    \/\/   \"dst | (value & shift)\" into BitfieldInsert(dst, value, width, 0)\n+    \/\/   \"dst | ((value & shift) << offset)\" into BitfieldInsert(dst, value, width, offset)\n@@ -861,1 +869,1 @@\n-        if (width + offset <= 32 && ((get_bitmask(phase, dst) & mask) == 0)) {\n+        if (width + offset <= 32 && ((value_range_mask(phase, dst) & mask) == 0)) {\n@@ -950,1 +958,1 @@\n-        if (width + offset <= 64 && ((get_bitmaskL(phase, dst) & mask) == 0)) {\n+        if (width + offset <= 64 && ((value_range_maskL(phase, dst) & mask) == 0)) {\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"}]}