{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,0 +238,39 @@\n+\/\/---------------------------Bitmask helper------------------------------------\n+\/\/ Get a bitmask for expression: \"(a & 0xFF) << 8\" -> 0xFF00\n+static juint get_bitmask(PhaseGVN *phase, Node* value) {\n+  int opcode = value->Opcode();\n+  if (opcode == Op_LShiftI && value->in(2)->is_Con()) {\n+    int lshift = phase->type(value->in(2))->is_int()->get_con();\n+    return get_bitmask(phase, value->in(1)) << lshift;\n+  } else if (opcode == Op_AndI && value->in(2)->is_Con()) {\n+    return phase->type(value->in(2))->is_int()->get_con();\n+  } else if (opcode == Op_BitfieldInsertI) {\n+    int width = value->in(3)->get_int();\n+    int offset = value->in(4)->get_int();\n+    int mask = ((1 << width) - 1) << offset;\n+    return mask | get_bitmask(phase, value->in(1));\n+  } else if (opcode == Op_OrI) {\n+    return get_bitmask(phase, value->in(1)) |\n+           get_bitmask(phase, value->in(2));\n+  }\n+  return 0xFFFFFFFF;\n+}\n+\n+static julong get_bitmaskL(PhaseGVN *phase, Node* value) {\n+  int opcode = value->Opcode();\n+  if (opcode == Op_LShiftL && value->in(2)->is_Con()) {\n+    int lshift = phase->type(value->in(2))->is_int()->get_con();\n+    return get_bitmaskL(phase, value->in(1)) << lshift;\n+  } else if (opcode == Op_AndL && value->in(2)->is_Con()) {\n+    return value->in(2)->get_long();\n+  } else if (opcode == Op_BitfieldInsertL) {\n+    int width = value->in(3)->get_int();\n+    int offset = value->in(4)->get_int();\n+    julong mask = ((1L << width) - 1) << offset;\n+    return mask | get_bitmaskL(phase, value->in(1));\n+  } else if (opcode == Op_OrL) {\n+    return get_bitmaskL(phase, value->in(1)) |\n+           get_bitmaskL(phase, value->in(2));\n+  }\n+  return CONST64(0xFFFFFFFFFFFFFFFF);\n+}\n@@ -324,0 +363,7 @@\n+  \/\/ Convert \"((a & 0xFF) << 8) + (b & 0xFF)\" into \"((a & 0xFF) << 8) | (b & 0xFF)\"\n+  int bitmask1 = get_bitmask(phase, in(1));\n+  int bitmask2 = get_bitmask(phase, in(2));\n+  if ((bitmask1 & bitmask2) == 0) {\n+    return new OrINode(in(1), in(2));\n+  }\n+\n@@ -441,0 +487,7 @@\n+  \/\/ Convert \"((a & 0xFF) << 8) + (b & 0xFF)\" into \"((a & 0xFF) << 8) | (b & 0xFF)\"\n+  julong bitmask1 = get_bitmaskL(phase, in(1));\n+  julong bitmask2 = get_bitmaskL(phase, in(2));\n+  if ((bitmask1 & bitmask2) == 0) {\n+    return new OrLNode(in(1), in(2));\n+  }\n+\n@@ -767,24 +820,0 @@\n-\/\/ Check if (offset,width) bitrange contains only zero bits in the value, the goal is\n-\/\/ to prove that bitranges do not overlap in expressions like \"((v1 & 0xFF) << 8) | (v2 & 0xFF)\"\n-static bool is_bitrange_zero(PhaseGVN *phase, Node* value, int offset, int width) {\n-  int opcode = value->Opcode();\n-  if (opcode == Op_LShiftI && value->in(2)->is_Con()) {\n-    int lshift = value->in(2)->get_int();\n-    return (lshift >= offset + width) || is_bitrange_zero(phase, value->in(1), offset - lshift, width);\n-  } else if (opcode == Op_AndI && value->in(2)->is_Con()) {\n-    int mask1 = value->in(2)->get_int();\n-    int mask2 = ((1 << width) - 1) << offset;\n-    return (mask1 & mask2) == 0;\n-  } else if (opcode == Op_BitfieldInsertI) {\n-    int width1 = value->in(3)->get_int();\n-    int offset1 = value->in(4)->get_int();\n-    if (offset >= offset1 + width1 || offset1 >= offset + width) {\n-      return is_bitrange_zero(phase, value->in(1), offset, width);\n-    }\n-  } else if (opcode == Op_OrI) {\n-    return is_bitrange_zero(phase, value->in(1), offset, width) &\n-           is_bitrange_zero(phase, value->in(2), offset, width);\n-  }\n-  return false;\n-}\n-\n@@ -831,1 +860,2 @@\n-        if (width + offset <= 32 && is_bitrange_zero(phase, dst, offset, width)) {\n+        int mask = ((1 << width) - 1) << offset;\n+        if (width + offset <= 32 && ((get_bitmask(phase, dst) & mask) == 0)) {\n@@ -881,22 +911,0 @@\n-static bool is_bitrangeL_zero(PhaseGVN *phase, Node* value, int offset, int width) {\n-  int opcode = value->Opcode();\n-  if (opcode == Op_LShiftL && value->in(2)->is_Con()) {\n-    int lshift = value->in(2)->get_int();\n-    return (lshift >= offset + width) || is_bitrangeL_zero(phase, value->in(1), offset - lshift, width);\n-  } else if (opcode == Op_AndL && value->in(2)->is_Con()) {\n-    jlong mask1 = value->in(2)->get_long();\n-    jlong mask2 = ((1L << width) - 1) << offset;\n-    return (mask1 & mask2) == 0;\n-  } else if (opcode == Op_BitfieldInsertL) {\n-    int width1 = value->in(3)->get_int();\n-    int offset1 = value->in(4)->get_int();\n-    if (offset >= offset1 + width1 || offset1 >= offset + width) {\n-      return is_bitrangeL_zero(phase, value->in(1), offset, width);\n-    }\n-  } else if (opcode == Op_OrL) {\n-    return is_bitrange_zero(phase, value->in(1), offset, width) &\n-           is_bitrange_zero(phase, value->in(2), offset, width);\n-  }\n-  return false;\n-}\n-\n@@ -940,2 +948,3 @@\n-        int width = exact_log2_long(mask->get_long() + 1);\n-        if (width + offset <= 64 && is_bitrangeL_zero(phase, dst, offset, width)) {\n+        julong width = exact_log2_long(mask->get_long() + 1);\n+        julong mask = ((1L << width) - 1) << offset;\n+        if (width + offset <= 64 && ((get_bitmaskL(phase, dst) & mask) == 0)) {\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":59,"deletions":50,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+            runTest(\"ColorPlus::<init>\",    ColorPlus.instrCount,    ColorPlus.useBFI);\n+            runTest(\"ColorLongPlus::<init>\",ColorLongPlus.instrCount,ColorLongPlus.useBFI);\n@@ -90,0 +92,10 @@\n+            case \"ColorPlus::<init>\":\n+                for (int i = 0; i < ITER; i++) {\n+                    new ColorPlus(i, i, i, i);\n+                }\n+                break;\n+            case \"ColorLongPlus::<init>\":\n+                for (int i = 0; i < ITER; i++) {\n+                    new ColorLongPlus(i, i, i, i);\n+                }\n+                break;\n@@ -136,0 +148,34 @@\n+\/\/ the same but PLUS instead of OR\n+class ColorPlus {\n+    int value;\n+    public ColorPlus(int r, int g, int b, int a) {\n+        \/\/ 1. lsl   w11, w5, #24\n+        \/\/ 2. bfi   x11, x2, #16, #8\n+        \/\/ 3. bfi   x11, x3, #8, #8\n+        \/\/ 4. bfxil x11, x4, #0, #8\n+        value = ((a & 0xFF) << 24) +\n+                ((r & 0xFF) << 16) +\n+                ((g & 0xFF) << 8)  +\n+                ((b & 0xFF) << 0);\n+    }\n+    static int instrCount = 4;\n+    static boolean useBFI = true;\n+}\n+\n+\/\/ same for long type\n+class ColorLongPlus {\n+    long value;\n+    public ColorLongPlus(long r, long g, long b, long a) {\n+        \/\/ 1. lsl   w11, w5, #24\n+        \/\/ 2. bfi   x11, x2, #16, #8\n+        \/\/ 3. bfi   x11, x3, #8, #8\n+        \/\/ 4. bfxil x11, x4, #0, #8\n+        value = ((a & 0xFF) << 24) +\n+                ((r & 0xFF) << 16) +\n+                ((g & 0xFF) << 8)  +\n+                ((b & 0xFF) << 0);\n+    }\n+    static int instrCount = 4;\n+    static boolean useBFI = true;\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestBFI.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}