{"files":[{"patch":"@@ -850,0 +850,21 @@\n+    \/\/ If the right input of this Or is an And with mask or an LShifted\n+    \/\/ And with mask with constant shift and the left and right inputs\n+    \/\/ can be determined to construct values lying in disjoint bit ranges\n+    \/\/ then the Or can be replaced with BitfieldInsert.\n+    \/\/\n+    \/\/ There are two substitution rules:\n+    \/\/\n+    \/\/ 1) (Or left (And value mask)) => (BitfieldInsert left value width 0))\n+    \/\/    where width == bitcount(mask) AND\n+    \/\/          (value_range_mask(left) & mask) == 0\n+    \/\/\n+    \/\/ 2) (Or left (LShift (And value mask) offset) => (BitfieldInsert left value width 0)\n+    \/\/    where width == bitcount(mask) AND\n+    \/\/          (value_range_mask(left) & (mask << offset)) == 0\n+    \/\/ n.b.\n+    \/\/ mask is an integer constant comprising a contiguous sequence of 1s\n+    \/\/ value_range_mask(node) computes a mask identifying the range of bits\n+    \/\/ that could be set by its argument\n+\n+    Node *left = in(1);\n+    Node *right = in(2);\n@@ -851,2 +872,0 @@\n-    Node *dst = in(1);\n-    Node *src = in(2);\n@@ -854,8 +873,6 @@\n-    \/\/ Perform the following transformations if the Or argument value range masks do not overlap:\n-    \/\/   \"dst | (value & shift)\" into BitfieldInsert(dst, value, width, 0)\n-    \/\/   \"dst | ((value & shift) << offset)\" into BitfieldInsert(dst, value, width, offset)\n-    if (src->Opcode() == Op_LShiftI && src->in(1)->Opcode() == Op_AndI && src->in(2)->is_Con()) {\n-      andi   = src->in(1);\n-      offset = src->in(2)->get_int();\n-    } else if (src->Opcode() == Op_AndI) {\n-      andi = src;\n+\n+    if (right->Opcode() == Op_LShiftI && right->in(1)->Opcode() == Op_AndI && right->in(2)->is_Con()) {\n+      andi   = right->in(1);\n+      offset = right->in(2)->get_int();\n+    } else if (right->Opcode() == Op_AndI) {\n+      andi = right;\n@@ -863,0 +880,1 @@\n+\n@@ -864,2 +882,1 @@\n-      Node* value = andi->in(1);\n-      Node* mask  = andi->in(2);\n+      Node* mask = andi->in(2);\n@@ -867,0 +884,1 @@\n+        Node* value = andi->in(1);\n@@ -868,3 +886,3 @@\n-        int mask = ((1 << width) - 1) << offset;\n-        if (width + offset <= 32 && ((value_range_mask(phase, dst) & mask) == 0)) {\n-          return new BitfieldInsertINode(dst, value, phase->intcon(offset), phase->intcon(width));\n+        int maskval = ((1 << width) - 1) << offset;\n+        if (width + offset <= 32 && ((value_range_mask(phase, left) & maskval) == 0)) {\n+          return new BitfieldInsertINode(left, value, phase->intcon(offset), phase->intcon(width));\n@@ -942,0 +960,5 @@\n+    \/\/ OrL can be replaced with BitfieldInsertL if the right and left inputs\n+    \/\/ can be determined to construct values lying in disjoint bit ranges.\n+    \/\/ See OrINode::Ideal for details.\n+    Node *left = in(1);\n+    Node *right = in(2);\n@@ -943,2 +966,0 @@\n-    Node *dst = in(1);\n-    Node *src = in(2);\n@@ -946,5 +967,6 @@\n-    if (src->Opcode() == Op_LShiftL && src->in(1)->Opcode() == Op_AndL && src->in(2)->is_Con()) {\n-      andl   = src->in(1);\n-      offset = src->in(2)->get_int();\n-    } else if (src->Opcode() == Op_AndL) {\n-      andl = src;\n+\n+    if (right->Opcode() == Op_LShiftL && right->in(1)->Opcode() == Op_AndL && right->in(2)->is_Con()) {\n+      andl   = right->in(1);\n+      offset = right->in(2)->get_int();\n+    } else if (right->Opcode() == Op_AndL) {\n+      andl = right;\n@@ -952,0 +974,1 @@\n+\n@@ -953,2 +976,1 @@\n-      Node* value = andl->in(1);\n-      Node* mask  = andl->in(2);\n+      Node* mask = andl->in(2);\n@@ -956,0 +978,1 @@\n+        Node* value = andl->in(1);\n@@ -957,3 +980,3 @@\n-        julong mask = ((1L << width) - 1) << offset;\n-        if (width + offset <= 64 && ((value_range_maskL(phase, dst) & mask) == 0)) {\n-          return new BitfieldInsertLNode(dst, value, phase->intcon(offset), phase->intcon(width));\n+        julong maskval = ((1L << width) - 1) << offset;\n+        if (width + offset <= 64 && ((value_range_maskL(phase, left) & maskval) == 0)) {\n+          return new BitfieldInsertLNode(left, value, phase->intcon(offset), phase->intcon(width));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":50,"deletions":27,"binary":false,"changes":77,"status":"modified"}]}