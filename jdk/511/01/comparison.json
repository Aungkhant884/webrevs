{"files":[{"patch":"@@ -12660,0 +12660,26 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bfiI(iRegINoSp dst, iRegINoSp src, immI lsb, immI width)\n+%{\n+  match(Set dst (BitfieldInsertI (Binary dst src) (Binary lsb width)));\n+  ins_cost(INSN_COST);\n+  format %{ \"bfi $dst, $src, #$lsb, #$width\" %}\n+  ins_encode %{\n+    __ bfi(as_Register($dst$$reg), as_Register($src$$reg), $lsb$$constant, $width$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bfiL(iRegLNoSp dst, iRegLNoSp src, immI lsb, immI width)\n+%{\n+  match(Set dst (BitfieldInsertL (Binary dst src) (Binary lsb width)));\n+  ins_cost(INSN_COST);\n+  format %{ \"bfi $dst, $src, #$lsb, #$width\" %}\n+  ins_encode %{\n+    __ bfi(as_Register($dst$$reg), as_Register($src$$reg), $lsb$$constant, $width$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -304,0 +304,15 @@\n+define(`BFI_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bfi$1(iReg$1NoSp dst, iReg$1NoSp src, immI lsb, immI width)\n+%{\n+  match(Set dst (BitfieldInsert$1 (Binary dst src) (Binary lsb width)));\n+  ins_cost(INSN_COST);\n+  format %{ \"bfi $dst, $src, #$lsb, #$width\" %}\n+  ins_encode %{\n+    __ bfi(as_Register($dst$$reg), as_Register($src$$reg), $lsb$$constant, $width$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+')dnl\n+BFI_INSN(I)\n+BFI_INSN(L)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_ad.m4","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -767,0 +767,24 @@\n+\/\/ Check if (offset,width) bitrange contains only zero bits in the value, the goal is\n+\/\/ to prove that bitranges do not overlap in expressions like \"((v1 & 0xFF) << 8) | (v2 & 0xFF)\"\n+static bool is_bitrange_zero(PhaseGVN *phase, Node* value, int offset, int width) {\n+  int opcode = value->Opcode();\n+  if (opcode == Op_LShiftI && value->in(2)->is_Con()) {\n+    int lshift = value->in(2)->get_int();\n+    return (lshift >= offset + width) || is_bitrange_zero(phase, value->in(1), offset - lshift, width);\n+  } else if (opcode == Op_AndI && value->in(2)->is_Con()) {\n+    int mask1 = value->in(2)->get_int();\n+    int mask2 = ((1 << width) - 1) << offset;\n+    return (mask1 & mask2) == 0;\n+  } else if (opcode == Op_BitfieldInsertI) {\n+    int width1 = value->in(3)->get_int();\n+    int offset1 = value->in(4)->get_int();\n+    if (offset >= offset1 + width1 || offset1 >= offset + width) {\n+      return is_bitrange_zero(phase, value->in(1), offset, width);\n+    }\n+  } else if (opcode == Op_OrI) {\n+    return is_bitrange_zero(phase, value->in(1), offset, width) &\n+           is_bitrange_zero(phase, value->in(2), offset, width);\n+  }\n+  return false;\n+}\n+\n@@ -789,0 +813,24 @@\n+  \/\/ major_progress() check postpones the transformation after loop optimization\n+  if (can_reshape && !phase->C->major_progress() && Matcher::match_rule_supported(Op_BitfieldInsertI)) {\n+    Node *andi = NULL;\n+    Node *dst = in(1);\n+    Node *src = in(2);\n+    int offset = 0;\n+    \/\/ Convert Or(v1, Shift(And(v2, 0xFF), shift)) into BitfieldInsert(dst, src, width, offset)\n+    if (src->Opcode() == Op_LShiftI && src->in(1)->Opcode() == Op_AndI && src->in(2)->is_Con()) {\n+      andi   = src->in(1);\n+      offset = src->in(2)->get_int();\n+    } else if (src->Opcode() == Op_AndI) {\n+      andi = src;\n+    }\n+    if (andi != NULL) {\n+      Node* value = andi->in(1);\n+      Node* mask  = andi->in(2);\n+      if (mask->is_Con() && is_power_of_2(mask->get_int() + 1)) {\n+        int width = exact_log2(mask->get_int() + 1);\n+        if (width + offset <= 32 && is_bitrange_zero(phase, dst, offset, width)) {\n+          return new BitfieldInsertINode(dst, value, phase->intcon(offset), phase->intcon(width));\n+        }\n+      }\n+    }\n+  }\n@@ -833,0 +881,22 @@\n+static bool is_bitrangeL_zero(PhaseGVN *phase, Node* value, int offset, int width) {\n+  int opcode = value->Opcode();\n+  if (opcode == Op_LShiftL && value->in(2)->is_Con()) {\n+    int lshift = value->in(2)->get_int();\n+    return (lshift >= offset + width) || is_bitrangeL_zero(phase, value->in(1), offset - lshift, width);\n+  } else if (opcode == Op_AndL && value->in(2)->is_Con()) {\n+    jlong mask1 = value->in(2)->get_long();\n+    jlong mask2 = ((1L << width) - 1) << offset;\n+    return (mask1 & mask2) == 0;\n+  } else if (opcode == Op_BitfieldInsertL) {\n+    int width1 = value->in(3)->get_int();\n+    int offset1 = value->in(4)->get_int();\n+    if (offset >= offset1 + width1 || offset1 >= offset + width) {\n+      return is_bitrangeL_zero(phase, value->in(1), offset, width);\n+    }\n+  } else if (opcode == Op_OrL) {\n+    return is_bitrange_zero(phase, value->in(1), offset, width) &\n+           is_bitrange_zero(phase, value->in(2), offset, width);\n+  }\n+  return false;\n+}\n+\n@@ -855,0 +925,22 @@\n+  if (can_reshape && !phase->C->major_progress() && Matcher::match_rule_supported(Op_BitfieldInsertL)) {\n+    Node *andl = NULL;\n+    Node *dst = in(1);\n+    Node *src = in(2);\n+    int offset = 0;\n+    if (src->Opcode() == Op_LShiftL && src->in(1)->Opcode() == Op_AndL && src->in(2)->is_Con()) {\n+      andl   = src->in(1);\n+      offset = src->in(2)->get_int();\n+    } else if (src->Opcode() == Op_AndL) {\n+      andl = src;\n+    }\n+    if (andl != NULL) {\n+      Node* value = andl->in(1);\n+      Node* mask  = andl->in(2);\n+      if (mask->is_Con() && is_power_of_2(mask->get_long() + 1)) {\n+        int width = exact_log2_long(mask->get_long() + 1);\n+        if (width + offset <= 64 && is_bitrangeL_zero(phase, dst, offset, width)) {\n+          return new BitfieldInsertLNode(dst, value, phase->intcon(offset), phase->intcon(width));\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+macro(BitfieldInsertI)\n+macro(BitfieldInsertL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1999,0 +1999,21 @@\n+\/\/ execute posponed transformations\n+void Compile::post_optimize_loops_igvn(PhaseIterGVN& igvn) {\n+  Unique_Node_List worklist;\n+  worklist.push(root());\n+  for (uint next = 0; next < worklist.size(); ++next) {\n+    Node *n = worklist.at(next);\n+    int opcode = n->Opcode();\n+    \/\/ OrI\/OrL: Or+Shift+And -> BitfieldInsert transformation\n+    if (opcode == Op_OrI || opcode == Op_OrL) {\n+      igvn._worklist.push(n);\n+    }\n+    uint max = n->len();\n+    for (uint i = 0; i < max; ++i) {\n+      Node *m = n->in(i);\n+      if (not_a_node(m))  continue;\n+      worklist.push(m);\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2211,0 +2232,2 @@\n+  post_optimize_loops_igvn(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -970,0 +970,1 @@\n+  void post_optimize_loops_igvn(PhaseIterGVN& igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2294,0 +2294,2 @@\n+    case Op_BitfieldInsertI:\n+    case Op_BitfieldInsertL:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,20 @@\n+\/\/-------------------------- BitfieldInsertINode ------------------------------\n+\/\/ BitfieldInsert copies a bitfield from the least significant bits of the src to\n+\/\/ bit position lsb of the dst, leaving the other destination bits unchanged.\n+class BitfieldInsertINode : public Node {\n+public:\n+  BitfieldInsertINode(Node *src, Node *dst, Node *lsb, Node *width) : Node(0, src, dst, lsb, width) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/-------------------------- BitfieldInsertLNode ------------------------------\n+class BitfieldInsertLNode : public Node {\n+public:\n+  BitfieldInsertLNode(Node *src, Node *dst, Node *lsb, Node *width) : Node(0, src, dst, lsb, width) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2020, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8249893\n+ * @summary C2 should use BFI instruction for (var1 & 0xFF) | ((var1 & 0xFF) << 8) expressions\n+ * @library \/test\/lib \/\n+ *\n+ * @run main\/othervm compiler.c2.aarch64.TestBFI\n+ *\n+ * @requires os.arch==\"aarch64\" & vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n+ *\/\n+public class TestBFI {\n+\n+    static void runTest(String testName, int expectedCommandsNumber, boolean useBFI) throws Exception {\n+        String className = \"compiler.c2.aarch64.TestBFI\";\n+        String[] procArgs = {\n+            \"-XX:+PrintOptoAssembly\", \"-XX:-TieredCompilation\", \"-Xbatch\",\n+            \"-XX:CompileCommand=compileonly,compiler.c2.aarch64.\" + testName,\n+            className, testName};\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        String bitManipulation = \".*(bfi|lsl|andsw|orrw).*\";\n+        System.out.println(testName + \" instructions:\");\n+        output.asLines().stream().filter(it -> it.matches(bitManipulation)).forEach(System.out::println);\n+\n+        long count = output.asLines().stream().filter(it -> it.matches(bitManipulation)).count();\n+        if (expectedCommandsNumber != count) {\n+            output.outputTo(System.out);\n+            throw new RuntimeException(\"unexpected instructions count: \" + count);\n+        }\n+\n+        if (useBFI) {\n+          output.shouldContain(\"bfi\");\n+        }\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static final int ITER = 40_000; \/\/ ~ Tier4CompileThreshold + compilation time\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Fork VMs to check their debug compiler output\n+            runTest(\"Color::<init>\",        Color.instrCount,        Color.useBFI);\n+            runTest(\"ColorReverse::<init>\", ColorReverse.instrCount, ColorReverse.useBFI);\n+            runTest(\"BigDecimal::mulsub\",   BigDecimal.instrCount,   BigDecimal.useBFI);\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM to execute the named test\n+            String testName = args[0];\n+            switch (testName) {\n+            case \"Color::<init>\":\n+                for (int i = 0; i < ITER; i++) {\n+                    new Color(i, i, i, i);\n+                }\n+                break;\n+            case \"ColorReverse::<init>\":\n+                for (int i = 0; i < ITER; i++) {\n+                    new ColorReverse(i, i, i, i, 0);\n+                }\n+                break;\n+            case \"BigDecimal::mulsub\":\n+                for (int i = 0; i < ITER; i++) {\n+                    BigDecimal.mulsub(i, i, i, i, i);\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"unexpected test name \" + testName);\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ java.awt.Color usecase\n+class Color {\n+    int value;\n+    public Color(int r, int g, int b, int a) {\n+        \/\/ 1. lsl   w11, w5, #24\n+        \/\/ 2. bfi   x11, x2, #16, #8\n+        \/\/ 3. bfi   x11, x3, #8, #8\n+        \/\/ 4. bfxil x11, x4, #0, #8\n+        value = ((a & 0xFF) << 24) |\n+                ((r & 0xFF) << 16) |\n+                ((g & 0xFF) << 8)  |\n+                ((b & 0xFF) << 0);\n+    }\n+    static int instrCount = 4;\n+    static boolean useBFI = true;\n+}\n+\n+\/\/ reverse byte order\n+class ColorReverse {\n+    int value;\n+    public ColorReverse(int r, int g, int b, int a, int dummy) {\n+        \/\/ 1. and  w11, w4, #0xff\n+        \/\/ 2. bfi  x11, x3, #8, #8\n+        \/\/ 3. bfi  x11, x2, #16, #8\n+        \/\/ 4. orr  w10, w11, w5, lsl #24\n+        value = ((a & 0xFF) << 0)   |\n+                ((r & 0xFF) << 8)   |\n+                ((g & 0xFF) << 16)  |\n+                ((b & 0xFF) << 24);\n+    }\n+    static int instrCount = 4;\n+    static boolean useBFI = true;\n+}\n+\n+class BigDecimal {\n+    static final long LONG_MASK = 0xffffffffL;\n+    static long mulsub(long u1, long u0, final long v1, final long v0, long q0) {\n+        long tmp = u0 - q0 * v0;\n+        long tmp1 = u1 + (tmp>>>32) - q0 * v1;\n+        \/\/ 1. lsl R0, R11, #32\n+        \/\/ 2. bfi R0, R10, ##0, ##32\n+        return (tmp1 << 32) | (tmp & LONG_MASK);\n+    }\n+    static int instrCount = 2;\n+    static boolean useBFI = true;\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestBFI.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class BitfieldInsert {\n+\n+    public int intValue;\n+\n+    @Benchmark \n+    public int bench1() {\n+        int b1, b2, b3, b4;\n+\tint base = intValue;\n+        int a1 = base + 1;\n+        int a2 = a1 + 1;\n+        int a3 = a1 + 2;\n+        int a4 = a1 + 3;\n+\n+        b1 = (base & 0x1) | ((a1 & 0x1) << 1) | ((a2 & 0x1) << 2) | ((a3 & 0x1) << 3) | ((a4 & 0x1) << 4);\n+        b2 = (base & 0x1) | ((a1 & 0x3) << 1) | ((a2 & 0x3) << 3) | ((a3 & 0x3) << 5) | ((a4 & 0x3) << 7);\n+        b3 = (base & 0x1) | ((a1 & 0x7) << 1) | ((a2 & 0x7) << 4) | ((a3 & 0x7) << 7) | ((a4 & 0x7) << 10);\n+        b4 = (base & 0x1) | ((a1 & 0xf) << 1) | ((a2 & 0xf) << 5) | ((a3 & 0xf) << 9) | ((a4 & 0xf) << 13);\n+\n+        a1 = (base & 0x1) | ((b1 & 0x1) << 1) | ((b2 & 0x1) << 2) | ((b3 & 0x1) << 3) | ((b4 & 0x1) << 4);\n+        a2 = (base & 0x1) | ((b1 & 0x3) << 1) | ((b2 & 0x3) << 3) | ((b3 & 0x3) << 5) | ((b4 & 0x3) << 7);\n+        a3 = (base & 0x1) | ((b1 & 0x7) << 1) | ((b2 & 0x7) << 4) | ((b3 & 0x7) << 7) | ((b4 & 0x7) << 10);\n+        a4 = (base & 0x1) | ((b1 & 0xf) << 1) | ((b2 & 0xf) << 5) | ((b3 & 0xf) << 9) | ((b4 & 0xf) << 13);\n+\n+        return a1 + a2 + a3 + a4;\n+    }\n+\n+    @Benchmark\n+    public int bench2() {\n+        int a = intValue;\n+        int b = intValue + 1;\n+        int c = intValue + 2;\n+        int d = intValue + 3;\n+        int e = intValue + 4;\n+        int f = intValue + 5;\n+        int g = intValue + 6;\n+        int h = intValue + 7;\n+        int i = intValue + 8;\n+        int j = intValue + 9;\n+        int k = intValue + 10;\n+        int l = intValue + 11;\n+        int m = intValue + 12;\n+        int n = intValue + 13;\n+        int o = intValue + 14;\n+        int p = intValue + 15;\n+        int a1 = ((a & 0x1) << 0) | ((a & 0x3) << 1) | ((a & 0x7) << 3) | ((a & 0xf) << 6) | ((a & 0x1f) << 10) | ((a & 0x3f) << 15) | ((a & 0x7f) << 21);\n+        int b1 = ((b & 0x1) << 0) | ((b & 0x3) << 1) | ((b & 0x7) << 3) | ((b & 0xf) << 6) | ((b & 0x1f) << 10) | ((b & 0x3f) << 15) | ((b & 0x7f) << 21);\n+        int c1 = ((c & 0x1) << 0) | ((c & 0x3) << 1) | ((c & 0x7) << 3) | ((c & 0xf) << 6) | ((c & 0x1f) << 10) | ((c & 0x3f) << 15) | ((c & 0x7f) << 21);\n+        int d1 = ((d & 0x1) << 0) | ((d & 0x3) << 1) | ((d & 0x7) << 3) | ((d & 0xf) << 6) | ((d & 0x1f) << 10) | ((d & 0x3f) << 15) | ((d & 0x7f) << 21);\n+        int e1 = ((e & 0x1) << 0) | ((e & 0x3) << 1) | ((e & 0x7) << 3) | ((e & 0xf) << 6) | ((e & 0x1f) << 10) | ((e & 0x3f) << 15) | ((e & 0x7f) << 21);\n+        int f1 = ((f & 0x1) << 0) | ((f & 0x3) << 1) | ((b & 0x7) << 3) | ((f & 0xf) << 6) | ((f & 0x1f) << 10) | ((f & 0x3f) << 15) | ((f & 0x7f) << 21);\n+        int g1 = ((g & 0x1) << 0) | ((g & 0x3) << 1) | ((a & 0x7) << 3) | ((g & 0xf) << 6) | ((g & 0x1f) << 10) | ((g & 0x3f) << 15) | ((g & 0x7f) << 21);\n+        int h1 = ((h & 0x1) << 0) | ((h & 0x3) << 1) | ((h & 0x7) << 3) | ((h & 0xf) << 6) | ((h & 0x1f) << 10) | ((h & 0x3f) << 15) | ((h & 0x7f) << 21);\n+        int i1 = ((i & 0x1) << 0) | ((i & 0x3) << 1) | ((i & 0x7) << 3) | ((i & 0xf) << 6) | ((i & 0x1f) << 10) | ((i & 0x3f) << 15) | ((i & 0x7f) << 21);\n+        int j1 = ((j & 0x1) << 0) | ((j & 0x3) << 1) | ((j & 0x7) << 3) | ((j & 0xf) << 6) | ((j & 0x1f) << 10) | ((j & 0x3f) << 15) | ((j & 0x7f) << 21);\n+        int k1 = ((k & 0x1) << 0) | ((k & 0x3) << 1) | ((k & 0x7) << 3) | ((k & 0xf) << 6) | ((k & 0x1f) << 10) | ((k & 0x3f) << 15) | ((k & 0x7f) << 21);\n+        int l1 = ((l & 0x1) << 0) | ((l & 0x3) << 1) | ((l & 0x7) << 3) | ((l & 0xf) << 6) | ((l & 0x1f) << 10) | ((l & 0x3f) << 15) | ((l & 0x7f) << 21);\n+        int m1 = ((m & 0x1) << 0) | ((m & 0x3) << 1) | ((m & 0x7) << 3) | ((m & 0xf) << 6) | ((m & 0x1f) << 10) | ((m & 0x3f) << 15) | ((m & 0x7f) << 21);\n+        int n1 = ((n & 0x1) << 0) | ((n & 0x3) << 1) | ((n & 0x7) << 3) | ((n & 0xf) << 6) | ((n & 0x1f) << 10) | ((n & 0x3f) << 15) | ((n & 0x7f) << 21);\n+        int o1 = ((o & 0x1) << 0) | ((o & 0x3) << 1) | ((o & 0x7) << 3) | ((o & 0xf) << 6) | ((o & 0x1f) << 10) | ((o & 0x3f) << 15) | ((o & 0x7f) << 21);\n+        int p1 = ((p & 0x1) << 0) | ((p & 0x3) << 1) | ((p & 0x7) << 3) | ((p & 0xf) << 6) | ((p & 0x1f) << 10) | ((p & 0x3f) << 15) | ((p & 0x7f) << 21);\n+        return a1 + b1 + c1 + d1 + e1 + f1 + g1 + h1 + i1 + j1 + k1 + l1 + m1 + n1 + o1 + p1;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/BitfieldInsert.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}