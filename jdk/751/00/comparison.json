{"files":[{"patch":"@@ -62,5 +62,0 @@\n-      if (C->range_check_cast_count() > 0) {\n-        \/\/ No more loop optimizations. Remove all range check dependent CastIINodes.\n-        C->remove_range_check_casts(igvn);\n-        igvn.optimize();\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -234,9 +234,10 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->major_progress()) {\n-    const TypeInt* this_type = this->type()->is_int();\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != NULL && this_type != NULL &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-      jint lo1 = this_type->_lo;\n-      jint hi1 = this_type->_hi;\n-      int w1  = this_type->_widen;\n+  if (can_reshape && !_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* this_type = this->type()->is_int();\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        jint lo1 = this_type->_lo;\n+        jint hi1 = this_type->_hi;\n+        int w1  = this_type->_widen;\n@@ -244,15 +245,16 @@\n-      if (lo1 >= 0) {\n-        \/\/ Keep a range assertion of >=0.\n-        lo1 = 0;        hi1 = max_jint;\n-      } else if (hi1 < 0) {\n-        \/\/ Keep a range assertion of <0.\n-        lo1 = min_jint; hi1 = -1;\n-      } else {\n-        lo1 = min_jint; hi1 = max_jint;\n-      }\n-      const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                           MIN2(in_type->_hi, hi1),\n-                                           MAX2((int)in_type->_widen, w1));\n-      if (wtype != type()) {\n-        set_type(wtype);\n-        return this;\n+        if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n+        }\n+        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                                             MIN2(in_type->_hi, hi1),\n+                                             MAX2((int)in_type->_widen, w1));\n+        if (wtype != type()) {\n+          set_type(wtype);\n+          return this;\n+        }\n@@ -260,0 +262,2 @@\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n@@ -265,0 +269,15 @@\n+Node* CastIINode::Identity(PhaseGVN* phase) {\n+  Node* progress = ConstraintCastNode::Identity(phase);\n+  if (progress != this) {\n+    return progress;\n+  }\n+  if (_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      return this->in(1);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,3 +122,3 @@\n-  for (int i = 1; i < _intrinsics->length(); i++) {\n-    CallGenerator* cg1 = _intrinsics->at(i-1);\n-    CallGenerator* cg2 = _intrinsics->at(i);\n+  for (int i = 1; i < _intrinsics.length(); i++) {\n+    CallGenerator* cg1 = _intrinsics.at(i-1);\n+    CallGenerator* cg2 = _intrinsics.at(i);\n@@ -132,1 +132,1 @@\n-  return _intrinsics->find_sorted<IntrinsicDescPair*, IntrinsicDescPair::compare>(&pair, found);\n+  return _intrinsics.find_sorted<IntrinsicDescPair*, IntrinsicDescPair::compare>(&pair, found);\n@@ -136,4 +136,0 @@\n-  if (_intrinsics == NULL) {\n-    _intrinsics = new (comp_arena())GrowableArray<CallGenerator*>(comp_arena(), 60, 0, NULL);\n-  }\n-  int len = _intrinsics->length();\n@@ -143,1 +139,1 @@\n-  _intrinsics->insert_before(index, cg);\n+  _intrinsics.insert_before(index, cg);\n@@ -149,1 +145,1 @@\n-  if (_intrinsics != NULL) {\n+  if (_intrinsics.length() > 0) {\n@@ -153,1 +149,1 @@\n-      return _intrinsics->at(index);\n+      return _intrinsics.at(index);\n@@ -171,3 +167,1 @@\n-\/\/ Compile:: register_library_intrinsics and make_vm_intrinsic are defined\n-\/\/ in library_call.cpp.\n-\n+\/\/ Compile::make_vm_intrinsic is defined in library_call.cpp.\n@@ -355,0 +349,9 @@\n+void Compile::remove_useless_nodes(GrowableArray<Node*>& node_list, Unique_Node_List& useful) {\n+  for (int i = node_list.length() - 1; i >= 0; i--) {\n+    Node* n = node_list.at(i);\n+    if (!useful.member(n)) {\n+      node_list.remove_if_existing(n);\n+    }\n+  }\n+}\n+\n@@ -369,1 +372,1 @@\n-      if (! useful.member(child)) {\n+      if (!useful.member(child)) {\n@@ -382,28 +385,5 @@\n-  \/\/ Remove useless macro and predicate opaq nodes\n-  for (int i = C->macro_count()-1; i >= 0; i--) {\n-    Node* n = C->macro_node(i);\n-    if (!useful.member(n)) {\n-      remove_macro_node(n);\n-    }\n-  }\n-  \/\/ Remove useless CastII nodes with range check dependency\n-  for (int i = range_check_cast_count() - 1; i >= 0; i--) {\n-    Node* cast = range_check_cast_node(i);\n-    if (!useful.member(cast)) {\n-      remove_range_check_cast(cast);\n-    }\n-  }\n-  \/\/ Remove useless expensive nodes\n-  for (int i = C->expensive_count()-1; i >= 0; i--) {\n-    Node* n = C->expensive_node(i);\n-    if (!useful.member(n)) {\n-      remove_expensive_node(n);\n-    }\n-  }\n-  \/\/ Remove useless Opaque4 nodes\n-  for (int i = opaque4_count() - 1; i >= 0; i--) {\n-    Node* opaq = opaque4_node(i);\n-    if (!useful.member(opaq)) {\n-      remove_opaque4_node(opaq);\n-    }\n-  }\n+\n+  remove_useless_nodes(_macro_nodes,        useful); \/\/ remove useless macro and predicate opaq nodes\n+  remove_useless_nodes(_expensive_nodes,    useful); \/\/ remove useless expensive nodes\n+  remove_useless_nodes(_for_post_loop_igvn, useful); \/\/ remove useless node recorded for post loop opts IGVN pass\n+\n@@ -519,0 +499,1 @@\n+                  _post_loop_opts_phase(false),\n@@ -536,0 +517,5 @@\n+                  _intrinsics        (comp_arena(), 0, 0, NULL),\n+                  _macro_nodes       (comp_arena(), 8, 0, NULL),\n+                  _predicate_opaqs   (comp_arena(), 8, 0, NULL),\n+                  _expensive_nodes   (comp_arena(), 8, 0, NULL),\n+                  _for_post_loop_igvn(comp_arena(), 8, 0, NULL),\n@@ -820,0 +806,1 @@\n+    _post_loop_opts_phase(false),\n@@ -1018,7 +1005,0 @@\n-  _intrinsics = NULL;\n-  _macro_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);\n-  _predicate_opaqs = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);\n-  _expensive_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);\n-  _range_check_casts = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);\n-  _opaque4_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);\n-  register_library_intrinsics();\n@@ -1795,12 +1775,5 @@\n-void Compile::add_range_check_cast(Node* n) {\n-  assert(n->isa_CastII()->has_range_check(), \"CastII should have range check dependency\");\n-  assert(!_range_check_casts->contains(n), \"duplicate entry in range check casts\");\n-  _range_check_casts->append(n);\n-}\n-\n-\/\/ Remove all range check dependent CastIINodes.\n-void Compile::remove_range_check_casts(PhaseIterGVN &igvn) {\n-  for (int i = range_check_cast_count(); i > 0; i--) {\n-    Node* cast = range_check_cast_node(i-1);\n-    assert(cast->isa_CastII()->has_range_check(), \"CastII should have range check dependency\");\n-    igvn.replace_node(cast, cast->in(1));\n+void Compile::record_for_post_loop_opts_igvn(Node* n) {\n+  if (!n->for_post_loop_opts_igvn()) {\n+    assert(!_for_post_loop_igvn.contains(n), \"duplicate\");\n+    n->add_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+    _for_post_loop_igvn.append(n);\n@@ -1808,1 +1781,0 @@\n-  assert(range_check_cast_count() == 0, \"should be empty\");\n@@ -1811,4 +1783,3 @@\n-void Compile::add_opaque4_node(Node* n) {\n-  assert(n->Opcode() == Op_Opaque4, \"Opaque4 only\");\n-  assert(!_opaque4_nodes->contains(n), \"duplicate entry in Opaque4 list\");\n-  _opaque4_nodes->append(n);\n+void Compile::remove_from_post_loop_opts_igvn(Node* n) {\n+  n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+  _for_post_loop_igvn.remove(n);\n@@ -1817,16 +1788,3 @@\n-\/\/ Remove all Opaque4 nodes.\n-void Compile::remove_opaque4_nodes(PhaseIterGVN &igvn) {\n-  for (int i = opaque4_count(); i > 0; i--) {\n-    Node* opaq = opaque4_node(i-1);\n-    assert(opaq->Opcode() == Op_Opaque4, \"Opaque4 only\");\n-    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-    \/\/ is always equal to the constant value of input 2. So we can\n-    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-    \/\/ leave the non constant test in instead to sanity check that it\n-    \/\/ never fails (if it does, that subgraph was constructed so, at\n-    \/\/ runtime, a Halt node is executed).\n-#ifdef ASSERT\n-    igvn.replace_node(opaq, opaq->in(1));\n-#else\n-    igvn.replace_node(opaq, opaq->in(2));\n-#endif\n+void Compile::process_for_post_loop_opts_igvn(PhaseIterGVN& igvn) {\n+  if (_for_post_loop_igvn.length() == 0) {\n+    return; \/\/ no work to do\n@@ -1834,1 +1792,7 @@\n-  assert(opaque4_count() == 0, \"should be empty\");\n+  while (_for_post_loop_igvn.length() > 0) {\n+    Node* n = _for_post_loop_igvn.pop();\n+    n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+    igvn._worklist.push(n);\n+  }\n+  igvn.optimize();\n+  assert(_for_post_loop_igvn.length() == 0, \"no more delayed nodes allowed\");\n@@ -1991,1 +1955,1 @@\n-  if(_loop_opts_cnt > 0) {\n+  if (_loop_opts_cnt > 0) {\n@@ -1993,1 +1957,1 @@\n-    while(major_progress() && (_loop_opts_cnt > 0)) {\n+    while (major_progress() && (_loop_opts_cnt > 0)) {\n@@ -2234,6 +2198,0 @@\n-  if (range_check_cast_count() > 0) {\n-    \/\/ No more loop optimizations. Remove all range check dependent CastIINodes.\n-    C->remove_range_check_casts(igvn);\n-    igvn.optimize();\n-  }\n-\n@@ -2263,4 +2221,3 @@\n-  if (opaque4_count() > 0) {\n-    C->remove_opaque4_nodes(igvn);\n-    igvn.optimize();\n-  }\n+  C->set_post_loop_opts_phase(); \/\/ no more loop opts allowed\n+\n+  process_for_post_loop_opts_igvn(igvn);\n@@ -2274,0 +2231,1 @@\n+  assert(igvn._worklist.size() == 0, \"not empty\");\n@@ -3684,1 +3642,1 @@\n-    _expensive_nodes->at(i)->set_req(0, NULL);\n+    _expensive_nodes.at(i)->set_req(0, NULL);\n@@ -4105,2 +4063,0 @@\n-    \/\/ Save CastII node to remove it after loop optimizations.\n-    phase->C->add_range_check_cast(value);\n@@ -4336,1 +4292,1 @@\n-    _expensive_nodes->sort(cmp_expensive_nodes);\n+    _expensive_nodes.sort(cmp_expensive_nodes);\n@@ -4341,2 +4297,2 @@\n-  for (int i = 1; i < _expensive_nodes->length(); i++) {\n-    if (cmp_expensive_nodes(_expensive_nodes->adr_at(i), _expensive_nodes->adr_at(i-1)) < 0) {\n+  for (int i = 1; i < _expensive_nodes.length(); i++) {\n+    if (cmp_expensive_nodes(_expensive_nodes.adr_at(i), _expensive_nodes.adr_at(i-1)) < 0) {\n@@ -4350,1 +4306,1 @@\n-  if (_expensive_nodes->length() == 0) {\n+  if (_expensive_nodes.length() == 0) {\n@@ -4358,2 +4314,2 @@\n-  for (int i = 0; i < _expensive_nodes->length(); i++) {\n-    Node* n = _expensive_nodes->at(i);\n+  for (int i = 0; i < _expensive_nodes.length(); i++) {\n+    Node* n = _expensive_nodes.at(i);\n@@ -4362,1 +4318,1 @@\n-      _expensive_nodes->at_put(j, n);\n+      _expensive_nodes.at_put(j, n);\n@@ -4366,1 +4322,1 @@\n-  _expensive_nodes->trunc_to(j);\n+  _expensive_nodes.trunc_to(j);\n@@ -4373,2 +4329,2 @@\n-  for (int i = 0; i < _expensive_nodes->length()-1; i++) {\n-    if (cmp_expensive_nodes(_expensive_nodes->adr_at(i), _expensive_nodes->adr_at(i+1)) == 0) {\n+  for (int i = 0; i < _expensive_nodes.length()-1; i++) {\n+    if (cmp_expensive_nodes(_expensive_nodes.adr_at(i), _expensive_nodes.adr_at(i+1)) == 0) {\n@@ -4383,1 +4339,1 @@\n-  if (_expensive_nodes->length() == 0) {\n+  if (_expensive_nodes.length() == 0) {\n@@ -4397,1 +4353,1 @@\n-  for (; i < _expensive_nodes->length()-1; i++) {\n+  for (; i < _expensive_nodes.length()-1; i++) {\n@@ -4399,1 +4355,1 @@\n-    if (_expensive_nodes->at(i)->Opcode() == _expensive_nodes->at(i+1)->Opcode()) {\n+    if (_expensive_nodes.at(i)->Opcode() == _expensive_nodes.at(i+1)->Opcode()) {\n@@ -4401,1 +4357,1 @@\n-      _expensive_nodes->at_put(j++, _expensive_nodes->at(i));\n+      _expensive_nodes.at_put(j++, _expensive_nodes.at(i));\n@@ -4405,1 +4361,1 @@\n-      _expensive_nodes->at_put(j++, _expensive_nodes->at(i));\n+      _expensive_nodes.at_put(j++, _expensive_nodes.at(i));\n@@ -4408,1 +4364,1 @@\n-      Node* n = _expensive_nodes->at(i);\n+      Node* n = _expensive_nodes.at(i);\n@@ -4415,3 +4371,3 @@\n-    _expensive_nodes->at_put(j++, _expensive_nodes->at(i));\n-  } else if (_expensive_nodes->length() >= 1) {\n-    Node* n = _expensive_nodes->at(i);\n+    _expensive_nodes.at_put(j++, _expensive_nodes.at(i));\n+  } else if (_expensive_nodes.length() >= 1) {\n+    Node* n = _expensive_nodes.at(i);\n@@ -4422,1 +4378,1 @@\n-  _expensive_nodes->trunc_to(j);\n+  _expensive_nodes.trunc_to(j);\n@@ -4429,1 +4385,1 @@\n-  assert(!_expensive_nodes->contains(n), \"duplicate entry in expensive list\");\n+  assert(!_expensive_nodes.contains(n), \"duplicate entry in expensive list\");\n@@ -4433,1 +4389,1 @@\n-    _expensive_nodes->append(n);\n+    _expensive_nodes.append(n);\n@@ -4611,2 +4567,2 @@\n-        _macro_nodes->at_put(allocates, n);\n-        _macro_nodes->at_put(i, tmp);\n+        _macro_nodes.at_put(allocates, n);\n+        _macro_nodes.at_put(i, tmp);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":79,"deletions":123,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -265,0 +265,2 @@\n+  bool                  _post_loop_opts_phase;  \/\/ Loop opts are finished.\n+\n@@ -312,6 +314,5 @@\n-  GrowableArray<CallGenerator*>* _intrinsics;   \/\/ List of intrinsics.\n-  GrowableArray<Node*>* _macro_nodes;           \/\/ List of nodes which need to be expanded before matching.\n-  GrowableArray<Node*>* _predicate_opaqs;       \/\/ List of Opaque1 nodes for the loop predicates.\n-  GrowableArray<Node*>* _expensive_nodes;       \/\/ List of nodes that are expensive to compute and that we'd better not let the GVN freely common\n-  GrowableArray<Node*>* _range_check_casts;     \/\/ List of CastII nodes with a range check dependency\n-  GrowableArray<Node*>* _opaque4_nodes;         \/\/ List of Opaque4 nodes that have a default value\n+  GrowableArray<CallGenerator*> _intrinsics;    \/\/ List of intrinsics.\n+  GrowableArray<Node*>  _macro_nodes;           \/\/ List of nodes which need to be expanded before matching.\n+  GrowableArray<Node*>  _predicate_opaqs;       \/\/ List of Opaque1 nodes for the loop predicates.\n+  GrowableArray<Node*>  _expensive_nodes;       \/\/ List of nodes that are expensive to compute and that we'd better not let the GVN freely common\n+  GrowableArray<Node*>  _for_post_loop_igvn;    \/\/ List of nodes for IGVN after loop opts are over\n@@ -379,2 +380,1 @@\n-  GrowableArray<CallGenerator*> _late_inlines;        \/\/ List of CallGenerators to be revisited after\n-                                                      \/\/ main parsing has finished.\n+  GrowableArray<CallGenerator*> _late_inlines;        \/\/ List of CallGenerators to be revisited after main parsing has finished.\n@@ -382,1 +382,0 @@\n-\n@@ -662,6 +661,8 @@\n-  int           macro_count()             const { return _macro_nodes->length(); }\n-  int           predicate_count()         const { return _predicate_opaqs->length();}\n-  int           expensive_count()         const { return _expensive_nodes->length(); }\n-  Node*         macro_node(int idx)       const { return _macro_nodes->at(idx); }\n-  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs->at(idx);}\n-  Node*         expensive_node(int idx)   const { return _expensive_nodes->at(idx); }\n+  int           macro_count()             const { return _macro_nodes.length(); }\n+  int           predicate_count()         const { return _predicate_opaqs.length();}\n+  int           expensive_count()         const { return _expensive_nodes.length(); }\n+\n+  Node*         macro_node(int idx)       const { return _macro_nodes.at(idx); }\n+  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx);}\n+  Node*         expensive_node(int idx)   const { return _expensive_nodes.at(idx); }\n+\n@@ -672,2 +673,2 @@\n-    assert(!_macro_nodes->contains(n), \"duplicate entry in expand list\");\n-    _macro_nodes->append(n);\n+    assert(!_macro_nodes.contains(n), \"duplicate entry in expand list\");\n+    _macro_nodes.append(n);\n@@ -678,1 +679,1 @@\n-    _macro_nodes->remove_if_existing(n);\n+    _macro_nodes.remove_if_existing(n);\n@@ -681,1 +682,1 @@\n-      _predicate_opaqs->remove_if_existing(n);\n+      _predicate_opaqs.remove_if_existing(n);\n@@ -686,1 +687,1 @@\n-    _expensive_nodes->remove_if_existing(n);\n+    _expensive_nodes.remove_if_existing(n);\n@@ -689,3 +690,3 @@\n-    assert(!_predicate_opaqs->contains(n), \"duplicate entry in predicate opaque1\");\n-    assert(_macro_nodes->contains(n), \"should have already been in macro list\");\n-    _predicate_opaqs->append(n);\n+    assert(!_predicate_opaqs.contains(n), \"duplicate entry in predicate opaque1\");\n+    assert(_macro_nodes.contains(n), \"should have already been in macro list\");\n+    _predicate_opaqs.append(n);\n@@ -694,17 +695,8 @@\n-  \/\/ Range check dependent CastII nodes that can be removed after loop optimizations\n-  void add_range_check_cast(Node* n);\n-  void remove_range_check_cast(Node* n) {\n-    _range_check_casts->remove_if_existing(n);\n-  }\n-  Node* range_check_cast_node(int idx) const { return _range_check_casts->at(idx);  }\n-  int   range_check_cast_count()       const { return _range_check_casts->length(); }\n-  \/\/ Remove all range check dependent CastIINodes.\n-  void  remove_range_check_casts(PhaseIterGVN &igvn);\n-\n-  void add_opaque4_node(Node* n);\n-  void remove_opaque4_node(Node* n) {\n-    _opaque4_nodes->remove_if_existing(n);\n-  }\n-  Node* opaque4_node(int idx) const { return _opaque4_nodes->at(idx);  }\n-  int   opaque4_count()       const { return _opaque4_nodes->length(); }\n-  void  remove_opaque4_nodes(PhaseIterGVN &igvn);\n+  bool     post_loop_opts_phase() { return _post_loop_opts_phase; }\n+  void set_post_loop_opts_phase() { _post_loop_opts_phase = true; }\n+\n+  void record_for_post_loop_opts_igvn(Node* n);\n+\n+  void remove_from_post_loop_opts_igvn(Node* n);\n+\n+  void process_for_post_loop_opts_igvn(PhaseIterGVN& igvn);\n@@ -717,2 +709,2 @@\n-  bool is_predicate_opaq(Node * n) {\n-    return _predicate_opaqs->contains(n);\n+  bool is_predicate_opaq(Node* n) {\n+    return _predicate_opaqs.contains(n);\n@@ -955,0 +947,1 @@\n+  void remove_useless_nodes       (GrowableArray<Node*>&        node_list, Unique_Node_List &useful);\n@@ -1087,1 +1080,0 @@\n-  void           register_library_intrinsics();                            \/\/ initializer\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":35,"deletions":43,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -268,40 +268,29 @@\n-  \/\/ If _major_progress, then more loop optimizations follow.  Do NOT\n-  \/\/ remove this node's type assertion until no more loop ops can happen.\n-  \/\/ The progress bit is set in the major loop optimizations THEN comes the\n-  \/\/ call to IterGVN and any chance of hitting this code.  Cf. Opaque1Node.\n-  if (can_reshape && !phase->C->major_progress()) {\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != NULL && this_type != NULL &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-          \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-          \/\/ because I2L nodes with the same input will common up, regardless\n-          \/\/ of slightly differing type assertions.  Such slight differences\n-          \/\/ arise routinely as a result of loop unrolling, so this is a\n-          \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-          \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-          jlong lo1 = this_type->_lo;\n-          jlong hi1 = this_type->_hi;\n-          int   w1  = this_type->_widen;\n-          if (lo1 != (jint)lo1 ||\n-              hi1 != (jint)hi1 ||\n-              lo1 > hi1) {\n-            \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-            lo1 = min_jint; hi1 = max_jint;\n-          } else if (lo1 >= 0) {\n-            \/\/ Keep a range assertion of >=0.\n-            lo1 = 0;        hi1 = max_jint;\n-          } else if (hi1 < 0) {\n-            \/\/ Keep a range assertion of <0.\n-            lo1 = min_jint; hi1 = -1;\n-          } else {\n-            lo1 = min_jint; hi1 = max_jint;\n-          }\n-          const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                                 MIN2((jlong)in_type->_hi, hi1),\n-                                                 MAX2((int)in_type->_widen, w1));\n-          if (wtype != type()) {\n-            set_type(wtype);\n-            \/\/ Note: this_type still has old type value, for the logic below.\n-            this_changed = this;\n-          }\n+  if (can_reshape) {\n+    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+        \/\/ because I2L nodes with the same input will common up, regardless\n+        \/\/ of slightly differing type assertions.  Such slight differences\n+        \/\/ arise routinely as a result of loop unrolling, so this is a\n+        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+        jlong lo1 = this_type->_lo;\n+        jlong hi1 = this_type->_hi;\n+        int   w1  = this_type->_widen;\n+        if (lo1 != (jint)lo1 ||\n+            hi1 != (jint)hi1 ||\n+            lo1 > hi1) {\n+          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n+          lo1 = min_jint; hi1 = max_jint;\n+        } else if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n@@ -309,0 +298,12 @@\n+        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                                               MIN2((jlong)in_type->_hi, hi1),\n+                                               MAX2((int)in_type->_widen, w1));\n+        if (wtype != type()) {\n+          set_type(wtype);\n+          \/\/ Note: this_type still has old type value, for the logic below.\n+          this_changed = this;\n+        }\n+      }\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n@@ -310,1 +311,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -98,6 +98,0 @@\n-\/\/----------------------register_library_intrinsics-----------------------\n-\/\/ Initialize this file's data structures, for each Compile instance.\n-void Compile::register_library_intrinsics() {\n-  \/\/ Nothing to do here.\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3489,1 +3489,1 @@\n-static void log_loop_tree(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {\n+static void log_loop_tree_helper(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {\n@@ -3494,1 +3494,1 @@\n-      if( loop->_child ) log_loop_tree(root, loop->_child, log);\n+      log_loop_tree_helper(root, loop->_child, log);\n@@ -3498,1 +3498,1 @@\n-  } else {\n+  } else if (loop != NULL) {\n@@ -3504,1 +3504,1 @@\n-      if (head->as_Loop()->is_inner_loop()) log->print(\"inner_loop='1' \");\n+      if (head->as_Loop()->is_inner_loop())        log->print(\"inner_loop='1' \");\n@@ -3506,2 +3506,1 @@\n-    }\n-    if (head->is_CountedLoop()) {\n+    } else if (head->is_CountedLoop()) {\n@@ -3511,1 +3510,1 @@\n-      if (cl->is_post_loop()) log->print(\"post_loop='%d' \",  cl->main_idx());\n+      if (cl->is_post_loop()) log->print(\"post_loop='%d' \", cl->main_idx());\n@@ -3514,1 +3513,1 @@\n-    if( loop->_child ) log_loop_tree(root, loop->_child, log);\n+    log_loop_tree_helper(root, loop->_child, log);\n@@ -3516,1 +3515,7 @@\n-    if( loop->_next  ) log_loop_tree(root, loop->_next, log);\n+    log_loop_tree_helper(root, loop->_next, log);\n+  }\n+}\n+\n+void PhaseIdealLoop::log_loop_tree() {\n+  if (C->log() != NULL) {\n+    log_loop_tree_helper(_ltree_root, _ltree_root, C->log());\n@@ -3703,0 +3708,2 @@\n+  assert(!C->post_loop_opts_phase(), \"no loop opts allowed\");\n+\n@@ -3779,1 +3786,0 @@\n-    _igvn.optimize();           \/\/ Cleanup NeverBranches\n@@ -3889,1 +3895,0 @@\n-    _igvn.optimize();\n@@ -3912,1 +3917,0 @@\n-    \/\/ restore major progress flag\n@@ -3914,7 +3918,0 @@\n-\n-    \/\/ Cleanup any modified bits\n-    _igvn.optimize();\n-\n-    if (C->log() != NULL) {\n-      log_loop_tree(_ltree_root, _ltree_root, C->log());\n-    }\n@@ -3942,6 +3939,0 @@\n-\n-    _igvn.optimize();\n-\n-    if (C->log() != NULL) {\n-      log_loop_tree(_ltree_root, _ltree_root, C->log());\n-    }\n@@ -3952,4 +3943,0 @@\n-    _igvn.optimize();\n-    if (C->log() != NULL) {\n-      log_loop_tree(_ltree_root, _ltree_root, C->log());\n-    }\n@@ -4094,3 +4081,0 @@\n-  \/\/ Cleanup any modified bits\n-  _igvn.optimize();\n-\n@@ -4100,4 +4084,0 @@\n-\n-  if (C->log() != NULL) {\n-    log_loop_tree(_ltree_root, _ltree_root, C->log());\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":16,"deletions":36,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -815,0 +815,2 @@\n+  void log_loop_tree();\n+\n@@ -1040,0 +1042,8 @@\n+\n+    Compile* C = Compile::current();\n+    if (!C->failing()) {\n+      \/\/ Cleanup any modified bits\n+      igvn.optimize();\n+\n+      v.log_loop_tree();\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-  if (is_macro())\n+  if (is_macro()) {\n@@ -520,1 +520,2 @@\n-  if (is_expensive())\n+  }\n+  if (is_expensive()) {\n@@ -522,6 +523,0 @@\n-  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-  bs->register_potential_barrier_node(n);\n-  \/\/ If the cloned node is a range check dependent CastII, add it to the list.\n-  CastIINode* cast = n->isa_CastII();\n-  if (cast != NULL && cast->has_range_check()) {\n-    C->add_range_check_cast(cast);\n@@ -529,2 +524,4 @@\n-  if (n->Opcode() == Op_Opaque4) {\n-    C->add_opaque4_node(n);\n+  if (for_post_loop_opts_igvn()) {\n+    \/\/ Don't add cloned node to Compile::_for_post_loop_opts_igvn list automatically.\n+    \/\/ If it is applicable, it will happen anyway when the cloned node is registered with IGVN.\n+    n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n@@ -532,0 +529,2 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bs->register_potential_barrier_node(n);\n@@ -638,6 +637,2 @@\n-  CastIINode* cast = isa_CastII();\n-  if (cast != NULL && cast->has_range_check()) {\n-    compile->remove_range_check_cast(cast);\n-  }\n-  if (Opcode() == Op_Opaque4) {\n-    compile->remove_opaque4_node(this);\n+  if (for_post_loop_opts_igvn()) {\n+    compile->remove_from_post_loop_opts_igvn(this);\n@@ -1058,1 +1053,1 @@\n-  assert(max_flags() <= max_jushort, \"too many NodeProperty flags\");\n+  assert(max_flags() <= max_juint, \"too many NodeProperty flags\");\n@@ -1415,6 +1410,2 @@\n-      CastIINode* cast = dead->isa_CastII();\n-      if (cast != NULL && cast->has_range_check()) {\n-        igvn->C->remove_range_check_cast(cast);\n-      }\n-      if (dead->Opcode() == Op_Opaque4) {\n-        igvn->C->remove_opaque4_node(dead);\n+      if (dead->for_post_loop_opts_igvn()) {\n+        igvn->C->remove_from_post_loop_opts_igvn(dead);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -733,16 +733,17 @@\n-    Flag_is_Copy                     = 0x01, \/\/ should be first bit to avoid shift\n-    Flag_rematerialize               = Flag_is_Copy << 1,\n-    Flag_needs_anti_dependence_check = Flag_rematerialize << 1,\n-    Flag_is_macro                    = Flag_needs_anti_dependence_check << 1,\n-    Flag_is_Con                      = Flag_is_macro << 1,\n-    Flag_is_cisc_alternate           = Flag_is_Con << 1,\n-    Flag_is_dead_loop_safe           = Flag_is_cisc_alternate << 1,\n-    Flag_may_be_short_branch         = Flag_is_dead_loop_safe << 1,\n-    Flag_avoid_back_to_back_before   = Flag_may_be_short_branch << 1,\n-    Flag_avoid_back_to_back_after    = Flag_avoid_back_to_back_before << 1,\n-    Flag_has_call                    = Flag_avoid_back_to_back_after << 1,\n-    Flag_is_reduction                = Flag_has_call << 1,\n-    Flag_is_scheduled                = Flag_is_reduction << 1,\n-    Flag_has_vector_mask_set         = Flag_is_scheduled << 1,\n-    Flag_is_expensive                = Flag_has_vector_mask_set << 1,\n-    _last_flag                       = Flag_is_expensive\n+    Flag_is_Copy                     = 1 << 0, \/\/ should be first bit to avoid shift\n+    Flag_rematerialize               = 1 << 1,\n+    Flag_needs_anti_dependence_check = 1 << 2,\n+    Flag_is_macro                    = 1 << 3,\n+    Flag_is_Con                      = 1 << 4,\n+    Flag_is_cisc_alternate           = 1 << 5,\n+    Flag_is_dead_loop_safe           = 1 << 6,\n+    Flag_may_be_short_branch         = 1 << 7,\n+    Flag_avoid_back_to_back_before   = 1 << 8,\n+    Flag_avoid_back_to_back_after    = 1 << 9,\n+    Flag_has_call                    = 1 << 10,\n+    Flag_is_reduction                = 1 << 11,\n+    Flag_is_scheduled                = 1 << 12,\n+    Flag_has_vector_mask_set         = 1 << 13,\n+    Flag_is_expensive                = 1 << 14,\n+    Flag_for_post_loop_opts_igvn     = 1 << 15,\n+    _last_flag                       = Flag_for_post_loop_opts_igvn\n@@ -755,1 +756,1 @@\n-  jushort _flags;\n+  juint _flags;\n@@ -776,1 +777,1 @@\n-  const jushort flags() const { return _flags; }\n+  const juint flags() const { return _flags; }\n@@ -778,1 +779,1 @@\n-  void add_flag(jushort fl) { init_flags(fl); }\n+  void add_flag(juint fl) { init_flags(fl); }\n@@ -780,1 +781,1 @@\n-  void remove_flag(jushort fl) { clear_flag(fl); }\n+  void remove_flag(juint fl) { clear_flag(fl); }\n@@ -794,1 +795,1 @@\n-    assert(is_##type(), \"invalid node class\");               \\\n+    assert(is_##type(), \"invalid node class: %s\", Name()); \\\n@@ -953,0 +954,2 @@\n+  bool for_post_loop_opts_igvn() const { return (_flags & Flag_for_post_loop_opts_igvn) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-\/\/ If _major_progress, then more loop optimizations follow.  Do NOT remove\n-\/\/ the opaque Node until no more loop ops can happen.  Note the timing of\n-\/\/ _major_progress; it's set in the major loop optimizations THEN comes the\n-\/\/ call to IterGVN and any chance of hitting this code.  Hence there's no\n-\/\/ phase-ordering problem with stripping Opaque1 in IGVN followed by some\n-\/\/ more loop optimizations that require it.\n+\/\/ Do NOT remove the opaque Node until no more loop ops can happen.\n@@ -44,1 +39,6 @@\n-  return phase->C->major_progress() ? this : in(1);\n+  if (phase->C->post_loop_opts_phase()) {\n+    return in(1);\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n@@ -63,0 +63,19 @@\n+Node* Opaque4Node::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n+    \/\/ is always equal to the constant value of input 2. So we can\n+    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n+    \/\/ leave the non constant test in instead to sanity check that it\n+    \/\/ never fails (if it does, that subgraph was constructed so, at\n+    \/\/ runtime, a Halt node is executed).\n+#ifdef ASSERT\n+    return this->in(1);\n+#else\n+    return this->in(2);\n+#endif\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -117,4 +117,2 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n-    \/\/ Put it on the Opaque4 nodes list to be removed after all optimizations\n-    C->add_opaque4_node(this);\n-  }\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {}\n+\n@@ -123,0 +121,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1408,6 +1408,2 @@\n-      CastIINode* cast = dead->isa_CastII();\n-      if (cast != NULL && cast->has_range_check()) {\n-        C->remove_range_check_cast(cast);\n-      }\n-      if (dead->Opcode() == Op_Opaque4) {\n-        C->remove_opaque4_node(dead);\n+      if (dead->for_post_loop_opts_igvn()) {\n+        C->remove_from_post_loop_opts_igvn(dead);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -907,1 +907,1 @@\n-  c2_nonstatic_field(Node,                     _flags,                                        jushort)                               \\\n+  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}