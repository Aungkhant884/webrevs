{"files":[{"patch":"@@ -62,5 +62,0 @@\n-      if (C->range_check_cast_count() > 0) {\n-        \/\/ No more loop optimizations. Remove all range check dependent CastIINodes.\n-        C->remove_range_check_casts(igvn);\n-        igvn.optimize();\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -234,9 +234,10 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->major_progress()) {\n-    const TypeInt* this_type = this->type()->is_int();\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != NULL && this_type != NULL &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-      jint lo1 = this_type->_lo;\n-      jint hi1 = this_type->_hi;\n-      int w1  = this_type->_widen;\n+  if (can_reshape && !_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* this_type = this->type()->is_int();\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        jint lo1 = this_type->_lo;\n+        jint hi1 = this_type->_hi;\n+        int w1  = this_type->_widen;\n@@ -244,15 +245,16 @@\n-      if (lo1 >= 0) {\n-        \/\/ Keep a range assertion of >=0.\n-        lo1 = 0;        hi1 = max_jint;\n-      } else if (hi1 < 0) {\n-        \/\/ Keep a range assertion of <0.\n-        lo1 = min_jint; hi1 = -1;\n-      } else {\n-        lo1 = min_jint; hi1 = max_jint;\n-      }\n-      const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                           MIN2(in_type->_hi, hi1),\n-                                           MAX2((int)in_type->_widen, w1));\n-      if (wtype != type()) {\n-        set_type(wtype);\n-        return this;\n+        if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n+        }\n+        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                                             MIN2(in_type->_hi, hi1),\n+                                             MAX2((int)in_type->_widen, w1));\n+        if (wtype != type()) {\n+          set_type(wtype);\n+          return this;\n+        }\n@@ -260,0 +262,2 @@\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n@@ -265,0 +269,15 @@\n+Node* CastIINode::Identity(PhaseGVN* phase) {\n+  Node* progress = ConstraintCastNode::Identity(phase);\n+  if (progress != this) {\n+    return progress;\n+  }\n+  if (_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      return this->in(1);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -388,2 +388,1 @@\n-  remove_useless_nodes(_range_check_casts,  useful); \/\/ remove useless CastII nodes with range check dependency\n-  remove_useless_nodes(_opaque4_nodes,      useful); \/\/ remove useless Opaque4 nodes\n+  remove_useless_nodes(_for_post_loop_igvn, useful); \/\/ remove useless node recorded for post loop opts IGVN pass\n@@ -500,0 +499,1 @@\n+                  _post_loop_opts_phase(false),\n@@ -521,2 +521,1 @@\n-                  _range_check_casts (comp_arena(), 8, 0, NULL),\n-                  _opaque4_nodes     (comp_arena(), 8, 0, NULL),\n+                  _for_post_loop_igvn(comp_arena(), 8, 0, NULL),\n@@ -807,0 +806,1 @@\n+    _post_loop_opts_phase(false),\n@@ -1775,12 +1775,5 @@\n-void Compile::add_range_check_cast(Node* n) {\n-  assert(n->isa_CastII()->has_range_check(), \"CastII should have range check dependency\");\n-  assert(!_range_check_casts.contains(n), \"duplicate entry in range check casts\");\n-  _range_check_casts.append(n);\n-}\n-\n-\/\/ Remove all range check dependent CastIINodes.\n-void Compile::remove_range_check_casts(PhaseIterGVN &igvn) {\n-  for (int i = range_check_cast_count(); i > 0; i--) {\n-    Node* cast = range_check_cast_node(i-1);\n-    assert(cast->isa_CastII()->has_range_check(), \"CastII should have range check dependency\");\n-    igvn.replace_node(cast, cast->in(1));\n+void Compile::record_for_post_loop_opts_igvn(Node* n) {\n+  if (!n->for_post_loop_opts_igvn()) {\n+    assert(!_for_post_loop_igvn.contains(n), \"duplicate\");\n+    n->add_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+    _for_post_loop_igvn.append(n);\n@@ -1788,1 +1781,0 @@\n-  assert(range_check_cast_count() == 0, \"should be empty\");\n@@ -1791,4 +1783,3 @@\n-void Compile::add_opaque4_node(Node* n) {\n-  assert(n->Opcode() == Op_Opaque4, \"Opaque4 only\");\n-  assert(!_opaque4_nodes.contains(n), \"duplicate entry in Opaque4 list\");\n-  _opaque4_nodes.append(n);\n+void Compile::remove_from_post_loop_opts_igvn(Node* n) {\n+  n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+  _for_post_loop_igvn.remove(n);\n@@ -1797,16 +1788,8 @@\n-\/\/ Remove all Opaque4 nodes.\n-void Compile::remove_opaque4_nodes(PhaseIterGVN &igvn) {\n-  for (int i = opaque4_count(); i > 0; i--) {\n-    Node* opaq = opaque4_node(i-1);\n-    assert(opaq->Opcode() == Op_Opaque4, \"Opaque4 only\");\n-    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-    \/\/ is always equal to the constant value of input 2. So we can\n-    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-    \/\/ leave the non constant test in instead to sanity check that it\n-    \/\/ never fails (if it does, that subgraph was constructed so, at\n-    \/\/ runtime, a Halt node is executed).\n-#ifdef ASSERT\n-    igvn.replace_node(opaq, opaq->in(1));\n-#else\n-    igvn.replace_node(opaq, opaq->in(2));\n-#endif\n+void Compile::process_for_post_loop_opts_igvn(PhaseIterGVN& igvn) {\n+  if (_for_post_loop_igvn.length() == 0) {\n+    return; \/\/ no work to do\n+  }\n+  while (_for_post_loop_igvn.length() > 0) {\n+    Node* n = _for_post_loop_igvn.pop();\n+    n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n+    igvn._worklist.push(n);\n@@ -1814,1 +1797,2 @@\n-  assert(opaque4_count() == 0, \"should be empty\");\n+  igvn.optimize();\n+  assert(_for_post_loop_igvn.length() == 0, \"no more delayed nodes allowed\");\n@@ -2216,6 +2200,0 @@\n-  if (range_check_cast_count() > 0) {\n-    \/\/ No more loop optimizations. Remove all range check dependent CastIINodes.\n-    C->remove_range_check_casts(igvn);\n-    igvn.optimize();\n-  }\n-\n@@ -2245,4 +2223,3 @@\n-  if (opaque4_count() > 0) {\n-    C->remove_opaque4_nodes(igvn);\n-    igvn.optimize();\n-  }\n+  C->set_post_loop_opts_phase(); \/\/ no more loop opts allowed\n+\n+  process_for_post_loop_opts_igvn(igvn);\n@@ -4088,2 +4065,0 @@\n-    \/\/ Save CastII node to remove it after loop optimizations.\n-    phase->C->add_range_check_cast(value);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":25,"deletions":50,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -265,0 +265,2 @@\n+  bool                  _post_loop_opts_phase;  \/\/ Loop opts are finished.\n+\n@@ -316,2 +318,1 @@\n-  GrowableArray<Node*>  _range_check_casts;     \/\/ List of CastII nodes with a range check dependency\n-  GrowableArray<Node*>  _opaque4_nodes;         \/\/ List of Opaque4 nodes that have a default value\n+  GrowableArray<Node*>  _for_post_loop_igvn;    \/\/ List of nodes for IGVN after loop opts are over\n@@ -663,0 +664,1 @@\n+\n@@ -666,0 +668,1 @@\n+\n@@ -692,17 +695,6 @@\n-  \/\/ Range check dependent CastII nodes that can be removed after loop optimizations\n-  void add_range_check_cast(Node* n);\n-  void remove_range_check_cast(Node* n) {\n-    _range_check_casts.remove_if_existing(n);\n-  }\n-  Node* range_check_cast_node(int idx) const { return _range_check_casts.at(idx);  }\n-  int   range_check_cast_count()       const { return _range_check_casts.length(); }\n-  \/\/ Remove all range check dependent CastIINodes.\n-  void  remove_range_check_casts(PhaseIterGVN &igvn);\n-\n-  void add_opaque4_node(Node* n);\n-  void remove_opaque4_node(Node* n) {\n-    _opaque4_nodes.remove_if_existing(n);\n-  }\n-  Node* opaque4_node(int idx) const { return _opaque4_nodes.at(idx);  }\n-  int   opaque4_count()       const { return _opaque4_nodes.length(); }\n-  void  remove_opaque4_nodes(PhaseIterGVN &igvn);\n+  bool     post_loop_opts_phase() { return _post_loop_opts_phase; }\n+  void set_post_loop_opts_phase() { _post_loop_opts_phase = true; }\n+\n+  void record_for_post_loop_opts_igvn(Node* n);\n+  void remove_from_post_loop_opts_igvn(Node* n);\n+  void process_for_post_loop_opts_igvn(PhaseIterGVN& igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -268,40 +268,29 @@\n-  \/\/ If _major_progress, then more loop optimizations follow.  Do NOT\n-  \/\/ remove this node's type assertion until no more loop ops can happen.\n-  \/\/ The progress bit is set in the major loop optimizations THEN comes the\n-  \/\/ call to IterGVN and any chance of hitting this code.  Cf. Opaque1Node.\n-  if (can_reshape && !phase->C->major_progress()) {\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != NULL && this_type != NULL &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-          \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-          \/\/ because I2L nodes with the same input will common up, regardless\n-          \/\/ of slightly differing type assertions.  Such slight differences\n-          \/\/ arise routinely as a result of loop unrolling, so this is a\n-          \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-          \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-          jlong lo1 = this_type->_lo;\n-          jlong hi1 = this_type->_hi;\n-          int   w1  = this_type->_widen;\n-          if (lo1 != (jint)lo1 ||\n-              hi1 != (jint)hi1 ||\n-              lo1 > hi1) {\n-            \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-            lo1 = min_jint; hi1 = max_jint;\n-          } else if (lo1 >= 0) {\n-            \/\/ Keep a range assertion of >=0.\n-            lo1 = 0;        hi1 = max_jint;\n-          } else if (hi1 < 0) {\n-            \/\/ Keep a range assertion of <0.\n-            lo1 = min_jint; hi1 = -1;\n-          } else {\n-            lo1 = min_jint; hi1 = max_jint;\n-          }\n-          const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                                 MIN2((jlong)in_type->_hi, hi1),\n-                                                 MAX2((int)in_type->_widen, w1));\n-          if (wtype != type()) {\n-            set_type(wtype);\n-            \/\/ Note: this_type still has old type value, for the logic below.\n-            this_changed = this;\n-          }\n+  if (can_reshape) {\n+    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+    if (phase->C->post_loop_opts_phase()) {\n+      const TypeInt* in_type = phase->type(in(1))->isa_int();\n+      if (in_type != NULL && this_type != NULL &&\n+          (in_type->_lo != this_type->_lo ||\n+           in_type->_hi != this_type->_hi)) {\n+        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+        \/\/ because I2L nodes with the same input will common up, regardless\n+        \/\/ of slightly differing type assertions.  Such slight differences\n+        \/\/ arise routinely as a result of loop unrolling, so this is a\n+        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+        jlong lo1 = this_type->_lo;\n+        jlong hi1 = this_type->_hi;\n+        int   w1  = this_type->_widen;\n+        if (lo1 != (jint)lo1 ||\n+            hi1 != (jint)hi1 ||\n+            lo1 > hi1) {\n+          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n+          lo1 = min_jint; hi1 = max_jint;\n+        } else if (lo1 >= 0) {\n+          \/\/ Keep a range assertion of >=0.\n+          lo1 = 0;        hi1 = max_jint;\n+        } else if (hi1 < 0) {\n+          \/\/ Keep a range assertion of <0.\n+          lo1 = min_jint; hi1 = -1;\n+        } else {\n+          lo1 = min_jint; hi1 = max_jint;\n@@ -309,0 +298,12 @@\n+        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                                               MIN2((jlong)in_type->_hi, hi1),\n+                                               MAX2((int)in_type->_widen, w1));\n+        if (wtype != type()) {\n+          set_type(wtype);\n+          \/\/ Note: this_type still has old type value, for the logic below.\n+          this_changed = this;\n+        }\n+      }\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n@@ -310,1 +311,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3708,0 +3708,2 @@\n+  assert(!C->post_loop_opts_phase(), \"no loop opts allowed\");\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-  if (is_macro())\n+  if (is_macro()) {\n@@ -520,1 +520,2 @@\n-  if (is_expensive())\n+  }\n+  if (is_expensive()) {\n@@ -522,6 +523,0 @@\n-  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-  bs->register_potential_barrier_node(n);\n-  \/\/ If the cloned node is a range check dependent CastII, add it to the list.\n-  CastIINode* cast = n->isa_CastII();\n-  if (cast != NULL && cast->has_range_check()) {\n-    C->add_range_check_cast(cast);\n@@ -529,2 +524,4 @@\n-  if (n->Opcode() == Op_Opaque4) {\n-    C->add_opaque4_node(n);\n+  if (for_post_loop_opts_igvn()) {\n+    \/\/ Don't add cloned node to Compile::_for_post_loop_opts_igvn list automatically.\n+    \/\/ If it is applicable, it will happen anyway when the cloned node is registered with IGVN.\n+    n->remove_flag(Node::NodeFlags::Flag_for_post_loop_opts_igvn);\n@@ -532,0 +529,2 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bs->register_potential_barrier_node(n);\n@@ -638,6 +637,2 @@\n-  CastIINode* cast = isa_CastII();\n-  if (cast != NULL && cast->has_range_check()) {\n-    compile->remove_range_check_cast(cast);\n-  }\n-  if (Opcode() == Op_Opaque4) {\n-    compile->remove_opaque4_node(this);\n+  if (for_post_loop_opts_igvn()) {\n+    compile->remove_from_post_loop_opts_igvn(this);\n@@ -1058,1 +1053,1 @@\n-  assert(max_flags() <= max_jushort, \"too many NodeProperty flags\");\n+  assert(max_flags() <= max_juint, \"too many NodeProperty flags\");\n@@ -1415,6 +1410,2 @@\n-      CastIINode* cast = dead->isa_CastII();\n-      if (cast != NULL && cast->has_range_check()) {\n-        igvn->C->remove_range_check_cast(cast);\n-      }\n-      if (dead->Opcode() == Op_Opaque4) {\n-        igvn->C->remove_opaque4_node(dead);\n+      if (dead->for_post_loop_opts_igvn()) {\n+        igvn->C->remove_from_post_loop_opts_igvn(dead);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -733,16 +733,17 @@\n-    Flag_is_Copy                     = 0x01, \/\/ should be first bit to avoid shift\n-    Flag_rematerialize               = Flag_is_Copy << 1,\n-    Flag_needs_anti_dependence_check = Flag_rematerialize << 1,\n-    Flag_is_macro                    = Flag_needs_anti_dependence_check << 1,\n-    Flag_is_Con                      = Flag_is_macro << 1,\n-    Flag_is_cisc_alternate           = Flag_is_Con << 1,\n-    Flag_is_dead_loop_safe           = Flag_is_cisc_alternate << 1,\n-    Flag_may_be_short_branch         = Flag_is_dead_loop_safe << 1,\n-    Flag_avoid_back_to_back_before   = Flag_may_be_short_branch << 1,\n-    Flag_avoid_back_to_back_after    = Flag_avoid_back_to_back_before << 1,\n-    Flag_has_call                    = Flag_avoid_back_to_back_after << 1,\n-    Flag_is_reduction                = Flag_has_call << 1,\n-    Flag_is_scheduled                = Flag_is_reduction << 1,\n-    Flag_has_vector_mask_set         = Flag_is_scheduled << 1,\n-    Flag_is_expensive                = Flag_has_vector_mask_set << 1,\n-    _last_flag                       = Flag_is_expensive\n+    Flag_is_Copy                     = 1 << 0, \/\/ should be first bit to avoid shift\n+    Flag_rematerialize               = 1 << 1,\n+    Flag_needs_anti_dependence_check = 1 << 2,\n+    Flag_is_macro                    = 1 << 3,\n+    Flag_is_Con                      = 1 << 4,\n+    Flag_is_cisc_alternate           = 1 << 5,\n+    Flag_is_dead_loop_safe           = 1 << 6,\n+    Flag_may_be_short_branch         = 1 << 7,\n+    Flag_avoid_back_to_back_before   = 1 << 8,\n+    Flag_avoid_back_to_back_after    = 1 << 9,\n+    Flag_has_call                    = 1 << 10,\n+    Flag_is_reduction                = 1 << 11,\n+    Flag_is_scheduled                = 1 << 12,\n+    Flag_has_vector_mask_set         = 1 << 13,\n+    Flag_is_expensive                = 1 << 14,\n+    Flag_for_post_loop_opts_igvn     = 1 << 15,\n+    _last_flag                       = Flag_for_post_loop_opts_igvn\n@@ -755,1 +756,1 @@\n-  jushort _flags;\n+  juint _flags;\n@@ -776,1 +777,1 @@\n-  const jushort flags() const { return _flags; }\n+  const juint flags() const { return _flags; }\n@@ -778,1 +779,1 @@\n-  void add_flag(jushort fl) { init_flags(fl); }\n+  void add_flag(juint fl) { init_flags(fl); }\n@@ -780,1 +781,1 @@\n-  void remove_flag(jushort fl) { clear_flag(fl); }\n+  void remove_flag(juint fl) { clear_flag(fl); }\n@@ -953,0 +954,2 @@\n+  bool for_post_loop_opts_igvn() const { return (_flags & Flag_for_post_loop_opts_igvn) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-\/\/ If _major_progress, then more loop optimizations follow.  Do NOT remove\n-\/\/ the opaque Node until no more loop ops can happen.  Note the timing of\n-\/\/ _major_progress; it's set in the major loop optimizations THEN comes the\n-\/\/ call to IterGVN and any chance of hitting this code.  Hence there's no\n-\/\/ phase-ordering problem with stripping Opaque1 in IGVN followed by some\n-\/\/ more loop optimizations that require it.\n+\/\/ Do NOT remove the opaque Node until no more loop ops can happen.\n@@ -44,1 +39,6 @@\n-  return phase->C->major_progress() ? this : in(1);\n+  if (phase->C->post_loop_opts_phase()) {\n+    return in(1);\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n@@ -63,0 +63,19 @@\n+Node* Opaque4Node::Identity(PhaseGVN* phase) {\n+  if (phase->C->post_loop_opts_phase()) {\n+    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n+    \/\/ is always equal to the constant value of input 2. So we can\n+    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n+    \/\/ leave the non constant test in instead to sanity check that it\n+    \/\/ never fails (if it does, that subgraph was constructed so, at\n+    \/\/ runtime, a Halt node is executed).\n+#ifdef ASSERT\n+    return this->in(1);\n+#else\n+    return this->in(2);\n+#endif\n+  } else {\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  return this;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -117,4 +117,2 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n-    \/\/ Put it on the Opaque4 nodes list to be removed after all optimizations\n-    C->add_opaque4_node(this);\n-  }\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {}\n+\n@@ -123,0 +121,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1412,6 +1412,2 @@\n-      CastIINode* cast = dead->isa_CastII();\n-      if (cast != NULL && cast->has_range_check()) {\n-        C->remove_range_check_cast(cast);\n-      }\n-      if (dead->Opcode() == Op_Opaque4) {\n-        C->remove_opaque4_node(dead);\n+      if (dead->for_post_loop_opts_igvn()) {\n+        C->remove_from_post_loop_opts_igvn(dead);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -906,1 +906,1 @@\n-  c2_nonstatic_field(Node,                     _flags,                                        jushort)                               \\\n+  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}