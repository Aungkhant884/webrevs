{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.loader.ClassLoaders;\n@@ -36,0 +37,1 @@\n+import java.lang.ref.SoftReference;\n@@ -452,6 +454,3 @@\n-    \/*private*\/\n-    final LambdaForm form;\n-    \/\/ form is not private so that invokers can easily fetch it\n-    \/*private*\/\n-    MethodHandle asTypeCache;\n-    \/\/ asTypeCache is not private so that invokers can easily fetch it\n+    \/*private*\/ final LambdaForm form; \/\/ form is not private so that invokers can easily fetch it\n+    private MethodHandle asTypeCache;\n+    private SoftReference<MethodHandle> asTypeSoftCache;\n@@ -858,1 +857,1 @@\n-    public MethodHandle asType(MethodType newType) {\n+    public final MethodHandle asType(MethodType newType) {\n@@ -865,3 +864,3 @@\n-        MethodHandle atc = asTypeCached(newType);\n-        if (atc != null) {\n-            return atc;\n+        MethodHandle at = asTypeCached(newType);\n+        if (at != null) {\n+            return at;\n@@ -869,1 +868,1 @@\n-        return asTypeUncached(newType);\n+        return setAsTypeCache(asTypeUncached(newType));\n@@ -875,1 +874,7 @@\n-            return atc;\n+            return atc; \/\/ cache hit\n+        }\n+        if (asTypeSoftCache != null) {\n+            atc = asTypeSoftCache.get();\n+            if (newType == atc.type) {\n+                return atc; \/\/ soft cache hit\n+            }\n@@ -880,0 +885,11 @@\n+    private MethodHandle setAsTypeCache(MethodHandle at) {\n+        \/\/ Don't introduce a strong reference in the cache if newType depends on any class loader other than\n+        \/\/ current method handle already does to avoid class loader leaks.\n+        if (isSafeToCache(at.type)) {\n+            asTypeCache = at;\n+        } else {\n+            asTypeSoftCache = new SoftReference<>(at);\n+        }\n+        return at;\n+    }\n+\n@@ -883,3 +899,71 @@\n-        if (!type.isConvertibleTo(newType))\n-            throw new WrongMethodTypeException(\"cannot convert \"+this+\" to \"+newType);\n-        return asTypeCache = MethodHandleImpl.makePairwiseConvert(this, newType, true);\n+        if (!type.isConvertibleTo(newType)) {\n+            throw new WrongMethodTypeException(\"cannot convert \" + this + \" to \" + newType);\n+        }\n+        return MethodHandleImpl.makePairwiseConvert(this, newType, true);\n+    }\n+\n+    \/**\n+     * Returns true if {@code newType} does not depend on any class loader other than current method handle already does.\n+     * May conservatively return false in order to be efficient.\n+     *\/\n+    private boolean isSafeToCache(MethodType newType) {\n+        ClassLoader loader = getApproximateCommonClassLoader(type);\n+        return keepsAlive(newType, loader);\n+    }\n+\n+    \/**\n+     * Tries to find the most specific {@code ClassLoader} which keeps all the classes mentioned in {@code mt} alive.\n+     * In the worst case, returns a {@code ClassLoader} which relates to some of the classes mentioned in {@code mt}.\n+     *\/\n+    private static ClassLoader getApproximateCommonClassLoader(MethodType mt) {\n+        ClassLoader loader = mt.rtype().getClassLoader();\n+        for (Class<?> ptype : mt.ptypes()) {\n+            ClassLoader ploader = ptype.getClassLoader();\n+            if (isAncestorLoaderOf(loader, ploader)) {\n+                loader = ploader; \/\/ pick more specific loader\n+            } else {\n+                \/\/ Either loader is a descendant of ploader or loaders are unrelated. Ignore both cases.\n+                \/\/ When loaders are not related, just pick one and proceed. It reduces the precision of keepsAlive, but\n+                \/\/ doesn't compromise correctness.\n+            }\n+        }\n+        return loader;\n+    }\n+\n+    \/* Returns true when {@code loader} keeps {@code mt} either directly or indirectly through the loader delegation chain. *\/\n+    private static boolean keepsAlive(MethodType mt, ClassLoader loader) {\n+        for (Class<?> ptype : mt.ptypes()) {\n+            if (!keepsAlive(ptype, loader)) {\n+                return false;\n+            }\n+        }\n+        return keepsAlive(mt.rtype(), loader);\n+    }\n+\n+    \/* Returns true when {@code loader} keeps {@code cls} either directly or indirectly through the loader delegation chain. *\/\n+    private static boolean keepsAlive(Class<?> cls, ClassLoader loader) {\n+        ClassLoader defLoader = cls.getClassLoader();\n+        if (isBuiltinLoader(defLoader)) {\n+            return true; \/\/ built-in loaders are always reachable\n+        }\n+        return isAncestorLoaderOf(defLoader, loader);\n+    }\n+\n+    private static boolean isAncestorLoaderOf(ClassLoader ancestor, ClassLoader descendant) {\n+        \/\/ Assume built-in loaders are interchangeable and all custom loaders delegate to one of them.\n+        if (isBuiltinLoader(ancestor)) {\n+            return true;\n+        }\n+        \/\/ Climb up the descendant chain until a built-in loader is encountered.\n+        for (ClassLoader loader = descendant; !isBuiltinLoader(loader); loader = loader.getParent()) {\n+            if (loader == ancestor) {\n+                return true;\n+            }\n+        }\n+        return false; \/\/ no direct relation between loaders is found\n+    }\n+\n+    private static boolean isBuiltinLoader(ClassLoader loader) {\n+        return loader == null ||\n+               loader == ClassLoaders.platformClassLoader() ||\n+               loader == ClassLoaders.appClassLoader();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":99,"deletions":15,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-                return asTypeCache = asFixedArity().asType(newType);\n+                return asFixedArity().asType(newType);\n@@ -501,1 +501,1 @@\n-                return asTypeCache = acc.asType(newType);\n+                return acc.asType(newType);\n@@ -512,1 +512,1 @@\n-            return asTypeCache = collector.asType(newType);\n+            return collector.asType(newType);\n@@ -740,1 +740,1 @@\n-            return (asTypeCache = wrapper);\n+            return wrapper;\n@@ -1216,1 +1216,1 @@\n-            return asTypeCache = target.asType(newType);\n+            return target.asType(newType);\n@@ -1279,1 +1279,1 @@\n-            return asTypeCache = target.asType(newType);\n+            return target.asType(newType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}