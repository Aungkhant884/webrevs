{"files":[{"patch":"@@ -1027,0 +1027,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+        \n@@ -1134,1 +1140,1 @@\n-    private void trimToSize() {\n+    void trimToSize() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    \n+\n@@ -43,1 +43,1 @@\n-     * Every public method must preserve these invariants.\n+     * Every public method must preserve this invariant.\n@@ -140,1 +140,2 @@\n-     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte array.\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * byte array.\n@@ -142,3 +143,5 @@\n-     * <p>More precisely,\n-     * <br>{@code NaturalsBitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n-     * <br>for all {@code n <  8 * bytes.length}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>\n+     * for all {@code n <  8 * bytes.length}.\n@@ -146,1 +149,2 @@\n-     * <p>This method is equivalent to\n+     * <p>\n+     * This method is equivalent to\n@@ -149,3 +153,3 @@\n-     * @param bytes a byte array containing a little-endian\n-     *        representation of a sequence of bits to be used as the\n-     *        initial bits of the new bit set\n+     * @param bytes a byte array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n@@ -159,2 +163,2 @@\n-     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte\n-     * buffer between its position and limit.\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * byte buffer between its position and limit.\n@@ -162,3 +166,5 @@\n-     * <p>More precisely,\n-     * <br>{@code NaturalsBitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n-     * <br>for all {@code n < 8 * bb.remaining()}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>\n+     * for all {@code n < 8 * bb.remaining()}.\n@@ -166,2 +172,3 @@\n-     * <p>The byte buffer is not modified by this method, and no\n-     * reference to the buffer is retained by the bit set.\n+     * <p>\n+     * The byte buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n@@ -169,3 +176,3 @@\n-     * @param bb a byte buffer containing a little-endian representation\n-     *        of a sequence of bits between its position and limit, to be\n-     *        used as the initial bits of the new bit set\n+     * @param bb a byte buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n@@ -184,2 +191,3 @@\n-     * Returns the number of bits set to true, starting from startWord (inclusive)\n-     * to endWord (exclusive)\n+     * Returns the number of bits set to true, starting from startWordIndex\n+     * (inclusive) to endWordIndex (exclusive). Word indices may be greater\n+     * than {@code wordsInUse}.\n@@ -187,1 +195,2 @@\n-    private int bitCount(int startWord, int endWord) {\n+    private int bitCount(int startWordIndex, int endWordIndex) {\n+        endWordIndex = Math.min(endWordIndex, wordsInUse);\n@@ -189,2 +198,3 @@\n-        for (int i = startWord; i < endWord; i++)\n-            sum += bitCount(i);\n+\n+        for (int i = startWordIndex; i < endWordIndex; i++)\n+            sum += Long.bitCount(words[i]);\n@@ -196,1 +206,2 @@\n-     * Returns the number of bits set to true at the specified word\n+     * Returns the number of bits set to true at the specified word.\n+     * {@code wordIndex} may be greater than or equal to {@code wordsInUse}.\n@@ -199,1 +210,1 @@\n-        return Long.bitCount(words[wordIndex]);\n+        return wordIndex < wordsInUse ? Long.bitCount(words[wordIndex]) : 0;\n@@ -231,2 +242,7 @@\n-        cardinality -= bitCount(startWord);\n-        cardinality -= bitCount(endWord);\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.flip(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n@@ -234,1 +250,1 @@\n-        super.flip(start, end);\n+            super.flip(start, end);\n@@ -236,2 +252,2 @@\n-        cardinality += bitCount(startWord);\n-        cardinality += bitCount(endWord);\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n@@ -239,2 +255,3 @@\n-        for (int i = startWord + 1; i < endWord; i++)\n-            cardinality += (bitCount(i) << 1) - BITS_PER_WORD;\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality += (bitCount(i) << 1) - BITS_PER_WORD;\n+        }\n@@ -276,2 +293,7 @@\n-        cardinality -= bitCount(startWord);\n-        cardinality -= bitCount(endWord);\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.set(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n@@ -279,2 +301,2 @@\n-        for (int i = startWord + 1; i < endWord; i++)\n-            cardinality += BITS_PER_WORD - bitCount(i);\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality += BITS_PER_WORD - bitCount(i);\n@@ -282,1 +304,1 @@\n-        super.set(start, end);\n+            super.set(start, end);\n@@ -284,2 +306,3 @@\n-        cardinality += bitCount(startWord);\n-        cardinality += bitCount(endWord);\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n+        }\n@@ -321,2 +344,7 @@\n-        cardinality -= bitCount(startWord);\n-        cardinality -= bitCount(endWord);\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.clear(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n@@ -324,2 +352,2 @@\n-        for (int i = startWord + 1; i < endWord; i++)\n-            cardinality -= bitCount(i);\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality -= bitCount(i);\n@@ -327,1 +355,1 @@\n-        super.clear(start, end);\n+            super.clear(start, end);\n@@ -329,2 +357,3 @@\n-        cardinality += bitCount(startWord);\n-        cardinality += bitCount(endWord);\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n+        }\n@@ -395,2 +424,9 @@\n-            super.or(set);\n-            computeCardinality();\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.or(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.or(set);\n+                computeCardinality();\n+            }\n+\n@@ -406,2 +442,9 @@\n-            super.xor(set);\n-            computeCardinality();\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.xor(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.xor(set);\n+                computeCardinality();\n+            }\n+\n@@ -414,1 +457,11 @@\n-        int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);\n+        if (this == set) { \/\/ An optimization\n+            clear();\n+        } else {\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.andNot(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.andNot(set);\n+                computeCardinality();\n+            }\n@@ -416,3 +469,0 @@\n-        if (wordsInCommon > wordsInUse \/ 2) { \/\/ An optimization\n-            super.andNot(set);\n-            computeCardinality();\n@@ -420,4 +470,0 @@\n-        } else {\n-            cardinality -= bitCount(0, wordsInCommon);\n-            super.andNot(set);\n-            cardinality += bitCount(0, wordsInCommon);\n@@ -452,8 +498,0 @@\n-        ObjectInputStream.GetField fields = s.readFields();\n-        words = (long[]) fields.get(\"bits\", null);\n-\n-        \/\/ Assume maximum length then find real length\n-        \/\/ because recalculateWordsInUse assumes maintenance\n-        \/\/ or reduction in logical size\n-        wordsInUse = words.length;\n-        recalculateWordsInUse();\n@@ -461,2 +499,0 @@\n-        sizeIsSticky = (words.length > 0 && words[words.length - 1] == 0L); \/\/ heuristic\n-        checkInvariants();\n","filename":"src\/java.base\/share\/classes\/java\/util\/NaturalsBitSet.java","additions":106,"deletions":70,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -821,40 +821,0 @@\n-    }\n-\n-    private static void testIncludes() {\n-        int failCount = 0;\n-\n-        for (int i=0; i<100; i++) {\n-            BitSet b1 = new BitSet(256);\n-            BitSet b2 = new BitSet(256);\n-\n-            \/\/ Set some random bits in first set\n-            int nextBitToSet = 0;\n-            for (int x=0; x<30; x++) {\n-                nextBitToSet = generator.nextInt(255);\n-                b1.set(nextBitToSet);\n-            }\n-\n-            \/\/ Set more random bits in second set\n-            for (int x=0; x<30; x++) {\n-                nextBitToSet = generator.nextInt(255);\n-                b2.set(nextBitToSet);\n-            }\n-\n-            \/\/ Make sure b1 includes b2\n-            b1.or(b2);\n-\n-            if (!b1.includes(b2))\n-                failCount++;\n-\n-            \/\/ Remove a common set bit\n-            nextBitToSet = b2.nextSetBit(generator.nextInt(b2.length()));\n-            b1.clear(nextBitToSet);\n-\n-            \/\/ Make sure b1 doesn't include b2\n-            if (b1.includes(b2))\n-                failCount++;\n-\n-            checkSanity(b1, b2);\n-        }\n-\n-        report(\"Includes                  \", failCount);\n","filename":"test\/jdk\/java\/util\/BitSet\/BSMethods.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\/**\n+ * @test\n+ * @bug 8300487\n+ * @summary test the NaturalsBitSet.and() method\n+ *\/\n+import java.util.NaturalsBitSet;\n+\n+public final class And {\n+    public static void main(String[] args) throws Exception {\n+        NaturalsBitSet a = new NaturalsBitSet();\n+        NaturalsBitSet b = new NaturalsBitSet();\n+\n+        a.set(0);\n+        a.set(70);\n+        b.set(40);\n+        a.and(b);\n+        if (a.length() != 0)\n+            throw new RuntimeException(\"Incorrect length after and().\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/And.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/**\n+ * @test\n+ * @bug 8300487\n+ * @run main\/othervm -Xms250m HugeToString\n+ *\/\n+\n+import java.util.NaturalsBitSet;\n+\n+public final class HugeToString {\n+\n+    public static void main(String[] args) {\n+        NaturalsBitSet bs = new NaturalsBitSet(500_000_000);\n+        bs.flip(0, 500_000_000);\n+        try {\n+            bs.toString();\n+        } catch (OutOfMemoryError expected) {\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/HugeToString.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Test import\/export constructors and methods\n+ * @author Martin Buchholz\n+ * @key randomness\n+ *\/\n+\n+import java.nio.*;\n+import java.util.*;\n+\n+public class ImportExport {\n+    final Random rnd = new Random();\n+\n+    void equal(byte[] x, byte[] y) {\n+        check(Arrays.equals(x, y));\n+    }\n+\n+    void equal(long[] x, long[] y) {\n+        check(Arrays.equals(x, y));\n+    }\n+\n+    void equal(byte[] bytes, NaturalsBitSet s) {\n+        equal(s, NaturalsBitSet.valueOf(bytes));\n+        equal(s, NaturalsBitSet.valueOf(ByteBuffer.wrap(bytes)));\n+        equal(s, NaturalsBitSet.valueOf(\n+                  ByteBuffer.wrap(\n+                      Arrays.copyOf(bytes, bytes.length + 8 + rnd.nextInt(8)))\n+                  .order(ByteOrder.LITTLE_ENDIAN)\n+                  .asLongBuffer()));\n+    }\n+\n+    void checkEmptyBitSet(NaturalsBitSet s) {\n+        equal(s.toByteArray(), new byte[0]);\n+        equal(s.toLongArray(), new long[0]);\n+        check(s.isEmpty());\n+    }\n+\n+    void test(String[] args) throws Throwable {\n+        for (int i = 0; i < 17; i++) {\n+            byte[] bytes = new byte[i];\n+            NaturalsBitSet s = new NaturalsBitSet();\n+            equal(bytes, s);\n+            equal(NaturalsBitSet.valueOf(bytes).toByteArray(), new byte[0]);\n+            if (i > 0) {\n+                int k = rnd.nextInt(i);\n+                for (int j = 0; j < 8; j++) {\n+                    bytes[k] |= 1 << j;\n+                    s.set(8*k+j);\n+                    equal(bytes, s);\n+                    byte[] expected = new byte[k+1]; expected[k] = bytes[k];\n+                    equal(NaturalsBitSet.valueOf(bytes).toByteArray(), expected);\n+                    ByteBuffer bb = ByteBuffer.wrap(bytes);\n+                    bb.position(k);\n+                    equal(NaturalsBitSet.valueOf(bb).toByteArray(),\n+                          new byte[]{bytes[k]});\n+                }\n+            }\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            byte[] bytes = new byte[rnd.nextInt(17)];\n+            for (int j = 0; j < bytes.length; j++)\n+                bytes[j] = (byte) rnd.nextInt(0x100);\n+            NaturalsBitSet s = NaturalsBitSet.valueOf(bytes);\n+            byte[] expected = s.toByteArray();\n+            equal(expected.length, (s.length()+7)\/8);\n+            if (bytes.length == 0)\n+                continue;\n+            if (expected.length > 0)\n+                check(expected[expected.length-1] != 0);\n+            if (bytes[bytes.length-1] != 0)\n+                equal(bytes, expected);\n+            int n = rnd.nextInt(8 * bytes.length);\n+            equal(s.get(n), ((bytes[n\/8] & (1<<(n%8))) != 0));\n+        }\n+\n+        for (int i = 0; i < 3; i++) {\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new byte[i]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(ByteBuffer.wrap(new byte[i])));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new byte[i*64]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(ByteBuffer.wrap(new byte[i*64])));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new long[i]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(LongBuffer.wrap(new long[i])));\n+        }\n+\n+        {\n+            long[] longs = new long[rnd.nextInt(10)];\n+            for (int i = 0; i < longs.length; i++)\n+                longs[i] = rnd.nextLong();\n+            LongBuffer b1 = LongBuffer.wrap(longs);\n+            LongBuffer b2 = LongBuffer.allocate(longs.length + 10);\n+            for (int i = 0; i < b2.limit(); i++)\n+                b2.put(i, rnd.nextLong());\n+            int beg = rnd.nextInt(10);\n+            b2.position(beg);\n+            b2.put(longs);\n+            b2.limit(b2.position());\n+            b2.position(beg);\n+            NaturalsBitSet s1 = NaturalsBitSet.valueOf(longs);\n+            NaturalsBitSet s2 = NaturalsBitSet.valueOf(b1);\n+            NaturalsBitSet s3 = NaturalsBitSet.valueOf(b2);\n+            equal(s1, s2);\n+            equal(s1, s3);\n+            if (longs.length > 0 && longs[longs.length -1] != 0) {\n+                equal(longs, s1.toLongArray());\n+                equal(longs, s2.toLongArray());\n+                equal(longs, s3.toLongArray());\n+            }\n+            for (int i = 0; i < 64 * longs.length; i++) {\n+                equal(s1.get(i), ((longs [i\/64] & (1L<<(i%64))) != 0));\n+                equal(s2.get(i), ((b1.get(i\/64) & (1L<<(i%64))) != 0));\n+                equal(s3.get(i), ((b2.get(b2.position()+i\/64) & (1L<<(i%64))) != 0));\n+            }\n+        }\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    volatile int passed = 0, failed = 0;\n+    void pass() {passed++;}\n+    void fail() {failed++; Thread.dumpStack();}\n+    void fail(String msg) {System.err.println(msg); fail();}\n+    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    void check(boolean cond) {if (cond) pass(); else fail();}\n+    void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        new ImportExport().instanceMain(args);}\n+    void instanceMain(String[] args) throws Throwable {\n+        try {test(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/ImportExport.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Repeatedly OR NaturalsBitSets; No OutOfMemoryException should result\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * This is a simple test class that repeatedly ORs two\n+ * NaturalsBitSets of unequal size together. Previously this\n+ * caused an exponential growth in the memory underlying\n+ * the BitSets quickly using all available memory\n+ *\/\n+public class MemoryLeak {\n+\n+   public static void main(String[] args) {\n+\n+        \/\/create 2 test bitsets\n+        NaturalsBitSet setOne = new NaturalsBitSet();\n+        NaturalsBitSet setTwo = new NaturalsBitSet();\n+\n+        setOne.set(64);\n+        setTwo.set(129);\n+\n+        \/\/test for bug #4091185\n+        \/\/exponential set growth causing memory depletion\n+        for (int i = 0; i < 50; i++) {\n+            setOne.or(setTwo);\n+            setTwo.or(setOne);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/MemoryLeak.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,961 @@\n+\/* @test\n+ * @summary Test the operation of the methods of NaturalsBitSet class\n+ * @author Mike McCloskey, Martin Buchholz\n+ * @run main\/othervm BSMethods\n+ * @key randomness\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * This is a simple test class created to run tests on the BitSet class.\n+ *\n+ *\/\n+public class NBSMethods {\n+\n+    private static Random generator = new Random();\n+    private static boolean failure = false;\n+\n+    private static void fail(String diagnostic) {\n+        new Error(diagnostic).printStackTrace();\n+        failure = true;\n+    }\n+\n+    private static void check(boolean condition) {\n+        check(condition, \"something's fishy\");\n+    }\n+\n+    private static void check(boolean condition, String diagnostic) {\n+        if (! condition)\n+            fail(diagnostic);\n+    }\n+\n+    private static void checkEmpty(NaturalsBitSet s) {\n+        check(s.isEmpty(), \"isEmpty\");\n+        check(s.length() == 0, \"length\");\n+        check(s.cardinality() == 0, \"cardinality\");\n+        check(s.equals(new NaturalsBitSet())   , \"equals\");\n+        check(s.equals(new NaturalsBitSet(0))  , \"equals\");\n+        check(s.equals(new NaturalsBitSet(127)), \"equals\");\n+        check(s.equals(new NaturalsBitSet(128)), \"equals\");\n+        check(s.nextSetBit(0)   == -1, \"nextSetBit\");\n+        check(s.nextSetBit(127) == -1, \"nextSetBit\");\n+        check(s.nextSetBit(128) == -1, \"nextSetBit\");\n+        check(s.nextClearBit(0)   == 0,   \"nextClearBit\");\n+        check(s.nextClearBit(127) == 127, \"nextClearBit\");\n+        check(s.nextClearBit(128) == 128, \"nextClearBit\");\n+        check(s.toString().equals(\"{}\"), \"toString\");\n+        check(! s.get(0), \"get\");\n+    }\n+\n+    private static NaturalsBitSet makeSet(int... elts) {\n+        NaturalsBitSet s = new NaturalsBitSet();\n+        for (int elt : elts)\n+            s.set(elt);\n+        return s;\n+    }\n+\n+    private static void checkEquality(NaturalsBitSet s, NaturalsBitSet t) {\n+        checkSanity(s, t);\n+        check(s.equals(t), \"equals\");\n+        check(s.toString().equals(t.toString()), \"equal strings\");\n+        check(s.length() == t.length(), \"equal lengths\");\n+        check(s.cardinality() == t.cardinality(), \"equal cardinalities\");\n+    }\n+\n+    private static void checkSanity(NaturalsBitSet... sets) {\n+        for (NaturalsBitSet s : sets) {\n+            int len = s.length();\n+            int cardinality1 = s.cardinality();\n+            int cardinality2 = 0;\n+            for (int i = s.nextSetBit(0); i >= 0; i = s.nextSetBit(i+1)) {\n+                check(s.get(i));\n+                cardinality2++;\n+            }\n+            check(s.nextSetBit(len) == -1, \"last set bit\");\n+            check(s.nextClearBit(len) == len, \"last set bit\");\n+            check(s.isEmpty() == (len == 0), \"emptiness\");\n+            check(cardinality1 == cardinality2, \"cardinalities\");\n+            check(len <= s.size(), \"length <= size\");\n+            check(len >= 0, \"length >= 0\");\n+            check(cardinality1 >= 0, \"cardinality >= 0\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        \/\/testFlipTime();\n+\n+        \/\/ These are the single bit versions\n+        testSetGetClearFlip();\n+\n+        \/\/ Test the ranged versions\n+        testClear();\n+\n+        testFlip();\n+        testSet();\n+        testGet();\n+\n+        \/\/ BitSet interaction calls\n+        testAndNot();\n+        testAnd();\n+        testOr();\n+        testXor();\n+\n+        \/\/ Miscellaneous calls\n+        testLength();\n+        testEquals();\n+        testNextSetBit();\n+        testNextClearBit();\n+        testIntersects();\n+        testCardinality();\n+        testEmpty();\n+        testEmpty2();\n+        testToString();\n+        testLogicalIdentities();\n+\n+        if (failure)\n+            throw new RuntimeException(\"One or more BitSet failures.\");\n+    }\n+\n+    private static void report(String testName, int failCount) {\n+        System.err.println(testName+\": \" +\n+                           (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n+        if (failCount > 0)\n+            failure = true;\n+    }\n+\n+    private static void testFlipTime() {\n+        \/\/ Make a fairly random bitset\n+        NaturalsBitSet b1 = new NaturalsBitSet();\n+        b1.set(1000);\n+        long startTime = System.currentTimeMillis();\n+        for(int x=0; x<100000; x++) {\n+            b1.flip(100, 900);\n+        }\n+        long endTime = System.currentTimeMillis();\n+        long total = endTime - startTime;\n+        System.out.println(\"Multiple word flip Time \"+total);\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x=0; x<100000; x++) {\n+            b1.flip(2, 44);\n+        }\n+        endTime = System.currentTimeMillis();\n+        total = endTime - startTime;\n+        System.out.println(\"Single word flip Time \"+total);\n+    }\n+\n+    private static void testNextSetBit() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            NaturalsBitSet testSet = new NaturalsBitSet();\n+            int[] history = new int[numberOfSetBits];\n+\n+            \/\/ Set some random bits and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                nextBitToSet += generator.nextInt(30)+1;\n+                history[x] = nextBitToSet;\n+                testSet.set(nextBitToSet);\n+            }\n+\n+            \/\/ Verify their retrieval using nextSetBit()\n+            int historyIndex = 0;\n+            for(int x=testSet.nextSetBit(0); x>=0; x=testSet.nextSetBit(x+1)) {\n+                if (x != history[historyIndex++])\n+                    failCount++;\n+            }\n+\n+            checkSanity(testSet);\n+        }\n+\n+        report(\"NextSetBit                  \", failCount);\n+    }\n+\n+    private static void testNextClearBit() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b = new NaturalsBitSet(256);\n+            int[] history = new int[10];\n+\n+            \/\/ Set all the bits\n+            for (int x=0; x<256; x++)\n+                b.set(x);\n+\n+            \/\/ Clear some random bits and remember them\n+            int nextBitToClear = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToClear += generator.nextInt(24)+1;\n+                history[x] = nextBitToClear;\n+                b.clear(nextBitToClear);\n+            }\n+\n+            \/\/ Verify their retrieval using nextClearBit()\n+            int historyIndex = 0;\n+            for(int x=b.nextClearBit(0); x<256; x=b.nextClearBit(x+1)) {\n+                if (x != history[historyIndex++])\n+                    failCount++;\n+            }\n+\n+            checkSanity(b);\n+        }\n+\n+        \/\/ regression test for 4350178\n+        NaturalsBitSet bs  = new NaturalsBitSet();\n+        if (bs.nextClearBit(0) != 0)\n+                failCount++;\n+        for (int i = 0; i < 64; i++) {\n+            bs.set(i);\n+            if (bs.nextClearBit(0) != i+1)\n+                failCount++;\n+        }\n+\n+        checkSanity(bs);\n+\n+        report(\"NextClearBit                \", failCount);\n+    }\n+\n+    private static void testSetGetClearFlip() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet testSet = new NaturalsBitSet();\n+            HashSet<Integer> history = new HashSet<Integer>();\n+\n+            \/\/ Set a random number of bits in random places\n+            \/\/ up to a random maximum\n+            int nextBitToSet = 0;\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                nextBitToSet = generator.nextInt(highestPossibleSetBit);\n+                history.add(nextBitToSet);\n+                testSet.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure each bit is set appropriately\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Clear the bits\n+            Iterator<Integer> setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = setBitIterator.next();\n+                testSet.clear(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were cleared\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            \/\/ Set them with set(int, boolean)\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = setBitIterator.next();\n+                testSet.set(setBit.intValue(), true);\n+            }\n+\n+            \/\/ Make sure each bit is set appropriately\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Clear them with set(int, boolean)\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.set(setBit.intValue(), false);\n+            }\n+\n+            \/\/ Verify they were cleared\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            \/\/ Flip them on\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.flip(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were flipped\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Flip them off\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.flip(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were flipped\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            checkSanity(testSet);\n+        }\n+\n+        report(\"SetGetClearFlip             \", failCount);\n+    }\n+\n+    private static void testAndNot() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set some random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ andNot the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.andNot(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 & (!bit2))))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        report(\"AndNot                      \", failCount);\n+    }\n+\n+    private static void testAnd() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ And the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.and(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 & bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        \/\/ `and' that happens to clear the last word\n+        NaturalsBitSet b4 = makeSet(2, 127);\n+        b4.and(makeSet(2, 64));\n+        checkSanity(b4);\n+        if (!(b4.equals(makeSet(2))))\n+            failCount++;\n+\n+        report(\"And                         \", failCount);\n+    }\n+\n+    private static void testOr() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+            int[] history = new int[20];\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                history[x] = nextBitToSet;\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                history[x] = nextBitToSet;\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Or the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.or(b2);\n+\n+            \/\/ Verify the set bits of b3 from the history\n+            int historyIndex = 0;\n+            for(int x=0; x<20; x++) {\n+                if (!b3.get(history[x]))\n+                    failCount++;\n+            }\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 | bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        report(\"Or                          \", failCount);\n+    }\n+\n+    private static void testXor() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ Xor the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.xor(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 ^ bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+            b3.xor(b3); checkEmpty(b3);\n+        }\n+\n+        \/\/ xor that happens to clear the last word\n+        NaturalsBitSet b4 = makeSet(2, 64, 127);\n+        b4.xor(makeSet(64, 127));\n+        checkSanity(b4);\n+        if (!(b4.equals(makeSet(2))))\n+            failCount++;\n+\n+        report(\"Xor                         \", failCount);\n+    }\n+\n+    private static void testEquals() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            \/\/ Create BitSets of different sizes\n+            NaturalsBitSet b1 = new NaturalsBitSet(generator.nextInt(1000)+1);\n+            NaturalsBitSet b2 = new NaturalsBitSet(generator.nextInt(1000)+1);\n+\n+            \/\/ Set some random bits\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToSet += generator.nextInt(50)+1;\n+                b1.set(nextBitToSet);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Verify their equality despite different storage sizes\n+            if (!b1.equals(b2))\n+                failCount++;\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Equals                      \", failCount);\n+    }\n+\n+    private static void testLength() {\n+        int failCount = 0;\n+\n+        \/\/ Test length after set\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            int highestSetBit = 0;\n+\n+            for(int x=0; x<100; x++) {\n+                int nextBitToSet = generator.nextInt(255);\n+                if (nextBitToSet > highestSetBit)\n+                    highestSetBit = nextBitToSet;\n+                b1.set(nextBitToSet);\n+                if (b1.length() != highestSetBit + 1)\n+                    failCount++;\n+            }\n+            checkSanity(b1);\n+        }\n+\n+        \/\/ Test length after flip\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            for(int x=0; x<100; x++) {\n+                \/\/ Flip a random range twice\n+                int rangeStart = generator.nextInt(100);\n+                int rangeEnd = rangeStart + generator.nextInt(100);\n+                b1.flip(rangeStart);\n+                b1.flip(rangeStart);\n+                if (b1.length() != 0)\n+                    failCount++;\n+                b1.flip(rangeStart, rangeEnd);\n+                b1.flip(rangeStart, rangeEnd);\n+                if (b1.length() != 0)\n+                    failCount++;\n+            }\n+            checkSanity(b1);\n+        }\n+\n+        \/\/ Test length after or\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+            int bit1 = generator.nextInt(100);\n+            int bit2 = generator.nextInt(100);\n+            int highestSetBit = (bit1 > bit2) ? bit1 : bit2;\n+            b1.set(bit1);\n+            b2.set(bit2);\n+            b1.or(b2);\n+            if (b1.length() != highestSetBit + 1)\n+                failCount++;\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Length                      \", failCount);\n+    }\n+\n+    private static void testClear() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Clear out a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the clear(int, int) call on b1\n+            b1.clear(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.clear(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"rangeStart = \" + rangeStart);\n+                System.out.println(\"rangeEnd = \" + rangeEnd);\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Clear                       \", failCount);\n+    }\n+\n+    private static void testSet() {\n+        int failCount = 0;\n+\n+        \/\/ Test set(int, int)\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Set a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the set(int, int) call on b1\n+            b1.set(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.set(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"Set 1\");\n+                System.out.println(\"rangeStart = \" + rangeStart);\n+                System.out.println(\"rangeEnd = \" + rangeEnd);\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        \/\/ Test set(int, int, boolean)\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+            boolean setOrClear = generator.nextBoolean();\n+\n+            \/\/ Set a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the set(int, int, boolean) call on b1\n+            b1.set(rangeStart, rangeEnd, setOrClear);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.set(x, setOrClear);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"Set 2\");\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Set                         \", failCount);\n+    }\n+\n+    private static void testFlip() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Flip a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the flip(int, int) call on b1\n+            b1.flip(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.flip(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2))\n+                failCount++;\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Flip                        \", failCount);\n+    }\n+\n+    private static void testGet() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            \/\/ Get a new set from a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            NaturalsBitSet b2 = b1.get(rangeStart, rangeEnd);\n+\n+            NaturalsBitSet b3 = new NaturalsBitSet();\n+            for(int x=rangeStart; x<rangeEnd; x++)\n+                b3.set(x-rangeStart, b1.get(x));\n+\n+            \/\/ Verify their equality\n+            if (!b2.equals(b3)) {\n+                System.out.println(\"start=\"+rangeStart);\n+                System.out.println(\"end=\"+rangeEnd);\n+                System.out.println(b1);\n+                System.out.println(b2);\n+                System.out.println(b3);\n+                failCount++;\n+            }\n+            checkEquality(b2,b3);\n+        }\n+\n+        report(\"Get                         \", failCount);\n+    }\n+\n+\n+    private static void testIntersects() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set\n+            int nextBitToSet = 0;\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure they intersect\n+            nextBitToSet = generator.nextInt(255);\n+            b1.set(nextBitToSet);\n+            b2.set(nextBitToSet);\n+\n+            if (!b1.intersects(b2))\n+                failCount++;\n+\n+            \/\/ Remove the common set bits\n+            b1.andNot(b2);\n+\n+            \/\/ Make sure they don't intersect\n+            if (b1.intersects(b2))\n+                failCount++;\n+\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Intersects                  \", failCount);\n+    }\n+\n+    private static void testCardinality() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+\n+            \/\/ Set a random number of increasing bits\n+            int nextBitToSet = 0;\n+            int iterations = generator.nextInt(20)+1;\n+            for (int x=0; x<iterations; x++) {\n+                nextBitToSet += generator.nextInt(20)+1;\n+                b1.set(nextBitToSet);\n+            }\n+\n+            if (b1.cardinality() != iterations) {\n+                System.out.println(\"Iterations is \"+iterations);\n+                System.out.println(\"Cardinality is \"+b1.cardinality());\n+                failCount++;\n+            }\n+\n+            checkSanity(b1);\n+        }\n+\n+        report(\"Cardinality                 \", failCount);\n+    }\n+\n+    private static void testEmpty() {\n+        int failCount = 0;\n+\n+        NaturalsBitSet b1 = new NaturalsBitSet();\n+        if (!b1.isEmpty())\n+            failCount++;\n+\n+        int nextBitToSet = 0;\n+        int numberOfSetBits = generator.nextInt(100) + 1;\n+        int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+        for (int x=0; x<numberOfSetBits; x++) {\n+            nextBitToSet = generator.nextInt(highestPossibleSetBit);\n+            b1.set(nextBitToSet);\n+            if (b1.isEmpty())\n+                failCount++;\n+            b1.clear(nextBitToSet);\n+            if (!b1.isEmpty())\n+                failCount++;\n+        }\n+\n+        report(\"Empty                       \", failCount);\n+    }\n+\n+    private static void testEmpty2() {\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.set(100); t.clear(3,600); checkEmpty(t);}\n+        checkEmpty(new NaturalsBitSet(0));\n+        checkEmpty(new NaturalsBitSet(342));\n+        NaturalsBitSet s = new NaturalsBitSet(0);\n+        checkEmpty(s);\n+        s.clear(92);      checkEmpty(s);\n+        s.clear(127,127); checkEmpty(s);\n+        s.set(127,127);   checkEmpty(s);\n+        s.set(128,128);   checkEmpty(s);\n+        NaturalsBitSet empty = new NaturalsBitSet();\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and   (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.or    (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.xor   (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.andNot(empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and   (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.or    (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.xor   (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.andNot(t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(1));   checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(127)); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(128)); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.flip(7);t.flip(7); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); checkEmpty(t.get(200,300));}\n+        {NaturalsBitSet t = makeSet(2,5); check(t.get(2,6).equals(makeSet(0,3)),\"\");}\n+    }\n+\n+    private static void testToString() {\n+        check(new NaturalsBitSet().toString().equals(\"{}\"));\n+        check(makeSet(2,3,42,43,234).toString().equals(\"{2, 3, 42, 43, 234}\"));\n+\n+        final long MB = 1024*1024;\n+        if (Runtime.getRuntime().maxMemory() >= 512*MB) {\n+            \/\/ only run it if we have enough memory\n+            try {\n+                check(makeSet(Integer.MAX_VALUE-1).toString().equals(\n+                        \"{\" + (Integer.MAX_VALUE-1) + \"}\"));\n+                check(makeSet(Integer.MAX_VALUE).toString().equals(\n+                        \"{\" + Integer.MAX_VALUE + \"}\"));\n+                check(makeSet(0, 1, Integer.MAX_VALUE-1, Integer.MAX_VALUE).toString().equals(\n+                        \"{0, 1, \" + (Integer.MAX_VALUE-1) + \", \" + Integer.MAX_VALUE + \"}\"));\n+            } catch (IndexOutOfBoundsException exc) {\n+                fail(\"toString() with indices near MAX_VALUE\");\n+            }\n+        }\n+    }\n+\n+    private static void testLogicalIdentities() {\n+        int failCount = 0;\n+\n+        \/\/ Verify that (!b1)|(!b2) == !(b1&b2)\n+        for (int i=0; i<50; i++) {\n+            \/\/ Construct two fairly random bitsets\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+            NaturalsBitSet b2 = new NaturalsBitSet();\n+\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+                b2.set(generator.nextInt(highestPossibleSetBit));\n+            }\n+\n+            NaturalsBitSet b3 = b1.clone();\n+            NaturalsBitSet b4 = b2.clone();\n+\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                b1.flip(x);\n+                b2.flip(x);\n+            }\n+            b1.or(b2);\n+            b3.and(b4);\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b3.flip(x);\n+            if (!b1.equals(b3))\n+                failCount++;\n+            checkSanity(b1, b2, b3, b4);\n+        }\n+\n+        \/\/ Verify that (b1&(!b2)|(b2&(!b1) == b1^b2\n+        for (int i=0; i<50; i++) {\n+            \/\/ Construct two fairly random bitsets\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+            NaturalsBitSet b2 = new NaturalsBitSet();\n+\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+                b2.set(generator.nextInt(highestPossibleSetBit));\n+            }\n+\n+            NaturalsBitSet b3 = b1.clone();\n+            NaturalsBitSet b4 = b2.clone();\n+            NaturalsBitSet b5 = b1.clone();\n+            NaturalsBitSet b6 = b2.clone();\n+\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b2.flip(x);\n+            b1.and(b2);\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b3.flip(x);\n+            b3.and(b4);\n+            b1.or(b3);\n+            b5.xor(b6);\n+            if (!b1.equals(b5))\n+                failCount++;\n+            checkSanity(b1, b2, b3, b4, b5, b6);\n+        }\n+        report(\"Logical Identities          \", failCount);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/NBSMethods.java","additions":961,"deletions":0,"binary":false,"changes":961,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Test previousClearBit, previousSetBit\n+ * @key randomness\n+ *\/\n+\n+import java.util.*;\n+\n+public class PreviousBits {\n+\n+    void testHashCode(final NaturalsBitSet s) {\n+        long h = 1234;\n+        long[] words = s.toLongArray();\n+        for (int i = words.length; --i >= 0; )\n+            h ^= words[i] * (i + 1);\n+        equal((int)((h >> 32) ^ h), s.hashCode());\n+    }\n+\n+    void testOutOfBounds(final NaturalsBitSet s) {\n+        THROWS(IndexOutOfBoundsException.class,\n+               new F(){void f(){ s.previousSetBit(-2);}},\n+               new F(){void f(){ s.previousClearBit(-2);}},\n+               new F(){void f(){ s.previousSetBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.previousClearBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.nextSetBit(-1);}},\n+               new F(){void f(){ s.nextClearBit(-1);}},\n+               new F(){void f(){ s.nextSetBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.nextClearBit(Integer.MIN_VALUE);}});\n+    }\n+\n+    void test(String[] args) throws Throwable {\n+        final NaturalsBitSet s = new NaturalsBitSet();\n+\n+        \/\/ Test empty bitset\n+        testOutOfBounds(s);\n+        testHashCode(s);\n+\n+        for (int i = -1; i < 93;) {\n+            equal(-1, s.previousSetBit(i));\n+            equal( i, s.previousClearBit(i));\n+            i++;\n+            equal(-1, s.nextSetBit(i));\n+            equal( i, s.nextClearBit(i));\n+        }\n+\n+        \/\/ Test \"singleton\" bitsets\n+        for (int j = 0; j < 161; j++) {\n+            s.clear();\n+            s.set(j);\n+            testOutOfBounds(s);\n+            testHashCode(s);\n+\n+            for (int i = -1; i < j; i++) {\n+                equal(-1, s.previousSetBit(i));\n+                equal( i, s.previousClearBit(i));\n+                if (i >= 0) {\n+                    equal(j, s.nextSetBit(i));\n+                    equal(i, s.nextClearBit(i));\n+                }\n+            }\n+\n+            equal(j,   s.previousSetBit(j));\n+            equal(j-1, s.previousClearBit(j));\n+            equal(j,   s.nextSetBit(j));\n+            equal(j+1, s.nextClearBit(j));\n+\n+            for (int i = j+1; i < j+100; i++) {\n+                equal(j, s.previousSetBit(i));\n+                equal(i, s.previousClearBit(i));\n+                equal(-1, s.nextSetBit(i));\n+                equal(i, s.nextClearBit(i));\n+            }\n+        }\n+\n+        \/\/ set even bits\n+        s.clear();\n+        for (int i = 0; i <= 128; i+=2)\n+            s.set(i);\n+        testHashCode(s);\n+        for (int i = 1; i <= 128; i++) {\n+            equal(s.previousSetBit(i),\n+                  ((i & 1) == 0) ? i : i - 1);\n+            equal(s.previousClearBit(i),\n+                  ((i & 1) == 0) ? i - 1 : i);\n+        }\n+\n+        \/\/ set odd bits as well\n+        for (int i = 1; i <= 128; i+=2)\n+            s.set(i);\n+        testHashCode(s);\n+        for (int i = 1; i <= 128; i++) {\n+            equal(s.previousSetBit(i), i);\n+            equal(s.previousClearBit(i), -1);\n+        }\n+\n+        \/\/ Test loops documented in javadoc\n+        Random rnd = new Random();\n+        s.clear();\n+        for (int i = 0; i < 10; i++)\n+            s.set(rnd.nextInt(1066));\n+        List<Integer> down = new ArrayList<Integer>();\n+        for (int i = s.length(); (i = s.previousSetBit(i-1)) >= 0; )\n+            down.add(i);\n+        List<Integer> up = new ArrayList<Integer>();\n+        for (int i = s.nextSetBit(0); i >= 0; i = s.nextSetBit(i+1))\n+            up.add(i);\n+        Collections.reverse(up);\n+        equal(up, down);\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    volatile int passed = 0, failed = 0;\n+    void pass() {passed++;}\n+    void fail() {failed++; Thread.dumpStack();}\n+    void fail(String msg) {System.err.println(msg); fail();}\n+    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    void check(boolean cond) {if (cond) pass(); else fail();}\n+    void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        new PreviousBits().instanceMain(args);}\n+    void instanceMain(String[] args) throws Throwable {\n+        try {test(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    abstract class F {abstract void f() throws Throwable;}\n+    void THROWS(Class<? extends Throwable> k, F... fs) {\n+        for (F f : fs)\n+            try {f.f(); fail(\"Expected \" + k.getName() + \" not thrown\");}\n+            catch (Throwable t) {\n+                if (k.isAssignableFrom(t.getClass())) pass();\n+                else unexpected(t);}}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/PreviousBits.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Check capacity management\n+ * @author Martin Buchholz\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class StickySize {\n+    static void equalClones(NaturalsBitSet s, int expectedSize) {\n+        equal(expectedSize, s.clone().size());\n+        equal(expectedSize, serialClone(s).size());\n+        equal(expectedSize, s.size());\n+        equal(s.clone(), serialClone(s));\n+    }\n+\n+    private static void realMain(String[] args) {\n+        NaturalsBitSet s;\n+\n+        s = new NaturalsBitSet();       \/\/ non-sticky\n+        equal(s.size(), 64);\n+        equalClones(s, 0);\n+        s.set(3*64);\n+        s.set(7*64);\n+        equal(s.size(), 8*64);\n+        equalClones(s, 8*64);\n+        s.clear(7*64);\n+        equal(s.size(), 8*64);\n+        equalClones(s, 4*64);\n+\n+        s = new NaturalsBitSet(8*64);   \/\/ sticky\n+        equalClones(s, 8*64);\n+        s.set(3*64);\n+        s.set(7*64);\n+        equalClones(s, 8*64);\n+        s.clear(7*64);\n+        equalClones(s, 8*64);\n+        equalClones(s.clone(), 8*64);\n+        equalClones(serialClone(s), 8*64);\n+        s.set(17*64);           \/\/ Expand beyond sticky size\n+        equalClones(s, 18*64);\n+        s.clear(17*64);\n+        equalClones(s, 4*64);\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    static volatile int passed = 0, failed = 0;\n+    static void pass() {passed++;}\n+    static void fail() {failed++; Thread.dumpStack();}\n+    static void fail(String msg) {System.out.println(msg); fail();}\n+    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    static void check(boolean cond) {if (cond) pass(); else fail();}\n+    static void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    static byte[] serializedForm(Object obj) {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            new ObjectOutputStream(baos).writeObject(obj);\n+            return baos.toByteArray();\n+        } catch (IOException e) { throw new RuntimeException(e); }}\n+    static Object readObject(byte[] bytes)\n+        throws IOException, ClassNotFoundException {\n+        InputStream is = new ByteArrayInputStream(bytes);\n+        return new ObjectInputStream(is).readObject();}\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serialClone(T obj) {\n+        try { return (T) readObject(serializedForm(obj)); }\n+        catch (Exception e) { throw new RuntimeException(e); }}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/StickySize.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}