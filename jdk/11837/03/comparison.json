{"files":[{"patch":"@@ -100,0 +100,6 @@\n+    \n+    \/**\n+     * The number of bits set to {@code true} in this {@code BitSet}.\n+     * @since  21\n+     *\/\n+    private transient int cardinality = 0;\n@@ -125,0 +131,1 @@\n+        assert(cardinality >= 0 && cardinality -1 <= length() - 1); \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n@@ -179,0 +186,1 @@\n+        computeCardinality();\n@@ -182,0 +190,23 @@\n+    private void computeCardinality() {\n+        cardinality = bitCount(0, wordsInUse);\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true, starting from\n+     * startWord (inclusive) to endWord (exclusive)\n+     *\/\n+    private int bitCount(int startWord, int endWord) {\n+        int sum = 0;\n+        for (int i = startWord; i < endWord; i++)\n+            sum += bitCount(i);\n+        \n+        return sum;\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true at the specified word\n+     *\/\n+    private int bitCount(int wordIndex) {\n+        return Long.bitCount(words[wordIndex]);\n+    }\n+\n@@ -387,3 +418,5 @@\n-\n-        words[wordIndex] ^= (1L << bitIndex);\n-\n+        \n+        final long bitMask = 1L << bitIndex;\n+        words[wordIndex] ^= bitMask;\n+        cardinality += (words[wordIndex] & bitMask) != 0 ? 1 : -1;\n+        \n@@ -420,0 +453,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -421,0 +455,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -424,0 +459,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -425,0 +461,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -427,1 +464,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n+                cardinality += BITS_PER_WORD - 2 * bitCount(i);\n@@ -429,0 +467,1 @@\n+            }\n@@ -431,0 +470,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -432,0 +472,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -450,0 +491,4 @@\n+        final long bitMask = 1L << bitIndex;\n+        if (wordIndex < wordsInUse && (words[wordIndex] & bitMask) != 0)\n+            return;\n+        \n@@ -451,2 +496,2 @@\n-\n-        words[wordIndex] |= (1L << bitIndex); \/\/ Restores invariants\n+        words[wordIndex] |= bitMask; \/\/ Restores invariants\n+        cardinality++;\n@@ -498,0 +543,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -499,0 +545,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -502,0 +549,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -503,0 +551,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -505,1 +554,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n+                cardinality += BITS_PER_WORD - bitCount(i);\n@@ -507,0 +557,1 @@\n+            }\n@@ -509,0 +560,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -510,0 +562,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -546,1 +599,2 @@\n-        if (wordIndex >= wordsInUse)\n+        final long bitMask = 1L << bitIndex;\n+        if (wordIndex >= wordsInUse || (words[wordIndex] & bitMask) == 0)\n@@ -549,1 +603,2 @@\n-        words[wordIndex] &= ~(1L << bitIndex);\n+        words[wordIndex] &= ~bitMask;\n+        cardinality--;\n@@ -586,0 +641,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -587,0 +643,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -590,0 +647,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -591,0 +649,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -593,1 +652,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n+                cardinality -= bitCount(i);\n@@ -595,0 +655,1 @@\n+            }\n@@ -597,0 +658,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -598,0 +660,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -610,2 +673,3 @@\n-        while (wordsInUse > 0)\n-            words[--wordsInUse] = 0;\n+        Arrays.fill(words, 0, wordsInUse, 0);\n+        wordsInUse = 0;\n+        cardinality = 0;\n@@ -683,1 +747,1 @@\n-        \/\/ Set wordsInUse correctly\n+        \/\/ Set wordsInUse and cardinality correctly\n@@ -686,0 +750,1 @@\n+        result.computeCardinality();\n@@ -862,2 +927,1 @@\n-        return BITS_PER_WORD * (wordsInUse - 1) +\n-            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - 1]));\n+        return BITS_PER_WORD * wordsInUse - Long.numberOfLeadingZeros(words[wordsInUse - 1]);\n@@ -874,1 +938,1 @@\n-        return wordsInUse == 0;\n+        return cardinality == 0;\n@@ -893,0 +957,20 @@\n+    \/**\n+     * Returns true if all bits set to {@code true} in the specified {@code BitSet}\n+     * are also set to {@code true} in this {@code BitSet}.\n+     *\n+     * @param  set {@code BitSet} to test\n+     * @return boolean indicating whether this {@code BitSet} includes\n+     *         the specified {@code BitSet}\n+     * @since  21\n+     *\/\n+    public boolean includes(BitSet set) {\n+        if (set.cardinality > cardinality || set.length() > length())\n+            return false;\n+        \n+        \/\/ set.wordsInUse <= wordsInUse\n+        for (int i = set.wordsInUse - 1; i >= 0; i--)\n+            if ((~set.words[i] | words[i]) != WORD_MASK) \/\/ Perform logical (!a | b) on words in common\n+                return false;\n+        return true;\n+    }\n+\n@@ -900,4 +984,1 @@\n-        int sum = 0;\n-        for (int i = 0; i < wordsInUse; i++)\n-            sum += Long.bitCount(words[i]);\n-        return sum;\n+        return cardinality;\n@@ -927,0 +1008,1 @@\n+        computeCardinality();\n@@ -961,0 +1043,1 @@\n+        computeCardinality();\n@@ -979,0 +1062,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+\n@@ -997,0 +1086,1 @@\n+        computeCardinality();\n@@ -1010,1 +1100,2 @@\n-        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--)\n+        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--) {\n+            cardinality -= bitCount(i);\n@@ -1012,0 +1103,2 @@\n+            cardinality += bitCount(i);\n+        }\n@@ -1077,1 +1170,1 @@\n-        if (wordsInUse != set.wordsInUse)\n+        if (cardinality != set.cardinality || length() != set.length())\n@@ -1157,0 +1250,1 @@\n+        computeCardinality();\n@@ -1188,5 +1282,3 @@\n-        int numBits = (wordsInUse > 128) ?\n-            cardinality() : wordsInUse * BITS_PER_WORD;\n-        \/\/ Avoid overflow in the case of a humongous numBits\n-        int initialCapacity = (numBits <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n-            6 * numBits + 2 : MAX_INITIAL_CAPACITY;\n+        \/\/ Avoid overflow in the case of a humongous cardinality\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n+            6 * cardinality + 2 : MAX_INITIAL_CAPACITY;\n@@ -1253,1 +1345,1 @@\n-                    est = cardinality();\n+                    est = cardinality;\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":120,"deletions":28,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -821,0 +821,40 @@\n+    }\n+\n+    private static void testIncludes() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            BitSet b1 = new BitSet(256);\n+            BitSet b2 = new BitSet(256);\n+\n+            \/\/ Set some random bits in first set\n+            int nextBitToSet = 0;\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure b1 includes b2\n+            b1.or(b2);\n+\n+            if (!b1.includes(b2))\n+                failCount++;\n+\n+            \/\/ Remove a common set bit\n+            nextBitToSet = b2.nextSetBit(generator.nextInt(b2.length()));\n+            b1.clear(nextBitToSet);\n+\n+            \/\/ Make sure b1 doesn't include b2\n+            if (b1.includes(b2))\n+                failCount++;\n+\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Includes                  \", failCount);\n","filename":"test\/jdk\/java\/util\/BitSet\/BSMethods.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}