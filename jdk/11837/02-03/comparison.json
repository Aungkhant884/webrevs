{"files":[{"patch":"@@ -37,6 +37,7 @@\n- * This class implements a vector of bits that grows as needed. Each component\n- * of the bit set has a {@code boolean} value. The bits of a {@code BitSet} are\n- * indexed by nonnegative integers. Individual indexed bits can be examined,\n- * set, or cleared. One {@code BitSet} may be used to modify the contents of\n- * another {@code BitSet} through logical AND, logical inclusive OR, and logical\n- * exclusive OR operations.\n+ * This class implements a vector of bits that grows as needed. Each\n+ * component of the bit set has a {@code boolean} value. The\n+ * bits of a {@code BitSet} are indexed by nonnegative integers.\n+ * Individual indexed bits can be examined, set, or cleared. One\n+ * {@code BitSet} may be used to modify the contents of another\n+ * {@code BitSet} through logical AND, logical inclusive OR, and\n+ * logical exclusive OR operations.\n@@ -44,2 +45,2 @@\n- * <p>\n- * By default, all bits in the set initially have the value {@code false}.\n+ * <p>By default, all bits in the set initially have the value\n+ * {@code false}.\n@@ -47,6 +48,5 @@\n- * <p>\n- * Every bit set has a current size, which is the number of bits of space\n- * currently in use by the bit set. Note that the size is related to the\n- * implementation of a bit set, so it may change with implementation. The length\n- * of a bit set relates to logical length of a bit set and is defined\n- * independently of implementation.\n+ * <p>Every bit set has a current size, which is the number of bits\n+ * of space currently in use by the bit set. Note that the size is\n+ * related to the implementation of a bit set, so it may change with\n+ * implementation. The length of a bit set relates to logical length\n+ * of a bit set and is defined independently of implementation.\n@@ -54,3 +54,3 @@\n- * <p>\n- * Unless otherwise noted, passing a null parameter to any of the methods in a\n- * {@code BitSet} will result in a {@code NullPointerException}.\n+ * <p>Unless otherwise noted, passing a null parameter to any of the\n+ * methods in a {@code BitSet} will result in a\n+ * {@code NullPointerException}.\n@@ -58,3 +58,2 @@\n- * <p>\n- * A {@code BitSet} is not safe for multithreaded use without external\n- * synchronization.\n+ * <p>A {@code BitSet} is not safe for multithreaded use without\n+ * external synchronization.\n@@ -62,4 +61,4 @@\n- * @author Arthur van Hoff\n- * @author Michael McCloskey\n- * @author Martin Buchholz\n- * @since 1.0\n+ * @author  Arthur van Hoff\n+ * @author  Michael McCloskey\n+ * @author  Martin Buchholz\n+ * @since   1.0\n@@ -69,3 +68,3 @@\n-     * BitSets are packed into arrays of \"words.\" Currently a word is a long, which\n-     * consists of 64 bits, requiring 6 address bits. The choice of word size is\n-     * determined purely by performance concerns.\n+     * BitSets are packed into arrays of \"words.\"  Currently a word is\n+     * a long, which consists of 64 bits, requiring 6 address bits.\n+     * The choice of word size is determined purely by performance concerns.\n@@ -83,4 +82,3 @@\n-     *                   The bits in this BitSet. The ith bit is stored in\n-     *                   bits[i\/64] at bit position i % 64 (where bit position 0\n-     *                   refers to the least significant bit and 63 refers to the\n-     *                   most significant bit).\n+     * The bits in this BitSet.  The ith bit is stored in bits[i\/64] at\n+     * bit position i % 64 (where bit position 0 refers to the least\n+     * significant bit and 63 refers to the most significant bit).\n@@ -89,1 +87,3 @@\n-    private static final ObjectStreamField[] serialPersistentFields = { new ObjectStreamField(\"bits\", long[].class), };\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+        new ObjectStreamField(\"bits\", long[].class),\n+    };\n@@ -100,1 +100,1 @@\n-\n+    \n@@ -103,2 +103,1 @@\n-     *\n-     * @since 21\n+     * @since  21\n@@ -109,2 +108,2 @@\n-     * Whether the size of \"words\" is user-specified. If so, we assume the user\n-     * knows what he's doing and try harder to preserve it.\n+     * Whether the size of \"words\" is user-specified.  If so, we assume\n+     * the user knows what he's doing and try harder to preserve it.\n@@ -129,5 +128,4 @@\n-        assert (wordsInUse == 0 || words[wordsInUse - 1] != 0);\n-        assert (wordsInUse >= 0 && wordsInUse <= words.length);\n-        assert (wordsInUse == words.length || words[wordsInUse] == 0);\n-        assert (cardinality >= 0 && cardinality - 1 <= length() - 1); \/\/ avoid overflow if get(Integer.MAX_VALUE) ==\n-                                                                      \/\/ true\n+        assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);\n+        assert(wordsInUse >= 0 && wordsInUse <= words.length);\n+        assert(wordsInUse == words.length || words[wordsInUse] == 0);\n+        assert(cardinality >= 0 && cardinality -1 <= length() - 1); \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n@@ -138,2 +136,2 @@\n-     * WARNING:This method assumes that the number of words actually in use is less\n-     * than or equal to the current value of wordsInUse!\n+     * WARNING:This method assumes that the number of words actually in use is\n+     * less than or equal to the current value of wordsInUse!\n@@ -144,1 +142,1 @@\n-        for (i = wordsInUse - 1; i >= 0; i--)\n+        for (i = wordsInUse-1; i >= 0; i--)\n@@ -148,1 +146,1 @@\n-        wordsInUse = i + 1; \/\/ The new logical size\n+        wordsInUse = i+1; \/\/ The new logical size\n@@ -160,3 +158,3 @@\n-     * Creates a bit set whose initial size is large enough to explicitly represent\n-     * bits with indices in the range {@code 0} through {@code nbits-1}. All bits\n-     * are initially {@code false}.\n+     * Creates a bit set whose initial size is large enough to explicitly\n+     * represent bits with indices in the range {@code 0} through\n+     * {@code nbits-1}. All bits are initially {@code false}.\n@@ -164,2 +162,3 @@\n-     * @param nbits the initial size of the bit set\n-     * @throws NegativeArraySizeException if the specified initial size is negative\n+     * @param  nbits the initial size of the bit set\n+     * @throws NegativeArraySizeException if the specified initial size\n+     *         is negative\n@@ -177,1 +176,1 @@\n-        words = new long[wordIndex(nbits - 1) + 1];\n+        words = new long[wordIndex(nbits-1) + 1];\n@@ -181,2 +180,2 @@\n-     * Creates a bit set using words as the internal representation. The last word\n-     * (if there is one) must be non-zero.\n+     * Creates a bit set using words as the internal representation.\n+     * The last word (if there is one) must be non-zero.\n@@ -196,2 +195,2 @@\n-     * Returns the number of bits set to true, starting from startWord (inclusive)\n-     * to endWord (exclusive)\n+     * Returns the number of bits set to true, starting from\n+     * startWord (inclusive) to endWord (exclusive)\n@@ -203,1 +202,1 @@\n-\n+        \n@@ -217,5 +216,3 @@\n-     * <p>\n-     * More precisely, <br>\n-     * {@code BitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n-     * <br>\n-     * for all {@code n < 64 * longs.length}.\n+     * <p>More precisely,\n+     * <br>{@code BitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>for all {@code n < 64 * longs.length}.\n@@ -223,2 +220,2 @@\n-     * <p>\n-     * This method is equivalent to {@code BitSet.valueOf(LongBuffer.wrap(longs))}.\n+     * <p>This method is equivalent to\n+     * {@code BitSet.valueOf(LongBuffer.wrap(longs))}.\n@@ -226,3 +223,3 @@\n-     * @param longs a long array containing a little-endian representation of a\n-     *              sequence of bits to be used as the initial bits of the new bit\n-     *              set\n+     * @param longs a long array containing a little-endian representation\n+     *        of a sequence of bits to be used as the initial bits of the\n+     *        new bit set\n@@ -240,2 +237,2 @@\n-     * Returns a new bit set containing all the bits in the given long buffer\n-     * between its position and limit.\n+     * Returns a new bit set containing all the bits in the given long\n+     * buffer between its position and limit.\n@@ -243,5 +240,3 @@\n-     * <p>\n-     * More precisely, <br>\n-     * {@code BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n-     * <br>\n-     * for all {@code n < 64 * lb.remaining()}.\n+     * <p>More precisely,\n+     * <br>{@code BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n+     * <br>for all {@code n < 64 * lb.remaining()}.\n@@ -249,3 +244,2 @@\n-     * <p>\n-     * The long buffer is not modified by this method, and no reference to the\n-     * buffer is retained by the bit set.\n+     * <p>The long buffer is not modified by this method, and no\n+     * reference to the buffer is retained by the bit set.\n@@ -253,3 +247,3 @@\n-     * @param lb a long buffer containing a little-endian representation of a\n-     *           sequence of bits between its position and limit, to be used as the\n-     *           initial bits of the new bit set\n+     * @param lb a long buffer containing a little-endian representation\n+     *        of a sequence of bits between its position and limit, to be\n+     *        used as the initial bits of the new bit set\n@@ -273,4 +267,3 @@\n-     * <p>\n-     * More precisely, <br>\n-     * {@code BitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)} <br>\n-     * for all {@code n <  8 * bytes.length}.\n+     * <p>More precisely,\n+     * <br>{@code BitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n <  8 * bytes.length}.\n@@ -278,2 +271,2 @@\n-     * <p>\n-     * This method is equivalent to {@code BitSet.valueOf(ByteBuffer.wrap(bytes))}.\n+     * <p>This method is equivalent to\n+     * {@code BitSet.valueOf(ByteBuffer.wrap(bytes))}.\n@@ -281,3 +274,3 @@\n-     * @param bytes a byte array containing a little-endian representation of a\n-     *              sequence of bits to be used as the initial bits of the new bit\n-     *              set\n+     * @param bytes a byte array containing a little-endian\n+     *        representation of a sequence of bits to be used as the\n+     *        initial bits of the new bit set\n@@ -292,2 +285,2 @@\n-     * Returns a new bit set containing all the bits in the given byte buffer\n-     * between its position and limit.\n+     * Returns a new bit set containing all the bits in the given byte\n+     * buffer between its position and limit.\n@@ -295,5 +288,3 @@\n-     * <p>\n-     * More precisely, <br>\n-     * {@code BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n-     * <br>\n-     * for all {@code n < 8 * bb.remaining()}.\n+     * <p>More precisely,\n+     * <br>{@code BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n < 8 * bb.remaining()}.\n@@ -301,3 +292,2 @@\n-     * <p>\n-     * The byte buffer is not modified by this method, and no reference to the\n-     * buffer is retained by the bit set.\n+     * <p>The byte buffer is not modified by this method, and no\n+     * reference to the buffer is retained by the bit set.\n@@ -305,3 +295,3 @@\n-     * @param bb a byte buffer containing a little-endian representation of a\n-     *           sequence of bits between its position and limit, to be used as the\n-     *           initial bits of the new bit set\n+     * @param bb a byte buffer containing a little-endian representation\n+     *        of a sequence of bits between its position and limit, to be\n+     *        used as the initial bits of the new bit set\n@@ -330,6 +320,5 @@\n-     * <p>\n-     * More precisely, if <br>\n-     * {@code byte[] bytes = s.toByteArray();} <br>\n-     * then {@code bytes.length == (s.length()+7)\/8} and <br>\n-     * {@code s.get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)} <br>\n-     * for all {@code n < 8 * bytes.length}.\n+     * <p>More precisely, if\n+     * <br>{@code byte[] bytes = s.toByteArray();}\n+     * <br>then {@code bytes.length == (s.length()+7)\/8} and\n+     * <br>{@code s.get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n < 8 * bytes.length}.\n@@ -337,2 +326,2 @@\n-     * @return a byte array containing a little-endian representation of all the\n-     *         bits in this bit set\n+     * @return a byte array containing a little-endian representation\n+     *         of all the bits in this bit set\n@@ -345,1 +334,1 @@\n-        int len = 8 * (n - 1);\n+        int len = 8 * (n-1);\n@@ -360,6 +349,5 @@\n-     * <p>\n-     * More precisely, if <br>\n-     * {@code long[] longs = s.toLongArray();} <br>\n-     * then {@code longs.length == (s.length()+63)\/64} and <br>\n-     * {@code s.get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)} <br>\n-     * for all {@code n < 64 * longs.length}.\n+     * <p>More precisely, if\n+     * <br>{@code long[] longs = s.toLongArray();}\n+     * <br>then {@code longs.length == (s.length()+63)\/64} and\n+     * <br>{@code s.get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>for all {@code n < 64 * longs.length}.\n@@ -367,2 +355,2 @@\n-     * @return a long array containing a little-endian representation of all the\n-     *         bits in this bit set\n+     * @return a long array containing a little-endian representation\n+     *         of all the bits in this bit set\n@@ -377,1 +365,0 @@\n-     *\n@@ -390,4 +377,4 @@\n-     * Ensures that the BitSet can accommodate a given wordIndex, temporarily\n-     * violating the invariants. The caller must restore the invariants before\n-     * returning to the user, possibly using recalculateWordsInUse().\n-     *\n+     * Ensures that the BitSet can accommodate a given wordIndex,\n+     * temporarily violating the invariants.  The caller must\n+     * restore the invariants before returning to the user,\n+     * possibly using recalculateWordsInUse().\n@@ -397,1 +384,1 @@\n-        int wordsRequired = wordIndex + 1;\n+        int wordsRequired = wordIndex+1;\n@@ -413,1 +400,2 @@\n-            throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex + \" > toIndex: \" + toIndex);\n+            throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex +\n+                                                \" > toIndex: \" + toIndex);\n@@ -417,1 +405,2 @@\n-     * Sets the bit at the specified index to the complement of its current value.\n+     * Sets the bit at the specified index to the complement of its\n+     * current value.\n@@ -419,1 +408,1 @@\n-     * @param bitIndex the index of the bit to flip\n+     * @param  bitIndex the index of the bit to flip\n@@ -421,1 +410,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -429,1 +418,1 @@\n-\n+        \n@@ -433,1 +422,1 @@\n-\n+        \n@@ -440,9 +429,9 @@\n-     * specified {@code toIndex} (exclusive) to the complement of its current value.\n-     *\n-     * @param fromIndex index of the first bit to flip\n-     * @param toIndex   index after the last bit to flip\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n-     *                                   {@code toIndex} is negative, or\n-     *                                   {@code fromIndex} is larger than\n-     *                                   {@code toIndex}\n-     * @since 1.4\n+     * specified {@code toIndex} (exclusive) to the complement of its current\n+     * value.\n+     *\n+     * @param  fromIndex index of the first bit to flip\n+     * @param  toIndex index after the last bit to flip\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n+     *         or {@code toIndex} is negative, or {@code fromIndex} is\n+     *         larger than {@code toIndex}\n+     * @since  1.4\n@@ -457,1 +446,1 @@\n-        int endWordIndex = wordIndex(toIndex - 1);\n+        int endWordIndex   = wordIndex(toIndex - 1);\n@@ -461,1 +450,1 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n+        long lastWordMask  = WORD_MASK >>> -toIndex;\n@@ -475,1 +464,1 @@\n-            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n@@ -493,1 +482,1 @@\n-     * @param bitIndex a bit index\n+     * @param  bitIndex a bit index\n@@ -495,1 +484,1 @@\n-     * @since 1.0\n+     * @since  1.0\n@@ -505,1 +494,1 @@\n-\n+        \n@@ -516,2 +505,2 @@\n-     * @param bitIndex a bit index\n-     * @param value    a boolean value to set\n+     * @param  bitIndex a bit index\n+     * @param  value a boolean value to set\n@@ -519,1 +508,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -532,7 +521,6 @@\n-     * @param fromIndex index of the first bit to be set\n-     * @param toIndex   index after the last bit to be set\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n-     *                                   {@code toIndex} is negative, or\n-     *                                   {@code fromIndex} is larger than\n-     *                                   {@code toIndex}\n-     * @since 1.4\n+     * @param  fromIndex index of the first bit to be set\n+     * @param  toIndex index after the last bit to be set\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n+     *         or {@code toIndex} is negative, or {@code fromIndex} is\n+     *         larger than {@code toIndex}\n+     * @since  1.4\n@@ -548,1 +536,1 @@\n-        int endWordIndex = wordIndex(toIndex - 1);\n+        int endWordIndex   = wordIndex(toIndex - 1);\n@@ -552,1 +540,1 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n+        long lastWordMask  = WORD_MASK >>> -toIndex;\n@@ -566,1 +554,1 @@\n-            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n@@ -584,8 +572,7 @@\n-     * @param fromIndex index of the first bit to be set\n-     * @param toIndex   index after the last bit to be set\n-     * @param value     value to set the selected bits to\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n-     *                                   {@code toIndex} is negative, or\n-     *                                   {@code fromIndex} is larger than\n-     *                                   {@code toIndex}\n-     * @since 1.4\n+     * @param  fromIndex index of the first bit to be set\n+     * @param  toIndex index after the last bit to be set\n+     * @param  value value to set the selected bits to\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n+     *         or {@code toIndex} is negative, or {@code fromIndex} is\n+     *         larger than {@code toIndex}\n+     * @since  1.4\n@@ -603,1 +590,1 @@\n-     * @param bitIndex the index of the bit to be cleared\n+     * @param  bitIndex the index of the bit to be cleared\n@@ -605,1 +592,1 @@\n-     * @since 1.0\n+     * @since  1.0\n@@ -627,7 +614,6 @@\n-     * @param fromIndex index of the first bit to be cleared\n-     * @param toIndex   index after the last bit to be cleared\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n-     *                                   {@code toIndex} is negative, or\n-     *                                   {@code fromIndex} is larger than\n-     *                                   {@code toIndex}\n-     * @since 1.4\n+     * @param  fromIndex index of the first bit to be cleared\n+     * @param  toIndex index after the last bit to be cleared\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n+     *         or {@code toIndex} is negative, or {@code fromIndex} is\n+     *         larger than {@code toIndex}\n+     * @since  1.4\n@@ -652,1 +638,1 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n+        long lastWordMask  = WORD_MASK >>> -toIndex;\n@@ -666,1 +652,1 @@\n-            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n@@ -693,3 +679,4 @@\n-     * Returns the value of the bit with the specified index. The value is\n-     * {@code true} if the bit with the index {@code bitIndex} is currently set in\n-     * this {@code BitSet}; otherwise, the result is {@code false}.\n+     * Returns the value of the bit with the specified index. The value\n+     * is {@code true} if the bit with the index {@code bitIndex}\n+     * is currently set in this {@code BitSet}; otherwise, the result\n+     * is {@code false}.\n@@ -697,1 +684,1 @@\n-     * @param bitIndex the bit index\n+     * @param  bitIndex   the bit index\n@@ -708,1 +695,2 @@\n-        return (wordIndex < wordsInUse) && ((words[wordIndex] & (1L << bitIndex)) != 0);\n+        return (wordIndex < wordsInUse)\n+            && ((words[wordIndex] & (1L << bitIndex)) != 0);\n@@ -712,2 +700,2 @@\n-     * Returns a new {@code BitSet} composed of bits from this {@code BitSet} from\n-     * {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).\n+     * Returns a new {@code BitSet} composed of bits from this {@code BitSet}\n+     * from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).\n@@ -715,2 +703,2 @@\n-     * @param fromIndex index of the first bit to include\n-     * @param toIndex   index after the last bit to include\n+     * @param  fromIndex index of the first bit to include\n+     * @param  toIndex index after the last bit to include\n@@ -718,5 +706,4 @@\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n-     *                                   {@code toIndex} is negative, or\n-     *                                   {@code fromIndex} is larger than\n-     *                                   {@code toIndex}\n-     * @since 1.4\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n+     *         or {@code toIndex} is negative, or {@code fromIndex} is\n+     *         larger than {@code toIndex}\n+     * @since  1.4\n@@ -746,2 +733,3 @@\n-            result.words[i] = wordAligned ? words[sourceIndex]\n-                    : (words[sourceIndex] >>> fromIndex) | (words[sourceIndex + 1] << -fromIndex);\n+            result.words[i] = wordAligned ? words[sourceIndex] :\n+                (words[sourceIndex] >>> fromIndex) |\n+                (words[sourceIndex+1] << -fromIndex);\n@@ -751,4 +739,7 @@\n-        result.words[targetWords - 1] = ((toIndex - 1) & BIT_INDEX_MASK) < (fromIndex & BIT_INDEX_MASK)\n-                ? \/* straddles source words *\/\n-                ((words[sourceIndex] >>> fromIndex) | (words[sourceIndex + 1] & lastWordMask) << -fromIndex)\n-                : ((words[sourceIndex] & lastWordMask) >>> fromIndex);\n+        result.words[targetWords - 1] =\n+            ((toIndex-1) & BIT_INDEX_MASK) < (fromIndex & BIT_INDEX_MASK)\n+            ? \/* straddles source words *\/\n+            ((words[sourceIndex] >>> fromIndex) |\n+             (words[sourceIndex+1] & lastWordMask) << -fromIndex)\n+            :\n+            ((words[sourceIndex] & lastWordMask) >>> fromIndex);\n@@ -766,3 +757,3 @@\n-     * Returns the index of the first bit that is set to {@code true} that occurs on\n-     * or after the specified starting index. If no such bit exists then {@code -1}\n-     * is returned.\n+     * Returns the index of the first bit that is set to {@code true}\n+     * that occurs on or after the specified starting index. If no such\n+     * bit exists then {@code -1} is returned.\n@@ -770,3 +761,2 @@\n-     * <p>\n-     * To iterate over the {@code true} bits in a {@code BitSet}, use the following\n-     * loop:\n+     * <p>To iterate over the {@code true} bits in a {@code BitSet},\n+     * use the following loop:\n@@ -774,2 +764,2 @@\n-     * <pre> {@code\n-     * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n+     *  <pre> {@code\n+     * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n@@ -780,2 +770,1 @@\n-     * }\n-     * }<\/pre>\n+     * }}<\/pre>\n@@ -783,2 +772,3 @@\n-     * @param fromIndex the index to start checking from (inclusive)\n-     * @return the index of the next set bit, or {@code -1} if there is no such bit\n+     * @param  fromIndex the index to start checking from (inclusive)\n+     * @return the index of the next set bit, or {@code -1} if there\n+     *         is no such bit\n@@ -786,1 +776,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -810,2 +800,2 @@\n-     * Returns the index of the first bit that is set to {@code false} that occurs\n-     * on or after the specified starting index.\n+     * Returns the index of the first bit that is set to {@code false}\n+     * that occurs on or after the specified starting index.\n@@ -813,1 +803,1 @@\n-     * @param fromIndex the index to start checking from (inclusive)\n+     * @param  fromIndex the index to start checking from (inclusive)\n@@ -816,1 +806,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -842,3 +832,4 @@\n-     * Returns the index of the nearest bit that is set to {@code true} that occurs\n-     * on or before the specified starting index. If no such bit exists, or if\n-     * {@code -1} is given as the starting index, then {@code -1} is returned.\n+     * Returns the index of the nearest bit that is set to {@code true}\n+     * that occurs on or before the specified starting index.\n+     * If no such bit exists, or if {@code -1} is given as the\n+     * starting index, then {@code -1} is returned.\n@@ -846,3 +837,2 @@\n-     * <p>\n-     * To iterate over the {@code true} bits in a {@code BitSet}, use the following\n-     * loop:\n+     * <p>To iterate over the {@code true} bits in a {@code BitSet},\n+     * use the following loop:\n@@ -850,2 +840,2 @@\n-     * <pre> {@code\n-     * for (int i = bs.length(); (i = bs.previousSetBit(i - 1)) >= 0;) {\n+     *  <pre> {@code\n+     * for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\n@@ -853,9 +843,8 @@\n-     * }\n-     * }<\/pre>\n-     *\n-     * @param fromIndex the index to start checking from (inclusive)\n-     * @return the index of the previous set bit, or {@code -1} if there is no such\n-     *         bit\n-     * @throws IndexOutOfBoundsException if the specified index is less than\n-     *                                   {@code -1}\n-     * @since 1.7\n+     * }}<\/pre>\n+     *\n+     * @param  fromIndex the index to start checking from (inclusive)\n+     * @return the index of the previous set bit, or {@code -1} if there\n+     *         is no such bit\n+     * @throws IndexOutOfBoundsException if the specified index is less\n+     *         than {@code -1}\n+     * @since  1.7\n@@ -867,1 +856,2 @@\n-            throw new IndexOutOfBoundsException(\"fromIndex < -1: \" + fromIndex);\n+            throw new IndexOutOfBoundsException(\n+                \"fromIndex < -1: \" + fromIndex);\n@@ -876,1 +866,1 @@\n-        long word = words[u] & (WORD_MASK >>> -(fromIndex + 1));\n+        long word = words[u] & (WORD_MASK >>> -(fromIndex+1));\n@@ -880,1 +870,1 @@\n-                return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n+                return (u+1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n@@ -888,10 +878,11 @@\n-     * Returns the index of the nearest bit that is set to {@code false} that occurs\n-     * on or before the specified starting index. If no such bit exists, or if\n-     * {@code -1} is given as the starting index, then {@code -1} is returned.\n-     *\n-     * @param fromIndex the index to start checking from (inclusive)\n-     * @return the index of the previous clear bit, or {@code -1} if there is no\n-     *         such bit\n-     * @throws IndexOutOfBoundsException if the specified index is less than\n-     *                                   {@code -1}\n-     * @since 1.7\n+     * Returns the index of the nearest bit that is set to {@code false}\n+     * that occurs on or before the specified starting index.\n+     * If no such bit exists, or if {@code -1} is given as the\n+     * starting index, then {@code -1} is returned.\n+     *\n+     * @param  fromIndex the index to start checking from (inclusive)\n+     * @return the index of the previous clear bit, or {@code -1} if there\n+     *         is no such bit\n+     * @throws IndexOutOfBoundsException if the specified index is less\n+     *         than {@code -1}\n+     * @since  1.7\n@@ -903,1 +894,2 @@\n-            throw new IndexOutOfBoundsException(\"fromIndex < -1: \" + fromIndex);\n+            throw new IndexOutOfBoundsException(\n+                \"fromIndex < -1: \" + fromIndex);\n@@ -912,1 +904,1 @@\n-        long word = ~words[u] & (WORD_MASK >>> -(fromIndex + 1));\n+        long word = ~words[u] & (WORD_MASK >>> -(fromIndex+1));\n@@ -916,1 +908,1 @@\n-                return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n+                return (u+1) * BITS_PER_WORD -1 - Long.numberOfLeadingZeros(word);\n@@ -924,3 +916,3 @@\n-     * Returns the \"logical size\" of this {@code BitSet}: the index of the highest\n-     * set bit in the {@code BitSet} plus one. Returns zero if the {@code BitSet}\n-     * contains no set bits.\n+     * Returns the \"logical size\" of this {@code BitSet}: the index of\n+     * the highest set bit in the {@code BitSet} plus one. Returns zero\n+     * if the {@code BitSet} contains no set bits.\n@@ -929,1 +921,1 @@\n-     * @since 1.2\n+     * @since  1.2\n@@ -939,2 +931,2 @@\n-     * Returns true if this {@code BitSet} contains no bits that are set to\n-     * {@code true}.\n+     * Returns true if this {@code BitSet} contains no bits that are set\n+     * to {@code true}.\n@@ -943,1 +935,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -950,2 +942,2 @@\n-     * Returns true if the specified {@code BitSet} has any bits set to {@code true}\n-     * that are also set to {@code true} in this {@code BitSet}.\n+     * Returns true if the specified {@code BitSet} has any bits set to\n+     * {@code true} that are also set to {@code true} in this {@code BitSet}.\n@@ -953,4 +945,4 @@\n-     * @param set {@code BitSet} to intersect with\n-     * @return boolean indicating whether this {@code BitSet} intersects the\n-     *         specified {@code BitSet}\n-     * @since 1.4\n+     * @param  set {@code BitSet} to intersect with\n+     * @return boolean indicating whether this {@code BitSet} intersects\n+     *         the specified {@code BitSet}\n+     * @since  1.4\n@@ -969,5 +961,4 @@\n-     * @param set {@code BitSet} to test\n-     * @return boolean indicating whether this {@code BitSet} includes the specified\n-     *         {@code BitSet}\n-     * @since 21\n-     * @author Fabio Romano\n+     * @param  set {@code BitSet} to test\n+     * @return boolean indicating whether this {@code BitSet} includes\n+     *         the specified {@code BitSet}\n+     * @since  21\n@@ -978,1 +969,1 @@\n-\n+        \n@@ -980,1 +971,1 @@\n-        for (int i = 0; i < set.wordsInUse; i++)\n+        for (int i = set.wordsInUse - 1; i >= 0; i--)\n@@ -990,1 +981,1 @@\n-     * @since 1.4\n+     * @since  1.4\n@@ -997,5 +988,5 @@\n-     * Performs a logical <b>AND<\/b> of this target bit set with the argument bit\n-     * set. This bit set is modified so that each bit in it has the value\n-     * {@code true} if and only if it both initially had the value {@code true} and\n-     * the corresponding bit in the bit set argument also had the value\n-     * {@code true}.\n+     * Performs a logical <b>AND<\/b> of this target bit set with the\n+     * argument bit set. This bit set is modified so that each bit in it\n+     * has the value {@code true} if and only if it both initially\n+     * had the value {@code true} and the corresponding bit in the\n+     * bit set argument also had the value {@code true}.\n@@ -1022,4 +1013,5 @@\n-     * Performs a logical <b>OR<\/b> of this bit set with the bit set argument. This\n-     * bit set is modified so that a bit in it has the value {@code true} if and\n-     * only if it either already had the value {@code true} or the corresponding bit\n-     * in the bit set argument has the value {@code true}.\n+     * Performs a logical <b>OR<\/b> of this bit set with the bit set\n+     * argument. This bit set is modified so that a bit in it has the\n+     * value {@code true} if and only if it either already had the\n+     * value {@code true} or the corresponding bit in the bit set\n+     * argument has the value {@code true}.\n@@ -1046,1 +1038,3 @@\n-            System.arraycopy(set.words, wordsInCommon, words, wordsInCommon, wordsInUse - wordsInCommon);\n+            System.arraycopy(set.words, wordsInCommon,\n+                             words, wordsInCommon,\n+                             wordsInUse - wordsInCommon);\n@@ -1054,3 +1048,4 @@\n-     * Performs a logical <b>XOR<\/b> of this bit set with the bit set argument. This\n-     * bit set is modified so that a bit in it has the value {@code true} if and\n-     * only if one of the following statements holds:\n+     * Performs a logical <b>XOR<\/b> of this bit set with the bit set\n+     * argument. This bit set is modified so that a bit in it has the\n+     * value {@code true} if and only if one of the following\n+     * statements holds:\n@@ -1058,4 +1053,4 @@\n-     * <li>The bit initially has the value {@code true}, and the corresponding bit\n-     * in the argument has the value {@code false}.\n-     * <li>The bit initially has the value {@code false}, and the corresponding bit\n-     * in the argument has the value {@code true}.\n+     * <li>The bit initially has the value {@code true}, and the\n+     *     corresponding bit in the argument has the value {@code false}.\n+     * <li>The bit initially has the value {@code false}, and the\n+     *     corresponding bit in the argument has the value {@code true}.\n@@ -1064,1 +1059,1 @@\n-     * @param set a bit set\n+     * @param  set a bit set\n@@ -1086,1 +1081,3 @@\n-            System.arraycopy(set.words, wordsInCommon, words, wordsInCommon, set.wordsInUse - wordsInCommon);\n+            System.arraycopy(set.words, wordsInCommon,\n+                             words, wordsInCommon,\n+                             set.wordsInUse - wordsInCommon);\n@@ -1094,2 +1091,2 @@\n-     * Clears all of the bits in this {@code BitSet} whose corresponding bit is set\n-     * in the specified {@code BitSet}.\n+     * Clears all of the bits in this {@code BitSet} whose corresponding\n+     * bit is set in the specified {@code BitSet}.\n@@ -1097,2 +1094,3 @@\n-     * @param set the {@code BitSet} with which to mask this {@code BitSet}\n-     * @since 1.2\n+     * @param  set the {@code BitSet} with which to mask this\n+     *         {@code BitSet}\n+     * @since  1.2\n@@ -1113,5 +1111,2 @@\n-     * Returns the hash code value for this bit set. The hash code depends only on\n-     * which bits are set within this {@code BitSet}.\n-     *\n-     * <p>\n-     * The hash code is defined to be the result of the following calculation:\n+     * Returns the hash code value for this bit set. The hash code depends\n+     * only on which bits are set within this {@code BitSet}.\n@@ -1119,1 +1114,3 @@\n-     * <pre> {@code\n+     * <p>The hash code is defined to be the result of the following\n+     * calculation:\n+     *  <pre> {@code\n@@ -1123,1 +1120,1 @@\n-     *     for (int i = words.length; --i >= 0;)\n+     *     for (int i = words.length; --i >= 0; )\n@@ -1125,4 +1122,2 @@\n-     *     return (int) ((h >> 32) ^ h);\n-     * }\n-     * }<\/pre>\n-     *\n+     *     return (int)((h >> 32) ^ h);\n+     * }}<\/pre>\n@@ -1135,1 +1130,1 @@\n-        for (int i = wordsInUse; --i >= 0;)\n+        for (int i = wordsInUse; --i >= 0; )\n@@ -1138,1 +1133,1 @@\n-        return (int) ((h >> 32) ^ h);\n+        return (int)((h >> 32) ^ h);\n@@ -1142,3 +1137,3 @@\n-     * Returns the number of bits of space actually in use by this {@code BitSet} to\n-     * represent bit values. The maximum element in the set is the size - 1st\n-     * element.\n+     * Returns the number of bits of space actually in use by this\n+     * {@code BitSet} to represent bit values.\n+     * The maximum element in the set is the size - 1st element.\n@@ -1153,3 +1148,4 @@\n-     * Compares this object against the specified object. The result is {@code true}\n-     * if and only if the argument is not {@code null} and is a {@code BitSet}\n-     * object that has exactly the same set of bits set to {@code true} as this bit\n+     * Compares this object against the specified object.\n+     * The result is {@code true} if and only if the argument is\n+     * not {@code null} and is a {@code BitSet} object that has\n+     * exactly the same set of bits set to {@code true} as this bit\n@@ -1157,5 +1153,1 @@\n-     *\n-     * <pre>\n-     * ((BitSet) obj).get(k) == this.get(k)\n-     * <\/pre>\n-     *\n+     * <pre>((BitSet)obj).get(k) == this.get(k)<\/pre>\n@@ -1164,3 +1156,4 @@\n-     * @param obj the object to compare with\n-     * @return {@code true} if the objects are the same; {@code false} otherwise\n-     * @see #size()\n+     * @param  obj the object to compare with\n+     * @return {@code true} if the objects are the same;\n+     *         {@code false} otherwise\n+     * @see    #size()\n@@ -1189,3 +1182,4 @@\n-     * Cloning this {@code BitSet} produces a new {@code BitSet} that is equal to\n-     * it. The clone of the bit set is another bit set that has exactly the same\n-     * bits set to {@code true} as this bit set.\n+     * Cloning this {@code BitSet} produces a new {@code BitSet}\n+     * that is equal to it.\n+     * The clone of the bit set is another bit set that has exactly the\n+     * same bits set to {@code true} as this bit set.\n@@ -1194,1 +1188,1 @@\n-     * @see #size()\n+     * @see    #size()\n@@ -1197,1 +1191,1 @@\n-        if (!sizeIsSticky)\n+        if (! sizeIsSticky)\n@@ -1212,2 +1206,2 @@\n-     * Calling this method may, but is not required to, affect the value returned by\n-     * a subsequent call to the {@link #size()} method.\n+     * Calling this method may, but is not required to, affect the value\n+     * returned by a subsequent call to the {@link #size()} method.\n@@ -1223,2 +1217,2 @@\n-     * Save the state of the {@code BitSet} instance to a stream (i.e., serialize\n-     * it).\n+     * Save the state of the {@code BitSet} instance to a stream (i.e.,\n+     * serialize it).\n@@ -1227,1 +1221,2 @@\n-    private void writeObject(ObjectOutputStream s) throws IOException {\n+    private void writeObject(ObjectOutputStream s)\n+        throws IOException {\n@@ -1231,1 +1226,1 @@\n-        if (!sizeIsSticky)\n+        if (! sizeIsSticky)\n@@ -1240,2 +1235,2 @@\n-     * Reconstitute the {@code BitSet} instance from a stream (i.e., deserialize\n-     * it).\n+     * Reconstitute the {@code BitSet} instance from a stream (i.e.,\n+     * deserialize it).\n@@ -1244,1 +1239,2 @@\n-    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n+    private void readObject(ObjectInputStream s)\n+        throws IOException, ClassNotFoundException {\n@@ -1255,1 +1251,1 @@\n-        sizeIsSticky = (words.length > 0 && words[words.length - 1] == 0L); \/\/ heuristic\n+        sizeIsSticky = (words.length > 0 && words[words.length-1] == 0L); \/\/ heuristic\n@@ -1260,10 +1256,9 @@\n-     * Returns a string representation of this bit set. For every index for which\n-     * this {@code BitSet} contains a bit in the set state, the decimal\n-     * representation of that index is included in the result. Such indices are\n-     * listed in order from lowest to highest, separated by \",&nbsp;\" (a comma and a\n-     * space) and surrounded by braces, resulting in the usual mathematical notation\n-     * for a set of integers.\n-     *\n-     * <p>\n-     * Example:\n-     *\n+     * Returns a string representation of this bit set. For every index\n+     * for which this {@code BitSet} contains a bit in the set\n+     * state, the decimal representation of that index is included in\n+     * the result. Such indices are listed in order from lowest to\n+     * highest, separated by \",&nbsp;\" (a comma and a space) and\n+     * surrounded by braces, resulting in the usual mathematical\n+     * notation for a set of integers.\n+     *\n+     * <p>Example:\n@@ -1271,3 +1266,1 @@\n-     * BitSet drPepper = new BitSet();\n-     * <\/pre>\n-     *\n+     * BitSet drPepper = new BitSet();<\/pre>\n@@ -1275,1 +1268,0 @@\n-     *\n@@ -1277,3 +1269,1 @@\n-     * drPepper.set(2);\n-     * <\/pre>\n-     *\n+     * drPepper.set(2);<\/pre>\n@@ -1281,1 +1271,0 @@\n-     *\n@@ -1284,3 +1273,1 @@\n-     * drPepper.set(10);\n-     * <\/pre>\n-     *\n+     * drPepper.set(10);<\/pre>\n@@ -1296,2 +1283,2 @@\n-        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ? 6 * cardinality + 2\n-                : MAX_INITIAL_CAPACITY;\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n+            6 * cardinality + 2 : MAX_INITIAL_CAPACITY;\n@@ -1305,4 +1292,2 @@\n-                if (++i < 0)\n-                    break;\n-                if ((i = nextSetBit(i)) < 0)\n-                    break;\n+                if (++i < 0) break;\n+                if ((i = nextSetBit(i)) < 0) break;\n@@ -1310,3 +1295,2 @@\n-                do {\n-                    b.append(\", \").append(i);\n-                } while (++i != endOfRun);\n+                do { b.append(\", \").append(i); }\n+                while (++i != endOfRun);\n@@ -1321,3 +1305,4 @@\n-     * Returns a stream of indices for which this {@code BitSet} contains a bit in\n-     * the set state. The indices are returned in order, from lowest to highest. The\n-     * size of the stream is the number of bits in the set state, equal to the value\n+     * Returns a stream of indices for which this {@code BitSet}\n+     * contains a bit in the set state. The indices are returned\n+     * in order, from lowest to highest. The size of the stream\n+     * is the number of bits in the set state, equal to the value\n@@ -1326,5 +1311,4 @@\n-     * <p>\n-     * The stream binds to this bit set when the terminal stream operation commences\n-     * (specifically, the spliterator for the stream is\n-     * <a href=\"Spliterator.html#binding\"><em>late-binding<\/em><\/a>). If the bit set\n-     * is modified during that operation then the result is undefined.\n+     * <p>The stream binds to this bit set when the terminal stream operation\n+     * commences (specifically, the spliterator for the stream is\n+     * <a href=\"Spliterator.html#binding\"><em>late-binding<\/em><\/a>).  If the\n+     * bit set is modified during that operation then the result is undefined.\n@@ -1339,1 +1323,1 @@\n-            private int est; \/\/ size estimate\n+            private int est;   \/\/ size estimate\n@@ -1358,2 +1342,3 @@\n-                    hi = fence = (wordsInUse >= wordIndex(Integer.MAX_VALUE)) ? Integer.MAX_VALUE\n-                            : wordsInUse << ADDRESS_BITS_PER_WORD;\n+                    hi = fence = (wordsInUse >= wordIndex(Integer.MAX_VALUE))\n+                                 ? Integer.MAX_VALUE\n+                                 : wordsInUse << ADDRESS_BITS_PER_WORD;\n@@ -1398,1 +1383,1 @@\n-                    int u = wordIndex(i); \/\/ next lower word bound\n+                    int u = wordIndex(i);      \/\/ next lower word bound\n@@ -1401,1 +1386,2 @@\n-                    words_loop: for (; u <= v && i <= hi; u++, i = u << ADDRESS_BITS_PER_WORD) {\n+                    words_loop:\n+                    for (; u <= v && i <= hi; u++, i = u << ADDRESS_BITS_PER_WORD) {\n@@ -1437,1 +1423,2 @@\n-                hi = fence = (hi < Integer.MAX_VALUE || !get(Integer.MAX_VALUE)) ? previousSetBit(hi - 1) + 1\n+                hi = fence = (hi < Integer.MAX_VALUE || !get(Integer.MAX_VALUE))\n+                        ? previousSetBit(hi - 1) + 1\n@@ -1465,1 +1452,2 @@\n-                return (root ? Spliterator.SIZED : 0) | Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED;\n+                return (root ? Spliterator.SIZED : 0) |\n+                    Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED;\n@@ -1477,7 +1465,9 @@\n-     * Returns the index of the first bit that is set to {@code true} that occurs on\n-     * or after the specified starting index and up to and including the specified\n-     * word index If no such bit exists then {@code -1} is returned.\n-     *\n-     * @param fromIndex   the index to start checking from (inclusive)\n-     * @param toWordIndex the last word index to check (inclusive)\n-     * @return the index of the next set bit, or {@code -1} if there is no such bit\n+     * Returns the index of the first bit that is set to {@code true}\n+     * that occurs on or after the specified starting index and up to and\n+     * including the specified word index\n+     * If no such bit exists then {@code -1} is returned.\n+     *\n+     * @param  fromIndex the index to start checking from (inclusive)\n+     * @param  toWordIndex the last word index to check (inclusive)\n+     * @return the index of the next set bit, or {@code -1} if there\n+     *         is no such bit\n@@ -1502,0 +1492,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":377,"deletions":386,"binary":false,"changes":763,"status":"modified"}]}