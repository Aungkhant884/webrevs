{"files":[{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230119_192355.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230120_161035.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n+    static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n@@ -94,1 +94,1 @@\n-    private long[] words;\n+    long[] words;\n@@ -99,1 +99,1 @@\n-    private transient int wordsInUse = 0;\n+    transient int wordsInUse = 0;\n@@ -105,1 +105,1 @@\n-    private transient boolean sizeIsSticky = false;\n+    transient boolean sizeIsSticky = false;\n@@ -114,1 +114,1 @@\n-    private static int wordIndex(int bitIndex) {\n+    static int wordIndex(int bitIndex) {\n@@ -121,1 +121,1 @@\n-    private void checkInvariants() {\n+    void checkInvariants() {\n@@ -132,1 +132,1 @@\n-    private void recalculateWordsInUse() {\n+    void recalculateWordsInUse() {\n@@ -135,5 +135,2 @@\n-        for (i = wordsInUse-1; i >= 0; i--)\n-            if (words[i] != 0)\n-                break;\n-\n-        wordsInUse = i+1; \/\/ The new logical size\n+        for (i = wordsInUse - 1; i >= 0 && words[i] == 0; i--);\n+        wordsInUse = i + 1; \/\/ The new logical size\n@@ -174,1 +171,0 @@\n-     * The last word (if there is one) must be non-zero.\n@@ -176,1 +172,1 @@\n-    private BitSet(long[] words) {\n+    BitSet(long[] words) {\n@@ -179,0 +175,2 @@\n+        \/\/ Set wordsInUse correctly\n+        recalculateWordsInUse();\n@@ -199,0 +197,4 @@\n+        return new BitSet(getWords(longs));\n+    }\n+    \n+    static long[] getWords(long[] longs) {\n@@ -200,3 +202,2 @@\n-        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--)\n-            ;\n-        return new BitSet(Arrays.copyOf(longs, n));\n+        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--);\n+        return Arrays.copyOf(longs, n);\n@@ -224,0 +225,4 @@\n+        return new BitSet(getWords(lb));\n+    }\n+    \n+    static long[] getWords(LongBuffer lb) {\n@@ -228,0 +233,1 @@\n+        \n@@ -230,1 +236,1 @@\n-        return new BitSet(words);\n+        return words;\n@@ -250,1 +256,5 @@\n-        return BitSet.valueOf(ByteBuffer.wrap(bytes));\n+        return BitSet.valueOf(getWords(bytes));\n+    }\n+    \n+    static long[] getWords(byte[] bytes) {\n+        return getWords(ByteBuffer.wrap(bytes));\n@@ -272,0 +282,4 @@\n+        return new BitSet(getWords(bb));\n+    }\n+    \n+    static long[] getWords(ByteBuffer bb) {\n@@ -283,1 +297,2 @@\n-        return new BitSet(words);\n+        \n+        return words;\n@@ -648,0 +663,4 @@\n+        return new BitSet(getWords(fromIndex, toIndex));\n+    }\n+    \n+    long[] getWords(int fromIndex, int toIndex) {\n@@ -652,1 +671,1 @@\n-        int len = length();\n+        final int len = length();\n@@ -654,1 +673,1 @@\n-        \/\/ If no set bits in range return empty bitset\n+        \/\/ If no set bits in range return empty array\n@@ -656,1 +675,1 @@\n-            return new BitSet(0);\n+            return new long[0];\n@@ -662,2 +681,1 @@\n-        BitSet result = new BitSet(toIndex - fromIndex);\n-        int targetWords = wordIndex(toIndex - fromIndex - 1) + 1;\n+        final long[] result = new long[wordIndex(toIndex - fromIndex - 1) + 1];\n@@ -665,1 +683,1 @@\n-        boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n+        final boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n@@ -668,2 +686,2 @@\n-        for (int i = 0; i < targetWords - 1; i++, sourceIndex++)\n-            result.words[i] = wordAligned ? words[sourceIndex] :\n+        for (int i = 0; i < result.length - 1; i++, sourceIndex++)\n+            result[i] = wordAligned ? words[sourceIndex] :\n@@ -674,2 +692,2 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n-        result.words[targetWords - 1] =\n+        final long lastWordMask = WORD_MASK >>> -toIndex;\n+        result[result.length - 1] =\n@@ -682,6 +700,1 @@\n-\n-        \/\/ Set wordsInUse correctly\n-        result.wordsInUse = targetWords;\n-        result.recalculateWordsInUse();\n-        result.checkInvariants();\n-\n+        \n@@ -862,2 +875,1 @@\n-        return BITS_PER_WORD * (wordsInUse - 1) +\n-            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - 1]));\n+        return BITS_PER_WORD * wordsInUse - Long.numberOfLeadingZeros(words[wordsInUse - 1]);\n@@ -979,0 +991,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+        \n@@ -1077,1 +1095,1 @@\n-        if (wordsInUse != set.wordsInUse)\n+        if (length() != set.length()) \/\/ more accurate than (wordsInUse != set.wordsInUse)\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":57,"deletions":39,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,526 @@\n+package java.util;\n+\n+import java.io.*;\n+import java.nio.*;\n+\n+\/**\n+ * This class implements a set of non-negative integers that grows as needed.\n+ * Individual integers can be checked if they are contained, added, or removed.\n+ * One {@code NaturalsBitSet} may be used to modify the contents of another\n+ * {@code NaturalsBitSet} through logical AND, logical inclusive OR, and logical\n+ * exclusive OR operations.\n+ *\n+ * <p>\n+ * Every {@code NaturalsBitSet} has a current size, which is the number of bits\n+ * of space currently in use by the bit set. Note that the size is related to\n+ * the implementation of a bit set, so it may change with implementation. The\n+ * length of a bit set relates to logical length of a bit set and is defined\n+ * independently of implementation.\n+ *\n+ * <p>\n+ * Unless otherwise noted, passing a null parameter to any of the methods in a\n+ * {@code NaturalsBitSet} will result in a {@code NullPointerException}.\n+ *\n+ * <p>\n+ * A {@code NaturalsBitSet} is not safe for multithreaded use without external\n+ * synchronization.\n+ *\n+ * @author Fabio Romano\n+ * @since 21\n+ *\/\n+public class NaturalsBitSet extends BitSet {\n+\n+    \/**\n+     * The number of bits set to {@code true} in this {@code BitSet}.\n+     *\/\n+    private transient int cardinality = 0;\n+    \n+    \/* use serialVersionUID from JDK 21 for interoperability *\/\n+    @java.io.Serial\n+    private static final long serialVersionUID = -212903409561554139L;\n+\n+    \/**\n+     * Every public method must preserve these invariants.\n+     *\/\n+    private void checkCardinality() {\n+        \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n+        assert (cardinality >= 0 && cardinality - 1 <= length() - 1);\n+    }\n+\n+    \/**\n+     * Creates a new empty {@code NaturalsBitSet}.\n+     *\/\n+    public NaturalsBitSet() {\n+        super();\n+    }\n+\n+    \/**\n+     * Creates an empty {@code NaturalsBitSet} whose initial size is large enough to\n+     * explicitly represent naturals in the range {@code 0} through {@code nbits-1}.\n+     *\n+     * @param nbits the initial size of the bit set\n+     * @throws NegativeArraySizeException if the specified initial size is negative\n+     *\/\n+    public NaturalsBitSet(int nbits) {\n+        super(nbits);\n+    }\n+\n+    \/**\n+     * Constructs a new {@code NaturalsBitSet} containing the integers in the\n+     * specified collection. It is created with an initial capacity sufficient to\n+     * contain the integers in the specified collection.\n+     *\n+     * @param c the collection whose integers are to be placed into this set\n+     * @throws NullPointerException      if the specified collection is null, or if\n+     *                                   some integer in the collection is null\n+     * @throws IndexOutOfBoundsException if some integer in the specified collection\n+     *                                   is negative\n+     *\/\n+    public NaturalsBitSet(Collection<Integer> c) {\n+        this(Collections.max(c) + 1);\n+\n+        for (int i : c)\n+            set(i);\n+    }\n+\n+    private NaturalsBitSet(long[] words) {\n+        super(words);\n+        computeCardinality();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long array.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * longs.length}.\n+     *\n+     * <p>\n+     * This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(LongBuffer.wrap(longs))}.\n+     *\n+     * @param longs a long array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the long array\n+     *\/\n+    public static NaturalsBitSet valueOf(long[] longs) {\n+        return new NaturalsBitSet(getWords(longs));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long buffer between its position and limit.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * lb.remaining()}.\n+     *\n+     * <p>\n+     * The long buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n+     *\n+     * @param lb a long buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(LongBuffer lb) {\n+        return new NaturalsBitSet(getWords(lb));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte array.\n+     *\n+     * <p>More precisely,\n+     * <br>{@code NaturalsBitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n <  8 * bytes.length}.\n+     *\n+     * <p>This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(ByteBuffer.wrap(bytes))}.\n+     *\n+     * @param bytes a byte array containing a little-endian\n+     *        representation of a sequence of bits to be used as the\n+     *        initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the byte array\n+     *\/\n+    public static NaturalsBitSet valueOf(byte[] bytes) {\n+        return new NaturalsBitSet(getWords(bytes));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte\n+     * buffer between its position and limit.\n+     *\n+     * <p>More precisely,\n+     * <br>{@code NaturalsBitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n < 8 * bb.remaining()}.\n+     *\n+     * <p>The byte buffer is not modified by this method, and no\n+     * reference to the buffer is retained by the bit set.\n+     *\n+     * @param bb a byte buffer containing a little-endian representation\n+     *        of a sequence of bits between its position and limit, to be\n+     *        used as the initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(ByteBuffer bb) {\n+        return new NaturalsBitSet(getWords(bb));\n+    }\n+\n+    private void computeCardinality() {\n+        cardinality = bitCount(0, wordsInUse);\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true, starting from startWord (inclusive)\n+     * to endWord (exclusive)\n+     *\/\n+    private int bitCount(int startWord, int endWord) {\n+        int sum = 0;\n+        for (int i = startWord; i < endWord; i++)\n+            sum += bitCount(i);\n+\n+        return sum;\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true at the specified word\n+     *\/\n+    private int bitCount(int wordIndex) {\n+        return Long.bitCount(words[wordIndex]);\n+    }\n+\n+    \/**\n+     * If the specified value is contained in this set, removes it; otherwise adds\n+     * it to this set.\n+     *\n+     * @param n the integer to flip\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void flip(int n) {\n+        super.flip(n);\n+        cardinality += (words[wordIndex(n)] & (1L << n)) != 0 ? 1 : -1;\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Flip each integer (as pecified in {@link #flip(int)} from the specified\n+     * {@code start} (inclusive) to the specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to flip\n+     * @param end   value after the last integer to flip\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void flip(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        super.flip(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality += (bitCount(i) << 1) - BITS_PER_WORD;\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Adds the specified integer to this set.\n+     *\n+     * @param n a non-negative integer\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void set(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex >= wordsInUse || (words[wordIndex] & (1L << n)) == 0) {\n+            super.set(n);\n+            cardinality++;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Adds the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be added\n+     * @param end   the value after the last integer to be added\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void set(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality += BITS_PER_WORD - bitCount(i);\n+\n+        super.set(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes the specified integer.\n+     *\n+     * @param n the integer to be removed\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void clear(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex < wordsInUse && (words[wordIndex] & (1L << n)) != 0) {\n+            super.clear(n);\n+            cardinality--;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Removes the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be removed\n+     * @param end   value after the last integer to be removed\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void clear(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality -= bitCount(i);\n+\n+        super.clear(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes all of the integers in this set.\n+     *\/\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        cardinality = 0;\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} composed of bits from this\n+     * {@code BitSet} from {@code fromIndex} (inclusive) to {@code toIndex}\n+     * (exclusive).\n+     *\n+     * @param fromIndex index of the first bit to include\n+     * @param toIndex   index after the last bit to include\n+     * @return a new {@code NaturalsBitSet} from a range of this\n+     *         {@code NaturalsBitSet}\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     *\/\n+    @Override\n+    public NaturalsBitSet get(int fromIndex, int toIndex) {\n+        return new NaturalsBitSet(getWords(fromIndex, toIndex));\n+    }\n+\n+    \/**\n+     * Returns true if this {@code NaturalsBitSet} contains no integers.\n+     *\n+     * @return boolean indicating whether this {@code NaturalsBitSet} is empty\n+     *\/\n+    @Override\n+    public boolean isEmpty() {\n+        return cardinality == 0;\n+    }\n+\n+    \/**\n+     * Returns the number of integers in this {@code NaturalsBitSet}.\n+     *\n+     * @return the number of integers in this {@code NaturalsBitSet}\n+     *\/\n+    @Override\n+    public int cardinality() {\n+        return cardinality;\n+    }\n+\n+    @Override\n+    public void and(BitSet set) {\n+        if (this != set) {\n+            super.and(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void or(BitSet set) {\n+        if (this != set) {\n+            super.or(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void xor(BitSet set) {\n+        if (this == set) { \/\/ An optimization\n+            clear();\n+        } else {\n+            super.xor(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void andNot(BitSet set) {\n+        int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);\n+\n+        if (wordsInCommon > wordsInUse \/ 2) { \/\/ An optimization\n+            super.andNot(set);\n+            computeCardinality();\n+            checkCardinality();\n+        } else {\n+            cardinality -= bitCount(0, wordsInCommon);\n+            super.andNot(set);\n+            cardinality += bitCount(0, wordsInCommon);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ compare the cardinalities if obj is a NaturalsBitSet\n+        return !((obj instanceof NaturalsBitSet set) && cardinality != set.cardinality) && super.equals(obj);\n+    }\n+\n+    \/**\n+     * Cloning this {@code NaturalsBitSet} produces a new {@code NaturalsBitSet}\n+     * that is equal to it. The clone of the bit set is another bit set that has\n+     * exactly the same integers as this bit set.\n+     *\n+     * @return a clone of this bit set\n+     * @see #size()\n+     *\/\n+    @Override\n+    public NaturalsBitSet clone() {\n+        return (NaturalsBitSet) super.clone();\n+    }\n+\n+    \/**\n+     * Reconstitute the {@code NaturalsBitSet} instance from a stream (i.e.,\n+     * deserialize it).\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n+        ObjectInputStream.GetField fields = s.readFields();\n+        words = (long[]) fields.get(\"bits\", null);\n+\n+        \/\/ Assume maximum length then find real length\n+        \/\/ because recalculateWordsInUse assumes maintenance\n+        \/\/ or reduction in logical size\n+        wordsInUse = words.length;\n+        recalculateWordsInUse();\n+        computeCardinality();\n+        sizeIsSticky = (words.length > 0 && words[words.length - 1] == 0L); \/\/ heuristic\n+        checkInvariants();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code NaturalsBitSet}. For every\n+     * integer for which this {@code NaturalsBitSet} contains it, the decimal\n+     * representation of that integer is included in the result. Such integers are\n+     * listed in order from lowest to highest, separated by \",&nbsp;\" (a comma and a\n+     * space) and surrounded by braces, resulting in the usual mathematical notation\n+     * for a set of integers.\n+     *\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     * BitSet drPepper = new BitSet();\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(2);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(4);\n+     * drPepper.set(10);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2, 4, 10}}\".\n+     *\n+     * @return a string representation of this bit set\n+     *\/\n+    public String toString() {\n+        checkInvariants();\n+\n+        final int MAX_INITIAL_CAPACITY = Integer.MAX_VALUE - 8;\n+        \/\/ Avoid overflow in the case of a humongous cardinality\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ? 6 * cardinality + 2\n+                : MAX_INITIAL_CAPACITY;\n+        StringBuilder b = new StringBuilder(initialCapacity);\n+        b.append('{');\n+\n+        int i = nextSetBit(0);\n+        if (i != -1) {\n+            b.append(i);\n+            while (true) {\n+                if (++i < 0)\n+                    break;\n+                if ((i = nextSetBit(i)) < 0)\n+                    break;\n+                int endOfRun = nextClearBit(i);\n+                do {\n+                    b.append(\", \").append(i);\n+                } while (++i != endOfRun);\n+            }\n+        }\n+\n+        b.append('}');\n+        return b.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/NaturalsBitSet.java","additions":526,"deletions":0,"binary":false,"changes":526,"status":"added"},{"patch":"@@ -821,0 +821,40 @@\n+    }\n+\n+    private static void testIncludes() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            BitSet b1 = new BitSet(256);\n+            BitSet b2 = new BitSet(256);\n+\n+            \/\/ Set some random bits in first set\n+            int nextBitToSet = 0;\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure b1 includes b2\n+            b1.or(b2);\n+\n+            if (!b1.includes(b2))\n+                failCount++;\n+\n+            \/\/ Remove a common set bit\n+            nextBitToSet = b2.nextSetBit(generator.nextInt(b2.length()));\n+            b1.clear(nextBitToSet);\n+\n+            \/\/ Make sure b1 doesn't include b2\n+            if (b1.includes(b2))\n+                failCount++;\n+\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Includes                  \", failCount);\n","filename":"test\/jdk\/java\/util\/BitSet\/BSMethods.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}