{"files":[{"patch":"@@ -37,7 +37,6 @@\n- * This class implements a vector of bits that grows as needed. Each\n- * component of the bit set has a {@code boolean} value. The\n- * bits of a {@code BitSet} are indexed by nonnegative integers.\n- * Individual indexed bits can be examined, set, or cleared. One\n- * {@code BitSet} may be used to modify the contents of another\n- * {@code BitSet} through logical AND, logical inclusive OR, and\n- * logical exclusive OR operations.\n+ * This class implements a vector of bits that grows as needed. Each component\n+ * of the bit set has a {@code boolean} value. The bits of a {@code BitSet} are\n+ * indexed by nonnegative integers. Individual indexed bits can be examined,\n+ * set, or cleared. One {@code BitSet} may be used to modify the contents of\n+ * another {@code BitSet} through logical AND, logical inclusive OR, and logical\n+ * exclusive OR operations.\n@@ -45,2 +44,2 @@\n- * <p>By default, all bits in the set initially have the value\n- * {@code false}.\n+ * <p>\n+ * By default, all bits in the set initially have the value {@code false}.\n@@ -48,5 +47,6 @@\n- * <p>Every bit set has a current size, which is the number of bits\n- * of space currently in use by the bit set. Note that the size is\n- * related to the implementation of a bit set, so it may change with\n- * implementation. The length of a bit set relates to logical length\n- * of a bit set and is defined independently of implementation.\n+ * <p>\n+ * Every bit set has a current size, which is the number of bits of space\n+ * currently in use by the bit set. Note that the size is related to the\n+ * implementation of a bit set, so it may change with implementation. The length\n+ * of a bit set relates to logical length of a bit set and is defined\n+ * independently of implementation.\n@@ -54,3 +54,3 @@\n- * <p>Unless otherwise noted, passing a null parameter to any of the\n- * methods in a {@code BitSet} will result in a\n- * {@code NullPointerException}.\n+ * <p>\n+ * Unless otherwise noted, passing a null parameter to any of the methods in a\n+ * {@code BitSet} will result in a {@code NullPointerException}.\n@@ -58,2 +58,3 @@\n- * <p>A {@code BitSet} is not safe for multithreaded use without\n- * external synchronization.\n+ * <p>\n+ * A {@code BitSet} is not safe for multithreaded use without external\n+ * synchronization.\n@@ -61,4 +62,4 @@\n- * @author  Arthur van Hoff\n- * @author  Michael McCloskey\n- * @author  Martin Buchholz\n- * @since   1.0\n+ * @author Arthur van Hoff\n+ * @author Michael McCloskey\n+ * @author Martin Buchholz\n+ * @since 1.0\n@@ -68,3 +69,3 @@\n-     * BitSets are packed into arrays of \"words.\"  Currently a word is\n-     * a long, which consists of 64 bits, requiring 6 address bits.\n-     * The choice of word size is determined purely by performance concerns.\n+     * BitSets are packed into arrays of \"words.\" Currently a word is a long, which\n+     * consists of 64 bits, requiring 6 address bits. The choice of word size is\n+     * determined purely by performance concerns.\n@@ -82,3 +83,4 @@\n-     * The bits in this BitSet.  The ith bit is stored in bits[i\/64] at\n-     * bit position i % 64 (where bit position 0 refers to the least\n-     * significant bit and 63 refers to the most significant bit).\n+     *                   The bits in this BitSet. The ith bit is stored in\n+     *                   bits[i\/64] at bit position i % 64 (where bit position 0\n+     *                   refers to the least significant bit and 63 refers to the\n+     *                   most significant bit).\n@@ -87,3 +89,1 @@\n-    private static final ObjectStreamField[] serialPersistentFields = {\n-        new ObjectStreamField(\"bits\", long[].class),\n-    };\n+    private static final ObjectStreamField[] serialPersistentFields = { new ObjectStreamField(\"bits\", long[].class), };\n@@ -102,2 +102,9 @@\n-     * Whether the size of \"words\" is user-specified.  If so, we assume\n-     * the user knows what he's doing and try harder to preserve it.\n+     * The number of bits set to {@code true} in this {@code BitSet}.\n+     *\n+     * @since 21\n+     *\/\n+    private transient int cardinality = 0;\n+\n+    \/**\n+     * Whether the size of \"words\" is user-specified. If so, we assume the user\n+     * knows what he's doing and try harder to preserve it.\n@@ -122,3 +129,5 @@\n-        assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);\n-        assert(wordsInUse >= 0 && wordsInUse <= words.length);\n-        assert(wordsInUse == words.length || words[wordsInUse] == 0);\n+        assert (wordsInUse == 0 || words[wordsInUse - 1] != 0);\n+        assert (wordsInUse >= 0 && wordsInUse <= words.length);\n+        assert (wordsInUse == words.length || words[wordsInUse] == 0);\n+        assert (cardinality >= 0 && cardinality - 1 <= length() - 1); \/\/ avoid overflow if get(Integer.MAX_VALUE) ==\n+                                                                      \/\/ true\n@@ -129,2 +138,2 @@\n-     * WARNING:This method assumes that the number of words actually in use is\n-     * less than or equal to the current value of wordsInUse!\n+     * WARNING:This method assumes that the number of words actually in use is less\n+     * than or equal to the current value of wordsInUse!\n@@ -135,1 +144,1 @@\n-        for (i = wordsInUse-1; i >= 0; i--)\n+        for (i = wordsInUse - 1; i >= 0; i--)\n@@ -139,1 +148,1 @@\n-        wordsInUse = i+1; \/\/ The new logical size\n+        wordsInUse = i + 1; \/\/ The new logical size\n@@ -151,3 +160,3 @@\n-     * Creates a bit set whose initial size is large enough to explicitly\n-     * represent bits with indices in the range {@code 0} through\n-     * {@code nbits-1}. All bits are initially {@code false}.\n+     * Creates a bit set whose initial size is large enough to explicitly represent\n+     * bits with indices in the range {@code 0} through {@code nbits-1}. All bits\n+     * are initially {@code false}.\n@@ -155,3 +164,2 @@\n-     * @param  nbits the initial size of the bit set\n-     * @throws NegativeArraySizeException if the specified initial size\n-     *         is negative\n+     * @param nbits the initial size of the bit set\n+     * @throws NegativeArraySizeException if the specified initial size is negative\n@@ -169,1 +177,1 @@\n-        words = new long[wordIndex(nbits-1) + 1];\n+        words = new long[wordIndex(nbits - 1) + 1];\n@@ -173,2 +181,2 @@\n-     * Creates a bit set using words as the internal representation.\n-     * The last word (if there is one) must be non-zero.\n+     * Creates a bit set using words as the internal representation. The last word\n+     * (if there is one) must be non-zero.\n@@ -179,0 +187,1 @@\n+        computeCardinality();\n@@ -182,0 +191,23 @@\n+    private void computeCardinality() {\n+        cardinality = bitCount(0, wordsInUse);\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true, starting from startWord (inclusive)\n+     * to endWord (exclusive)\n+     *\/\n+    private int bitCount(int startWord, int endWord) {\n+        int sum = 0;\n+        for (int i = startWord; i < endWord; i++)\n+            sum += bitCount(i);\n+\n+        return sum;\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true at the specified word\n+     *\/\n+    private int bitCount(int wordIndex) {\n+        return Long.bitCount(words[wordIndex]);\n+    }\n+\n@@ -185,3 +217,5 @@\n-     * <p>More precisely,\n-     * <br>{@code BitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n-     * <br>for all {@code n < 64 * longs.length}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code BitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * longs.length}.\n@@ -189,2 +223,2 @@\n-     * <p>This method is equivalent to\n-     * {@code BitSet.valueOf(LongBuffer.wrap(longs))}.\n+     * <p>\n+     * This method is equivalent to {@code BitSet.valueOf(LongBuffer.wrap(longs))}.\n@@ -192,3 +226,3 @@\n-     * @param longs a long array containing a little-endian representation\n-     *        of a sequence of bits to be used as the initial bits of the\n-     *        new bit set\n+     * @param longs a long array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n@@ -206,2 +240,2 @@\n-     * Returns a new bit set containing all the bits in the given long\n-     * buffer between its position and limit.\n+     * Returns a new bit set containing all the bits in the given long buffer\n+     * between its position and limit.\n@@ -209,3 +243,5 @@\n-     * <p>More precisely,\n-     * <br>{@code BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n-     * <br>for all {@code n < 64 * lb.remaining()}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * lb.remaining()}.\n@@ -213,2 +249,3 @@\n-     * <p>The long buffer is not modified by this method, and no\n-     * reference to the buffer is retained by the bit set.\n+     * <p>\n+     * The long buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n@@ -216,3 +253,3 @@\n-     * @param lb a long buffer containing a little-endian representation\n-     *        of a sequence of bits between its position and limit, to be\n-     *        used as the initial bits of the new bit set\n+     * @param lb a long buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n@@ -236,3 +273,4 @@\n-     * <p>More precisely,\n-     * <br>{@code BitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n-     * <br>for all {@code n <  8 * bytes.length}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code BitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)} <br>\n+     * for all {@code n <  8 * bytes.length}.\n@@ -240,2 +278,2 @@\n-     * <p>This method is equivalent to\n-     * {@code BitSet.valueOf(ByteBuffer.wrap(bytes))}.\n+     * <p>\n+     * This method is equivalent to {@code BitSet.valueOf(ByteBuffer.wrap(bytes))}.\n@@ -243,3 +281,3 @@\n-     * @param bytes a byte array containing a little-endian\n-     *        representation of a sequence of bits to be used as the\n-     *        initial bits of the new bit set\n+     * @param bytes a byte array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n@@ -254,2 +292,2 @@\n-     * Returns a new bit set containing all the bits in the given byte\n-     * buffer between its position and limit.\n+     * Returns a new bit set containing all the bits in the given byte buffer\n+     * between its position and limit.\n@@ -257,3 +295,5 @@\n-     * <p>More precisely,\n-     * <br>{@code BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n-     * <br>for all {@code n < 8 * bb.remaining()}.\n+     * <p>\n+     * More precisely, <br>\n+     * {@code BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>\n+     * for all {@code n < 8 * bb.remaining()}.\n@@ -261,2 +301,3 @@\n-     * <p>The byte buffer is not modified by this method, and no\n-     * reference to the buffer is retained by the bit set.\n+     * <p>\n+     * The byte buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n@@ -264,3 +305,3 @@\n-     * @param bb a byte buffer containing a little-endian representation\n-     *        of a sequence of bits between its position and limit, to be\n-     *        used as the initial bits of the new bit set\n+     * @param bb a byte buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n@@ -289,5 +330,6 @@\n-     * <p>More precisely, if\n-     * <br>{@code byte[] bytes = s.toByteArray();}\n-     * <br>then {@code bytes.length == (s.length()+7)\/8} and\n-     * <br>{@code s.get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n-     * <br>for all {@code n < 8 * bytes.length}.\n+     * <p>\n+     * More precisely, if <br>\n+     * {@code byte[] bytes = s.toByteArray();} <br>\n+     * then {@code bytes.length == (s.length()+7)\/8} and <br>\n+     * {@code s.get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)} <br>\n+     * for all {@code n < 8 * bytes.length}.\n@@ -295,2 +337,2 @@\n-     * @return a byte array containing a little-endian representation\n-     *         of all the bits in this bit set\n+     * @return a byte array containing a little-endian representation of all the\n+     *         bits in this bit set\n@@ -303,1 +345,1 @@\n-        int len = 8 * (n-1);\n+        int len = 8 * (n - 1);\n@@ -318,5 +360,6 @@\n-     * <p>More precisely, if\n-     * <br>{@code long[] longs = s.toLongArray();}\n-     * <br>then {@code longs.length == (s.length()+63)\/64} and\n-     * <br>{@code s.get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n-     * <br>for all {@code n < 64 * longs.length}.\n+     * <p>\n+     * More precisely, if <br>\n+     * {@code long[] longs = s.toLongArray();} <br>\n+     * then {@code longs.length == (s.length()+63)\/64} and <br>\n+     * {@code s.get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)} <br>\n+     * for all {@code n < 64 * longs.length}.\n@@ -324,2 +367,2 @@\n-     * @return a long array containing a little-endian representation\n-     *         of all the bits in this bit set\n+     * @return a long array containing a little-endian representation of all the\n+     *         bits in this bit set\n@@ -334,0 +377,1 @@\n+     *\n@@ -346,4 +390,4 @@\n-     * Ensures that the BitSet can accommodate a given wordIndex,\n-     * temporarily violating the invariants.  The caller must\n-     * restore the invariants before returning to the user,\n-     * possibly using recalculateWordsInUse().\n+     * Ensures that the BitSet can accommodate a given wordIndex, temporarily\n+     * violating the invariants. The caller must restore the invariants before\n+     * returning to the user, possibly using recalculateWordsInUse().\n+     *\n@@ -353,1 +397,1 @@\n-        int wordsRequired = wordIndex+1;\n+        int wordsRequired = wordIndex + 1;\n@@ -369,2 +413,1 @@\n-            throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex +\n-                                                \" > toIndex: \" + toIndex);\n+            throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex + \" > toIndex: \" + toIndex);\n@@ -374,2 +417,1 @@\n-     * Sets the bit at the specified index to the complement of its\n-     * current value.\n+     * Sets the bit at the specified index to the complement of its current value.\n@@ -377,1 +419,1 @@\n-     * @param  bitIndex the index of the bit to flip\n+     * @param bitIndex the index of the bit to flip\n@@ -379,1 +421,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -388,1 +430,3 @@\n-        words[wordIndex] ^= (1L << bitIndex);\n+        final long bitMask = 1L << bitIndex;\n+        words[wordIndex] ^= bitMask;\n+        cardinality += (words[wordIndex] & bitMask) != 0 ? 1 : -1;\n@@ -396,9 +440,9 @@\n-     * specified {@code toIndex} (exclusive) to the complement of its current\n-     * value.\n-     *\n-     * @param  fromIndex index of the first bit to flip\n-     * @param  toIndex index after the last bit to flip\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n-     *         or {@code toIndex} is negative, or {@code fromIndex} is\n-     *         larger than {@code toIndex}\n-     * @since  1.4\n+     * specified {@code toIndex} (exclusive) to the complement of its current value.\n+     *\n+     * @param fromIndex index of the first bit to flip\n+     * @param toIndex   index after the last bit to flip\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     * @since 1.4\n@@ -413,1 +457,1 @@\n-        int endWordIndex   = wordIndex(toIndex - 1);\n+        int endWordIndex = wordIndex(toIndex - 1);\n@@ -417,1 +461,1 @@\n-        long lastWordMask  = WORD_MASK >>> -toIndex;\n+        long lastWordMask = WORD_MASK >>> -toIndex;\n@@ -420,0 +464,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -421,0 +466,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -424,0 +470,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -425,0 +472,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -427,1 +475,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+                cardinality += BITS_PER_WORD - 2 * bitCount(i);\n@@ -429,0 +478,1 @@\n+            }\n@@ -431,0 +481,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -432,0 +483,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -441,1 +493,1 @@\n-     * @param  bitIndex a bit index\n+     * @param bitIndex a bit index\n@@ -443,1 +495,1 @@\n-     * @since  1.0\n+     * @since 1.0\n@@ -450,1 +502,3 @@\n-        expandTo(wordIndex);\n+        final long bitMask = 1L << bitIndex;\n+        if (wordIndex < wordsInUse && (words[wordIndex] & bitMask) != 0)\n+            return;\n@@ -452,1 +506,3 @@\n-        words[wordIndex] |= (1L << bitIndex); \/\/ Restores invariants\n+        expandTo(wordIndex);\n+        words[wordIndex] |= bitMask; \/\/ Restores invariants\n+        cardinality++;\n@@ -460,2 +516,2 @@\n-     * @param  bitIndex a bit index\n-     * @param  value a boolean value to set\n+     * @param bitIndex a bit index\n+     * @param value    a boolean value to set\n@@ -463,1 +519,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -476,6 +532,7 @@\n-     * @param  fromIndex index of the first bit to be set\n-     * @param  toIndex index after the last bit to be set\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n-     *         or {@code toIndex} is negative, or {@code fromIndex} is\n-     *         larger than {@code toIndex}\n-     * @since  1.4\n+     * @param fromIndex index of the first bit to be set\n+     * @param toIndex   index after the last bit to be set\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     * @since 1.4\n@@ -491,1 +548,1 @@\n-        int endWordIndex   = wordIndex(toIndex - 1);\n+        int endWordIndex = wordIndex(toIndex - 1);\n@@ -495,1 +552,1 @@\n-        long lastWordMask  = WORD_MASK >>> -toIndex;\n+        long lastWordMask = WORD_MASK >>> -toIndex;\n@@ -498,0 +555,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -499,0 +557,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -502,0 +561,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -503,0 +563,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -505,1 +566,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+                cardinality += BITS_PER_WORD - bitCount(i);\n@@ -507,0 +569,1 @@\n+            }\n@@ -509,0 +572,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -510,0 +574,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -519,7 +584,8 @@\n-     * @param  fromIndex index of the first bit to be set\n-     * @param  toIndex index after the last bit to be set\n-     * @param  value value to set the selected bits to\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n-     *         or {@code toIndex} is negative, or {@code fromIndex} is\n-     *         larger than {@code toIndex}\n-     * @since  1.4\n+     * @param fromIndex index of the first bit to be set\n+     * @param toIndex   index after the last bit to be set\n+     * @param value     value to set the selected bits to\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     * @since 1.4\n@@ -537,1 +603,1 @@\n-     * @param  bitIndex the index of the bit to be cleared\n+     * @param bitIndex the index of the bit to be cleared\n@@ -539,1 +605,1 @@\n-     * @since  1.0\n+     * @since 1.0\n@@ -546,1 +612,2 @@\n-        if (wordIndex >= wordsInUse)\n+        final long bitMask = 1L << bitIndex;\n+        if (wordIndex >= wordsInUse || (words[wordIndex] & bitMask) == 0)\n@@ -549,1 +616,2 @@\n-        words[wordIndex] &= ~(1L << bitIndex);\n+        words[wordIndex] &= ~bitMask;\n+        cardinality--;\n@@ -559,6 +627,7 @@\n-     * @param  fromIndex index of the first bit to be cleared\n-     * @param  toIndex index after the last bit to be cleared\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n-     *         or {@code toIndex} is negative, or {@code fromIndex} is\n-     *         larger than {@code toIndex}\n-     * @since  1.4\n+     * @param fromIndex index of the first bit to be cleared\n+     * @param toIndex   index after the last bit to be cleared\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     * @since 1.4\n@@ -583,1 +652,1 @@\n-        long lastWordMask  = WORD_MASK >>> -toIndex;\n+        long lastWordMask = WORD_MASK >>> -toIndex;\n@@ -586,0 +655,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -587,0 +657,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -590,0 +661,1 @@\n+            cardinality -= bitCount(startWordIndex);\n@@ -591,0 +663,1 @@\n+            cardinality += bitCount(startWordIndex);\n@@ -593,1 +666,2 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++)\n+            for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n+                cardinality -= bitCount(i);\n@@ -595,0 +669,1 @@\n+            }\n@@ -597,0 +672,1 @@\n+            cardinality -= bitCount(endWordIndex);\n@@ -598,0 +674,1 @@\n+            cardinality += bitCount(endWordIndex);\n@@ -610,2 +687,3 @@\n-        while (wordsInUse > 0)\n-            words[--wordsInUse] = 0;\n+        Arrays.fill(words, 0, wordsInUse, 0);\n+        wordsInUse = 0;\n+        cardinality = 0;\n@@ -615,4 +693,3 @@\n-     * Returns the value of the bit with the specified index. The value\n-     * is {@code true} if the bit with the index {@code bitIndex}\n-     * is currently set in this {@code BitSet}; otherwise, the result\n-     * is {@code false}.\n+     * Returns the value of the bit with the specified index. The value is\n+     * {@code true} if the bit with the index {@code bitIndex} is currently set in\n+     * this {@code BitSet}; otherwise, the result is {@code false}.\n@@ -620,1 +697,1 @@\n-     * @param  bitIndex   the bit index\n+     * @param bitIndex the bit index\n@@ -631,2 +708,1 @@\n-        return (wordIndex < wordsInUse)\n-            && ((words[wordIndex] & (1L << bitIndex)) != 0);\n+        return (wordIndex < wordsInUse) && ((words[wordIndex] & (1L << bitIndex)) != 0);\n@@ -636,2 +712,2 @@\n-     * Returns a new {@code BitSet} composed of bits from this {@code BitSet}\n-     * from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).\n+     * Returns a new {@code BitSet} composed of bits from this {@code BitSet} from\n+     * {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).\n@@ -639,2 +715,2 @@\n-     * @param  fromIndex index of the first bit to include\n-     * @param  toIndex index after the last bit to include\n+     * @param fromIndex index of the first bit to include\n+     * @param toIndex   index after the last bit to include\n@@ -642,4 +718,5 @@\n-     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,\n-     *         or {@code toIndex} is negative, or {@code fromIndex} is\n-     *         larger than {@code toIndex}\n-     * @since  1.4\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     * @since 1.4\n@@ -669,3 +746,2 @@\n-            result.words[i] = wordAligned ? words[sourceIndex] :\n-                (words[sourceIndex] >>> fromIndex) |\n-                (words[sourceIndex+1] << -fromIndex);\n+            result.words[i] = wordAligned ? words[sourceIndex]\n+                    : (words[sourceIndex] >>> fromIndex) | (words[sourceIndex + 1] << -fromIndex);\n@@ -675,9 +751,6 @@\n-        result.words[targetWords - 1] =\n-            ((toIndex-1) & BIT_INDEX_MASK) < (fromIndex & BIT_INDEX_MASK)\n-            ? \/* straddles source words *\/\n-            ((words[sourceIndex] >>> fromIndex) |\n-             (words[sourceIndex+1] & lastWordMask) << -fromIndex)\n-            :\n-            ((words[sourceIndex] & lastWordMask) >>> fromIndex);\n-\n-        \/\/ Set wordsInUse correctly\n+        result.words[targetWords - 1] = ((toIndex - 1) & BIT_INDEX_MASK) < (fromIndex & BIT_INDEX_MASK)\n+                ? \/* straddles source words *\/\n+                ((words[sourceIndex] >>> fromIndex) | (words[sourceIndex + 1] & lastWordMask) << -fromIndex)\n+                : ((words[sourceIndex] & lastWordMask) >>> fromIndex);\n+\n+        \/\/ Set wordsInUse and cardinality correctly\n@@ -686,0 +759,1 @@\n+        result.computeCardinality();\n@@ -692,3 +766,3 @@\n-     * Returns the index of the first bit that is set to {@code true}\n-     * that occurs on or after the specified starting index. If no such\n-     * bit exists then {@code -1} is returned.\n+     * Returns the index of the first bit that is set to {@code true} that occurs on\n+     * or after the specified starting index. If no such bit exists then {@code -1}\n+     * is returned.\n@@ -696,2 +770,3 @@\n-     * <p>To iterate over the {@code true} bits in a {@code BitSet},\n-     * use the following loop:\n+     * <p>\n+     * To iterate over the {@code true} bits in a {@code BitSet}, use the following\n+     * loop:\n@@ -699,2 +774,2 @@\n-     *  <pre> {@code\n-     * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n+     * <pre> {@code\n+     * for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n@@ -705,1 +780,2 @@\n-     * }}<\/pre>\n+     * }\n+     * }<\/pre>\n@@ -707,3 +783,2 @@\n-     * @param  fromIndex the index to start checking from (inclusive)\n-     * @return the index of the next set bit, or {@code -1} if there\n-     *         is no such bit\n+     * @param fromIndex the index to start checking from (inclusive)\n+     * @return the index of the next set bit, or {@code -1} if there is no such bit\n@@ -711,1 +786,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -735,2 +810,2 @@\n-     * Returns the index of the first bit that is set to {@code false}\n-     * that occurs on or after the specified starting index.\n+     * Returns the index of the first bit that is set to {@code false} that occurs\n+     * on or after the specified starting index.\n@@ -738,1 +813,1 @@\n-     * @param  fromIndex the index to start checking from (inclusive)\n+     * @param fromIndex the index to start checking from (inclusive)\n@@ -741,1 +816,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -767,4 +842,3 @@\n-     * Returns the index of the nearest bit that is set to {@code true}\n-     * that occurs on or before the specified starting index.\n-     * If no such bit exists, or if {@code -1} is given as the\n-     * starting index, then {@code -1} is returned.\n+     * Returns the index of the nearest bit that is set to {@code true} that occurs\n+     * on or before the specified starting index. If no such bit exists, or if\n+     * {@code -1} is given as the starting index, then {@code -1} is returned.\n@@ -772,2 +846,3 @@\n-     * <p>To iterate over the {@code true} bits in a {@code BitSet},\n-     * use the following loop:\n+     * <p>\n+     * To iterate over the {@code true} bits in a {@code BitSet}, use the following\n+     * loop:\n@@ -775,2 +850,2 @@\n-     *  <pre> {@code\n-     * for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\n+     * <pre> {@code\n+     * for (int i = bs.length(); (i = bs.previousSetBit(i - 1)) >= 0;) {\n@@ -778,8 +853,9 @@\n-     * }}<\/pre>\n-     *\n-     * @param  fromIndex the index to start checking from (inclusive)\n-     * @return the index of the previous set bit, or {@code -1} if there\n-     *         is no such bit\n-     * @throws IndexOutOfBoundsException if the specified index is less\n-     *         than {@code -1}\n-     * @since  1.7\n+     * }\n+     * }<\/pre>\n+     *\n+     * @param fromIndex the index to start checking from (inclusive)\n+     * @return the index of the previous set bit, or {@code -1} if there is no such\n+     *         bit\n+     * @throws IndexOutOfBoundsException if the specified index is less than\n+     *                                   {@code -1}\n+     * @since 1.7\n@@ -791,2 +867,1 @@\n-            throw new IndexOutOfBoundsException(\n-                \"fromIndex < -1: \" + fromIndex);\n+            throw new IndexOutOfBoundsException(\"fromIndex < -1: \" + fromIndex);\n@@ -801,1 +876,1 @@\n-        long word = words[u] & (WORD_MASK >>> -(fromIndex+1));\n+        long word = words[u] & (WORD_MASK >>> -(fromIndex + 1));\n@@ -805,1 +880,1 @@\n-                return (u+1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n+                return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n@@ -813,11 +888,10 @@\n-     * Returns the index of the nearest bit that is set to {@code false}\n-     * that occurs on or before the specified starting index.\n-     * If no such bit exists, or if {@code -1} is given as the\n-     * starting index, then {@code -1} is returned.\n-     *\n-     * @param  fromIndex the index to start checking from (inclusive)\n-     * @return the index of the previous clear bit, or {@code -1} if there\n-     *         is no such bit\n-     * @throws IndexOutOfBoundsException if the specified index is less\n-     *         than {@code -1}\n-     * @since  1.7\n+     * Returns the index of the nearest bit that is set to {@code false} that occurs\n+     * on or before the specified starting index. If no such bit exists, or if\n+     * {@code -1} is given as the starting index, then {@code -1} is returned.\n+     *\n+     * @param fromIndex the index to start checking from (inclusive)\n+     * @return the index of the previous clear bit, or {@code -1} if there is no\n+     *         such bit\n+     * @throws IndexOutOfBoundsException if the specified index is less than\n+     *                                   {@code -1}\n+     * @since 1.7\n@@ -829,2 +903,1 @@\n-            throw new IndexOutOfBoundsException(\n-                \"fromIndex < -1: \" + fromIndex);\n+            throw new IndexOutOfBoundsException(\"fromIndex < -1: \" + fromIndex);\n@@ -839,1 +912,1 @@\n-        long word = ~words[u] & (WORD_MASK >>> -(fromIndex+1));\n+        long word = ~words[u] & (WORD_MASK >>> -(fromIndex + 1));\n@@ -843,1 +916,1 @@\n-                return (u+1) * BITS_PER_WORD -1 - Long.numberOfLeadingZeros(word);\n+                return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);\n@@ -851,3 +924,3 @@\n-     * Returns the \"logical size\" of this {@code BitSet}: the index of\n-     * the highest set bit in the {@code BitSet} plus one. Returns zero\n-     * if the {@code BitSet} contains no set bits.\n+     * Returns the \"logical size\" of this {@code BitSet}: the index of the highest\n+     * set bit in the {@code BitSet} plus one. Returns zero if the {@code BitSet}\n+     * contains no set bits.\n@@ -856,1 +929,1 @@\n-     * @since  1.2\n+     * @since 1.2\n@@ -862,2 +935,1 @@\n-        return BITS_PER_WORD * (wordsInUse - 1) +\n-            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - 1]));\n+        return BITS_PER_WORD * wordsInUse - Long.numberOfLeadingZeros(words[wordsInUse - 1]);\n@@ -867,2 +939,2 @@\n-     * Returns true if this {@code BitSet} contains no bits that are set\n-     * to {@code true}.\n+     * Returns true if this {@code BitSet} contains no bits that are set to\n+     * {@code true}.\n@@ -871,1 +943,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -874,1 +946,1 @@\n-        return wordsInUse == 0;\n+        return cardinality == 0;\n@@ -878,2 +950,2 @@\n-     * Returns true if the specified {@code BitSet} has any bits set to\n-     * {@code true} that are also set to {@code true} in this {@code BitSet}.\n+     * Returns true if the specified {@code BitSet} has any bits set to {@code true}\n+     * that are also set to {@code true} in this {@code BitSet}.\n@@ -881,4 +953,4 @@\n-     * @param  set {@code BitSet} to intersect with\n-     * @return boolean indicating whether this {@code BitSet} intersects\n-     *         the specified {@code BitSet}\n-     * @since  1.4\n+     * @param set {@code BitSet} to intersect with\n+     * @return boolean indicating whether this {@code BitSet} intersects the\n+     *         specified {@code BitSet}\n+     * @since 1.4\n@@ -893,0 +965,21 @@\n+    \/**\n+     * Returns true if all bits set to {@code true} in the specified {@code BitSet}\n+     * are also set to {@code true} in this {@code BitSet}.\n+     *\n+     * @param set {@code BitSet} to test\n+     * @return boolean indicating whether this {@code BitSet} includes the specified\n+     *         {@code BitSet}\n+     * @since 21\n+     * @author Fabio Romano\n+     *\/\n+    public boolean includes(BitSet set) {\n+        if (set.cardinality > cardinality || set.length() > length())\n+            return false;\n+\n+        \/\/ set.wordsInUse <= wordsInUse\n+        for (int i = 0; i < set.wordsInUse; i++)\n+            if ((~set.words[i] | words[i]) != WORD_MASK) \/\/ Perform logical (!a | b) on words in common\n+                return false;\n+        return true;\n+    }\n+\n@@ -897,1 +990,1 @@\n-     * @since  1.4\n+     * @since 1.4\n@@ -900,4 +993,1 @@\n-        int sum = 0;\n-        for (int i = 0; i < wordsInUse; i++)\n-            sum += Long.bitCount(words[i]);\n-        return sum;\n+        return cardinality;\n@@ -907,5 +997,5 @@\n-     * Performs a logical <b>AND<\/b> of this target bit set with the\n-     * argument bit set. This bit set is modified so that each bit in it\n-     * has the value {@code true} if and only if it both initially\n-     * had the value {@code true} and the corresponding bit in the\n-     * bit set argument also had the value {@code true}.\n+     * Performs a logical <b>AND<\/b> of this target bit set with the argument bit\n+     * set. This bit set is modified so that each bit in it has the value\n+     * {@code true} if and only if it both initially had the value {@code true} and\n+     * the corresponding bit in the bit set argument also had the value\n+     * {@code true}.\n@@ -927,0 +1017,1 @@\n+        computeCardinality();\n@@ -931,5 +1022,4 @@\n-     * Performs a logical <b>OR<\/b> of this bit set with the bit set\n-     * argument. This bit set is modified so that a bit in it has the\n-     * value {@code true} if and only if it either already had the\n-     * value {@code true} or the corresponding bit in the bit set\n-     * argument has the value {@code true}.\n+     * Performs a logical <b>OR<\/b> of this bit set with the bit set argument. This\n+     * bit set is modified so that a bit in it has the value {@code true} if and\n+     * only if it either already had the value {@code true} or the corresponding bit\n+     * in the bit set argument has the value {@code true}.\n@@ -956,3 +1046,1 @@\n-            System.arraycopy(set.words, wordsInCommon,\n-                             words, wordsInCommon,\n-                             wordsInUse - wordsInCommon);\n+            System.arraycopy(set.words, wordsInCommon, words, wordsInCommon, wordsInUse - wordsInCommon);\n@@ -961,0 +1049,1 @@\n+        computeCardinality();\n@@ -965,4 +1054,3 @@\n-     * Performs a logical <b>XOR<\/b> of this bit set with the bit set\n-     * argument. This bit set is modified so that a bit in it has the\n-     * value {@code true} if and only if one of the following\n-     * statements holds:\n+     * Performs a logical <b>XOR<\/b> of this bit set with the bit set argument. This\n+     * bit set is modified so that a bit in it has the value {@code true} if and\n+     * only if one of the following statements holds:\n@@ -970,4 +1058,4 @@\n-     * <li>The bit initially has the value {@code true}, and the\n-     *     corresponding bit in the argument has the value {@code false}.\n-     * <li>The bit initially has the value {@code false}, and the\n-     *     corresponding bit in the argument has the value {@code true}.\n+     * <li>The bit initially has the value {@code true}, and the corresponding bit\n+     * in the argument has the value {@code false}.\n+     * <li>The bit initially has the value {@code false}, and the corresponding bit\n+     * in the argument has the value {@code true}.\n@@ -976,1 +1064,1 @@\n-     * @param  set a bit set\n+     * @param set a bit set\n@@ -979,0 +1067,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+\n@@ -992,3 +1086,1 @@\n-            System.arraycopy(set.words, wordsInCommon,\n-                             words, wordsInCommon,\n-                             set.wordsInUse - wordsInCommon);\n+            System.arraycopy(set.words, wordsInCommon, words, wordsInCommon, set.wordsInUse - wordsInCommon);\n@@ -997,0 +1089,1 @@\n+        computeCardinality();\n@@ -1001,2 +1094,2 @@\n-     * Clears all of the bits in this {@code BitSet} whose corresponding\n-     * bit is set in the specified {@code BitSet}.\n+     * Clears all of the bits in this {@code BitSet} whose corresponding bit is set\n+     * in the specified {@code BitSet}.\n@@ -1004,3 +1097,2 @@\n-     * @param  set the {@code BitSet} with which to mask this\n-     *         {@code BitSet}\n-     * @since  1.2\n+     * @param set the {@code BitSet} with which to mask this {@code BitSet}\n+     * @since 1.2\n@@ -1010,1 +1102,2 @@\n-        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--)\n+        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--) {\n+            cardinality -= bitCount(i);\n@@ -1012,0 +1105,2 @@\n+            cardinality += bitCount(i);\n+        }\n@@ -1018,2 +1113,5 @@\n-     * Returns the hash code value for this bit set. The hash code depends\n-     * only on which bits are set within this {@code BitSet}.\n+     * Returns the hash code value for this bit set. The hash code depends only on\n+     * which bits are set within this {@code BitSet}.\n+     *\n+     * <p>\n+     * The hash code is defined to be the result of the following calculation:\n@@ -1021,3 +1119,1 @@\n-     * <p>The hash code is defined to be the result of the following\n-     * calculation:\n-     *  <pre> {@code\n+     * <pre> {@code\n@@ -1027,1 +1123,1 @@\n-     *     for (int i = words.length; --i >= 0; )\n+     *     for (int i = words.length; --i >= 0;)\n@@ -1029,2 +1125,4 @@\n-     *     return (int)((h >> 32) ^ h);\n-     * }}<\/pre>\n+     *     return (int) ((h >> 32) ^ h);\n+     * }\n+     * }<\/pre>\n+     *\n@@ -1037,1 +1135,1 @@\n-        for (int i = wordsInUse; --i >= 0; )\n+        for (int i = wordsInUse; --i >= 0;)\n@@ -1040,1 +1138,1 @@\n-        return (int)((h >> 32) ^ h);\n+        return (int) ((h >> 32) ^ h);\n@@ -1044,3 +1142,3 @@\n-     * Returns the number of bits of space actually in use by this\n-     * {@code BitSet} to represent bit values.\n-     * The maximum element in the set is the size - 1st element.\n+     * Returns the number of bits of space actually in use by this {@code BitSet} to\n+     * represent bit values. The maximum element in the set is the size - 1st\n+     * element.\n@@ -1055,4 +1153,3 @@\n-     * Compares this object against the specified object.\n-     * The result is {@code true} if and only if the argument is\n-     * not {@code null} and is a {@code BitSet} object that has\n-     * exactly the same set of bits set to {@code true} as this bit\n+     * Compares this object against the specified object. The result is {@code true}\n+     * if and only if the argument is not {@code null} and is a {@code BitSet}\n+     * object that has exactly the same set of bits set to {@code true} as this bit\n@@ -1060,1 +1157,5 @@\n-     * <pre>((BitSet)obj).get(k) == this.get(k)<\/pre>\n+     *\n+     * <pre>\n+     * ((BitSet) obj).get(k) == this.get(k)\n+     * <\/pre>\n+     *\n@@ -1063,4 +1164,3 @@\n-     * @param  obj the object to compare with\n-     * @return {@code true} if the objects are the same;\n-     *         {@code false} otherwise\n-     * @see    #size()\n+     * @param obj the object to compare with\n+     * @return {@code true} if the objects are the same; {@code false} otherwise\n+     * @see #size()\n@@ -1077,1 +1177,1 @@\n-        if (wordsInUse != set.wordsInUse)\n+        if (cardinality != set.cardinality || length() != set.length())\n@@ -1089,4 +1189,3 @@\n-     * Cloning this {@code BitSet} produces a new {@code BitSet}\n-     * that is equal to it.\n-     * The clone of the bit set is another bit set that has exactly the\n-     * same bits set to {@code true} as this bit set.\n+     * Cloning this {@code BitSet} produces a new {@code BitSet} that is equal to\n+     * it. The clone of the bit set is another bit set that has exactly the same\n+     * bits set to {@code true} as this bit set.\n@@ -1095,1 +1194,1 @@\n-     * @see    #size()\n+     * @see #size()\n@@ -1098,1 +1197,1 @@\n-        if (! sizeIsSticky)\n+        if (!sizeIsSticky)\n@@ -1113,2 +1212,2 @@\n-     * Calling this method may, but is not required to, affect the value\n-     * returned by a subsequent call to the {@link #size()} method.\n+     * Calling this method may, but is not required to, affect the value returned by\n+     * a subsequent call to the {@link #size()} method.\n@@ -1124,2 +1223,2 @@\n-     * Save the state of the {@code BitSet} instance to a stream (i.e.,\n-     * serialize it).\n+     * Save the state of the {@code BitSet} instance to a stream (i.e., serialize\n+     * it).\n@@ -1128,2 +1227,1 @@\n-    private void writeObject(ObjectOutputStream s)\n-        throws IOException {\n+    private void writeObject(ObjectOutputStream s) throws IOException {\n@@ -1133,1 +1231,1 @@\n-        if (! sizeIsSticky)\n+        if (!sizeIsSticky)\n@@ -1142,2 +1240,2 @@\n-     * Reconstitute the {@code BitSet} instance from a stream (i.e.,\n-     * deserialize it).\n+     * Reconstitute the {@code BitSet} instance from a stream (i.e., deserialize\n+     * it).\n@@ -1146,2 +1244,1 @@\n-    private void readObject(ObjectInputStream s)\n-        throws IOException, ClassNotFoundException {\n+    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n@@ -1157,1 +1254,2 @@\n-        sizeIsSticky = (words.length > 0 && words[words.length-1] == 0L); \/\/ heuristic\n+        computeCardinality();\n+        sizeIsSticky = (words.length > 0 && words[words.length - 1] == 0L); \/\/ heuristic\n@@ -1162,9 +1260,10 @@\n-     * Returns a string representation of this bit set. For every index\n-     * for which this {@code BitSet} contains a bit in the set\n-     * state, the decimal representation of that index is included in\n-     * the result. Such indices are listed in order from lowest to\n-     * highest, separated by \",&nbsp;\" (a comma and a space) and\n-     * surrounded by braces, resulting in the usual mathematical\n-     * notation for a set of integers.\n-     *\n-     * <p>Example:\n+     * Returns a string representation of this bit set. For every index for which\n+     * this {@code BitSet} contains a bit in the set state, the decimal\n+     * representation of that index is included in the result. Such indices are\n+     * listed in order from lowest to highest, separated by \",&nbsp;\" (a comma and a\n+     * space) and surrounded by braces, resulting in the usual mathematical notation\n+     * for a set of integers.\n+     *\n+     * <p>\n+     * Example:\n+     *\n@@ -1172,1 +1271,3 @@\n-     * BitSet drPepper = new BitSet();<\/pre>\n+     * BitSet drPepper = new BitSet();\n+     * <\/pre>\n+     *\n@@ -1174,0 +1275,1 @@\n+     *\n@@ -1175,1 +1277,3 @@\n-     * drPepper.set(2);<\/pre>\n+     * drPepper.set(2);\n+     * <\/pre>\n+     *\n@@ -1177,0 +1281,1 @@\n+     *\n@@ -1179,1 +1284,3 @@\n-     * drPepper.set(10);<\/pre>\n+     * drPepper.set(10);\n+     * <\/pre>\n+     *\n@@ -1188,5 +1295,3 @@\n-        int numBits = (wordsInUse > 128) ?\n-            cardinality() : wordsInUse * BITS_PER_WORD;\n-        \/\/ Avoid overflow in the case of a humongous numBits\n-        int initialCapacity = (numBits <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n-            6 * numBits + 2 : MAX_INITIAL_CAPACITY;\n+        \/\/ Avoid overflow in the case of a humongous cardinality\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ? 6 * cardinality + 2\n+                : MAX_INITIAL_CAPACITY;\n@@ -1200,2 +1305,4 @@\n-                if (++i < 0) break;\n-                if ((i = nextSetBit(i)) < 0) break;\n+                if (++i < 0)\n+                    break;\n+                if ((i = nextSetBit(i)) < 0)\n+                    break;\n@@ -1203,2 +1310,3 @@\n-                do { b.append(\", \").append(i); }\n-                while (++i != endOfRun);\n+                do {\n+                    b.append(\", \").append(i);\n+                } while (++i != endOfRun);\n@@ -1213,4 +1321,3 @@\n-     * Returns a stream of indices for which this {@code BitSet}\n-     * contains a bit in the set state. The indices are returned\n-     * in order, from lowest to highest. The size of the stream\n-     * is the number of bits in the set state, equal to the value\n+     * Returns a stream of indices for which this {@code BitSet} contains a bit in\n+     * the set state. The indices are returned in order, from lowest to highest. The\n+     * size of the stream is the number of bits in the set state, equal to the value\n@@ -1219,4 +1326,5 @@\n-     * <p>The stream binds to this bit set when the terminal stream operation\n-     * commences (specifically, the spliterator for the stream is\n-     * <a href=\"Spliterator.html#binding\"><em>late-binding<\/em><\/a>).  If the\n-     * bit set is modified during that operation then the result is undefined.\n+     * <p>\n+     * The stream binds to this bit set when the terminal stream operation commences\n+     * (specifically, the spliterator for the stream is\n+     * <a href=\"Spliterator.html#binding\"><em>late-binding<\/em><\/a>). If the bit set\n+     * is modified during that operation then the result is undefined.\n@@ -1231,1 +1339,1 @@\n-            private int est;   \/\/ size estimate\n+            private int est; \/\/ size estimate\n@@ -1250,4 +1358,3 @@\n-                    hi = fence = (wordsInUse >= wordIndex(Integer.MAX_VALUE))\n-                                 ? Integer.MAX_VALUE\n-                                 : wordsInUse << ADDRESS_BITS_PER_WORD;\n-                    est = cardinality();\n+                    hi = fence = (wordsInUse >= wordIndex(Integer.MAX_VALUE)) ? Integer.MAX_VALUE\n+                            : wordsInUse << ADDRESS_BITS_PER_WORD;\n+                    est = cardinality;\n@@ -1291,1 +1398,1 @@\n-                    int u = wordIndex(i);      \/\/ next lower word bound\n+                    int u = wordIndex(i); \/\/ next lower word bound\n@@ -1294,2 +1401,1 @@\n-                    words_loop:\n-                    for (; u <= v && i <= hi; u++, i = u << ADDRESS_BITS_PER_WORD) {\n+                    words_loop: for (; u <= v && i <= hi; u++, i = u << ADDRESS_BITS_PER_WORD) {\n@@ -1331,2 +1437,1 @@\n-                hi = fence = (hi < Integer.MAX_VALUE || !get(Integer.MAX_VALUE))\n-                        ? previousSetBit(hi - 1) + 1\n+                hi = fence = (hi < Integer.MAX_VALUE || !get(Integer.MAX_VALUE)) ? previousSetBit(hi - 1) + 1\n@@ -1360,2 +1465,1 @@\n-                return (root ? Spliterator.SIZED : 0) |\n-                    Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED;\n+                return (root ? Spliterator.SIZED : 0) | Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SORTED;\n@@ -1373,9 +1477,7 @@\n-     * Returns the index of the first bit that is set to {@code true}\n-     * that occurs on or after the specified starting index and up to and\n-     * including the specified word index\n-     * If no such bit exists then {@code -1} is returned.\n-     *\n-     * @param  fromIndex the index to start checking from (inclusive)\n-     * @param  toWordIndex the last word index to check (inclusive)\n-     * @return the index of the next set bit, or {@code -1} if there\n-     *         is no such bit\n+     * Returns the index of the first bit that is set to {@code true} that occurs on\n+     * or after the specified starting index and up to and including the specified\n+     * word index If no such bit exists then {@code -1} is returned.\n+     *\n+     * @param fromIndex   the index to start checking from (inclusive)\n+     * @param toWordIndex the last word index to check (inclusive)\n+     * @return the index of the next set bit, or {@code -1} if there is no such bit\n@@ -1400,1 +1502,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":485,"deletions":384,"binary":false,"changes":869,"status":"modified"},{"patch":"@@ -821,0 +821,40 @@\n+    }\n+\n+    private static void testIncludes() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            BitSet b1 = new BitSet(256);\n+            BitSet b2 = new BitSet(256);\n+\n+            \/\/ Set some random bits in first set\n+            int nextBitToSet = 0;\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure b1 includes b2\n+            b1.or(b2);\n+\n+            if (!b1.includes(b2))\n+                failCount++;\n+\n+            \/\/ Remove a common set bit\n+            nextBitToSet = b2.nextSetBit(generator.nextInt(b2.length()));\n+            b1.clear(nextBitToSet);\n+\n+            \/\/ Make sure b1 doesn't include b2\n+            if (b1.includes(b2))\n+                failCount++;\n+\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Includes                  \", failCount);\n","filename":"test\/jdk\/java\/util\/BitSet\/BSMethods.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}