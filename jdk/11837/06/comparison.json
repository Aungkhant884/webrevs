{"files":[{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230119_192355.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230120_161035.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n+    static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n@@ -94,1 +94,1 @@\n-    private long[] words;\n+    long[] words;\n@@ -99,1 +99,1 @@\n-    private transient int wordsInUse = 0;\n+    transient int wordsInUse = 0;\n@@ -105,1 +105,1 @@\n-    private transient boolean sizeIsSticky = false;\n+    transient boolean sizeIsSticky = false;\n@@ -114,1 +114,1 @@\n-    private static int wordIndex(int bitIndex) {\n+    static int wordIndex(int bitIndex) {\n@@ -121,1 +121,1 @@\n-    private void checkInvariants() {\n+    void checkInvariants() {\n@@ -132,1 +132,1 @@\n-    private void recalculateWordsInUse() {\n+    void recalculateWordsInUse() {\n@@ -135,5 +135,2 @@\n-        for (i = wordsInUse-1; i >= 0; i--)\n-            if (words[i] != 0)\n-                break;\n-\n-        wordsInUse = i+1; \/\/ The new logical size\n+        for (i = wordsInUse - 1; i >= 0 && words[i] == 0; i--);\n+        wordsInUse = i + 1; \/\/ The new logical size\n@@ -174,1 +171,0 @@\n-     * The last word (if there is one) must be non-zero.\n@@ -176,1 +172,1 @@\n-    private BitSet(long[] words) {\n+    BitSet(long[] words) {\n@@ -179,0 +175,2 @@\n+        \/\/ Set wordsInUse correctly\n+        recalculateWordsInUse();\n@@ -199,0 +197,4 @@\n+        return new BitSet(getWords(longs));\n+    }\n+    \n+    static long[] getWords(long[] longs) {\n@@ -200,3 +202,2 @@\n-        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--)\n-            ;\n-        return new BitSet(Arrays.copyOf(longs, n));\n+        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--);\n+        return Arrays.copyOf(longs, n);\n@@ -224,0 +225,4 @@\n+        return new BitSet(getWords(lb));\n+    }\n+    \n+    static long[] getWords(LongBuffer lb) {\n@@ -228,0 +233,1 @@\n+        \n@@ -230,1 +236,1 @@\n-        return new BitSet(words);\n+        return words;\n@@ -250,1 +256,5 @@\n-        return BitSet.valueOf(ByteBuffer.wrap(bytes));\n+        return BitSet.valueOf(getWords(bytes));\n+    }\n+    \n+    static long[] getWords(byte[] bytes) {\n+        return getWords(ByteBuffer.wrap(bytes));\n@@ -272,0 +282,4 @@\n+        return new BitSet(getWords(bb));\n+    }\n+    \n+    static long[] getWords(ByteBuffer bb) {\n@@ -283,1 +297,2 @@\n-        return new BitSet(words);\n+        \n+        return words;\n@@ -648,0 +663,4 @@\n+        return new BitSet(getWords(fromIndex, toIndex));\n+    }\n+    \n+    long[] getWords(int fromIndex, int toIndex) {\n@@ -652,1 +671,1 @@\n-        int len = length();\n+        final int len = length();\n@@ -654,1 +673,1 @@\n-        \/\/ If no set bits in range return empty bitset\n+        \/\/ If no set bits in range return empty array\n@@ -656,1 +675,1 @@\n-            return new BitSet(0);\n+            return new long[0];\n@@ -662,2 +681,1 @@\n-        BitSet result = new BitSet(toIndex - fromIndex);\n-        int targetWords = wordIndex(toIndex - fromIndex - 1) + 1;\n+        final long[] result = new long[wordIndex(toIndex - fromIndex - 1) + 1];\n@@ -665,1 +683,1 @@\n-        boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n+        final boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n@@ -668,2 +686,2 @@\n-        for (int i = 0; i < targetWords - 1; i++, sourceIndex++)\n-            result.words[i] = wordAligned ? words[sourceIndex] :\n+        for (int i = 0; i < result.length - 1; i++, sourceIndex++)\n+            result[i] = wordAligned ? words[sourceIndex] :\n@@ -674,2 +692,2 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n-        result.words[targetWords - 1] =\n+        final long lastWordMask = WORD_MASK >>> -toIndex;\n+        result[result.length - 1] =\n@@ -682,6 +700,1 @@\n-\n-        \/\/ Set wordsInUse correctly\n-        result.wordsInUse = targetWords;\n-        result.recalculateWordsInUse();\n-        result.checkInvariants();\n-\n+        \n@@ -862,2 +875,1 @@\n-        return BITS_PER_WORD * (wordsInUse - 1) +\n-            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - 1]));\n+        return BITS_PER_WORD * wordsInUse - Long.numberOfLeadingZeros(words[wordsInUse - 1]);\n@@ -979,0 +991,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+        \n@@ -1009,0 +1027,6 @@\n+        \/\/ An optimization\n+        if (this == set) {\n+            clear();\n+            return;\n+        }\n+        \n@@ -1077,1 +1101,1 @@\n-        if (wordsInUse != set.wordsInUse)\n+        if (length() != set.length()) \/\/ more accurate than (wordsInUse != set.wordsInUse)\n@@ -1116,1 +1140,1 @@\n-    private void trimToSize() {\n+    void trimToSize() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":64,"deletions":40,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -0,0 +1,562 @@\n+package java.util;\n+\n+import java.io.*;\n+import java.nio.*;\n+\n+\/**\n+ * This class implements a set of non-negative integers that grows as needed.\n+ * Individual integers can be checked if they are contained, added, or removed.\n+ * One {@code NaturalsBitSet} may be used to modify the contents of another\n+ * {@code NaturalsBitSet} through logical AND, logical inclusive OR, and logical\n+ * exclusive OR operations.\n+ *\n+ * <p>\n+ * Every {@code NaturalsBitSet} has a current size, which is the number of bits\n+ * of space currently in use by the bit set. Note that the size is related to\n+ * the implementation of a bit set, so it may change with implementation. The\n+ * length of a bit set relates to logical length of a bit set and is defined\n+ * independently of implementation.\n+ *\n+ * <p>\n+ * Unless otherwise noted, passing a null parameter to any of the methods in a\n+ * {@code NaturalsBitSet} will result in a {@code NullPointerException}.\n+ *\n+ * <p>\n+ * A {@code NaturalsBitSet} is not safe for multithreaded use without external\n+ * synchronization.\n+ *\n+ * @author Fabio Romano\n+ * @since 21\n+ *\/\n+public class NaturalsBitSet extends BitSet {\n+\n+    \/**\n+     * The number of bits set to {@code true} in this {@code BitSet}.\n+     *\/\n+    private transient int cardinality = 0;\n+\n+    \/* use serialVersionUID from JDK 21 for interoperability *\/\n+    @java.io.Serial\n+    private static final long serialVersionUID = -212903409561554139L;\n+\n+    \/**\n+     * Every public method must preserve this invariant.\n+     *\/\n+    private void checkCardinality() {\n+        \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n+        assert (cardinality >= 0 && cardinality - 1 <= length() - 1);\n+    }\n+\n+    \/**\n+     * Creates a new empty {@code NaturalsBitSet}.\n+     *\/\n+    public NaturalsBitSet() {\n+        super();\n+    }\n+\n+    \/**\n+     * Creates an empty {@code NaturalsBitSet} whose initial size is large enough to\n+     * explicitly represent naturals in the range {@code 0} through {@code nbits-1}.\n+     *\n+     * @param nbits the initial size of the bit set\n+     * @throws NegativeArraySizeException if the specified initial size is negative\n+     *\/\n+    public NaturalsBitSet(int nbits) {\n+        super(nbits);\n+    }\n+\n+    \/**\n+     * Constructs a new {@code NaturalsBitSet} containing the integers in the\n+     * specified collection. It is created with an initial capacity sufficient to\n+     * contain the integers in the specified collection.\n+     *\n+     * @param c the collection whose integers are to be placed into this set\n+     * @throws NullPointerException      if the specified collection is null, or if\n+     *                                   some integer in the collection is null\n+     * @throws IndexOutOfBoundsException if some integer in the specified collection\n+     *                                   is negative\n+     *\/\n+    public NaturalsBitSet(Collection<Integer> c) {\n+        this(Collections.max(c) + 1);\n+\n+        for (int i : c)\n+            set(i);\n+    }\n+\n+    private NaturalsBitSet(long[] words) {\n+        super(words);\n+        computeCardinality();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long array.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * longs.length}.\n+     *\n+     * <p>\n+     * This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(LongBuffer.wrap(longs))}.\n+     *\n+     * @param longs a long array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the long array\n+     *\/\n+    public static NaturalsBitSet valueOf(long[] longs) {\n+        return new NaturalsBitSet(getWords(longs));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long buffer between its position and limit.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * lb.remaining()}.\n+     *\n+     * <p>\n+     * The long buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n+     *\n+     * @param lb a long buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(LongBuffer lb) {\n+        return new NaturalsBitSet(getWords(lb));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * byte array.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>\n+     * for all {@code n <  8 * bytes.length}.\n+     *\n+     * <p>\n+     * This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(ByteBuffer.wrap(bytes))}.\n+     *\n+     * @param bytes a byte array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the byte array\n+     *\/\n+    public static NaturalsBitSet valueOf(byte[] bytes) {\n+        return new NaturalsBitSet(getWords(bytes));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * byte buffer between its position and limit.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>\n+     * for all {@code n < 8 * bb.remaining()}.\n+     *\n+     * <p>\n+     * The byte buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n+     *\n+     * @param bb a byte buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(ByteBuffer bb) {\n+        return new NaturalsBitSet(getWords(bb));\n+    }\n+\n+    private void computeCardinality() {\n+        cardinality = bitCount(0, wordsInUse);\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true, starting from startWordIndex\n+     * (inclusive) to endWordIndex (exclusive). Word indices may be greater\n+     * than {@code wordsInUse}.\n+     *\/\n+    private int bitCount(int startWordIndex, int endWordIndex) {\n+        endWordIndex = Math.min(endWordIndex, wordsInUse);\n+        int sum = 0;\n+\n+        for (int i = startWordIndex; i < endWordIndex; i++)\n+            sum += Long.bitCount(words[i]);\n+\n+        return sum;\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true at the specified word.\n+     * {@code wordIndex} may be greater than or equal to {@code wordsInUse}.\n+     *\/\n+    private int bitCount(int wordIndex) {\n+        return wordIndex < wordsInUse ? Long.bitCount(words[wordIndex]) : 0;\n+    }\n+\n+    \/**\n+     * If the specified value is contained in this set, removes it; otherwise adds\n+     * it to this set.\n+     *\n+     * @param n the integer to flip\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void flip(int n) {\n+        super.flip(n);\n+        cardinality += (words[wordIndex(n)] & (1L << n)) != 0 ? 1 : -1;\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Flip each integer (as pecified in {@link #flip(int)} from the specified\n+     * {@code start} (inclusive) to the specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to flip\n+     * @param end   value after the last integer to flip\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void flip(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.flip(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n+\n+            super.flip(start, end);\n+\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n+\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality += (bitCount(i) << 1) - BITS_PER_WORD;\n+        }\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Adds the specified integer to this set.\n+     *\n+     * @param n a non-negative integer\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void set(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex >= wordsInUse || (words[wordIndex] & (1L << n)) == 0) {\n+            super.set(n);\n+            cardinality++;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Adds the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be added\n+     * @param end   the value after the last integer to be added\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void set(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.set(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n+\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality += BITS_PER_WORD - bitCount(i);\n+\n+            super.set(start, end);\n+\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n+        }\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes the specified integer.\n+     *\n+     * @param n the integer to be removed\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void clear(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex < wordsInUse && (words[wordIndex] & (1L << n)) != 0) {\n+            super.clear(n);\n+            cardinality--;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Removes the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be removed\n+     * @param end   value after the last integer to be removed\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void clear(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        if (startWord == endWord) {\n+            cardinality -= bitCount(startWord);\n+            super.clear(start, end);\n+            cardinality += bitCount(startWord);\n+        } else {\n+            cardinality -= bitCount(startWord);\n+            cardinality -= bitCount(endWord);\n+\n+            for (int i = startWord + 1; i < endWord; i++)\n+                cardinality -= bitCount(i);\n+\n+            super.clear(start, end);\n+\n+            cardinality += bitCount(startWord);\n+            cardinality += bitCount(endWord);\n+        }\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes all of the integers in this set.\n+     *\/\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        cardinality = 0;\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} composed of bits from this\n+     * {@code BitSet} from {@code fromIndex} (inclusive) to {@code toIndex}\n+     * (exclusive).\n+     *\n+     * @param fromIndex index of the first bit to include\n+     * @param toIndex   index after the last bit to include\n+     * @return a new {@code NaturalsBitSet} from a range of this\n+     *         {@code NaturalsBitSet}\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     *\/\n+    @Override\n+    public NaturalsBitSet get(int fromIndex, int toIndex) {\n+        return new NaturalsBitSet(getWords(fromIndex, toIndex));\n+    }\n+\n+    \/**\n+     * Returns true if this {@code NaturalsBitSet} contains no integers.\n+     *\n+     * @return boolean indicating whether this {@code NaturalsBitSet} is empty\n+     *\/\n+    @Override\n+    public boolean isEmpty() {\n+        return cardinality == 0;\n+    }\n+\n+    \/**\n+     * Returns the number of integers in this {@code NaturalsBitSet}.\n+     *\n+     * @return the number of integers in this {@code NaturalsBitSet}\n+     *\/\n+    @Override\n+    public int cardinality() {\n+        return cardinality;\n+    }\n+\n+    @Override\n+    public void and(BitSet set) {\n+        if (this != set) {\n+            super.and(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void or(BitSet set) {\n+        if (this != set) {\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.or(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.or(set);\n+                computeCardinality();\n+            }\n+\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void xor(BitSet set) {\n+        if (this == set) { \/\/ An optimization\n+            clear();\n+        } else {\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.xor(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.xor(set);\n+                computeCardinality();\n+            }\n+\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void andNot(BitSet set) {\n+        if (this == set) { \/\/ An optimization\n+            clear();\n+        } else {\n+            if (set.wordsInUse <= wordsInUse \/ 2) { \/\/ An optimization\n+                cardinality -= bitCount(0, set.wordsInUse);\n+                super.andNot(set);\n+                cardinality += bitCount(0, set.wordsInUse);\n+            } else {\n+                super.andNot(set);\n+                computeCardinality();\n+            }\n+\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ compare the cardinalities if obj is a NaturalsBitSet\n+        return !((obj instanceof NaturalsBitSet set) && cardinality != set.cardinality) && super.equals(obj);\n+    }\n+\n+    \/**\n+     * Cloning this {@code NaturalsBitSet} produces a new {@code NaturalsBitSet}\n+     * that is equal to it. The clone of the bit set is another bit set that has\n+     * exactly the same integers as this bit set.\n+     *\n+     * @return a clone of this bit set\n+     * @see #size()\n+     *\/\n+    @Override\n+    public NaturalsBitSet clone() {\n+        return (NaturalsBitSet) super.clone();\n+    }\n+\n+    \/**\n+     * Reconstitute the {@code NaturalsBitSet} instance from a stream (i.e.,\n+     * deserialize it).\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n+        computeCardinality();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code NaturalsBitSet}. For every\n+     * integer for which this {@code NaturalsBitSet} contains it, the decimal\n+     * representation of that integer is included in the result. Such integers are\n+     * listed in order from lowest to highest, separated by \",&nbsp;\" (a comma and a\n+     * space) and surrounded by braces, resulting in the usual mathematical notation\n+     * for a set of integers.\n+     *\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     * BitSet drPepper = new BitSet();\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(2);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(4);\n+     * drPepper.set(10);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2, 4, 10}}\".\n+     *\n+     * @return a string representation of this bit set\n+     *\/\n+    public String toString() {\n+        checkInvariants();\n+\n+        final int MAX_INITIAL_CAPACITY = Integer.MAX_VALUE - 8;\n+        \/\/ Avoid overflow in the case of a humongous cardinality\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ? 6 * cardinality + 2\n+                : MAX_INITIAL_CAPACITY;\n+        StringBuilder b = new StringBuilder(initialCapacity);\n+        b.append('{');\n+\n+        int i = nextSetBit(0);\n+        if (i != -1) {\n+            b.append(i);\n+            while (true) {\n+                if (++i < 0)\n+                    break;\n+                if ((i = nextSetBit(i)) < 0)\n+                    break;\n+                int endOfRun = nextClearBit(i);\n+                do {\n+                    b.append(\", \").append(i);\n+                } while (++i != endOfRun);\n+            }\n+        }\n+\n+        b.append('}');\n+        return b.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/NaturalsBitSet.java","additions":562,"deletions":0,"binary":false,"changes":562,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/**\n+ * @test\n+ * @bug 8300487\n+ * @summary test the NaturalsBitSet.and() method\n+ *\/\n+import java.util.NaturalsBitSet;\n+\n+public final class And {\n+    public static void main(String[] args) throws Exception {\n+        NaturalsBitSet a = new NaturalsBitSet();\n+        NaturalsBitSet b = new NaturalsBitSet();\n+\n+        a.set(0);\n+        a.set(70);\n+        b.set(40);\n+        a.and(b);\n+        if (a.length() != 0)\n+            throw new RuntimeException(\"Incorrect length after and().\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/And.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/**\n+ * @test\n+ * @bug 8300487\n+ * @run main\/othervm -Xms250m HugeToString\n+ *\/\n+\n+import java.util.NaturalsBitSet;\n+\n+public final class HugeToString {\n+\n+    public static void main(String[] args) {\n+        NaturalsBitSet bs = new NaturalsBitSet(500_000_000);\n+        bs.flip(0, 500_000_000);\n+        try {\n+            bs.toString();\n+        } catch (OutOfMemoryError expected) {\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/HugeToString.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Test import\/export constructors and methods\n+ * @author Martin Buchholz\n+ * @key randomness\n+ *\/\n+\n+import java.nio.*;\n+import java.util.*;\n+\n+public class ImportExport {\n+    final Random rnd = new Random();\n+\n+    void equal(byte[] x, byte[] y) {\n+        check(Arrays.equals(x, y));\n+    }\n+\n+    void equal(long[] x, long[] y) {\n+        check(Arrays.equals(x, y));\n+    }\n+\n+    void equal(byte[] bytes, NaturalsBitSet s) {\n+        equal(s, NaturalsBitSet.valueOf(bytes));\n+        equal(s, NaturalsBitSet.valueOf(ByteBuffer.wrap(bytes)));\n+        equal(s, NaturalsBitSet.valueOf(\n+                  ByteBuffer.wrap(\n+                      Arrays.copyOf(bytes, bytes.length + 8 + rnd.nextInt(8)))\n+                  .order(ByteOrder.LITTLE_ENDIAN)\n+                  .asLongBuffer()));\n+    }\n+\n+    void checkEmptyBitSet(NaturalsBitSet s) {\n+        equal(s.toByteArray(), new byte[0]);\n+        equal(s.toLongArray(), new long[0]);\n+        check(s.isEmpty());\n+    }\n+\n+    void test(String[] args) throws Throwable {\n+        for (int i = 0; i < 17; i++) {\n+            byte[] bytes = new byte[i];\n+            NaturalsBitSet s = new NaturalsBitSet();\n+            equal(bytes, s);\n+            equal(NaturalsBitSet.valueOf(bytes).toByteArray(), new byte[0]);\n+            if (i > 0) {\n+                int k = rnd.nextInt(i);\n+                for (int j = 0; j < 8; j++) {\n+                    bytes[k] |= 1 << j;\n+                    s.set(8*k+j);\n+                    equal(bytes, s);\n+                    byte[] expected = new byte[k+1]; expected[k] = bytes[k];\n+                    equal(NaturalsBitSet.valueOf(bytes).toByteArray(), expected);\n+                    ByteBuffer bb = ByteBuffer.wrap(bytes);\n+                    bb.position(k);\n+                    equal(NaturalsBitSet.valueOf(bb).toByteArray(),\n+                          new byte[]{bytes[k]});\n+                }\n+            }\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            byte[] bytes = new byte[rnd.nextInt(17)];\n+            for (int j = 0; j < bytes.length; j++)\n+                bytes[j] = (byte) rnd.nextInt(0x100);\n+            NaturalsBitSet s = NaturalsBitSet.valueOf(bytes);\n+            byte[] expected = s.toByteArray();\n+            equal(expected.length, (s.length()+7)\/8);\n+            if (bytes.length == 0)\n+                continue;\n+            if (expected.length > 0)\n+                check(expected[expected.length-1] != 0);\n+            if (bytes[bytes.length-1] != 0)\n+                equal(bytes, expected);\n+            int n = rnd.nextInt(8 * bytes.length);\n+            equal(s.get(n), ((bytes[n\/8] & (1<<(n%8))) != 0));\n+        }\n+\n+        for (int i = 0; i < 3; i++) {\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new byte[i]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(ByteBuffer.wrap(new byte[i])));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new byte[i*64]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(ByteBuffer.wrap(new byte[i*64])));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(new long[i]));\n+            checkEmptyBitSet(NaturalsBitSet.valueOf(LongBuffer.wrap(new long[i])));\n+        }\n+\n+        {\n+            long[] longs = new long[rnd.nextInt(10)];\n+            for (int i = 0; i < longs.length; i++)\n+                longs[i] = rnd.nextLong();\n+            LongBuffer b1 = LongBuffer.wrap(longs);\n+            LongBuffer b2 = LongBuffer.allocate(longs.length + 10);\n+            for (int i = 0; i < b2.limit(); i++)\n+                b2.put(i, rnd.nextLong());\n+            int beg = rnd.nextInt(10);\n+            b2.position(beg);\n+            b2.put(longs);\n+            b2.limit(b2.position());\n+            b2.position(beg);\n+            NaturalsBitSet s1 = NaturalsBitSet.valueOf(longs);\n+            NaturalsBitSet s2 = NaturalsBitSet.valueOf(b1);\n+            NaturalsBitSet s3 = NaturalsBitSet.valueOf(b2);\n+            equal(s1, s2);\n+            equal(s1, s3);\n+            if (longs.length > 0 && longs[longs.length -1] != 0) {\n+                equal(longs, s1.toLongArray());\n+                equal(longs, s2.toLongArray());\n+                equal(longs, s3.toLongArray());\n+            }\n+            for (int i = 0; i < 64 * longs.length; i++) {\n+                equal(s1.get(i), ((longs [i\/64] & (1L<<(i%64))) != 0));\n+                equal(s2.get(i), ((b1.get(i\/64) & (1L<<(i%64))) != 0));\n+                equal(s3.get(i), ((b2.get(b2.position()+i\/64) & (1L<<(i%64))) != 0));\n+            }\n+        }\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    volatile int passed = 0, failed = 0;\n+    void pass() {passed++;}\n+    void fail() {failed++; Thread.dumpStack();}\n+    void fail(String msg) {System.err.println(msg); fail();}\n+    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    void check(boolean cond) {if (cond) pass(); else fail();}\n+    void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        new ImportExport().instanceMain(args);}\n+    void instanceMain(String[] args) throws Throwable {\n+        try {test(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/ImportExport.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Repeatedly OR NaturalsBitSets; No OutOfMemoryException should result\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * This is a simple test class that repeatedly ORs two\n+ * NaturalsBitSets of unequal size together. Previously this\n+ * caused an exponential growth in the memory underlying\n+ * the BitSets quickly using all available memory\n+ *\/\n+public class MemoryLeak {\n+\n+   public static void main(String[] args) {\n+\n+        \/\/create 2 test bitsets\n+        NaturalsBitSet setOne = new NaturalsBitSet();\n+        NaturalsBitSet setTwo = new NaturalsBitSet();\n+\n+        setOne.set(64);\n+        setTwo.set(129);\n+\n+        \/\/test for bug #4091185\n+        \/\/exponential set growth causing memory depletion\n+        for (int i = 0; i < 50; i++) {\n+            setOne.or(setTwo);\n+            setTwo.or(setOne);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/MemoryLeak.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,961 @@\n+\/* @test\n+ * @summary Test the operation of the methods of NaturalsBitSet class\n+ * @author Mike McCloskey, Martin Buchholz\n+ * @run main\/othervm BSMethods\n+ * @key randomness\n+ *\/\n+\n+import java.util.*;\n+\n+\/**\n+ * This is a simple test class created to run tests on the BitSet class.\n+ *\n+ *\/\n+public class NBSMethods {\n+\n+    private static Random generator = new Random();\n+    private static boolean failure = false;\n+\n+    private static void fail(String diagnostic) {\n+        new Error(diagnostic).printStackTrace();\n+        failure = true;\n+    }\n+\n+    private static void check(boolean condition) {\n+        check(condition, \"something's fishy\");\n+    }\n+\n+    private static void check(boolean condition, String diagnostic) {\n+        if (! condition)\n+            fail(diagnostic);\n+    }\n+\n+    private static void checkEmpty(NaturalsBitSet s) {\n+        check(s.isEmpty(), \"isEmpty\");\n+        check(s.length() == 0, \"length\");\n+        check(s.cardinality() == 0, \"cardinality\");\n+        check(s.equals(new NaturalsBitSet())   , \"equals\");\n+        check(s.equals(new NaturalsBitSet(0))  , \"equals\");\n+        check(s.equals(new NaturalsBitSet(127)), \"equals\");\n+        check(s.equals(new NaturalsBitSet(128)), \"equals\");\n+        check(s.nextSetBit(0)   == -1, \"nextSetBit\");\n+        check(s.nextSetBit(127) == -1, \"nextSetBit\");\n+        check(s.nextSetBit(128) == -1, \"nextSetBit\");\n+        check(s.nextClearBit(0)   == 0,   \"nextClearBit\");\n+        check(s.nextClearBit(127) == 127, \"nextClearBit\");\n+        check(s.nextClearBit(128) == 128, \"nextClearBit\");\n+        check(s.toString().equals(\"{}\"), \"toString\");\n+        check(! s.get(0), \"get\");\n+    }\n+\n+    private static NaturalsBitSet makeSet(int... elts) {\n+        NaturalsBitSet s = new NaturalsBitSet();\n+        for (int elt : elts)\n+            s.set(elt);\n+        return s;\n+    }\n+\n+    private static void checkEquality(NaturalsBitSet s, NaturalsBitSet t) {\n+        checkSanity(s, t);\n+        check(s.equals(t), \"equals\");\n+        check(s.toString().equals(t.toString()), \"equal strings\");\n+        check(s.length() == t.length(), \"equal lengths\");\n+        check(s.cardinality() == t.cardinality(), \"equal cardinalities\");\n+    }\n+\n+    private static void checkSanity(NaturalsBitSet... sets) {\n+        for (NaturalsBitSet s : sets) {\n+            int len = s.length();\n+            int cardinality1 = s.cardinality();\n+            int cardinality2 = 0;\n+            for (int i = s.nextSetBit(0); i >= 0; i = s.nextSetBit(i+1)) {\n+                check(s.get(i));\n+                cardinality2++;\n+            }\n+            check(s.nextSetBit(len) == -1, \"last set bit\");\n+            check(s.nextClearBit(len) == len, \"last set bit\");\n+            check(s.isEmpty() == (len == 0), \"emptiness\");\n+            check(cardinality1 == cardinality2, \"cardinalities\");\n+            check(len <= s.size(), \"length <= size\");\n+            check(len >= 0, \"length >= 0\");\n+            check(cardinality1 >= 0, \"cardinality >= 0\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        \/\/testFlipTime();\n+\n+        \/\/ These are the single bit versions\n+        testSetGetClearFlip();\n+\n+        \/\/ Test the ranged versions\n+        testClear();\n+\n+        testFlip();\n+        testSet();\n+        testGet();\n+\n+        \/\/ BitSet interaction calls\n+        testAndNot();\n+        testAnd();\n+        testOr();\n+        testXor();\n+\n+        \/\/ Miscellaneous calls\n+        testLength();\n+        testEquals();\n+        testNextSetBit();\n+        testNextClearBit();\n+        testIntersects();\n+        testCardinality();\n+        testEmpty();\n+        testEmpty2();\n+        testToString();\n+        testLogicalIdentities();\n+\n+        if (failure)\n+            throw new RuntimeException(\"One or more BitSet failures.\");\n+    }\n+\n+    private static void report(String testName, int failCount) {\n+        System.err.println(testName+\": \" +\n+                           (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n+        if (failCount > 0)\n+            failure = true;\n+    }\n+\n+    private static void testFlipTime() {\n+        \/\/ Make a fairly random bitset\n+        NaturalsBitSet b1 = new NaturalsBitSet();\n+        b1.set(1000);\n+        long startTime = System.currentTimeMillis();\n+        for(int x=0; x<100000; x++) {\n+            b1.flip(100, 900);\n+        }\n+        long endTime = System.currentTimeMillis();\n+        long total = endTime - startTime;\n+        System.out.println(\"Multiple word flip Time \"+total);\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x=0; x<100000; x++) {\n+            b1.flip(2, 44);\n+        }\n+        endTime = System.currentTimeMillis();\n+        total = endTime - startTime;\n+        System.out.println(\"Single word flip Time \"+total);\n+    }\n+\n+    private static void testNextSetBit() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            NaturalsBitSet testSet = new NaturalsBitSet();\n+            int[] history = new int[numberOfSetBits];\n+\n+            \/\/ Set some random bits and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                nextBitToSet += generator.nextInt(30)+1;\n+                history[x] = nextBitToSet;\n+                testSet.set(nextBitToSet);\n+            }\n+\n+            \/\/ Verify their retrieval using nextSetBit()\n+            int historyIndex = 0;\n+            for(int x=testSet.nextSetBit(0); x>=0; x=testSet.nextSetBit(x+1)) {\n+                if (x != history[historyIndex++])\n+                    failCount++;\n+            }\n+\n+            checkSanity(testSet);\n+        }\n+\n+        report(\"NextSetBit                  \", failCount);\n+    }\n+\n+    private static void testNextClearBit() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b = new NaturalsBitSet(256);\n+            int[] history = new int[10];\n+\n+            \/\/ Set all the bits\n+            for (int x=0; x<256; x++)\n+                b.set(x);\n+\n+            \/\/ Clear some random bits and remember them\n+            int nextBitToClear = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToClear += generator.nextInt(24)+1;\n+                history[x] = nextBitToClear;\n+                b.clear(nextBitToClear);\n+            }\n+\n+            \/\/ Verify their retrieval using nextClearBit()\n+            int historyIndex = 0;\n+            for(int x=b.nextClearBit(0); x<256; x=b.nextClearBit(x+1)) {\n+                if (x != history[historyIndex++])\n+                    failCount++;\n+            }\n+\n+            checkSanity(b);\n+        }\n+\n+        \/\/ regression test for 4350178\n+        NaturalsBitSet bs  = new NaturalsBitSet();\n+        if (bs.nextClearBit(0) != 0)\n+                failCount++;\n+        for (int i = 0; i < 64; i++) {\n+            bs.set(i);\n+            if (bs.nextClearBit(0) != i+1)\n+                failCount++;\n+        }\n+\n+        checkSanity(bs);\n+\n+        report(\"NextClearBit                \", failCount);\n+    }\n+\n+    private static void testSetGetClearFlip() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet testSet = new NaturalsBitSet();\n+            HashSet<Integer> history = new HashSet<Integer>();\n+\n+            \/\/ Set a random number of bits in random places\n+            \/\/ up to a random maximum\n+            int nextBitToSet = 0;\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                nextBitToSet = generator.nextInt(highestPossibleSetBit);\n+                history.add(nextBitToSet);\n+                testSet.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure each bit is set appropriately\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Clear the bits\n+            Iterator<Integer> setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = setBitIterator.next();\n+                testSet.clear(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were cleared\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            \/\/ Set them with set(int, boolean)\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = setBitIterator.next();\n+                testSet.set(setBit.intValue(), true);\n+            }\n+\n+            \/\/ Make sure each bit is set appropriately\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Clear them with set(int, boolean)\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.set(setBit.intValue(), false);\n+            }\n+\n+            \/\/ Verify they were cleared\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            \/\/ Flip them on\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.flip(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were flipped\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                if (testSet.get(x) != history.contains(x))\n+                    failCount++;\n+            }\n+\n+            \/\/ Flip them off\n+            setBitIterator = history.iterator();\n+            while (setBitIterator.hasNext()) {\n+                Integer setBit = (Integer)setBitIterator.next();\n+                testSet.flip(setBit.intValue());\n+            }\n+\n+            \/\/ Verify they were flipped\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                if (testSet.get(x))\n+                    failCount++;\n+            if(testSet.length() != 0)\n+                failCount++;\n+\n+            checkSanity(testSet);\n+        }\n+\n+        report(\"SetGetClearFlip             \", failCount);\n+    }\n+\n+    private static void testAndNot() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set some random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ andNot the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.andNot(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 & (!bit2))))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        report(\"AndNot                      \", failCount);\n+    }\n+\n+    private static void testAnd() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ And the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.and(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 & bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        \/\/ `and' that happens to clear the last word\n+        NaturalsBitSet b4 = makeSet(2, 127);\n+        b4.and(makeSet(2, 64));\n+        checkSanity(b4);\n+        if (!(b4.equals(makeSet(2))))\n+            failCount++;\n+\n+        report(\"And                         \", failCount);\n+    }\n+\n+    private static void testOr() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+            int[] history = new int[20];\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                history[x] = nextBitToSet;\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                history[x] = nextBitToSet;\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Or the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.or(b2);\n+\n+            \/\/ Verify the set bits of b3 from the history\n+            int historyIndex = 0;\n+            for(int x=0; x<20; x++) {\n+                if (!b3.get(history[x]))\n+                    failCount++;\n+            }\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 | bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+        }\n+\n+        report(\"Or                          \", failCount);\n+    }\n+\n+    private static void testXor() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set and remember them\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++)\n+                b1.set(generator.nextInt(255));\n+\n+            \/\/ Set more random bits in second set and remember them\n+            for (int x=10; x<20; x++)\n+                b2.set(generator.nextInt(255));\n+\n+            \/\/ Xor the sets together\n+            NaturalsBitSet b3 = b1.clone();\n+            b3.xor(b2);\n+\n+            \/\/ Examine each bit of b3 for errors\n+            for(int x=0; x<256; x++) {\n+                boolean bit1 = b1.get(x);\n+                boolean bit2 = b2.get(x);\n+                boolean bit3 = b3.get(x);\n+                if (!(bit3 == (bit1 ^ bit2)))\n+                    failCount++;\n+            }\n+            checkSanity(b1, b2, b3);\n+            b3.xor(b3); checkEmpty(b3);\n+        }\n+\n+        \/\/ xor that happens to clear the last word\n+        NaturalsBitSet b4 = makeSet(2, 64, 127);\n+        b4.xor(makeSet(64, 127));\n+        checkSanity(b4);\n+        if (!(b4.equals(makeSet(2))))\n+            failCount++;\n+\n+        report(\"Xor                         \", failCount);\n+    }\n+\n+    private static void testEquals() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            \/\/ Create BitSets of different sizes\n+            NaturalsBitSet b1 = new NaturalsBitSet(generator.nextInt(1000)+1);\n+            NaturalsBitSet b2 = new NaturalsBitSet(generator.nextInt(1000)+1);\n+\n+            \/\/ Set some random bits\n+            int nextBitToSet = 0;\n+            for (int x=0; x<10; x++) {\n+                nextBitToSet += generator.nextInt(50)+1;\n+                b1.set(nextBitToSet);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Verify their equality despite different storage sizes\n+            if (!b1.equals(b2))\n+                failCount++;\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Equals                      \", failCount);\n+    }\n+\n+    private static void testLength() {\n+        int failCount = 0;\n+\n+        \/\/ Test length after set\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            int highestSetBit = 0;\n+\n+            for(int x=0; x<100; x++) {\n+                int nextBitToSet = generator.nextInt(255);\n+                if (nextBitToSet > highestSetBit)\n+                    highestSetBit = nextBitToSet;\n+                b1.set(nextBitToSet);\n+                if (b1.length() != highestSetBit + 1)\n+                    failCount++;\n+            }\n+            checkSanity(b1);\n+        }\n+\n+        \/\/ Test length after flip\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            for(int x=0; x<100; x++) {\n+                \/\/ Flip a random range twice\n+                int rangeStart = generator.nextInt(100);\n+                int rangeEnd = rangeStart + generator.nextInt(100);\n+                b1.flip(rangeStart);\n+                b1.flip(rangeStart);\n+                if (b1.length() != 0)\n+                    failCount++;\n+                b1.flip(rangeStart, rangeEnd);\n+                b1.flip(rangeStart, rangeEnd);\n+                if (b1.length() != 0)\n+                    failCount++;\n+            }\n+            checkSanity(b1);\n+        }\n+\n+        \/\/ Test length after or\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+            int bit1 = generator.nextInt(100);\n+            int bit2 = generator.nextInt(100);\n+            int highestSetBit = (bit1 > bit2) ? bit1 : bit2;\n+            b1.set(bit1);\n+            b2.set(bit2);\n+            b1.or(b2);\n+            if (b1.length() != highestSetBit + 1)\n+                failCount++;\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Length                      \", failCount);\n+    }\n+\n+    private static void testClear() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Clear out a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the clear(int, int) call on b1\n+            b1.clear(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.clear(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"rangeStart = \" + rangeStart);\n+                System.out.println(\"rangeEnd = \" + rangeEnd);\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Clear                       \", failCount);\n+    }\n+\n+    private static void testSet() {\n+        int failCount = 0;\n+\n+        \/\/ Test set(int, int)\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Set a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the set(int, int) call on b1\n+            b1.set(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.set(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"Set 1\");\n+                System.out.println(\"rangeStart = \" + rangeStart);\n+                System.out.println(\"rangeEnd = \" + rangeEnd);\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        \/\/ Test set(int, int, boolean)\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+            boolean setOrClear = generator.nextBoolean();\n+\n+            \/\/ Set a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the set(int, int, boolean) call on b1\n+            b1.set(rangeStart, rangeEnd, setOrClear);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.set(x, setOrClear);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2)) {\n+                System.out.println(\"Set 2\");\n+                System.out.println(\"b1 = \" + b1);\n+                System.out.println(\"b2 = \" + b2);\n+                failCount++;\n+            }\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Set                         \", failCount);\n+    }\n+\n+    private static void testFlip() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            NaturalsBitSet b2 = b1.clone();\n+\n+            \/\/ Flip a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            \/\/ Use the flip(int, int) call on b1\n+            b1.flip(rangeStart, rangeEnd);\n+\n+            \/\/ Use a loop on b2\n+            for (int x=rangeStart; x<rangeEnd; x++)\n+                b2.flip(x);\n+\n+            \/\/ Verify their equality\n+            if (!b1.equals(b2))\n+                failCount++;\n+            checkEquality(b1,b2);\n+        }\n+\n+        report(\"Flip                        \", failCount);\n+    }\n+\n+    private static void testGet() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<1000; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+\n+            \/\/ Make a fairly random bitset\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++)\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+\n+            \/\/ Get a new set from a random range\n+            int rangeStart = generator.nextInt(100);\n+            int rangeEnd = rangeStart + generator.nextInt(100);\n+\n+            NaturalsBitSet b2 = b1.get(rangeStart, rangeEnd);\n+\n+            NaturalsBitSet b3 = new NaturalsBitSet();\n+            for(int x=rangeStart; x<rangeEnd; x++)\n+                b3.set(x-rangeStart, b1.get(x));\n+\n+            \/\/ Verify their equality\n+            if (!b2.equals(b3)) {\n+                System.out.println(\"start=\"+rangeStart);\n+                System.out.println(\"end=\"+rangeEnd);\n+                System.out.println(b1);\n+                System.out.println(b2);\n+                System.out.println(b3);\n+                failCount++;\n+            }\n+            checkEquality(b2,b3);\n+        }\n+\n+        report(\"Get                         \", failCount);\n+    }\n+\n+\n+    private static void testIntersects() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+            NaturalsBitSet b2 = new NaturalsBitSet(256);\n+\n+            \/\/ Set some random bits in first set\n+            int nextBitToSet = 0;\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b1.set(nextBitToSet);\n+            }\n+\n+            \/\/ Set more random bits in second set\n+            for (int x=0; x<30; x++) {\n+                nextBitToSet = generator.nextInt(255);\n+                b2.set(nextBitToSet);\n+            }\n+\n+            \/\/ Make sure they intersect\n+            nextBitToSet = generator.nextInt(255);\n+            b1.set(nextBitToSet);\n+            b2.set(nextBitToSet);\n+\n+            if (!b1.intersects(b2))\n+                failCount++;\n+\n+            \/\/ Remove the common set bits\n+            b1.andNot(b2);\n+\n+            \/\/ Make sure they don't intersect\n+            if (b1.intersects(b2))\n+                failCount++;\n+\n+            checkSanity(b1, b2);\n+        }\n+\n+        report(\"Intersects                  \", failCount);\n+    }\n+\n+    private static void testCardinality() {\n+        int failCount = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            NaturalsBitSet b1 = new NaturalsBitSet(256);\n+\n+            \/\/ Set a random number of increasing bits\n+            int nextBitToSet = 0;\n+            int iterations = generator.nextInt(20)+1;\n+            for (int x=0; x<iterations; x++) {\n+                nextBitToSet += generator.nextInt(20)+1;\n+                b1.set(nextBitToSet);\n+            }\n+\n+            if (b1.cardinality() != iterations) {\n+                System.out.println(\"Iterations is \"+iterations);\n+                System.out.println(\"Cardinality is \"+b1.cardinality());\n+                failCount++;\n+            }\n+\n+            checkSanity(b1);\n+        }\n+\n+        report(\"Cardinality                 \", failCount);\n+    }\n+\n+    private static void testEmpty() {\n+        int failCount = 0;\n+\n+        NaturalsBitSet b1 = new NaturalsBitSet();\n+        if (!b1.isEmpty())\n+            failCount++;\n+\n+        int nextBitToSet = 0;\n+        int numberOfSetBits = generator.nextInt(100) + 1;\n+        int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+        for (int x=0; x<numberOfSetBits; x++) {\n+            nextBitToSet = generator.nextInt(highestPossibleSetBit);\n+            b1.set(nextBitToSet);\n+            if (b1.isEmpty())\n+                failCount++;\n+            b1.clear(nextBitToSet);\n+            if (!b1.isEmpty())\n+                failCount++;\n+        }\n+\n+        report(\"Empty                       \", failCount);\n+    }\n+\n+    private static void testEmpty2() {\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.set(100); t.clear(3,600); checkEmpty(t);}\n+        checkEmpty(new NaturalsBitSet(0));\n+        checkEmpty(new NaturalsBitSet(342));\n+        NaturalsBitSet s = new NaturalsBitSet(0);\n+        checkEmpty(s);\n+        s.clear(92);      checkEmpty(s);\n+        s.clear(127,127); checkEmpty(s);\n+        s.set(127,127);   checkEmpty(s);\n+        s.set(128,128);   checkEmpty(s);\n+        NaturalsBitSet empty = new NaturalsBitSet();\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and   (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.or    (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.xor   (empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.andNot(empty);     checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and   (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.or    (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.xor   (t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.andNot(t);         checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(1));   checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(127)); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.and(makeSet(128)); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); t.flip(7);t.flip(7); checkEmpty(t);}\n+        {NaturalsBitSet t = new NaturalsBitSet(); checkEmpty(t.get(200,300));}\n+        {NaturalsBitSet t = makeSet(2,5); check(t.get(2,6).equals(makeSet(0,3)),\"\");}\n+    }\n+\n+    private static void testToString() {\n+        check(new NaturalsBitSet().toString().equals(\"{}\"));\n+        check(makeSet(2,3,42,43,234).toString().equals(\"{2, 3, 42, 43, 234}\"));\n+\n+        final long MB = 1024*1024;\n+        if (Runtime.getRuntime().maxMemory() >= 512*MB) {\n+            \/\/ only run it if we have enough memory\n+            try {\n+                check(makeSet(Integer.MAX_VALUE-1).toString().equals(\n+                        \"{\" + (Integer.MAX_VALUE-1) + \"}\"));\n+                check(makeSet(Integer.MAX_VALUE).toString().equals(\n+                        \"{\" + Integer.MAX_VALUE + \"}\"));\n+                check(makeSet(0, 1, Integer.MAX_VALUE-1, Integer.MAX_VALUE).toString().equals(\n+                        \"{0, 1, \" + (Integer.MAX_VALUE-1) + \", \" + Integer.MAX_VALUE + \"}\"));\n+            } catch (IndexOutOfBoundsException exc) {\n+                fail(\"toString() with indices near MAX_VALUE\");\n+            }\n+        }\n+    }\n+\n+    private static void testLogicalIdentities() {\n+        int failCount = 0;\n+\n+        \/\/ Verify that (!b1)|(!b2) == !(b1&b2)\n+        for (int i=0; i<50; i++) {\n+            \/\/ Construct two fairly random bitsets\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+            NaturalsBitSet b2 = new NaturalsBitSet();\n+\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+                b2.set(generator.nextInt(highestPossibleSetBit));\n+            }\n+\n+            NaturalsBitSet b3 = b1.clone();\n+            NaturalsBitSet b4 = b2.clone();\n+\n+            for (int x=0; x<highestPossibleSetBit; x++) {\n+                b1.flip(x);\n+                b2.flip(x);\n+            }\n+            b1.or(b2);\n+            b3.and(b4);\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b3.flip(x);\n+            if (!b1.equals(b3))\n+                failCount++;\n+            checkSanity(b1, b2, b3, b4);\n+        }\n+\n+        \/\/ Verify that (b1&(!b2)|(b2&(!b1) == b1^b2\n+        for (int i=0; i<50; i++) {\n+            \/\/ Construct two fairly random bitsets\n+            NaturalsBitSet b1 = new NaturalsBitSet();\n+            NaturalsBitSet b2 = new NaturalsBitSet();\n+\n+            int numberOfSetBits = generator.nextInt(100) + 1;\n+            int highestPossibleSetBit = generator.nextInt(1000) + 1;\n+\n+            for (int x=0; x<numberOfSetBits; x++) {\n+                b1.set(generator.nextInt(highestPossibleSetBit));\n+                b2.set(generator.nextInt(highestPossibleSetBit));\n+            }\n+\n+            NaturalsBitSet b3 = b1.clone();\n+            NaturalsBitSet b4 = b2.clone();\n+            NaturalsBitSet b5 = b1.clone();\n+            NaturalsBitSet b6 = b2.clone();\n+\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b2.flip(x);\n+            b1.and(b2);\n+            for (int x=0; x<highestPossibleSetBit; x++)\n+                b3.flip(x);\n+            b3.and(b4);\n+            b1.or(b3);\n+            b5.xor(b6);\n+            if (!b1.equals(b5))\n+                failCount++;\n+            checkSanity(b1, b2, b3, b4, b5, b6);\n+        }\n+        report(\"Logical Identities          \", failCount);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/NBSMethods.java","additions":961,"deletions":0,"binary":false,"changes":961,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Test previousClearBit, previousSetBit\n+ * @key randomness\n+ *\/\n+\n+import java.util.*;\n+\n+public class PreviousBits {\n+\n+    void testHashCode(final NaturalsBitSet s) {\n+        long h = 1234;\n+        long[] words = s.toLongArray();\n+        for (int i = words.length; --i >= 0; )\n+            h ^= words[i] * (i + 1);\n+        equal((int)((h >> 32) ^ h), s.hashCode());\n+    }\n+\n+    void testOutOfBounds(final NaturalsBitSet s) {\n+        THROWS(IndexOutOfBoundsException.class,\n+               new F(){void f(){ s.previousSetBit(-2);}},\n+               new F(){void f(){ s.previousClearBit(-2);}},\n+               new F(){void f(){ s.previousSetBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.previousClearBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.nextSetBit(-1);}},\n+               new F(){void f(){ s.nextClearBit(-1);}},\n+               new F(){void f(){ s.nextSetBit(Integer.MIN_VALUE);}},\n+               new F(){void f(){ s.nextClearBit(Integer.MIN_VALUE);}});\n+    }\n+\n+    void test(String[] args) throws Throwable {\n+        final NaturalsBitSet s = new NaturalsBitSet();\n+\n+        \/\/ Test empty bitset\n+        testOutOfBounds(s);\n+        testHashCode(s);\n+\n+        for (int i = -1; i < 93;) {\n+            equal(-1, s.previousSetBit(i));\n+            equal( i, s.previousClearBit(i));\n+            i++;\n+            equal(-1, s.nextSetBit(i));\n+            equal( i, s.nextClearBit(i));\n+        }\n+\n+        \/\/ Test \"singleton\" bitsets\n+        for (int j = 0; j < 161; j++) {\n+            s.clear();\n+            s.set(j);\n+            testOutOfBounds(s);\n+            testHashCode(s);\n+\n+            for (int i = -1; i < j; i++) {\n+                equal(-1, s.previousSetBit(i));\n+                equal( i, s.previousClearBit(i));\n+                if (i >= 0) {\n+                    equal(j, s.nextSetBit(i));\n+                    equal(i, s.nextClearBit(i));\n+                }\n+            }\n+\n+            equal(j,   s.previousSetBit(j));\n+            equal(j-1, s.previousClearBit(j));\n+            equal(j,   s.nextSetBit(j));\n+            equal(j+1, s.nextClearBit(j));\n+\n+            for (int i = j+1; i < j+100; i++) {\n+                equal(j, s.previousSetBit(i));\n+                equal(i, s.previousClearBit(i));\n+                equal(-1, s.nextSetBit(i));\n+                equal(i, s.nextClearBit(i));\n+            }\n+        }\n+\n+        \/\/ set even bits\n+        s.clear();\n+        for (int i = 0; i <= 128; i+=2)\n+            s.set(i);\n+        testHashCode(s);\n+        for (int i = 1; i <= 128; i++) {\n+            equal(s.previousSetBit(i),\n+                  ((i & 1) == 0) ? i : i - 1);\n+            equal(s.previousClearBit(i),\n+                  ((i & 1) == 0) ? i - 1 : i);\n+        }\n+\n+        \/\/ set odd bits as well\n+        for (int i = 1; i <= 128; i+=2)\n+            s.set(i);\n+        testHashCode(s);\n+        for (int i = 1; i <= 128; i++) {\n+            equal(s.previousSetBit(i), i);\n+            equal(s.previousClearBit(i), -1);\n+        }\n+\n+        \/\/ Test loops documented in javadoc\n+        Random rnd = new Random();\n+        s.clear();\n+        for (int i = 0; i < 10; i++)\n+            s.set(rnd.nextInt(1066));\n+        List<Integer> down = new ArrayList<Integer>();\n+        for (int i = s.length(); (i = s.previousSetBit(i-1)) >= 0; )\n+            down.add(i);\n+        List<Integer> up = new ArrayList<Integer>();\n+        for (int i = s.nextSetBit(0); i >= 0; i = s.nextSetBit(i+1))\n+            up.add(i);\n+        Collections.reverse(up);\n+        equal(up, down);\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    volatile int passed = 0, failed = 0;\n+    void pass() {passed++;}\n+    void fail() {failed++; Thread.dumpStack();}\n+    void fail(String msg) {System.err.println(msg); fail();}\n+    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    void check(boolean cond) {if (cond) pass(); else fail();}\n+    void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        new PreviousBits().instanceMain(args);}\n+    void instanceMain(String[] args) throws Throwable {\n+        try {test(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    abstract class F {abstract void f() throws Throwable;}\n+    void THROWS(Class<? extends Throwable> k, F... fs) {\n+        for (F f : fs)\n+            try {f.f(); fail(\"Expected \" + k.getName() + \" not thrown\");}\n+            catch (Throwable t) {\n+                if (k.isAssignableFrom(t.getClass())) pass();\n+                else unexpected(t);}}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/PreviousBits.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * @test\n+ * @bug 8300487\n+ * @summary Check capacity management\n+ * @author Martin Buchholz\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class StickySize {\n+    static void equalClones(NaturalsBitSet s, int expectedSize) {\n+        equal(expectedSize, s.clone().size());\n+        equal(expectedSize, serialClone(s).size());\n+        equal(expectedSize, s.size());\n+        equal(s.clone(), serialClone(s));\n+    }\n+\n+    private static void realMain(String[] args) {\n+        NaturalsBitSet s;\n+\n+        s = new NaturalsBitSet();       \/\/ non-sticky\n+        equal(s.size(), 64);\n+        equalClones(s, 0);\n+        s.set(3*64);\n+        s.set(7*64);\n+        equal(s.size(), 8*64);\n+        equalClones(s, 8*64);\n+        s.clear(7*64);\n+        equal(s.size(), 8*64);\n+        equalClones(s, 4*64);\n+\n+        s = new NaturalsBitSet(8*64);   \/\/ sticky\n+        equalClones(s, 8*64);\n+        s.set(3*64);\n+        s.set(7*64);\n+        equalClones(s, 8*64);\n+        s.clear(7*64);\n+        equalClones(s, 8*64);\n+        equalClones(s.clone(), 8*64);\n+        equalClones(serialClone(s), 8*64);\n+        s.set(17*64);           \/\/ Expand beyond sticky size\n+        equalClones(s, 18*64);\n+        s.clear(17*64);\n+        equalClones(s, 4*64);\n+    }\n+\n+    \/\/--------------------- Infrastructure ---------------------------\n+    static volatile int passed = 0, failed = 0;\n+    static void pass() {passed++;}\n+    static void fail() {failed++; Thread.dumpStack();}\n+    static void fail(String msg) {System.out.println(msg); fail();}\n+    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n+    static void check(boolean cond) {if (cond) pass(); else fail();}\n+    static void equal(Object x, Object y) {\n+        if (x == null ? y == null : x.equals(y)) pass();\n+        else fail(x + \" not equal to \" + y);}\n+    public static void main(String[] args) throws Throwable {\n+        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n+        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n+        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    static byte[] serializedForm(Object obj) {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            new ObjectOutputStream(baos).writeObject(obj);\n+            return baos.toByteArray();\n+        } catch (IOException e) { throw new RuntimeException(e); }}\n+    static Object readObject(byte[] bytes)\n+        throws IOException, ClassNotFoundException {\n+        InputStream is = new ByteArrayInputStream(bytes);\n+        return new ObjectInputStream(is).readObject();}\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serialClone(T obj) {\n+        try { return (T) readObject(serializedForm(obj)); }\n+        catch (Exception e) { throw new RuntimeException(e); }}\n+}\n","filename":"test\/jdk\/java\/util\/NaturalsBitSet\/StickySize.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}