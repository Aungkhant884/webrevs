{"files":[{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230119_192355.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+-g\n+-Xlint:all\n+-source\n+21\n+-target\n+21\n+-implicit:none\n+-Xprefer:source\n+-XDignore.symbol.file=true\n+-encoding\n+ascii\n+-Werror\n+-Xdoclint:all\/protected\n+-Xdoclint\/package:java.*,javax.*\n+-XDstringConcat=inline\n+--module-source-path\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/gensrc\/*:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/linux\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/unix\/classes:\/home\/kali\/Documents\/GitHub\/jdk\/src\/*\/share\/classes\n+--module-path\n+\n+--system\n+none\n+-classpath\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/buildtools\/depend\n+\"-Xplugin:depend \/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_pubapi\"\n+-XDinternalAPIPath=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_internalapi\n+-XDLOG_LEVEL=warn\n+-XDmodifiedInputs=\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.modfiles.fixed\n+-d\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\n+-h\n+\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/support\/headers.java.base.tmp\n+@\/home\/kali\/Documents\/GitHub\/jdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\/_the.java.base_batch.filelist\n","filename":"make\/javac.20230120_161035.args","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n+    static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n@@ -94,1 +94,1 @@\n-    private long[] words;\n+    long[] words;\n@@ -99,7 +99,1 @@\n-    private transient int wordsInUse = 0;\n-    \n-    \/**\n-     * The number of bits set to {@code true} in this {@code BitSet}.\n-     * @since  21\n-     *\/\n-    private transient int cardinality = 0;\n+    transient int wordsInUse = 0;\n@@ -111,1 +105,1 @@\n-    private transient boolean sizeIsSticky = false;\n+    transient boolean sizeIsSticky = false;\n@@ -120,1 +114,1 @@\n-    private static int wordIndex(int bitIndex) {\n+    static int wordIndex(int bitIndex) {\n@@ -127,1 +121,1 @@\n-    private void checkInvariants() {\n+    void checkInvariants() {\n@@ -131,1 +125,0 @@\n-        assert(cardinality >= 0 && cardinality -1 <= length() - 1); \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n@@ -139,1 +132,1 @@\n-    private void recalculateWordsInUse() {\n+    void recalculateWordsInUse() {\n@@ -142,5 +135,2 @@\n-        for (i = wordsInUse-1; i >= 0; i--)\n-            if (words[i] != 0)\n-                break;\n-\n-        wordsInUse = i+1; \/\/ The new logical size\n+        for (i = wordsInUse - 1; i >= 0 && words[i] == 0; i--);\n+        wordsInUse = i + 1; \/\/ The new logical size\n@@ -181,1 +171,0 @@\n-     * The last word (if there is one) must be non-zero.\n@@ -183,1 +172,1 @@\n-    private BitSet(long[] words) {\n+    BitSet(long[] words) {\n@@ -186,1 +175,2 @@\n-        computeCardinality();\n+        \/\/ Set wordsInUse correctly\n+        recalculateWordsInUse();\n@@ -190,23 +180,0 @@\n-    private void computeCardinality() {\n-        cardinality = bitCount(0, wordsInUse);\n-    }\n-\n-    \/**\n-     * Returns the number of bits set to true, starting from\n-     * startWord (inclusive) to endWord (exclusive)\n-     *\/\n-    private int bitCount(int startWord, int endWord) {\n-        int sum = 0;\n-        for (int i = startWord; i < endWord; i++)\n-            sum += bitCount(i);\n-        \n-        return sum;\n-    }\n-\n-    \/**\n-     * Returns the number of bits set to true at the specified word\n-     *\/\n-    private int bitCount(int wordIndex) {\n-        return Long.bitCount(words[wordIndex]);\n-    }\n-\n@@ -230,0 +197,4 @@\n+        return new BitSet(getWords(longs));\n+    }\n+    \n+    static long[] getWords(long[] longs) {\n@@ -231,3 +202,2 @@\n-        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--)\n-            ;\n-        return new BitSet(Arrays.copyOf(longs, n));\n+        for (n = longs.length; n > 0 && longs[n - 1] == 0; n--);\n+        return Arrays.copyOf(longs, n);\n@@ -255,0 +225,4 @@\n+        return new BitSet(getWords(lb));\n+    }\n+    \n+    static long[] getWords(LongBuffer lb) {\n@@ -259,0 +233,1 @@\n+        \n@@ -261,1 +236,1 @@\n-        return new BitSet(words);\n+        return words;\n@@ -281,1 +256,5 @@\n-        return BitSet.valueOf(ByteBuffer.wrap(bytes));\n+        return BitSet.valueOf(getWords(bytes));\n+    }\n+    \n+    static long[] getWords(byte[] bytes) {\n+        return getWords(ByteBuffer.wrap(bytes));\n@@ -303,0 +282,4 @@\n+        return new BitSet(getWords(bb));\n+    }\n+    \n+    static long[] getWords(ByteBuffer bb) {\n@@ -314,1 +297,2 @@\n-        return new BitSet(words);\n+        \n+        return words;\n@@ -418,5 +402,3 @@\n-        \n-        final long bitMask = 1L << bitIndex;\n-        words[wordIndex] ^= bitMask;\n-        cardinality += (words[wordIndex] & bitMask) != 0 ? 1 : -1;\n-        \n+\n+        words[wordIndex] ^= (1L << bitIndex);\n+\n@@ -453,1 +435,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -455,1 +436,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -459,1 +439,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -461,1 +440,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -464,2 +442,1 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n-                cardinality += BITS_PER_WORD - 2 * bitCount(i);\n+            for (int i = startWordIndex+1; i < endWordIndex; i++)\n@@ -467,1 +444,0 @@\n-            }\n@@ -470,1 +446,0 @@\n-            cardinality -= bitCount(endWordIndex);\n@@ -472,1 +447,0 @@\n-            cardinality += bitCount(endWordIndex);\n@@ -491,4 +465,0 @@\n-        final long bitMask = 1L << bitIndex;\n-        if (wordIndex < wordsInUse && (words[wordIndex] & bitMask) != 0)\n-            return;\n-        \n@@ -496,2 +466,2 @@\n-        words[wordIndex] |= bitMask; \/\/ Restores invariants\n-        cardinality++;\n+\n+        words[wordIndex] |= (1L << bitIndex); \/\/ Restores invariants\n@@ -543,1 +513,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -545,1 +514,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -549,1 +517,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -551,1 +518,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -554,2 +520,1 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n-                cardinality += BITS_PER_WORD - bitCount(i);\n+            for (int i = startWordIndex+1; i < endWordIndex; i++)\n@@ -557,1 +522,0 @@\n-            }\n@@ -560,1 +524,0 @@\n-            cardinality -= bitCount(endWordIndex);\n@@ -562,1 +525,0 @@\n-            cardinality += bitCount(endWordIndex);\n@@ -599,2 +561,1 @@\n-        final long bitMask = 1L << bitIndex;\n-        if (wordIndex >= wordsInUse || (words[wordIndex] & bitMask) == 0)\n+        if (wordIndex >= wordsInUse)\n@@ -603,2 +564,1 @@\n-        words[wordIndex] &= ~bitMask;\n-        cardinality--;\n+        words[wordIndex] &= ~(1L << bitIndex);\n@@ -641,1 +601,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -643,1 +602,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -647,1 +605,0 @@\n-            cardinality -= bitCount(startWordIndex);\n@@ -649,1 +606,0 @@\n-            cardinality += bitCount(startWordIndex);\n@@ -652,2 +608,1 @@\n-            for (int i = startWordIndex+1; i < endWordIndex; i++) {\n-                cardinality -= bitCount(i);\n+            for (int i = startWordIndex+1; i < endWordIndex; i++)\n@@ -655,1 +610,0 @@\n-            }\n@@ -658,1 +612,0 @@\n-            cardinality -= bitCount(endWordIndex);\n@@ -660,1 +613,0 @@\n-            cardinality += bitCount(endWordIndex);\n@@ -673,3 +625,2 @@\n-        Arrays.fill(words, 0, wordsInUse, 0);\n-        wordsInUse = 0;\n-        cardinality = 0;\n+        while (wordsInUse > 0)\n+            words[--wordsInUse] = 0;\n@@ -712,0 +663,4 @@\n+        return new BitSet(getWords(fromIndex, toIndex));\n+    }\n+    \n+    long[] getWords(int fromIndex, int toIndex) {\n@@ -716,1 +671,1 @@\n-        int len = length();\n+        final int len = length();\n@@ -718,1 +673,1 @@\n-        \/\/ If no set bits in range return empty bitset\n+        \/\/ If no set bits in range return empty array\n@@ -720,1 +675,1 @@\n-            return new BitSet(0);\n+            return new long[0];\n@@ -726,2 +681,1 @@\n-        BitSet result = new BitSet(toIndex - fromIndex);\n-        int targetWords = wordIndex(toIndex - fromIndex - 1) + 1;\n+        final long[] result = new long[wordIndex(toIndex - fromIndex - 1) + 1];\n@@ -729,1 +683,1 @@\n-        boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n+        final boolean wordAligned = ((fromIndex & BIT_INDEX_MASK) == 0);\n@@ -732,2 +686,2 @@\n-        for (int i = 0; i < targetWords - 1; i++, sourceIndex++)\n-            result.words[i] = wordAligned ? words[sourceIndex] :\n+        for (int i = 0; i < result.length - 1; i++, sourceIndex++)\n+            result[i] = wordAligned ? words[sourceIndex] :\n@@ -738,2 +692,2 @@\n-        long lastWordMask = WORD_MASK >>> -toIndex;\n-        result.words[targetWords - 1] =\n+        final long lastWordMask = WORD_MASK >>> -toIndex;\n+        result[result.length - 1] =\n@@ -746,7 +700,1 @@\n-\n-        \/\/ Set wordsInUse and cardinality correctly\n-        result.wordsInUse = targetWords;\n-        result.recalculateWordsInUse();\n-        result.computeCardinality();\n-        result.checkInvariants();\n-\n+        \n@@ -938,1 +886,1 @@\n-        return cardinality == 0;\n+        return wordsInUse == 0;\n@@ -957,21 +905,0 @@\n-    \/**\n-     * Returns true if all bits set to {@code true} in the specified {@code BitSet}\n-     * are also set to {@code true} in this {@code BitSet}.\n-     *\n-     * @param  set {@code BitSet} to test\n-     * @return boolean indicating whether this {@code BitSet} includes\n-     *         the specified {@code BitSet}\n-     * @since  21\n-     * @author Fabio Romano\n-     *\/\n-    public boolean includes(BitSet set) {\n-        if (set.cardinality > cardinality || set.length() > length())\n-            return false;\n-        \n-        \/\/ set.wordsInUse <= wordsInUse\n-        for (int i = 0; i < set.wordsInUse; i++)\n-            if ((~set.words[i] | words[i]) != WORD_MASK) \/\/ Perform logical (!a | b) on words in common\n-                return false;\n-        return true;\n-    }\n-\n@@ -985,1 +912,4 @@\n-        return cardinality;\n+        int sum = 0;\n+        for (int i = 0; i < wordsInUse; i++)\n+            sum += Long.bitCount(words[i]);\n+        return sum;\n@@ -1009,1 +939,0 @@\n-        computeCardinality();\n@@ -1044,1 +973,0 @@\n-        computeCardinality();\n@@ -1068,1 +996,1 @@\n-\n+        \n@@ -1087,1 +1015,0 @@\n-        computeCardinality();\n@@ -1101,2 +1028,1 @@\n-        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--) {\n-            cardinality -= bitCount(i);\n+        for (int i = Math.min(wordsInUse, set.wordsInUse) - 1; i >= 0; i--)\n@@ -1104,2 +1030,0 @@\n-            cardinality += bitCount(i);\n-        }\n@@ -1171,1 +1095,1 @@\n-        if (cardinality != set.cardinality || length() != set.length())\n+        if (length() != set.length()) \/\/ more accurate than (wordsInUse != set.wordsInUse)\n@@ -1251,1 +1175,0 @@\n-        computeCardinality();\n@@ -1283,3 +1206,5 @@\n-        \/\/ Avoid overflow in the case of a humongous cardinality\n-        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n-            6 * cardinality + 2 : MAX_INITIAL_CAPACITY;\n+        int numBits = (wordsInUse > 128) ?\n+            cardinality() : wordsInUse * BITS_PER_WORD;\n+        \/\/ Avoid overflow in the case of a humongous numBits\n+        int initialCapacity = (numBits <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ?\n+            6 * numBits + 2 : MAX_INITIAL_CAPACITY;\n@@ -1346,1 +1271,1 @@\n-                    est = cardinality;\n+                    est = cardinality();\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":75,"deletions":150,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -0,0 +1,526 @@\n+package java.util;\n+\n+import java.io.*;\n+import java.nio.*;\n+\n+\/**\n+ * This class implements a set of non-negative integers that grows as needed.\n+ * Individual integers can be checked if they are contained, added, or removed.\n+ * One {@code NaturalsBitSet} may be used to modify the contents of another\n+ * {@code NaturalsBitSet} through logical AND, logical inclusive OR, and logical\n+ * exclusive OR operations.\n+ *\n+ * <p>\n+ * Every {@code NaturalsBitSet} has a current size, which is the number of bits\n+ * of space currently in use by the bit set. Note that the size is related to\n+ * the implementation of a bit set, so it may change with implementation. The\n+ * length of a bit set relates to logical length of a bit set and is defined\n+ * independently of implementation.\n+ *\n+ * <p>\n+ * Unless otherwise noted, passing a null parameter to any of the methods in a\n+ * {@code NaturalsBitSet} will result in a {@code NullPointerException}.\n+ *\n+ * <p>\n+ * A {@code NaturalsBitSet} is not safe for multithreaded use without external\n+ * synchronization.\n+ *\n+ * @author Fabio Romano\n+ * @since 21\n+ *\/\n+public class NaturalsBitSet extends BitSet {\n+\n+    \/**\n+     * The number of bits set to {@code true} in this {@code BitSet}.\n+     *\/\n+    private transient int cardinality = 0;\n+    \n+    \/* use serialVersionUID from JDK 21 for interoperability *\/\n+    @java.io.Serial\n+    private static final long serialVersionUID = -212903409561554139L;\n+\n+    \/**\n+     * Every public method must preserve these invariants.\n+     *\/\n+    private void checkCardinality() {\n+        \/\/ avoid overflow if get(Integer.MAX_VALUE) == true\n+        assert (cardinality >= 0 && cardinality - 1 <= length() - 1);\n+    }\n+\n+    \/**\n+     * Creates a new empty {@code NaturalsBitSet}.\n+     *\/\n+    public NaturalsBitSet() {\n+        super();\n+    }\n+\n+    \/**\n+     * Creates an empty {@code NaturalsBitSet} whose initial size is large enough to\n+     * explicitly represent naturals in the range {@code 0} through {@code nbits-1}.\n+     *\n+     * @param nbits the initial size of the bit set\n+     * @throws NegativeArraySizeException if the specified initial size is negative\n+     *\/\n+    public NaturalsBitSet(int nbits) {\n+        super(nbits);\n+    }\n+\n+    \/**\n+     * Constructs a new {@code NaturalsBitSet} containing the integers in the\n+     * specified collection. It is created with an initial capacity sufficient to\n+     * contain the integers in the specified collection.\n+     *\n+     * @param c the collection whose integers are to be placed into this set\n+     * @throws NullPointerException      if the specified collection is null, or if\n+     *                                   some integer in the collection is null\n+     * @throws IndexOutOfBoundsException if some integer in the specified collection\n+     *                                   is negative\n+     *\/\n+    public NaturalsBitSet(Collection<Integer> c) {\n+        this(Collections.max(c) + 1);\n+\n+        for (int i : c)\n+            set(i);\n+    }\n+\n+    private NaturalsBitSet(long[] words) {\n+        super(words);\n+        computeCardinality();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long array.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(longs).get(n) == ((longs[n\/64] & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * longs.length}.\n+     *\n+     * <p>\n+     * This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(LongBuffer.wrap(longs))}.\n+     *\n+     * @param longs a long array containing a little-endian representation of a\n+     *              sequence of bits to be used as the initial bits of the new bit\n+     *              set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the long array\n+     *\/\n+    public static NaturalsBitSet valueOf(long[] longs) {\n+        return new NaturalsBitSet(getWords(longs));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given\n+     * long buffer between its position and limit.\n+     *\n+     * <p>\n+     * More precisely, <br>\n+     * {@code NaturalsBitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n\/64) & (1L<<(n%64))) != 0)}\n+     * <br>\n+     * for all {@code n < 64 * lb.remaining()}.\n+     *\n+     * <p>\n+     * The long buffer is not modified by this method, and no reference to the\n+     * buffer is retained by the bit set.\n+     *\n+     * @param lb a long buffer containing a little-endian representation of a\n+     *           sequence of bits between its position and limit, to be used as the\n+     *           initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(LongBuffer lb) {\n+        return new NaturalsBitSet(getWords(lb));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte array.\n+     *\n+     * <p>More precisely,\n+     * <br>{@code NaturalsBitSet.valueOf(bytes).get(n) == ((bytes[n\/8] & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n <  8 * bytes.length}.\n+     *\n+     * <p>This method is equivalent to\n+     * {@code NaturalsBitSet.valueOf(ByteBuffer.wrap(bytes))}.\n+     *\n+     * @param bytes a byte array containing a little-endian\n+     *        representation of a sequence of bits to be used as the\n+     *        initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the byte array\n+     *\/\n+    public static NaturalsBitSet valueOf(byte[] bytes) {\n+        return new NaturalsBitSet(getWords(bytes));\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} containing all the bits in the given byte\n+     * buffer between its position and limit.\n+     *\n+     * <p>More precisely,\n+     * <br>{@code NaturalsBitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n\/8) & (1<<(n%8))) != 0)}\n+     * <br>for all {@code n < 8 * bb.remaining()}.\n+     *\n+     * <p>The byte buffer is not modified by this method, and no\n+     * reference to the buffer is retained by the bit set.\n+     *\n+     * @param bb a byte buffer containing a little-endian representation\n+     *        of a sequence of bits between its position and limit, to be\n+     *        used as the initial bits of the new bit set\n+     * @return a {@code NaturalsBitSet} containing all the bits in the buffer in the\n+     *         specified range\n+     *\/\n+    public static NaturalsBitSet valueOf(ByteBuffer bb) {\n+        return new NaturalsBitSet(getWords(bb));\n+    }\n+\n+    private void computeCardinality() {\n+        cardinality = bitCount(0, wordsInUse);\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true, starting from startWord (inclusive)\n+     * to endWord (exclusive)\n+     *\/\n+    private int bitCount(int startWord, int endWord) {\n+        int sum = 0;\n+        for (int i = startWord; i < endWord; i++)\n+            sum += bitCount(i);\n+\n+        return sum;\n+    }\n+\n+    \/**\n+     * Returns the number of bits set to true at the specified word\n+     *\/\n+    private int bitCount(int wordIndex) {\n+        return Long.bitCount(words[wordIndex]);\n+    }\n+\n+    \/**\n+     * If the specified value is contained in this set, removes it; otherwise adds\n+     * it to this set.\n+     *\n+     * @param n the integer to flip\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void flip(int n) {\n+        super.flip(n);\n+        cardinality += (words[wordIndex(n)] & (1L << n)) != 0 ? 1 : -1;\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Flip each integer (as pecified in {@link #flip(int)} from the specified\n+     * {@code start} (inclusive) to the specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to flip\n+     * @param end   value after the last integer to flip\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void flip(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        super.flip(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality += (bitCount(i) << 1) - BITS_PER_WORD;\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Adds the specified integer to this set.\n+     *\n+     * @param n a non-negative integer\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void set(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex >= wordsInUse || (words[wordIndex] & (1L << n)) == 0) {\n+            super.set(n);\n+            cardinality++;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Adds the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be added\n+     * @param end   the value after the last integer to be added\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void set(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality += BITS_PER_WORD - bitCount(i);\n+\n+        super.set(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes the specified integer.\n+     *\n+     * @param n the integer to be removed\n+     * @throws IndexOutOfBoundsException if the specified integer is negative\n+     *\/\n+    @Override\n+    public void clear(int n) {\n+        final int wordIndex = wordIndex(n);\n+        if (wordIndex < wordsInUse && (words[wordIndex] & (1L << n)) != 0) {\n+            super.clear(n);\n+            cardinality--;\n+            checkCardinality();\n+        }\n+    }\n+\n+    \/**\n+     * Removes the integers from the specified {@code start} (inclusive) to the\n+     * specified {@code end} (exclusive).\n+     *\n+     * @param start the first integer to be removed\n+     * @param end   value after the last integer to be removed\n+     * @throws IndexOutOfBoundsException if {@code start} is negative, or\n+     *                                   {@code end} is negative, or {@code start}\n+     *                                   is larger than {@code end}\n+     *\/\n+    @Override\n+    public void clear(int start, int end) {\n+        final int startWord = wordIndex(start);\n+        final int endWord = wordIndex(end - 1);\n+\n+        cardinality -= bitCount(startWord);\n+        cardinality -= bitCount(endWord);\n+\n+        for (int i = startWord + 1; i < endWord; i++)\n+            cardinality -= bitCount(i);\n+\n+        super.clear(start, end);\n+\n+        cardinality += bitCount(startWord);\n+        cardinality += bitCount(endWord);\n+\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Removes all of the integers in this set.\n+     *\/\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        cardinality = 0;\n+    }\n+\n+    \/**\n+     * Returns a new {@code NaturalsBitSet} composed of bits from this\n+     * {@code BitSet} from {@code fromIndex} (inclusive) to {@code toIndex}\n+     * (exclusive).\n+     *\n+     * @param fromIndex index of the first bit to include\n+     * @param toIndex   index after the last bit to include\n+     * @return a new {@code NaturalsBitSet} from a range of this\n+     *         {@code NaturalsBitSet}\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} is negative, or\n+     *                                   {@code toIndex} is negative, or\n+     *                                   {@code fromIndex} is larger than\n+     *                                   {@code toIndex}\n+     *\/\n+    @Override\n+    public NaturalsBitSet get(int fromIndex, int toIndex) {\n+        return new NaturalsBitSet(getWords(fromIndex, toIndex));\n+    }\n+\n+    \/**\n+     * Returns true if this {@code NaturalsBitSet} contains no integers.\n+     *\n+     * @return boolean indicating whether this {@code NaturalsBitSet} is empty\n+     *\/\n+    @Override\n+    public boolean isEmpty() {\n+        return cardinality == 0;\n+    }\n+\n+    \/**\n+     * Returns the number of integers in this {@code NaturalsBitSet}.\n+     *\n+     * @return the number of integers in this {@code NaturalsBitSet}\n+     *\/\n+    @Override\n+    public int cardinality() {\n+        return cardinality;\n+    }\n+\n+    @Override\n+    public void and(BitSet set) {\n+        if (this != set) {\n+            super.and(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void or(BitSet set) {\n+        if (this != set) {\n+            super.or(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void xor(BitSet set) {\n+        if (this == set) { \/\/ An optimization\n+            clear();\n+        } else {\n+            super.xor(set);\n+            computeCardinality();\n+            checkCardinality();\n+        }\n+    }\n+\n+    @Override\n+    public void andNot(BitSet set) {\n+        int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);\n+\n+        if (wordsInCommon > wordsInUse \/ 2) { \/\/ An optimization\n+            super.andNot(set);\n+            computeCardinality();\n+            checkCardinality();\n+        } else {\n+            cardinality -= bitCount(0, wordsInCommon);\n+            super.andNot(set);\n+            cardinality += bitCount(0, wordsInCommon);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ compare the cardinalities if obj is a NaturalsBitSet\n+        return !((obj instanceof NaturalsBitSet set) && cardinality != set.cardinality) && super.equals(obj);\n+    }\n+\n+    \/**\n+     * Cloning this {@code NaturalsBitSet} produces a new {@code NaturalsBitSet}\n+     * that is equal to it. The clone of the bit set is another bit set that has\n+     * exactly the same integers as this bit set.\n+     *\n+     * @return a clone of this bit set\n+     * @see #size()\n+     *\/\n+    @Override\n+    public NaturalsBitSet clone() {\n+        return (NaturalsBitSet) super.clone();\n+    }\n+\n+    \/**\n+     * Reconstitute the {@code NaturalsBitSet} instance from a stream (i.e.,\n+     * deserialize it).\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n+        ObjectInputStream.GetField fields = s.readFields();\n+        words = (long[]) fields.get(\"bits\", null);\n+\n+        \/\/ Assume maximum length then find real length\n+        \/\/ because recalculateWordsInUse assumes maintenance\n+        \/\/ or reduction in logical size\n+        wordsInUse = words.length;\n+        recalculateWordsInUse();\n+        computeCardinality();\n+        sizeIsSticky = (words.length > 0 && words[words.length - 1] == 0L); \/\/ heuristic\n+        checkInvariants();\n+        checkCardinality();\n+    }\n+\n+    \/**\n+     * Returns a string representation of this {@code NaturalsBitSet}. For every\n+     * integer for which this {@code NaturalsBitSet} contains it, the decimal\n+     * representation of that integer is included in the result. Such integers are\n+     * listed in order from lowest to highest, separated by \",&nbsp;\" (a comma and a\n+     * space) and surrounded by braces, resulting in the usual mathematical notation\n+     * for a set of integers.\n+     *\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     * BitSet drPepper = new BitSet();\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(2);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2}}\".\n+     * \n+     * <pre>\n+     * drPepper.set(4);\n+     * drPepper.set(10);\n+     * <\/pre>\n+     * \n+     * Now {@code drPepper.toString()} returns \"{@code {2, 4, 10}}\".\n+     *\n+     * @return a string representation of this bit set\n+     *\/\n+    public String toString() {\n+        checkInvariants();\n+\n+        final int MAX_INITIAL_CAPACITY = Integer.MAX_VALUE - 8;\n+        \/\/ Avoid overflow in the case of a humongous cardinality\n+        int initialCapacity = (cardinality <= (MAX_INITIAL_CAPACITY - 2) \/ 6) ? 6 * cardinality + 2\n+                : MAX_INITIAL_CAPACITY;\n+        StringBuilder b = new StringBuilder(initialCapacity);\n+        b.append('{');\n+\n+        int i = nextSetBit(0);\n+        if (i != -1) {\n+            b.append(i);\n+            while (true) {\n+                if (++i < 0)\n+                    break;\n+                if ((i = nextSetBit(i)) < 0)\n+                    break;\n+                int endOfRun = nextClearBit(i);\n+                do {\n+                    b.append(\", \").append(i);\n+                } while (++i != endOfRun);\n+            }\n+        }\n+\n+        b.append('}');\n+        return b.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/NaturalsBitSet.java","additions":526,"deletions":0,"binary":false,"changes":526,"status":"added"}]}