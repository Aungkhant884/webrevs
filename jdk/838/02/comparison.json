{"files":[{"patch":"@@ -284,12 +284,0 @@\n-uint G1PLABAllocator::calc_survivor_alignment_bytes() {\n-  assert(SurvivorAlignmentInBytes >= ObjectAlignmentInBytes, \"sanity\");\n-  if (SurvivorAlignmentInBytes == ObjectAlignmentInBytes) {\n-    \/\/ No need to align objects in the survivors differently, return 0\n-    \/\/ which means \"survivor alignment is not used\".\n-    return 0;\n-  } else {\n-    assert(SurvivorAlignmentInBytes > 0, \"sanity\");\n-    return SurvivorAlignmentInBytes;\n-  }\n-}\n-\n@@ -298,2 +286,1 @@\n-  _allocator(allocator),\n-  _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {\n+  _allocator(allocator) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -152,7 +152,0 @@\n-  \/\/ The survivor alignment in effect in bytes.\n-  \/\/ == 0 : don't align survivors\n-  \/\/ != 0 : align survivors to that alignment\n-  \/\/ These values were chosen to favor the non-alignment case since some\n-  \/\/ architectures have a special compare against zero instructions.\n-  const uint _survivor_alignment_bytes;\n-\n@@ -171,4 +164,0 @@\n-  \/\/ Calculate the survivor space object alignment in bytes. Returns that or 0 if\n-  \/\/ there are no restrictions on survivor alignment.\n-  static uint calc_survivor_alignment_bytes();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -108,5 +108,1 @@\n-  if (_survivor_alignment_bytes == 0 || !dest.is_young()) {\n-    return buffer->allocate(word_sz);\n-  } else {\n-    return buffer->allocate_aligned(word_sz, _survivor_alignment_bytes);\n-  }\n+  return buffer->allocate(word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,5 +35,1 @@\n-  HeapWord* obj = CollectedHeap::align_allocation_or_fail(top(), end(), SurvivorAlignmentInBytes);\n-  if (obj == NULL) {\n-    return NULL;\n-  }\n-\n+  HeapWord* obj = top();\n@@ -44,2 +40,1 @@\n-    assert(is_aligned(obj, SurvivorAlignmentInBytes) && is_object_aligned(new_top),\n-           \"checking alignment\");\n+    assert(is_object_aligned(new_top), \"checking alignment\");\n@@ -48,1 +43,0 @@\n-    set_top(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-    obj = (oop) to()->allocate_aligned(s);\n+    obj = (oop) to()->allocate(s);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,6 +313,0 @@\n-  \/\/ Return the address \"addr\" aligned by \"alignment_in_bytes\" if such\n-  \/\/ an address is below \"end\".  Return NULL otherwise.\n-  inline static HeapWord* align_allocation_or_fail(HeapWord* addr,\n-                                                   HeapWord* end,\n-                                                   unsigned short alignment_in_bytes);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,37 +33,0 @@\n-inline HeapWord* CollectedHeap::align_allocation_or_fail(HeapWord* addr,\n-                                                         HeapWord* end,\n-                                                         unsigned short alignment_in_bytes) {\n-  if (alignment_in_bytes <= ObjectAlignmentInBytes) {\n-    return addr;\n-  }\n-\n-  assert(is_aligned(addr, HeapWordSize),\n-         \"Address \" PTR_FORMAT \" is not properly aligned.\", p2i(addr));\n-  assert(is_aligned(alignment_in_bytes, HeapWordSize),\n-         \"Alignment size %u is incorrect.\", alignment_in_bytes);\n-\n-  HeapWord* new_addr = align_up(addr, alignment_in_bytes);\n-  size_t padding = pointer_delta(new_addr, addr);\n-\n-  if (padding == 0) {\n-    return addr;\n-  }\n-\n-  if (padding < CollectedHeap::min_fill_size()) {\n-    padding += alignment_in_bytes \/ HeapWordSize;\n-    assert(padding >= CollectedHeap::min_fill_size(),\n-           \"alignment_in_bytes %u is expect to be larger \"\n-           \"than the minimum object size\", alignment_in_bytes);\n-    new_addr = addr + padding;\n-  }\n-\n-  assert(new_addr > addr, \"Unexpected arithmetic overflow \"\n-         PTR_FORMAT \" not greater than \" PTR_FORMAT, p2i(new_addr), p2i(addr));\n-  if(new_addr < end) {\n-    CollectedHeap::fill_with_object(addr, padding);\n-    return new_addr;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -441,19 +441,0 @@\n-JVMFlag::Error SurvivorAlignmentInBytesConstraintFunc(intx value, bool verbose) {\n-  if (value != 0) {\n-    if (!is_power_of_2(value)) {\n-      JVMFlag::printError(verbose,\n-                          \"SurvivorAlignmentInBytes (\" INTX_FORMAT \") must be \"\n-                          \"power of 2\\n\",\n-                          value);\n-      return JVMFlag::VIOLATES_CONSTRAINT;\n-    }\n-    if (value < ObjectAlignmentInBytes) {\n-      JVMFlag::printError(verbose,\n-                          \"SurvivorAlignmentInBytes (\" INTX_FORMAT \") must be \"\n-                          \"greater than or equal to ObjectAlignmentInBytes (\" INTX_FORMAT \")\\n\",\n-                          value, ObjectAlignmentInBytes);\n-      return JVMFlag::VIOLATES_CONSTRAINT;\n-    }\n-  }\n-  return JVMFlag::SUCCESS;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n- f(intx,   SurvivorAlignmentInBytesConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-inline HeapWord* PLAB::allocate_aligned(size_t word_sz, unsigned short alignment_in_bytes) {\n-  HeapWord* res = CollectedHeap::align_allocation_or_fail(_top, _end, alignment_in_bytes);\n-  if (res == NULL) {\n-    return NULL;\n-  }\n-\n-  \/\/ Set _top so that allocate(), which expects _top to be correctly set,\n-  \/\/ can be used below.\n-  _top = res;\n-  return allocate(word_sz);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -570,21 +570,0 @@\n-HeapWord* ContiguousSpace::allocate_aligned(size_t size) {\n-  assert(Heap_lock->owned_by_self() || (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()), \"not locked\");\n-  HeapWord* end_value = end();\n-\n-  HeapWord* obj = CollectedHeap::align_allocation_or_fail(top(), end_value, SurvivorAlignmentInBytes);\n-  if (obj == NULL) {\n-    return NULL;\n-  }\n-\n-  if (pointer_delta(end_value, obj) >= size) {\n-    HeapWord* new_top = obj + size;\n-    set_top(new_top);\n-    assert(::is_aligned(obj, SurvivorAlignmentInBytes) && is_aligned(new_top),\n-      \"checking alignment\");\n-    return obj;\n-  } else {\n-    set_top(obj);\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -563,1 +563,0 @@\n-  HeapWord* allocate_aligned(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1662,4 +1662,0 @@\n-\n-  if (SurvivorAlignmentInBytes == 0) {\n-    SurvivorAlignmentInBytes = ObjectAlignmentInBytes;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2396,5 +2396,0 @@\n-  product(intx, SurvivorAlignmentInBytes, 0, EXPERIMENTAL,                  \\\n-           \"Default survivor space alignment in bytes\")                     \\\n-           range(8, 256)                                                    \\\n-           constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-  -gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.arguments;\n-\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-\/**\n- * @test\n- * @bug 8031323\n- * @summary Verify SurvivorAlignmentInBytes option processing.\n- * @library \/test\/lib\n- * @requires vm.opt.SurvivorAlignmentInBytes == null\n- *           & vm.opt.ObjectAlignmentInBytes == null\n- *           & vm.opt.UnlockExperimentalVMOptions == null\n- *           & (vm.opt.IgnoreUnrecognizedVMOptions == null\n- *              | vm.opt.IgnoreUnrecognizedVMOptions == \"false\")\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver gc.arguments.TestSurvivorAlignmentInBytesOption\n- *\/\n-public class TestSurvivorAlignmentInBytesOption {\n-    public static void main(String args[]) throws Throwable {\n-        String optionName = \"SurvivorAlignmentInBytes\";\n-        String unlockExperimentalVMOpts = \"UnlockExperimentalVMOptions\";\n-        String optionIsExperimental\n-                = CommandLineOptionTest.getExperimentalOptionErrorMessage(\n-                optionName);\n-        String valueIsTooSmall= \".*SurvivorAlignmentInBytes.*must be greater\"\n-                + \" than or equal to ObjectAlignmentInBytes.*\";\n-        String mustBePowerOf2 = \".*SurvivorAlignmentInBytes.*must be \"\n-                + \"power of 2.*\";\n-\n-        \/\/ Verify that without -XX:+UnlockExperimentalVMOptions usage of\n-        \/\/ SurvivorAlignmentInBytes option will cause JVM startup failure\n-        \/\/ with the warning message saying that that option is experimental.\n-        String shouldFailMessage = String.format(\"JVM option '%s' is \"\n-                + \"experimental.%nJVM startup should fail without \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                new String[]{optionIsExperimental}, null,\n-                shouldFailMessage, shouldFailMessage,\n-                ExitCode.FAIL, false,\n-                \"-XX:-UnlockExperimentalVMOptions\",\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, false),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 64));\n-\n-        \/\/ Verify that with -XX:+UnlockExperimentalVMOptions passed to JVM\n-        \/\/ usage of SurvivorAlignmentInBytes option won't cause JVM startup\n-        \/\/ failure.\n-        String shouldPassMessage = String.format(\"JVM option '%s' is \"\n-                + \"experimental.%nJVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        String noWarningMessage = \"There should be no warnings when use \"\n-                + \"with -XX:+UnlockExperimentalVMOptions option\";\n-        CommandLineOptionTest.verifyJVMStartup(\n-                null, new String[]{optionIsExperimental},\n-                shouldPassMessage, noWarningMessage,\n-                ExitCode.OK, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 64));\n-\n-        \/\/ Verify that if specified SurvivorAlignmentInBytes is lower than\n-        \/\/ ObjectAlignmentInBytes, then the JVM startup will fail with\n-        \/\/ appropriate error message.\n-        if (Platform.is64bit()) {\n-            shouldFailMessage = String.format(\"JVM startup should fail with \"\n-                    + \"'%s' option value lower than ObjectAlignmentInBytes\", optionName);\n-            CommandLineOptionTest.verifyJVMStartup(\n-                    new String[]{valueIsTooSmall}, null,\n-                    shouldFailMessage, shouldFailMessage,\n-                    ExitCode.FAIL, false,\n-                    CommandLineOptionTest.prepareBooleanFlag(\n-                            unlockExperimentalVMOpts, true),\n-                    CommandLineOptionTest.prepareNumericFlag(optionName, 8),\n-                    CommandLineOptionTest.prepareNumericFlag(\"ObjectAlignmentInBytes\", 16));\n-        }\n-\n-        \/\/ Verify that if specified SurvivorAlignmentInBytes value is not\n-        \/\/ a power of 2 then the JVM startup will fail with appropriate error\n-        \/\/ message.\n-        shouldFailMessage = String.format(\"JVM startup should fail with \"\n-                + \"'%s' option value is not a power of 2\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                new String[]{mustBePowerOf2}, null,\n-                shouldFailMessage, shouldFailMessage,\n-                ExitCode.FAIL, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 127));\n-\n-        \/\/ Verify that if SurvivorAlignmentInBytes has correct value, then\n-        \/\/ the JVM will be started without errors.\n-        shouldPassMessage = String.format(\"JVM startup should pass with \"\n-                + \"correct '%s' option value\", optionName);\n-        noWarningMessage = String.format(\"There should be no warnings when use \"\n-                + \"correct '%s' option value\", optionName);\n-        CommandLineOptionTest.verifyJVMStartup(\n-                null, new String[]{\".*SurvivorAlignmentInBytes.*\"},\n-                shouldPassMessage, noWarningMessage,\n-                ExitCode.OK, false,\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        unlockExperimentalVMOpts, true),\n-                CommandLineOptionTest.prepareNumericFlag(optionName, 128));\n-\n-        \/\/ Verify that we can setup different SurvivorAlignmentInBytes values.\n-        for (int alignment = 32; alignment <= 128; alignment *= 2) {\n-            shouldPassMessage = String.format(\"JVM startup should pass with \"\n-                    + \"'%s' = %d\", optionName, alignment);\n-            CommandLineOptionTest.verifyOptionValue(optionName,\n-                    Integer.toString(alignment), shouldPassMessage,\n-                    CommandLineOptionTest.prepareBooleanFlag(\n-                            unlockExperimentalVMOpts, true),\n-                    CommandLineOptionTest.prepareNumericFlag(\n-                            optionName, alignment));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSurvivorAlignmentInBytesOption.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-import java.lang.management.MemoryPoolMXBean;\n-import java.util.Optional;\n-\n-import sun.hotspot.WhiteBox;\n-\n-\/**\n- * Helper class aimed to provide information about alignment of objects in\n- * particular heap space, expected memory usage after objects' allocation so on.\n- *\/\n-public class AlignmentHelper {\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    private static final long OBJECT_ALIGNMENT_IN_BYTES_FOR_32_VM = 8L;\n-\n-    \/**\n-     * Max relative allowed actual memory usage deviation from expected memory\n-     * usage.\n-     *\/\n-    private static final float MAX_RELATIVE_DEVIATION = 0.05f; \/\/ 5%\n-\n-    public static final long OBJECT_ALIGNMENT_IN_BYTES = Optional.ofNullable(\n-            AlignmentHelper.WHITE_BOX.getIntxVMFlag(\"ObjectAlignmentInBytes\"))\n-            .orElse(AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES_FOR_32_VM);\n-\n-    public static final long SURVIVOR_ALIGNMENT_IN_BYTES = Optional.ofNullable(\n-            AlignmentHelper.WHITE_BOX.getIntxVMFlag(\"SurvivorAlignmentInBytes\"))\n-            .orElseThrow(() ->new AssertionError(\n-                    \"Unable to get SurvivorAlignmentInBytes value\"));\n-    \/**\n-     * Min amount of memory that will be occupied by an object.\n-     *\/\n-    public static final long MIN_OBJECT_SIZE\n-            = AlignmentHelper.WHITE_BOX.getObjectSize(new Object());\n-    \/**\n-     * Min amount of memory that will be occupied by an empty byte array.\n-     *\/\n-    public static final long MIN_ARRAY_SIZE\n-            = AlignmentHelper.WHITE_BOX.getObjectSize(new byte[0]);\n-\n-    \/**\n-     * Precision at which actual memory usage in a heap space represented by\n-     * this sizing helper could be measured.\n-     *\/\n-    private final long memoryUsageMeasurementPrecision;\n-    \/**\n-     * Min amount of memory that will be occupied by an object allocated in a\n-     * heap space represented by this sizing helper.\n-     *\/\n-    private final long minObjectSizeInThisSpace;\n-    \/**\n-     * Object's alignment in a heap space represented by this sizing helper.\n-     *\/\n-    private final long objectAlignmentInThisRegion;\n-    \/**\n-     * MemoryPoolMXBean associated with a heap space represented by this sizing\n-     * helper.\n-     *\/\n-    private final MemoryPoolMXBean poolMXBean;\n-\n-    private static long alignUp(long value, long alignment) {\n-        return ((value - 1) \/ alignment + 1) * alignment;\n-    }\n-\n-    protected AlignmentHelper(long memoryUsageMeasurementPrecision,\n-            long objectAlignmentInThisRegion, long minObjectSizeInThisSpace,\n-            MemoryPoolMXBean poolMXBean) {\n-        this.memoryUsageMeasurementPrecision = memoryUsageMeasurementPrecision;\n-        this.minObjectSizeInThisSpace = minObjectSizeInThisSpace;\n-        this.objectAlignmentInThisRegion = objectAlignmentInThisRegion;\n-        this.poolMXBean = poolMXBean;\n-    }\n-\n-    \/**\n-     * Returns how many objects have to be allocated to fill\n-     * {@code memoryToFill} bytes in this heap space using objects of size\n-     * {@code objectSize}.\n-     *\/\n-    public int getObjectsCount(long memoryToFill, long objectSize) {\n-        return (int) (memoryToFill \/ getObjectSizeInThisSpace(objectSize));\n-    }\n-\n-    \/**\n-     * Returns amount of memory that {@code objectsCount} of objects with size\n-     * {@code objectSize} will occupy this this space after allocation.\n-     *\/\n-    public long getExpectedMemoryUsage(long objectSize, int objectsCount) {\n-        long correctedObjectSize = getObjectSizeInThisSpace(objectSize);\n-        return AlignmentHelper.alignUp(correctedObjectSize * objectsCount,\n-                memoryUsageMeasurementPrecision);\n-    }\n-\n-    \/**\n-     * Returns current memory usage in this heap space.\n-     *\/\n-    public long getActualMemoryUsage() {\n-        return poolMXBean.getUsage().getUsed();\n-    }\n-\n-    \/**\n-     * Returns maximum memory usage deviation from {@code expectedMemoryUsage}\n-     * given the max allowed relative deviation equal to\n-     * {@code relativeDeviation}.\n-     *\n-     * Note that value returned by this method is aligned according to\n-     * memory measurement precision for this heap space.\n-     *\/\n-    public long getAllowedMemoryUsageDeviation(long expectedMemoryUsage) {\n-        long unalignedDeviation = (long) (expectedMemoryUsage *\n-                AlignmentHelper.MAX_RELATIVE_DEVIATION);\n-        return AlignmentHelper.alignUp(unalignedDeviation,\n-                memoryUsageMeasurementPrecision);\n-    }\n-\n-    \/**\n-     * Returns amount of memory that will be occupied by an object with size\n-     * {@code objectSize} in this heap space.\n-     *\/\n-    public long getObjectSizeInThisSpace(long objectSize) {\n-        objectSize = Math.max(objectSize, minObjectSizeInThisSpace);\n-\n-        long alignedObjectSize = AlignmentHelper.alignUp(objectSize,\n-                objectAlignmentInThisRegion);\n-        long sizeDiff = alignedObjectSize - objectSize;\n-\n-        \/\/ If there is not enough space to fit padding object, then object will\n-        \/\/ be aligned to {@code 2 * objectAlignmentInThisRegion}.\n-        if (sizeDiff >= AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES\n-                && sizeDiff < AlignmentHelper.MIN_OBJECT_SIZE) {\n-            alignedObjectSize += AlignmentHelper.MIN_OBJECT_SIZE;\n-            alignedObjectSize = AlignmentHelper.alignUp(alignedObjectSize,\n-                    objectAlignmentInThisRegion);\n-        }\n-\n-        return alignedObjectSize;\n-    }\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(String.format(\"AlignmentHelper for memory pool '%s':%n\",\n-                poolMXBean.getName()));\n-        builder.append(String.format(\"Memory usage measurement precision: %d%n\",\n-                memoryUsageMeasurementPrecision));\n-        builder.append(String.format(\"Min object size in this space: %d%n\",\n-                minObjectSizeInThisSpace));\n-        builder.append(String.format(\"Object alignment in this space: %d%n\",\n-                objectAlignmentInThisRegion));\n-\n-        return builder.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/AlignmentHelper.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,395 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.MemoryPoolMXBean;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.Asserts;\n-import com.sun.management.ThreadMXBean;\n-import sun.hotspot.WhiteBox;\n-import jdk.internal.misc.Unsafe;\n-\n-\/**\n- * Main class for tests on {@code SurvivorAlignmentInBytes} option.\n- *\n- * Typical usage is to obtain instance using fromArgs method, allocate objects\n- * and verify that actual memory usage in tested heap space is close to\n- * expected.\n- *\/\n-public class SurvivorAlignmentTestMain {\n-    enum HeapSpace {\n-        EDEN,\n-        SURVIVOR,\n-        TENURED\n-    }\n-\n-    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    public static final long MAX_TENURING_THRESHOLD = Optional.ofNullable(\n-            SurvivorAlignmentTestMain.WHITE_BOX.getIntxVMFlag(\n-                    \"MaxTenuringThreshold\")).orElse(15L);\n-\n-    \/**\n-     * Regexp used to parse memory size params, like 2G, 34m or 15k.\n-     *\/\n-    private static final Pattern SIZE_REGEX\n-            = Pattern.compile(\"(?<size>[0-9]+)(?<multiplier>[GMKgmk])?\");\n-\n-    \/\/ Names of different heap spaces.\n-    private static final String DEF_NEW_EDEN = \"Eden Space\";\n-    private static final String DEF_NEW_SURVIVOR = \"Survivor Space\";\n-    private static final String PAR_NEW_EDEN = \"Par Eden Space\";\n-    private static final String PAR_NEW_SURVIVOR = \"Par Survivor Space\";\n-    private static final String PS_EDEN = \"PS Eden Space\";\n-    private static final String PS_SURVIVOR = \"PS Survivor Space\";\n-    private static final String G1_EDEN = \"G1 Eden Space\";\n-    private static final String G1_SURVIVOR = \"G1 Survivor Space\";\n-    private static final String SERIAL_TENURED = \"Tenured Gen\";\n-    private static final String PS_TENURED = \"PS Old Gen\";\n-    private static final String G1_TENURED = \"G1 Old Gen\";\n-\n-    private static final long G1_HEAP_REGION_SIZE = Optional.ofNullable(\n-            SurvivorAlignmentTestMain.WHITE_BOX.getUintxVMFlag(\n-                    \"G1HeapRegionSize\")).orElse(-1L);\n-\n-    private static final AlignmentHelper EDEN_SPACE_HELPER;\n-    private static final AlignmentHelper SURVIVOR_SPACE_HELPER;\n-    private static final AlignmentHelper TENURED_SPACE_HELPER;\n-    \/**\n-     * Amount of memory that should be filled during a test run.\n-     *\/\n-    private final long memoryToFill;\n-    \/**\n-     * The size of an objects that will be allocated during a test run.\n-     *\/\n-    private final long objectSize;\n-    \/**\n-     * Amount of memory that will be actually occupied by an object in eden\n-     * space.\n-     *\/\n-    private final long actualObjectSize;\n-    \/**\n-     * Storage for allocated objects.\n-     *\/\n-    private final Object[] garbage;\n-    \/**\n-     * Heap space whose memory usage is a subject of assertions during the test\n-     * run.\n-     *\/\n-    private final HeapSpace testedSpace;\n-\n-    private long[] baselinedThreadMemoryUsage = null;\n-    private long[] threadIds = null;\n-\n-    \/**\n-     * Initialize {@code EDEN_SPACE_HELPER}, {@code SURVIVOR_SPACE_HELPER} and\n-     * {@code TENURED_SPACE_HELPER} to represent heap spaces in use.\n-     *\n-     * Note that regardless to GC object's alignment in survivor space is\n-     * expected to be equal to {@code SurvivorAlignmentInBytes} value and\n-     * alignment in other spaces is expected to be equal to\n-     * {@code ObjectAlignmentInBytes} value.\n-     *\n-     * For G1 GC MXBeans could report memory usage only with region size\n-     * precision (if an object allocated in some G1 heap region, then all region\n-     * will claimed as used), so for G1's spaces precision is equal to\n-     * {@code G1HeapRegionSize} value.\n-     *\/\n-    static {\n-        AlignmentHelper edenHelper = null;\n-        AlignmentHelper survivorHelper = null;\n-        AlignmentHelper tenuredHelper = null;\n-        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {\n-            switch (pool.getName()) {\n-                case SurvivorAlignmentTestMain.DEF_NEW_EDEN:\n-                case SurvivorAlignmentTestMain.PAR_NEW_EDEN:\n-                case SurvivorAlignmentTestMain.PS_EDEN:\n-                    Asserts.assertNull(edenHelper,\n-                            \"Only one bean for eden space is expected.\");\n-                    edenHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.G1_EDEN:\n-                    Asserts.assertNull(edenHelper,\n-                            \"Only one bean for eden space is expected.\");\n-                    edenHelper = new AlignmentHelper(\n-                            SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.DEF_NEW_SURVIVOR:\n-                case SurvivorAlignmentTestMain.PAR_NEW_SURVIVOR:\n-                case SurvivorAlignmentTestMain.PS_SURVIVOR:\n-                    Asserts.assertNull(survivorHelper,\n-                            \"Only one bean for survivor space is expected.\");\n-                    survivorHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.G1_SURVIVOR:\n-                    Asserts.assertNull(survivorHelper,\n-                            \"Only one bean for survivor space is expected.\");\n-                    survivorHelper = new AlignmentHelper(\n-                            SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,\n-                            AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-                case SurvivorAlignmentTestMain.SERIAL_TENURED:\n-                case SurvivorAlignmentTestMain.PS_TENURED:\n-                case SurvivorAlignmentTestMain.G1_TENURED:\n-                    Asserts.assertNull(tenuredHelper,\n-                            \"Only one bean for tenured space is expected.\");\n-                    tenuredHelper = new AlignmentHelper(\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,\n-                            AlignmentHelper.MIN_OBJECT_SIZE, pool);\n-                    break;\n-            }\n-        }\n-        EDEN_SPACE_HELPER = Objects.requireNonNull(edenHelper,\n-                \"AlignmentHelper for eden space should be initialized.\");\n-        SURVIVOR_SPACE_HELPER = Objects.requireNonNull(survivorHelper,\n-                \"AlignmentHelper for survivor space should be initialized.\");\n-        TENURED_SPACE_HELPER = Objects.requireNonNull(tenuredHelper,\n-                \"AlignmentHelper for tenured space should be initialized.\");\n-    }\n-    \/**\n-     * Returns an SurvivorAlignmentTestMain instance constructed using CLI\n-     * options.\n-     *\n-     * Following options are expected:\n-     * <ul>\n-     *     <li>memoryToFill<\/li>\n-     *     <li>objectSize<\/li>\n-     * <\/ul>\n-     *\n-     * Both argument may contain multiplier suffix k, m or g.\n-     *\/\n-    public static SurvivorAlignmentTestMain fromArgs(String[] args) {\n-        Asserts.assertEQ(args.length, 3, \"Expected three arguments: \"\n-                + \"memory size, object size and tested heap space name.\");\n-\n-        long memoryToFill = parseSize(args[0]);\n-        long objectSize = Math.max(parseSize(args[1]),\n-                AlignmentHelper.MIN_ARRAY_SIZE);\n-        HeapSpace testedSpace = HeapSpace.valueOf(args[2]);\n-\n-        return new SurvivorAlignmentTestMain(memoryToFill, objectSize,\n-                testedSpace);\n-    }\n-\n-    \/**\n-     * Returns a value parsed from a string with format\n-     * &lt;integer&gt;&lt;multiplier&gt;.\n-     *\/\n-    private static long parseSize(String sizeString) {\n-        Matcher matcher = SIZE_REGEX.matcher(sizeString);\n-        Asserts.assertTrue(matcher.matches(),\n-                \"sizeString should have following format \\\"[0-9]+([MBK])?\\\"\");\n-        long size = Long.valueOf(matcher.group(\"size\"));\n-\n-        if (matcher.group(\"multiplier\") != null) {\n-            long K = 1024L;\n-            \/\/ fall through multipliers\n-            switch (matcher.group(\"multiplier\").toLowerCase()) {\n-                case \"g\":\n-                    size *= K;\n-                case \"m\":\n-                    size *= K;\n-                case \"k\":\n-                    size *= K;\n-            }\n-        }\n-        return size;\n-    }\n-\n-    private SurvivorAlignmentTestMain(long memoryToFill, long objectSize,\n-            HeapSpace testedSpace) {\n-        this.objectSize = objectSize;\n-        this.memoryToFill = memoryToFill;\n-        this.testedSpace = testedSpace;\n-\n-        AlignmentHelper helper = SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;\n-\n-        this.actualObjectSize = helper.getObjectSizeInThisSpace(\n-                this.objectSize);\n-        int arrayLength = helper.getObjectsCount(memoryToFill, this.objectSize);\n-        garbage = new Object[arrayLength];\n-    }\n-\n-    \/**\n-     * Allocate byte arrays to fill {@code memoryToFill} memory.\n-     *\/\n-    public void allocate() {\n-        int byteArrayLength = Math.max((int) (objectSize\n-                - Unsafe.ARRAY_BYTE_BASE_OFFSET), 0);\n-\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = new byte[byteArrayLength];\n-        }\n-    }\n-\n-    \/**\n-     * Release memory occupied after {@code allocate} call.\n-     *\/\n-    public void release() {\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = null;\n-        }\n-    }\n-\n-    \/**\n-     * Returns expected amount of memory occupied in a {@code heapSpace} by\n-     * objects referenced from {@code garbage} array.\n-     *\/\n-    public long getExpectedMemoryUsage() {\n-        AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);\n-        return alignmentHelper.getExpectedMemoryUsage(objectSize,\n-                garbage.length);\n-    }\n-\n-    \/**\n-     * Verifies that memory usage in a {@code heapSpace} deviates from\n-     * {@code expectedUsage} for no more than {@code MAX_RELATIVE_DEVIATION}.\n-     *\/\n-    public void verifyMemoryUsage(long expectedUsage) {\n-        AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);\n-\n-        long actualMemoryUsage = alignmentHelper.getActualMemoryUsage();\n-        boolean otherThreadsAllocatedMemory = areOtherThreadsAllocatedMemory();\n-\n-        long memoryUsageDiff = Math.abs(actualMemoryUsage - expectedUsage);\n-        long maxAllowedUsageDiff\n-                = alignmentHelper.getAllowedMemoryUsageDeviation(expectedUsage);\n-\n-        System.out.println(\"Verifying memory usage in space: \" + testedSpace);\n-        System.out.println(\"Allocated objects count: \" + garbage.length);\n-        System.out.println(\"Desired object size: \" + objectSize);\n-        System.out.println(\"Actual object size: \" + actualObjectSize);\n-        System.out.println(\"Expected object size in space: \"\n-                + alignmentHelper.getObjectSizeInThisSpace(objectSize));\n-        System.out.println(\"Expected memory usage: \" + expectedUsage);\n-        System.out.println(\"Actual memory usage: \" + actualMemoryUsage);\n-        System.out.println(\"Memory usage diff: \" + memoryUsageDiff);\n-        System.out.println(\"Max allowed usage diff: \" + maxAllowedUsageDiff);\n-\n-        if (memoryUsageDiff > maxAllowedUsageDiff\n-                && otherThreadsAllocatedMemory) {\n-            System.out.println(\"Memory usage diff is incorrect, but it seems \"\n-                    + \"like someone else allocated objects\");\n-            return;\n-        }\n-\n-        Asserts.assertLTE(memoryUsageDiff, maxAllowedUsageDiff,\n-                \"Actual memory usage should not deviate from expected for \" +\n-                        \"more then \" + maxAllowedUsageDiff);\n-    }\n-\n-    \/**\n-     * Baselines amount of memory allocated by each thread.\n-     *\/\n-    public void baselineMemoryAllocation() {\n-        ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();\n-        threadIds = bean.getAllThreadIds();\n-        baselinedThreadMemoryUsage = bean.getThreadAllocatedBytes(threadIds);\n-    }\n-\n-    \/**\n-     * Checks if threads other then the current thread were allocating objects\n-     * after baselinedThreadMemoryUsage call.\n-     *\n-     * If baselinedThreadMemoryUsage was not called, then this method will return\n-     * {@code false}.\n-     *\/\n-    public boolean areOtherThreadsAllocatedMemory() {\n-        if (baselinedThreadMemoryUsage == null) {\n-            return false;\n-        }\n-\n-        ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();\n-        long currentMemoryAllocation[]\n-                = bean.getThreadAllocatedBytes(threadIds);\n-        boolean otherThreadsAllocatedMemory = false;\n-\n-        System.out.println(\"Verifying amount of memory allocated by threads:\");\n-        for (int i = 0; i < threadIds.length; i++) {\n-            System.out.format(\"Thread %d%nbaseline allocation: %d\"\n-                            + \"%ncurrent allocation:%d%n\", threadIds[i],\n-                    baselinedThreadMemoryUsage[i], currentMemoryAllocation[i]);\n-            System.out.println(bean.getThreadInfo(threadIds[i]));\n-\n-            long bytesAllocated = Math.abs(currentMemoryAllocation[i]\n-                    - baselinedThreadMemoryUsage[i]);\n-            if (bytesAllocated > 0\n-                    && threadIds[i] != Thread.currentThread().getId()) {\n-                otherThreadsAllocatedMemory = true;\n-            }\n-        }\n-\n-        return otherThreadsAllocatedMemory;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-\n-        builder.append(String.format(\"SurvivorAlignmentTestMain info:%n\"));\n-        builder.append(String.format(\"Desired object size: %d%n\", objectSize));\n-        builder.append(String.format(\"Memory to fill: %d%n\", memoryToFill));\n-        builder.append(String.format(\"Objects to be allocated: %d%n\",\n-                garbage.length));\n-\n-        builder.append(String.format(\"Alignment helpers to be used: %n\"));\n-        for (HeapSpace heapSpace: HeapSpace.values()) {\n-            builder.append(String.format(\"For space %s:%n%s%n\", heapSpace,\n-                    getAlignmentHelper(heapSpace)));\n-        }\n-\n-        return builder.toString();\n-    }\n-\n-    \/**\n-     * Returns {@code AlignmentHelper} for a space {@code heapSpace}.\n-     *\/\n-    public static AlignmentHelper getAlignmentHelper(HeapSpace heapSpace) {\n-        switch (heapSpace) {\n-            case EDEN:\n-                return SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;\n-            case SURVIVOR:\n-                return SurvivorAlignmentTestMain.SURVIVOR_SPACE_HELPER;\n-            case TENURED:\n-                return SurvivorAlignmentTestMain.TENURED_SPACE_HELPER;\n-            default:\n-                throw new Error(\"Unexpected heap space: \" + heapSpace);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/SurvivorAlignmentTestMain.java","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestAllocationInEden\n- * @bug 8031323\n- * @summary Verify that object's alignment in eden space is not affected by\n- *          SurvivorAlignmentInBytes option.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 47 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m  -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m  -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 87 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 9 EDEN\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:-UseTLAB -XX:-ResizePLAB\n- *                   -XX:OldSize=128m -XX:MaxHeapSize=192m\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   gc.survivorAlignment.TestAllocationInEden 10m 147 EDEN\n- *\/\n-public class TestAllocationInEden {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-\n-        test.allocate();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestAllocationInEden.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromEdenToTenured\n- * @bug 8031323\n- * @summary Verify that objects promoted from eden space to tenured space during\n- *          full GC are not aligned to SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 47 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m  -XX:MaxHeapSize=96m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 87 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=64m -XX:MaxNewSize=64m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=96m -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromEdenToTenured 10m 147 TENURED\n- *\/\n-public class TestPromotionFromEdenToTenured {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        System.gc();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromEdenToTenured.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC\n- * @bug 8031323\n- * @summary Verify that objects promoted from survivor space to tenured space\n- *          during full GC are not aligned to SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m -XX:-ResizePLAB\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 47\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=200m -XX:MaxNewSize=200m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=232m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9 TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 87\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=288m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                    gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 10m 9\n- *                    TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32m -XX:MaxHeapSize=160m\n- *                   -XX:SurvivorRatio=1 -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterFullGC 20m 147\n- *                   TENURED\n- *\/\n-public class TestPromotionFromSurvivorToTenuredAfterFullGC {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        System.gc();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-        System.gc();\n-\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterFullGC.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC\n- * @bug 8031323\n- * @summary Verify that objects promoted from survivor space to tenured space\n- *          when their age exceeded tenuring threshold are not aligned to\n- *          SurvivorAlignmentInBytes value.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 47\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=200m -XX:MaxNewSize=200m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=232m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 87\n- *                   TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=288m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                    gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 10m 9\n- *                    TENURED\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:OldSize=32M -XX:MaxHeapSize=160m -XX:SurvivorRatio=1 -XX:-ResizePLAB\n- *                   -XX:-ExplicitGCInvokesConcurrent\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128\n- *                   gc.survivorAlignment.TestPromotionFromSurvivorToTenuredAfterMinorGC 20m 147\n- *                   TENURED\n- *\/\n-public class TestPromotionFromSurvivorToTenuredAfterMinorGC {\n-    public static void main(String args[]) throws Exception {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedMemoryUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        SurvivorAlignmentTestMain.WHITE_BOX.fullGC();\n-        \/\/ increase expected usage by current old gen usage\n-        expectedMemoryUsage += SurvivorAlignmentTestMain.getAlignmentHelper(\n-                SurvivorAlignmentTestMain.HeapSpace.TENURED)\n-                .getActualMemoryUsage();\n-\n-        test.allocate();\n-        for (int i = 0; i <= SurvivorAlignmentTestMain.MAX_TENURING_THRESHOLD; i++) {\n-            SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-        }\n-\n-        \/\/ Sometimes we see that data unrelated to the test has been allocated during\n-        \/\/ the loop. This data is included in the expectedMemoryUsage since we look\n-        \/\/ through all threads to see what they allocated. If this data is still in\n-        \/\/ the survivor area however, it should not be included in expectedMemoryUsage\n-        \/\/ since the verification below only look at what's in tenured space.\n-        expectedMemoryUsage -= SurvivorAlignmentTestMain.getAlignmentHelper(\n-                                   SurvivorAlignmentTestMain.HeapSpace.SURVIVOR)\n-                                   .getActualMemoryUsage();\n-        test.verifyMemoryUsage(expectedMemoryUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @bug 8060463\n- * @summary Verify that objects promoted from eden space to survivor space\n- *          with large values for SurvivorAlignmentInBytes succeed.\n- * @requires vm.opt.ExplicitGCInvokesConcurrent != true\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=8 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=16 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- * @run main\/othervm -Xmx128m\n- *                   -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=256 -XX:SurvivorRatio=1\n- *                   -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionLABLargeSurvivorAlignment\n- *\/\n-public class TestPromotionLABLargeSurvivorAlignment {\n-    public static void main(String args[]) {\n-        Object garbage[] = new Object[1000000];\n-        for (int i = 0; i < garbage.length; i++) {\n-            garbage[i] = new byte[0];\n-        }\n-        for (int i = 0; i < 2; i++) {\n-            System.gc();\n-        }\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionLABLargeSurvivorAlignment.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.survivorAlignment;\n-\n-\/**\n- * @test gc.survivorAlignment.TestPromotionToSurvivor\n- * @bug 8031323\n- * @summary Verify that objects promoted from eden space to survivor space after\n- *          minor GC are aligned to SurvivorAlignmentInBytes.\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 10m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=32 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 47 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 8m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=64 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 87 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=256m -XX:MaxNewSize=256m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=384m  -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 10m 9 SURVIVOR\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI -XX:NewSize=128m -XX:MaxNewSize=128m\n- *                   -XX:SurvivorRatio=1 -XX:+UnlockExperimentalVMOptions\n- *                   -XX:SurvivorAlignmentInBytes=128 -XX:OldSize=128m\n- *                   -XX:MaxHeapSize=256m -XX:-ExplicitGCInvokesConcurrent -XX:-ResizePLAB\n- *                   gc.survivorAlignment.TestPromotionToSurvivor 20m 147 SURVIVOR\n- *\/\n-public class TestPromotionToSurvivor {\n-    public static void main(String args[]) {\n-        SurvivorAlignmentTestMain test\n-                = SurvivorAlignmentTestMain.fromArgs(args);\n-        System.out.println(test);\n-\n-        long expectedUsage = test.getExpectedMemoryUsage();\n-        test.baselineMemoryAllocation();\n-        SurvivorAlignmentTestMain.WHITE_BOX.fullGC();\n-\n-        test.allocate();\n-        SurvivorAlignmentTestMain.WHITE_BOX.youngGC();\n-\n-        test.verifyMemoryUsage(expectedUsage);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/survivorAlignment\/TestPromotionToSurvivor.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"}]}