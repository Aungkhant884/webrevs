{"files":[{"patch":"@@ -270,5 +270,1 @@\n-      if (vec_value->Opcode() == Op_VectorLoadMask) {\n-        const Type* in1_ty = vec_value->in(1)->bottom_type();\n-        assert(in1_ty->isa_vect() && in1_ty->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n-        vec_value = vec_value->in(1);\n-      } else if (vec_value->Opcode() != Op_VectorStoreMask) {\n+      if (vec_value->Opcode() != Op_VectorStoreMask) {\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  } else if (is_vector_mask(ik)) {\n+    return T_BOOLEAN;\n@@ -89,23 +91,20 @@\n-void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n-  if (is_mask) {\n-    switch (elem_bt) {\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_INT:\n-      case T_LONG:\n-      case T_FLOAT:\n-      case T_DOUBLE: arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n-\n-      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-    }\n-  } else {\n-    switch (elem_bt) {\n-      case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n-      case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n-      case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n-      case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n-      case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n-      case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n-\n-      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-    }\n+\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+\/\/ occupies the whole 512-bit vector register when scalarized.\n+\/\/ During scalarization inserting a VectorStoreMask node between mask\n+\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n+\/\/\n+\/\/ TODO: revisit when predicate registers are fully supported.\n+\/\/\n+void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n+  switch (elem_bt) {\n+    case T_BOOLEAN:\n+    case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n+    case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n+    case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n+    case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n+    case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n+    case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n+\n+    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -116,2 +115,0 @@\n-  bool is_mask = is_vector_mask(ik);\n-\n@@ -120,5 +117,1 @@\n-  \/\/ Inserting a VectorStoreMask before stitching the mask\n-  \/\/ to SafePointNode will ensure packing the mask into a\n-  \/\/ byte array for masks present in both predicated register\n-  \/\/ or vector registers.\n-  int elem_size = is_mask ? 1 : type2aelembytes(elem_bt);\n+  int elem_size = type2aelembytes(elem_bt);\n@@ -127,1 +120,1 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(is_mask ? T_BOOLEAN : elem_bt));\n+  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n@@ -140,1 +133,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n+      init_payload_element(arr, elem_bt, i, elem_addr);\n@@ -146,1 +139,1 @@\n-      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n+      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":26,"deletions":33,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n+  static void init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}