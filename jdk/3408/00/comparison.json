{"files":[{"patch":"@@ -35,0 +35,9 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+\n@@ -255,0 +264,16 @@\n+\n+    \/\/ If a mask is feeding into a safepoint, then its value should be\n+    \/\/ packed into a byte vector first, this will simplify the re-materialization\n+    \/\/ logic for both predicated and non-predicated targets.\n+    bool is_mask = is_vector_mask(iklass);\n+    if (is_mask) {\n+      if (vec_value->Opcode() == Op_VectorLoadMask) {\n+        const Type* in1_ty = vec_value->in(1)->bottom_type();\n+        assert(in1_ty->isa_vect() && in1_ty->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n+        vec_value = vec_value->in(1);\n+      } else if (vec_value->Opcode() != Op_VectorStoreMask) {\n+        const TypeVect* vt = vec_value->bottom_type()->is_vect();\n+        BasicType bt = vt->element_basic_type();\n+        vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n+      }\n+    }\n@@ -308,8 +333,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -91,7 +91,0 @@\n-    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-    \/\/ occupies the whole 512-bit vector register when scalarized.\n-    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n-    \/\/\n-    \/\/ TODO: revisit when predicate registers are fully supported.\n@@ -99,6 +92,6 @@\n-      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n-      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n-      case T_INT:    \/\/ fall-through\n-      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n-      case T_LONG:   \/\/ fall-through\n-      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT:\n+      case T_LONG:\n+      case T_FLOAT:\n+      case T_DOUBLE: arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n@@ -127,1 +120,5 @@\n-  int elem_size = type2aelembytes(elem_bt);\n+  \/\/ Inserting a VectorStoreMask before stitching the mask\n+  \/\/ to SafePointNode will ensure packing the mask into a\n+  \/\/ byte array for masks present in both predicated register\n+  \/\/ or vector registers.\n+  int elem_size = is_mask ? 1 : type2aelembytes(elem_bt);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"}]}