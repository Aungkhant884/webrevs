{"files":[{"patch":"@@ -88,16 +88,0 @@\n-\/\/ Entry points in zip.dll for loading zip\/jar file entries\n-\n-typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);\n-typedef void     (*ZipClose_t)(jzfile *zip);\n-typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);\n-typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);\n-typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);\n-\n-static ZipOpen_t         ZipOpen            = nullptr;\n-static ZipClose_t        ZipClose           = nullptr;\n-static FindEntry_t       FindEntry          = nullptr;\n-static ReadEntry_t       ReadEntry          = nullptr;\n-static Crc32_t           Crc32              = nullptr;\n-int    ClassLoader::_libzip_loaded          = 0;\n-void*  ClassLoader::_zip_handle             = nullptr;\n-\n@@ -295,1 +279,1 @@\n-  (*ZipClose)(_zip);\n+  ZipLibrary::close(_zip);\n@@ -304,1 +288,1 @@\n-  jzentry* entry = (*FindEntry)(_zip, name, filesize, &name_len);\n+  jzentry* entry = ZipLibrary::find_entry(_zip, name, filesize, &name_len);\n@@ -324,1 +308,3 @@\n-  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return nullptr;\n+  if (!ZipLibrary::read_entry(_zip, entry, buffer, filename)) {\n+    return nullptr;\n+  }\n@@ -727,2 +713,1 @@\n-  load_zip_library_if_needed();\n-  return (*ZipOpen)(canonical_path, error_msg);\n+  return ZipLibrary::open(canonical_path, error_msg);\n@@ -940,26 +925,0 @@\n-void ClassLoader::release_load_zip_library() {\n-  ConditionalMutexLocker locker(Zip_lock, Zip_lock != nullptr, Monitor::_no_safepoint_check_flag);\n-  if (_libzip_loaded == 0) {\n-    load_zip_library();\n-    Atomic::release_store(&_libzip_loaded, 1);\n-  }\n-}\n-\n-void ClassLoader::load_zip_library() {\n-  assert(ZipOpen == nullptr, \"should not load zip library twice\");\n-  char path[JVM_MAXPATHLEN];\n-  char ebuf[1024];\n-  if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), \"zip\")) {\n-    _zip_handle = os::dll_load(path, ebuf, sizeof ebuf);\n-  }\n-  if (_zip_handle == nullptr) {\n-    vm_exit_during_initialization(\"Unable to load zip library\", path);\n-  }\n-\n-  ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(_zip_handle, \"ZIP_Open\", path));\n-  ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(_zip_handle, \"ZIP_Close\", path));\n-  FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(_zip_handle, \"ZIP_FindEntry\", path));\n-  ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(_zip_handle, \"ZIP_ReadEntry\", path));\n-  Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(_zip_handle, \"ZIP_CRC32\", path));\n-}\n-\n@@ -985,2 +944,1 @@\n-  load_zip_library_if_needed();\n-  return (*Crc32)(crc, (const jbyte*)buf, len);\n+  return ZipLibrary::crc32(crc, (const jbyte*)buf, len);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":7,"deletions":49,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/zipLibrary.hpp\"\n@@ -87,13 +88,0 @@\n-\/\/ Type definitions for zip file and zip file entry\n-typedef void* jzfile;\n-typedef struct {\n-  char *name;                   \/* entry name *\/\n-  jlong time;                   \/* modification time *\/\n-  jlong size;                   \/* size of uncompressed data *\/\n-  jlong csize;                  \/* size of compressed data (zero if uncompressed) *\/\n-  jint crc;                     \/* crc of uncompressed data *\/\n-  char *comment;                \/* optional zip file comment *\/\n-  jbyte *extra;                 \/* optional extra data *\/\n-  jlong pos;                    \/* position of LOC header (if negative) or data *\/\n-} jzentry;\n-\n@@ -231,2 +219,0 @@\n-  \/\/ cache the zip library handle\n-  static void* _zip_handle;\n@@ -251,1 +237,0 @@\n-  static void load_zip_library();\n@@ -254,4 +239,0 @@\n- private:\n-  static int  _libzip_loaded; \/\/ used to sync loading zip.\n-  static void release_load_zip_library();\n-\n@@ -259,2 +240,1 @@\n-  static inline void load_zip_library_if_needed();\n-  static void* zip_library_handle() { return _zip_handle; }\n+  static void* zip_library_handle();\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -61,6 +61,0 @@\n-inline void ClassLoader::load_zip_library_if_needed() {\n-  if (Atomic::load_acquire(&_libzip_loaded) == 0) {\n-    release_load_zip_library();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+#include \"utilities\/zipLibrary.hpp\"\n@@ -3415,2 +3416,1 @@\n-  ClassLoader::load_zip_library_if_needed();\n-  return ClassLoader::zip_library_handle();\n+  return ZipLibrary::handle();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-Monitor* Zip_lock                     = nullptr;\n@@ -325,1 +324,0 @@\n-  MUTEX_DEFN(Zip_lock                        , PaddedMonitor, nosafepoint-1); \/\/ Holds DumpTimeTable_lock\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-extern Monitor* Zip_lock;                        \/\/ synchronize initialization of zip library\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -33,0 +30,1 @@\n+#include \"utilities\/zipLibrary.hpp\"\n@@ -65,25 +63,0 @@\n-\n-typedef char const* (*GzipInitFunc)(size_t, size_t*, size_t*, int);\n-typedef size_t(*GzipCompressFunc)(char*, size_t, char*, size_t, char*, size_t,\n-                                  int, char*, char const**);\n-\n-static GzipInitFunc gzip_init_func;\n-static GzipCompressFunc gzip_compress_func;\n-\n-void* GZipCompressor::load_gzip_func(char const* name) {\n-  char path[JVM_MAXPATHLEN];\n-  char ebuf[1024];\n-  void* handle;\n-  MutexLocker locker(Zip_lock, Monitor::_no_safepoint_check_flag);\n-\n-  if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), \"zip\")) {\n-    handle = os::dll_load(path, ebuf, sizeof ebuf);\n-\n-    if (handle != nullptr) {\n-      return os::dll_lookup(handle, name);\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n@@ -94,19 +67,2 @@\n-\n-  if (gzip_compress_func == nullptr) {\n-    gzip_compress_func = (GzipCompressFunc) load_gzip_func(\"ZIP_GZip_Fully\");\n-\n-    if (gzip_compress_func == nullptr) {\n-      return \"Cannot get ZIP_GZip_Fully function\";\n-    }\n-  }\n-\n-  if (gzip_init_func == nullptr) {\n-    gzip_init_func = (GzipInitFunc) load_gzip_func(\"ZIP_GZip_InitParams\");\n-\n-    if (gzip_init_func == nullptr) {\n-      return \"Cannot get ZIP_GZip_InitParams function\";\n-    }\n-  }\n-\n-  char const* result = gzip_init_func(block_size, needed_out_size,\n-                                      needed_tmp_size, _level);\n+  char const* result = ZipLibrary::init_params(block_size, needed_out_size,\n+                                               needed_tmp_size, _level);\n@@ -114,1 +70,0 @@\n-\n@@ -121,1 +76,0 @@\n-\n@@ -127,2 +81,1 @@\n-    *compressed_size = gzip_compress_func(in, in_size, out, out_size, tmp, tmp_size, _level,\n-                                          buf, &msg);\n+    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, buf, &msg);\n@@ -131,2 +84,1 @@\n-    *compressed_size = gzip_compress_func(in, in_size, out, out_size, tmp, tmp_size, _level,\n-                                          nullptr, &msg);\n+    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, nullptr, &msg);\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":5,"deletions":53,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +94,0 @@\n-  void* load_gzip_func(char const* name);\n-\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/semaphore.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/zipLibrary.hpp\"\n+\n+ \/\/ Entry points in zip.dll for loading zip\/jar file entries\n+typedef void**(*ZIP_Open_t)(const char* name, char** pmsg);\n+typedef void(*ZIP_Close_t)(jzfile* zip);\n+typedef jzentry* (*ZIP_FindEntry_t)(jzfile* zip, const char* name, jint* sizeP, jint* nameLen);\n+typedef jboolean(*ZIP_ReadEntry_t)(jzfile* zip, jzentry* entry, unsigned char* buf, char* namebuf);\n+typedef jint(*ZIP_CRC32_t)(jint crc, const jbyte* buf, jint len);\n+typedef const char* (*ZIP_GZip_InitParams_t)(size_t, size_t*, size_t*, int);\n+typedef size_t(*ZIP_GZip_Fully_t)(char*, size_t, char*, size_t, char*, size_t, int, char*, char const**);\n+\n+static ZIP_Open_t ZIP_Open = nullptr;\n+static ZIP_Close_t ZIP_Close = nullptr;\n+static ZIP_FindEntry_t ZIP_FindEntry = nullptr;\n+static ZIP_ReadEntry_t ZIP_ReadEntry = nullptr;\n+static ZIP_CRC32_t ZIP_CRC32 = nullptr;\n+static ZIP_GZip_InitParams_t ZIP_GZip_InitParams = nullptr;\n+static ZIP_GZip_Fully_t ZIP_GZip_Fully = nullptr;\n+\n+static void* _zip_handle = nullptr;\n+static bool _loaded = false;\n+\n+static inline bool is_loaded() {\n+  return Atomic::load_acquire(&_loaded);\n+}\n+\n+static inline bool not_loaded() {\n+  return !is_loaded();\n+}\n+\n+static void* dll_lookup(const char* name, const char* path, bool vm_exit_on_failure) {\n+  assert(_zip_handle != nullptr, \"invariant\");\n+  void* func = os::dll_lookup(_zip_handle, name);\n+  if (func == nullptr && vm_exit_on_failure) {\n+    char msg[256] = \"\";\n+    jio_snprintf(&msg[0], sizeof msg, \"Could not resolve \\\"%s\\\"\", name);\n+    vm_exit_during_initialization(&msg[0], path);\n+  }\n+  return func;\n+}\n+\n+static void store_function_pointers(const char* path, bool vm_exit_on_failure) {\n+  assert(_zip_handle != nullptr, \"invariant\");\n+  ZIP_Open = CAST_TO_FN_PTR(ZIP_Open_t, dll_lookup(\"ZIP_Open\", path, vm_exit_on_failure));\n+  ZIP_Close = CAST_TO_FN_PTR(ZIP_Close_t, dll_lookup(\"ZIP_Close\", path, vm_exit_on_failure));\n+  ZIP_FindEntry = CAST_TO_FN_PTR(ZIP_FindEntry_t, dll_lookup(\"ZIP_FindEntry\", path, vm_exit_on_failure));\n+  ZIP_ReadEntry = CAST_TO_FN_PTR(ZIP_ReadEntry_t, dll_lookup(\"ZIP_ReadEntry\", path, vm_exit_on_failure));\n+  ZIP_CRC32 = CAST_TO_FN_PTR(ZIP_CRC32_t, dll_lookup(\"ZIP_CRC32\", path, vm_exit_on_failure));\n+  \/\/ The following entry points are most likely optional from a zip library implementation perspective.\n+  \/\/ Hence no vm_exit on a resolution failure. Further refactorings should investigate this,\n+  \/\/ and if possible, streamline setting all entry points consistently.\n+  ZIP_GZip_InitParams = CAST_TO_FN_PTR(ZIP_GZip_InitParams_t, dll_lookup(\"ZIP_GZip_InitParams\", path, false));\n+  ZIP_GZip_Fully = CAST_TO_FN_PTR(ZIP_GZip_Fully_t, dll_lookup(\"ZIP_GZip_Fully\", path, false));\n+}\n+\n+static void load_zip_library(bool vm_exit_on_failure) {\n+  assert(!is_loaded(), \"should not load zip library twice\");\n+  char path[JVM_MAXPATHLEN];\n+  if (os::dll_locate_lib(&path[0], sizeof path, Arguments::get_dll_dir(), \"zip\")) {\n+    char ebuf[1024];\n+    _zip_handle = os::dll_load(&path[0], &ebuf[0], sizeof ebuf);\n+  }\n+  if (_zip_handle == nullptr) {\n+    if (vm_exit_on_failure) {\n+      vm_exit_during_initialization(\"Unable to load zip library\", &path[0]);\n+    }\n+    return;\n+  }\n+  store_function_pointers(&path[0], vm_exit_on_failure);\n+  Atomic::release_store(&_loaded, true);\n+  assert(is_loaded(), \"invariant\");\n+}\n+\n+\/\/\n+\/\/ Helper mutex class that also ensures that java threads\n+\/\/ are in _thread_in_native when loading the zip library.\n+\/\/\n+class ZipLibraryLoaderLock : public StackObj {\n+ private:\n+  static Semaphore _lock;\n+  JavaThread* _jt;\n+ public:\n+   ZipLibraryLoaderLock() : _jt(nullptr) {\n+    Thread* thread = Thread::current_or_null();\n+    if (thread != nullptr && thread->is_Java_thread()) {\n+      JavaThread* const jt = JavaThread::cast(thread);\n+      if (jt->thread_state() != _thread_in_native) {\n+        _jt = jt;\n+        ThreadStateTransition::transition_from_vm(jt, _thread_in_native, false);\n+      }\n+    }\n+    _lock.wait();\n+  }\n+  ~ZipLibraryLoaderLock() {\n+    _lock.signal();\n+    if (_jt != nullptr) {\n+      ThreadStateTransition::transition_from_native(_jt, _thread_in_vm, false);\n+    }\n+  }\n+};\n+\n+Semaphore ZipLibraryLoaderLock::_lock(1);\n+\n+static void initialize(bool vm_exit_on_failure = true) {\n+  if (is_loaded()) {\n+    return;\n+  }\n+  ZipLibraryLoaderLock lock;\n+  if (not_loaded()) {\n+    load_zip_library(vm_exit_on_failure);\n+  }\n+}\n+\n+void** ZipLibrary::open(const char* name, char** pmsg) {\n+  initialize();\n+  assert(ZIP_Open != nullptr, \"invariant\");\n+  return ZIP_Open(name, pmsg);\n+}\n+\n+void ZipLibrary::close(jzfile* zip) {\n+  assert(is_loaded(), \"invariant\");\n+  assert(ZIP_Close != nullptr, \"invariant\");\n+  ZIP_Close(zip);\n+}\n+\n+jzentry* ZipLibrary::find_entry(jzfile* zip, const char* name, jint* sizeP, jint* nameLen) {\n+  initialize();\n+  assert(ZIP_FindEntry != nullptr, \"invariant\");\n+  return ZIP_FindEntry(zip, name, sizeP, nameLen);\n+}\n+\n+jboolean ZipLibrary::read_entry(jzfile* zip, jzentry* entry, unsigned char* buf, char* namebuf) {\n+  initialize();\n+  assert(ZIP_ReadEntry != nullptr, \"invariant\");\n+  return ZIP_ReadEntry(zip, entry, buf, namebuf);\n+}\n+\n+jint ZipLibrary::crc32(jint crc, const jbyte* buf, jint len) {\n+  initialize();\n+  assert(ZIP_CRC32 != nullptr, \"invariant\");\n+  return ZIP_CRC32(crc, buf, len);\n+}\n+\n+const char* ZipLibrary::init_params(size_t block_size, size_t* needed_out_size, size_t* needed_tmp_size, int level) {\n+  initialize(false);\n+  if (ZIP_GZip_InitParams == nullptr) {\n+    return \"Cannot get ZIP_GZip_InitParams function\";\n+  }\n+  return ZIP_GZip_InitParams(block_size, needed_out_size, needed_tmp_size, level);\n+}\n+\n+size_t ZipLibrary::compress(char* in, size_t in_size, char* out, size_t out_size, char* tmp, size_t tmp_size, int level, char* buf, const char** pmsg) {\n+  initialize(false);\n+  if (ZIP_GZip_Fully == nullptr) {\n+    *pmsg = \"Cannot get ZIP_GZip_Fully function\";\n+    return 0;\n+  }\n+  return ZIP_GZip_Fully(in, in_size, out, out_size, tmp, tmp_size, level, buf, pmsg);\n+}\n+\n+void* ZipLibrary::handle() {\n+  initialize();\n+  assert(is_loaded(), \"invariant\");\n+  assert(_zip_handle != nullptr, \"invariant\");\n+  return _zip_handle;\n+}\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ZIPLIBRARY_HPP\n+#define SHARE_UTILITIES_ZIPLIBRARY_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+ \/\/ Type definitions for zip file and zip file entry\n+typedef void* jzfile;\n+typedef struct {\n+  char* name;                   \/* entry name *\/\n+  jlong time;                   \/* modification time *\/\n+  jlong size;                   \/* size of uncompressed data *\/\n+  jlong csize;                  \/* size of compressed data (zero if uncompressed) *\/\n+  jint crc;                     \/* crc of uncompressed data *\/\n+  char* comment;                \/* optional zip file comment *\/\n+  jbyte* extra;                 \/* optional extra data *\/\n+  jlong pos;                    \/* position of LOC header (if negative) or data *\/\n+} jzentry;\n+\n+class ZipLibrary : AllStatic {\n+ public:\n+  static void** open(const char* name, char** pmsg);\n+  static void close(jzfile* zip);\n+  static jzentry* find_entry(jzfile* zip, const char* name, jint* sizeP, jint* nameLen);\n+  static jboolean read_entry(jzfile* zip, jzentry* entry, unsigned char* buf, char* namebuf);\n+  static jint crc32(jint crc, const jbyte* buf, jint len);\n+  static const char* init_params(size_t block_size, size_t* needed_out_size, size_t* needed_tmp_size, int level);\n+  static size_t compress(char* in, size_t in_size, char* out, size_t out_size, char* tmp, size_t tmp_size, int level, char* buf, const char** pmsg);\n+  static void* handle();\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ZIPLIBRARY_HPP\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}