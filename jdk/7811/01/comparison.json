{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8283122\n@@ -39,0 +40,1 @@\n+import java.nio.ByteOrder;\n@@ -44,0 +46,2 @@\n+    static final boolean IS_BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n+\n@@ -107,0 +111,4 @@\n+        \/\/ On LE systems, low-order bytes of long and int overlap, but\n+        \/\/ on BE systems, they differ by the size of an int.\n+        long mismatchedOffset = Unsafe.ARRAY_LONG_BASE_OFFSET + (IS_BIG_ENDIAN ? 4 : 0);\n+\n@@ -108,1 +116,1 @@\n-                          dstArrL, Unsafe.ARRAY_LONG_BASE_OFFSET, 4); \/\/ mismatched\n+                          dstArrL, mismatchedOffset, 4); \/\/ mismatched\n@@ -159,0 +167,1 @@\n+        srcOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n@@ -182,0 +191,1 @@\n+        dstOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeCopyMemory.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}