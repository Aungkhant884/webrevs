{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.nio.ByteOrder;\n@@ -44,0 +45,2 @@\n+    static final boolean IS_BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n+\n@@ -107,0 +110,4 @@\n+        \/\/ On LE systems, low-order bytes of long and int overlap, but\n+        \/\/ on BE systems, they differ by the size of an int.\n+        long mismatchedOffset = Unsafe.ARRAY_LONG_BASE_OFFSET + (IS_BIG_ENDIAN ? 4 : 0);\n+\n@@ -108,1 +115,1 @@\n-                          dstArrL, Unsafe.ARRAY_LONG_BASE_OFFSET, 4); \/\/ mismatched\n+                          dstArrL, mismatchedOffset, 4); \/\/ mismatched\n@@ -159,0 +166,1 @@\n+        srcOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n@@ -182,0 +190,1 @@\n+        dstOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeCopyMemory.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}