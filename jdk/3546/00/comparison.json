{"files":[{"patch":"@@ -150,0 +150,1 @@\n+        java.instrument,\n@@ -177,0 +178,1 @@\n+        java.instrument,\n@@ -193,0 +195,1 @@\n+        java.instrument,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -538,0 +538,44 @@\n+    \/**\n+     * Defines a new class or interface for the given class loader using the specified\n+     * class file. This has the same effect as if calling\n+     * {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.\n+     *\n+     * <p> The {@code bytes} parameter is the class bytes of a valid class file (as defined\n+     * by the <em>The Java Virtual Machine Specification<\/em>) with a class name in the\n+     * same package as the lookup class. <\/p>\n+     *\n+     * <p> This method does not run the class initializer. The class initializer may\n+     * run at a later time, as detailed in section 12.4 of the <em>The Java Language\n+     * Specification<\/em>. <\/p>\n+     *\n+     * <p>\n+     * <cite>The Java Virtual Machine Specification<\/cite>\n+     * specifies that a subsequent attempt to resolve a symbolic\n+     * reference that the Java virtual machine has previously unsuccessfully attempted\n+     * to resolve always fails with the same error that was thrown as a result of the\n+     * initial resolution attempt. Consequently, if the JAR file contains an entry\n+     * that corresponds to a class for which the Java virtual machine has\n+     * unsuccessfully attempted to resolve a reference, then subsequent attempts to\n+     * resolve that reference will fail with the same error as the initial attempt.\n+     *\n+     * @param loader The class loader in which the class is to be defined. This might\n+     *               be {@code null} to represent the bootstrap class loader.\n+     * @param pd    The class's protection domain or {@code null} for defining a\n+     *              default protection domain with all permissions.\n+     * @param bytes The class file of the class that is being defined.\n+     * @throws java.lang.NullPointerException if passed <code>null<\/code> for the\n+     * class file\n+     * @throws java.lang.ClassFormatError if passed an invalid class file.\\\n+     * @throws java.lang.IllegalArgumentException if passed a non-injectable class\n+     * file, for example a module-info\n+     * @throws java.lang.UnsupportedClassVersionError if passed a class file in a\n+     * version that the current VM does not support.\n+     * @throws VerifyError if the newly created class cannot be verified\n+     * @throws LinkageError if a class with the same name already was defined by\n+     * the targeted class loader or if the class cannot be linked for any other reason\n+     * @return The class that has been defined.\n+     *\n+     * @since 17\n+     *\/\n+    Class<?> defineClass(ClassLoader loader, ProtectionDomain pd, byte[] bytes);\n+\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/Instrumentation.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.VM;\n@@ -48,0 +50,3 @@\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -329,0 +334,61 @@\n+    @Override\n+    public Class<?> defineClass(ClassLoader loader, ProtectionDomain pd, byte[] bytes) {\n+        int magic = readInt(bytes, 0);\n+        if (magic != 0xCAFEBABE) {\n+            throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n+        }\n+        int minor = readUnsignedShort(bytes, 4);\n+        int major = readUnsignedShort(bytes, 6);\n+        if (!VM.isSupportedClassFileVersion(major, minor)) {\n+            throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n+        }\n+\n+        String name;\n+        int accessFlags;\n+        try {\n+            ClassReader reader = new ClassReader(bytes);\n+            \/\/ ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info\n+            \/\/ workaround to read `this_class` using readConst and validate the value\n+            int thisClass = reader.readUnsignedShort(reader.header + 2);\n+            Object constant = reader.readConst(thisClass, new char[reader.getMaxStringLength()]);\n+            if (!(constant instanceof Type type)) {\n+                throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n+            }\n+            if (!type.getDescriptor().startsWith(\"L\")) {\n+                throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n+            }\n+            name = type.getClassName();\n+            accessFlags = reader.readUnsignedShort(reader.header);\n+        } catch (RuntimeException e) {\n+            \/\/ ASM exceptions are poorly specified\n+            ClassFormatError cfe = new ClassFormatError();\n+            cfe.initCause(e);\n+            throw cfe;\n+        }\n+\n+        \/\/ must be a class or interface\n+        if ((accessFlags & Opcodes.ACC_MODULE) != 0) {\n+            throw new IllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n+        }\n+\n+        return SharedSecrets.getJavaLangAccess()\n+                .defineClass(loader, name, bytes, pd, \"__instrumentation_defined__\");\n+    }\n+\n+    private static int readInt(byte[] bytes, int offset) {\n+        if ((offset+4) > bytes.length) {\n+            throw new ClassFormatError(\"Invalid ClassFile structure\");\n+        }\n+        return ((bytes[offset] & 0xFF) << 24)\n+                | ((bytes[offset + 1] & 0xFF) << 16)\n+                | ((bytes[offset + 2] & 0xFF) << 8)\n+                | (bytes[offset + 3] & 0xFF);\n+    }\n+\n+    private static int readUnsignedShort(byte[] bytes, int offset) {\n+        if ((offset+2) > bytes.length) {\n+            throw new ClassFormatError(\"Invalid ClassFile structure\");\n+        }\n+        return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n+    }\n+\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8200559\n+ * @summary Test class definition by use of instrumentation API.\n+ * @library \/test\/lib\n+ * @modules java.instrument\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm -javaagent:redefineagent.jar DefineClassInstrumentation\n+ *\/\n+\n+import java.io.InputStream;\n+import java.lang.instrument.Instrumentation;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.security.AllPermission;\n+import java.security.ProtectionDomain;\n+\n+public class DefineClassInstrumentation {\n+\n+    public static void main(String[] unused) throws Throwable {\n+        doDefine(null);\n+        doDefine(new ProtectionDomain(null, null));\n+    }\n+\n+    private static void doDefine(ProtectionDomain pd) {\n+        try {\n+            URLClassLoader loader = new URLClassLoader(new URL[0], null);\n+\n+            byte[] classFile;\n+            try (InputStream inputStream = DefineClassInstrumentation.class.getResourceAsStream(\"DefineClassInstrumentation.class\")) {\n+                classFile = inputStream.readAllBytes();\n+            }\n+            Class<?> c = RedefineClassHelper.instrumentation.defineClass(loader, pd, classFile);\n+            if (c == DefineClassInstrumentation.class) {\n+                throw new RuntimeException(\"Class defined by system loader\");\n+            }\n+            if (pd == null) {\n+                if (!c.getProtectionDomain().getPermissions().implies(new AllPermission())) {\n+                    throw new RuntimeException(\"Protection domain not set to default protection domain\");\n+                }\n+            } else if (pd != c.getProtectionDomain()) {\n+                throw new RuntimeException(\"Protection domain not set correctly\");\n+            }\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new RuntimeException(\"Failed class definition\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/DefineClass\/DefineClassInstrumentation.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}