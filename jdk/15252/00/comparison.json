{"files":[{"patch":"@@ -115,1 +115,10 @@\n-        for (int i=0; i < count; ++i) {\n+        return !non0AfterIndex(0);\n+    }\n+\n+\n+    \/**\n+     * Return true if there exists a non-zero digit in the digit list\n+     * from the given index until the end.\n+     *\/\n+    private boolean non0AfterIndex(int index) {\n+        for (int i=index; i < count; ++i) {\n@@ -117,1 +126,1 @@\n-                return false;\n+                return true;\n@@ -120,1 +129,1 @@\n-        return true;\n+        return false;\n@@ -193,3 +202,1 @@\n-        for (int i = count; i < decimalAt; ++i) {\n-            temp.append('0');\n-        }\n+        temp.append(\"0\".repeat(Math.max(0, decimalAt - count)));\n@@ -397,0 +404,13 @@\n+     * This method is reserved for Long and BigInteger representations.\n+     * @param maximumDigits The maximum number of digits to be shown.\n+     *\n+     * Upon return, count will be less than or equal to maximumDigits.\n+     *\/\n+    private void round(int maximumDigits) {\n+        \/\/ Integers do not need to worry about double rounding\n+        round(maximumDigits, false, true);\n+    }\n+\n+    \/**\n+     * Round the representation to the given number of digits.\n+     * This method is reserved for Double and BigDecimal representations.\n@@ -411,19 +431,2 @@\n-                \/\/ Rounding up involved incrementing digits from LSD to MSD.\n-                \/\/ In most cases this is simple, but in a worst case situation\n-                \/\/ (9999..99) we have to adjust the decimalAt value.\n-                for (;;) {\n-                    --maximumDigits;\n-                    if (maximumDigits < 0) {\n-                        \/\/ We have all 9's, so we increment to a single digit\n-                        \/\/ of one and adjust the exponent.\n-                        digits[0] = '1';\n-                        ++decimalAt;\n-                        maximumDigits = 0; \/\/ Adjust the count\n-                        break;\n-                    }\n-\n-                    ++digits[maximumDigits];\n-                    if (digits[maximumDigits] <= '9') break;\n-                    \/\/ digits[maximumDigits] = '0'; \/\/ Unnecessary since we'll truncate this\n-                }\n-                ++maximumDigits; \/\/ Increment for use as count\n+                \/\/ Rounding can adjust the max digits\n+                maximumDigits = roundUp(maximumDigits);\n@@ -511,6 +514,1 @@\n-                for (int i=maximumDigits; i<count; ++i) {\n-                    if (digits[i] != '0') {\n-                        return true;\n-                    }\n-                }\n-                break;\n+                return non0AfterIndex(maximumDigits);\n@@ -520,6 +518,0 @@\n-                for (int i=maximumDigits; i<count; ++i) {\n-                    if (digits[i] != '0') {\n-                        return !isNegative;\n-                    }\n-                }\n-                break;\n@@ -527,4 +519,3 @@\n-                for (int i=maximumDigits; i<count; ++i) {\n-                    if (digits[i] != '0') {\n-                        return isNegative;\n-                    }\n+                if (non0AfterIndex(maximumDigits)) {\n+                    return (isNegative && roundingMode == RoundingMode.FLOOR)\n+                            || (!isNegative && roundingMode == RoundingMode.CEILING);\n@@ -535,7 +526,3 @@\n-                if (digits[maximumDigits] > '5') {\n-                    \/\/ Value is above tie ==> must round up\n-                    return true;\n-                } else if (digits[maximumDigits] == '5') {\n-                    \/\/ Digit at rounding position is a '5'. Tie cases.\n-                    if (maximumDigits != (count - 1)) {\n-                        \/\/ There are remaining digits. Above tie => must round up\n+                case HALF_EVEN:\n+                    \/\/ Above tie, round up for all cases\n+                    if (digits[maximumDigits] > '5') {\n@@ -543,45 +530,14 @@\n-                    } else {\n-                        \/\/ Digit at rounding position is the last one !\n-                        if (valueExactAsDecimal) {\n-                            \/\/ Exact binary representation. On the tie.\n-                            \/\/ Apply rounding given by roundingMode.\n-                            return roundingMode == RoundingMode.HALF_UP;\n-                        } else {\n-                            \/\/ Not an exact binary representation.\n-                            \/\/ Digit sequence either rounded up or truncated.\n-                            \/\/ Round up only if it was truncated.\n-                            return !alreadyRounded;\n-                        }\n-                    }\n-                }\n-                \/\/ Digit at rounding position is < '5' ==> no round up.\n-                \/\/ Just let do the default, which is no round up (thus break).\n-                break;\n-            case HALF_EVEN:\n-                \/\/ Implement IEEE half-even rounding\n-                if (digits[maximumDigits] > '5') {\n-                    return true;\n-                } else if (digits[maximumDigits] == '5' ) {\n-                    if (maximumDigits == (count - 1)) {\n-                        \/\/ the rounding position is exactly the last index :\n-                        if (alreadyRounded)\n-                            \/\/ If FloatingDecimal rounded up (value was below tie),\n-                            \/\/ then we should not round up again.\n-                            return false;\n-\n-                        if (!valueExactAsDecimal)\n-                            \/\/ Otherwise if the digits don't represent exact value,\n-                            \/\/ value was above tie and FloatingDecimal truncated\n-                            \/\/ digits to tie. We must round up.\n-                            return true;\n-                        else {\n-                            \/\/ This is an exact tie value, and FloatingDecimal\n-                            \/\/ provided all of the exact digits. We thus apply\n-                            \/\/ HALF_EVEN rounding rule.\n-                            return ((maximumDigits > 0) &&\n-                                    (digits[maximumDigits-1] % 2 != 0));\n-                        }\n-                    } else {\n-                        \/\/ Rounds up if it gives a non null digit after '5'\n-                        for (int i=maximumDigits+1; i<count; ++i) {\n-                            if (digits[i] != '0')\n+                        \/\/ At tie, consider UP, DOWN, and EVEN logic\n+                    } else if (digits[maximumDigits] == '5' ) {\n+                        \/\/ Rounding position is the last index, there are 3 Cases.\n+                        if (maximumDigits == (count - 1)) {\n+                            \/\/ Do not round twice\n+                            if (alreadyRounded) {\n+                                return false;\n+                                \/\/ When exact, consider specific contract logic\n+                            } else if (valueExactAsDecimal) {\n+                                return (roundingMode == RoundingMode.HALF_UP) ||\n+                                        (roundingMode == RoundingMode.HALF_EVEN\n+                                                && (maximumDigits > 0) && (digits[maximumDigits - 1] % 2 != 0));\n+                                \/\/ Not already rounded, and not exact, round up\n+                            } else {\n@@ -589,0 +545,5 @@\n+                            }\n+                            \/\/ Rounding position is not the last index\n+                            \/\/ If any further digits have a non-zero value, round up\n+                        } else {\n+                            return non0AfterIndex(maximumDigits+1);\n@@ -591,6 +552,5 @@\n-                }\n-                break;\n-            case UNNECESSARY:\n-                for (int i=maximumDigits; i<count; ++i) {\n-                    if (digits[i] != '0') {\n-                        throw new ArithmeticException(\n+                    \/\/ Below tie, do not round up for all cases\n+                    break;\n+                case UNNECESSARY:\n+                if (non0AfterIndex(maximumDigits)) {\n+                    throw new ArithmeticException(\n@@ -598,1 +558,0 @@\n-                    }\n@@ -608,0 +567,27 @@\n+    \/**\n+     * Round the digit list up numerically.\n+     * This involves incrementing digits from the LSD to the MSD.\n+     * @param maximumDigits The maximum number of digits to be shown.\n+     * @return The new maximum digits after rounding.\n+     *\/\n+    private int roundUp(int maximumDigits) {\n+        do {\n+            --maximumDigits;\n+            \/*\n+             * We have exhausted the max digits while attempting to round up\n+             * from the LSD to the MSD. This implies a value of all 9's. As such,\n+             * adjust representation to a single digit of one and increment the exponent.\n+             *\/\n+            if (maximumDigits < 0) {\n+                digits[0] = '1';\n+                ++decimalAt;\n+                maximumDigits = 0; \/\/ Adjust the count\n+                break;\n+            }\n+            ++digits[maximumDigits];\n+        }\n+        while (digits[maximumDigits] > '9');\n+\n+        return ++maximumDigits; \/\/ Increment for use as count\n+    }\n+\n@@ -652,2 +638,4 @@\n-            for (right = MAX_COUNT - 1; digits[right] == '0'; --right)\n-                ;\n+            right = MAX_COUNT - 1;\n+            while (digits[right] == '0') {\n+                --right;\n+            }\n@@ -657,1 +645,3 @@\n-        if (maximumDigits > 0) round(maximumDigits, false, true);\n+        if (maximumDigits > 0) {\n+            round(maximumDigits);\n+        }\n@@ -695,3 +685,4 @@\n-        int right;\n-        for (right = len - 1; right >= 0 && digits[right] == '0'; --right)\n-            ;\n+        int right = len - 1;\n+        while (right >= 0 && digits[right] == '0') {\n+            --right;\n+        }\n@@ -701,1 +692,1 @@\n-            round(maximumDigits, false, true);\n+            round(maximumDigits);\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":98,"deletions":107,"binary":false,"changes":205,"status":"modified"}]}