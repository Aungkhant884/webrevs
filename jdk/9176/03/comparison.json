{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/bitMap.hpp\"\n@@ -373,12 +372,0 @@\n-\/\/ Dispatches to the non-virtual functions if OopClosureType has\n-\/\/ a concrete implementation, otherwise a virtual call is taken.\n-class Devirtualizer {\n- public:\n-  template <typename OopClosureType, typename T> static void do_oop(OopClosureType* closure, T* p);\n-  template <typename OopClosureType>             static void do_klass(OopClosureType* closure, Klass* k);\n-  template <typename OopClosureType>             static void do_cld(OopClosureType* closure, ClassLoaderData* cld);\n-  template <typename OopClosureType>             static bool do_metadata(OopClosureType* closure);\n-  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived);\n-  template <typename BitMapClosureType>          static bool do_bit(BitMapClosureType* closure, BitMap::idx_t index);\n-};\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,136 +66,0 @@\n-\/\/ Implementation of the non-virtual do_oop dispatch.\n-\/\/\n-\/\/ The same implementation is used for do_metadata, do_klass, and do_cld.\n-\/\/\n-\/\/ Preconditions:\n-\/\/  - Base has a pure virtual do_oop\n-\/\/  - Only one of the classes in the inheritance chain from OopClosureType to\n-\/\/    Base implements do_oop.\n-\/\/\n-\/\/ Given the preconditions:\n-\/\/  - If &OopClosureType::do_oop is resolved to &Base::do_oop, then there is no\n-\/\/    implementation of do_oop between Base and OopClosureType. However, there\n-\/\/    must be one implementation in one of the subclasses of OopClosureType.\n-\/\/    In this case we take the virtual call.\n-\/\/\n-\/\/  - Conversely, if &OopClosureType::do_oop is not resolved to &Base::do_oop,\n-\/\/    then we've found the one and only concrete implementation. In this case we\n-\/\/    take a non-virtual call.\n-\/\/\n-\/\/ Because of this it's clear when we should call the virtual call and\n-\/\/   when the non-virtual call should be made.\n-\/\/\n-\/\/ The way we find if &OopClosureType::do_oop is resolved to &Base::do_oop is to\n-\/\/   check if the resulting type of the class of a member-function pointer to\n-\/\/   &OopClosureType::do_oop is equal to the type of the class of a\n-\/\/   &Base::do_oop member-function pointer. Template parameter deduction is used\n-\/\/   to find these types, and then the IsSame trait is used to check if they are\n-\/\/   equal. Finally, SFINAE is used to select the appropriate implementation.\n-\/\/\n-\/\/ Template parameters:\n-\/\/   T              - narrowOop or oop\n-\/\/   Receiver       - the resolved type of the class of the\n-\/\/                    &OopClosureType::do_oop member-function pointer. That is,\n-\/\/                    the klass with the do_oop member function.\n-\/\/   Base           - klass with the pure virtual do_oop member function.\n-\/\/   OopClosureType - The dynamic closure type\n-\/\/\n-\/\/ Parameters:\n-\/\/   closure - The closure to call\n-\/\/   p       - The oop (or narrowOop) field to pass to the closure\n-\n-template <typename T, typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n-  closure->do_oop(p);\n-}\n-\n-template <typename T, typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n-  \/\/ Sanity check\n-  STATIC_ASSERT((!IsSame<OopClosureType, OopIterateClosure>::value));\n-  closure->OopClosureType::do_oop(p);\n-}\n-\n-template <typename OopClosureType, typename T>\n-inline void Devirtualizer::do_oop(OopClosureType* closure, T* p) {\n-  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n-}\n-\n-\/\/ Implementation of the non-virtual do_metadata dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, bool>::type\n-call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n-  return closure->do_metadata();\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, bool>::type\n-call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n-  return closure->OopClosureType::do_metadata();\n-}\n-\n-template <typename OopClosureType>\n-inline bool Devirtualizer::do_metadata(OopClosureType* closure) {\n-  return call_do_metadata(&OopClosureType::do_metadata, &OopIterateClosure::do_metadata, closure);\n-}\n-\n-\/\/ Implementation of the non-virtual do_klass dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n-  closure->do_klass(k);\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n-  closure->OopClosureType::do_klass(k);\n-}\n-\n-template <typename OopClosureType>\n-inline void Devirtualizer::do_klass(OopClosureType* closure, Klass* k) {\n-  call_do_klass(&OopClosureType::do_klass, &OopIterateClosure::do_klass, closure, k);\n-}\n-\n-\/\/ Implementation of the non-virtual do_cld dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n-  closure->do_cld(cld);\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n-  closure->OopClosureType::do_cld(cld);\n-}\n-\n-template <typename OopClosureType>\n-void Devirtualizer::do_cld(OopClosureType* closure, ClassLoaderData* cld) {\n-  call_do_cld(&OopClosureType::do_cld, &OopIterateClosure::do_cld, closure, cld);\n-}\n-\n-\/\/ Implementation of the non-virtual do_derived_oop dispatch.\n-\n-template <typename Receiver, typename Base, typename DerivedOopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  closure->do_derived_oop(base, derived);\n-}\n-\n-template <typename Receiver, typename Base, typename DerivedOopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  closure->DerivedOopClosureType::do_derived_oop(base, derived);\n-}\n-\n-template <typename DerivedOopClosureType>\n-inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  call_do_derived_oop(&DerivedOopClosureType::do_derived_oop, &DerivedOopClosure::do_derived_oop, closure, base, derived);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":0,"deletions":136,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n@@ -50,0 +49,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_DEVIRTUALIZER_HPP\n+#define SHARE_UTILITIES_DEVIRTUALIZER_HPP\n+\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+\n+class ClassLoaderData;\n+\n+\/\/ Dispatches to the non-virtual functions if OopClosureType has\n+\/\/ a concrete implementation, otherwise a virtual call is taken.\n+class Devirtualizer {\n+ public:\n+  template <typename OopClosureType, typename T> static void do_oop(OopClosureType* closure, T* p);\n+  template <typename OopClosureType>             static void do_klass(OopClosureType* closure, Klass* k);\n+  template <typename OopClosureType>             static void do_cld(OopClosureType* closure, ClassLoaderData* cld);\n+  template <typename OopClosureType>             static bool do_metadata(OopClosureType* closure);\n+  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived);\n+  template <typename BitMapClosureType>          static bool do_bit(BitMapClosureType* closure, BitMap::idx_t index);\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_DEVIRTUALIZER_HPP\n","filename":"src\/hotspot\/share\/utilities\/devirtualizer.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_DEVIRTUALIZER_INLINE_HPP\n+#define SHARE_UTILITIES_DEVIRTUALIZER_INLINE_HPP\n+\n+#include \"utilities\/devirtualizer.hpp\"\n+\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Implementation of the non-virtual do_oop dispatch.\n+\/\/\n+\/\/ The same implementation is used for do_metadata, do_klass, and do_cld.\n+\/\/\n+\/\/ Preconditions:\n+\/\/  - Base has a pure virtual do_oop\n+\/\/  - Only one of the classes in the inheritance chain from OopClosureType to\n+\/\/    Base implements do_oop.\n+\/\/\n+\/\/ Given the preconditions:\n+\/\/  - If &OopClosureType::do_oop is resolved to &Base::do_oop, then there is no\n+\/\/    implementation of do_oop between Base and OopClosureType. However, there\n+\/\/    must be one implementation in one of the subclasses of OopClosureType.\n+\/\/    In this case we take the virtual call.\n+\/\/\n+\/\/  - Conversely, if &OopClosureType::do_oop is not resolved to &Base::do_oop,\n+\/\/    then we've found the one and only concrete implementation. In this case we\n+\/\/    take a non-virtual call.\n+\/\/\n+\/\/ Because of this it's clear when we should call the virtual call and\n+\/\/   when the non-virtual call should be made.\n+\/\/\n+\/\/ The way we find if &OopClosureType::do_oop is resolved to &Base::do_oop is to\n+\/\/   check if the resulting type of the class of a member-function pointer to\n+\/\/   &OopClosureType::do_oop is equal to the type of the class of a\n+\/\/   &Base::do_oop member-function pointer. Template parameter deduction is used\n+\/\/   to find these types, and then the IsSame trait is used to check if they are\n+\/\/   equal. Finally, SFINAE is used to select the appropriate implementation.\n+\/\/\n+\/\/ Template parameters:\n+\/\/   T              - narrowOop or oop\n+\/\/   Receiver       - the resolved type of the class of the\n+\/\/                    &OopClosureType::do_oop member-function pointer. That is,\n+\/\/                    the klass with the do_oop member function.\n+\/\/   Base           - klass with the pure virtual do_oop member function.\n+\/\/   OopClosureType - The dynamic closure type\n+\/\/\n+\/\/ Parameters:\n+\/\/   closure - The closure to call\n+\/\/   p       - The oop (or narrowOop) field to pass to the closure\n+\n+template <typename T, typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n+  closure->do_oop(p);\n+}\n+\n+template <typename T, typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n+  \/\/ Sanity check\n+  STATIC_ASSERT((!IsSame<OopClosureType, OopIterateClosure>::value));\n+  closure->OopClosureType::do_oop(p);\n+}\n+\n+template <typename OopClosureType, typename T>\n+inline void Devirtualizer::do_oop(OopClosureType* closure, T* p) {\n+  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n+}\n+\n+\/\/ Implementation of the non-virtual do_metadata dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, bool>::type\n+call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n+  return closure->do_metadata();\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, bool>::type\n+call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n+  return closure->OopClosureType::do_metadata();\n+}\n+\n+template <typename OopClosureType>\n+inline bool Devirtualizer::do_metadata(OopClosureType* closure) {\n+  return call_do_metadata(&OopClosureType::do_metadata, &OopIterateClosure::do_metadata, closure);\n+}\n+\n+\/\/ Implementation of the non-virtual do_klass dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n+  closure->do_klass(k);\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n+  closure->OopClosureType::do_klass(k);\n+}\n+\n+template <typename OopClosureType>\n+inline void Devirtualizer::do_klass(OopClosureType* closure, Klass* k) {\n+  call_do_klass(&OopClosureType::do_klass, &OopIterateClosure::do_klass, closure, k);\n+}\n+\n+\/\/ Implementation of the non-virtual do_cld dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n+  closure->do_cld(cld);\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n+  closure->OopClosureType::do_cld(cld);\n+}\n+\n+template <typename OopClosureType>\n+void Devirtualizer::do_cld(OopClosureType* closure, ClassLoaderData* cld) {\n+  call_do_cld(&OopClosureType::do_cld, &OopIterateClosure::do_cld, closure, cld);\n+}\n+\n+\/\/ Implementation of the non-virtual do_derived_oop dispatch.\n+\n+template <typename Receiver, typename Base, typename DerivedOopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  closure->do_derived_oop(base, derived);\n+}\n+\n+template <typename Receiver, typename Base, typename DerivedOopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  closure->DerivedOopClosureType::do_derived_oop(base, derived);\n+}\n+\n+template <typename DerivedOopClosureType>\n+inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  call_do_derived_oop(&DerivedOopClosureType::do_derived_oop, &DerivedOopClosure::do_derived_oop, closure, base, derived);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_DEVIRTUALIZER_INLINE_HPP\n+\n","filename":"src\/hotspot\/share\/utilities\/devirtualizer.inline.hpp","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"}]}