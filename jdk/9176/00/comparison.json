{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_SERIALIZECLOSURE_HPP\n+#define SHARE_CDS_SERIALIZECLOSURE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ Abstract closure for serializing data (read or write).\n+\n+class SerializeClosure : public StackObj {\n+public:\n+  \/\/ Return bool indicating whether closure implements read or write.\n+  virtual bool reading() const = 0;\n+\n+  \/\/ Read\/write the void pointer pointed to by p.\n+  virtual void do_ptr(void** p) = 0;\n+\n+  \/\/ Read\/write the 32-bit unsigned integer pointed to by p.\n+  virtual void do_u4(u4* p) = 0;\n+\n+  \/\/ Read\/write the bool pointed to by p.\n+  virtual void do_bool(bool* p) = 0;\n+\n+  \/\/ Read\/write the region specified.\n+  virtual void do_region(u_char* start, size_t size) = 0;\n+\n+  \/\/ Check\/write the tag.  If reading, then compare the tag against\n+  \/\/ the passed in value and fail is they don't match.  This allows\n+  \/\/ for verification that sections of the serialized data are of the\n+  \/\/ correct length.\n+  virtual void do_tag(int tag) = 0;\n+\n+  \/\/ Read\/write the oop\n+  virtual void do_oop(oop* o) = 0;\n+\n+  bool writing() {\n+    return !reading();\n+  }\n+};\n+\n+#endif \/\/ SHARE_CDS_SERIALIZECLOSURE_HPP\n+\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class SerializeClosure;\n+\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_DEVIRTUALIZER_HPP\n+#define SHARE_MEMORY_DEVIRTUALIZER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+\n+\/\/ Dispatches to the non-virtual functions if OopClosureType has\n+\/\/ a concrete implementation, otherwise a virtual call is taken.\n+class Devirtualizer {\n+ public:\n+  template <typename OopClosureType, typename T> static void do_oop(OopClosureType* closure, T* p);\n+  template <typename OopClosureType>             static void do_klass(OopClosureType* closure, Klass* k);\n+  template <typename OopClosureType>             static void do_cld(OopClosureType* closure, ClassLoaderData* cld);\n+  template <typename OopClosureType>             static bool do_metadata(OopClosureType* closure);\n+  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived);\n+  template <typename BitMapClosureType>          static bool do_bit(BitMapClosureType* closure, BitMap::idx_t index);\n+};\n+\n+#endif \/\/ SHARE_MEMORY_DEVIRTUALIZER_HPP\n","filename":"src\/hotspot\/share\/memory\/devirtualizer.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_DEVIRTUALIZER_INLINE_HPP\n+#define SHARE_MEMORY_DEVIRTUALIZER_INLINE_HPP\n+\n+#include \"memory\/devirtualizer.hpp\"\n+\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Implementation of the non-virtual do_oop dispatch.\n+\/\/\n+\/\/ The same implementation is used for do_metadata, do_klass, and do_cld.\n+\/\/\n+\/\/ Preconditions:\n+\/\/  - Base has a pure virtual do_oop\n+\/\/  - Only one of the classes in the inheritance chain from OopClosureType to\n+\/\/    Base implements do_oop.\n+\/\/\n+\/\/ Given the preconditions:\n+\/\/  - If &OopClosureType::do_oop is resolved to &Base::do_oop, then there is no\n+\/\/    implementation of do_oop between Base and OopClosureType. However, there\n+\/\/    must be one implementation in one of the subclasses of OopClosureType.\n+\/\/    In this case we take the virtual call.\n+\/\/\n+\/\/  - Conversely, if &OopClosureType::do_oop is not resolved to &Base::do_oop,\n+\/\/    then we've found the one and only concrete implementation. In this case we\n+\/\/    take a non-virtual call.\n+\/\/\n+\/\/ Because of this it's clear when we should call the virtual call and\n+\/\/   when the non-virtual call should be made.\n+\/\/\n+\/\/ The way we find if &OopClosureType::do_oop is resolved to &Base::do_oop is to\n+\/\/   check if the resulting type of the class of a member-function pointer to\n+\/\/   &OopClosureType::do_oop is equal to the type of the class of a\n+\/\/   &Base::do_oop member-function pointer. Template parameter deduction is used\n+\/\/   to find these types, and then the IsSame trait is used to check if they are\n+\/\/   equal. Finally, SFINAE is used to select the appropriate implementation.\n+\/\/\n+\/\/ Template parameters:\n+\/\/   T              - narrowOop or oop\n+\/\/   Receiver       - the resolved type of the class of the\n+\/\/                    &OopClosureType::do_oop member-function pointer. That is,\n+\/\/                    the klass with the do_oop member function.\n+\/\/   Base           - klass with the pure virtual do_oop member function.\n+\/\/   OopClosureType - The dynamic closure type\n+\/\/\n+\/\/ Parameters:\n+\/\/   closure - The closure to call\n+\/\/   p       - The oop (or narrowOop) field to pass to the closure\n+\n+template <typename T, typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n+  closure->do_oop(p);\n+}\n+\n+template <typename T, typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n+  \/\/ Sanity check\n+  STATIC_ASSERT((!IsSame<OopClosureType, OopIterateClosure>::value));\n+  closure->OopClosureType::do_oop(p);\n+}\n+\n+template <typename OopClosureType, typename T>\n+inline void Devirtualizer::do_oop(OopClosureType* closure, T* p) {\n+  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n+}\n+\n+\/\/ Implementation of the non-virtual do_metadata dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, bool>::type\n+call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n+  return closure->do_metadata();\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, bool>::type\n+call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n+  return closure->OopClosureType::do_metadata();\n+}\n+\n+template <typename OopClosureType>\n+inline bool Devirtualizer::do_metadata(OopClosureType* closure) {\n+  return call_do_metadata(&OopClosureType::do_metadata, &OopIterateClosure::do_metadata, closure);\n+}\n+\n+\/\/ Implementation of the non-virtual do_klass dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n+  closure->do_klass(k);\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n+  closure->OopClosureType::do_klass(k);\n+}\n+\n+template <typename OopClosureType>\n+inline void Devirtualizer::do_klass(OopClosureType* closure, Klass* k) {\n+  call_do_klass(&OopClosureType::do_klass, &OopIterateClosure::do_klass, closure, k);\n+}\n+\n+\/\/ Implementation of the non-virtual do_cld dispatch.\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n+  closure->do_cld(cld);\n+}\n+\n+template <typename Receiver, typename Base, typename OopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n+  closure->OopClosureType::do_cld(cld);\n+}\n+\n+template <typename OopClosureType>\n+void Devirtualizer::do_cld(OopClosureType* closure, ClassLoaderData* cld) {\n+  call_do_cld(&OopClosureType::do_cld, &OopIterateClosure::do_cld, closure, cld);\n+}\n+\n+\/\/ Implementation of the non-virtual do_derived_oop dispatch.\n+\n+template <typename Receiver, typename Base, typename DerivedOopClosureType>\n+static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n+call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  closure->do_derived_oop(base, derived);\n+}\n+\n+template <typename Receiver, typename Base, typename DerivedOopClosureType>\n+static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n+call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  closure->DerivedOopClosureType::do_derived_oop(base, derived);\n+}\n+\n+template <typename DerivedOopClosureType>\n+inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+  call_do_derived_oop(&DerivedOopClosureType::do_derived_oop, &DerivedOopClosure::do_derived_oop, closure, base, derived);\n+}\n+\n+#endif \/\/ SHARE_MEMORY_DEVIRTUALIZER_INLINE_HPP\n+\n","filename":"src\/hotspot\/share\/memory\/devirtualizer.inline.hpp","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/bitMap.hpp\"\n@@ -329,33 +328,0 @@\n-\/\/ Abstract closure for serializing data (read or write).\n-\n-class SerializeClosure : public Closure {\n-public:\n-  \/\/ Return bool indicating whether closure implements read or write.\n-  virtual bool reading() const = 0;\n-\n-  \/\/ Read\/write the void pointer pointed to by p.\n-  virtual void do_ptr(void** p) = 0;\n-\n-  \/\/ Read\/write the 32-bit unsigned integer pointed to by p.\n-  virtual void do_u4(u4* p) = 0;\n-\n-  \/\/ Read\/write the bool pointed to by p.\n-  virtual void do_bool(bool* p) = 0;\n-\n-  \/\/ Read\/write the region specified.\n-  virtual void do_region(u_char* start, size_t size) = 0;\n-\n-  \/\/ Check\/write the tag.  If reading, then compare the tag against\n-  \/\/ the passed in value and fail is they don't match.  This allows\n-  \/\/ for verification that sections of the serialized data are of the\n-  \/\/ correct length.\n-  virtual void do_tag(int tag) = 0;\n-\n-  \/\/ Read\/write the oop\n-  virtual void do_oop(oop* o) = 0;\n-\n-  bool writing() {\n-    return !reading();\n-  }\n-};\n-\n@@ -373,12 +339,0 @@\n-\/\/ Dispatches to the non-virtual functions if OopClosureType has\n-\/\/ a concrete implementation, otherwise a virtual call is taken.\n-class Devirtualizer {\n- public:\n-  template <typename OopClosureType, typename T> static void do_oop(OopClosureType* closure, T* p);\n-  template <typename OopClosureType>             static void do_klass(OopClosureType* closure, Klass* k);\n-  template <typename OopClosureType>             static void do_cld(OopClosureType* closure, ClassLoaderData* cld);\n-  template <typename OopClosureType>             static bool do_metadata(OopClosureType* closure);\n-  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived);\n-  template <typename BitMapClosureType>          static bool do_bit(BitMapClosureType* closure, BitMap::idx_t index);\n-};\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -66,136 +66,0 @@\n-\/\/ Implementation of the non-virtual do_oop dispatch.\n-\/\/\n-\/\/ The same implementation is used for do_metadata, do_klass, and do_cld.\n-\/\/\n-\/\/ Preconditions:\n-\/\/  - Base has a pure virtual do_oop\n-\/\/  - Only one of the classes in the inheritance chain from OopClosureType to\n-\/\/    Base implements do_oop.\n-\/\/\n-\/\/ Given the preconditions:\n-\/\/  - If &OopClosureType::do_oop is resolved to &Base::do_oop, then there is no\n-\/\/    implementation of do_oop between Base and OopClosureType. However, there\n-\/\/    must be one implementation in one of the subclasses of OopClosureType.\n-\/\/    In this case we take the virtual call.\n-\/\/\n-\/\/  - Conversely, if &OopClosureType::do_oop is not resolved to &Base::do_oop,\n-\/\/    then we've found the one and only concrete implementation. In this case we\n-\/\/    take a non-virtual call.\n-\/\/\n-\/\/ Because of this it's clear when we should call the virtual call and\n-\/\/   when the non-virtual call should be made.\n-\/\/\n-\/\/ The way we find if &OopClosureType::do_oop is resolved to &Base::do_oop is to\n-\/\/   check if the resulting type of the class of a member-function pointer to\n-\/\/   &OopClosureType::do_oop is equal to the type of the class of a\n-\/\/   &Base::do_oop member-function pointer. Template parameter deduction is used\n-\/\/   to find these types, and then the IsSame trait is used to check if they are\n-\/\/   equal. Finally, SFINAE is used to select the appropriate implementation.\n-\/\/\n-\/\/ Template parameters:\n-\/\/   T              - narrowOop or oop\n-\/\/   Receiver       - the resolved type of the class of the\n-\/\/                    &OopClosureType::do_oop member-function pointer. That is,\n-\/\/                    the klass with the do_oop member function.\n-\/\/   Base           - klass with the pure virtual do_oop member function.\n-\/\/   OopClosureType - The dynamic closure type\n-\/\/\n-\/\/ Parameters:\n-\/\/   closure - The closure to call\n-\/\/   p       - The oop (or narrowOop) field to pass to the closure\n-\n-template <typename T, typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n-  closure->do_oop(p);\n-}\n-\n-template <typename T, typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_oop(void (Receiver::*)(T*), void (Base::*)(T*), OopClosureType* closure, T* p) {\n-  \/\/ Sanity check\n-  STATIC_ASSERT((!IsSame<OopClosureType, OopIterateClosure>::value));\n-  closure->OopClosureType::do_oop(p);\n-}\n-\n-template <typename OopClosureType, typename T>\n-inline void Devirtualizer::do_oop(OopClosureType* closure, T* p) {\n-  call_do_oop<T>(&OopClosureType::do_oop, &OopClosure::do_oop, closure, p);\n-}\n-\n-\/\/ Implementation of the non-virtual do_metadata dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, bool>::type\n-call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n-  return closure->do_metadata();\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, bool>::type\n-call_do_metadata(bool (Receiver::*)(), bool (Base::*)(), OopClosureType* closure) {\n-  return closure->OopClosureType::do_metadata();\n-}\n-\n-template <typename OopClosureType>\n-inline bool Devirtualizer::do_metadata(OopClosureType* closure) {\n-  return call_do_metadata(&OopClosureType::do_metadata, &OopIterateClosure::do_metadata, closure);\n-}\n-\n-\/\/ Implementation of the non-virtual do_klass dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n-  closure->do_klass(k);\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_klass(void (Receiver::*)(Klass*), void (Base::*)(Klass*), OopClosureType* closure, Klass* k) {\n-  closure->OopClosureType::do_klass(k);\n-}\n-\n-template <typename OopClosureType>\n-inline void Devirtualizer::do_klass(OopClosureType* closure, Klass* k) {\n-  call_do_klass(&OopClosureType::do_klass, &OopIterateClosure::do_klass, closure, k);\n-}\n-\n-\/\/ Implementation of the non-virtual do_cld dispatch.\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n-  closure->do_cld(cld);\n-}\n-\n-template <typename Receiver, typename Base, typename OopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_cld(void (Receiver::*)(ClassLoaderData*), void (Base::*)(ClassLoaderData*), OopClosureType* closure, ClassLoaderData* cld) {\n-  closure->OopClosureType::do_cld(cld);\n-}\n-\n-template <typename OopClosureType>\n-void Devirtualizer::do_cld(OopClosureType* closure, ClassLoaderData* cld) {\n-  call_do_cld(&OopClosureType::do_cld, &OopIterateClosure::do_cld, closure, cld);\n-}\n-\n-\/\/ Implementation of the non-virtual do_derived_oop dispatch.\n-\n-template <typename Receiver, typename Base, typename DerivedOopClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, void>::type\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  closure->do_derived_oop(base, derived);\n-}\n-\n-template <typename Receiver, typename Base, typename DerivedOopClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, void>::type\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  closure->DerivedOopClosureType::do_derived_oop(base, derived);\n-}\n-\n-template <typename DerivedOopClosureType>\n-inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n-  call_do_derived_oop(&DerivedOopClosureType::do_derived_oop, &DerivedOopClosure::do_derived_oop, closure, base, derived);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":0,"deletions":136,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n@@ -84,0 +85,29 @@\n+\/\/ A helper class for caching a Method* when the user of the cache\n+\/\/ only cares about the latest version of the Method*.  This cache safely\n+\/\/ interacts with the RedefineClasses API.\n+\n+class LatestMethodCache : public CHeapObj<mtClass> {\n+  \/\/ We save the Klass* and the idnum of Method* in order to get\n+  \/\/ the current cached Method*.\n+ private:\n+  Klass*                _klass;\n+  int                   _method_idnum;\n+\n+ public:\n+  LatestMethodCache()   { _klass = NULL; _method_idnum = -1; }\n+  ~LatestMethodCache()  { _klass = NULL; _method_idnum = -1; }\n+\n+  void   init(Klass* k, Method* m);\n+  Klass* klass() const           { return _klass; }\n+  int    method_idnum() const    { return _method_idnum; }\n+\n+  Method* get_method();\n+\n+  \/\/ CDS support.  Replace the klass in this with the archive version\n+  \/\/ could use this for Enhanced Class Redefinition also.\n+  void serialize(SerializeClosure* f) {\n+    f->do_ptr((void**)&_klass);\n+  }\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+};\n+\n@@ -1250,0 +1280,5 @@\n+Method* Universe::finalizer_register_method()   { return _finalizer_register_cache->get_method(); }\n+Method* Universe::loader_addClass_method()      { return _loader_addClass_cache->get_method(); }\n+Method* Universe::throw_illegal_access_error()  { return _throw_illegal_access_error_cache->get_method(); }\n+Method* Universe::throw_no_such_method_error()  { return _throw_no_such_method_error_cache->get_method(); }\n+Method* Universe::do_stack_walk_method()        { return _do_stack_walk_cache->get_method(); }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -46,29 +46,2 @@\n-\n-\/\/ A helper class for caching a Method* when the user of the cache\n-\/\/ only cares about the latest version of the Method*.  This cache safely\n-\/\/ interacts with the RedefineClasses API.\n-\n-class LatestMethodCache : public CHeapObj<mtClass> {\n-  \/\/ We save the Klass* and the idnum of Method* in order to get\n-  \/\/ the current cached Method*.\n- private:\n-  Klass*                _klass;\n-  int                   _method_idnum;\n-\n- public:\n-  LatestMethodCache()   { _klass = NULL; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = NULL; _method_idnum = -1; }\n-\n-  void   init(Klass* k, Method* m);\n-  Klass* klass() const           { return _klass; }\n-  int    method_idnum() const    { return _method_idnum; }\n-\n-  Method* get_method();\n-\n-  \/\/ CDS support.  Replace the klass in this with the archive version\n-  \/\/ could use this for Enhanced Class Redefinition also.\n-  void serialize(SerializeClosure* f) {\n-    f->do_ptr((void**)&_klass);\n-  }\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-};\n+class LatestMethodCache;\n+class SerializeClosure;\n@@ -258,5 +231,0 @@\n-  static Method*      finalizer_register_method()     { return _finalizer_register_cache->get_method(); }\n-  static Method*      loader_addClass_method()        { return _loader_addClass_cache->get_method(); }\n-\n-  static Method*      throw_illegal_access_error()    { return _throw_illegal_access_error_cache->get_method(); }\n-  static Method*      throw_no_such_method_error()    { return _throw_no_such_method_error_cache->get_method(); }\n@@ -264,1 +232,5 @@\n-  static Method*      do_stack_walk_method()          { return _do_stack_walk_cache->get_method(); }\n+  static Method*      finalizer_register_method();\n+  static Method*      loader_addClass_method();\n+  static Method*      throw_illegal_access_error();\n+  static Method*      throw_no_such_method_error();\n+  static Method*      do_stack_walk_method();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":7,"deletions":35,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"memory\/iterator.hpp\"\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"memory\/iterator.hpp\"\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"memory\/iterator.hpp\"\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}