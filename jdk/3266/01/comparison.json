{"files":[{"patch":"@@ -102,0 +102,2 @@\n+    permission java.io.FilePermission \"<<ALL FILES>>\",\"read\";\n+    permission java.net.SocketPermission \"*\", \"connect,resolve\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import javax.xml.crypto.dsig.DigestMethod;\n@@ -587,3 +588,4 @@\n-            SHA256(\"SHA-256\", \"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha256\", 32),\n-            SHA384(\"SHA-384\", \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#sha384\", 48),\n-            SHA512(\"SHA-512\", \"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha512\", 64);\n+\/\/            SHA1(\"SHA-1\", DigestMethod.SHA1, 20),\n+            SHA256(\"SHA-256\", DigestMethod.SHA256, 32),\n+            SHA384(\"SHA-384\", DigestMethod.SHA384, 48),\n+            SHA512(\"SHA-512\", DigestMethod.SHA512, 64);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureBaseRSA.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+    \/** Tag of Element MaskGenerationFunction **\/\n+    public static final String _TAG_MGF = \"MaskGenerationFunction\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/Constants.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,0 +238,9 @@\n+\n+    \/**\n+     * The <a href=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\">\n+     * RSASSA-PSS<\/a> signature method algorithm URI.\n+     *\n+     * @since 17\n+     *\/\n+    String RSA_PSS = \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\";\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/SignatureMethod.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.xml.crypto.dsig.spec;\n+\n+import javax.xml.crypto.dsig.SignatureMethod;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Objects;\n+\n+\/**\n+ * Parameters for the <a href=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\">\n+ * XML Signature RSASSA-PSS Algorithm<\/a>. The parameters are expressed as a\n+ * {@link PSSParameterSpec} object encapsulated.\n+ * <p>\n+ * The XML Schema Definition is defined as:\n+ * <pre><code>\n+ *    &lt;xs:element name=\"RSAPSSParams\" type=\"pss:RSAPSSParamsType\"&gt;\n+ *        &lt;xs:annotation&gt;\n+ *            &lt;xs:documentation&gt;\n+ *    Top level element that can be used in xs:any namespace=\"#other\"\n+ *    wildcard of ds:SignatureMethod content.\n+ *            &lt;\/xs:documentation&gt;\n+ *        &lt;\/xs:annotation&gt;\n+ *    &lt;\/xs:element&gt;\n+ *    &lt;xs:complexType name=\"RSAPSSParamsType\"&gt;\n+ *        &lt;xs:sequence&gt;\n+ *            &lt;xs:element ref=\"ds:DigestMethod\" minOccurs=\"0\"\/&gt;\n+ *            &lt;xs:element name=\"MaskGenerationFunction\"\n+ *               type=\"pss:MaskGenerationFunctionType\" minOccurs=\"0\"\/&gt;\n+ *            &lt;xs:element name=\"SaltLength\" type=\"xs:int\"\n+ *               minOccurs=\"0\"\/&gt;\n+ *            &lt;xs:element name=\"TrailerField\" type=\"xs:int\"\n+ *               minOccurs=\"0\"\/&gt;\n+ *        &lt;\/xs:sequence&gt;\n+ *    &lt;\/xs:complexType&gt;\n+ *    &lt;xs:complexType name=\"MaskGenerationFunctionType\"&gt;\n+ *        &lt;xs:sequence&gt;\n+ *            &lt;xs:element ref=\"ds:DigestMethod\" minOccurs=\"0\"\/&gt;\n+ *        &lt;\/xs:sequence&gt;\n+ *        &lt;xs:attribute name=\"Algorithm\" type=\"xs:anyURI\"\n+ *           default=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\"\/&gt;\n+ *    &lt;\/xs:complexType&gt;\n+ * <\/code><\/pre>\n+ *\n+ * @implSpec\n+ * If the parameter is not specified when using the RSASSA-PSS signature\n+ * algorithm, the default parameter is used, which uses SHA-256 as the\n+ * {@code DigestMethod}, MGF1 with SHA-256 as the\n+ * {@code MaskGenerationFunction}, 32 as {@code SaltLength}, and 1 as\n+ * {@code TrailerField}. This is equivalent to the parameter-less signature\n+ * method as defined by http:\/\/www.w3.org\/2007\/05\/xmldsig-more#sha256-rsa-MGF1.\n+ *\n+ * @since 17\n+ * @see SignatureMethod\n+ * @see <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6931.txt\">RFC 6931<\/a>\n+ *\/\n+public final class RSAPSSParameterSpec implements SignatureMethodParameterSpec {\n+\n+    private final PSSParameterSpec spec;\n+\n+    \/**\n+     * Creates a new {@code RSAPSSParameterSpec} object with the specified\n+     * {@link PSSParameterSpec} object encapsulated.\n+     *\n+     * @param spec the input {@code PSSParameterSpec} to be encapsulated\n+     *\/\n+    public RSAPSSParameterSpec(PSSParameterSpec spec) {\n+        this.spec = Objects.requireNonNull(spec);\n+    }\n+\n+    \/**\n+     * Returns the encapsulated {@code PSSParameterSpec} object.\n+     *\n+     * @return the encapsulated {@code PSSParameterSpec} object\n+     *\/\n+    public PSSParameterSpec getPSSParameterSpec() {\n+        return spec;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(\n+                spec.getDigestAlgorithm(),\n+                spec.getSaltLength(),\n+                spec.getTrailerField(),\n+                mgfParamsAsString(spec));\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (!(obj instanceof RSAPSSParameterSpec)) {\n+            return false;\n+        }\n+        PSSParameterSpec other = ((RSAPSSParameterSpec)obj).spec;\n+        return Objects.equals(spec.getDigestAlgorithm(), other.getDigestAlgorithm())\n+                && Objects.equals(mgfParamsAsString(spec), mgfParamsAsString(other))\n+                && spec.getSaltLength() == other.getSaltLength()\n+                && spec.getTrailerField() == other.getTrailerField();\n+    }\n+\n+    private static String mgfParamsAsString(PSSParameterSpec spec) {\n+        String output = spec.getMGFAlgorithm() + \":\";\n+        AlgorithmParameterSpec mgfSpec = spec.getMGFParameters();\n+        if (mgfSpec instanceof MGF1ParameterSpec) {\n+            output += ((MGF1ParameterSpec)mgfSpec).getDigestAlgorithm();\n+        } else {\n+            output += System.identityHashCode(mgfSpec);\n+        }\n+        return output;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RSAPSSParameterSpec (dm:\" + spec.getDigestAlgorithm()\n+                + \", mgf:\" + mgfParamsAsString(spec)\n+                + \", sl:\" + spec.getSaltLength()\n+                + \", tf:\" + spec.getTrailerField() + \")\";\n+    }\n+}\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n@@ -49,1 +50,0 @@\n- *\n@@ -65,3 +65,6 @@\n-    private int trailerField = 1;\n-    private int saltLength = 32;\n-    private String digestName = \"SHA-256\";\n+    private static final RSAPSSParameterSpec DEFAULT_PSS_SPEC\n+            = new RSAPSSParameterSpec(new PSSParameterSpec(\n+                \"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-256\"),\n+                32, PSSParameterSpec.TRAILER_FIELD_BC));\n+\n+    private PSSParameterSpec spec;\n@@ -85,1 +88,1 @@\n-            params = getDefaultParameterSpec();\n+            params = DEFAULT_PSS_SPEC;\n@@ -103,1 +106,1 @@\n-            params = getDefaultParameterSpec();\n+            params = DEFAULT_PSS_SPEC;\n@@ -122,12 +125,2 @@\n-            if (((RSAPSSParameterSpec)params).getTrailerField() > 0) {\n-                trailerField = ((RSAPSSParameterSpec)params).getTrailerField();\n-                LOG.debug(\"Setting trailerField from RSAPSSParameterSpec to: {}\", trailerField);\n-            }\n-            if (((RSAPSSParameterSpec)params).getSaltLength() > 0) {\n-                saltLength = ((RSAPSSParameterSpec)params).getSaltLength();\n-                LOG.debug(\"Setting saltLength from RSAPSSParameterSpec to: {}\", saltLength);\n-            }\n-            if (((RSAPSSParameterSpec)params).getDigestName() != null) {\n-                digestName = ((RSAPSSParameterSpec)params).getDigestName();\n-                LOG.debug(\"Setting digestName from RSAPSSParameterSpec to: {}\", digestName);\n-            }\n+            spec = ((RSAPSSParameterSpec) params).getPSSParameterSpec();\n+            LOG.debug(\"Setting RSAPSSParameterSpec to: {}\", params.toString());\n@@ -149,2 +142,1 @@\n-        Element digestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n-                                                             XMLSignature.XMLNS, prefix);\n+        DigestAlgorithm digestAlgorithm;\n@@ -152,1 +144,14 @@\n-            digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, DigestAlgorithm.fromDigestAlgorithm(digestName).getXmlDigestAlgorithm());\n+            digestAlgorithm = DigestAlgorithm.fromDigestAlgorithm(spec.getDigestAlgorithm());\n+            String xmlDigestAlgorithm = digestAlgorithm.getXmlDigestAlgorithm();\n+            if (!xmlDigestAlgorithm.equals(DigestMethod.SHA256)) {\n+                Element digestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n+                        XMLSignature.XMLNS, prefix);\n+                digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, xmlDigestAlgorithm);\n+                rsaPssParamsElement.appendChild(digestMethodElement);\n+            }\n+            if (spec.getSaltLength() != digestAlgorithm.getSaltLength()) {\n+                Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n+                Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getSaltLength()));\n+                saltLengthElement.appendChild(saltLengthText);\n+                rsaPssParamsElement.appendChild(saltLengthElement);\n+            }\n@@ -154,1 +159,1 @@\n-            throw new MarshalException(\"Invalid digest name supplied: \" + digestName);\n+            throw new MarshalException(\"Invalid digest name supplied: \" + spec.getDigestAlgorithm());\n@@ -156,1 +161,0 @@\n-        rsaPssParamsElement.appendChild(digestMethodElement);\n@@ -158,3 +162,3 @@\n-        Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n-        Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(saltLength));\n-        saltLengthElement.appendChild(saltLengthText);\n+        if (!spec.getMGFAlgorithm().equals(\"MGF1\")) {\n+            throw new MarshalException(\"Unsupported MGF algorithm supplied: \" + spec.getMGFAlgorithm());\n+        }\n@@ -162,1 +166,20 @@\n-        rsaPssParamsElement.appendChild(saltLengthElement);\n+        MGF1ParameterSpec mgfSpec = (MGF1ParameterSpec)spec.getMGFParameters();\n+        try {\n+            DigestAlgorithm mgfDigestAlgorithm = DigestAlgorithm.fromDigestAlgorithm(mgfSpec.getDigestAlgorithm());\n+            if (mgfDigestAlgorithm != digestAlgorithm) {\n+                Element mgfElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_MGF);\n+                try {\n+                    mgfElement.setAttributeNS(null, Constants._ATT_ALGORITHM, \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\");\n+                } catch (DOMException e) {\n+                    throw new MarshalException(\"Should not happen\");\n+                }\n+                Element mgfDigestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n+                        XMLSignature.XMLNS, prefix);\n+                String xmlDigestAlgorithm = mgfDigestAlgorithm.getXmlDigestAlgorithm();\n+                mgfDigestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, xmlDigestAlgorithm);\n+                mgfElement.appendChild(mgfDigestMethodElement);\n+                rsaPssParamsElement.appendChild(mgfElement);\n+            }\n+        } catch (DOMException | com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+            throw new MarshalException(\"Invalid digest name supplied: \" + mgfSpec.getDigestAlgorithm());\n+        }\n@@ -164,3 +187,6 @@\n-        Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n-        Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(trailerField));\n-        trailerFieldElement.appendChild(trailerFieldText);\n+        if (spec.getTrailerField() != 1) {\n+            Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n+            Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(spec.getTrailerField()));\n+            trailerFieldElement.appendChild(trailerFieldText);\n+            rsaPssParamsElement.appendChild(trailerFieldElement);\n+        }\n@@ -168,1 +194,4 @@\n-        rsaPssParamsElement.appendChild(trailerFieldElement);\n+        if (rsaPssParamsElement.hasChildNodes()) {\n+            parent.appendChild(rsaPssParamsElement);\n+        }\n+    }\n@@ -170,1 +199,7 @@\n-        parent.appendChild(rsaPssParamsElement);\n+    private static DigestAlgorithm validateDigestAlgorithm(String input)\n+            throws MarshalException {\n+        try {\n+            return DigestAlgorithm.fromXmlDigestAlgorithm(input);\n+        } catch (com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+            throw new MarshalException(\"Invalid digest algorithm supplied: \" + input);\n+        }\n@@ -179,6 +214,16 @@\n-            int trailerField = 1;\n-            if (trailerFieldNode != null) {\n-                try {\n-                    trailerField = Integer.parseInt(trailerFieldNode.getTextContent());\n-                } catch (NumberFormatException ex) {\n-                    throw new MarshalException(\"Invalid trailer field supplied: \" + trailerFieldNode.getTextContent());\n+            Element digestAlgorithmNode = XMLUtils.selectDsNode(paramsElem.getFirstChild(), Constants._TAG_DIGESTMETHOD, 0);\n+            Element mgfNode = XMLUtils.selectNode(paramsElem.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_MGF, 0);\n+\n+            DigestAlgorithm digestAlgorithm = digestAlgorithmNode != null\n+                    ? validateDigestAlgorithm(digestAlgorithmNode.getAttribute(Constants._ATT_ALGORITHM))\n+                    : DigestAlgorithm.SHA256;\n+\n+            DigestAlgorithm mgfDigestAlgorithm = digestAlgorithm;\n+            if (mgfNode != null) {\n+                String mgfAlgorithm = mgfNode.getAttribute(Constants._ATT_ALGORITHM);\n+                if (!mgfAlgorithm.equals(\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\")) {\n+                    throw new MarshalException(\"Unknown MGF algorithm: \" + mgfAlgorithm);\n+                }\n+                Element mgfDigestAlgorithmNode = XMLUtils.selectDsNode(mgfNode.getFirstChild(), Constants._TAG_DIGESTMETHOD, 0);\n+                if (mgfDigestAlgorithmNode != null) {\n+                    mgfDigestAlgorithm = validateDigestAlgorithm(mgfDigestAlgorithmNode.getAttribute(Constants._ATT_ALGORITHM));\n@@ -187,2 +232,2 @@\n-            String xmlAlgorithm = XMLUtils.selectDsNode(paramsElem.getFirstChild(), Constants._TAG_DIGESTMETHOD, 0).getAttribute(Constants._ATT_ALGORITHM);\n-            DigestAlgorithm digestAlgorithm;\n+\n+            int saltLength;\n@@ -190,3 +235,3 @@\n-                digestAlgorithm = DigestAlgorithm.fromXmlDigestAlgorithm(xmlAlgorithm);\n-            } catch (com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n-                throw new MarshalException(\"Invalid digest algorithm supplied: \" + xmlAlgorithm);\n+                saltLength = saltLengthNode == null ? digestAlgorithm.getSaltLength() : Integer.parseInt(saltLengthNode.getTextContent());\n+            } catch (NumberFormatException ex) {\n+                throw new MarshalException(\"Invalid salt length supplied: \" + saltLengthNode.getTextContent());\n@@ -194,1 +239,0 @@\n-            String digestName = digestAlgorithm.getDigestAlgorithm();\n@@ -196,2 +240,1 @@\n-            RSAPSSParameterSpec params = new RSAPSSParameterSpec();\n-            params.setTrailerField(trailerField);\n+            int trailerField;\n@@ -199,2 +242,1 @@\n-                int saltLength = saltLengthNode == null ? digestAlgorithm.getSaltLength() : Integer.parseInt(saltLengthNode.getTextContent());\n-                params.setSaltLength(saltLength);\n+                trailerField = trailerFieldNode == null ? 1 : Integer.parseInt(trailerFieldNode.getTextContent());\n@@ -202,1 +244,1 @@\n-                throw new MarshalException(\"Invalid salt length supplied: \" + saltLengthNode.getTextContent());\n+                throw new MarshalException(\"Invalid trailer field supplied: \" + trailerFieldNode.getTextContent());\n@@ -204,2 +246,5 @@\n-            params.setDigestName(digestName);\n-            return params;\n+\n+            return new RSAPSSParameterSpec(new PSSParameterSpec(\n+                    digestAlgorithm.getDigestAlgorithm(),\n+                    \"MGF1\", new MGF1ParameterSpec(mgfDigestAlgorithm.getDigestAlgorithm()),\n+                    saltLength, trailerField));\n@@ -207,1 +252,1 @@\n-        return getDefaultParameterSpec();\n+        return DEFAULT_PSS_SPEC;\n@@ -233,1 +278,1 @@\n-            signature.setParameter(new PSSParameterSpec(digestName, \"MGF1\", new MGF1ParameterSpec(digestName), saltLength, trailerField));\n+            signature.setParameter(spec);\n@@ -273,1 +318,1 @@\n-            signature.setParameter(new PSSParameterSpec(digestName, \"MGF1\", new MGF1ParameterSpec(digestName), saltLength, trailerField));\n+            signature.setParameter(spec);\n@@ -295,8 +340,0 @@\n-    private SignatureMethodParameterSpec getDefaultParameterSpec() {\n-        RSAPSSParameterSpec params = new RSAPSSParameterSpec();\n-        params.setTrailerField(trailerField);\n-        params.setSaltLength(saltLength);\n-        params.setDigestName(digestName);\n-        return params;\n-    }\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMRSAPSSSignatureMethod.java","additions":99,"deletions":62,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n@@ -38,0 +39,3 @@\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n@@ -40,0 +44,1 @@\n+import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA;\n@@ -155,0 +160,27 @@\n+        if (secVal && signatureMethod instanceof DOMRSAPSSSignatureMethod.RSAPSS) {\n+            AlgorithmParameterSpec spec = signatureMethod.getParameterSpec();\n+            if (spec instanceof RSAPSSParameterSpec) {\n+                try {\n+                    PSSParameterSpec pspec = ((RSAPSSParameterSpec) spec).getPSSParameterSpec();\n+                    String da = SignatureBaseRSA.SignatureRSASSAPSS.DigestAlgorithm\n+                            .fromDigestAlgorithm(pspec.getDigestAlgorithm()).getXmlDigestAlgorithm();\n+                    if (Policy.restrictAlg(da)) {\n+                        throw new MarshalException(\n+                                \"It is forbidden to use algorithm \" + da + \" in PSS when secure validation is enabled\"\n+                        );\n+                    }\n+                    AlgorithmParameterSpec mspec = pspec.getMGFParameters();\n+                    if (mspec instanceof MGF1ParameterSpec) {\n+                        String da2 = SignatureBaseRSA.SignatureRSASSAPSS.DigestAlgorithm\n+                                .fromDigestAlgorithm(((MGF1ParameterSpec) mspec).getDigestAlgorithm()).getXmlDigestAlgorithm();\n+                        if (Policy.restrictAlg(da2)) {\n+                            throw new MarshalException(\n+                                    \"It is forbidden to use algorithm \" + da2 + \" in MGF1 when secure validation is enabled\"\n+                            );\n+                        }\n+                    }\n+                } catch (com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+                    \/\/ Unknown digest algorithm. Ignored.\n+                }\n+            }\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignedInfo.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package org.jcp.xml.dsig.internal.dom;\n-\n-import javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec;\n-\n-public class RSAPSSParameterSpec implements SignatureMethodParameterSpec {\n-\n-    private int trailerField;\n-    private int saltLength;\n-    private String digestName;\n-\n-    public int getTrailerField() {\n-        return trailerField;\n-    }\n-    public void setTrailerField(int trailerField) {\n-        this.trailerField = trailerField;\n-    }\n-    public int getSaltLength() {\n-        return saltLength;\n-    }\n-    public void setSaltLength(int saltLength) {\n-        this.saltLength = saltLength;\n-    }\n-    public String getDigestName() {\n-        return digestName;\n-    }\n-    public void setDigestName(String digestName) {\n-        this.digestName = digestName;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        final int prime = 31;\n-        int result = 1;\n-        result = prime * result + ((digestName == null) ? 0 : digestName.hashCode());\n-        result = prime * result + saltLength;\n-        result = prime * result + trailerField;\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj)\n-            return true;\n-        if (obj == null)\n-            return false;\n-        if (getClass() != obj.getClass())\n-            return false;\n-        RSAPSSParameterSpec other = (RSAPSSParameterSpec)obj;\n-        if (digestName == null) {\n-            if (other.digestName != null)\n-                return false;\n-        } else if (!digestName.equals(other.digestName))\n-            return false;\n-        if (saltLength != other.saltLength)\n-            return false;\n-        return trailerField == other.trailerField;\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/RSAPSSParameterSpec.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8264277\n+ * @library \/test\/jdk\/java\/security\/testlibrary\/ \/test\/lib\n+ * @modules jdk.httpserver\n+ *          java.base\/jdk.internal.misc\n+ * @require os.family != \"windows\"\n+ * @summary check permissions for XML signature\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.XMLUtils;\n+\n+import java.io.File;\n+import java.io.FilePermission;\n+import java.net.InetSocketAddress;\n+import java.net.SocketPermission;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+\n+\/\/ Note: This test does not run fine on Windows because the format by\n+\/\/ Path.toUri.toString (file:\/\/\/c:\/path\/to\/file) is not supported by\n+\/\/ ResolverLocalFilesystem.translateUriToFilename.\n+public class FileSocketPermissions    {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            Path plain = Files.writeString(\n+                    Path.of(System.getProperty(\"user.dir\"), \"a.xml\"), \"<a>x<\/a>\");\n+            HttpServer server = HttpServer.create(new InetSocketAddress(0), 0);\n+            server.createContext(\"\/\", ex -> {\n+                ex.sendResponseHeaders(200, 0);\n+                ex.getResponseBody().write(\"<a>x<\/a>\".getBytes(StandardCharsets.UTF_8));\n+                ex.close();\n+            });\n+            server.start();\n+            try {\n+                String httpDoc = \"http:\/\/localhost:\" + server.getAddress().getPort() + \"\/b.xml\";\n+                System.out.println(httpDoc);\n+\n+                \/\/ No permission granted.\n+                Proc p0 = Proc.create(\"FileSocketPermissions\")\n+                        .prop(\"java.security.manager\", \"\")\n+                        .debug(\"S\")\n+                        .args(\"sign\", plain.toUri().toString(), httpDoc)\n+                        .start();\n+                Asserts.assertEQ(p0.readData(), \"Error\");\n+                Asserts.assertEQ(p0.readData(), \"Error\");\n+\n+                \/\/ Permission to file and socket granted.\n+                Proc p = Proc.create(\"FileSocketPermissions\")\n+                        .prop(\"java.security.manager\", \"\")\n+                        .grant(new File(System.getProperty(\"test.classes\")))\n+                        .perm(new FilePermission(plain.toString(), \"read\"))\n+                        .perm(new SocketPermission(\"localhost\", \"resolve,connect\"))\n+                        .debug(\"S2\")\n+                        .args(\"sign\", plain.toUri().toString(), httpDoc)\n+                        .start();\n+\n+                Proc p2 = Proc.create(\"FileSocketPermissions\")\n+                        .prop(\"java.security.manager\", \"\")\n+                        .grant(new File(System.getProperty(\"test.classes\")))\n+                        .perm(new FilePermission(plain.toString(), \"read\"))\n+                        .perm(new SocketPermission(\"localhost\", \"resolve,connect\"))\n+                        .debug(\"V\")\n+                        .args(\"validate\")\n+                        .start();\n+\n+                while (true) {\n+                    String in = p.readData(); \/\/ read signed XML from signer\n+                    p2.println(in); \/\/ send signed XML to validator\n+                    if (in.equals(\"Over\")) {\n+                        break;\n+                    }\n+                    if (!p2.readData().equals(\"true\")) { \/\/ read validator result\n+                        throw new Exception(\"Validation error\");\n+                    }\n+                }\n+            } finally {\n+                server.stop(0);\n+            }\n+        } else if (args[0].equals(\"sign\")) {\n+            KeyPairGenerator g = KeyPairGenerator.getInstance(\"EC\");\n+            KeyPair p = g.generateKeyPair();\n+            var signer = XMLUtils.signer(p.getPrivate(), p.getPublic());\n+            for (int i = 1; i < args.length; i++) {\n+                try {\n+                    \/\/ Multiple line XML. Send as raw bytes (in Base64)\n+                    Proc.binOut(XMLUtils.doc2string(signer.sign(new URI(args[i])))\n+                            .getBytes(StandardCharsets.UTF_8));\n+                } catch (Exception se) {\n+                    se.printStackTrace();\n+                    Proc.textOut(\"Error\");\n+                }\n+            }\n+            Proc.textOut(\"Over\");\n+        } else if (args[0].equals(\"validate\")) {\n+            \/\/ Turn secureValidation off. Will read external data\n+            var validator = XMLUtils.validator().secureValidation(false);\n+            while (true) {\n+                String in = new String(Proc.binIn());\n+                if (in.equals(\"Over\")) {\n+                    Proc.textOut(\"Over\");\n+                    break;\n+                }\n+                Proc.textOut(Boolean.toString(validator.validate(XMLUtils.string2doc(in))));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/FileSocketPermissions.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -111,1 +111,1 @@\n-            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1;\n+            rsaSha1mgf1, rsaSha224mgf1, rsaSha256mgf1, rsaSha384mgf1, rsaSha512mgf1, rsaShaPSS;\n@@ -217,1 +217,2 @@\n-            SignatureMethod.SHA256_RSA_MGF1);\n+            SignatureMethod.SHA256_RSA_MGF1,\n+            SignatureMethod.RSA_PSS);\n@@ -249,1 +250,1 @@\n-    \/\/ As of JDK 11, the number of defined algorithms are...\n+    \/\/ As of JDK 17, the number of defined algorithms are...\n@@ -251,1 +252,1 @@\n-        if (allSignatureMethods.length != 22\n+        if (allSignatureMethods.length != 23\n@@ -338,0 +339,1 @@\n+        test_create_signature_enveloping_sha512_rsa_pss();\n@@ -534,0 +536,1 @@\n+        rsaShaPSS = fac.newSignatureMethod(SignatureMethod. RSA_PSS, null);\n@@ -795,0 +798,8 @@\n+    static void test_create_signature_enveloping_sha512_rsa_pss()\n+            throws Exception {\n+        System.out.println(\"* Generating signature-enveloping-sha512_rsa_pss.xml\");\n+        test_create_signature_enveloping(sha512, rsaShaPSS, rsa1024,\n+                getPrivateKey(\"RSA\", 1024), kvks, false, true);\n+        System.out.println();\n+    }\n+\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.XMLUtils;\n+import org.w3c.dom.Document;\n+\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.dsig.DigestMethod;\n+import javax.xml.crypto.dsig.SignatureMethod;\n+import javax.xml.crypto.dsig.XMLSignatureFactory;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+\n+\/**\n+ * @test\n+ * @bug 8241306\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ * @summary Testing marshal and unmarshal of RSAPSSParameterSpec\n+ *\/\n+public class PSSSpec {\n+    private static final String P2SM = \"\/\/ds:Signature\/ds:SignedInfo\/ds:SignatureMethod\";\n+    private static final String P2PSS = P2SM + \"\/pss:RSAPSSParams\";\n+    private static final String P2MGF = P2PSS + \"\/pss:MaskGenerationFunction\";\n+\n+    public static void main(String[] args) throws Exception {\n+        unmarshal();\n+        marshal();\n+    }\n+\n+    static void unmarshal() throws Exception {\n+        \/\/ Original document with all elements\n+        Document doc = XMLUtils.string2doc(\"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <ds:Signature\n+                        xmlns:ds=\"http:\/\/www.w3.org\/2000\/09\/xmldsig#\"\n+                        xmlns:ec=\"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#\"\n+                        xmlns:pss=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#\">\n+                    <ds:SignedInfo>\n+                        <ds:CanonicalizationMethod Algorithm=\"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#WithComments\"\/>\n+                        <ds:SignatureMethod Algorithm=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\">\n+                            <pss:RSAPSSParams>\n+                                <ds:DigestMethod Algorithm=\"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha512\"\/>\n+                                <pss:MaskGenerationFunction Algorithm=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#MGF1\">\n+                                    <ds:DigestMethod Algorithm=\"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#sha384\"\/>\n+                                <\/pss:MaskGenerationFunction>\n+                                <pss:SaltLength>32<\/pss:SaltLength>\n+                                <pss:TrailerField>2<\/pss:TrailerField>\n+                            <\/pss:RSAPSSParams>\n+                        <\/ds:SignatureMethod>\n+                        <ds:Reference>\n+                            <ds:DigestMethod Algorithm=\"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha512\"\/>\n+                            <ds:DigestValue>abc=<\/ds:DigestValue>\n+                        <\/ds:Reference>\n+                    <\/ds:SignedInfo>\n+                    <ds:SignatureValue>abc=<\/ds:SignatureValue>\n+                <\/ds:Signature>\n+                \"\"\");\n+\n+        \/\/ Unknown DigestMethod\n+        Utils.runAndCheckException(\n+                () -> getSpec(XMLUtils.withAttribute(doc, P2PSS + \"\/ds:DigestMethod\", \"Algorithm\", \"http:\/\/unknown\")),\n+                e -> Asserts.assertTrue(e instanceof MarshalException && e.getMessage().contains(\"Invalid digest algorithm\"), e.getMessage()));\n+        \/\/ Unknown MGF algorithm\n+        Utils.runAndCheckException(\n+                () -> getSpec(XMLUtils.withAttribute(doc, P2MGF, \"Algorithm\", \"http:\/\/unknown\")),\n+                e -> Asserts.assertTrue(e instanceof MarshalException && e.getMessage().contains(\"Unknown MGF algorithm\"), e.getMessage()));\n+        \/\/ Unknown MGF DigestMethod\n+        Utils.runAndCheckException(\n+                () -> getSpec(XMLUtils.withAttribute(doc, P2MGF + \"\/ds:DigestMethod\", \"Algorithm\", \"http:\/\/unknown\")),\n+                e -> Asserts.assertTrue(e instanceof MarshalException && e.getMessage().contains(\"Invalid digest algorithm\"), e.getMessage()));\n+        \/\/ Invalid SaltLength\n+        Utils.runAndCheckException(\n+                () -> getSpec(XMLUtils.withText(doc, P2PSS + \"\/pss:SaltLength\", \"big\")),\n+                e -> Asserts.assertTrue(e instanceof MarshalException && e.getMessage().contains(\"Invalid salt length supplied\"), e.getMessage()));\n+        \/\/ Invalid TrailerField\n+        Utils.runAndCheckException(\n+                () -> getSpec(XMLUtils.withText(doc, P2PSS + \"\/pss:TrailerField\", \"small\")),\n+                e -> Asserts.assertTrue(e instanceof MarshalException && e.getMessage().contains(\"Invalid trailer field supplied\"), e.getMessage()));\n+\n+        \/\/ Spec in original doc\n+        checkSpec(doc, new PSSParameterSpec(\"SHA-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 32, 2));\n+        \/\/ Default MGF1 dm is same as PSS dm\n+        checkSpec(XMLUtils.withoutNode(doc, P2MGF + \"\/ds:DigestMethod\"), \/\/ No dm in MGF\n+                new PSSParameterSpec(\"SHA-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA-512\"), 32, 2));\n+        checkSpec(XMLUtils.withoutNode(doc, P2MGF), \/\/ No MGF at all\n+                new PSSParameterSpec(\"SHA-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA-512\"), 32, 2));\n+        \/\/ Default TrailerField is 1\n+        checkSpec(XMLUtils.withoutNode(doc, P2PSS + \"\/pss:TrailerField\"),\n+                new PSSParameterSpec(\"SHA-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 32, 1));\n+        \/\/ Default SaltLength is dm's SaltLength\n+        checkSpec(XMLUtils.withoutNode(doc, P2PSS + \"\/pss:SaltLength\"),\n+                new PSSParameterSpec(\"SHA-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 64, 2));\n+        \/\/ Default DigestMethod is 256\n+        checkSpec(XMLUtils.withoutNode(doc, P2PSS + \"\/ds:DigestMethod\"),\n+                new PSSParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 32, 2));\n+        \/\/ Default PSS is SHA-256\n+        checkSpec(XMLUtils.withoutNode(doc, P2PSS),\n+                new PSSParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-256\"), 32, 1));\n+    }\n+\n+    static void marshal() throws Exception {\n+        var keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        var signer = XMLUtils.signer(keyPairGenerator.generateKeyPair().getPrivate());\n+        PSSParameterSpec spec;\n+        Document doc = XMLUtils.string2doc(\"<a>x<\/a>\");\n+        Document signedDoc;\n+\n+        \/\/ Default sm. No need to describe at all\n+        spec = new PSSParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-256\"), 32, PSSParameterSpec.TRAILER_FIELD_BC);\n+        signer.sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(spec));\n+        signedDoc = signer.sign(doc);\n+        Asserts.assertTrue(!XMLUtils.sub(signedDoc, P2SM).hasChildNodes());\n+\n+        \/\/ Special salt.\n+        spec = new PSSParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-256\"), 40, PSSParameterSpec.TRAILER_FIELD_BC);\n+        signer.sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(spec));\n+        signedDoc = signer.sign(doc);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:SaltLength\").getTextContent().equals(\"40\"));\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2MGF) == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/ds:DigestMethod\") == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:TrailerField\") == null);\n+\n+        \/\/ Different MGF1 dm\n+        spec = new PSSParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 32, PSSParameterSpec.TRAILER_FIELD_BC);\n+        signer.sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(spec));\n+        signedDoc = signer.sign(doc);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2MGF + \"\/ds:DigestMethod\").getAttribute(\"Algorithm\").equals(DigestMethod.SHA384));\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/ds:DigestMethod\") == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:SaltLength\") == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:TrailerField\") == null);\n+\n+        \/\/ Non default dm only\n+        spec = new PSSParameterSpec(\"SHA-384\", \"MGF1\", new MGF1ParameterSpec(\"SHA-384\"), 48, PSSParameterSpec.TRAILER_FIELD_BC);\n+        signer.sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(spec));\n+        signedDoc = signer.sign(doc);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/ds:DigestMethod\").getAttribute(\"Algorithm\").equals(DigestMethod.SHA384));\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2MGF) == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:SaltLength\") == null);\n+        Asserts.assertTrue(XMLUtils.sub(signedDoc, P2PSS + \"\/pss:TrailerField\") == null);\n+    }\n+\n+    static PSSParameterSpec getSpec(Document doc) throws Exception {\n+        var signatureNode = doc.getElementsByTagNameNS(\"http:\/\/www.w3.org\/2000\/09\/xmldsig#\", \"Signature\").item(0);\n+        DOMValidateContext valContext = new DOMValidateContext(new SecretKeySpec(new byte[1], \"WHAT\"), signatureNode);\n+        valContext.setProperty(\"org.jcp.xml.dsig.secureValidation\", false);\n+        var signedInfo = XMLSignatureFactory.getInstance(\"DOM\").unmarshalXMLSignature(valContext).getSignedInfo();\n+        var spec = signedInfo.getSignatureMethod().getParameterSpec();\n+        if (spec instanceof RSAPSSParameterSpec pspec) {\n+            return pspec.getPSSParameterSpec();\n+        } else {\n+            jdk.test.lib.Asserts.fail(\"Not PSSParameterSpec: \" + spec.getClass());\n+            return null;\n+        }\n+    }\n+\n+    static void checkSpec(Document doc, PSSParameterSpec expected) throws Exception {\n+        jdk.test.lib.Asserts.assertTrue(equals(getSpec(doc), expected));\n+    }\n+\n+    static boolean equals(PSSParameterSpec p1, PSSParameterSpec p2) {\n+        return p1.getDigestAlgorithm().equals(p2.getDigestAlgorithm())\n+                && p1.getSaltLength() == p2.getSaltLength()\n+                && p1.getTrailerField() == p2.getTrailerField()\n+                && p1.getMGFAlgorithm().equals(p2.getMGFAlgorithm())\n+                && ((MGF1ParameterSpec) p1.getMGFParameters()).getDigestAlgorithm()\n+                .equals(((MGF1ParameterSpec) p2.getMGFParameters()).getDigestAlgorithm());\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/PSSSpec.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8241306\n+ * @summary Tests for the jdk.xml.dsig.secureValidationPolicy security property\n+ *          on the RSASSA-PSS signature method\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.XMLUtils;\n+import jdk.test.lib.Utils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.dsig.DigestMethod;\n+import javax.xml.crypto.dsig.SignatureMethod;\n+import javax.xml.crypto.dsig.spec.RSAPSSParameterSpec;\n+import javax.xml.namespace.NamespaceContext;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import static java.security.spec.PSSParameterSpec.TRAILER_FIELD_BC;\n+\n+public class SecureValidation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Document doc = XMLUtils.string2doc(\"<a><b>Text<\/b>Raw<\/a>\");\n+\n+        CertAndKeyGen g = new CertAndKeyGen(\"RSASSA-PSS\", \"RSASSA-PSS\");\n+        g.generate(2048);\n+        X509Certificate cert = g.getSelfCertificate(new X500Name(\"CN=Me\"), 100);\n+        PrivateKey privateKey = g.getPrivateKey();\n+        PSSParameterSpec pspec = new PSSParameterSpec(\"SHA-384\", \"MGF1\",\n+                MGF1ParameterSpec.SHA512, 48, TRAILER_FIELD_BC);\n+\n+        \/\/ Sign with PSS with SHA-384 and SHA-512\n+        Document signed = XMLUtils.signer(privateKey, cert)\n+                .dm(DigestMethod.SHA384)\n+                .sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec))\n+                .sign(doc);\n+\n+        XPath xp = XPathFactory.newInstance().newXPath();\n+        xp.setNamespaceContext(new NamespaceContext() {\n+            @Override\n+            public String getNamespaceURI(String prefix) {\n+                return switch (prefix) {\n+                    case \"ds\" -> \"http:\/\/www.w3.org\/2000\/09\/xmldsig#\";\n+                    case \"pss\" -> \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#\";\n+                    default -> throw new IllegalArgumentException();\n+                };\n+            }\n+\n+            @Override\n+            public String getPrefix(String namespaceURI) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Iterator<String> getPrefixes(String namespaceURI) {\n+                return null;\n+            }\n+        });\n+\n+        var validator = XMLUtils.validator();\n+        XMLUtils.addPolicy(\"disallowAlg \" + DigestMethod.SHA256);\n+        Element e;\n+\n+        \/\/ 1. Modify the MGF1 digest algorithm in PSSParams to SHA-256\n+        e = (Element) xp.evaluate(\n+                \"\/a\/ds:Signature\/ds:SignedInfo\/ds:SignatureMethod\" +\n+                        \"\/pss:RSAPSSParams\/pss:MaskGenerationFunction\/ds:DigestMethod\",\n+                signed, XPathConstants.NODE);\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA256);\n+\n+        \/\/ When secureValidation is true, validate() throws an exception\n+        Utils.runAndCheckException(() -> validator.secureValidation(true).validate(signed),\n+                t -> Asserts.assertTrue(t instanceof MarshalException\n+                    && t.getMessage().contains(\"in MGF1\")\n+                    && t.getMessage().contains(DigestMethod.SHA256), Objects.toString(t)));\n+        \/\/ When secureValidation is false, validate() returns false\n+        Asserts.assertFalse(validator.secureValidation(false).validate(signed));\n+\n+        \/\/ Revert the change and confirm validate() returns true\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA512);\n+        Asserts.assertTrue(validator.secureValidation(true).validate(signed));\n+\n+        \/\/ 2. Modify the digest algorithm in PSSParams to SHA-256\n+        e = (Element) xp.evaluate(\n+                \"\/a\/ds:Signature\/ds:SignedInfo\/ds:SignatureMethod\" +\n+                        \"\/pss:RSAPSSParams\/ds:DigestMethod\",\n+                signed, XPathConstants.NODE);\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA256);\n+\n+        \/\/ When secureValidation is true, validate() throws an exception\n+        Utils.runAndCheckException(() -> validator.secureValidation(true).validate(signed),\n+                t -> Asserts.assertTrue(t instanceof MarshalException\n+                        && t.getMessage().contains(\"in PSS\")\n+                        && t.getMessage().contains(DigestMethod.SHA256), Objects.toString(t)));\n+        \/\/ When secureValidation is false, validate() returns false\n+        Asserts.assertFalse(validator.secureValidation(false).validate(signed));\n+\n+        \/\/ 3. Modify the digest algorithm in PSSParams to SHA-512\n+        e.setAttribute(\"Algorithm\", DigestMethod.SHA512);\n+\n+        \/\/ No matter if secureValidation is true or false, validate()\n+        \/\/ returns false. This means the policy allows it.\n+        Asserts.assertFalse(validator.secureValidation(true).validate(signed));\n+        Asserts.assertFalse(validator.secureValidation(false).validate(signed));\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/SecureValidation.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,558 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.Asserts;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+\n+import javax.xml.crypto.*;\n+import javax.xml.crypto.dom.DOMStructure;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.keyinfo.*;\n+import javax.xml.crypto.dsig.spec.*;\n+import javax.xml.namespace.NamespaceContext;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.File;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAKey;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.*;\n+\n+public class XMLUtils {\n+\n+    private static final XMLSignatureFactory FAC =\n+            XMLSignatureFactory.getInstance(\"DOM\");\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ MAIN as TEST \/\/\/\/\/\/\/\/\/\/\/\/\n+    public static void main(String[] args) throws Exception {\n+        var x = \"<a><b>c<\/b>x<\/a>\";\n+        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n+        var b = Path.of(\"\").toUri().toString();\n+        var d = string2doc(x);\n+        \/\/ keytool -keystore ks -keyalg ec -storepass changeit -genkeypair -alias a -dname CN=a\n+        var pass = \"changeit\".toCharArray();\n+        var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+        var c = (X509Certificate) ks.getCertificate(\"a\");\n+        var pr = (PrivateKey) ks.getKey(\"a\", pass);\n+        var pu = c.getPublicKey();\n+        var s0 = signer(pr); \/\/ No KeyInfo\n+        var s1 = signer(pr, pu); \/\/ KeyInfo is PublicKey\n+        var s2 = signer(pr, c); \/\/ KeyInfo is X509Data\n+        var s3 = signer(ks, \"a\", pass); \/\/ KeyInfo is KeyName\n+        var v1 = validator(); \/\/ knows nothing\n+        var v2 = validator(ks); \/\/ knows KeyName\n+        Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n+        Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v1.validate(s2.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.validate(s3.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.secureValidation(false).validate(s3.sign(p.toUri()))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n+                s3.sign(p.getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v1.validate(s1.sign(\"text\"))); \/\/ plain text\n+        Asserts.assertTrue(v1.validate(s1.sign(\"binary\".getBytes()))); \/\/ raw data\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ CONVERT \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public static String doc2string(Document doc) throws Exception {\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        Transformer transformer = tf.newTransformer();\n+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+        \/\/ Indentation would invalidate the signature\n+\/\/        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+        StringWriter writer = new StringWriter();\n+        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n+        return writer.getBuffer().toString();\n+    }\n+\n+    public static Document string2doc(String input) throws Exception {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+        return factory.newDocumentBuilder().\n+                parse(new InputSource(new StringReader(input)));\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ QUERY AND EDIT \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public static final XPath XPATH;\n+\n+    static {\n+        XPATH = XPathFactory.newInstance().newXPath();\n+        XPATH.setNamespaceContext(new NamespaceContext() {\n+            @Override\n+            public String getNamespaceURI(String prefix) {\n+                return switch (prefix) {\n+                    case \"ds\" -> \"http:\/\/www.w3.org\/2000\/09\/xmldsig#\";\n+                    case \"pss\" -> \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#\";\n+                    default -> throw new IllegalArgumentException();\n+                };\n+            }\n+\n+            @Override\n+            public String getPrefix(String namespaceURI) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Iterator<String> getPrefixes(String namespaceURI) {\n+                return null;\n+            }\n+        });\n+    }\n+\n+    \/\/ Returns an Element inside a Document\n+    public static Element sub(Document d, String path) throws Exception {\n+        return (Element) XMLUtils.XPATH.evaluate(path, d, XPathConstants.NODE);\n+    }\n+\n+    \/\/ Returns a new document with an attribute modified\n+    public static Document withAttribute(Document d, String path, String attr, String value) throws Exception {\n+        d = clone(d);\n+        sub(d, path).setAttribute(attr, value);\n+        return d;\n+    }\n+\n+    \/\/ Returns a new document with a text modified\n+    public static Document withText(Document d, String path, String value) throws Exception {\n+        d = clone(d);\n+        sub(d, path).setTextContent(value);\n+        return d;\n+    }\n+\n+    \/\/ Returns a new document without a child element\n+    public static Document withoutNode(Document d, String path) throws Exception {\n+        d = clone(d);\n+        Element e = sub(d, path);\n+        e.getParentNode().removeChild(e);\n+        return d;\n+    }\n+\n+    \/\/ Clones a document\n+    public static Document clone(Document d) throws Exception {\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder db = dbf.newDocumentBuilder();\n+        Document copiedDocument = db.newDocument();\n+        Node copiedRoot = copiedDocument.importNode(d.getDocumentElement(), true);\n+        copiedDocument.appendChild(copiedRoot);\n+        return copiedDocument;\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ SIGN \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ Creates a signer from a private key and a certificate\n+    public static Signer signer(PrivateKey privateKey, X509Certificate cert)\n+            throws Exception {\n+        return signer(privateKey).cert(cert);\n+    }\n+\n+    \/\/ Creates a signer from a private key and a public key\n+    public static Signer signer(PrivateKey privateKey, PublicKey publicKey)\n+            throws Exception {\n+        return signer(privateKey).publicKey(publicKey);\n+    }\n+\n+    \/\/ Creates a signer from a private key entry in a keystore. The KeyInfo\n+    \/\/ inside the signature will only contain a KeyName to alias\n+    public static Signer signer(KeyStore ks, String alias, char[] password)\n+            throws Exception {\n+        return signer((PrivateKey) ks.getKey(alias, password))\n+                .keyName(alias);\n+    }\n+\n+    \/\/ Creates a signer from a private key. There will be no KeyInfo inside\n+    \/\/ the signature and must be validated with a given public key.\n+    public static Signer signer(PrivateKey privateKey)\n+            throws Exception {\n+        return new Signer(privateKey);\n+    }\n+\n+    public static class Signer {\n+\n+        PrivateKey privateKey;  \/\/ signer key, never null\n+        X509Certificate cert;   \/\/ certificate, optional\n+        PublicKey publicKey;    \/\/ public key, optional\n+        String keyName;         \/\/ alias, optional\n+\n+        SignatureMethod sm;     \/\/ default determined by privateKey\n+        DigestMethod dm;        \/\/ default SHA-256\n+        CanonicalizationMethod cm;  \/\/ default EXCLUSIVE\n+        Transform tr;           \/\/ default ENVELOPED\n+\n+        public Signer(PrivateKey privateKey) throws Exception {\n+            this.privateKey = privateKey;\n+            dm(DigestMethod.SHA256);\n+            tr(Transform.ENVELOPED);\n+            cm(CanonicalizationMethod.EXCLUSIVE);\n+            String alg = privateKey.getAlgorithm();\n+            if (alg.equals(\"RSASSA-PSS\")) {\n+                PSSParameterSpec pspec\n+                        = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n+                if (pspec != null) {\n+                    sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n+                } else {\n+                    sm(SignatureMethod.RSA_PSS);\n+                }\n+            } else {\n+                sm(switch (privateKey.getAlgorithm()) {\n+                    case \"RSA\" -> SignatureMethod.RSA_SHA256;\n+                    case \"DSA\" -> SignatureMethod.DSA_SHA256;\n+                    case \"EC\" -> SignatureMethod.ECDSA_SHA256;\n+                    default -> throw new InvalidKeyException();\n+                });\n+            }\n+        }\n+\n+        \/\/ Change KeyInfo source\n+\n+        public Signer cert(X509Certificate cert) {\n+            this.cert = cert;\n+            return this;\n+        }\n+\n+        public Signer publicKey(PublicKey key) {\n+            this.publicKey = key;\n+            return this;\n+        }\n+\n+        public Signer keyName(String n) {\n+            keyName = n;\n+            return this;\n+        }\n+\n+        \/\/ Change various methods\n+\n+        public Signer tr(String transform) throws Exception {\n+            TransformParameterSpec params = null;\n+            switch (transform) {\n+                case Transform.XPATH:\n+                    params = new XPathFilterParameterSpec(\"\/\/.\");\n+                    break;\n+                case Transform.XPATH2:\n+                    params = new XPathFilter2ParameterSpec(\n+                            Collections.singletonList(new XPathType(\"\/\/.\",\n+                                    XPathType.Filter.INTERSECT)));\n+                    break;\n+            }\n+            tr = FAC.newTransform(transform, params);\n+            return this;\n+        }\n+\n+        public Signer sm(String method) throws Exception {\n+            sm = FAC.newSignatureMethod(method, null);\n+            return this;\n+        }\n+\n+        public Signer dm(String method) throws Exception {\n+            dm = FAC.newDigestMethod(method, null);\n+            return this;\n+        }\n+\n+        public Signer cm(String method) throws Exception {\n+            cm = FAC.newCanonicalizationMethod(method, (C14NMethodParameterSpec) null);\n+            return this;\n+        }\n+\n+        public Signer sm(String method, SignatureMethodParameterSpec spec)\n+                throws Exception {\n+            sm = FAC.newSignatureMethod(method, spec);\n+            return this;\n+        }\n+\n+        public Signer dm(String method, DigestMethodParameterSpec spec)\n+                throws Exception {\n+            dm = FAC.newDigestMethod(method, spec);\n+            return this;\n+        }\n+\n+        \/\/ Signs different sources\n+\n+        \/\/ Signs an XML file in detached mode\n+        public Document sign(URI uri) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(buildSignedInfo(uri.toString()), buildKeyInfo()).sign(\n+                    new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs an XML file in a relative reference in detached mode\n+        public Document sign(URI base, URI ref) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            DOMSignContext ctxt = new DOMSignContext(privateKey, newDocument);\n+            ctxt.setBaseURI(base.toString());\n+            FAC.newXMLSignature(buildSignedInfo(ref.toString()), buildKeyInfo()).sign(ctxt);\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a document in enveloped mode\n+        public Document sign(Document document) throws Exception {\n+            DOMResult result = new DOMResult();\n+            TransformerFactory.newInstance().newTransformer()\n+                    .transform(new DOMSource(document), result);\n+            Document newDocument = (Document) result.getNode();\n+            FAC.newXMLSignature(buildSignedInfo(\"\"), buildKeyInfo()).sign(\n+                    new DOMSignContext(privateKey, newDocument.getDocumentElement()));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a document in enveloping mode\n+        public Document signEnveloping(Document document) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(document.getDocumentElement())),\n+                            \"object\", null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a raw byte array\n+        public Document sign(byte[] data) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(\"#object\", dm, List.of\n+                            (FAC.newTransform(Transform.BASE64,\n+                                    (TransformParameterSpec) null)), null, null)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(\n+                            newDocument.createTextNode(Base64.getEncoder().encodeToString(data)))),\n+                            \"object\", null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a plain string\n+        public Document sign(String str) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(newDocument.createTextNode(str))),\n+                            \"object\", null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Builds a SignedInfo for a string reference\n+        private SignedInfo buildSignedInfo(String ref) {\n+            return FAC.newSignedInfo(\n+                    cm,\n+                    sm,\n+                    List.of(FAC.newReference(\n+                            ref,\n+                            dm,\n+                            List.of(tr),\n+                            null, null)));\n+        }\n+\n+        \/\/ Builds a SignedInfo for a Reference\n+        private SignedInfo buildSignedInfo(Reference ref) {\n+            return FAC.newSignedInfo(\n+                    cm,\n+                    sm,\n+                    List.of(ref));\n+        }\n+\n+        \/\/ Builds a KeyInfo from different sources\n+        private KeyInfo buildKeyInfo() throws Exception {\n+            KeyInfoFactory keyInfoFactory = FAC.getKeyInfoFactory();\n+            if (cert != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newX509Data(List.of(cert))));\n+            } else if (publicKey != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newKeyValue(publicKey)));\n+            } else if (keyName != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newKeyName(keyName)));\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ VALIDATE \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ Create a Validator, ks will be used if there is a KeyName\n+    public static Validator validator(KeyStore ks)\n+            throws Exception {\n+        return new Validator(ks);\n+    }\n+\n+    \/\/ Create a Validator, key will either be inside KeyInfo or\n+    \/\/ a key will be provided when validate() is called\n+    public static Validator validator()\n+            throws Exception {\n+        return new Validator(null);\n+    }\n+\n+    public static class Validator {\n+\n+        private Boolean secureValidation = null;\n+        private String baseURI = null;\n+        private final KeyStore ks;\n+\n+        public Validator(KeyStore ks) {\n+            this.ks = ks;\n+        }\n+\n+        public Validator secureValidation(boolean v) {\n+            this.secureValidation = v;\n+            return this;\n+        }\n+\n+        public Validator baseURI(String base) {\n+            this.baseURI = base;\n+            return this;\n+        }\n+\n+        public boolean validate(Document document) throws Exception {\n+            return validate(document, null);\n+        }\n+\n+        \/\/ If key is not null, any key from the signature will be ignored\n+        public boolean validate(Document document, PublicKey key)\n+                throws Exception {\n+            NodeList nodeList = document.getElementsByTagName(\"Signature\");\n+            if (nodeList.getLength() == 1) {\n+                Node signatureNode = nodeList.item(0);\n+                if (signatureNode != null) {\n+                    KeySelector ks = key == null ? new MyKeySelector(this.ks) : new KeySelector() {\n+                        @Override\n+                        public KeySelectorResult select(KeyInfo ki, Purpose p,\n+                                AlgorithmMethod m, XMLCryptoContext c) {\n+                            return () -> key;\n+                        }\n+                    };\n+                    DOMValidateContext valContext\n+                            = new DOMValidateContext(ks, signatureNode);\n+                    if (baseURI != null) {\n+                        valContext.setBaseURI(baseURI);\n+                    }\n+                    if (secureValidation != null) {\n+                        valContext.setProperty(\"org.jcp.xml.dsig.secureValidation\",\n+                                secureValidation.booleanValue());\n+                        valContext.setProperty(\"org.apache.jcp.xml.dsig.secureValidation\",\n+                                secureValidation.booleanValue());\n+                    }\n+                    return XMLSignatureFactory.getInstance(\"DOM\")\n+                            .unmarshalXMLSignature(valContext).validate(valContext);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ Find public key from KeyInfo, ks will be used if it's KeyName\n+        private static class MyKeySelector extends KeySelector {\n+            private final KeyStore ks;\n+\n+            public MyKeySelector(KeyStore ks) {\n+                this.ks = ks;\n+            }\n+\n+            public KeySelectorResult select(KeyInfo keyInfo,\n+                                            KeySelector.Purpose purpose,\n+                                            AlgorithmMethod method,\n+                                            XMLCryptoContext context)\n+                    throws KeySelectorException {\n+                Objects.requireNonNull(keyInfo, \"Null KeyInfo object!\");\n+\n+                for (XMLStructure xmlStructure : keyInfo.getContent()) {\n+                    PublicKey pk;\n+                    if (xmlStructure instanceof KeyValue kv) {\n+                        try {\n+                            pk = kv.getPublicKey();\n+                        } catch (KeyException ke) {\n+                            throw new KeySelectorException(ke);\n+                        }\n+                        return () -> pk;\n+                    } else if (xmlStructure instanceof X509Data x509) {\n+                        for (Object data : x509.getContent()) {\n+                            if (data instanceof X509Certificate) {\n+                                pk = ((X509Certificate) data).getPublicKey();\n+                                return () -> pk;\n+                            }\n+                        }\n+                    } else if (xmlStructure instanceof KeyName kn) {\n+                        try {\n+                            pk = ks.getCertificate(kn.getName()).getPublicKey();\n+                        } catch (KeyStoreException e) {\n+                            throw new KeySelectorException(e);\n+                        }\n+                        return () -> pk;\n+                    }\n+                }\n+                throw new KeySelectorException(\"No KeyValue element found!\");\n+            }\n+        };\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ MISC \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/**\n+     * Adds a new rule to \"jdk.xml.dsig.secureValidationPolicy\"\n+     *\/\n+    public static void addPolicy(String rule) {\n+        String value = Security.getProperty(\"jdk.xml.dsig.secureValidationPolicy\");\n+        value = rule + \",\" + value;\n+        Security.setProperty(\"jdk.xml.dsig.secureValidationPolicy\", value);\n+    }\n+\n+    private XMLUtils() {\n+        assert false : \"No one instantiates me\";\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":558,"deletions":0,"binary":false,"changes":558,"status":"added"}]}