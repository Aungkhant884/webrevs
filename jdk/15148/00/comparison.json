{"files":[{"patch":"@@ -1273,1 +1273,6 @@\n-                        context.dispatch(me.getKey(), me.getValue());\n+                        try {\n+                            context.dispatch(me.getKey(), me.getValue());\n+                        } catch (Exception e) {\n+                            throw context.conContext.fatal(Alert.INTERNAL_ERROR,\n+                                    \"Unhandled exception\", e);\n+                        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLException;\n+import java.nio.ByteBuffer;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.HexFormat;\n+\n+\/*\n+ * @test\n+ * @bug 8293176\n+ * @summary SSLEngine should close after bad key share\n+ * @run main SSLEngineDecodeBadPoint\n+ *\/\n+public class SSLEngineDecodeBadPoint {\n+    static final byte[] clientHello = HexFormat.of().parseHex(\n+            \"160303013a0100013603031570\" +\n+                    \"151d6066940aa5dfcecc99f470bfdc175eec2c6f3273b079b2f80b49\" +\n+                    \"75c820efe3d307201492a49fcee79fac5b2f05dca26c572b65b0d90d\" +\n+                    \"81f51fd26b49b700021302010000eb000500050100000000000a0016\" +\n+                    \"0014001d001700180019001e01000101010201030104000d00220020\" +\n+                    \"040305030603080708080804080508060809080a080b040105010601\" +\n+                    \"02030201002b0003020304002d000201010032002200200403050306\" +\n+                    \"03080708080804080508060809080a080b0401050106010203020100\" +\n+                    \"33006b0069001d00209a4d13131f83cc4c5be46520f0b4d7a6f1d3f6\" +\n+                    \"ca7118e6dd115125090da6e044\" +\n+                    \/\/ ECDHE key share, 5th byte changed from 04 to (invalid) 05\n+                    \"0017004105d8c3734b9c729f6a9851\" +\n+                    \"5049543ec5a9bb6c19b8c02ca0bdc3b20a77c44acdab226b6329b7c5\" +\n+                    \"db9204421932c6fa1abe614c6892f5289edf9ff43cac534cad9e\");\n+\n+    public static void main(String[] args) throws NoSuchAlgorithmException, SSLException {\n+        SSLContext ctx = SSLContext.getDefault();\n+        SSLEngine eng = ctx.createSSLEngine();\n+        eng.setUseClientMode(false);\n+        eng.beginHandshake();\n+        ByteBuffer hello = ByteBuffer.wrap(clientHello);\n+        ByteBuffer emptyBuf = ByteBuffer.allocate(0);\n+        SSLEngineResult res = eng.unwrap(hello, emptyBuf);\n+        System.out.println(\"status after unwrap: \" + res);\n+        eng.getDelegatedTask().run();\n+\n+        SSLEngineResult.HandshakeStatus status = eng.getHandshakeStatus();\n+        System.out.println(\"status after task: \" + status);\n+        if (status != SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+            throw new RuntimeException(\"Unexpected status after task: \" + status);\n+        }\n+        ByteBuffer alert = ByteBuffer.allocate(eng.getSession().getPacketBufferSize());\n+\n+        try {\n+            eng.wrap(emptyBuf, alert);\n+            throw new RuntimeException(\"Expected wrap to throw\");\n+        } catch (Exception e) {\n+            System.err.println(\"Received expected exception:\");\n+            e.printStackTrace();\n+        }\n+        if (alert.position() != 0) {\n+            throw new RuntimeException(\"Expected no bytes written in first wrap call\");\n+        }\n+        res = eng.wrap(emptyBuf, alert);\n+        System.out.println(\"status after wrap: \" + res);\n+        if (res.getStatus() != SSLEngineResult.Status.CLOSED ||\n+                res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            throw new RuntimeException(\"Unexpected status after wrap: \" + res);\n+        }\n+        if (!eng.isOutboundDone()) {\n+            throw new RuntimeException(\"Expected outbound done\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineDecodeBadPoint.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}