{"files":[{"patch":"@@ -894,2 +894,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr002\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm\/native --enable-preview -agentlib:allthr01 allthr01\n+ * @run main\/othervm\/native --enable-preview -Djava.util.concurrent.ForkJoinPool.common.parallelism=1 -agentlib:allthr01 allthr01\n@@ -56,1 +56,0 @@\n-    native static void setSysCnt();\n@@ -67,1 +66,0 @@\n-        setSysCnt();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetAllThreads\/allthr01\/allthr01.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,5 @@\n+typedef struct  {\n+  info expected;\n+  info unexpected;\n+} thread_info;\n+\n@@ -40,5 +45,0 @@\n-static int system_threads_count;\n-static const char *names0[] = {\"main\"};\n-static const char *names1[] = {\"main\", \"thread1\"};\n-static const char *names2[] = {\"main\", \"Thread-\"};\n-static const char *names3[] = {\"main\", \"ForkJoinPool-\"};\n@@ -46,6 +46,22 @@\n-\/*\n- * Expected number and names of threads started by test for each test point\n- *\/\n-static info expected_thread_info[] = {\n-    {1, names0}, {1, names0}, {2, names1},\n-    {1, names0}, {2, names2},  {2, names3}\n+static const char main_name[] = \"main\";\n+static const char thread1_name[] = \"thread1\";\n+static const char sys_thread_name[] = \"SysThread\";\n+\/\/ Tes uses -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+\/\/ to make name of carrier thread deterministic\n+static const char fj_thread_name[] = \"ForkJoinPool-1-worker-1\";\n+\n+static const char *main_only[] = { main_name };\n+static const char *thr1_only[] = { thread1_name };\n+static const char *sys_only[] = { sys_thread_name };\n+static const char *main_thr1[] = { main_name, thread1_name };\n+static const char *main_sys[] = { main_name, sys_thread_name };\n+static const char *thr1_sys[] = { thread1_name, sys_thread_name };\n+static const char *main_fj[] = { main_name, fj_thread_name };\n+\n+static thread_info thr_info[] = {\n+  {{1, main_only},    {2, thr1_sys}},\n+  {{1, main_only},    {2, thr1_sys}},\n+  {{2, main_thr1},    {1, sys_only}},\n+  {{1, main_only},    {2, thr1_sys}},\n+  {{2, main_sys},     {1, thr1_only}},\n+  {{2, main_fj},      {1, thr1_sys}}\n@@ -54,3 +70,0 @@\n-const char VTHREAD_PREFIX[] = \"ForkJoinPool\";\n-\n-\n@@ -58,3 +71,6 @@\n-  jclass thrClass = jni->FindClass(\"java\/lang\/Thread\");\n-  jmethodID cid = jni->GetMethodID(thrClass, \"<init>\", \"()V\");\n-  return jni->NewObject(thrClass, cid);\n+  jclass thr_class = jni->FindClass(\"java\/lang\/Thread\");\n+  jmethodID cid = jni->GetMethodID(thr_class, \"<init>\", \"(Ljava\/lang\/String;)V\");\n+  jstring thread_name = jni->NewStringUTF(sys_thread_name);\n+  jthread res = jni->NewObject(thr_class, cid, thread_name);\n+  jni->DeleteLocalRef(thread_name);\n+  return res;\n@@ -100,1 +116,0 @@\n-  jboolean result = JNI_TRUE;\n@@ -103,1 +118,1 @@\n-  int num_unexpected = 0;\n+  jvmtiThreadInfo inf;\n@@ -110,0 +125,1 @@\n+  \/\/ check unexpected threads\n@@ -111,5 +127,12 @@\n-    if (!isThreadExpected(jvmti_env, threads[i])) {\n-      num_unexpected++;\n-      LOG(\">>> unexpected:  \");\n-    } else {\n-      LOG(\">>> expected: \");\n+    err = jvmti_env->GetThreadInfo(threads[i], &inf);\n+    check_jvmti_status(jni, err, \"Failed in GetThreadInfo\");\n+    char *name = get_thread_name(jvmti_env, jni, threads[i]);\n+    LOG(\" >>> %s\", name);\n+\n+    bool found = false;\n+    for (int j = 0; j < thr_info[idx].unexpected.cnt && !found; j++) {\n+      found = strcmp(name, thr_info[idx].unexpected.thr_names[j]) == 0;\n+    }\n+    if (found) {\n+      LOG(\"Point %d: detected unexpected thread %s\\n\", idx, inf.name);\n+      return JNI_FALSE;\n@@ -117,1 +140,0 @@\n-    print_thread_info(jvmti_env, jni, threads[i]);\n@@ -120,5 +142,1 @@\n-  if (threads_count - num_unexpected != expected_thread_info[idx].cnt + system_threads_count) {\n-    LOG(\"Point %d: number of threads expected: %d, got: %d\\n\",\n-           idx, expected_thread_info[idx].cnt + system_threads_count, threads_count - num_unexpected);\n-    return JNI_FALSE;\n-  }\n+  LOG(\"\\n\");\n@@ -126,1 +144,2 @@\n-  for (int i = 0; i < expected_thread_info[idx].cnt; i++) {\n+  \/\/ verify all expected threads are present\n+  for (int i = 0; i < thr_info[idx].expected.cnt; i++) {\n@@ -130,4 +149,1 @@\n-      found = strstr(name, expected_thread_info[idx].thr_names[i]);\n-      if (found) {\n-        LOG(\" >>> found: %s\\n\", name);\n-      }\n+      found = strcmp(name, thr_info[idx].expected.thr_names[i]) == 0;\n@@ -135,1 +151,0 @@\n-\n@@ -137,2 +152,2 @@\n-      LOG(\"Point %d: thread %s not detected\\n\", idx, expected_thread_info[idx].thr_names[i]);\n-      result = JNI_FALSE;\n+      LOG(\"Point %d: thread %s not detected\\n\", idx, thr_info[idx].expected.thr_names[i]);\n+      return JNI_FALSE;\n@@ -143,2 +158,1 @@\n-\n-  return result;\n+  return JNI_TRUE;\n@@ -147,1 +161,2 @@\n-JNIEXPORT void Java_allthr01_startAgentThread(JNIEnv *jni) {\n+JNIEXPORT void\n+Java_allthr01_startAgentThread(JNIEnv *jni) {\n@@ -163,21 +178,0 @@\n-\n-\n-JNIEXPORT void JNICALL\n-Java_allthr01_setSysCnt(JNIEnv *jni, jclass cls) {\n-  jint threadsCount = -1;\n-  jthread *threads;\n-\n-  jvmtiError err = jvmti_env->GetAllThreads(&threadsCount, &threads);\n-  check_jvmti_status(jni,err, \"Failed in GetAllThreads\");\n-\n-  system_threads_count = threadsCount - 1;\n-\n-  for (int i = 0; i < threadsCount; i++) {\n-    if (!isThreadExpected(jvmti_env, threads[i])) {\n-      system_threads_count--;\n-    }\n-  }\n-\n-  LOG(\" >>> number of system threads: %d\\n\", system_threads_count);\n-}\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetAllThreads\/allthr01\/liballthr01.cpp","additions":57,"deletions":63,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetAllThreads;\n-\n-import java.io.PrintStream;\n-\n-public class allthr001 {\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"allthr001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load allthr001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void checkInfo(int thr_ind);\n-    native static int getRes();\n-\n-    public static Object lock1 = new Object();\n-    public static Object lock2 = new Object();\n-    public static int waitTime = 2;\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-\n-        checkInfo(0);\n-\n-        ThreadGroup tg = new ThreadGroup(\"tg1\");\n-        allthr001a t_a = new allthr001a(tg, \"thread1\");\n-        t_a.setDaemon(true);\n-        checkInfo(1);\n-\n-        synchronized (lock1) {\n-            try {\n-                t_a.start();\n-                lock1.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-        checkInfo(2);\n-\n-        synchronized (lock2) {\n-            lock2.notify();\n-        }\n-\n-        try {\n-            t_a.join(waitTime * 60000);\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-        checkInfo(3);\n-\n-        checkInfo(4);\n-        return getRes();\n-    }\n-}\n-\n-class allthr001a extends Thread {\n-    allthr001a(ThreadGroup tg, String name) {\n-        super(tg, name);\n-    }\n-\n-    public void run() {\n-        synchronized (allthr001.lock2) {\n-            synchronized (allthr001.lock1) {\n-                allthr001.lock1.notify();\n-            }\n-            try {\n-                allthr001.lock2.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr001.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetAllThreads\/allthr001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetAllThreads.\n- *     The test cases include:\n- *     - user-defined java and debug threads\n- *     - running and dead threads\n- * COMMENTS\n- *     Fixed according to the 4480280 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:allthr001=printdump nsk.jvmti.GetAllThreads.allthr001 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr001\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,312 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-\n-typedef struct {\n-    int cnt;\n-    const char **thrNames;\n-} info;\n-\n-typedef struct  {\n-    info expected;\n-    info unexpected;\n-} threadInfo;\n-\n-static jvmtiEnv *jvmti;\n-static jrawMonitorID lock1;\n-static jrawMonitorID lock2;\n-static jboolean printdump = JNI_FALSE;\n-static jint result = PASSED;\n-\n-static const char main_name[] = \"main\";\n-static const char thread1_name[] = \"thread1\";\n-static const char sys_thread_name[] = \"SysThread\";\n-\n-static const char *main_only[] = { main_name };\n-static const char *thr1_only[] = { thread1_name };\n-static const char *sys_only[] = { sys_thread_name };\n-static const char *main_thr1[] = { main_name, thread1_name };\n-static const char *main_sys[] = { main_name, sys_thread_name };\n-static const char *thr1_sys[] = { thread1_name, sys_thread_name };\n-\n-static threadInfo thrInfo[] = {\n-    {{1, main_only},    {2, thr1_sys}},\n-    {{1, main_only},    {2, thr1_sys}},\n-    {{2, main_thr1},    {1, sys_only}},\n-    {{1, main_only},    {2, thr1_sys}},\n-    {{2, main_sys},     {1, thr1_only}}\n-};\n-\n-jthread jthr(JNIEnv *env) {\n-    jclass thrClass;\n-    jmethodID cid;\n-    jthread res;\n-    thrClass = env->FindClass(\"java\/lang\/Thread\");\n-    cid = env->GetMethodID(thrClass, \"<init>\", \"(Ljava\/lang\/String;)V\");\n-    jstring thread_name = env->NewStringUTF(sys_thread_name);\n-    res = env->NewObject(thrClass, cid, thread_name);\n-    env->DeleteLocalRef(thread_name);\n-    return res;\n-}\n-\n-static void JNICALL\n-sys_thread(jvmtiEnv* jvmti, JNIEnv* jni, void *p) {\n-    jvmtiError err;\n-\n-    err = jvmti->RawMonitorEnter(lock2);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enter raw monitor 2 (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/* allows the main thread to wait until the child thread is running *\/\n-    err = jvmti->RawMonitorEnter(lock1);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enter raw monitor 1 (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorNotify(lock1);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to notify raw monitor (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(lock1);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to exit raw monitor 1 (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/* keeps the child thread from exiting *\/\n-    err = jvmti->RawMonitorWait(lock2, (jlong)0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to wait raw monitor (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(lock2);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to exit raw monitor 2 (thread): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_allthr001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_allthr001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_allthr001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_lock1\", &lock1);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to create raw monitor 1, err = %d\\n\", err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_lock2\", &lock2);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to create raw monitor 2, err = %d\\n\", err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-void releaseThreadInfo(JNIEnv *env, jvmtiThreadInfo *info) {\n-    jvmti->Deallocate((unsigned char *)info->name);\n-    if (info->thread_group != NULL) {\n-        env->DeleteLocalRef(info->thread_group);\n-    }\n-    if (info->context_class_loader != NULL) {\n-        env->DeleteLocalRef(info->context_class_loader);\n-    }\n-}\n-\n-JNIEXPORT void checkInfo(JNIEnv *env, int ind) {\n-    jint threadsCount = -1;\n-    jthread *threads;\n-    jvmtiError err;\n-    int expected = 0;\n-    jvmtiThreadInfo inf;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\" >>> Check: %d\\n\", ind);\n-    }\n-\n-    if (ind == 4) {\n-        err = jvmti->RawMonitorEnter(lock1);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enter raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RunAgentThread(jthr(env), sys_thread, NULL,\n-                                       JVMTI_THREAD_NORM_PRIORITY);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to start agent thread: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorWait(lock1, (jlong)0);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to wait raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorExit(lock1);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to exit raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    err = jvmti->GetAllThreads(&threadsCount, &threads);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to get all threads (check): %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    \/\/ check unexpected threads\n-    for (int i = 0; i < threadsCount; i++) {\n-        err = jvmti->GetThreadInfo(threads[i], &inf);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to get thread info: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\" >>> %s\", inf.name);\n-        }\n-        bool found = false;\n-        for (int j = 0; j < thrInfo[ind].unexpected.cnt && !found; j++) {\n-            found = (inf.name != NULL && strcmp(inf.name, thrInfo[ind].unexpected.thrNames[j]) == 0);\n-        }\n-        if (found) {\n-            printf(\"Point %d: detected unexpected thread %s\\n\", ind, inf.name);\n-            result = STATUS_FAILED;\n-        }\n-        releaseThreadInfo(env, &inf);\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\"\\n\");\n-    }\n-\n-    \/\/ verify all expected threads are present\n-    for (int i = 0; i < thrInfo[ind].expected.cnt; i++) {\n-        bool found = false;\n-        for (int j = 0; j < threadsCount && !found; j++) {\n-            err = jvmti->GetThreadInfo(threads[j], &inf);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"Failed to get thread info: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                result = STATUS_FAILED;\n-                return;\n-            }\n-            found = (inf.name != NULL && strcmp(inf.name, thrInfo[ind].expected.thrNames[j]) == 0);\n-            releaseThreadInfo(env, &inf);\n-        }\n-        if (!found) {\n-            printf(\"Point %d: thread %s not detected\\n\",\n-                   ind, thrInfo[ind].expected.thrNames[i]);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    err = jvmti->Deallocate((unsigned char *)threads);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to deallocate array: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (ind == 4) {\n-        err = jvmti->RawMonitorEnter(lock2);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enter raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorNotify(lock2);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to notify raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorExit(lock2);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to exit raw monitor (check): %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetAllThreads_allthr001_checkInfo(JNIEnv *env, jclass cls, jint ind) {\n-    checkInfo(env, ind);\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetAllThreads_allthr001_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr001\/allthr001.cpp","additions":0,"deletions":312,"binary":false,"changes":312,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"allthr001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr001\/liballthr001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetAllThreads;\n-\n-import java.io.PrintStream;\n-\n-public class allthr002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"allthr002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load allthr002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr002.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetAllThreads\/allthr002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetAllThreads(threadsCountPtr, threadsPtr)\n- *     The test checks the following:\n- *       - if JVMTI_ERROR_NULL_POINTER is returned when threadsCountPtr is null\n- *       - if JVMTI_ERROR_NULL_POINTER is returned when threadsPtr is null\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:allthr002 nsk.jvmti.GetAllThreads.allthr002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr002\/TestDescription.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_allthr002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_allthr002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_allthr002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetAllThreads_allthr002_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jint threadsCountPtr;\n-    jthread *threadsPtr;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (threadsCountPtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetAllThreads(NULL, &threadsPtr);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(threadsCountPtr) error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (threadsPtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetAllThreads(&threadsCountPtr, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(threadsPtr) error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> done\\n\");\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr002\/allthr002.cpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"allthr002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAllThreads\/allthr002\/liballthr002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"}]}