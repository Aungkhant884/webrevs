{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -134,0 +135,1 @@\n+\n@@ -135,2 +137,8 @@\n-        assert(ctor.isConstructor() && ctor.getName().equals(\"<init>\"));\n-        Class<?> instanceClass = ctor.getDeclaringClass();\n+        return makeAllocator(ctor.getDeclaringClass(), ctor);\n+    }\n+\n+    \/**\n+     * Allows serialization constructor to allocate and invoke constructor of different types.\n+     *\/\n+    static DirectMethodHandle makeAllocator(Class<?> instanceClass, MemberName ctor) {\n+        assert (ctor.isConstructor() && ctor.getName().equals(ConstantDescs.INIT_NAME));\n@@ -138,1 +146,1 @@\n-        assert(ctor.isConstructor() && ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n+        assert (ctor.isConstructor() && ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1663,0 +1663,7 @@\n+\n+            @Override\n+            public MethodHandle serializableConstructorAccessor(Class<?> allocated, Constructor<?> toCall) {\n+                \/\/ This is also called via sun.reflect.ReflectionFactory public API\n+                MemberName mn = new MemberName(toCall);\n+                return DirectMethodHandle.makeAllocator(allocated, mn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,5 @@\n+    @Override\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex) {\n+        return ex.getSharedExceptionTypes();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -176,0 +176,11 @@\n+\n+    \/**\n+     * Returns a method handle that allocates an instance of a class and calls a constructor of\n+     * one of its superclasses. Used by serialization, but also exposed via sun.reflect.ReflectionFactory.\n+     *\n+     * @param allocated the allocated type\n+     * @param toCall the constructor of a supertype of the allocated type to call\n+     * @see <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/20\/docs\/specs\/serialization\/input.html#the-objectinputstream-class\">\n+     *     The ObjectInputStream Class<\/a>\n+     *\/\n+    MethodHandle serializableConstructorAccessor(Class<?> allocated, Constructor<?> toCall);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,3 @@\n+    \/** Gets the shared array of exception types of an Executable. *\/\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,9 +107,1 @@\n-            int paramCount = mh.type().parameterCount();\n-            MethodHandle target = mh.asFixedArity();\n-            MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n-            if (paramCount > SPECIALIZED_PARAM_COUNT) {\n-                \/\/ spread the parameters only for the non-specialized case\n-                target = target.asSpreader(Object[].class, paramCount);\n-            }\n-            target = target.asType(mtype);\n-            return DirectConstructorHandleAccessor.constructorAccessor(ctor, target);\n+            return maybeSpecializeDirectConstructorHandleAccessor(ctor, mh);\n@@ -121,0 +113,15 @@\n+    \/**\n+     * Shared routine, can also wrap serialization constructor allocator in an accessor.\n+     *\/\n+    static ConstructorAccessorImpl maybeSpecializeDirectConstructorHandleAccessor(Constructor<?> ctor, MethodHandle mh) {\n+        int paramCount = mh.type().parameterCount();\n+        MethodHandle target = mh.asFixedArity();\n+        MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+            \/\/ spread the parameters only for the non-specialized case\n+            target = target.asSpreader(Object[].class, paramCount);\n+        }\n+        target = target.asType(mtype);\n+        return DirectConstructorHandleAccessor.constructorAccessor(ctor, target);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Objects;\n@@ -44,0 +45,2 @@\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -203,14 +206,0 @@\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -288,1 +277,1 @@\n-        return generateConstructor(cl, constructorToCall);\n+        return generateSerializableConstructor(cl, constructorToCall);\n@@ -367,1 +356,1 @@\n-        return generateConstructor(cl, constructorToCall);\n+        return generateSerializableConstructor(cl, constructorToCall);\n@@ -370,22 +359,22 @@\n-    private final Constructor<?> generateConstructor(Class<?> cl,\n-                                                     Constructor<?> constructorToCall) {\n-\n-\n-        ConstructorAccessor acc = new SerializationConstructorAccessorGenerator().\n-            generateSerializationConstructor(cl,\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             constructorToCall.getDeclaringClass());\n-        Constructor<?> c = newConstructor(constructorToCall.getDeclaringClass(),\n-                                          constructorToCall.getParameterTypes(),\n-                                          constructorToCall.getExceptionTypes(),\n-                                          constructorToCall.getModifiers(),\n-                                          langReflectAccess.\n-                                          getConstructorSlot(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorSignature(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorAnnotations(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorParameterAnnotations(constructorToCall));\n-        setConstructorAccessor(c, acc);\n+    private Constructor<?> generateSerializableConstructor(Class<?> cl, Constructor<?> constructorToCall) {\n+        Objects.requireNonNull(cl); \/\/ constructorToCall.getDeclaringClass checks null\n+        Constructor<?> c = newConstructor(\n+                constructorToCall.getDeclaringClass(),\n+                langReflectAccess.getExecutableSharedParameterTypes(constructorToCall),\n+                langReflectAccess.getExecutableSharedExceptionTypes(constructorToCall),\n+                constructorToCall.getModifiers(),\n+                langReflectAccess.getConstructorSlot(constructorToCall),\n+                langReflectAccess.getConstructorSignature(constructorToCall),\n+                langReflectAccess.getConstructorAnnotations(constructorToCall),\n+                langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n+\n+        assert VM.isJavaLangInvokeInited() : \"Cannot use method handle serialization constructors before j.l.i is ready\";\n+        class InvokeAccessHolder {\n+            \/\/ ReflectionFactory is initialized earlier\n+            static final JavaLangInvokeAccess ACCESS = SharedSecrets.getJavaLangInvokeAccess();\n+        }\n+\n+        var accessor = MethodHandleAccessorFactory.maybeSpecializeDirectConstructorHandleAccessor(c,\n+                InvokeAccessHolder.ACCESS.serializableConstructorAccessor(cl, constructorToCall));\n+\n+        langReflectAccess.setConstructorAccessor(c, accessor);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":27,"deletions":38,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -64,18 +64,0 @@\n-    \/** This routine is not thread-safe *\/\n-    public SerializationConstructorAccessorImpl\n-    generateSerializationConstructor(Class<?> declaringClass,\n-                                     Class<?>[] parameterTypes,\n-                                     int modifiers,\n-                                     Class<?> targetConstructorClass)\n-    {\n-        return (SerializationConstructorAccessorImpl)\n-            generate(declaringClass,\n-                     \"<init>\",\n-                     parameterTypes,\n-                     Void.TYPE,\n-                     modifiers,\n-                     true,\n-                     true,\n-                     targetConstructorClass);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"}]}