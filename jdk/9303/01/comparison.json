{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/os\/linux\/decoder_linux.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_MUTEX_POSIX_HPP\n+#define OS_POSIX_MUTEX_POSIX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <pthread.h>\n+\n+\n+\/\/ Workaround for a bug in macOSX kernel's pthread support (fixed in Mojave?).\n+\/\/ Avoid ever allocating a pthread_mutex_t at the same address as one of our\n+\/\/ former pthread_cond_t, by using freelists of mutexes and condvars.\n+\/\/ Conditional to avoid extra indirection and padding loss on other platforms.\n+#ifdef __APPLE__\n+#define PLATFORM_MONITOR_IMPL_INDIRECT 1\n+#else\n+#define PLATFORM_MONITOR_IMPL_INDIRECT 0\n+#endif\n+\n+\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n+\/\/ Note that we use \"normal\" pthread_mutex_t attributes so that recursive\n+\/\/ locking is not supported, which matches the expected semantics of the\n+\/\/ VM Mutex class.\n+\n+class PlatformMutex : public CHeapObj<mtSynchronizer> {\n+#if PLATFORM_MONITOR_IMPL_INDIRECT\n+  class Mutex : public CHeapObj<mtSynchronizer> {\n+   public:\n+    pthread_mutex_t _mutex;\n+    Mutex* _next;\n+\n+    Mutex();\n+    ~Mutex();\n+  };\n+\n+  Mutex* _impl;\n+\n+  static pthread_mutex_t _freelist_lock; \/\/ used for mutex and cond freelists\n+  static Mutex* _mutex_freelist;\n+\n+ protected:\n+  class WithFreeListLocked;\n+  pthread_mutex_t* mutex() { return &(_impl->_mutex); }\n+\n+ public:\n+  PlatformMutex();              \/\/ Use freelist allocation of impl.\n+  ~PlatformMutex();\n+\n+  static void init();           \/\/ Initialize the freelist.\n+\n+#else\n+\n+  pthread_mutex_t _mutex;\n+\n+ protected:\n+  pthread_mutex_t* mutex() { return &_mutex; }\n+\n+ public:\n+  static void init() {}         \/\/ Nothing needed for the non-indirect case.\n+\n+  PlatformMutex();\n+  ~PlatformMutex();\n+\n+#endif \/\/ PLATFORM_MONITOR_IMPL_INDIRECT\n+\n+ private:\n+  NONCOPYABLE(PlatformMutex);\n+\n+ public:\n+  void lock();\n+  void unlock();\n+  bool try_lock();\n+};\n+\n+class PlatformMonitor : public PlatformMutex {\n+#if PLATFORM_MONITOR_IMPL_INDIRECT\n+  class Cond : public CHeapObj<mtSynchronizer> {\n+   public:\n+    pthread_cond_t _cond;\n+    Cond* _next;\n+\n+    Cond();\n+    ~Cond();\n+  };\n+\n+  Cond* _impl;\n+\n+  static Cond* _cond_freelist;\n+\n+  pthread_cond_t* cond() { return &(_impl->_cond); }\n+\n+ public:\n+  PlatformMonitor();            \/\/ Use freelist allocation of impl.\n+  ~PlatformMonitor();\n+\n+#else\n+\n+  pthread_cond_t _cond;\n+  pthread_cond_t* cond() { return &_cond; }\n+\n+ public:\n+  PlatformMonitor();\n+  ~PlatformMonitor();\n+\n+#endif \/\/ PLATFORM_MONITOR_IMPL_INDIRECT\n+\n+ private:\n+  NONCOPYABLE(PlatformMonitor);\n+\n+ public:\n+  int wait(jlong millis);\n+  void notify();\n+  void notify_all();\n+};\n+\n+#endif \/\/ OS_POSIX_MUTEX_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/mutex_posix.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/park.hpp\"\n@@ -1158,56 +1159,0 @@\n-Thread* os::ThreadCrashProtection::_protected_thread = NULL;\n-os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;\n-\n-os::ThreadCrashProtection::ThreadCrashProtection() {\n-  _protected_thread = Thread::current();\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n-}\n-\n-\/*\n- * See the caveats for this class in os_posix.hpp\n- * Protects the callback call so that SIGSEGV \/ SIGBUS jumps back into this\n- * method and returns false. If none of the signals are raised, returns true.\n- * The callback is supposed to provide the method that should be protected.\n- *\/\n-bool os::ThreadCrashProtection::call(os::CrashProtectionCallback& cb) {\n-  sigset_t saved_sig_mask;\n-\n-  \/\/ we cannot rely on sigsetjmp\/siglongjmp to save\/restore the signal mask\n-  \/\/ since on at least some systems (OS X) siglongjmp will restore the mask\n-  \/\/ for the process, not the thread\n-  pthread_sigmask(0, NULL, &saved_sig_mask);\n-  if (sigsetjmp(_jmpbuf, 0) == 0) {\n-    \/\/ make sure we can see in the signal handler that we have crash protection\n-    \/\/ installed\n-    _crash_protection = this;\n-    cb.call();\n-    \/\/ and clear the crash protection\n-    _crash_protection = NULL;\n-    _protected_thread = NULL;\n-    return true;\n-  }\n-  \/\/ this happens when we siglongjmp() back\n-  pthread_sigmask(SIG_SETMASK, &saved_sig_mask, NULL);\n-  _crash_protection = NULL;\n-  _protected_thread = NULL;\n-  return false;\n-}\n-\n-void os::ThreadCrashProtection::restore() {\n-  assert(_crash_protection != NULL, \"must have crash protection\");\n-  siglongjmp(_jmpbuf, 1);\n-}\n-\n-void os::ThreadCrashProtection::check_crash_protection(int sig,\n-    Thread* thread) {\n-\n-  if (thread != NULL &&\n-      thread == _protected_thread &&\n-      _crash_protection != NULL) {\n-\n-    if (sig == SIGSEGV || sig == SIGBUS) {\n-      _crash_protection->restore();\n-    }\n-  }\n-}\n-\n@@ -1240,1 +1185,1 @@\n-  os::PlatformMutex::init();\n+  PlatformMutex::init();\n@@ -1507,5 +1452,0 @@\n-\n-\/\/ Shared pthread_mutex\/cond based PlatformEvent implementation.\n-\/\/ Not currently usable by Solaris.\n-\n-\n@@ -1527,1 +1467,1 @@\n-os::PlatformEvent::PlatformEvent() {\n+PlatformEvent::PlatformEvent() {\n@@ -1536,1 +1476,1 @@\n-void os::PlatformEvent::park() {       \/\/ AKA \"down()\"\n+void PlatformEvent::park() {       \/\/ AKA \"down()\"\n@@ -1578,1 +1518,1 @@\n-int os::PlatformEvent::park(jlong millis) {\n+int PlatformEvent::park(jlong millis) {\n@@ -1630,1 +1570,1 @@\n-void os::PlatformEvent::unpark() {\n+void PlatformEvent::unpark() {\n@@ -1673,1 +1613,1 @@\n- os::PlatformParker::PlatformParker() : _counter(0), _cur_index(-1) {\n+ PlatformParker::PlatformParker() : _counter(0), _cur_index(-1) {\n@@ -1682,1 +1622,1 @@\n-os::PlatformParker::~PlatformParker() {\n+PlatformParker::~PlatformParker() {\n@@ -1804,1 +1744,1 @@\n-os::PlatformMutex::Mutex::Mutex() : _next(NULL) {\n+PlatformMutex::Mutex::Mutex() : _next(NULL) {\n@@ -1809,1 +1749,1 @@\n-os::PlatformMutex::Mutex::~Mutex() {\n+PlatformMutex::Mutex::~Mutex() {\n@@ -1814,2 +1754,2 @@\n-pthread_mutex_t os::PlatformMutex::_freelist_lock;\n-os::PlatformMutex::Mutex* os::PlatformMutex::_mutex_freelist = NULL;\n+pthread_mutex_t PlatformMutex::_freelist_lock;\n+PlatformMutex::Mutex* PlatformMutex::_mutex_freelist = NULL;\n@@ -1817,1 +1757,1 @@\n-void os::PlatformMutex::init() {\n+void PlatformMutex::init() {\n@@ -1822,1 +1762,1 @@\n-struct os::PlatformMutex::WithFreeListLocked : public StackObj {\n+struct PlatformMutex::WithFreeListLocked : public StackObj {\n@@ -1834,1 +1774,1 @@\n-os::PlatformMutex::PlatformMutex() {\n+PlatformMutex::PlatformMutex() {\n@@ -1847,1 +1787,1 @@\n-os::PlatformMutex::~PlatformMutex() {\n+PlatformMutex::~PlatformMutex() {\n@@ -1854,1 +1794,1 @@\n-os::PlatformMonitor::Cond::Cond() : _next(NULL) {\n+PlatformMonitor::Cond::Cond() : _next(NULL) {\n@@ -1859,1 +1799,1 @@\n-os::PlatformMonitor::Cond::~Cond() {\n+PlatformMonitor::Cond::~Cond() {\n@@ -1864,1 +1804,1 @@\n-os::PlatformMonitor::Cond* os::PlatformMonitor::_cond_freelist = NULL;\n+PlatformMonitor::Cond* PlatformMonitor::_cond_freelist = NULL;\n@@ -1866,1 +1806,1 @@\n-os::PlatformMonitor::PlatformMonitor() {\n+PlatformMonitor::PlatformMonitor() {\n@@ -1879,1 +1819,1 @@\n-os::PlatformMonitor::~PlatformMonitor() {\n+PlatformMonitor::~PlatformMonitor() {\n@@ -1888,1 +1828,1 @@\n-os::PlatformMutex::PlatformMutex() {\n+PlatformMutex::PlatformMutex() {\n@@ -1893,1 +1833,1 @@\n-os::PlatformMutex::~PlatformMutex() {\n+PlatformMutex::~PlatformMutex() {\n@@ -1898,1 +1838,1 @@\n-os::PlatformMonitor::PlatformMonitor() {\n+PlatformMonitor::PlatformMonitor() {\n@@ -1903,1 +1843,1 @@\n-os::PlatformMonitor::~PlatformMonitor() {\n+PlatformMonitor::~PlatformMonitor() {\n@@ -1911,1 +1851,1 @@\n-int os::PlatformMonitor::wait(jlong millis) {\n+int PlatformMonitor::wait(jlong millis) {\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":26,"deletions":86,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -99,191 +99,0 @@\n-\/*\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n- * back.\n- * To be able to use this - don't take locks, don't rely on destructors,\n- * don't make OS library calls, don't allocate memory, don't print,\n- * don't call code that could leave the heap \/ memory in an inconsistent state,\n- * or anything else where we are not in control if we suddenly jump out.\n- *\/\n-class ThreadCrashProtection : public StackObj {\n-public:\n-  static bool is_crash_protected(Thread* thr) {\n-    return _crash_protection != NULL && _protected_thread == thr;\n-  }\n-\n-  ThreadCrashProtection();\n-  bool call(os::CrashProtectionCallback& cb);\n-\n-  static void check_crash_protection(int signal, Thread* thread);\n-private:\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n-  void restore();\n-  sigjmp_buf _jmpbuf;\n-};\n-\n-\/*\n- * This is the platform-specific implementation underpinning\n- * the ParkEvent class, which itself underpins Java-level monitor\n- * operations. See park.hpp for details.\n- * These event objects are type-stable and immortal - we never delete them.\n- * Events are associated with a thread for the lifetime of the thread.\n- *\/\n-class PlatformEvent : public CHeapObj<mtSynchronizer> {\n- private:\n-  double cachePad[4];        \/\/ Increase odds that _mutex is sole occupant of cache line\n-  volatile int _event;       \/\/ Event count\/permit: -1, 0 or 1\n-  volatile int _nParked;     \/\/ Indicates if associated thread is blocked: 0 or 1\n-  pthread_mutex_t _mutex[1]; \/\/ Native mutex for locking\n-  pthread_cond_t  _cond[1];  \/\/ Native condition variable for blocking\n-  double postPad[2];\n-\n- protected:       \/\/ TODO-FIXME: make dtor private\n-  ~PlatformEvent() { guarantee(false, \"invariant\"); } \/\/ immortal so can't delete\n-\n- public:\n-  PlatformEvent();\n-  void park();\n-  int  park(jlong millis);\n-  void unpark();\n-\n-  \/\/ Use caution with reset() and fired() -- they may require MEMBARs\n-  void reset() { _event = 0; }\n-  int  fired() { return _event; }\n-};\n-\n-\/\/ JSR166 support\n-\/\/ PlatformParker provides the platform dependent base class for the\n-\/\/ Parker class. It basically provides the internal data structures:\n-\/\/ - mutex and convars\n-\/\/ which are then used directly by the Parker methods defined in the OS\n-\/\/ specific implementation files.\n-\/\/ There is significant overlap between the funcionality supported in the\n-\/\/ combination of Parker+PlatformParker and PlatformEvent (above). If Parker\n-\/\/ were more like ObjectMonitor we could use PlatformEvent in both (with some\n-\/\/ API updates of course). But Parker methods use fastpaths that break that\n-\/\/ level of encapsulation - so combining the two remains a future project.\n-\n-class PlatformParker {\n-  NONCOPYABLE(PlatformParker);\n- protected:\n-  enum {\n-    REL_INDEX = 0,\n-    ABS_INDEX = 1\n-  };\n-  volatile int _counter;\n-  int _cur_index;  \/\/ which cond is in use: -1, 0, 1\n-  pthread_mutex_t _mutex[1];\n-  pthread_cond_t  _cond[2]; \/\/ one for relative times and one for absolute\n-\n- public:\n-  PlatformParker();\n-  ~PlatformParker();\n-};\n-\n-\/\/ Workaround for a bug in macOSX kernel's pthread support (fixed in Mojave?).\n-\/\/ Avoid ever allocating a pthread_mutex_t at the same address as one of our\n-\/\/ former pthread_cond_t, by using freelists of mutexes and condvars.\n-\/\/ Conditional to avoid extra indirection and padding loss on other platforms.\n-#ifdef __APPLE__\n-#define PLATFORM_MONITOR_IMPL_INDIRECT 1\n-#else\n-#define PLATFORM_MONITOR_IMPL_INDIRECT 0\n-#endif\n-\n-\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n-\/\/ Note that we use \"normal\" pthread_mutex_t attributes so that recursive\n-\/\/ locking is not supported, which matches the expected semantics of the\n-\/\/ VM Mutex class.\n-\n-class PlatformMutex : public CHeapObj<mtSynchronizer> {\n-#if PLATFORM_MONITOR_IMPL_INDIRECT\n-  class Mutex : public CHeapObj<mtSynchronizer> {\n-   public:\n-    pthread_mutex_t _mutex;\n-    Mutex* _next;\n-\n-    Mutex();\n-    ~Mutex();\n-  };\n-\n-  Mutex* _impl;\n-\n-  static pthread_mutex_t _freelist_lock; \/\/ used for mutex and cond freelists\n-  static Mutex* _mutex_freelist;\n-\n- protected:\n-  class WithFreeListLocked;\n-  pthread_mutex_t* mutex() { return &(_impl->_mutex); }\n-\n- public:\n-  PlatformMutex();              \/\/ Use freelist allocation of impl.\n-  ~PlatformMutex();\n-\n-  static void init();           \/\/ Initialize the freelist.\n-\n-#else\n-\n-  pthread_mutex_t _mutex;\n-\n- protected:\n-  pthread_mutex_t* mutex() { return &_mutex; }\n-\n- public:\n-  static void init() {}         \/\/ Nothing needed for the non-indirect case.\n-\n-  PlatformMutex();\n-  ~PlatformMutex();\n-\n-#endif \/\/ PLATFORM_MONITOR_IMPL_INDIRECT\n-\n- private:\n-  NONCOPYABLE(PlatformMutex);\n-\n- public:\n-  void lock();\n-  void unlock();\n-  bool try_lock();\n-};\n-\n-class PlatformMonitor : public PlatformMutex {\n-#if PLATFORM_MONITOR_IMPL_INDIRECT\n-  class Cond : public CHeapObj<mtSynchronizer> {\n-   public:\n-    pthread_cond_t _cond;\n-    Cond* _next;\n-\n-    Cond();\n-    ~Cond();\n-  };\n-\n-  Cond* _impl;\n-\n-  static Cond* _cond_freelist;\n-\n-  pthread_cond_t* cond() { return &(_impl->_cond); }\n-\n- public:\n-  PlatformMonitor();            \/\/ Use freelist allocation of impl.\n-  ~PlatformMonitor();\n-\n-#else\n-\n-  pthread_cond_t _cond;\n-  pthread_cond_t* cond() { return &_cond; }\n-\n- public:\n-  PlatformMonitor();\n-  ~PlatformMonitor();\n-\n-#endif \/\/ PLATFORM_MONITOR_IMPL_INDIRECT\n-\n- private:\n-  NONCOPYABLE(PlatformMonitor);\n-\n- public:\n-  int wait(jlong millis);\n-  void notify();\n-  void notify_all();\n-};\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":191,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -54,1 +55,1 @@\n-inline void os::PlatformMutex::lock() {\n+inline void PlatformMutex::lock() {\n@@ -59,1 +60,1 @@\n-inline void os::PlatformMutex::unlock() {\n+inline void PlatformMutex::unlock() {\n@@ -64,1 +65,1 @@\n-inline bool os::PlatformMutex::try_lock() {\n+inline bool PlatformMutex::try_lock() {\n@@ -70,1 +71,1 @@\n-inline void os::PlatformMonitor::notify() {\n+inline void PlatformMonitor::notify() {\n@@ -75,1 +76,1 @@\n-inline void os::PlatformMonitor::notify_all() {\n+inline void PlatformMonitor::notify_all() {\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_PARK_POSIX_HPP\n+#define OS_POSIX_PARK_POSIX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <pthread.h>\n+\n+\/*\n+ * This is the platform-specific implementation underpinning\n+ * the ParkEvent class, which itself underpins Java-level monitor\n+ * operations. See park.hpp for details.\n+ * These event objects are type-stable and immortal - we never delete them.\n+ * Events are associated with a thread for the lifetime of the thread.\n+ *\/\n+class PlatformEvent : public CHeapObj<mtSynchronizer> {\n+ private:\n+  double cachePad[4];        \/\/ Increase odds that _mutex is sole occupant of cache line\n+  volatile int _event;       \/\/ Event count\/permit: -1, 0 or 1\n+  volatile int _nParked;     \/\/ Indicates if associated thread is blocked: 0 or 1\n+  pthread_mutex_t _mutex[1]; \/\/ Native mutex for locking\n+  pthread_cond_t  _cond[1];  \/\/ Native condition variable for blocking\n+  double postPad[2];\n+\n+ protected:       \/\/ TODO-FIXME: make dtor private\n+  ~PlatformEvent() { guarantee(false, \"invariant\"); } \/\/ immortal so can't delete\n+\n+ public:\n+  PlatformEvent();\n+  void park();\n+  int  park(jlong millis);\n+  void unpark();\n+\n+  \/\/ Use caution with reset() and fired() -- they may require MEMBARs\n+  void reset() { _event = 0; }\n+  int  fired() { return _event; }\n+};\n+\n+\/\/ JSR166 support\n+\/\/ PlatformParker provides the platform dependent base class for the\n+\/\/ Parker class. It basically provides the internal data structures:\n+\/\/ - mutex and convars\n+\/\/ which are then used directly by the Parker methods defined in the OS\n+\/\/ specific implementation files.\n+\/\/ There is significant overlap between the funcionality supported in the\n+\/\/ combination of Parker+PlatformParker and PlatformEvent (above). If Parker\n+\/\/ were more like ObjectMonitor we could use PlatformEvent in both (with some\n+\/\/ API updates of course). But Parker methods use fastpaths that break that\n+\/\/ level of encapsulation - so combining the two remains a future project.\n+\n+class PlatformParker {\n+  NONCOPYABLE(PlatformParker);\n+ protected:\n+  enum {\n+    REL_INDEX = 0,\n+    ABS_INDEX = 1\n+  };\n+  volatile int _counter;\n+  int _cur_index;  \/\/ which cond is in use: -1, 0, 1\n+  pthread_mutex_t _mutex[1];\n+  pthread_cond_t  _cond[2]; \/\/ one for relative times and one for absolute\n+\n+ public:\n+  PlatformParker();\n+  ~PlatformParker();\n+};\n+\n+#endif \/\/ OS_POSIX_PARK_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/park_posix.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/threadCrashProtection.hpp\"\n@@ -587,1 +588,1 @@\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+  ThreadCrashProtection::check_crash_protection(sig, t);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadCrashProtection.hpp\"\n+\n+Thread* ThreadCrashProtection::_protected_thread = NULL;\n+ThreadCrashProtection* ThreadCrashProtection::_crash_protection = NULL;\n+\n+ThreadCrashProtection::ThreadCrashProtection() {\n+  _protected_thread = Thread::current();\n+  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n+}\n+\n+\/*\n+ * See the caveats for this class in threadCrashProtection_posix.hpp\n+ * Protects the callback call so that SIGSEGV \/ SIGBUS jumps back into this\n+ * method and returns false. If none of the signals are raised, returns true.\n+ * The callback is supposed to provide the method that should be protected.\n+ *\/\n+bool ThreadCrashProtection::call(CrashProtectionCallback& cb) {\n+  sigset_t saved_sig_mask;\n+\n+  \/\/ we cannot rely on sigsetjmp\/siglongjmp to save\/restore the signal mask\n+  \/\/ since on at least some systems (OS X) siglongjmp will restore the mask\n+  \/\/ for the process, not the thread\n+  pthread_sigmask(0, NULL, &saved_sig_mask);\n+  if (sigsetjmp(_jmpbuf, 0) == 0) {\n+    \/\/ make sure we can see in the signal handler that we have crash protection\n+    \/\/ installed\n+    _crash_protection = this;\n+    cb.call();\n+    \/\/ and clear the crash protection\n+    _crash_protection = NULL;\n+    _protected_thread = NULL;\n+    return true;\n+  }\n+  \/\/ this happens when we siglongjmp() back\n+  pthread_sigmask(SIG_SETMASK, &saved_sig_mask, NULL);\n+  _crash_protection = NULL;\n+  _protected_thread = NULL;\n+  return false;\n+}\n+\n+void ThreadCrashProtection::restore() {\n+  assert(_crash_protection != NULL, \"must have crash protection\");\n+  siglongjmp(_jmpbuf, 1);\n+}\n+\n+void ThreadCrashProtection::check_crash_protection(int sig,\n+    Thread* thread) {\n+\n+  if (thread != NULL &&\n+      thread == _protected_thread &&\n+      _crash_protection != NULL) {\n+\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      _crash_protection->restore();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os\/posix\/threadCrashProtection_posix.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_THREADCRASHPROTECTION_POSIX_HPP\n+#define OS_POSIX_THREADCRASHPROTECTION_POSIX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+#include <setjmp.h>\n+\n+class CrashProtectionCallback;\n+class Thread;\n+\n+\/*\n+ * Crash protection for the JfrSampler thread. Wrap the callback\n+ * with a sigsetjmp and in case of a SIGSEGV\/SIGBUS we siglongjmp\n+ * back.\n+ * To be able to use this - don't take locks, don't rely on destructors,\n+ * don't make OS library calls, don't allocate memory, don't print,\n+ * don't call code that could leave the heap \/ memory in an inconsistent state,\n+ * or anything else where we are not in control if we suddenly jump out.\n+ *\/\n+class ThreadCrashProtection : public StackObj {\n+public:\n+  static bool is_crash_protected(Thread* thr) {\n+    return _crash_protection != NULL && _protected_thread == thr;\n+  }\n+\n+  ThreadCrashProtection();\n+  bool call(CrashProtectionCallback& cb);\n+\n+  static void check_crash_protection(int signal, Thread* thread);\n+private:\n+  static Thread* _protected_thread;\n+  static ThreadCrashProtection* _crash_protection;\n+  void restore();\n+  sigjmp_buf _jmpbuf;\n+};\n+\n+#endif \/\/ OS_POSIX_THREADCRASHPROTECTION_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/threadCrashProtection_posix.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_MUTEX_WINDOWS_HPP\n+#define OS_WINDOWS_MUTEX_WINDOWS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n+\/\/ Note that CRITICAL_SECTION supports recursive locking, while the semantics\n+\/\/ of the VM Mutex class does not. It is up to the Mutex class to hide this\n+\/\/ difference in behaviour.\n+\n+class PlatformMutex : public CHeapObj<mtSynchronizer> {\n+  NONCOPYABLE(PlatformMutex);\n+\n+ protected:\n+  CRITICAL_SECTION   _mutex; \/\/ Native mutex for locking\n+\n+ public:\n+  PlatformMutex();\n+  ~PlatformMutex();\n+  void lock();\n+  void unlock();\n+  bool try_lock();\n+};\n+\n+class PlatformMonitor : public PlatformMutex {\n+ private:\n+  CONDITION_VARIABLE _cond;  \/\/ Native condition variable for blocking\n+  NONCOPYABLE(PlatformMonitor);\n+\n+ public:\n+  PlatformMonitor();\n+  ~PlatformMonitor();\n+  int wait(jlong millis);\n+  void notify();\n+  void notify_all();\n+};\n+\n+#endif \/\/ OS_WINDOWS_MUTEX_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/mutex_windows.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"runtime\/park.hpp\"\n@@ -5102,29 +5103,0 @@\n-Thread* os::ThreadCrashProtection::_protected_thread = NULL;\n-os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;\n-\n-os::ThreadCrashProtection::ThreadCrashProtection() {\n-  _protected_thread = Thread::current();\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n-}\n-\n-\/\/ See the caveats for this class in os_windows.hpp\n-\/\/ Protects the callback call so that raised OS EXCEPTIONS causes a jump back\n-\/\/ into this method and returns false. If no OS EXCEPTION was raised, returns\n-\/\/ true.\n-\/\/ The callback is supposed to provide the method that should be protected.\n-\/\/\n-bool os::ThreadCrashProtection::call(os::CrashProtectionCallback& cb) {\n-  bool success = true;\n-  __try {\n-    _crash_protection = this;\n-    cb.call();\n-  } __except(EXCEPTION_EXECUTE_HANDLER) {\n-    \/\/ only for protection, nothing to do\n-    success = false;\n-  }\n-  _crash_protection = NULL;\n-  _protected_thread = NULL;\n-  return success;\n-}\n-\n-\n@@ -5228,1 +5200,1 @@\n-int os::PlatformEvent::park(jlong Millis) {\n+int PlatformEvent::park(jlong Millis) {\n@@ -5285,1 +5257,1 @@\n-  \/\/ see comment at end of os::PlatformEvent::park() below:\n+  \/\/ see comment at end of PlatformEvent::park() below:\n@@ -5293,1 +5265,1 @@\n-void os::PlatformEvent::park() {\n+void PlatformEvent::park() {\n@@ -5327,1 +5299,1 @@\n-void os::PlatformEvent::unpark() {\n+void PlatformEvent::unpark() {\n@@ -5400,1 +5372,1 @@\n-int os::PlatformMonitor::wait(jlong millis) {\n+int PlatformMonitor::wait(jlong millis) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":6,"deletions":34,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -136,95 +136,0 @@\n-\/*\n- * Crash protection for the JfrSampler thread. Wrap the callback\n- * with a __try { call() }\n- * To be able to use this - don't take locks, don't rely on destructors,\n- * don't make OS library calls, don't allocate memory, don't print,\n- * don't call code that could leave the heap \/ memory in an inconsistent state,\n- * or anything else where we are not in control if we suddenly jump out.\n- *\/\n-class ThreadCrashProtection : public StackObj {\n-public:\n-  static bool is_crash_protected(Thread* thr) {\n-    return _crash_protection != NULL && _protected_thread == thr;\n-  }\n-\n-  ThreadCrashProtection();\n-  bool call(os::CrashProtectionCallback& cb);\n-private:\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n-};\n-\n-class PlatformEvent : public CHeapObj<mtSynchronizer> {\n-  private:\n-    double CachePad [4] ;   \/\/ increase odds that _Event is sole occupant of cache line\n-    volatile int _Event ;\n-    HANDLE _ParkHandle ;\n-\n-  public:       \/\/ TODO-FIXME: make dtor private\n-    ~PlatformEvent() { guarantee (0, \"invariant\") ; }\n-\n-  public:\n-    PlatformEvent() {\n-      _Event   = 0 ;\n-      _ParkHandle = CreateEvent (NULL, false, false, NULL) ;\n-      guarantee (_ParkHandle != NULL, \"invariant\") ;\n-    }\n-\n-    \/\/ Exercise caution using reset() and fired() - they may require MEMBARs\n-    void reset() { _Event = 0 ; }\n-    int  fired() { return _Event; }\n-    void park () ;\n-    void unpark () ;\n-    int  park (jlong millis) ;\n-} ;\n-\n-\n-\n-class PlatformParker {\n-  NONCOPYABLE(PlatformParker);\n-\n- protected:\n-  HANDLE _ParkHandle;\n-\n- public:\n-  PlatformParker() {\n-    _ParkHandle = CreateEvent (NULL, true, false, NULL) ;\n-    guarantee(_ParkHandle != NULL, \"invariant\") ;\n-  }\n-  ~PlatformParker() {\n-    CloseHandle(_ParkHandle);\n-  }\n-};\n-\n-\/\/ Platform specific implementations that underpin VM Mutex\/Monitor classes.\n-\/\/ Note that CRITICAL_SECTION supports recursive locking, while the semantics\n-\/\/ of the VM Mutex class does not. It is up to the Mutex class to hide this\n-\/\/ difference in behaviour.\n-\n-class PlatformMutex : public CHeapObj<mtSynchronizer> {\n-  NONCOPYABLE(PlatformMutex);\n-\n- protected:\n-  CRITICAL_SECTION   _mutex; \/\/ Native mutex for locking\n-\n- public:\n-  PlatformMutex();\n-  ~PlatformMutex();\n-  void lock();\n-  void unlock();\n-  bool try_lock();\n-};\n-\n-class PlatformMonitor : public PlatformMutex {\n- private:\n-  CONDITION_VARIABLE _cond;  \/\/ Native condition variable for blocking\n-  NONCOPYABLE(PlatformMonitor);\n-\n- public:\n-  PlatformMonitor();\n-  ~PlatformMonitor();\n-  int wait(jlong millis);\n-  void notify();\n-  void notify_all();\n-};\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -60,1 +61,1 @@\n-inline os::PlatformMutex::PlatformMutex() {\n+inline PlatformMutex::PlatformMutex() {\n@@ -64,1 +65,1 @@\n-inline os::PlatformMutex::~PlatformMutex() {\n+inline PlatformMutex::~PlatformMutex() {\n@@ -68,1 +69,1 @@\n-inline os::PlatformMonitor::PlatformMonitor() {\n+inline PlatformMonitor::PlatformMonitor() {\n@@ -72,1 +73,1 @@\n-inline os::PlatformMonitor::~PlatformMonitor() {\n+inline PlatformMonitor::~PlatformMonitor() {\n@@ -76,1 +77,1 @@\n-inline void os::PlatformMutex::lock() {\n+inline void PlatformMutex::lock() {\n@@ -80,1 +81,1 @@\n-inline void os::PlatformMutex::unlock() {\n+inline void PlatformMutex::unlock() {\n@@ -84,1 +85,1 @@\n-inline bool os::PlatformMutex::try_lock() {\n+inline bool PlatformMutex::try_lock() {\n@@ -88,1 +89,1 @@\n-inline void os::PlatformMonitor::notify() {\n+inline void PlatformMonitor::notify() {\n@@ -92,1 +93,1 @@\n-inline void os::PlatformMonitor::notify_all() {\n+inline void PlatformMonitor::notify_all() {\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_PARK_WINDOWS_HPP\n+#define OS_WINDOWS_PARK_WINDOWS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class PlatformEvent : public CHeapObj<mtSynchronizer> {\n+  private:\n+    double CachePad [4] ;   \/\/ increase odds that _Event is sole occupant of cache line\n+    volatile int _Event ;\n+    HANDLE _ParkHandle ;\n+\n+  public:       \/\/ TODO-FIXME: make dtor private\n+    ~PlatformEvent() { guarantee (0, \"invariant\") ; }\n+\n+  public:\n+    PlatformEvent() {\n+      _Event   = 0 ;\n+      _ParkHandle = CreateEvent (NULL, false, false, NULL) ;\n+      guarantee (_ParkHandle != NULL, \"invariant\") ;\n+    }\n+\n+    \/\/ Exercise caution using reset() and fired() - they may require MEMBARs\n+    void reset() { _Event = 0 ; }\n+    int  fired() { return _Event; }\n+    void park () ;\n+    void unpark () ;\n+    int  park (jlong millis) ;\n+};\n+\n+class PlatformParker {\n+  NONCOPYABLE(PlatformParker);\n+\n+ protected:\n+  HANDLE _ParkHandle;\n+\n+ public:\n+  PlatformParker() {\n+    _ParkHandle = CreateEvent (NULL, true, false, NULL) ;\n+    guarantee(_ParkHandle != NULL, \"invariant\") ;\n+  }\n+  ~PlatformParker() {\n+    CloseHandle(_ParkHandle);\n+  }\n+};\n+\n+#endif \/\/ OS_WINDOWS_PARK_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/park_windows.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadCrashProtection.hpp\"\n+\n+Thread* ThreadCrashProtection::_protected_thread = NULL;\n+ThreadCrashProtection* ThreadCrashProtection::_crash_protection = NULL;\n+\n+ThreadCrashProtection::ThreadCrashProtection() {\n+  _protected_thread = Thread::current();\n+  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n+}\n+\n+\/\/ See the caveats for this class in os_windows.hpp\n+\/\/ Protects the callback call so that raised OS EXCEPTIONS causes a jump back\n+\/\/ into this method and returns false. If no OS EXCEPTION was raised, returns\n+\/\/ true.\n+\/\/ The callback is supposed to provide the method that should be protected.\n+\/\/\n+bool ThreadCrashProtection::call(CrashProtectionCallback& cb) {\n+  bool success = true;\n+  __try {\n+    _crash_protection = this;\n+    cb.call();\n+  } __except(EXCEPTION_EXECUTE_HANDLER) {\n+    \/\/ only for protection, nothing to do\n+    success = false;\n+  }\n+  _crash_protection = NULL;\n+  _protected_thread = NULL;\n+  return success;\n+}\n","filename":"src\/hotspot\/os\/windows\/threadCrashProtection_windows.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_THREADCRASHPROTECTION_WINDOWS_HPP\n+#define OS_WINDOWS_THREADCRASHPROTECTION_WINDOWS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class CrashProtectionCallback;\n+class Thread;\n+\n+\/*\n+ * Crash protection for the JfrSampler thread. Wrap the callback\n+ * with a __try { call() }\n+ * To be able to use this - don't take locks, don't rely on destructors,\n+ * don't make OS library calls, don't allocate memory, don't print,\n+ * don't call code that could leave the heap \/ memory in an inconsistent state,\n+ * or anything else where we are not in control if we suddenly jump out.\n+ *\/\n+class ThreadCrashProtection : public StackObj {\n+public:\n+  static bool is_crash_protected(Thread* thr) {\n+    return _crash_protection != NULL && _protected_thread == thr;\n+  }\n+\n+  ThreadCrashProtection();\n+  bool call(CrashProtectionCallback& cb);\n+private:\n+  static Thread* _protected_thread;\n+  static ThreadCrashProtection* _crash_protection;\n+};\n+\n+#endif \/\/ OS_WINDOWS_THREADCRASHPROTECTION_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/threadCrashProtection_windows.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  os::PlatformMonitor   _lock; \/\/ native lock\n+  PlatformMonitor   _lock; \/\/ native lock\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/mutex.hpp\"\n@@ -32,1 +32,1 @@\n-  os::PlatformMutex _lock;\n+  PlatformMutex _lock;\n@@ -57,1 +57,1 @@\n-  os::PlatformMonitor _lock;\n+  PlatformMonitor _lock;\n","filename":"src\/hotspot\/share\/gc\/z\/zLock.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/threadCrashProtection.hpp\"\n@@ -144,1 +145,1 @@\n-class OSThreadSamplerCallback : public os::CrashProtectionCallback {\n+class OSThreadSamplerCallback : public CrashProtectionCallback {\n@@ -166,1 +167,1 @@\n-    os::ThreadCrashProtection crash_protection;\n+    ThreadCrashProtection crash_protection;\n@@ -207,1 +208,1 @@\n-class JfrNativeSamplerCallback : public os::CrashProtectionCallback {\n+class JfrNativeSamplerCallback : public CrashProtectionCallback {\n@@ -275,1 +276,1 @@\n-    os::ThreadCrashProtection crash_protection;\n+    ThreadCrashProtection crash_protection;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/mutex.hpp\"\n@@ -147,1 +148,1 @@\n-  os::PlatformMonitor _lock;\n+  PlatformMonitor _lock;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/rootChunkArea.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3520,1 +3520,1 @@\n-  return new os::PlatformMutex();\n+  return new PlatformMutex();\n@@ -3526,1 +3526,1 @@\n-  delete ((os::PlatformMutex*) mon);\n+  delete ((PlatformMutex*) mon);\n@@ -3532,1 +3532,1 @@\n-  ((os::PlatformMutex*) mon)->lock();\n+  ((PlatformMutex*) mon)->lock();\n@@ -3539,1 +3539,1 @@\n-  ((os::PlatformMutex*) mon)->unlock();\n+  ((PlatformMutex*) mon)->unlock();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/park.hpp\"\n@@ -32,0 +31,3 @@\n+class ParkEvent;\n+class Thread;\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/threadCrashProtection.hpp\"\n@@ -59,1 +60,1 @@\n-  assert(!os::ThreadCrashProtection::is_crash_protected(thread),\n+  assert(!ThreadCrashProtection::is_crash_protected(thread),\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,9 @@\n-#include \"runtime\/os.hpp\"\n+\n+#if defined(LINUX) || defined(AIX) || defined(BSD)\n+# include \"mutex_posix.hpp\"\n+#elif defined(_WINDOWS)\n+# include \"mutex_windows.hpp\"\n+#else\n+# error \"No PlatformMutex implementation provided for this OS\"\n+#endif\n+\n@@ -92,1 +100,1 @@\n-  os::PlatformMonitor _lock;             \/\/ Native monitor implementation\n+  PlatformMonitor _lock;                 \/\/ Native monitor implementation\n@@ -195,1 +203,1 @@\n-    void print() const                      { print_on(::tty); }\n+    void print() const                      { \/*print_on(::tty); *\/ } \/\/ FIXME\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/park.hpp\"\n@@ -37,0 +35,1 @@\n+class ParkEvent;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/threadCrashProtection.hpp\"\n@@ -621,1 +622,1 @@\n-  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n+  assert(!ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-#ifndef _WINDOWS\n-# include <setjmp.h>\n-#endif\n@@ -875,4 +872,0 @@\n-  class CrashProtectionCallback : public StackObj {\n-  public:\n-    virtual void call() = 0;\n-  };\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/osThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,10 @@\n+#if defined(LINUX) || defined(AIX) || defined(BSD)\n+# include \"park_posix.hpp\"\n+#elif defined(_WINDOWS)\n+# include \"park_windows.hpp\"\n+#else\n+# error \"No PlatformParker implementation provided for this OS\"\n+#endif\n+\n+class Thread;\n+\n@@ -42,1 +52,1 @@\n- * os::PlatformParker class, which contains the actual implementation\n+ * PlatformParker class, which contains the actual implementation\n@@ -52,1 +62,1 @@\n-class Parker : public os::PlatformParker {\n+class Parker : public PlatformParker {\n@@ -105,1 +115,1 @@\n-class ParkEvent : public os::PlatformEvent {\n+class ParkEvent : public PlatformEvent {\n","filename":"src\/hotspot\/share\/runtime\/park.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-static os::PlatformMutex* gInflationLocks[NINFLATIONLOCKS];\n+static PlatformMutex* gInflationLocks[NINFLATIONLOCKS];\n@@ -247,1 +247,1 @@\n-    gInflationLocks[i] = new os::PlatformMutex();\n+    gInflationLocks[i] = new PlatformMutex();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#ifndef SHARE_RUNTIME_THREADCRASHPROTECTION_HPP\n+#define SHARE_RUNTIME_THREADCRASHPROTECTION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class CrashProtectionCallback : public StackObj {\n+public:\n+  virtual void call() = 0;\n+};\n+\n+#if defined(LINUX) || defined(AIX) || defined(BSD)\n+# include \"threadCrashProtection_posix.hpp\"\n+#elif defined(_WINDOWS)\n+# include \"threadCrashProtection_windows.hpp\"\n+#else\n+# error \"No ThreadCrashProtection implementation provided for this OS\"\n+#endif\n+\n+#endif \/\/ SHARE_RUNTIME_THREADCRASHPROTECTION_HPP\n","filename":"src\/hotspot\/share\/runtime\/threadCrashProtection.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}