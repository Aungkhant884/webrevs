{"files":[{"patch":"@@ -0,0 +1,678 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiPredicate;\n+import java.util.stream.IntStream;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static java.util.Map.entry;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8285295\n+ * @summary Basic tests for IdentityHashMap\n+ * @run testng Basic\n+ *\/\n+\n+\/\/ NOTE: avoid using TestNG's assertEquals\/assertNotEquals directly on two IDHM instances,\n+\/\/ as its logic for testing collections equality is suspect. Use checkEntries() to assert\n+\/\/ that a map's entrySet contains exactly the expected mappings. There are no guarantees about\n+\/\/ the identities of Map.Entry instances obtained from the entrySet; however, the keys and\n+\/\/ values they contain are guaranteed to have the right identity.\n+\n+\/\/ TODO remove(k, v)\n+\/\/ TODO replace(k, v1, v2)\n+\/\/ TODO add tests using null keys and values\n+\/\/ TODO deeper testing of view collections including iterators, equals, contains, etc.\n+\/\/ TODO Map.Entry::setValue\n+\n+public class Basic {\n+    \/*\n+     * Helpers\n+     *\/\n+\n+    record Box(int i) {\n+        Box(Box other) {\n+            this(other.i());\n+        }\n+    }\n+\n+    \/\/ Checks that a collection contains exactly the given elements and no others, using the\n+    \/\/ provided predicate for equivalence. Checking is performed both using contains() on the\n+    \/\/ collection and by simple array searching. The latter is O(N^2) so is suitable only for\n+    \/\/ small arrays. No two of the given elements can be equivalent according to the predicate.\n+\n+    \/\/ TODO: read out the elements using iterator and stream and check them too\n+\n+    @SafeVarargs\n+    private <E> void checkContents(Collection<E> c, BiPredicate<E,E> p, E... given) {\n+        @SuppressWarnings(\"unchecked\")\n+        E[] contents = (E[]) c.toArray();\n+\n+        assertEquals(c.size(), given.length);\n+        assertEquals(contents.length, given.length);\n+        final int LEN = given.length;\n+\n+        for (E e : given) {\n+            assertTrue(c.contains(e));\n+        }\n+\n+        \/\/ Fill indexes array with position of a given element in the contents array,\n+        \/\/ or -1 if the given element cannot be found.\n+\n+        int[] indexes = new int[LEN];\n+\n+        outer:\n+        for (int i = 0; i < LEN; i++) {\n+            for (int j = 0; j < LEN; j++) {\n+                if (p.test(given[i], contents[j])) {\n+                    indexes[i] = j;\n+                    continue outer;\n+                }\n+            }\n+            indexes[i] = -1;\n+        }\n+\n+        \/\/ If every given element matches a distinct element in the contents array,\n+        \/\/ the sorted indexes array will be the sequence [0..LEN-1].\n+\n+        Arrays.sort(indexes);\n+        assertEquals(indexes, IntStream.range(0, LEN).toArray());\n+    }\n+\n+    \/\/ Checks that the collection contains the given boxes, by identity.\n+    private void checkElements(Collection<Box> c, Box... given) {\n+        checkContents(c, (b1, b2) -> b1 == b2, given);\n+    }\n+\n+    \/\/ Checks that the collection contains entries that have identical keys and values.\n+    \/\/ The entries themselves are not checked for identity.\n+    @SafeVarargs\n+    private void checkEntries(Collection<Map.Entry<Box, Box>> c, Map.Entry<Box, Box>... given) {\n+        checkContents(c, (e1, e2) -> e1.getKey() == e2.getKey() && e1.getValue() == e2.getValue(), given);\n+    }\n+\n+    \/*\n+     * Setup\n+     *\/\n+\n+    final Box k1a = new Box(17);\n+    final Box k1b = new Box(17); \/\/ equals but != k1a\n+    final Box k2  = new Box(42);\n+\n+    final Box v1a = new Box(30);\n+    final Box v1b = new Box(30); \/\/ equals but != v1a\n+    final Box v2  = new Box(99);\n+\n+    IdentityHashMap<Box, Box> map;\n+    IdentityHashMap<Box, Box> map2;\n+\n+    @BeforeMethod\n+    public void setup() {\n+        map = new IdentityHashMap<>();\n+        map.put(k1a, v1a);\n+        map.put(k1b, v1b);\n+        map.put(k2,  v2);\n+\n+        map2 = new IdentityHashMap<>();\n+        map2.put(k1a, v1a);\n+        map2.put(k1b, v1b);\n+        map2.put(k2,  v2);\n+    }\n+\n+    \/*\n+     * Tests\n+     *\/\n+\n+    \/\/ containsKey\n+    \/\/ containsValue\n+    \/\/ size\n+    @Test\n+    public void testSizeContainsKeyValue() {\n+        assertEquals(map.size(), 3);\n+\n+        assertTrue(map.containsKey(k1a));\n+        assertTrue(map.containsKey(k1b));\n+        assertTrue(map.containsKey(k2));\n+        assertFalse(map.containsKey(new Box(k1a)));\n+\n+        assertTrue(map.containsValue(v1a));\n+        assertTrue(map.containsValue(v1b));\n+        assertFalse(map.containsValue(new Box(v1a)));\n+        assertTrue(map.containsValue(v2));\n+    }\n+\n+    \/\/ get\n+    @Test\n+    public void testGet() {\n+        assertSame(map.get(k1a), v1a);\n+        assertSame(map.get(k1b), v1b);\n+        assertSame(map.get(k2), v2);\n+        assertNull(map.get(new Box(k1a)));\n+    }\n+\n+    \/\/ getOrDefault\n+    @Test\n+    public void testGetOrDefault() {\n+        Box other = new Box(22);\n+\n+        assertSame(map.getOrDefault(k1a, other), v1a);\n+        assertSame(map.getOrDefault(k1b, other), v1b);\n+        assertSame(map.getOrDefault(new Box(k1a), other), other);\n+        assertSame(map.getOrDefault(k2, other), v2);\n+    }\n+\n+    \/\/ clear\n+    \/\/ isEmpty\n+    @Test\n+    public void testClearEmpty() {\n+        assertFalse(map.isEmpty());\n+        map.clear();\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    \/\/ hashCode\n+    @Test\n+    public void testHashCode() {\n+        int expected = (System.identityHashCode(k1a) ^ System.identityHashCode(v1a)) +\n+                       (System.identityHashCode(k1b) ^ System.identityHashCode(v1b)) +\n+                       (System.identityHashCode(k2)  ^ System.identityHashCode(v2));\n+        assertEquals(map.hashCode(), expected);\n+        assertEquals(map.entrySet().hashCode(), expected);\n+    }\n+\n+    \/\/ equals\n+    @Test\n+    public void testEquals() {\n+        assertTrue(map.equals(map));\n+        assertTrue(map.equals(map2));\n+        assertTrue(map2.equals(map));\n+\n+        assertTrue(map.keySet().equals(map.keySet()));\n+        assertTrue(map.keySet().equals(map2.keySet()));\n+        assertTrue(map2.keySet().equals(map.keySet()));\n+\n+        assertTrue(map.entrySet().equals(map.entrySet()));\n+        assertTrue(map.entrySet().equals(map2.entrySet()));\n+        assertTrue(map2.entrySet().equals(map.entrySet()));\n+    }\n+\n+    \/\/ equals\n+    @Test\n+    public void testEqualsDifferentKey() {\n+        map2.remove(k1a);\n+        map2.put(new Box(k1a), v1a);\n+\n+        assertFalse(map.equals(map2));\n+        assertFalse(map2.equals(map));\n+\n+        assertFalse(map.keySet().equals(map2.keySet()));\n+        assertFalse(map2.keySet().equals(map.keySet()));\n+\n+        assertFalse(map.entrySet().equals(map2.entrySet()));\n+        assertFalse(map2.entrySet().equals(map.entrySet()));\n+    }\n+\n+    \/\/ equals\n+    @Test\n+    public void testEqualsDifferentValue() {\n+        map2.put(k1a, new Box(v1a));\n+\n+        assertFalse(map.equals(map2));\n+        assertFalse(map2.equals(map));\n+\n+        assertTrue(map.keySet().equals(map2.keySet()));\n+        assertTrue(map2.keySet().equals(map.keySet()));\n+\n+        assertFalse(map.entrySet().equals(map2.entrySet()));\n+        assertFalse(map2.entrySet().equals(map.entrySet()));\n+    }\n+\n+    \/\/ equals\n+    @Test\n+    public void testEqualsNewMapping() {\n+        map.put(new Box(k1a), new Box(v1a));\n+\n+        assertFalse(map.equals(map2));\n+        assertFalse(map2.equals(map));\n+\n+        assertFalse(map.keySet().equals(map2.keySet()));\n+        assertFalse(map2.keySet().equals(map.keySet()));\n+\n+        assertFalse(map.entrySet().equals(map2.entrySet()));\n+        assertFalse(map2.entrySet().equals(map.entrySet()));\n+    }\n+\n+    \/\/ equals\n+    @Test\n+    public void testEqualsMissingMapping() {\n+        var tmp = new IdentityHashMap<Box, Box>();\n+        tmp.put(k1a, v1a);\n+        tmp.put(k1b, v1b);\n+\n+        assertFalse(map.equals(tmp));\n+        assertFalse(tmp.equals(map));\n+\n+        assertFalse(map.keySet().equals(tmp.keySet()));\n+        assertFalse(tmp.keySet().equals(map.keySet()));\n+\n+        assertFalse(map.entrySet().equals(tmp.entrySet()));\n+        assertFalse(tmp.entrySet().equals(map.entrySet()));\n+    }\n+\n+    \/\/ keySet equals, contains\n+    @Test\n+    public void testKeySet() {\n+        Set<Box> keySet = map.keySet();\n+\n+        checkElements(keySet, k1a, k1b, k2);\n+        assertFalse(keySet.contains(new Box(k1a)));\n+        assertTrue(map.keySet().equals(map2.keySet()));\n+        assertTrue(map2.keySet().equals(map.keySet()));\n+    }\n+\n+    \/\/ keySet remove\n+    @Test\n+    public void testKeySetNoRemove() {\n+        Set<Box> keySet = map.keySet();\n+        boolean r = keySet.remove(new Box(k1a));\n+\n+        assertFalse(r);\n+        checkElements(keySet, k1a, k1b, k2);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+        assertTrue(map.keySet().equals(map2.keySet()));\n+        assertTrue(map2.keySet().equals(map.keySet()));\n+    }\n+\n+    \/\/ keySet remove\n+    @Test\n+    public void testKeySetRemove() {\n+        Set<Box> keySet = map.keySet();\n+        boolean r = keySet.remove(k1a);\n+\n+        assertTrue(r);\n+        checkElements(keySet, k1b, k2);\n+        checkEntries(map.entrySet(), entry(k1b, v1b),\n+                                     entry(k2, v2));\n+        assertFalse(map.keySet().equals(map2.keySet()));\n+        assertFalse(map2.keySet().equals(map.keySet()));\n+    }\n+\n+    \/\/ values\n+    @Test\n+    public void testValues() {\n+        Collection<Box> values = map.values();\n+        checkElements(values, v1a, v1b, v2);\n+        assertFalse(values.contains(new Box(v1a)));\n+    }\n+\n+    \/\/ values remove\n+    @Test\n+    public void testValuesNoRemove() {\n+        Collection<Box> values = map.values();\n+        boolean r = values.remove(new Box(v1a));\n+\n+        assertFalse(r);\n+        checkElements(values, v1a, v1b, v2);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ values remove\n+    @Test\n+    public void testValuesRemove() {\n+        Collection<Box> values = map.values();\n+        boolean r = values.remove(v1a);\n+\n+        assertTrue(r);\n+        checkElements(values, v1b, v2);\n+        checkEntries(map.entrySet(), entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ entrySet equals, contains\n+    @Test\n+    public void testEntrySet() {\n+        Set<Map.Entry<Box,Box>> entrySet = map.entrySet();\n+\n+        assertFalse(entrySet.contains(entry(new Box(k1a), v1a)));\n+        assertFalse(entrySet.contains(entry(k1b, new Box(v1b))));\n+        assertFalse(entrySet.contains(entry(new Box(k2), new Box(v2))));\n+        assertTrue(map.entrySet().equals(map2.entrySet()));\n+        checkEntries(entrySet, entry(k1a, v1a),\n+                               entry(k1b, v1b),\n+                               entry(k2, v2));\n+    }\n+\n+    \/\/ entrySet remove\n+    @Test\n+    public void testEntrySetNoRemove() {\n+        Set<Map.Entry<Box, Box>> entrySet = map.entrySet();\n+        boolean r1 = entrySet.remove(entry(new Box(k1a), v1a));\n+        boolean r2 = entrySet.remove(entry(k1a, new Box(v1a)));\n+\n+        assertFalse(r1);\n+        assertFalse(r2);\n+        assertTrue(entrySet.equals(map2.entrySet()));\n+        checkEntries(entrySet, entry(k1a, v1a),\n+                               entry(k1b, v1b),\n+                               entry(k2, v2));\n+    }\n+\n+    \/\/ entrySet remove\n+    @Test\n+    public void testEntrySetRemove() {\n+        Set<Map.Entry<Box, Box>> entrySet = map.entrySet();\n+        boolean r = entrySet.remove(Map.entry(k1a, v1a));\n+\n+        assertTrue(r);\n+        assertFalse(entrySet.equals(map2.entrySet()));\n+        assertFalse(map.entrySet().equals(map2.entrySet()));\n+        checkEntries(entrySet, entry(k1b, v1b),\n+                               entry(k2, v2));\n+        checkEntries(map.entrySet(), entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ put\n+    @Test\n+    public void testPutNew() {\n+        Box newKey = new Box(k1a);\n+        Box newVal = new Box(v1a);\n+        Box r = map.put(newKey, newVal);\n+\n+        assertNull(r);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ put\n+    @Test\n+    public void testPutOverwrite() {\n+        Box newVal = new Box(v1a);\n+        Box r = map.put(k1a, newVal);\n+\n+        assertSame(r, v1a);\n+        checkEntries(map.entrySet(), entry(k1a, newVal),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ putAll\n+    @Test\n+    public void testPutAll() {\n+        Box newKey  = new Box(k1a);\n+        Box newVal  = new Box(v1a);\n+        Box newValB = new Box(v1b);\n+        var argMap = new IdentityHashMap<Box, Box>();\n+        argMap.put(newKey, newVal); \/\/ new entry\n+        argMap.put(k1b, newValB);   \/\/ will overwrite value\n+        map.putAll(argMap);\n+\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, newValB),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ putIfAbsent\n+    @Test\n+    public void testPutIfAbsentNoop() {\n+        Box r = map.putIfAbsent(k1a, new Box(v1a)); \/\/ no-op\n+\n+        assertSame(r, v1a);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ putIfAbsent\n+    @Test\n+    public void testPutIfAbsentAddsNew() {\n+        Box newKey = new Box(k1a);\n+        Box newVal = new Box(v1a);\n+        Box r = map.putIfAbsent(newKey, newVal); \/\/ adds new entry\n+\n+        assertNull(r);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ remove(Object)\n+    @Test\n+    public void testRemoveKey() {\n+        Box r = map.remove(k1b);\n+\n+        assertSame(r, v1b);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ AN: key absent, remappingFunction returns null\n+    @Test\n+    public void testComputeAN() {\n+        Box newKey = new Box(k1a);\n+        Box r = map.compute(newKey, (k, v) -> null);\n+\n+        assertNull(r);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ AV: key absent, remappingFunction returns non-null value\n+    @Test\n+    public void testComputeAV() {\n+        Box newKey = new Box(k1a);\n+        Box newVal = new Box(v1a);\n+        Box r = map.compute(newKey, (k, v) -> newVal);\n+\n+        assertSame(r, newVal);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ PN: key present, remappingFunction returns null\n+    @Test\n+    public void testComputePN() {\n+        Box r = map.compute(k1a, (k, v) -> null);\n+\n+        assertNull(r);\n+        checkEntries(map.entrySet(), entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ PV: key present, remappingFunction returns non-null value\n+    @Test\n+    public void testComputePV() {\n+        Box newVal = new Box(v1a);\n+        Box r = map.compute(k1a, (k, v) -> newVal);\n+\n+        assertSame(r, newVal);\n+        checkEntries(map.entrySet(), entry(k1a, newVal),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ computeIfAbsent\n+    @Test\n+    public void testComputeIfAbsentIsCalled() {\n+        boolean[] called = new boolean[1];\n+        Box newKey = new Box(k1a);\n+        Box newVal = new Box(v1a);\n+        Box r = map.computeIfAbsent(newKey, k -> { called[0] = true; return newVal; });\n+\n+        assertSame(r, newVal);\n+        assertTrue(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ computeIfAbsent\n+    @Test\n+    public void testComputeIfAbsentNotCalled() {\n+        boolean[] called = new boolean[1];\n+        Box r = map.computeIfAbsent(k1a, k -> { called[0] = true; return null; });\n+\n+        assertSame(r, v1a);\n+        assertFalse(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ computeIfAbsent\n+    @Test\n+    public void testComputeIfAbsentNullReturn() {\n+        boolean[] called = new boolean[1];\n+        Box newKey = new Box(k1a);\n+        Box r = map.computeIfAbsent(newKey, k -> { called[0] = true; return null; });\n+\n+        assertNull(r);\n+        assertTrue(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ computeIfPresent\n+    @Test\n+    public void testComputeIfPresentIsCalled() {\n+        boolean[] called = new boolean[1];\n+        Box newVal = new Box(v1a);\n+        Box r = map.computeIfPresent(k1a, (k, v) -> { called[0] = true; return newVal; });\n+\n+        assertSame(r, newVal);\n+        assertTrue(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, newVal),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ computeIfPresent\n+    @Test\n+    public void testComputeIfPresentNotCalled() {\n+        boolean[] called = new boolean[1];\n+        Box r = map.computeIfPresent(new Box(k1a), (k, v) -> { called[0] = true; return null; });\n+\n+        assertNull(r);\n+        assertFalse(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ computeIfPresent\n+    @Test\n+    public void testComputeIfPresentNullReturn() {\n+        boolean[] called = new boolean[1];\n+        Box r = map.computeIfPresent(k1a, (k, v) -> { called[0] = true; return null; });\n+\n+        assertNull(r);\n+        assertTrue(called[0]);\n+        checkEntries(map.entrySet(), entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ merge\n+    @Test\n+    public void testMergeAbsent() {\n+        boolean[] called = new boolean[1];\n+        Box newKey = new Box(k1a);\n+        Box newVal = new Box(v1a);\n+        Box r = map.merge(newKey, newVal, (v1, v2) -> { called[0] = true; return newVal; });\n+\n+        assertSame(r, newVal);\n+        assertFalse(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, v1a),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2),\n+                                     entry(newKey, newVal));\n+    }\n+\n+    \/\/ merge\n+    @Test\n+    public void testMergePresent() {\n+        boolean[] called = new boolean[1];\n+        Box val2 = new Box(47);\n+        Box[] mergedVal = new Box[1];\n+        Box r = map.merge(k1a, val2, (v1, v2) -> {\n+            called[0] = true;\n+            mergedVal[0] = new Box(v1.i + v2.i);\n+            return mergedVal[0];\n+        });\n+\n+        assertSame(r, mergedVal[0]);\n+        assertTrue(called[0]);\n+        checkEntries(map.entrySet(), entry(k1a, mergedVal[0]),\n+                                     entry(k1b, v1b),\n+                                     entry(k2, v2));\n+    }\n+\n+    \/\/ forEach\n+    @Test\n+    public void testForEach() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<Map.Entry<Box, Box>> entries = new ArrayList<>();\n+        map.forEach((k, v) -> entries.add(entry(k, v)));\n+        checkEntries(entries, entry(k1a, v1a),\n+                              entry(k1b, v1b),\n+                              entry(k2, v2));\n+    }\n+\n+    \/\/ replaceAll\n+    @Test\n+    public void testReplaceAll() {\n+        List<Map.Entry<Box, Box>> replacements = new ArrayList<>();\n+\n+        map.replaceAll((k, v) -> {\n+            Box v1 = new Box(v);\n+            replacements.add(entry(k, v1));\n+            return v1;\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var replacementArray = (Map.Entry<Box, Box>[]) replacements.toArray(Map.Entry[]::new);\n+        checkEntries(map.entrySet(), replacementArray);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/IdentityHashMap\/Basic.java","additions":678,"deletions":0,"binary":false,"changes":678,"status":"added"}]}