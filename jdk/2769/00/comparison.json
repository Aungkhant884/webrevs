{"files":[{"patch":"@@ -398,1 +398,1 @@\n-  \/\/ Check if the hashtable needs to be resized\n+  \/\/ Decide whether to resize, and compute desired new size if so.\n@@ -400,5 +400,6 @@\n-    \/\/ Grow table, double the size\n-    size *= 2;\n-    if (size > _max_size) {\n-      \/\/ Too big, don't resize\n-      return NULL;\n+    \/\/ Compute new size.\n+    size_t needed = _table->_entries \/ _grow_load_factor;\n+    if (needed < _max_size) {\n+      size = round_up_power_of_2(needed);\n+    } else {\n+      size = _max_size;\n@@ -407,5 +408,6 @@\n-    \/\/ Shrink table, half the size\n-    size \/= 2;\n-    if (size < _min_size) {\n-      \/\/ Too small, don't resize\n-      return NULL;\n+    \/\/ Compute new size.\n+    size_t needed = _table->_entries \/ _shrink_load_factor;\n+    if (needed > _min_size) {\n+      size = round_down_power_of_2(needed);\n+    } else {\n+      size = _min_size;\n@@ -413,6 +415,9 @@\n-  } else if (StringDeduplicationResizeALot) {\n-    \/\/ Force grow\n-    size *= 2;\n-    if (size > _max_size) {\n-      \/\/ Too big, force shrink instead\n-      size \/= 4;\n+  }\n+  \/\/ If no change in size needed (and not forcing resize) then done.\n+  if (size == _table->_size) {\n+    if (!StringDeduplicationResizeALot) {\n+      return NULL;              \/\/ Don't resize.\n+    } else if (size < _max_size) {\n+      size *= 2;                \/\/ Force grow, but not past _max_size.\n+    } else {\n+      size \/= 2;                \/\/ Can't force grow, so force shrink instead.\n@@ -420,3 +425,0 @@\n-  } else {\n-    \/\/ Resize not needed\n-    return NULL;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupTable.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,3 @@\n+    private static final int LargeNumberOfStrings = 10000;\n+    private static final int SmallNumberOfStrings = 10;\n+\n@@ -72,0 +75,1 @@\n+        List<List<String>> newStrings = new ArrayList<List<String>>();\n@@ -73,0 +77,3 @@\n+            \/\/ Create some more strings for every collection, to ensure\n+            \/\/ there will be deduplication work that will be reported.\n+            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n@@ -83,0 +90,1 @@\n+        List<List<String>> newStrings = new ArrayList<List<String>>();\n@@ -84,0 +92,3 @@\n+            \/\/ Create some more strings for every collection, to ensure\n+            \/\/ there will be deduplication work that will be reported.\n+            newStrings.add(createStrings(SmallNumberOfStrings, SmallNumberOfStrings));\n@@ -321,3 +332,0 @@\n-    private static final int LargeNumberOfStrings = 10000;\n-    private static final int SmallNumberOfStrings = 10;\n-\n@@ -379,1 +387,5 @@\n-        output.shouldNotContain(\"Rehash Count: 0\");\n+        \/\/ Ensure there have been some rehashes.  Can't check for never\n+        \/\/ being zero, because the first collection might trigger a resize,\n+        \/\/ which suppresses rehash.  But as written, some collections should\n+        \/\/ not lead to a resize, and those will do a rehash.\n+        output.shouldMatch(\".* Rehash Count: [1-9].*\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestStringDeduplicationTools.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"}]}