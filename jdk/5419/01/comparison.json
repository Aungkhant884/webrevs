{"files":[{"patch":"@@ -1755,2 +1755,0 @@\n-  _evac_failure_regions.initialize(max_reserved_regions());\n-\n@@ -2775,4 +2773,0 @@\n-  \/\/ Inject evacuation failure tag into type if needed.\n-  if (evacuation_failed()) {\n-    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n-  }\n@@ -2887,1 +2881,1 @@\n-  G1YoungCollector collector(gc_cause(), target_pause_time_ms, &_evac_failure_regions);\n+  G1YoungCollector collector(gc_cause(), target_pause_time_ms);\n@@ -3394,2 +3388,2 @@\n-void G1CollectedHeap::update_used_after_gc() {\n-  if (evacuation_failed()) {\n+void G1CollectedHeap::update_used_after_gc(bool evacuation_failed) {\n+  if (evacuation_failed) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -818,2 +817,0 @@\n-  G1EvacFailureRegions _evac_failure_regions;\n-\n@@ -1037,3 +1034,0 @@\n-  \/\/ True iff an evacuation has failed in the most-recent collection.\n-  inline bool evacuation_failed() const;\n-\n@@ -1292,1 +1286,1 @@\n-  void update_used_after_gc();\n+  void update_used_after_gc(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -199,4 +199,0 @@\n-bool G1CollectedHeap::evacuation_failed() const {\n-  return _evac_failure_regions.num_regions_failed_evacuation() > 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -33,1 +33,0 @@\n-\n@@ -35,2 +34,4 @@\n-  _regions_failed_evacuation(mtGC) {\n-}\n+  _regions_failed_evacuation(mtGC),\n+  _evac_failure_regions(nullptr),\n+  _evac_failure_regions_cur_length(0),\n+  _max_regions(0) { }\n@@ -39,1 +40,1 @@\n-  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+  assert(_evac_failure_regions == nullptr, \"not cleaned up\");\n@@ -42,1 +43,1 @@\n-void G1EvacFailureRegions::initialize(uint max_regions) {\n+void G1EvacFailureRegions::pre_collection(uint max_regions) {\n@@ -49,0 +50,7 @@\n+void G1EvacFailureRegions::post_collection() {\n+  _regions_failed_evacuation.resize(0);\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+  _evac_failure_regions = nullptr;\n+  _max_regions = 0; \/\/ To have any record() attempt fail in the future.\n+}\n+\n@@ -59,5 +67,0 @@\n-void G1EvacFailureRegions::reset() {\n-  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n-  _regions_failed_evacuation.clear();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  void initialize(uint max_regions);\n@@ -52,1 +51,4 @@\n-  void reset();\n+  \/\/ Sets up the bitmap and failed regions array for addition.\n+  void pre_collection(uint max_regions);\n+  \/\/ Drops memory for internal data structures, but keep counts.\n+  void post_collection();\n@@ -63,0 +65,4 @@\n+  bool evacuation_failed() const {\n+    return num_regions_failed_evacuation() > 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-double G1GCPhaseTimes::print_post_evacuate_collection_set() const {\n+double G1GCPhaseTimes::print_post_evacuate_collection_set(bool evacuation_failed) const {\n@@ -484,1 +484,1 @@\n-  if (G1CollectedHeap::heap()->evacuation_failed()) {\n+  if (evacuation_failed) {\n@@ -490,1 +490,1 @@\n-  if (G1CollectedHeap::heap()->evacuation_failed()) {\n+  if (evacuation_failed) {\n@@ -529,1 +529,1 @@\n-void G1GCPhaseTimes::print() {\n+void G1GCPhaseTimes::print(bool evacuation_failed) {\n@@ -541,1 +541,1 @@\n-  accounted_ms += print_post_evacuate_collection_set();\n+  accounted_ms += print_post_evacuate_collection_set(evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  double print_post_evacuate_collection_set() const;\n+  double print_post_evacuate_collection_set(bool evacuation_failed) const;\n@@ -237,1 +237,1 @@\n-  void print();\n+  void print(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool update_stats) {\n@@ -641,2 +641,0 @@\n-  bool update_stats = should_update_gc_stats();\n-\n@@ -671,1 +669,1 @@\n-  record_pause(this_pause, start_time_sec, end_time_sec);\n+  record_pause(this_pause, start_time_sec, end_time_sec, update_stats);\n@@ -894,1 +892,1 @@\n-void G1Policy::record_young_gc_pause_end() {\n+void G1Policy::record_young_gc_pause_end(bool evacuation_failed) {\n@@ -896,1 +894,1 @@\n-  phase_times()->print();\n+  phase_times()->print(evacuation_failed);\n@@ -1179,6 +1177,0 @@\n-bool G1Policy::should_update_gc_stats() {\n-  \/\/ Evacuation failures skew the timing too much to be considered for statistics updates.\n-  \/\/ We make the assumption that these are rare.\n-  return !_g1h->evacuation_failed();\n-}\n-\n@@ -1202,1 +1194,2 @@\n-                            double end) {\n+                            double end,\n+                            bool should_update_gc_pause_time_ratios) {\n@@ -1208,1 +1201,1 @@\n-  if (should_update_gc_stats()) {\n+  if (should_update_gc_pause_time_ratios) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -271,4 +271,7 @@\n-  \/\/ Record the given STW pause with the given start and end times (in s).\n-  void record_pause(G1GCPauseType gc_type, double start, double end);\n-\n-  bool should_update_gc_stats();\n+  \/\/ Record the given STW pause with the given start and end times (in s). Optionally\n+  \/\/ update pause time ratios - in some situations (evacuation failure) we do not want\n+  \/\/ to do this since timings of these garbage collections are very skewed.\n+  void record_pause(G1GCPauseType gc_type,\n+                    double start,\n+                    double end,\n+                    bool should_update_gc_pause_time_ratios = true);\n@@ -306,1 +309,1 @@\n-  void record_young_gc_pause_end();\n+  void record_young_gc_pause_end(bool evacuation_failed);\n@@ -316,1 +319,1 @@\n-  void record_young_collection_end(bool concurrent_operation_is_full_mark);\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool update_stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -107,0 +107,2 @@\n+  G1YoungCollector* _collector;\n+\n@@ -121,1 +123,1 @@\n-             G1CollectedHeap::heap()->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+             _collector->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n@@ -126,1 +128,2 @@\n-  G1YoungGCTraceTime(GCCause::Cause cause) :\n+  G1YoungGCTraceTime(G1YoungCollector* collector, GCCause::Cause cause) :\n+    _collector(collector),\n@@ -130,1 +133,1 @@\n-    _pause_type(G1CollectedHeap::heap()->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n+    _pause_type(_collector->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n@@ -143,0 +146,2 @@\n+  G1YoungCollector* _collector;\n+\n@@ -144,2 +149,7 @@\n-  G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_start(); }\n-  ~G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(); }\n+  G1YoungGCNotifyPauseMark(G1YoungCollector* collector) : _collector(collector) {\n+    G1CollectedHeap::heap()->policy()->record_young_gc_pause_start();\n+  }\n+\n+  ~G1YoungGCNotifyPauseMark() {\n+    G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(_collector->evacuation_failed());\n+  }\n@@ -173,0 +183,1 @@\n+  G1YoungCollector* _collector;\n@@ -187,1 +198,1 @@\n-  G1YoungGCVerifierMark() : _type(young_collection_verify_type()) {\n+  G1YoungGCVerifierMark(G1YoungCollector* collector) : _collector(collector), _type(young_collection_verify_type()) {\n@@ -192,1 +203,6 @@\n-    G1CollectedHeap::heap()->verify_after_young_collection(_type);\n+    \/\/ Inject evacuation failure tag into type if needed.\n+    G1HeapVerifier::G1VerifyType type = _type;\n+    if (_collector->evacuation_failed()) {\n+      type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+    }\n+    G1CollectedHeap::heap()->verify_after_young_collection(type);\n@@ -501,1 +517,1 @@\n-  _evac_failure_regions->reset();\n+   _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n@@ -797,1 +813,1 @@\n-  while (!_g1h->evacuation_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_failed() && collection_set()->optional_region_length() > 0) {\n@@ -958,1 +974,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, _evac_failure_regions);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, &_evac_failure_regions);\n@@ -968,1 +984,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info, _evac_failure_regions);\n+    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info, &_evac_failure_regions);\n@@ -996,0 +1012,2 @@\n+  _evac_failure_regions.post_collection();\n+\n@@ -1014,0 +1032,4 @@\n+bool G1YoungCollector::evacuation_failed() const {\n+  return _evac_failure_regions.evacuation_failed();\n+}\n+\n@@ -1028,2 +1050,1 @@\n-                                   double target_pause_time_ms,\n-                                   G1EvacFailureRegions* evac_failure_regions) :\n+                                   double target_pause_time_ms) :\n@@ -1034,1 +1055,1 @@\n-  _evac_failure_regions(evac_failure_regions)\n+  _evac_failure_regions()\n@@ -1045,1 +1066,1 @@\n-  G1YoungGCTraceTime tm(_gc_cause);\n+  G1YoungGCTraceTime tm(this, _gc_cause);\n@@ -1057,1 +1078,1 @@\n-  G1YoungGCNotifyPauseMark npm;\n+  G1YoungGCNotifyPauseMark npm(this);\n@@ -1068,1 +1089,1 @@\n-  G1YoungGCVerifierMark vm;\n+  G1YoungGCVerifierMark vm(this);\n@@ -1087,1 +1108,2 @@\n-                                              _evac_failure_regions);\n+                                              &_evac_failure_regions);\n+\n@@ -1107,1 +1129,3 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark);\n+    \/\/ Evacuation failures skew the timing too much to be considered for some statistics updates.\n+    \/\/ We make the assumption that these are rare.\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, !evacuation_failed());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -59,0 +60,3 @@\n+  friend class G1YoungGCNotifyPauseMark;\n+  friend class G1YoungGCTraceTime;\n+  friend class G1YoungGCVerifierMark;\n@@ -85,0 +89,3 @@\n+  \/\/ Evacuation failure tracking.\n+  G1EvacFailureRegions _evac_failure_regions;\n+\n@@ -127,1 +134,2 @@\n-  G1EvacFailureRegions* _evac_failure_regions;\n+  \/\/ True iff an evacuation has failed in the most-recent collection.\n+  bool evacuation_failed() const;\n@@ -139,2 +147,1 @@\n-                   double target_pause_time_ms,\n-                   G1EvacFailureRegions* evac_failure_regions);\n+                   double target_pause_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  add_serial_task(new RecalculateUsedTask());\n+  add_serial_task(new RecalculateUsedTask(evac_failure_regions->evacuation_failed()));\n@@ -51,1 +51,1 @@\n-  if (RemoveSelfForwardPtrsTask::should_execute()) {\n+  if (evac_failure_regions->evacuation_failed()) {\n@@ -67,1 +67,1 @@\n-  return G1CollectedHeap::heap()->evacuation_failed() ? 1.0 : AlmostNoWork;\n+  return _evacuation_failed ? 1.0 : AlmostNoWork;\n@@ -71,1 +71,1 @@\n-  G1CollectedHeap::heap()->update_used_after_gc();\n+  G1CollectedHeap::heap()->update_used_after_gc(_evacuation_failed);\n@@ -100,4 +100,0 @@\n-bool G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::should_execute() {\n-  return G1CollectedHeap::heap()->evacuation_failed();\n-}\n-\n@@ -112,1 +108,0 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -119,1 +114,1 @@\n-  assert(should_execute(), \"Should not call this if not executed\");\n+  assert(_evac_failure_regions->evacuation_failed(), \"Should not call this if not executed\");\n@@ -274,4 +269,0 @@\n-bool G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::should_execute() {\n-  return G1CollectedHeap::heap()->evacuation_failed();\n-}\n-\n@@ -286,1 +277,0 @@\n-  assert(should_execute(), \"Should not call this if not executed\");\n@@ -638,1 +628,1 @@\n-  if (RestorePreservedMarksTask::should_execute()) {\n+  if (evac_failure_regions->evacuation_failed()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  bool _evacuation_failed;\n+\n@@ -68,1 +70,3 @@\n-  RecalculateUsedTask() : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed) { }\n+  RecalculateUsedTask(bool evacuation_failed) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed),\n+    _evacuation_failed(evacuation_failed) { }\n@@ -92,2 +96,0 @@\n-  static bool should_execute();\n-\n@@ -172,2 +174,0 @@\n-  static bool should_execute();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}