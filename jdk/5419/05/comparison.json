{"files":[{"patch":"@@ -1755,2 +1755,0 @@\n-  _evac_failure_regions.initialize(max_reserved_regions());\n-\n@@ -2775,4 +2773,0 @@\n-  \/\/ Inject evacuation failure tag into type if needed.\n-  if (evacuation_failed()) {\n-    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n-  }\n@@ -2887,1 +2881,1 @@\n-  G1YoungCollector collector(gc_cause(), target_pause_time_ms, &_evac_failure_regions);\n+  G1YoungCollector collector(gc_cause(), target_pause_time_ms);\n@@ -3395,2 +3389,2 @@\n-void G1CollectedHeap::update_used_after_gc() {\n-  if (evacuation_failed()) {\n+void G1CollectedHeap::update_used_after_gc(bool evacuation_failed) {\n+  if (evacuation_failed) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -819,2 +818,0 @@\n-  G1EvacFailureRegions _evac_failure_regions;\n-\n@@ -1038,3 +1035,0 @@\n-  \/\/ True iff an evacuation has failed in the most-recent collection.\n-  inline bool evacuation_failed() const;\n-\n@@ -1286,1 +1280,1 @@\n-  void update_used_after_gc();\n+  void update_used_after_gc(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -204,4 +204,0 @@\n-bool G1CollectedHeap::evacuation_failed() const {\n-  return _evac_failure_regions.num_regions_failed_evacuation() > 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -33,1 +33,0 @@\n-\n@@ -35,2 +34,4 @@\n-  _regions_failed_evacuation(mtGC) {\n-}\n+  _regions_failed_evacuation(mtGC),\n+  _evac_failure_regions(nullptr),\n+  _evac_failure_regions_cur_length(0),\n+  _max_regions(0) { }\n@@ -39,1 +40,1 @@\n-  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+  assert(_evac_failure_regions == nullptr, \"not cleaned up\");\n@@ -42,1 +43,1 @@\n-void G1EvacFailureRegions::initialize(uint max_regions) {\n+void G1EvacFailureRegions::pre_collection(uint max_regions) {\n@@ -49,0 +50,7 @@\n+void G1EvacFailureRegions::post_collection() {\n+  _regions_failed_evacuation.resize(0);\n+  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n+  _evac_failure_regions = nullptr;\n+  _max_regions = 0; \/\/ To have any record() attempt fail in the future.\n+}\n+\n@@ -59,5 +67,0 @@\n-void G1EvacFailureRegions::reset() {\n-  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n-  _regions_failed_evacuation.clear();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  void initialize(uint max_regions);\n@@ -52,1 +51,4 @@\n-  void reset();\n+  \/\/ Sets up the bitmap and failed regions array for addition.\n+  void pre_collection(uint max_regions);\n+  \/\/ Drops memory for internal data structures, but keep counts.\n+  void post_collection();\n@@ -63,0 +65,4 @@\n+  bool evacuation_failed() const {\n+    return num_regions_failed_evacuation() > 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-double G1GCPhaseTimes::print_post_evacuate_collection_set() const {\n+double G1GCPhaseTimes::print_post_evacuate_collection_set(bool evacuation_failed) const {\n@@ -484,1 +484,1 @@\n-  if (G1CollectedHeap::heap()->evacuation_failed()) {\n+  if (evacuation_failed) {\n@@ -490,1 +490,1 @@\n-  if (G1CollectedHeap::heap()->evacuation_failed()) {\n+  if (evacuation_failed) {\n@@ -529,1 +529,1 @@\n-void G1GCPhaseTimes::print() {\n+void G1GCPhaseTimes::print(bool evacuation_failed) {\n@@ -541,1 +541,1 @@\n-  accounted_ms += print_post_evacuate_collection_set();\n+  accounted_ms += print_post_evacuate_collection_set(evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  double print_post_evacuate_collection_set() const;\n+  double print_post_evacuate_collection_set(bool evacuation_failed) const;\n@@ -237,1 +237,1 @@\n-  void print();\n+  void print(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+class G1EvacFailureRegions;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool evacuation_failure) {\n@@ -641,2 +641,0 @@\n-  bool update_stats = should_update_gc_stats();\n-\n@@ -657,0 +655,4 @@\n+  \/\/ Evacuation failures skew the timing too much to be considered for some statistics updates.\n+  \/\/ We make the assumption that these are rare.\n+  bool update_stats = !evacuation_failure;\n+\n@@ -671,1 +673,1 @@\n-  record_pause(this_pause, start_time_sec, end_time_sec);\n+  record_pause(this_pause, start_time_sec, end_time_sec, evacuation_failure);\n@@ -894,1 +896,1 @@\n-void G1Policy::record_young_gc_pause_end() {\n+void G1Policy::record_young_gc_pause_end(bool evacuation_failed) {\n@@ -896,1 +898,1 @@\n-  phase_times()->print();\n+  phase_times()->print(evacuation_failed);\n@@ -1179,6 +1181,0 @@\n-bool G1Policy::should_update_gc_stats() {\n-  \/\/ Evacuation failures skew the timing too much to be considered for statistics updates.\n-  \/\/ We make the assumption that these are rare.\n-  return !_g1h->evacuation_failed();\n-}\n-\n@@ -1202,1 +1198,2 @@\n-                            double end) {\n+                            double end,\n+                            bool evacuation_failure) {\n@@ -1208,1 +1205,1 @@\n-  if (should_update_gc_stats()) {\n+  if (!evacuation_failure) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -272,3 +272,4 @@\n-  void record_pause(G1GCPauseType gc_type, double start, double end);\n-\n-  bool should_update_gc_stats();\n+  void record_pause(G1GCPauseType gc_type,\n+                    double start,\n+                    double end,\n+                    bool evacuation_failure = false);\n@@ -306,1 +307,1 @@\n-  void record_young_gc_pause_end();\n+  void record_young_gc_pause_end(bool evacuation_failed);\n@@ -316,1 +317,1 @@\n-  void record_young_collection_end(bool concurrent_operation_is_full_mark);\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool evacuation_failure);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+  G1YoungCollector* _collector;\n+\n@@ -122,1 +124,1 @@\n-             G1CollectedHeap::heap()->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+             _collector->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n@@ -127,1 +129,2 @@\n-  G1YoungGCTraceTime(GCCause::Cause cause) :\n+  G1YoungGCTraceTime(G1YoungCollector* collector, GCCause::Cause cause) :\n+    _collector(collector),\n@@ -131,1 +134,1 @@\n-    _pause_type(G1CollectedHeap::heap()->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n+    _pause_type(_collector->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n@@ -144,0 +147,2 @@\n+  G1YoungCollector* _collector;\n+\n@@ -145,2 +150,7 @@\n-  G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_start(); }\n-  ~G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(); }\n+  G1YoungGCNotifyPauseMark(G1YoungCollector* collector) : _collector(collector) {\n+    G1CollectedHeap::heap()->policy()->record_young_gc_pause_start();\n+  }\n+\n+  ~G1YoungGCNotifyPauseMark() {\n+    G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(_collector->evacuation_failed());\n+  }\n@@ -174,0 +184,1 @@\n+  G1YoungCollector* _collector;\n@@ -188,1 +199,1 @@\n-  G1YoungGCVerifierMark() : _type(young_collection_verify_type()) {\n+  G1YoungGCVerifierMark(G1YoungCollector* collector) : _collector(collector), _type(young_collection_verify_type()) {\n@@ -193,1 +204,6 @@\n-    G1CollectedHeap::heap()->verify_after_young_collection(_type);\n+    \/\/ Inject evacuation failure tag into type if needed.\n+    G1HeapVerifier::G1VerifyType type = _type;\n+    if (_collector->evacuation_failed()) {\n+      type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+    }\n+    G1CollectedHeap::heap()->verify_after_young_collection(type);\n@@ -502,1 +518,1 @@\n-  _evac_failure_regions->reset();\n+   _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n@@ -798,1 +814,1 @@\n-  while (!_g1h->evacuation_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_failed() && collection_set()->optional_region_length() > 0) {\n@@ -987,1 +1003,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, _evac_failure_regions);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, &_evac_failure_regions);\n@@ -997,1 +1013,1 @@\n-    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info, _evac_failure_regions);\n+    G1PostEvacuateCollectionSetCleanupTask2 cl(per_thread_states, evacuation_info, &_evac_failure_regions);\n@@ -1025,0 +1041,2 @@\n+  _evac_failure_regions.post_collection();\n+\n@@ -1043,0 +1061,4 @@\n+bool G1YoungCollector::evacuation_failed() const {\n+  return _evac_failure_regions.evacuation_failed();\n+}\n+\n@@ -1057,2 +1079,1 @@\n-                                   double target_pause_time_ms,\n-                                   G1EvacFailureRegions* evac_failure_regions) :\n+                                   double target_pause_time_ms) :\n@@ -1063,1 +1084,1 @@\n-  _evac_failure_regions(evac_failure_regions)\n+  _evac_failure_regions()\n@@ -1074,1 +1095,1 @@\n-  G1YoungGCTraceTime tm(_gc_cause);\n+  G1YoungGCTraceTime tm(this, _gc_cause);\n@@ -1086,1 +1107,1 @@\n-  G1YoungGCNotifyPauseMark npm;\n+  G1YoungGCNotifyPauseMark npm(this);\n@@ -1097,1 +1118,1 @@\n-  G1YoungGCVerifierMark vm;\n+  G1YoungGCVerifierMark vm(this);\n@@ -1116,1 +1137,2 @@\n-                                              _evac_failure_regions);\n+                                              &_evac_failure_regions);\n+\n@@ -1136,1 +1158,1 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark);\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_failed());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n@@ -59,0 +60,3 @@\n+  friend class G1YoungGCNotifyPauseMark;\n+  friend class G1YoungGCTraceTime;\n+  friend class G1YoungGCVerifierMark;\n@@ -85,0 +89,3 @@\n+  \/\/ Evacuation failure tracking.\n+  G1EvacFailureRegions _evac_failure_regions;\n+\n@@ -127,1 +134,2 @@\n-  G1EvacFailureRegions* _evac_failure_regions;\n+  \/\/ True iff an evacuation has failed in the most-recent collection.\n+  bool evacuation_failed() const;\n@@ -138,2 +146,1 @@\n-                   double target_pause_time_ms,\n-                   G1EvacFailureRegions* evac_failure_regions);\n+                   double target_pause_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  bool _evacuation_failed;\n+\n@@ -57,1 +59,1 @@\n-  RecalculateUsedTask() : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed) { }\n+  RecalculateUsedTask(bool evacuation_failed) : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed), _evacuation_failed(evacuation_failed) { }\n@@ -61,1 +63,1 @@\n-    return G1CollectedHeap::heap()->evacuation_failed() ? 1.0 : AlmostNoWork;\n+    return _evacuation_failed ? 1.0 : AlmostNoWork;\n@@ -64,1 +66,1 @@\n-  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(); }\n+  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(_evacuation_failed); }\n@@ -114,4 +116,0 @@\n-  static bool should_execute() {\n-    return G1CollectedHeap::heap()->evacuation_failed();\n-  }\n-\n@@ -119,1 +117,1 @@\n-    assert(should_execute(), \"Should not call this if not executed\");\n+    assert(_evac_failure_regions->evacuation_failed(), \"Should not call this if not executed\");\n@@ -132,0 +130,2 @@\n+  bool evacuation_failed = evac_failure_regions->evacuation_failed();\n+\n@@ -133,1 +133,1 @@\n-  add_serial_task(new RecalculateUsedTask());\n+  add_serial_task(new RecalculateUsedTask(evacuation_failed));\n@@ -137,1 +137,1 @@\n-  if (RemoveSelfForwardPtrsTask::should_execute()) {\n+  if (evacuation_failed) {\n@@ -321,2 +321,0 @@\n-  static bool should_execute() { return G1CollectedHeap::heap()->evacuation_failed(); }\n-\n@@ -324,1 +322,0 @@\n-    assert(should_execute(), \"Should not call this if not executed\");\n@@ -689,1 +686,1 @@\n-  if (RestorePreservedMarksTask::should_execute()) {\n+  if (evac_failure_regions->evacuation_failed()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"}]}