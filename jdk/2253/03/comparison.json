{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -416,9 +417,11 @@\n-    Node* vec_field_ld = LoadNode::make(gvn,\n-                                        ctrl,\n-                                        mem,\n-                                        vec_adr,\n-                                        vec_adr->bottom_type()->is_ptr(),\n-                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                        T_OBJECT,\n-                                        MemNode::unordered);\n-    vec_field_ld = gvn.transform(vec_field_ld);\n+    Node* vec_field_ld;\n+    {\n+      DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP;\n+      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n+      MergeMemNode* local_mem = MergeMemNode::make(mem);\n+      gvn.record_for_igvn(local_mem);\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n+      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n+      vec_field_ld = bs->load_at(access, type);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.incubator.vector.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import java.util.function.IntUnaryOperator;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/*\n+ * @test\n+ * @bug 8260473\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n+ *      -XX:-TieredCompilation -XX:CICompilerCount=1 -XX:+UseZGC -Xbatch -Xmx256m VectorReshapeTest\n+ *\/\n+\n+public class VectorReshapeTest {\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+    static final int NUM_ITER = 200 * INVOC_COUNT;\n+\n+    static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Float> fspec128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Long> lspec128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Double> dspec128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Byte> bspec128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Short> sspec128 = ShortVector.SPECIES_128;\n+\n+    public static void main(String[] args) {\n+        IntFunction<byte[]> makeArray = size->{\n+            byte[] array = new byte[size];\n+            for(int x = 0; x < size; x++) {\n+                array[x] = (byte) x;\n+            }\n+            return array;\n+        };\n+\n+        testRebracket128(makeArray);\n+    }\n+\n+    static\n+    void checkPartialResult(VectorSpecies<?> a, VectorSpecies<?> b,\n+                            byte[] input, byte[] output, byte[] expected,\n+                            int part, int origin) {\n+        if (Arrays.equals(expected, output)) {\n+            return;\n+        }\n+        int block;\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+\n+        System.out.println(\"input:  \"+Arrays.toString(input));\n+        System.out.println(\"Failing with \"+a+\"->\"+b+\n+                           \" (reinterpret)\"+\n+                           \", block=\" + block +\n+                           \", part=\" + part +\n+                           \", origin=\" + origin);\n+        System.out.println(\"expect: \"+Arrays.toString(expected));\n+        System.out.println(\"output: \"+Arrays.toString(output));\n+        \/\/ Assert.assertEquals(expected, output);\n+        assert(expected.equals(output)); \/\/ SRDM\n+        try {\n+            Thread.sleep( 0);\n+        } catch (Exception e) {}\n+        Thread.dumpStack();\n+        System.exit(-1);\n+    }\n+\n+    @ForceInline\n+    static <E,F>\n+    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n+        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        int block;\n+        assert(input.length == output.length);\n+\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+        if (false)\n+            System.out.println(\"testing \"+a+\"->\"+b+\n+                    (false?\" (lanewise)\":\" (reinterpret)\")+\n+                    \", block=\" + block);\n+        byte[] expected;\n+        int origin;\n+\n+        int part = 0;\n+        Vector<F> bv = av.reinterpretShape(b, part);\n+        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+        \/\/ in-place copy, no resize\n+        expected = input;\n+        origin = 0;\n+        checkPartialResult(a, b, input, output, expected,\n+                part, origin);\n+\n+    }\n+\n+    \/\/ TODO Auto-generated method stub\n+    static void testRebracket128(IntFunction<byte[]> fa) {\n+        byte[] barr = fa.apply(128\/Byte.SIZE);\n+        byte[] bout = new byte[barr.length];\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            testVectorRebracket(bspec128, bspec128, barr, bout);\n+            testVectorRebracket(bspec128, sspec128, barr, bout);\n+            testVectorRebracket(bspec128, ispec128, barr, bout);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReshapeTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}