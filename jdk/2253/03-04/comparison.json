{"files":[{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.incubator.vector.*;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import java.util.function.IntUnaryOperator;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/*\n+ * @test\n+ * @bug 8260473\n+ * @requires vm.gc.Z\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n+ *      -XX:-TieredCompilation -XX:CICompilerCount=1 -XX:+UseZGC -Xbatch -Xmx256m VectorRebracket128Test\n+ *\/\n+\n+@Test\n+public class VectorRebracket128Test {\n+    static final int INVOC_COUNT = Integer.getInteger(\"jtreg.compiler.vectorapi.vectorrebracket128test.loop-iterations\", 1000);\n+    static final int NUM_ITER = 200 * INVOC_COUNT;\n+\n+    static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Float> fspec128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Long> lspec128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Double> dspec128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Byte> bspec128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Short> sspec128 = ShortVector.SPECIES_128;\n+\n+    static <T> IntFunction<T> withToString(String s, IntFunction<T> f) {\n+        return new IntFunction<T>() {\n+            @Override\n+            public T apply(int v) {\n+                return f.apply(v);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return s;\n+            }\n+        };\n+    }\n+\n+    interface ToByteF {\n+        byte apply(int i);\n+    }\n+\n+    static byte[] fill_byte(int s , ToByteF f) {\n+        return fill_byte(new byte[s], f);\n+    }\n+\n+    static byte[] fill_byte(byte[] a, ToByteF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static final List<IntFunction<byte[]>> BYTE_GENERATORS = List.of(\n+            withToString(\"byte(i)\", (int s) -> {\n+                return fill_byte(s, i -> (byte)(i+1));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] byteUnaryOpProvider() {\n+        return BYTE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n+    static\n+    void checkPartialResult(VectorSpecies<?> a, VectorSpecies<?> b,\n+                            byte[] input, byte[] output, byte[] expected,\n+                            int part, int origin) {\n+        if (Arrays.equals(expected, output)) {\n+            return;\n+        }\n+        int block;\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+\n+        System.out.println(\"input:  \"+Arrays.toString(input));\n+        System.out.println(\"Failing with \"+a+\"->\"+b+\n+                           \" (reinterpret)\"+\n+                           \", block=\" + block +\n+                           \", part=\" + part +\n+                           \", origin=\" + origin);\n+        System.out.println(\"expect: \"+Arrays.toString(expected));\n+        System.out.println(\"output: \"+Arrays.toString(output));\n+        Assert.assertEquals(expected, output);\n+    }\n+\n+    @ForceInline\n+    static <E,F>\n+    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n+        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        int block;\n+        assert(input.length == output.length);\n+\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+        if (false)\n+            System.out.println(\"testing \"+a+\"->\"+b+\n+                    (false?\" (lanewise)\":\" (reinterpret)\")+\n+                    \", block=\" + block);\n+        byte[] expected;\n+        int origin;\n+\n+        int part = 0;\n+        Vector<F> bv = av.reinterpretShape(b, part);\n+        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+        \/\/ in-place copy, no resize\n+        expected = input;\n+        origin = 0;\n+        checkPartialResult(a, b, input, output, expected,\n+                part, origin);\n+\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void testRebracket128(IntFunction<byte[]> fa) {\n+        byte[] barr = fa.apply(128\/Byte.SIZE);\n+        byte[] bout = new byte[barr.length];\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            testVectorRebracket(bspec128, bspec128, barr, bout);\n+            testVectorRebracket(bspec128, sspec128, barr, bout);\n+            testVectorRebracket(bspec128, ispec128, barr, bout);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import jdk.incubator.vector.*;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-import java.util.function.IntUnaryOperator;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/*\n- * @test\n- * @bug 8260473\n- * @modules jdk.incubator.vector\n- * @modules java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n- *      -XX:-TieredCompilation -XX:CICompilerCount=1 -XX:+UseZGC -Xbatch -Xmx256m VectorReshapeTest\n- *\/\n-\n-public class VectorReshapeTest {\n-    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n-    static final int NUM_ITER = 200 * INVOC_COUNT;\n-\n-    static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n-    static final VectorSpecies<Float> fspec128 = FloatVector.SPECIES_128;\n-    static final VectorSpecies<Long> lspec128 = LongVector.SPECIES_128;\n-    static final VectorSpecies<Double> dspec128 = DoubleVector.SPECIES_128;\n-    static final VectorSpecies<Byte> bspec128 = ByteVector.SPECIES_128;\n-    static final VectorSpecies<Short> sspec128 = ShortVector.SPECIES_128;\n-\n-    public static void main(String[] args) {\n-        IntFunction<byte[]> makeArray = size->{\n-            byte[] array = new byte[size];\n-            for(int x = 0; x < size; x++) {\n-                array[x] = (byte) x;\n-            }\n-            return array;\n-        };\n-\n-        testRebracket128(makeArray);\n-    }\n-\n-    static\n-    void checkPartialResult(VectorSpecies<?> a, VectorSpecies<?> b,\n-                            byte[] input, byte[] output, byte[] expected,\n-                            int part, int origin) {\n-        if (Arrays.equals(expected, output)) {\n-            return;\n-        }\n-        int block;\n-        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n-\n-        System.out.println(\"input:  \"+Arrays.toString(input));\n-        System.out.println(\"Failing with \"+a+\"->\"+b+\n-                           \" (reinterpret)\"+\n-                           \", block=\" + block +\n-                           \", part=\" + part +\n-                           \", origin=\" + origin);\n-        System.out.println(\"expect: \"+Arrays.toString(expected));\n-        System.out.println(\"output: \"+Arrays.toString(output));\n-        \/\/ Assert.assertEquals(expected, output);\n-        assert(expected.equals(output)); \/\/ SRDM\n-        try {\n-            Thread.sleep( 0);\n-        } catch (Exception e) {}\n-        Thread.dumpStack();\n-        System.exit(-1);\n-    }\n-\n-    @ForceInline\n-    static <E,F>\n-    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n-        int block;\n-        assert(input.length == output.length);\n-\n-        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n-        if (false)\n-            System.out.println(\"testing \"+a+\"->\"+b+\n-                    (false?\" (lanewise)\":\" (reinterpret)\")+\n-                    \", block=\" + block);\n-        byte[] expected;\n-        int origin;\n-\n-        int part = 0;\n-        Vector<F> bv = av.reinterpretShape(b, part);\n-        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n-        \/\/ in-place copy, no resize\n-        expected = input;\n-        origin = 0;\n-        checkPartialResult(a, b, input, output, expected,\n-                part, origin);\n-\n-    }\n-\n-    \/\/ TODO Auto-generated method stub\n-    static void testRebracket128(IntFunction<byte[]> fa) {\n-        byte[] barr = fa.apply(128\/Byte.SIZE);\n-        byte[] bout = new byte[barr.length];\n-        for (int i = 0; i < NUM_ITER; i++) {\n-            testVectorRebracket(bspec128, bspec128, barr, bout);\n-            testVectorRebracket(bspec128, sspec128, barr, bout);\n-            testVectorRebracket(bspec128, ispec128, barr, bout);\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReshapeTest.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"}]}