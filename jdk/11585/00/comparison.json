{"files":[{"patch":"@@ -94,0 +94,2 @@\n+  inline oop cont() const;\n+  template<typename P>\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,12 @@\n-inline oop stackChunkOopDesc::cont() const                { return jdk_internal_vm_StackChunk::cont(as_oop()); }\n+inline oop stackChunkOopDesc::cont() const                { return UseCompressedOops ? cont<narrowOop>() : cont<oop>(); \/* jdk_internal_vm_StackChunk::cont(as_oop()); *\/ }\n+template<typename P>\n+inline oop stackChunkOopDesc::cont() const                {\n+  \/\/ The state of the cont oop is used by ZCollectedHeap::requires_barriers,\n+  \/\/ to determine the age of the stackChunkOopDesc. For that to work, it is\n+  \/\/ only the GC that is allowed to perform a load barrier on the oop.\n+  \/\/ This function is used by non-GC code and therfore create a stack-local\n+  \/\/ copy on the oop and perform the load barrier on that copy instead.\n+  oop obj = jdk_internal_vm_StackChunk::cont_raw<P>(as_oop());\n+  obj = (oop)NativeAccess<>::oop_load(&obj);\n+  return obj;\n+}\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -127,1 +127,2 @@\n-  static inline oop cont(oop chunk);\n+  template<typename P>\n+  static inline oop cont_raw(oop chunk);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,2 +84,3 @@\n-inline oop jdk_internal_vm_StackChunk::cont(oop chunk) {\n-  return chunk->obj_field(_cont_offset);\n+template<typename P>\n+inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n+  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}